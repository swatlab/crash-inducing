52557: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
52557:  * vim: set ts=4 sw=4 et tw=99:
52557:  *
52557:  * ***** BEGIN LICENSE BLOCK *****
52557:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52557:  *
52557:  * The contents of this file are subject to the Mozilla Public License Version
52557:  * 1.1 (the "License"); you may not use this file except in compliance with
52557:  * the License. You may obtain a copy of the License at
52557:  * http://www.mozilla.org/MPL/
52557:  *
52557:  * Software distributed under the License is distributed on an "AS IS" basis,
52557:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52557:  * for the specific language governing rights and limitations under the
52557:  * License.
52557:  *
52557:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
52557:  * May 28, 2008.
52557:  *
52557:  * The Initial Developer of the Original Code is
52557:  *   Brendan Eich <brendan@mozilla.org>
52557:  *
52557:  * Contributor(s):
52557:  *   David Anderson <danderson@mozilla.com>
52557:  *   David Mandelin <dmandelin@mozilla.com>
52557:  *
52557:  * Alternatively, the contents of this file may be used under the terms of
52557:  * either of the GNU General Public License Version 2 or later (the "GPL"),
52557:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52557:  * in which case the provisions of the GPL or the LGPL are applicable instead
52557:  * of those above. If you wish to allow use of your version of this file only
52557:  * under the terms of either the GPL or the LGPL, and not to allow others to
52557:  * use your version of this file under the terms of the MPL, indicate your
52557:  * decision by deleting the provisions above and replace them with the notice
52557:  * and other provisions required by the GPL or the LGPL. If you do not delete
52557:  * the provisions above, a recipient may use your version of this file under
52557:  * the terms of any one of the MPL, the GPL or the LGPL.
52557:  *
52557:  * ***** END LICENSE BLOCK ***** */
52557: 
52557: #include "jscntxt.h"
52557: #include "jsscope.h"
52557: #include "jsobj.h"
52557: #include "jslibmath.h"
52557: #include "jsiter.h"
52557: #include "jsnum.h"
52557: #include "jsxml.h"
52557: #include "jsstaticcheck.h"
52557: #include "jsbool.h"
52557: #include "assembler/assembler/MacroAssemblerCodeRef.h"
52557: #include "jsiter.h"
52557: #include "jstypes.h"
53168: #include "methodjit/Compiler.h"
52608: #include "methodjit/StubCalls.h"
52557: #include "jstracer.h"
53840: 
53840: #include "jsinterpinlines.h"
52557: #include "jspropertycache.h"
52557: #include "jspropertycacheinlines.h"
52557: #include "jsscopeinlines.h"
52557: #include "jsscriptinlines.h"
52557: #include "jsstrinlines.h"
52557: #include "jsobjinlines.h"
52557: #include "jscntxtinlines.h"
52696: #include "jsatominlines.h"
52880: #include "StubCalls-inl.h"
55713: #include "jsfuninlines.h"
60585: #include "jstypedarray.h"
55713: 
52897: #ifdef XP_WIN
52897: # include "jswin.h"
52897: #endif
52557: 
52557: #include "jsautooplen.h"
52557: 
52557: using namespace js;
52557: using namespace js::mjit;
52557: using namespace JSC;
52557: 
52789: void JS_FASTCALL
53473: stubs::BindName(VMFrame &f)
52608: {
52608:     PropertyCacheEntry *entry;
52608: 
52608:     /* Fast-path should have caught this. See comment in interpreter. */
53840:     JS_ASSERT(f.fp()->scopeChain().getParent());
52608: 
52608:     JSAtom *atom;
52608:     JSObject *obj2;
52608:     JSContext *cx = f.cx;
53840:     JSObject *obj = &f.fp()->scopeChain();
52608:     JS_PROPERTY_CACHE(cx).test(cx, f.regs.pc, obj, obj2, entry, atom);
52789:     if (atom) {
52608:         jsid id = ATOM_TO_JSID(atom);
53840:         obj = js_FindIdentifierBase(cx, &f.fp()->scopeChain(), id);
52608:         if (!obj)
52789:             THROW();
52789:     }
52789:     f.regs.sp++;
53023:     f.regs.sp[-1].setObject(*obj);
52608: }
52608: 
56201: void JS_FASTCALL
56201: stubs::BindNameNoCache(VMFrame &f, JSAtom *atom)
56201: {
56201:     JSObject *obj = js_FindIdentifierBase(f.cx, &f.fp()->scopeChain(), ATOM_TO_JSID(atom));
56201:     if (!obj)
56201:         THROW();
56201:     f.regs.sp[0].setObject(*obj);
56201: }
56201: 
52826: JSObject * JS_FASTCALL
53473: stubs::BindGlobalName(VMFrame &f)
52826: {
53840:     return f.fp()->scopeChain().getGlobal();
52826: }
52826: 
54169: template<JSBool strict>
52847: void JS_FASTCALL
53473: stubs::SetName(VMFrame &f, JSAtom *origAtom)
52611: {
52611:     JSContext *cx = f.cx;
52611: 
53203:     Value rval = f.regs.sp[-1];
52611:     Value &lref = f.regs.sp[-2];
52611:     JSObject *obj = ValueToObject(cx, &lref);
52611:     if (!obj)
52611:         THROW();
52611: 
52611:     do {
52611:         PropertyCache *cache = &JS_PROPERTY_CACHE(cx);
52611: 
52611:         /*
52611:          * Probe the property cache, specializing for two important
52611:          * set-property cases. First:
52611:          *
52611:          *   function f(a, b, c) {
52611:          *     var o = {p:a, q:b, r:c};
52611:          *     return o;
52611:          *   }
52611:          *
52611:          * or similar real-world cases, which evolve a newborn native
52611:          * object predicatably through some bounded number of property
52611:          * additions. And second:
52611:          *
52611:          *   o.p = x;
52611:          *
52611:          * in a frequently executed method or loop body, where p will
52611:          * (possibly after the first iteration) always exist in native
52611:          * object o.
52611:          */
52611:         PropertyCacheEntry *entry;
52611:         JSObject *obj2;
52611:         JSAtom *atom;
52611:         if (cache->testForSet(cx, f.regs.pc, obj, &entry, &obj2, &atom)) {
52611:             /*
56605:              * Property cache hit, only partially confirmed by testForSet. We
56605:              * know that the entry applies to regs.pc and that obj's shape
56605:              * matches.
52611:              *
56605:              * The entry predicts either a new property to be added directly to
56605:              * obj by this set, or on an existing "own" property, or on a
56605:              * prototype property that has a setter.
52611:              */
53531:             const Shape *shape = entry->vword.toShape();
53531:             JS_ASSERT_IF(shape->isDataDescriptor(), shape->writable());
53531:             JS_ASSERT_IF(shape->hasSlot(), entry->vcapTag() == 0);
52611: 
52611:             /*
53531:              * Fastest path: check whether obj already has the cached shape and
53531:              * call NATIVE_SET and break to get out of the do-while(0). But we
53531:              * can call NATIVE_SET only for a direct or proto-setter hit.
52611:              */
53531:             if (!entry->adding()) {
52611:                 if (entry->vcapTag() == 0 ||
53537:                     ((obj2 = obj->getProto()) && obj2->shape() == entry->vshape()))
53531:                 {
53531: #ifdef DEBUG
53531:                     if (entry->directHit()) {
53531:                         JS_ASSERT(obj->nativeContains(*shape));
53531:                     } else {
53531:                         JS_ASSERT(obj2->nativeContains(*shape));
53531:                         JS_ASSERT(entry->vcapTag() == 1);
53531:                         JS_ASSERT(entry->kshape != entry->vshape());
53531:                         JS_ASSERT(!shape->hasSlot());
52611:                     }
53531: #endif
52611: 
52611:                     PCMETER(cache->pchits++);
52611:                     PCMETER(cache->setpchits++);
62395:                     NATIVE_SET(cx, obj, shape, entry, strict, &rval);
52611:                     break;
52611:                 }
52611:             } else {
56008:                 JS_ASSERT(obj->isExtensible());
56008: 
53531:                 if (obj->nativeEmpty()) {
56567:                     if (!obj->ensureClassReservedSlotsForEmptyObject(cx))
52611:                         THROW();
52611:                 }
52611: 
52611:                 uint32 slot;
53531:                 if (shape->previous() == obj->lastProperty() &&
52611:                     entry->vshape() == cx->runtime->protoHazardShape &&
53531:                     shape->hasDefaultSetter()) {
53531:                     slot = shape->slot;
53652:                     JS_ASSERT(slot == obj->slotSpan());
53531: 
52611:                     /*
53531:                      * Fast path: adding a plain old property that was once at
53531:                      * the frontier of the property tree, whose slot is next to
53531:                      * claim among the already-allocated slots in obj, where
53531:                      * shape->table has not been created yet.
52611:                      */
52611:                     PCMETER(cache->pchits++);
52611:                     PCMETER(cache->addpchits++);
52611: 
53081:                     if (slot < obj->numSlots()) {
53531:                         JS_ASSERT(obj->getSlot(slot).isUndefined());
52611:                     } else {
53531:                         if (!obj->allocSlot(cx, &slot))
52611:                             THROW();
53531:                         JS_ASSERT(slot == shape->slot);
52611:                     }
52611: 
53531:                     /* Simply extend obj's property tree path with shape! */
53531:                     obj->extend(cx, shape);
52611: 
52611:                     /*
53531:                      * No method change check here because here we are adding a
53531:                      * new property, not updating an existing slot's value that
53531:                      * might contain a method of a branded shape.
52611:                      */
56567:                     obj->setSlot(slot, rval);
52611: 
52611:                     /*
52611:                      * Purge the property cache of the id we may have just
53531:                      * shadowed in obj's scope and proto chains.
52611:                      */
53531:                     js_PurgeScopeChain(cx, obj, shape->id);
52611:                     break;
52611:                 }
53531:             }
52611:             PCMETER(cache->setpcmisses++);
56605: 
56605:             atom = origAtom;
56605:         } else {
56605:             JS_ASSERT(atom);
52611:         }
52611: 
52611:         jsid id = ATOM_TO_JSID(atom);
53245:         if (entry && JS_LIKELY(!obj->getOps()->setProperty)) {
52611:             uintN defineHow;
52611:             JSOp op = JSOp(*f.regs.pc);
52611:             if (op == JSOP_SETMETHOD)
52611:                 defineHow = JSDNP_CACHE_RESULT | JSDNP_SET_METHOD;
52611:             else if (op == JSOP_SETNAME)
52611:                 defineHow = JSDNP_CACHE_RESULT | JSDNP_UNQUALIFIED;
52611:             else
52611:                 defineHow = JSDNP_CACHE_RESULT;
56760:             if (!js_SetPropertyHelper(cx, obj, id, defineHow, &rval, strict))
52611:                 THROW();
52611:         } else {
54169:             if (!obj->setProperty(cx, id, &rval, strict))
52611:                 THROW();
52611:         }
52611:     } while (0);
52611: 
52611:     f.regs.sp[-2] = f.regs.sp[-1];
52611: }
52611: 
54169: template void JS_FASTCALL stubs::SetName<true>(VMFrame &f, JSAtom *origAtom);
54169: template void JS_FASTCALL stubs::SetName<false>(VMFrame &f, JSAtom *origAtom);
54169: 
54169: template<JSBool strict>
52825: void JS_FASTCALL
55503: stubs::SetPropNoCache(VMFrame &f, JSAtom *atom)
55503: {
55503:     JSObject *obj = ValueToObject(f.cx, &f.regs.sp[-2]);
55503:     if (!obj)
55503:         THROW();
55503:     Value rval = f.regs.sp[-1];
55503:     if (!obj->setProperty(f.cx, ATOM_TO_JSID(atom), &f.regs.sp[-1], strict))
55503:         THROW();
55503:     f.regs.sp[-2] = rval;
55503: }
55503: 
55503: template void JS_FASTCALL stubs::SetPropNoCache<true>(VMFrame &f, JSAtom *origAtom);
55503: template void JS_FASTCALL stubs::SetPropNoCache<false>(VMFrame &f, JSAtom *origAtom);
55503: 
55503: template<JSBool strict>
55503: void JS_FASTCALL
57784: stubs::SetGlobalNameNoCache(VMFrame &f, JSAtom *atom)
53511: {
53511:     JSContext *cx = f.cx;
53511: 
53511:     Value rval = f.regs.sp[-1];
53511:     Value &lref = f.regs.sp[-2];
53511:     JSObject *obj = ValueToObject(cx, &lref);
53511:     if (!obj)
53511:         THROW();
53511:     jsid id = ATOM_TO_JSID(atom);
54169:     if (!obj->setProperty(cx, id, &rval, strict))
53511:         THROW();
53511: 
53511:     f.regs.sp[-2] = f.regs.sp[-1];
53511: }
53511: 
57784: template void JS_FASTCALL stubs::SetGlobalNameNoCache<true>(VMFrame &f, JSAtom *atom);
57784: template void JS_FASTCALL stubs::SetGlobalNameNoCache<false>(VMFrame &f, JSAtom *atom);
54169: 
54169: template<JSBool strict>
53511: void JS_FASTCALL
52825: stubs::SetGlobalName(VMFrame &f, JSAtom *atom)
52825: {
54169:     SetName<strict>(f, atom);
52825: }
52825: 
54169: template void JS_FASTCALL stubs::SetGlobalName<true>(VMFrame &f, JSAtom *atom);
54169: template void JS_FASTCALL stubs::SetGlobalName<false>(VMFrame &f, JSAtom *atom);
54169: 
52644: static JSObject *
53004: NameOp(VMFrame &f, JSObject *obj, bool callname = false)
52615: {
52615:     JSContext *cx = f.cx;
52615: 
53531:     const Shape *shape;
52615:     Value rval;
52615: 
52615:     PropertyCacheEntry *entry;
52615:     JSObject *obj2;
52615:     JSAtom *atom;
52615:     JS_PROPERTY_CACHE(cx).test(cx, f.regs.pc, obj, obj2, entry, atom);
52615:     if (!atom) {
52615:         if (entry->vword.isFunObj()) {
52650:             f.regs.sp++;
53023:             f.regs.sp[-1].setObject(entry->vword.toFunObj());
53004:         } else if (entry->vword.isSlot()) {
52615:             uintN slot = entry->vword.toSlot();
52650:             f.regs.sp++;
56567:             f.regs.sp[-1] = obj2->nativeGetSlot(slot);
53004:         } else {
53531:             JS_ASSERT(entry->vword.isShape());
53531:             shape = entry->vword.toShape();
53531:             NATIVE_GET(cx, obj, obj2, shape, JSGET_METHOD_BARRIER, &rval, return NULL);
53004:             f.regs.sp++;
53004:             f.regs.sp[-1] = rval;
52615:         }
52615: 
53004:         /*
53531:          * Push results, the same as below, but with a prop$ hit there
53531:          * is no need to test for the unusual and uncacheable case where
53531:          * the caller determines |this|.
53004:          */
53004: #if DEBUG
53004:         Class *clasp;
53004:         JS_ASSERT(!obj->getParent() ||
53004:                   (clasp = obj->getClass()) == &js_CallClass ||
53004:                   clasp == &js_BlockClass ||
53004:                   clasp == &js_DeclEnvClass);
53004: #endif
53004:         if (callname) {
53004:             f.regs.sp++;
55712:             f.regs.sp[-1].setUndefined();
53004:         }
53004:         return obj;
52615:     }
52615: 
52615:     jsid id;
52615:     id = ATOM_TO_JSID(atom);
52615:     JSProperty *prop;
52615:     if (!js_FindPropertyHelper(cx, id, true, &obj, &obj2, &prop))
52644:         return NULL;
52615:     if (!prop) {
52615:         /* Kludge to allow (typeof foo == "undefined") tests. */
53840:         JSOp op2 = js_GetOpcode(cx, f.fp()->script(), f.regs.pc + JSOP_NAME_LENGTH);
52615:         if (op2 == JSOP_TYPEOF) {
52650:             f.regs.sp++;
52615:             f.regs.sp[-1].setUndefined();
52644:             return obj;
52615:         }
52615:         ReportAtomNotDefined(cx, atom);
52644:         return NULL;
52615:     }
52615: 
52615:     /* Take the slow path if prop was not found in a native object. */
52615:     if (!obj->isNative() || !obj2->isNative()) {
52615:         if (!obj->getProperty(cx, id, &rval))
52644:             return NULL;
52615:     } else {
53531:         shape = (Shape *)prop;
53399:         JSObject *normalized = obj;
53531:         if (normalized->getClass() == &js_WithClass && !shape->hasDefaultGetter())
53531:             normalized = js_UnwrapWithObject(cx, normalized);
53531:         NATIVE_GET(cx, normalized, obj2, shape, JSGET_METHOD_BARRIER, &rval, return NULL);
52615:     }
52615: 
52644:     f.regs.sp++;
52615:     f.regs.sp[-1] = rval;
53004:     if (callname) {
53004:         Class *clasp;
53004:         JSObject *thisp = obj;
53004:         if (!thisp->getParent() ||
53004:             (clasp = thisp->getClass()) == &js_CallClass ||
53004:             clasp == &js_BlockClass ||
53004:             clasp == &js_DeclEnvClass) {
55712:             f.regs.sp++;
55712:             f.regs.sp[-1].setUndefined();
53004:         } else {
53004:             thisp = thisp->thisObject(cx);
53004:             if (!thisp)
53004:                 return NULL;
55712:             f.regs.sp++;
55712:             f.regs.sp[-1].setObject(*thisp);
53004:         }
53004:     }
52644:     return obj;
52615: }
52615: 
52617: void JS_FASTCALL
52819: stubs::Name(VMFrame &f)
52644: {
53840:     if (!NameOp(f, &f.fp()->scopeChain()))
52825:         THROW();
52825: }
52825: 
52825: void JS_FASTCALL
52825: stubs::GetGlobalName(VMFrame &f)
52825: {
53840:     JSObject *globalObj = f.fp()->scopeChain().getGlobal();
52825:     if (!NameOp(f, globalObj))
52644:          THROW();
52644: }
52644: 
52644: void JS_FASTCALL
52693: stubs::GetElem(VMFrame &f)
52693: {
52693:     JSContext *cx = f.cx;
52693:     JSFrameRegs &regs = f.regs;
52693: 
53491:     Value &lref = regs.sp[-2];
53491:     Value &rref = regs.sp[-1];
53491:     if (lref.isString() && rref.isInt32()) {
53491:         JSString *str = lref.toString();
53491:         int32_t i = rref.toInt32();
53219:         if ((size_t)i < str->length()) {
52693:             str = JSString::getUnitString(cx, str, (size_t)i);
52693:             if (!str)
52693:                 THROW();
52693:             f.regs.sp[-2].setString(str);
52693:             return;
52693:         }
53219:     }
52693: 
53491:     JSObject *obj = ValueToObject(cx, &lref);
52694:     if (!obj)
52693:         THROW();
52693: 
53491:     const Value *copyFrom;
53491:     Value rval;
53491:     jsid id;
53491:     if (rref.isInt32()) {
53491:         int32_t i = rref.toInt32();
52693:         if (obj->isDenseArray()) {
53491:             jsuint idx = jsuint(i);
52693: 
52693:             if (idx < obj->getArrayLength() &&
52693:                 idx < obj->getDenseArrayCapacity()) {
52693:                 copyFrom = obj->addressOfDenseArrayElement(idx);
52693:                 if (!copyFrom->isMagic())
52693:                     goto end_getelem;
52693:             }
53491:         } else if (obj->isArguments()) {
53491:             uint32 arg = uint32(i);
52693: 
53446:             if (arg < obj->getArgsInitialLength()) {
55525:                 copyFrom = obj->addressOfArgsElement(arg);
55525:                 if (!copyFrom->isMagic()) {
55525:                     if (JSStackFrame *afp = (JSStackFrame *) obj->getPrivate())
53840:                         copyFrom = &afp->canonicalActualArg(arg);
52693:                     goto end_getelem;
52693:                 }
52693:             }
52693:         }
53491:         if (JS_LIKELY(INT_FITS_IN_JSID(i)))
53491:             id = INT_TO_JSID(i);
53491:         else
53491:             goto intern_big_int;
52693: 
52693:     } else {
58066:         int32_t i;
58066:         if (ValueFitsInInt32(rref, &i) && INT_FITS_IN_JSID(i)) {
58066:             id = INT_TO_JSID(i);
58066:         } else {
53491:           intern_big_int:
53491:             if (!js_InternNonIntElementId(cx, obj, rref, &id))
52693:                 THROW();
52693:         }
58066:     }
52693: 
52693:     if (!obj->getProperty(cx, id, &rval))
52693:         THROW();
52693:     copyFrom = &rval;
52693: 
52693:   end_getelem:
52693:     f.regs.sp[-2] = *copyFrom;
52693: }
52693: 
52723: static inline bool
52723: FetchElementId(VMFrame &f, JSObject *obj, const Value &idval, jsid &id, Value *vp)
52723: {
52723:     int32_t i_;
53341:     if (ValueFitsInInt32(idval, &i_) && INT_FITS_IN_JSID(i_)) {
52723:         id = INT_TO_JSID(i_);
52723:         return true;
52723:     }
52723:     return !!js_InternNonIntElementId(f.cx, obj, idval, &id, vp);
52723: }
52723: 
52693: void JS_FASTCALL
52771: stubs::CallElem(VMFrame &f)
52771: {
52771:     JSContext *cx = f.cx;
52771:     JSFrameRegs &regs = f.regs;
52771: 
55713:     /* Find the object on which to look for |this|'s properties. */
55713:     Value thisv = regs.sp[-2];
55713:     JSObject *thisObj = ValuePropertyBearer(cx, thisv, -2);
55713:     if (!thisObj)
52771:         THROW();
52771: 
55713:     /* Fetch index and convert it to id suitable for use with thisObj. */
52771:     jsid id;
55713:     if (!FetchElementId(f, thisObj, regs.sp[-1], id, &regs.sp[-2]))
52771:         THROW();
52771: 
52771:     /* Get or set the element. */
55713:     if (!js_GetMethod(cx, thisObj, id, JSGET_NO_METHOD_BARRIER, &regs.sp[-2]))
52771:         THROW();
52771: 
52771: #if JS_HAS_NO_SUCH_METHOD
55713:     if (JS_UNLIKELY(regs.sp[-2].isUndefined()) && thisv.isObject()) {
52771:         regs.sp[-2] = regs.sp[-1];
55713:         regs.sp[-1].setObject(*thisObj);
52771:         if (!js_OnUnknownMethod(cx, regs.sp - 2))
52771:             THROW();
52771:     } else
52771: #endif
52771:     {
55713:         regs.sp[-1] = thisv;
52771:     }
52771: }
52771: 
54169: template<JSBool strict>
52771: void JS_FASTCALL
52693: stubs::SetElem(VMFrame &f)
52693: {
52693:     JSContext *cx = f.cx;
52693:     JSFrameRegs &regs = f.regs;
52693: 
52693:     Value &objval = regs.sp[-3];
52693:     Value &idval  = regs.sp[-2];
59916:     Value rval    = regs.sp[-1];
52693: 
52693:     JSObject *obj;
52693:     jsid id;
52693: 
52694:     obj = ValueToObject(cx, &objval);
52694:     if (!obj)
52693:         THROW();
52693: 
52723:     if (!FetchElementId(f, obj, idval, id, &regs.sp[-2]))
52693:         THROW();
52693: 
53161:     do {
52693:         if (obj->isDenseArray() && JSID_IS_INT(id)) {
52693:             jsuint length = obj->getDenseArrayCapacity();
52693:             jsint i = JSID_TO_INT(id);
52693:             if ((jsuint)i < length) {
52693:                 if (obj->getDenseArrayElement(i).isMagic(JS_ARRAY_HOLE)) {
52693:                     if (js_PrototypeHasIndexedProperties(cx, obj))
53161:                         break;
52693:                     if ((jsuint)i >= obj->getArrayLength())
53161:                         obj->setArrayLength(i + 1);
52693:                 }
59916:                 obj->setDenseArrayElement(i, rval);
52693:                 goto end_setelem;
52693:             }
52693:         }
53161:     } while (0);
59916:     if (!obj->setProperty(cx, id, &rval, strict))
52693:         THROW();
52693:   end_setelem:
52693:     /* :FIXME: Moving the assigned object into the lowest stack slot
52693:      * is a temporary hack. What we actually want is an implementation
52693:      * of popAfterSet() that allows popping more than one value;
52693:      * this logic can then be handled in Compiler.cpp. */
59916:     regs.sp[-3] = regs.sp[-1];
52693: }
52693: 
54169: template void JS_FASTCALL stubs::SetElem<true>(VMFrame &f);
54169: template void JS_FASTCALL stubs::SetElem<false>(VMFrame &f);
54169: 
52693: void JS_FASTCALL
52819: stubs::CallName(VMFrame &f)
52644: {
53840:     JSObject *obj = NameOp(f, &f.fp()->scopeChain(), true);
52644:     if (!obj)
52644:         THROW();
52644: }
52644: 
52644: void JS_FASTCALL
52721: stubs::BitOr(VMFrame &f)
52617: {
52617:     int32_t i, j;
52617: 
52617:     if (!ValueToECMAInt32(f.cx, f.regs.sp[-2], &i) ||
52617:         !ValueToECMAInt32(f.cx, f.regs.sp[-1], &j)) {
52617:         THROW();
52617:     }
52721:     i = i | j;
52617:     f.regs.sp[-2].setInt32(i);
52617: }
52617: 
52685: void JS_FASTCALL
52718: stubs::BitXor(VMFrame &f)
52718: {
52718:     int32_t i, j;
52718: 
52718:     if (!ValueToECMAInt32(f.cx, f.regs.sp[-2], &i) ||
52718:         !ValueToECMAInt32(f.cx, f.regs.sp[-1], &j)) {
52718:         THROW();
52718:     }
52718:     i = i ^ j;
52718:     f.regs.sp[-2].setInt32(i);
52718: }
52718: 
52718: void JS_FASTCALL
52721: stubs::BitAnd(VMFrame &f)
52721: {
52721:     int32_t i, j;
52721: 
52721:     if (!ValueToECMAInt32(f.cx, f.regs.sp[-2], &i) ||
52721:         !ValueToECMAInt32(f.cx, f.regs.sp[-1], &j)) {
52721:         THROW();
52721:     }
52721:     i = i & j;
52721:     f.regs.sp[-2].setInt32(i);
52721: }
52721: 
52721: void JS_FASTCALL
52724: stubs::BitNot(VMFrame &f)
52724: {
52724:     int32_t i;
52724: 
52724:     if (!ValueToECMAInt32(f.cx, f.regs.sp[-1], &i))
52724:         THROW();
52724:     i = ~i;
52724:     f.regs.sp[-1].setInt32(i);
52724: }
52724: 
52724: void JS_FASTCALL
52685: stubs::Lsh(VMFrame &f)
52685: {
52685:     int32_t i, j;
52685:     if (!ValueToECMAInt32(f.cx, f.regs.sp[-2], &i))
52685:         THROW();
52685:     if (!ValueToECMAInt32(f.cx, f.regs.sp[-1], &j))
52685:         THROW();
52685:     i = i << (j & 31);
52685:     f.regs.sp[-2].setInt32(i);
52685: }
52685: 
52685: void JS_FASTCALL
52685: stubs::Rsh(VMFrame &f)
52685: {
52685:     int32_t i, j;
52685:     if (!ValueToECMAInt32(f.cx, f.regs.sp[-2], &i))
52685:         THROW();
52685:     if (!ValueToECMAInt32(f.cx, f.regs.sp[-1], &j))
52685:         THROW();
52685:     i = i >> (j & 31);
52685:     f.regs.sp[-2].setInt32(i);
52685: }
52685: 
52725: void JS_FASTCALL
52725: stubs::Ursh(VMFrame &f)
52725: {
52725:     uint32_t u;
52725:     if (!ValueToECMAUint32(f.cx, f.regs.sp[-2], &u))
52725:         THROW();
52725:     int32_t j;
52725:     if (!ValueToECMAInt32(f.cx, f.regs.sp[-1], &j))
52725:         THROW();
52725: 
52725:     u >>= (j & 31);
52725: 
52725: 	f.regs.sp[-2].setNumber(uint32(u));
52725: }
52725: 
54169: template<JSBool strict>
53345: void JS_FASTCALL
53591: stubs::DefFun(VMFrame &f, JSFunction *fun)
52647: {
53531:     JSObject *obj2;
52647: 
52647:     JSContext *cx = f.cx;
53482:     JSStackFrame *fp = f.fp();
52647: 
52647:     /*
52647:      * A top-level function defined in Global or Eval code (see ECMA-262
52647:      * Ed. 3), or else a SpiderMonkey extension: a named function statement in
52647:      * a compound statement (not at the top statement level of global code, or
52647:      * at the top level of a function body).
52647:      */
52647:     JSObject *obj = FUN_OBJECT(fun);
52647: 
52647:     if (FUN_NULL_CLOSURE(fun)) {
52647:         /*
52647:          * Even a null closure needs a parent for principals finding.
52647:          * FIXME: bug 476950, although debugger users may also demand some kind
52647:          * of scope link for debugger-assisted eval-in-frame.
52647:          */
53840:         obj2 = &fp->scopeChain();
52647:     } else {
61216:         JS_ASSERT(!fun->isFlatClosure());
52647: 
62855:         obj2 = GetScopeChainFast(cx, fp, JSOP_DEFFUN, JSOP_DEFFUN_LENGTH, ORIGIN_MJIT_DEFFUN);
52647:         if (!obj2)
52647:             THROW();
52647:     }
52647: 
52647:     /*
52647:      * If static link is not current scope, clone fun's object to link to the
52647:      * current scope via parent. We do this to enable sharing of compiled
52647:      * functions among multiple equivalent scopes, amortizing the cost of
52647:      * compilation over a number of executions.  Examples include XUL scripts
52647:      * and event handlers shared among Firefox or other Mozilla app chrome
52647:      * windows, and user-defined JS functions precompiled and then shared among
52647:      * requests in server-side JS.
52647:      */
52647:     if (obj->getParent() != obj2) {
52647:         obj = CloneFunctionObject(cx, fun, obj2);
52647:         if (!obj)
52647:             THROW();
52647:     }
52647: 
52647:     /*
52647:      * ECMA requires functions defined when entering Eval code to be
52647:      * impermanent.
52647:      */
53840:     uintN attrs = fp->isEvalFrame()
52647:                   ? JSPROP_ENUMERATE
52647:                   : JSPROP_ENUMERATE | JSPROP_PERMANENT;
52647: 
52647:     /*
52647:      * We define the function as a property of the variable object and not the
52647:      * current scope chain even for the case of function expression statements
52647:      * and functions defined by eval inside let or with blocks.
52647:      */
53840:     JSObject *parent = &fp->varobj(cx);
52647: 
61216:     /* ES5 10.5 (NB: with subsequent errata). */
53531:     jsid id = ATOM_TO_JSID(fun->atom);
53531:     JSProperty *prop = NULL;
53531:     JSObject *pobj;
61216:     if (!parent->lookupProperty(cx, id, &pobj, &prop))
53840:         THROW();
52647: 
61216:     Value rval = ObjectValue(*obj);
55563: 
61216:     do {
61216:         /* Steps 5d, 5f. */
61216:         if (!prop || pobj != parent) {
62395:             if (!parent->defineProperty(cx, id, rval, PropertyStub, StrictPropertyStub, attrs))
61216:                 THROW();
61216:             break;
61216:         }
55563: 
61216:         /* Step 5e. */
61216:         JS_ASSERT(parent->isNative());
61216:         Shape *shape = reinterpret_cast<Shape *>(prop);
61216:         if (parent->isGlobal()) {
61216:             if (shape->configurable()) {
62395:                 if (!parent->defineProperty(cx, id, rval, PropertyStub, StrictPropertyStub, attrs))
61216:                     THROW();
61216:                 break;
61216:             }
61216: 
61216:             if (shape->isAccessorDescriptor() || !shape->writable() || !shape->enumerable()) {
61216:                 JSAutoByteString bytes;
61216:                 if (const char *name = js_ValueToPrintable(cx, IdToValue(id), &bytes)) {
61216:                     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
61216:                                          JSMSG_CANT_REDEFINE_PROP, name);
61216:                 }
61216:                 THROW();
61216:             }
61216:         }
55563: 
52647:         /*
61216:          * Non-global properties, and global properties which we aren't simply
61216:          * redefining, must be set.  First, this preserves their attributes.
61216:          * Second, this will produce warnings and/or errors as necessary if the
61216:          * specified Call object property is not writable (const).
52647:          */
55563: 
61216:         /* Step 5f. */
61216:         if (!parent->setProperty(cx, id, &rval, strict))
52647:             THROW();
61216:     } while (false);
52647: }
52653: 
54169: template void JS_FASTCALL stubs::DefFun<true>(VMFrame &f, JSFunction *fun);
54169: template void JS_FASTCALL stubs::DefFun<false>(VMFrame &f, JSFunction *fun);
54169: 
52653: #define DEFAULT_VALUE(cx, n, hint, v)                                         \
52653:     JS_BEGIN_MACRO                                                            \
52653:         JS_ASSERT(v.isObject());                                              \
52653:         JS_ASSERT(v == regs.sp[n]);                                           \
53125:         if (!DefaultValue(cx, &v.toObject(), hint, &regs.sp[n]))              \
52653:             THROWV(JS_FALSE);                                                 \
52653:         v = regs.sp[n];                                                       \
52653:     JS_END_MACRO
52653: 
52653: #define RELATIONAL(OP)                                                        \
52653:     JS_BEGIN_MACRO                                                            \
52653:         JSContext *cx = f.cx;                                                 \
52653:         JSFrameRegs &regs = f.regs;                                           \
52653:         Value rval = regs.sp[-1];                                             \
52653:         Value lval = regs.sp[-2];                                             \
52653:         bool cond;                                                            \
52653:         if (lval.isObject())                                                  \
52653:             DEFAULT_VALUE(cx, -2, JSTYPE_NUMBER, lval);                       \
52653:         if (rval.isObject())                                                  \
52653:             DEFAULT_VALUE(cx, -1, JSTYPE_NUMBER, rval);                       \
52954:         if (lval.isString() && rval.isString()) {                             \
53081:             JSString *l = lval.toString(), *r = rval.toString();              \
59890:             JSBool cmp;                                                       \
59890:             if (!CompareStrings(cx, l, r, &cmp))                              \
59890:                 THROWV(JS_FALSE);                                             \
59890:             cond = cmp OP 0;                                                  \
52653:         } else {                                                              \
52653:             double l, r;                                                      \
52653:             if (!ValueToNumber(cx, lval, &l) ||                               \
52653:                 !ValueToNumber(cx, rval, &r)) {                               \
52653:                 THROWV(JS_FALSE);                                             \
52653:             }                                                                 \
52653:             cond = JSDOUBLE_COMPARE(l, OP, r, false);                         \
52653:         }                                                                     \
52668:         regs.sp[-2].setBoolean(cond);                                         \
52653:         return cond;                                                          \
52653:     JS_END_MACRO
52653: 
52653: JSBool JS_FASTCALL
52653: stubs::LessThan(VMFrame &f)
52653: {
52653:     RELATIONAL(<);
52653: }
52653: 
52653: JSBool JS_FASTCALL
52653: stubs::LessEqual(VMFrame &f)
52653: {
52653:     RELATIONAL(<=);
52653: }
52653: 
52653: JSBool JS_FASTCALL
52653: stubs::GreaterThan(VMFrame &f)
52653: {
52653:     RELATIONAL(>);
52653: }
52653: 
52653: JSBool JS_FASTCALL
52653: stubs::GreaterEqual(VMFrame &f)
52653: {
52653:     RELATIONAL(>=);
52653: }
52653: 
52686: JSBool JS_FASTCALL
52686: stubs::ValueToBoolean(VMFrame &f)
52686: {
52686:     return js_ValueToBoolean(f.regs.sp[-1]);
52686: }
52686: 
52734: void JS_FASTCALL
52734: stubs::Not(VMFrame &f)
52734: {
52734:     JSBool b = !js_ValueToBoolean(f.regs.sp[-1]);
52734:     f.regs.sp[-1].setBoolean(b);
52734: }
52734: 
52954: template <JSBool EQ, bool IFNAN>
52679: static inline bool
52954: StubEqualityOp(VMFrame &f)
52679: {
52679:     JSContext *cx = f.cx;
52679:     JSFrameRegs &regs = f.regs;
52679: 
52679:     Value rval = regs.sp[-1];
52679:     Value lval = regs.sp[-2];
52679: 
52954:     JSBool cond;
52679: 
53429:     /* The string==string case is easily the hottest;  try it first. */
53429:     if (lval.isString() && rval.isString()) {
53429:         JSString *l = lval.toString();
53429:         JSString *r = rval.toString();
59890:         JSBool equal;
59890:         if (!EqualStrings(cx, l, r, &equal))
59890:             return false;
59890:         cond = equal == EQ;
53429:     } else
52679: #if JS_HAS_XML_SUPPORT
53081:     if ((lval.isObject() && lval.toObject().isXML()) ||
53081:         (rval.isObject() && rval.toObject().isXML())) {
52954:         if (!js_TestXMLEquality(cx, lval, rval, &cond))
52954:             return false;
52954:         cond = cond == EQ;
52679:     } else
52954: #endif
52679: 
53023:     if (SameType(lval, rval)) {
53429:         JS_ASSERT(!lval.isString());    /* this case is handled above */
53429:         if (lval.isDouble()) {
53081:             double l = lval.toDouble();
53081:             double r = rval.toDouble();
52954:             if (EQ)
52954:                 cond = JSDOUBLE_COMPARE(l, ==, r, IFNAN);
52954:             else
52954:                 cond = JSDOUBLE_COMPARE(l, !=, r, IFNAN);
52954:         } else if (lval.isObject()) {
53081:             JSObject *l = &lval.toObject(), *r = &rval.toObject();
57806:             l->assertSpecialEqualitySynced();
53244:             if (EqualityOp eq = l->getClass()->ext.equality) {
53244:                 if (!eq(cx, l, &rval, &cond))
52954:                     return false;
52954:                 cond = cond == EQ;
52679:             } else {
52954:                 cond = (l == r) == EQ;
52679:             }
53418:         } else if (lval.isNullOrUndefined()) {
53418:             cond = EQ;
52679:         } else {
53081:             cond = (lval.payloadAsRawUint32() == rval.payloadAsRawUint32()) == EQ;
52679:         }
52679:     } else {
52679:         if (lval.isNullOrUndefined()) {
52954:             cond = rval.isNullOrUndefined() == EQ;
52679:         } else if (rval.isNullOrUndefined()) {
52954:             cond = !EQ;
52679:         } else {
52679:             if (lval.isObject()) {
53125:                 if (!DefaultValue(cx, &lval.toObject(), JSTYPE_VOID, &regs.sp[-2]))
52954:                     return false;
52679:                 lval = regs.sp[-2];
52679:             }
52679: 
52679:             if (rval.isObject()) {
53125:                 if (!DefaultValue(cx, &rval.toObject(), JSTYPE_VOID, &regs.sp[-1]))
52954:                     return false;
52679:                 rval = regs.sp[-1];
52679:             }
52679: 
53429:             /*
53429:              * The string==string case is repeated because DefaultValue() can
53429:              * convert lval/rval to strings.
53429:              */
52954:             if (lval.isString() && rval.isString()) {
53081:                 JSString *l = lval.toString();
53081:                 JSString *r = rval.toString();
59890:                 JSBool equal;
59890:                 if (!EqualStrings(cx, l, r, &equal))
59890:                     return false;
59890:                 cond = equal == EQ;
52679:             } else {
52679:                 double l, r;
52679:                 if (!ValueToNumber(cx, lval, &l) ||
52679:                     !ValueToNumber(cx, rval, &r)) {
52954:                     return false;
52679:                 }
52679: 
52954:                 if (EQ)
52997:                     cond = JSDOUBLE_COMPARE(l, ==, r, false);
52679:                 else
52997:                     cond = JSDOUBLE_COMPARE(l, !=, r, true);
52679:             }
52679:         }
52679:     }
52679: 
52680:     regs.sp[-2].setBoolean(cond);
52954:     return true;
52679: }
52679: 
52679: JSBool JS_FASTCALL
52679: stubs::Equal(VMFrame &f)
52679: {
52954:     if (!StubEqualityOp<JS_TRUE, false>(f))
52954:         THROWV(JS_FALSE);
53081:     return f.regs.sp[-2].toBoolean();
52679: }
52679: 
52679: JSBool JS_FASTCALL
52679: stubs::NotEqual(VMFrame &f)
52679: {
52954:     if (!StubEqualityOp<JS_FALSE, true>(f))
52954:         THROWV(JS_FALSE);
53081:     return f.regs.sp[-2].toBoolean();
52679: }
52679: 
52692: static inline bool
52692: DefaultValue(VMFrame &f, JSType hint, Value &v, int n)
52692: {
52692:     JS_ASSERT(v.isObject());
53125:     if (!DefaultValue(f.cx, &v.toObject(), hint, &f.regs.sp[n]))
52692:         return false;
52692:     v = f.regs.sp[n];
52692:     return true;
52692: }
52692: 
52692: void JS_FASTCALL
52692: stubs::Add(VMFrame &f)
52692: {
52692:     JSContext *cx = f.cx;
52692:     JSFrameRegs &regs = f.regs;
52692:     Value rval = regs.sp[-1];
52692:     Value lval = regs.sp[-2];
52692: 
53357:     /* The string + string case is easily the hottest;  try it first. */
53357:     bool lIsString = lval.isString();
53357:     bool rIsString = rval.isString();
53357:     JSString *lstr, *rstr;
53357:     if (lIsString && rIsString) {
53357:         lstr = lval.toString();
53357:         rstr = rval.toString();
53357:         goto string_concat;
53357: 
52692:     } else
52692: #if JS_HAS_XML_SUPPORT
53081:     if (lval.isObject() && lval.toObject().isXML() &&
53081:         rval.isObject() && rval.toObject().isXML()) {
53081:         if (!js_ConcatenateXML(cx, &lval.toObject(), &rval.toObject(), &rval))
52692:             THROW();
52692:         regs.sp--;
52692:         regs.sp[-1] = rval;
52692:     } else
52692: #endif
52692:     {
53357:         /* These can convert lval/rval to strings. */
52692:         if (lval.isObject() && !DefaultValue(f, JSTYPE_VOID, lval, -2))
52692:             THROW();
52692:         if (rval.isObject() && !DefaultValue(f, JSTYPE_VOID, rval, -1))
52692:             THROW();
53357:         if ((lIsString = lval.isString()) || (rIsString = rval.isString())) {
52692:             if (lIsString) {
53081:                 lstr = lval.toString();
52692:             } else {
52692:                 lstr = js_ValueToString(cx, lval);
52692:                 if (!lstr)
52692:                     THROW();
52692:                 regs.sp[-2].setString(lstr);
52692:             }
52692:             if (rIsString) {
53081:                 rstr = rval.toString();
52692:             } else {
52692:                 rstr = js_ValueToString(cx, rval);
52692:                 if (!rstr)
52692:                     THROW();
52692:                 regs.sp[-1].setString(rstr);
52692:             }
53357:             goto string_concat;
53357: 
52692:         } else {
52692:             double l, r;
52692:             if (!ValueToNumber(cx, lval, &l) || !ValueToNumber(cx, rval, &r))
52692:                 THROW();
52692:             l += r;
52692:             regs.sp--;
52692:             regs.sp[-1].setNumber(l);
52692:         }
52692:     }
53357:     return;
53357: 
53357:   string_concat:
53357:     JSString *str = js_ConcatStrings(cx, lstr, rstr);
53357:     if (!str)
53357:         THROW();
53357:     regs.sp--;
53357:     regs.sp[-1].setString(str);
52692: }
52692: 
52692: 
52692: void JS_FASTCALL
52692: stubs::Sub(VMFrame &f)
52692: {
52692:     JSContext *cx = f.cx;
52692:     JSFrameRegs &regs = f.regs;
52692:     double d1, d2;
52692:     if (!ValueToNumber(cx, regs.sp[-2], &d1) ||
52692:         !ValueToNumber(cx, regs.sp[-1], &d2)) {
52692:         THROW();
52692:     }
52692:     double d = d1 - d2;
52692:     regs.sp[-2].setNumber(d);
52692: }
52692: 
52692: void JS_FASTCALL
52692: stubs::Mul(VMFrame &f)
52692: {
52692:     JSContext *cx = f.cx;
52692:     JSFrameRegs &regs = f.regs;
52692:     double d1, d2;
52692:     if (!ValueToNumber(cx, regs.sp[-2], &d1) ||
52692:         !ValueToNumber(cx, regs.sp[-1], &d2)) {
52692:         THROW();
52692:     }
52692:     double d = d1 * d2;
52692:     regs.sp[-2].setNumber(d);
52692: }
52692: 
52692: void JS_FASTCALL
52692: stubs::Div(VMFrame &f)
52692: {
52692:     JSContext *cx = f.cx;
52692:     JSRuntime *rt = cx->runtime;
52692:     JSFrameRegs &regs = f.regs;
52692: 
52692:     double d1, d2;
52692:     if (!ValueToNumber(cx, regs.sp[-2], &d1) ||
52692:         !ValueToNumber(cx, regs.sp[-1], &d2)) {
52692:         THROW();
52692:     }
52692:     if (d2 == 0) {
52692:         const Value *vp;
52692: #ifdef XP_WIN
52692:         /* XXX MSVC miscompiles such that (NaN == 0) */
52692:         if (JSDOUBLE_IS_NaN(d2))
52692:             vp = &rt->NaNValue;
52692:         else
52692: #endif
52692:         if (d1 == 0 || JSDOUBLE_IS_NaN(d1))
52692:             vp = &rt->NaNValue;
52692:         else if (JSDOUBLE_IS_NEG(d1) != JSDOUBLE_IS_NEG(d2))
52692:             vp = &rt->negativeInfinityValue;
52692:         else
52692:             vp = &rt->positiveInfinityValue;
52692:         regs.sp[-2] = *vp;
52692:     } else {
52692:         d1 /= d2;
52692:         regs.sp[-2].setNumber(d1);
52692:     }
52692: }
52692: 
52692: void JS_FASTCALL
52692: stubs::Mod(VMFrame &f)
52692: {
52692:     JSContext *cx = f.cx;
52692:     JSFrameRegs &regs = f.regs;
52692: 
52692:     Value &lref = regs.sp[-2];
52692:     Value &rref = regs.sp[-1];
52692:     int32_t l, r;
52692:     if (lref.isInt32() && rref.isInt32() &&
53081:         (l = lref.toInt32()) >= 0 && (r = rref.toInt32()) > 0) {
52692:         int32_t mod = l % r;
52692:         regs.sp[-2].setInt32(mod);
52692:     } else {
52692:         double d1, d2;
52692:         if (!ValueToNumber(cx, regs.sp[-2], &d1) ||
52692:             !ValueToNumber(cx, regs.sp[-1], &d2)) {
52692:             THROW();
52692:         }
52692:         if (d2 == 0) {
52692:             regs.sp[-2].setDouble(js_NaN);
52692:         } else {
52692:             d1 = js_fmod(d1, d2);
52692:             regs.sp[-2].setDouble(d1);
52692:         }
52692:     }
52692: }
52692: 
52704: void JS_FASTCALL
53395: stubs::Debugger(VMFrame &f, jsbytecode *pc)
53395: {
53395:     JSDebuggerHandler handler = f.cx->debugHooks->debuggerHandler;
53395:     if (handler) {
53395:         Value rval;
53840:         switch (handler(f.cx, f.cx->fp()->script(), pc, Jsvalify(&rval),
53395:                         f.cx->debugHooks->debuggerHandlerData)) {
53395:           case JSTRAP_THROW:
60211:             f.cx->setPendingException(rval);
53395:             THROW();
53395: 
53395:           case JSTRAP_RETURN:
60211:             f.cx->clearPendingException();
55483:             f.cx->fp()->setReturnValue(rval);
53477: #if (defined(JS_NO_FASTCALL) && defined(JS_CPU_X86)) || defined(_WIN64)
53477:             *f.returnAddressLocation() = JS_FUNC_TO_DATA_PTR(void *,
56773:                                          f.cx->jaegerCompartment()->forceReturnFastTrampoline());
53477: #else
53395:             *f.returnAddressLocation() = JS_FUNC_TO_DATA_PTR(void *,
56773:                                          f.cx->jaegerCompartment()->forceReturnTrampoline());
53468: #endif
53395:             break;
53395: 
53395:           case JSTRAP_ERROR:
60211:             f.cx->clearPendingException();
53395:             THROW();
53395: 
53395:           default:
53395:             break;
53395:         }
53395:     }
53395: }
53395: 
53395: void JS_FASTCALL
53168: stubs::Interrupt(VMFrame &f, jsbytecode *pc)
52753: {
53168:     if (!js_HandleExecutionInterrupt(f.cx))
52753:         THROW();
52753: }
53168: 
53168: void JS_FASTCALL
59882: stubs::Trap(VMFrame &f, uint32 trapTypes)
53168: {
53168:     Value rval;
59882:     jsbytecode *pc = f.cx->regs->pc;
53168: 
59882:     /*
59882:      * Trap may be called for a single-step interrupt trap and/or a
59882:      * regular trap. Try the single-step first, and if it lets control
59882:      * flow through or does not exist, do the regular trap.
59882:      */
59882:     JSTrapStatus result = JSTRAP_CONTINUE;
59882:     if (trapTypes & JSTRAP_SINGLESTEP) {
59882:         /*
59882:          * single step mode may be paused without recompiling by
59882:          * setting the interruptHook to NULL.
59882:          */
59882:         JSInterruptHook hook = f.cx->debugHooks->interruptHook;
59882:         if (hook)
59882:             result = hook(f.cx, f.cx->fp()->script(), pc, Jsvalify(&rval),
59882:                           f.cx->debugHooks->interruptHookData);
59882:     }
59882: 
59882:     if (result == JSTRAP_CONTINUE && (trapTypes & JSTRAP_TRAP))
59882:         result = JS_HandleTrap(f.cx, f.cx->fp()->script(), pc, Jsvalify(&rval));
59882: 
59882:     switch (result) {
53168:       case JSTRAP_THROW:
60211:         f.cx->setPendingException(rval);
53168:         THROW();
53168: 
53168:       case JSTRAP_RETURN:
60211:         f.cx->clearPendingException();
55483:         f.cx->fp()->setReturnValue(rval);
53477: #if (defined(JS_NO_FASTCALL) && defined(JS_CPU_X86)) || defined(_WIN64)
53477:         *f.returnAddressLocation() = JS_FUNC_TO_DATA_PTR(void *,
56773:                                      f.cx->jaegerCompartment()->forceReturnFastTrampoline());
53477: #else
53168:         *f.returnAddressLocation() = JS_FUNC_TO_DATA_PTR(void *,
56773:                                      f.cx->jaegerCompartment()->forceReturnTrampoline());
53468: #endif
53168:         break;
53168: 
53168:       case JSTRAP_ERROR:
60211:         f.cx->clearPendingException();
53168:         THROW();
53168: 
53168:       default:
53168:         break;
53168:     }
52753: }
52753: 
52753: void JS_FASTCALL
52704: stubs::This(VMFrame &f)
52704: {
55713:     if (!f.fp()->computeThis(f.cx))
52704:         THROW();
55713:     f.regs.sp[-1] = f.fp()->thisValue();
53023: }
53023: 
53023: void JS_FASTCALL
52713: stubs::Neg(VMFrame &f)
52713: {
52713:     double d;
52713:     if (!ValueToNumber(f.cx, f.regs.sp[-1], &d))
52713:         THROW();
52713:     d = -d;
52713:     f.regs.sp[-1].setNumber(d);
52713: }
52713: 
52719: JSObject * JS_FASTCALL
55746: stubs::NewInitArray(VMFrame &f, uint32 count)
52719: {
59234:     JSObject *obj = NewDenseAllocatedArray(f.cx, count);
59234:     if (!obj)
52719:         THROWV(NULL);
58056: 
52719:     return obj;
52719: }
52719: 
52719: JSObject * JS_FASTCALL
58056: stubs::NewInitObject(VMFrame &f, JSObject *baseobj)
52719: {
52719:     JSContext *cx = f.cx;
52719: 
58056:     if (!baseobj) {
58056:         gc::FinalizeKind kind = GuessObjectGCKind(0, false);
55746:         JSObject *obj = NewBuiltinClassInstance(cx, &js_ObjectClass, kind);
58056:         if (!obj)
52719:             THROWV(NULL);
58056:         return obj;
58056:     }
52719: 
58056:     JSObject *obj = CopyInitializerObject(cx, baseobj);
58056: 
58056:     if (!obj)
58056:         THROWV(NULL);
52719:     return obj;
52719: }
52719: 
52719: void JS_FASTCALL
52723: stubs::InitElem(VMFrame &f, uint32 last)
52723: {
52723:     JSContext *cx = f.cx;
52723:     JSFrameRegs &regs = f.regs;
52723: 
52723:     /* Pop the element's value into rval. */
53482:     JS_ASSERT(regs.sp - f.fp()->base() >= 3);
52723:     const Value &rref = regs.sp[-1];
52723: 
52723:     /* Find the object being initialized at top of stack. */
52723:     const Value &lref = regs.sp[-3];
52723:     JS_ASSERT(lref.isObject());
53081:     JSObject *obj = &lref.toObject();
52723: 
52723:     /* Fetch id now that we have obj. */
52723:     jsid id;
52723:     const Value &idval = regs.sp[-2];
52723:     if (!FetchElementId(f, obj, idval, id, &regs.sp[-2]))
52723:         THROW();
52723: 
52723:     /*
52723:      * If rref is a hole, do not call JSObject::defineProperty. In this case,
52723:      * obj must be an array, so if the current op is the last element
52723:      * initialiser, set the array length to one greater than id.
52723:      */
52723:     if (rref.isMagic(JS_ARRAY_HOLE)) {
52723:         JS_ASSERT(obj->isArray());
52723:         JS_ASSERT(JSID_IS_INT(id));
52723:         JS_ASSERT(jsuint(JSID_TO_INT(id)) < JS_ARGS_LENGTH_MAX);
52723:         if (last && !js_SetLengthProperty(cx, obj, (jsuint) (JSID_TO_INT(id) + 1)))
52723:             THROW();
52723:     } else {
52723:         if (!obj->defineProperty(cx, id, rref, NULL, NULL, JSPROP_ENUMERATE))
52723:             THROW();
52723:     }
52723: }
52723: 
52726: void JS_FASTCALL
53081: stubs::GetUpvar(VMFrame &f, uint32 ck)
52726: {
52726:     /* :FIXME: We can do better, this stub isn't needed. */
53840:     uint32 staticLevel = f.fp()->script()->staticLevel;
53081:     UpvarCookie cookie;
53081:     cookie.fromInteger(ck);
53091:     f.regs.sp[0] = GetUpvar(f.cx, staticLevel, cookie);
52726: }
52726: 
52727: JSObject * JS_FASTCALL
52727: stubs::DefLocalFun(VMFrame &f, JSFunction *fun)
52727: {
52727:     /*
52727:      * Define a local function (i.e., one nested at the top level of another
52727:      * function), parented by the current scope chain, stored in a local
52727:      * variable slot that the compiler allocated.  This is an optimization over
52727:      * JSOP_DEFFUN that avoids requiring a call object for the outer function's
52727:      * activation.
52727:      */
52727:     JS_ASSERT(fun->isInterpreted());
52727:     JS_ASSERT(!FUN_FLAT_CLOSURE(fun));
52727:     JSObject *obj = FUN_OBJECT(fun);
52727: 
52727:     if (FUN_NULL_CLOSURE(fun)) {
53840:         obj = CloneFunctionObject(f.cx, fun, &f.fp()->scopeChain());
52727:         if (!obj)
52727:             THROWV(NULL);
52727:     } else {
56729:         JSObject *parent = GetScopeChainFast(f.cx, f.fp(), JSOP_DEFLOCALFUN,
62855:                                              JSOP_DEFLOCALFUN_LENGTH, ORIGIN_MJIT_DEFLOCALFUN);
52727:         if (!parent)
52727:             THROWV(NULL);
52727: 
52727:         if (obj->getParent() != parent) {
52727:             obj = CloneFunctionObject(f.cx, fun, parent);
52727:             if (!obj)
52727:                 THROWV(NULL);
52727:         }
52727:     }
52727: 
52727:     return obj;
52727: }
52727: 
52729: JSObject * JS_FASTCALL
53038: stubs::DefLocalFun_FC(VMFrame &f, JSFunction *fun)
53038: {
55527:     JSObject *obj = js_NewFlatClosure(f.cx, fun, JSOP_DEFLOCALFUN_FC, JSOP_DEFLOCALFUN_FC_LENGTH);
53038:     if (!obj)
53038:         THROWV(NULL);
53038:     return obj;
53038: }
53038: 
53038: JSObject * JS_FASTCALL
52729: stubs::RegExp(VMFrame &f, JSObject *regex)
52729: {
52729:     /*
52729:      * Push a regexp object cloned from the regexp literal object mapped by the
52729:      * bytecode at pc. ES5 finally fixed this bad old ES3 design flaw which was
52729:      * flouted by many browser-based implementations.
52729:      *
56729:      * We avoid the GetScopeChain call here and pass fp->scopeChain() as
52729:      * js_GetClassPrototype uses the latter only to locate the global.
52729:      */
52729:     JSObject *proto;
53840:     if (!js_GetClassPrototype(f.cx, &f.fp()->scopeChain(), JSProto_RegExp, &proto))
52729:         THROWV(NULL);
52729:     JS_ASSERT(proto);
52729:     JSObject *obj = js_CloneRegExpObject(f.cx, regex, proto);
52729:     if (!obj)
52729:         THROWV(NULL);
52729:     return obj;
52729: }
52729: 
52730: JSObject * JS_FASTCALL
53128: stubs::LambdaForInit(VMFrame &f, JSFunction *fun)
53128: {
53128:     JSObject *obj = FUN_OBJECT(fun);
53840:     if (FUN_NULL_CLOSURE(fun) && obj->getParent() == &f.fp()->scopeChain()) {
54855:         fun->setMethodAtom(f.fp()->script()->getAtom(GET_SLOTNO(f.regs.pc)));
53128:         return obj;
53249:     }
53249:     return Lambda(f, fun);
53128: }
53128: 
53249: JSObject * JS_FASTCALL
53249: stubs::LambdaForSet(VMFrame &f, JSFunction *fun)
53249: {
53249:     JSObject *obj = FUN_OBJECT(fun);
53840:     if (FUN_NULL_CLOSURE(fun) && obj->getParent() == &f.fp()->scopeChain()) {
53249:         const Value &lref = f.regs.sp[-1];
53249:         if (lref.isObject() && lref.toObject().canHaveMethodBarrier()) {
54855:             fun->setMethodAtom(f.fp()->script()->getAtom(GET_SLOTNO(f.regs.pc)));
53249:             return obj;
53249:         }
53249:     }
53249:     return Lambda(f, fun);
53249: }
53128: 
53249: JSObject * JS_FASTCALL
53249: stubs::LambdaJoinableForCall(VMFrame &f, JSFunction *fun)
53249: {
53249:     JSObject *obj = FUN_OBJECT(fun);
53840:     if (FUN_NULL_CLOSURE(fun) && obj->getParent() == &f.fp()->scopeChain()) {
53249:         /*
53249:          * Array.prototype.sort and String.prototype.replace are
53249:          * optimized as if they are special form. We know that they
53249:          * won't leak the joined function object in obj, therefore
53249:          * we don't need to clone that compiler- created function
53249:          * object for identity/mutation reasons.
53249:          */
54855:         int iargc = GET_ARGC(f.regs.pc);
53249: 
53249:         /*
53249:          * Note that we have not yet pushed obj as the final argument,
53249:          * so regs.sp[1 - (iargc + 2)], and not regs.sp[-(iargc + 2)],
53249:          * is the callee for this JSOP_CALL.
53249:          */
53249:         const Value &cref = f.regs.sp[1 - (iargc + 2)];
53249:         JSObject *callee;
53249: 
53249:         if (IsFunctionObject(cref, &callee)) {
53557:             JSFunction *calleeFun = callee->getFunctionPrivate();
53557:             Native native = calleeFun->maybeNative();
53249: 
53557:             if (native) {
53557:                 if (iargc == 1 && native == array_sort)
53128:                     return obj;
53557:                 if (iargc == 2 && native == str_replace)
53249:                     return obj;
53249:             }
53249:         }
53249:     }
53249:     return Lambda(f, fun);
53249: }
53249: 
53249: JSObject * JS_FASTCALL
53249: stubs::LambdaJoinableForNull(VMFrame &f, JSFunction *fun)
53249: {
53249:     JSObject *obj = FUN_OBJECT(fun);
53840:     if (FUN_NULL_CLOSURE(fun) && obj->getParent() == &f.fp()->scopeChain()) {
54855:         jsbytecode *pc2 = f.regs.pc + JSOP_NULL_LENGTH;
53249:         JSOp op2 = JSOp(*pc2);
53249: 
53249:         if (op2 == JSOP_CALL && GET_ARGC(pc2) == 0)
53249:             return obj;
53249:     }
53249:     return Lambda(f, fun);
53128: }
53128: 
53128: JSObject * JS_FASTCALL
52730: stubs::Lambda(VMFrame &f, JSFunction *fun)
52730: {
52730:     JSObject *obj = FUN_OBJECT(fun);
52730: 
52730:     JSObject *parent;
52730:     if (FUN_NULL_CLOSURE(fun)) {
53840:         parent = &f.fp()->scopeChain();
52730:     } else {
62855:         parent = GetScopeChainFast(f.cx, f.fp(), JSOP_LAMBDA, JSOP_LAMBDA_LENGTH, ORIGIN_MJIT_LAMBDA);
52730:         if (!parent)
52730:             THROWV(NULL);
52730:     }
52730: 
52730:     obj = CloneFunctionObject(f.cx, fun, parent);
52730:     if (!obj)
52730:         THROWV(NULL);
52730: 
52730:     return obj;
52730: }
52730: 
52732: /* Test whether v is an int in the range [-2^31 + 1, 2^31 - 2] */
52732: static JS_ALWAYS_INLINE bool
52732: CanIncDecWithoutOverflow(int32_t i)
52732: {
52732:     return (i > JSVAL_INT_MIN) && (i < JSVAL_INT_MAX);
52732: }
52730: 
54169: template <int32 N, bool POST, JSBool strict>
52732: static inline bool
52732: ObjIncOp(VMFrame &f, JSObject *obj, jsid id)
52732: {
52732:     JSContext *cx = f.cx;
53482:     JSStackFrame *fp = f.fp();
52732: 
52732:     f.regs.sp[0].setNull();
52732:     f.regs.sp++;
52732:     if (!obj->getProperty(cx, id, &f.regs.sp[-1]))
52732:         return false;
52732: 
52732:     Value &ref = f.regs.sp[-1];
52732:     int32_t tmp;
53081:     if (JS_LIKELY(ref.isInt32() && CanIncDecWithoutOverflow(tmp = ref.toInt32()))) {
52732:         if (POST)
53081:             ref.getInt32Ref() = tmp + N;
52732:         else
53081:             ref.getInt32Ref() = tmp += N;
53840:         fp->setAssigning();
54169:         JSBool ok = obj->setProperty(cx, id, &ref, strict);
53840:         fp->clearAssigning();
52732:         if (!ok)
52732:             return false;
52732: 
52732:         /*
52732:          * We must set regs.sp[-1] to tmp for both post and pre increments
52732:          * as the setter overwrites regs.sp[-1].
52732:          */
52732:         ref.setInt32(tmp);
52732:     } else {
52732:         Value v;
52732:         double d;
52732:         if (!ValueToNumber(cx, ref, &d))
52732:             return false;
52732:         if (POST) {
52732:             ref.setDouble(d);
52732:             d += N;
52732:         } else {
52732:             d += N;
52732:             ref.setDouble(d);
52732:         }
52732:         v.setDouble(d);
53840:         fp->setAssigning();
54169:         JSBool ok = obj->setProperty(cx, id, &v, strict);
53840:         fp->clearAssigning();
52732:         if (!ok)
52732:             return false;
52732:     }
52732: 
52732:     return true;
52732: }
52732: 
54169: template <int32 N, bool POST, JSBool strict>
52732: static inline bool
52825: NameIncDec(VMFrame &f, JSObject *obj, JSAtom *origAtom)
52732: {
52732:     JSContext *cx = f.cx;
52732: 
52732:     JSAtom *atom;
52732:     JSObject *obj2;
52732:     JSProperty *prop;
52732:     PropertyCacheEntry *entry;
52732:     JS_PROPERTY_CACHE(cx).test(cx, f.regs.pc, obj, obj2, entry, atom);
52732:     if (!atom) {
52732:         if (obj == obj2 && entry->vword.isSlot()) {
52732:             uint32 slot = entry->vword.toSlot();
56567:             Value &rref = obj->nativeGetSlotRef(slot);
52732:             int32_t tmp;
53081:             if (JS_LIKELY(rref.isInt32() && CanIncDecWithoutOverflow(tmp = rref.toInt32()))) {
52732:                 int32_t inc = tmp + N;
52732:                 if (!POST)
52732:                     tmp = inc;
53081:                 rref.getInt32Ref() = inc;
52732:                 f.regs.sp[0].setInt32(tmp);
52732:                 return true;
52732:             }
52732:         }
52732:         atom = origAtom;
52732:     }
52732: 
52732:     jsid id = ATOM_TO_JSID(atom);
52732:     if (!js_FindPropertyHelper(cx, id, true, &obj, &obj2, &prop))
52732:         return false;
52732:     if (!prop) {
52732:         ReportAtomNotDefined(cx, atom);
52732:         return false;
52732:     }
54169:     return ObjIncOp<N, POST, strict>(f, obj, id);
52732: }
52732: 
54169: template<JSBool strict>
52732: void JS_FASTCALL
52746: stubs::PropInc(VMFrame &f, JSAtom *atom)
52746: {
52746:     JSObject *obj = ValueToObject(f.cx, &f.regs.sp[-1]);
52746:     if (!obj)
52746:         THROW();
54169:     if (!ObjIncOp<1, true, strict>(f, obj, ATOM_TO_JSID(atom)))
52746:         THROW();
52746:     f.regs.sp[-2] = f.regs.sp[-1];
52746: }
52746: 
54169: template void JS_FASTCALL stubs::PropInc<true>(VMFrame &f, JSAtom *atom);
54169: template void JS_FASTCALL stubs::PropInc<false>(VMFrame &f, JSAtom *atom);
54169: 
54169: template<JSBool strict>
52746: void JS_FASTCALL
52746: stubs::PropDec(VMFrame &f, JSAtom *atom)
52746: {
52746:     JSObject *obj = ValueToObject(f.cx, &f.regs.sp[-1]);
52746:     if (!obj)
52746:         THROW();
54169:     if (!ObjIncOp<-1, true, strict>(f, obj, ATOM_TO_JSID(atom)))
52746:         THROW();
52746:     f.regs.sp[-2] = f.regs.sp[-1];
52746: }
52746: 
54169: template void JS_FASTCALL stubs::PropDec<true>(VMFrame &f, JSAtom *atom);
54169: template void JS_FASTCALL stubs::PropDec<false>(VMFrame &f, JSAtom *atom);
54169: 
54169: template<JSBool strict>
52746: void JS_FASTCALL
52746: stubs::IncProp(VMFrame &f, JSAtom *atom)
52746: {
52746:     JSObject *obj = ValueToObject(f.cx, &f.regs.sp[-1]);
52746:     if (!obj)
52746:         THROW();
54169:     if (!ObjIncOp<1, false, strict>(f, obj, ATOM_TO_JSID(atom)))
52746:         THROW();
52746:     f.regs.sp[-2] = f.regs.sp[-1];
52746: }
52746: 
54169: template void JS_FASTCALL stubs::IncProp<true>(VMFrame &f, JSAtom *atom);
54169: template void JS_FASTCALL stubs::IncProp<false>(VMFrame &f, JSAtom *atom);
54169: 
54169: template<JSBool strict>
52746: void JS_FASTCALL
52746: stubs::DecProp(VMFrame &f, JSAtom *atom)
52746: {
52746:     JSObject *obj = ValueToObject(f.cx, &f.regs.sp[-1]);
52746:     if (!obj)
52746:         THROW();
54169:     if (!ObjIncOp<-1, false, strict>(f, obj, ATOM_TO_JSID(atom)))
52746:         THROW();
52746:     f.regs.sp[-2] = f.regs.sp[-1];
52746: }
52746: 
54169: template void JS_FASTCALL stubs::DecProp<true>(VMFrame &f, JSAtom *atom);
54169: template void JS_FASTCALL stubs::DecProp<false>(VMFrame &f, JSAtom *atom);
54169: 
54169: template<JSBool strict>
52746: void JS_FASTCALL
52815: stubs::ElemInc(VMFrame &f)
52815: {
52815:     JSObject *obj = ValueToObject(f.cx, &f.regs.sp[-2]);
52815:     if (!obj)
52815:         THROW();
52815:     jsid id;
52815:     if (!FetchElementId(f, obj, f.regs.sp[-1], id, &f.regs.sp[-1]))
52815:         THROW();
54169:     if (!ObjIncOp<1, true, strict>(f, obj, id))
52815:         THROW();
52815:     f.regs.sp[-3] = f.regs.sp[-1];
52815: }
52815: 
54169: template void JS_FASTCALL stubs::ElemInc<true>(VMFrame &f);
54169: template void JS_FASTCALL stubs::ElemInc<false>(VMFrame &f);
54169: 
54169: template<JSBool strict>
52815: void JS_FASTCALL
52815: stubs::ElemDec(VMFrame &f)
52815: {
52815:     JSObject *obj = ValueToObject(f.cx, &f.regs.sp[-2]);
52815:     if (!obj)
52815:         THROW();
52815:     jsid id;
52815:     if (!FetchElementId(f, obj, f.regs.sp[-1], id, &f.regs.sp[-1]))
52815:         THROW();
54169:     if (!ObjIncOp<-1, true, strict>(f, obj, id))
52815:         THROW();
52815:     f.regs.sp[-3] = f.regs.sp[-1];
52815: }
52815: 
54169: template void JS_FASTCALL stubs::ElemDec<true>(VMFrame &f);
54169: template void JS_FASTCALL stubs::ElemDec<false>(VMFrame &f);
54169: 
54169: template<JSBool strict>
52815: void JS_FASTCALL
52815: stubs::IncElem(VMFrame &f)
52815: {
52815:     JSObject *obj = ValueToObject(f.cx, &f.regs.sp[-2]);
52815:     if (!obj)
52815:         THROW();
52815:     jsid id;
52815:     if (!FetchElementId(f, obj, f.regs.sp[-1], id, &f.regs.sp[-1]))
52815:         THROW();
54169:     if (!ObjIncOp<1, false, strict>(f, obj, id))
52815:         THROW();
52815:     f.regs.sp[-3] = f.regs.sp[-1];
52815: }
52815: 
54169: template void JS_FASTCALL stubs::IncElem<true>(VMFrame &f);
54169: template void JS_FASTCALL stubs::IncElem<false>(VMFrame &f);
54169: 
54169: template<JSBool strict>
52815: void JS_FASTCALL
52815: stubs::DecElem(VMFrame &f)
52815: {
52815:     JSObject *obj = ValueToObject(f.cx, &f.regs.sp[-2]);
52815:     if (!obj)
52815:         THROW();
52815:     jsid id;
52815:     if (!FetchElementId(f, obj, f.regs.sp[-1], id, &f.regs.sp[-1]))
52815:         THROW();
54169:     if (!ObjIncOp<-1, false, strict>(f, obj, id))
52815:         THROW();
52815:     f.regs.sp[-3] = f.regs.sp[-1];
52815: }
52815: 
54169: template void JS_FASTCALL stubs::DecElem<true>(VMFrame &f);
54169: template void JS_FASTCALL stubs::DecElem<false>(VMFrame &f);
54169: 
54169: template<JSBool strict>
52815: void JS_FASTCALL
52732: stubs::NameInc(VMFrame &f, JSAtom *atom)
52732: {
53840:     JSObject *obj = &f.fp()->scopeChain();
54169:     if (!NameIncDec<1, true, strict>(f, obj, atom))
52732:         THROW();
52732: }
52732: 
54169: template void JS_FASTCALL stubs::NameInc<true>(VMFrame &f, JSAtom *atom);
54169: template void JS_FASTCALL stubs::NameInc<false>(VMFrame &f, JSAtom *atom);
54169: 
54169: template<JSBool strict>
52732: void JS_FASTCALL
52732: stubs::NameDec(VMFrame &f, JSAtom *atom)
52732: {
53840:     JSObject *obj = &f.fp()->scopeChain();
54169:     if (!NameIncDec<-1, true, strict>(f, obj, atom))
52732:         THROW();
52732: }
52732: 
54169: template void JS_FASTCALL stubs::NameDec<true>(VMFrame &f, JSAtom *atom);
54169: template void JS_FASTCALL stubs::NameDec<false>(VMFrame &f, JSAtom *atom);
54169: 
54169: template<JSBool strict>
52732: void JS_FASTCALL
52732: stubs::IncName(VMFrame &f, JSAtom *atom)
52732: {
53840:     JSObject *obj = &f.fp()->scopeChain();
54169:     if (!NameIncDec<1, false, strict>(f, obj, atom))
52732:         THROW();
52732: }
52732: 
54169: template void JS_FASTCALL stubs::IncName<true>(VMFrame &f, JSAtom *atom);
54169: template void JS_FASTCALL stubs::IncName<false>(VMFrame &f, JSAtom *atom);
54169: 
54169: template<JSBool strict>
52732: void JS_FASTCALL
52732: stubs::DecName(VMFrame &f, JSAtom *atom)
52732: {
53840:     JSObject *obj = &f.fp()->scopeChain();
54169:     if (!NameIncDec<-1, false, strict>(f, obj, atom))
52825:         THROW();
52825: }
52825: 
54169: template void JS_FASTCALL stubs::DecName<true>(VMFrame &f, JSAtom *atom);
54169: template void JS_FASTCALL stubs::DecName<false>(VMFrame &f, JSAtom *atom);
54169: 
54169: template<JSBool strict>
52825: void JS_FASTCALL
52825: stubs::GlobalNameInc(VMFrame &f, JSAtom *atom)
52825: {
53840:     JSObject *obj = f.fp()->scopeChain().getGlobal();
54169:     if (!NameIncDec<1, true, strict>(f, obj, atom))
52825:         THROW();
52825: }
52825: 
54169: template void JS_FASTCALL stubs::GlobalNameInc<true>(VMFrame &f, JSAtom *atom);
54169: template void JS_FASTCALL stubs::GlobalNameInc<false>(VMFrame &f, JSAtom *atom);
54169: 
54169: template<JSBool strict>
52825: void JS_FASTCALL
52825: stubs::GlobalNameDec(VMFrame &f, JSAtom *atom)
52825: {
53840:     JSObject *obj = f.fp()->scopeChain().getGlobal();
54169:     if (!NameIncDec<-1, true, strict>(f, obj, atom))
52825:         THROW();
52825: }
52825: 
54169: template void JS_FASTCALL stubs::GlobalNameDec<true>(VMFrame &f, JSAtom *atom);
54169: template void JS_FASTCALL stubs::GlobalNameDec<false>(VMFrame &f, JSAtom *atom);
54169: 
54169: template<JSBool strict>
52825: void JS_FASTCALL
52825: stubs::IncGlobalName(VMFrame &f, JSAtom *atom)
52825: {
53840:     JSObject *obj = f.fp()->scopeChain().getGlobal();
54169:     if (!NameIncDec<1, false, strict>(f, obj, atom))
52825:         THROW();
52825: }
52825: 
54169: template void JS_FASTCALL stubs::IncGlobalName<true>(VMFrame &f, JSAtom *atom);
54169: template void JS_FASTCALL stubs::IncGlobalName<false>(VMFrame &f, JSAtom *atom);
54169: 
54169: template<JSBool strict>
52825: void JS_FASTCALL
52825: stubs::DecGlobalName(VMFrame &f, JSAtom *atom)
52825: {
53840:     JSObject *obj = f.fp()->scopeChain().getGlobal();
54169:     if (!NameIncDec<-1, false, strict>(f, obj, atom))
52732:         THROW();
52732: }
52732: 
54169: template void JS_FASTCALL stubs::DecGlobalName<true>(VMFrame &f, JSAtom *atom);
54169: template void JS_FASTCALL stubs::DecGlobalName<false>(VMFrame &f, JSAtom *atom);
54169: 
52761: static bool JS_FASTCALL
52761: InlineGetProp(VMFrame &f)
52741: {
52741:     JSContext *cx = f.cx;
52741:     JSFrameRegs &regs = f.regs;
52741: 
52741:     Value *vp = &f.regs.sp[-1];
52741:     JSObject *obj = ValueToObject(f.cx, vp);
52741:     if (!obj)
52761:         return false;
52741: 
52741:     Value rval;
52741:     do {
52741:         /*
52741:          * We do not impose the method read barrier if in an imacro,
52741:          * assuming any property gets it does (e.g., for 'toString'
52741:          * from JSOP_NEW) will not be leaked to the calling script.
52741:          */
52741:         JSObject *aobj = js_GetProtoIfDenseArray(obj);
52741: 
52741:         PropertyCacheEntry *entry;
52741:         JSObject *obj2;
52741:         JSAtom *atom;
52741:         JS_PROPERTY_CACHE(cx).test(cx, regs.pc, aobj, obj2, entry, atom);
52741:         if (!atom) {
52741:             if (entry->vword.isFunObj()) {
53023:                 rval.setObject(entry->vword.toFunObj());
52741:             } else if (entry->vword.isSlot()) {
52741:                 uint32 slot = entry->vword.toSlot();
56567:                 rval = obj2->nativeGetSlot(slot);
52741:             } else {
53531:                 JS_ASSERT(entry->vword.isShape());
53531:                 const Shape *shape = entry->vword.toShape();
53531:                 NATIVE_GET(cx, obj, obj2, shape,
53840:                         f.fp()->hasImacropc() ? JSGET_NO_METHOD_BARRIER : JSGET_METHOD_BARRIER,
52761:                         &rval, return false);
52741:             }
52741:             break;
52741:         }
52741: 
52741:         jsid id = ATOM_TO_JSID(atom);
53244:         if (JS_LIKELY(!aobj->getOps()->getProperty)
52741:                 ? !js_GetPropertyHelper(cx, obj, id,
53840:                     f.fp()->hasImacropc()
52741:                     ? JSGET_CACHE_RESULT | JSGET_NO_METHOD_BARRIER
52741:                     : JSGET_CACHE_RESULT | JSGET_METHOD_BARRIER,
52741:                     &rval)
52741:                 : !obj->getProperty(cx, id, &rval)) {
52761:             return false;
52741:         }
52741:     } while(0);
52741: 
52741:     regs.sp[-1] = rval;
52761:     return true;
52761: }
52761: 
52761: void JS_FASTCALL
52761: stubs::GetProp(VMFrame &f)
52761: {
52761:     if (!InlineGetProp(f))
52761:         THROW();
52761: }
52761: 
52761: void JS_FASTCALL
56201: stubs::GetPropNoCache(VMFrame &f, JSAtom *atom)
56201: {
56201:     JSContext *cx = f.cx;
56201: 
56201:     Value *vp = &f.regs.sp[-1];
56201:     JSObject *obj = ValueToObject(cx, vp);
56201:     if (!obj)
56201:         THROW();
56201: 
56201:     if (!obj->getProperty(cx, ATOM_TO_JSID(atom), vp))
56201:         THROW();
56201: }
56201: 
56201: void JS_FASTCALL
52788: stubs::CallProp(VMFrame &f, JSAtom *origAtom)
52761: {
52761:     JSContext *cx = f.cx;
52761:     JSFrameRegs &regs = f.regs;
52761: 
52788:     Value lval;
52788:     lval = regs.sp[-1];
52788: 
52788:     Value objv;
52788:     if (lval.isObject()) {
52788:         objv = lval;
52788:     } else {
52788:         JSProtoKey protoKey;
52788:         if (lval.isString()) {
52788:             protoKey = JSProto_String;
52788:         } else if (lval.isNumber()) {
52788:             protoKey = JSProto_Number;
52788:         } else if (lval.isBoolean()) {
52788:             protoKey = JSProto_Boolean;
52788:         } else {
52788:             JS_ASSERT(lval.isNull() || lval.isUndefined());
52788:             js_ReportIsNullOrUndefined(cx, -1, lval, NULL);
52761:             THROW();
52788:         }
52788:         JSObject *pobj;
52788:         if (!js_GetClassPrototype(cx, NULL, protoKey, &pobj))
52788:             THROW();
53023:         objv.setObject(*pobj);
52788:     }
52761: 
53081:     JSObject *aobj = js_GetProtoIfDenseArray(&objv.toObject());
52788:     Value rval;
52761: 
52788:     PropertyCacheEntry *entry;
52788:     JSObject *obj2;
52788:     JSAtom *atom;
52788:     JS_PROPERTY_CACHE(cx).test(cx, regs.pc, aobj, obj2, entry, atom);
52788:     if (!atom) {
52788:         if (entry->vword.isFunObj()) {
53023:             rval.setObject(entry->vword.toFunObj());
52788:         } else if (entry->vword.isSlot()) {
52788:             uint32 slot = entry->vword.toSlot();
56567:             rval = obj2->nativeGetSlot(slot);
52788:         } else {
53531:             JS_ASSERT(entry->vword.isShape());
53531:             const Shape *shape = entry->vword.toShape();
53531:             NATIVE_GET(cx, &objv.toObject(), obj2, shape, JSGET_NO_METHOD_BARRIER, &rval,
52788:                        THROW());
52788:         }
52788:         regs.sp++;
52788:         regs.sp[-2] = rval;
52788:         regs.sp[-1] = lval;
55713:     } else {
52788:         /*
52788:          * Cache miss: use the immediate atom that was loaded for us under
52788:          * PropertyCache::test.
52788:          */
52788:         jsid id;
52788:         id = ATOM_TO_JSID(origAtom);
52788: 
52788:         regs.sp++;
52788:         regs.sp[-1].setNull();
52788:         if (lval.isObject()) {
53081:             if (!js_GetMethod(cx, &objv.toObject(), id,
53244:                               JS_LIKELY(!aobj->getOps()->getProperty)
52788:                               ? JSGET_CACHE_RESULT | JSGET_NO_METHOD_BARRIER
52788:                               : JSGET_NO_METHOD_BARRIER,
52788:                               &rval)) {
52788:                 THROW();
52788:             }
52788:             regs.sp[-1] = objv;
52788:             regs.sp[-2] = rval;
52788:         } else {
53244:             JS_ASSERT(!objv.toObject().getOps()->getProperty);
53081:             if (!js_GetPropertyHelper(cx, &objv.toObject(), id,
52788:                                       JSGET_CACHE_RESULT | JSGET_NO_METHOD_BARRIER,
52788:                                       &rval)) {
52788:                 THROW();
52788:             }
52788:             regs.sp[-1] = lval;
52788:             regs.sp[-2] = rval;
52788:         }
52761:     }
52761: #if JS_HAS_NO_SUCH_METHOD
55713:     if (JS_UNLIKELY(rval.isUndefined()) && regs.sp[-1].isObject()) {
52788:         regs.sp[-2].setString(ATOM_TO_STRING(origAtom));
52761:         if (!js_OnUnknownMethod(cx, regs.sp - 2))
52761:             THROW();
52761:     }
52788: #endif
52741: }
52741: 
52741: void JS_FASTCALL
52762: stubs::Length(VMFrame &f)
52762: {
52762:     JSFrameRegs &regs = f.regs;
52762:     Value *vp = &regs.sp[-1];
52762: 
52762:     if (vp->isString()) {
53081:         vp->setInt32(vp->toString()->length());
52762:         return;
52762:     } else if (vp->isObject()) {
53081:         JSObject *obj = &vp->toObject();
52762:         if (obj->isArray()) {
52762:             jsuint length = obj->getArrayLength();
53182:             regs.sp[-1].setNumber(length);
52762:             return;
52762:         } else if (obj->isArguments() && !obj->isArgsLengthOverridden()) {
53446:             uint32 length = obj->getArgsInitialLength();
52762:             JS_ASSERT(length < INT32_MAX);
52762:             regs.sp[-1].setInt32(int32_t(length));
52762:             return;
52762:         }
52762:     }
52762: 
52762:     if (!InlineGetProp(f))
52762:         THROW();
52762: }
52762: 
52762: void JS_FASTCALL
52733: stubs::Iter(VMFrame &f, uint32 flags)
52733: {
52733:     if (!js_ValueToIterator(f.cx, flags, &f.regs.sp[-1]))
52733:         THROW();
52733:     JS_ASSERT(!f.regs.sp[-1].isPrimitive());
52733: }
52733: 
52735: static void
52735: InitPropOrMethod(VMFrame &f, JSAtom *atom, JSOp op)
52735: {
52735:     JSContext *cx = f.cx;
52735:     JSRuntime *rt = cx->runtime;
52735:     JSFrameRegs &regs = f.regs;
52735: 
52735:     /* Load the property's initial value into rval. */
53482:     JS_ASSERT(regs.sp - f.fp()->base() >= 2);
52735:     Value rval;
52735:     rval = regs.sp[-1];
52735: 
52735:     /* Load the object being initialized into lval/obj. */
53081:     JSObject *obj = &regs.sp[-2].toObject();
52735:     JS_ASSERT(obj->isNative());
52735: 
52735:     /*
52735:      * Probe the property cache.
52735:      *
52735:      * We can not assume that the object created by JSOP_NEWINIT is still
52735:      * single-threaded as the debugger can access it from other threads.
52735:      * So check first.
52735:      *
53531:      * On a hit, if the cached shape has a non-default setter, it must be
53531:      * __proto__. If shape->previous() != obj->lastProperty(), there must be a
52735:      * repeated property name. The fast path does not handle these two cases.
52735:      */
52735:     PropertyCacheEntry *entry;
53531:     const Shape *shape;
56567:     if (JS_PROPERTY_CACHE(cx).testForInit(rt, regs.pc, obj, &shape, &entry) &&
53531:         shape->hasDefaultSetter() &&
53531:         shape->previous() == obj->lastProperty())
52735:     {
52735:         /* Fast path. Property cache hit. */
53531:         uint32 slot = shape->slot;
53531: 
53652:         JS_ASSERT(slot == obj->slotSpan());
53531:         JS_ASSERT(slot >= JSSLOT_FREE(obj->getClass()));
52735:         if (slot < obj->numSlots()) {
53531:             JS_ASSERT(obj->getSlot(slot).isUndefined());
52735:         } else {
53531:             if (!obj->allocSlot(cx, &slot))
52735:                 THROW();
53531:             JS_ASSERT(slot == shape->slot);
52735:         }
52735: 
53531:         /* A new object, or one we just extended in a recent initprop op. */
53531:         JS_ASSERT(!obj->lastProperty() ||
53531:                   obj->shape() == obj->lastProperty()->shape);
53531:         obj->extend(cx, shape);
52735: 
52735:         /*
52735:          * No method change check here because here we are adding a new
52735:          * property, not updating an existing slot's value that might
53531:          * contain a method of a branded shape.
52735:          */
56567:         obj->nativeSetSlot(slot, rval);
52735:     } else {
52735:         PCMETER(JS_PROPERTY_CACHE(cx).inipcmisses++);
52735: 
52735:         /* Get the immediate property name into id. */
52735:         jsid id = ATOM_TO_JSID(atom);
52735: 
52735:         uintN defineHow = (op == JSOP_INITMETHOD)
52735:                           ? JSDNP_CACHE_RESULT | JSDNP_SET_METHOD
52735:                           : JSDNP_CACHE_RESULT;
52735:         if (!(JS_UNLIKELY(atom == cx->runtime->atomState.protoAtom)
56760:               ? js_SetPropertyHelper(cx, obj, id, defineHow, &rval, false)
52735:               : js_DefineNativeProperty(cx, obj, id, rval, NULL, NULL,
52735:                                         JSPROP_ENUMERATE, 0, 0, NULL,
52735:                                         defineHow))) {
52735:             THROW();
52735:         }
52735:     }
52735: }
52735: 
52735: void JS_FASTCALL
52735: stubs::InitProp(VMFrame &f, JSAtom *atom)
52735: {
52735:     InitPropOrMethod(f, atom, JSOP_INITPROP);
52735: }
52735: 
52737: void JS_FASTCALL
52783: stubs::InitMethod(VMFrame &f, JSAtom *atom)
52783: {
52783:     InitPropOrMethod(f, atom, JSOP_INITMETHOD);
52783: }
52783: 
52783: void JS_FASTCALL
52737: stubs::IterNext(VMFrame &f)
52737: {
53482:     JS_ASSERT(f.regs.sp - 1 >= f.fp()->base());
52737:     JS_ASSERT(f.regs.sp[-1].isObject());
52737: 
53081:     JSObject *iterobj = &f.regs.sp[-1].toObject();
52737:     f.regs.sp[0].setNull();
52737:     f.regs.sp++;
52737:     if (!js_IteratorNext(f.cx, iterobj, &f.regs.sp[-1]))
52737:         THROW();
52737: }
52737: 
52737: JSBool JS_FASTCALL
52737: stubs::IterMore(VMFrame &f)
52737: {
53482:     JS_ASSERT(f.regs.sp - 1 >= f.fp()->base());
52737:     JS_ASSERT(f.regs.sp[-1].isObject());
52737: 
52737:     Value v;
53081:     JSObject *iterobj = &f.regs.sp[-1].toObject();
52737:     if (!js_IteratorMore(f.cx, iterobj, &v))
52737:         THROWV(JS_FALSE);
52737: 
53081:     return v.toBoolean();
52737: }
52737: 
52737: void JS_FASTCALL
52737: stubs::EndIter(VMFrame &f)
52737: {
53482:     JS_ASSERT(f.regs.sp - 1 >= f.fp()->base());
53100:     if (!js_CloseIterator(f.cx, &f.regs.sp[-1].toObject()))
52737:         THROW();
52737: }
52737: 
52738: JSString * JS_FASTCALL
52738: stubs::TypeOf(VMFrame &f)
52738: {
52738:     const Value &ref = f.regs.sp[-1];
52738:     JSType type = JS_TypeOfValue(f.cx, Jsvalify(ref));
52738:     JSAtom *atom = f.cx->runtime->atomState.typeAtoms[type];
52738:     return ATOM_TO_STRING(atom);
52738: }
52738: 
53513: void JS_FASTCALL
52739: stubs::StrictEq(VMFrame &f)
52739: {
52739:     const Value &rhs = f.regs.sp[-1];
52739:     const Value &lhs = f.regs.sp[-2];
59890:     JSBool equal;
59890:     if (!StrictlyEqual(f.cx, lhs, rhs, &equal))
59890:         THROW();
53513:     f.regs.sp--;
59908:     f.regs.sp[-1].setBoolean(equal == JS_TRUE);
52739: }
52739: 
53513: void JS_FASTCALL
52739: stubs::StrictNe(VMFrame &f)
52739: {
52739:     const Value &rhs = f.regs.sp[-1];
52739:     const Value &lhs = f.regs.sp[-2];
59890:     JSBool equal;
59890:     if (!StrictlyEqual(f.cx, lhs, rhs, &equal))
59890:         THROW();
53513:     f.regs.sp--;
59908:     f.regs.sp[-1].setBoolean(equal != JS_TRUE);
52739: }
52739: 
52772: void JS_FASTCALL
52772: stubs::Throw(VMFrame &f)
52772: {
52772:     JSContext *cx = f.cx;
52772: 
60211:     JS_ASSERT(!cx->isExceptionPending());
60211:     cx->setPendingException(f.regs.sp[-1]);
52772:     THROW();
52772: }
52772: 
52775: JSObject * JS_FASTCALL
52775: stubs::FlatLambda(VMFrame &f, JSFunction *fun)
52775: {
55527:     JSObject *obj = js_NewFlatClosure(f.cx, fun, JSOP_LAMBDA_FC, JSOP_LAMBDA_FC_LENGTH);
52775:     if (!obj)
52775:         THROWV(NULL);
52775:     return obj;
52775: }
52775: 
52778: void JS_FASTCALL
52778: stubs::Arguments(VMFrame &f)
52778: {
52778:     f.regs.sp++;
53482:     if (!js_GetArgsValue(f.cx, f.fp(), &f.regs.sp[-1]))
52778:         THROW();
52778: }
52778: 
52780: JSBool JS_FASTCALL
52780: stubs::InstanceOf(VMFrame &f)
52780: {
52780:     JSContext *cx = f.cx;
52780:     JSFrameRegs &regs = f.regs;
52780: 
52780:     const Value &rref = regs.sp[-1];
53155:     if (rref.isPrimitive()) {
52780:         js_ReportValueError(cx, JSMSG_BAD_INSTANCEOF_RHS,
52780:                             -1, rref, NULL);
52780:         THROWV(JS_FALSE);
52780:     }
53155:     JSObject *obj = &rref.toObject();
52780:     const Value &lref = regs.sp[-2];
52780:     JSBool cond = JS_FALSE;
53161:     if (!HasInstance(cx, obj, &lref, &cond))
52780:         THROWV(JS_FALSE);
52894:     f.regs.sp[-2].setBoolean(cond);
52780:     return cond;
52780: }
52780: 
52911: void JS_FASTCALL
52894: stubs::FastInstanceOf(VMFrame &f)
52894: {
52894:     const Value &lref = f.regs.sp[-1];
52894: 
52894:     if (lref.isPrimitive()) {
52894:         /*
52894:          * Throw a runtime error if instanceof is called on a function that
52894:          * has a non-object as its .prototype value.
52894:          */
52894:         js_ReportValueError(f.cx, JSMSG_BAD_PROTOTYPE, -1, f.regs.sp[-2], NULL);
52911:         THROW();
52894:     }
52894: 
53081:     f.regs.sp[-3].setBoolean(js_IsDelegate(f.cx, &lref.toObject(), f.regs.sp[-3]));
52894: }
52781: 
52781: void JS_FASTCALL
52781: stubs::ArgCnt(VMFrame &f)
52781: {
52781:     JSContext *cx = f.cx;
52781:     JSRuntime *rt = cx->runtime;
53482:     JSStackFrame *fp = f.fp();
52781: 
52781:     jsid id = ATOM_TO_JSID(rt->atomState.lengthAtom);
52781:     f.regs.sp++;
52781:     if (!js_GetArgsProperty(cx, fp, id, &f.regs.sp[-1]))
52781:         THROW();
52781: }
52781: 
52785: void JS_FASTCALL
52785: stubs::EnterBlock(VMFrame &f, JSObject *obj)
52785: {
52785:     JSFrameRegs &regs = f.regs;
54855: #ifdef DEBUG
53482:     JSStackFrame *fp = f.fp();
54855: #endif
52785: 
53650:     JS_ASSERT(obj->isStaticBlock());
52785:     JS_ASSERT(fp->base() + OBJ_BLOCK_DEPTH(cx, obj) == regs.sp);
52785:     Value *vp = regs.sp + OBJ_BLOCK_COUNT(cx, obj);
52785:     JS_ASSERT(regs.sp < vp);
53840:     JS_ASSERT(vp <= fp->slots() + fp->script()->nslots);
52785:     SetValueRangeToUndefined(regs.sp, vp);
52785:     regs.sp = vp;
52785: 
52785: #ifdef DEBUG
52787:     JSContext *cx = f.cx;
52785: 
52785:     /*
53840:      * The young end of fp->scopeChain() may omit blocks if we haven't closed
53840:      * over them, but if there are any closure blocks on fp->scopeChain(), they'd
52785:      * better be (clones of) ancestors of the block we're entering now;
53840:      * anything else we should have popped off fp->scopeChain() when we left its
52785:      * static scope.
52785:      */
53840:     JSObject *obj2 = &fp->scopeChain();
52785:     Class *clasp;
52785:     while ((clasp = obj2->getClass()) == &js_WithClass)
52785:         obj2 = obj2->getParent();
52785:     if (clasp == &js_BlockClass &&
52785:         obj2->getPrivate() == js_FloatingFrameIfGenerator(cx, fp)) {
52785:         JSObject *youngestProto = obj2->getProto();
53650:         JS_ASSERT(youngestProto->isStaticBlock());
52785:         JSObject *parent = obj;
52785:         while ((parent = parent->getParent()) != youngestProto)
52785:             JS_ASSERT(parent);
52785:     }
52785: #endif
52785: }
52785: 
52785: void JS_FASTCALL
54855: stubs::LeaveBlock(VMFrame &f, JSObject *blockChain)
52785: {
52785:     JSContext *cx = f.cx;
53482:     JSStackFrame *fp = f.fp();
52785: 
52785: #ifdef DEBUG
54855:     JS_ASSERT(blockChain->isStaticBlock());
54855:     uintN blockDepth = OBJ_BLOCK_DEPTH(cx, blockChain);
52785: 
53840:     JS_ASSERT(blockDepth <= StackDepth(fp->script()));
52785: #endif
52785:     /*
52785:      * If we're about to leave the dynamic scope of a block that has been
53840:      * cloned onto fp->scopeChain(), clear its private data, move its locals from
52785:      * the stack into the clone, and pop it off the chain.
52785:      */
53840:     JSObject *obj = &fp->scopeChain();
54855:     if (obj->getProto() == blockChain) {
52785:         JS_ASSERT(obj->getClass() == &js_BlockClass);
52785:         if (!js_PutBlockObject(cx, JS_TRUE))
52785:             THROW();
52785:     }
52785: }
52785: 
52793: void * JS_FASTCALL
52793: stubs::LookupSwitch(VMFrame &f, jsbytecode *pc)
52793: {
52793:     jsbytecode *jpc = pc;
53840:     JSScript *script = f.fp()->script();
58993:     bool ctor = f.fp()->isConstructing();
52793: 
52793:     /* This is correct because the compiler adjusts the stack beforehand. */
52793:     Value lval = f.regs.sp[-1];
52793: 
52793:     if (!lval.isPrimitive()) {
58993:         void* native = script->nativeCodeForPC(ctor, pc + GET_JUMP_OFFSET(pc));
58993:         JS_ASSERT(native);
58993:         return native;
52793:     }
52793: 
52793:     JS_ASSERT(pc[0] == JSOP_LOOKUPSWITCH);
52793: 
52793:     pc += JUMP_OFFSET_LEN;
52793:     uint32 npairs = GET_UINT16(pc);
52793:     pc += UINT16_LEN;
52793: 
52793:     JS_ASSERT(npairs);
52793: 
52793:     if (lval.isString()) {
59890:         JSLinearString *str = lval.toString()->ensureLinear(f.cx);
59890:         if (!str)
59890:             THROWV(NULL);
52793:         for (uint32 i = 1; i <= npairs; i++) {
52793:             Value rval = script->getConst(GET_INDEX(pc));
52793:             pc += INDEX_LEN;
52793:             if (rval.isString()) {
59890:                 JSLinearString *rhs = rval.toString()->assertIsLinear();
59890:                 if (rhs == str || EqualStrings(str, rhs)) {
58993:                     void* native = script->nativeCodeForPC(ctor,
58993:                                                            jpc + GET_JUMP_OFFSET(pc));
58993:                     JS_ASSERT(native);
58993:                     return native;
52793:                 }
52793:             }
52793:             pc += JUMP_OFFSET_LEN;
52793:         }
52793:     } else if (lval.isNumber()) {
53081:         double d = lval.toNumber();
52793:         for (uint32 i = 1; i <= npairs; i++) {
52793:             Value rval = script->getConst(GET_INDEX(pc));
52793:             pc += INDEX_LEN;
53081:             if (rval.isNumber() && d == rval.toNumber()) {
58993:                 void* native = script->nativeCodeForPC(ctor,
58993:                                                        jpc + GET_JUMP_OFFSET(pc));
58993:                 JS_ASSERT(native);
58993:                 return native;
52793:             }
52793:             pc += JUMP_OFFSET_LEN;
52793:         }
52793:     } else {
52793:         for (uint32 i = 1; i <= npairs; i++) {
52793:             Value rval = script->getConst(GET_INDEX(pc));
52793:             pc += INDEX_LEN;
52793:             if (lval == rval) {
58993:                 void* native = script->nativeCodeForPC(ctor,
58993:                                                        jpc + GET_JUMP_OFFSET(pc));
58993:                 JS_ASSERT(native);
58993:                 return native;
52793:             }
52793:             pc += JUMP_OFFSET_LEN;
52793:         }
52793:     }
52793: 
58993:     void* native = script->nativeCodeForPC(ctor, jpc + GET_JUMP_OFFSET(jpc));
58993:     JS_ASSERT(native);
58993:     return native;
52793: }
52793: 
52794: void * JS_FASTCALL
52794: stubs::TableSwitch(VMFrame &f, jsbytecode *origPc)
52794: {
52794:     jsbytecode * const originalPC = origPc;
52794:     jsbytecode *pc = originalPC;
52794:     uint32 jumpOffset = GET_JUMP_OFFSET(pc);
52794:     pc += JUMP_OFFSET_LEN;
52794: 
52794:     /* Note: compiler adjusts the stack beforehand. */
52794:     Value rval = f.regs.sp[-1];
52794: 
52794:     jsint tableIdx;
52794:     if (rval.isInt32()) {
53081:         tableIdx = rval.toInt32();
52794:     } else if (rval.isDouble()) {
53081:         double d = rval.toDouble();
52794:         if (d == 0) {
52794:             /* Treat -0 (double) as 0. */
52794:             tableIdx = 0;
53051:         } else if (!JSDOUBLE_IS_INT32(d, (int32_t *)&tableIdx)) {
52794:             goto finally;
52794:         }
52794:     } else {
52794:         goto finally;
52794:     }
52794: 
52794:     {
59979:         jsint low = GET_JUMP_OFFSET(pc);
52794:         pc += JUMP_OFFSET_LEN;
59979:         jsint high = GET_JUMP_OFFSET(pc);
52794:         pc += JUMP_OFFSET_LEN;
52794: 
52794:         tableIdx -= low;
52794:         if ((jsuint) tableIdx < (jsuint)(high - low + 1)) {
52794:             pc += JUMP_OFFSET_LEN * tableIdx;
52794:             uint32 candidateOffset = GET_JUMP_OFFSET(pc);
52794:             if (candidateOffset)
52794:                 jumpOffset = candidateOffset;
52794:         }
52794:     }
52794: 
52794: finally:
58993:     /* Provide the native address. */
55520:     JSScript* script = f.fp()->script();
58993:     void* native = script->nativeCodeForPC(f.fp()->isConstructing(),
58993:                                            originalPC + jumpOffset);
58993:     JS_ASSERT(native);
58993:     return native;
52794: }
52794: 
52874: void JS_FASTCALL
52874: stubs::Unbrand(VMFrame &f)
52874: {
55713:     const Value &thisv = f.regs.sp[-1];
55713:     if (!thisv.isObject())
55713:         return;
55713:     JSObject *obj = &thisv.toObject();
59227:     if (obj->isNative())
59227:         obj->unbrand(f.cx);
52874: }
52874: 
52916: void JS_FASTCALL
52916: stubs::Pos(VMFrame &f)
52916: {
52916:     if (!ValueToNumber(f.cx, &f.regs.sp[-1]))
52916:         THROW();
52916: }
52916: 
53037: void JS_FASTCALL
53037: stubs::ArgSub(VMFrame &f, uint32 n)
53037: {
53037:     jsid id = INT_TO_JSID(n);
53037:     Value rval;
53482:     if (!js_GetArgsProperty(f.cx, f.fp(), id, &rval))
53037:         THROW();
53037:     f.regs.sp[0] = rval;
53037: }
53037: 
54409: void JS_FASTCALL
54409: stubs::DelName(VMFrame &f, JSAtom *atom)
54409: {
54409:     jsid id = ATOM_TO_JSID(atom);
54409:     JSObject *obj, *obj2;
54409:     JSProperty *prop;
54409:     if (!js_FindProperty(f.cx, id, &obj, &obj2, &prop))
54409:         THROW();
54409: 
54409:     /* Strict mode code should never contain JSOP_DELNAME opcodes. */
54409:     JS_ASSERT(!f.fp()->script()->strictModeCode);
54409: 
54409:     /* ECMA says to return true if name is undefined or inherited. */
54409:     f.regs.sp++;
54409:     f.regs.sp[-1] = BooleanValue(true);
54409:     if (prop) {
54409:         if (!obj->deleteProperty(f.cx, id, &f.regs.sp[-1], false))
54409:             THROW();
54409:     }
54409: }
54409: 
54406: template<JSBool strict>
54406: void JS_FASTCALL
54406: stubs::DelProp(VMFrame &f, JSAtom *atom)
54406: {
54406:     JSContext *cx = f.cx;
54406: 
54406:     JSObject *obj = ValueToObject(cx, &f.regs.sp[-1]);
54406:     if (!obj)
54406:         THROW();
54406: 
54406:     Value rval;
54406:     if (!obj->deleteProperty(cx, ATOM_TO_JSID(atom), &rval, strict))
54406:         THROW();
54406: 
54406:     f.regs.sp[-1] = rval;
54406: }
54406: 
54406: template void JS_FASTCALL stubs::DelProp<true>(VMFrame &f, JSAtom *atom);
54406: template void JS_FASTCALL stubs::DelProp<false>(VMFrame &f, JSAtom *atom);
54406: 
54406: template<JSBool strict>
54406: void JS_FASTCALL
54406: stubs::DelElem(VMFrame &f)
54406: {
54406:     JSContext *cx = f.cx;
54406: 
54406:     JSObject *obj = ValueToObject(cx, &f.regs.sp[-2]);
54406:     if (!obj)
54406:         THROW();
54406: 
54406:     jsid id;
54406:     if (!FetchElementId(f, obj, f.regs.sp[-1], id, &f.regs.sp[-1]))
54406:         THROW();
54406: 
54406:     if (!obj->deleteProperty(cx, id, &f.regs.sp[-2], strict))
54406:         THROW();
54406: }
54406: 
54408: void JS_FASTCALL
57795: stubs::DefVarOrConst(VMFrame &f, JSAtom *atom)
54408: {
54408:     JSContext *cx = f.cx;
54408:     JSStackFrame *fp = f.fp();
54408: 
54408:     JSObject *obj = &fp->varobj(cx);
54408:     JS_ASSERT(!obj->getOps()->defineProperty);
54408:     uintN attrs = JSPROP_ENUMERATE;
54408:     if (!fp->isEvalFrame())
54408:         attrs |= JSPROP_PERMANENT;
54408: 
54408:     /* Lookup id in order to check for redeclaration problems. */
54408:     jsid id = ATOM_TO_JSID(atom);
62411:     bool shouldDefine;
57795:     if (JSOp(*f.regs.pc) == JSOP_DEFVAR) {
54408:         /*
54408:          * Redundant declaration of a |var|, even one for a non-writable
54408:          * property like |undefined| in ES5, does nothing.
54408:          */
62411:         JSProperty *prop;
62411:         JSObject *obj2;
54408:         if (!obj->lookupProperty(cx, id, &obj2, &prop))
54408:             THROW();
62411:         shouldDefine = (!prop || obj2 != obj);
57795:     } else {
62411:         JS_ASSERT(JSOp(*f.regs.pc) == JSOP_DEFCONST);
62411:         attrs |= JSPROP_READONLY;
62411:         if (!CheckRedeclaration(cx, obj, id, attrs))
57795:             THROW();
62411: 
62411:         /*
62411:          * As attrs includes readonly, CheckRedeclaration can succeed only
62411:          * if prop does not exist.
62411:          */
62411:         shouldDefine = true;
57795:     }
54408: 
54408:     /* Bind a variable only if it's not yet defined. */
62411:     if (shouldDefine && 
62411:         !js_DefineNativeProperty(cx, obj, id, UndefinedValue(), PropertyStub, StrictPropertyStub,
62411:                                      attrs, 0, 0, NULL)) {
54408:         THROW();
54408:     }
54408: }
54408: 
57795: void JS_FASTCALL
57795: stubs::SetConst(VMFrame &f, JSAtom *atom)
57795: {
57795:     JSContext *cx = f.cx;
57795:     JSStackFrame *fp = f.fp();
57795: 
57795:     JSObject *obj = &fp->varobj(cx);
57795:     const Value &ref = f.regs.sp[-1];
57795:     if (!obj->defineProperty(cx, ATOM_TO_JSID(atom), ref,
62395:                              PropertyStub, StrictPropertyStub,
57795:                              JSPROP_ENUMERATE | JSPROP_PERMANENT | JSPROP_READONLY)) {
57795:         THROW();
57795:     }
57795: }
57795: 
54413: JSBool JS_FASTCALL
54413: stubs::In(VMFrame &f)
54413: {
54413:     JSContext *cx = f.cx;
54413: 
54413:     const Value &rref = f.regs.sp[-1];
54413:     if (!rref.isObject()) {
54413:         js_ReportValueError(cx, JSMSG_IN_NOT_OBJECT, -1, rref, NULL);
54413:         THROWV(JS_FALSE);
54413:     }
54413: 
54413:     JSObject *obj = &rref.toObject();
54413:     jsid id;
54413:     if (!FetchElementId(f, obj, f.regs.sp[-2], id, &f.regs.sp[-2]))
54413:         THROWV(JS_FALSE);
54413: 
54413:     JSObject *obj2;
54413:     JSProperty *prop;
54413:     if (!obj->lookupProperty(cx, id, &obj2, &prop))
54413:         THROWV(JS_FALSE);
54413: 
56568:     return !!prop;
54413: }
54413: 
54406: template void JS_FASTCALL stubs::DelElem<true>(VMFrame &f);
54406: template void JS_FASTCALL stubs::DelElem<false>(VMFrame &f);
54406: 
60211: void JS_FASTCALL
60211: stubs::Exception(VMFrame &f)
60211: {
60211:     f.regs.sp[0] = f.cx->getPendingException();
60211:     f.cx->clearPendingException();
60211: }
60164: template <bool Clamped>
60164: int32 JS_FASTCALL
60164: stubs::ConvertToTypedInt(JSContext *cx, Value *vp)
60164: {
60164:     JS_ASSERT(!vp->isInt32());
60164: 
60164:     if (vp->isDouble()) {
60164:         if (Clamped)
60164:             return js_TypedArray_uint8_clamp_double(vp->toDouble());
60164:         return js_DoubleToECMAInt32(vp->toDouble());
60164:     }
60164: 
60164:     if (vp->isNull() || vp->isObject() || vp->isUndefined())
60164:         return 0;
60164: 
60164:     if (vp->isBoolean())
60164:         return vp->toBoolean() ? 1 : 0;
60164: 
60164:     JS_ASSERT(vp->isString());
60164: 
60546:     int32 i32 = 0;
60164: #ifdef DEBUG
60164:     bool success = 
60164: #endif
60164:         StringToNumberType<jsint>(cx, vp->toString(), &i32);
60164:     JS_ASSERT(success);
60164: 
60164:     return i32;
60164: }
60164: 
60164: template int32 JS_FASTCALL stubs::ConvertToTypedInt<true>(JSContext *, Value *);
60164: template int32 JS_FASTCALL stubs::ConvertToTypedInt<false>(JSContext *, Value *);
60164: 
60164: void JS_FASTCALL
60164: stubs::ConvertToTypedFloat(JSContext *cx, Value *vp)
60164: {
60164:     JS_ASSERT(!vp->isDouble() && !vp->isInt32());
60164: 
60164:     if (vp->isNull()) {
60164:         vp->setDouble(0);
60164:     } else if (vp->isObject() || vp->isUndefined()) {
60164:         vp->setDouble(js_NaN);
60164:     } else if (vp->isBoolean()) {
60164:         vp->setDouble(vp->toBoolean() ? 1 : 0);
60164:     } else {
60164:         JS_ASSERT(vp->isString());
60546:         double d = 0;
60164: #ifdef DEBUG
60164:         bool success = 
60164: #endif
60164:             StringToNumberType<double>(cx, vp->toString(), &d);
60164:         JS_ASSERT(success);
60164:         vp->setDouble(d);
60164:     }
60164: }
60164: 
