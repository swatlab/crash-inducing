    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
98983: /* This Source Code Form is subject to the terms of the Mozilla Public
98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
    1: #include "nsUnicharUtils.h"
    1: 
    1: #include "nsHTMLEditor.h"
    1: #include "nsHTMLEditRules.h"
    1: #include "nsTextEditUtils.h"
    1: #include "nsHTMLEditUtils.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMAttr.h"
    1: #include "nsIDOMMouseEvent.h"
    1: #include "nsISelection.h"
    1: #include "nsISelectionPrivate.h"
    1: #include "nsIDOMHTMLImageElement.h"
    1: #include "nsISelectionController.h"
    1: #include "nsIDocumentObserver.h"
    1: #include "TypeInState.h"
    1: 
    1: #include "nsIEnumerator.h"
    1: #include "nsIContent.h"
    1: #include "nsIContentIterator.h"
    1: #include "nsAttrName.h"
    1: 
89176: #include "mozilla/dom/Element.h"
89176: 
89176: using namespace mozilla;
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::AddDefaultProperty(nsIAtom *aProperty, 
    1:                                             const nsAString & aAttribute, 
    1:                                             const nsAString & aValue)
    1: {
    1:   nsString outValue;
    1:   PRInt32 index;
    1:   nsString attr(aAttribute);
    1:   if (TypeInState::FindPropInList(aProperty, attr, &outValue, mDefaultStyles, index))
    1:   {
27986:     PropItem *item = mDefaultStyles[index];
    1:     item->value = aValue;
    1:   }
    1:   else
    1:   {
    1:     nsString value(aValue);
    1:     PropItem *propItem = new PropItem(aProperty, attr, value);
27986:     mDefaultStyles.AppendElement(propItem);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::RemoveDefaultProperty(nsIAtom *aProperty, 
    1:                                    const nsAString & aAttribute, 
    1:                                    const nsAString & aValue)
    1: {
    1:   nsString outValue;
    1:   PRInt32 index;
    1:   nsString attr(aAttribute);
    1:   if (TypeInState::FindPropInList(aProperty, attr, &outValue, mDefaultStyles, index))
    1:   {
27986:     delete mDefaultStyles[index];
    1:     mDefaultStyles.RemoveElementAt(index);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::RemoveAllDefaultProperties()
    1: {
27986:   PRUint32 j, defcon = mDefaultStyles.Length();
    1:   for (j=0; j<defcon; j++)
    1:   {
27986:     delete mDefaultStyles[j];
    1:   }
    1:   mDefaultStyles.Clear();
    1:   return NS_OK;
    1: }
    1: 
    1: 
96751: NS_IMETHODIMP
96751: nsHTMLEditor::SetInlineProperty(nsIAtom *aProperty,
    1:                                 const nsAString& aAttribute,
    1:                                 const nsAString& aValue)
    1: {
96751:   if (!aProperty) {
96751:     return NS_ERROR_NULL_POINTER;
96751:   }
96751:   if (!mRules) {
96751:     return NS_ERROR_NOT_INITIALIZED;
96751:   }
    1:   ForceCompositionEnd();
    1: 
99469:   nsRefPtr<nsTypedSelection> selection = GetTypedSelection();
43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
    1: 
98815:   if (selection->Collapsed()) {
96751:     // manipulating text attributes on a collapsed selection only sets state
96751:     // for the next text insertion
97756:     mTypeInState->SetProp(aProperty, aAttribute, aValue);
97756:     return NS_OK;
    1:   }
    1: 
    1:   nsAutoEditBatch batchIt(this);
    1:   nsAutoRules beginRulesSniffing(this, kOpInsertElement, nsIEditor::eNext);
    1:   nsAutoSelectionReset selectionResetter(selection, this);
    1:   nsAutoTxnsConserveSelection dontSpazMySelection(this);
    1: 
79445:   bool cancel, handled;
97808:   nsTextRulesInfo ruleInfo(kOpSetTextProperty);
99469:   nsresult res = mRules->WillDoAction(selection, &ruleInfo, &cancel, &handled);
43805:   NS_ENSURE_SUCCESS(res, res);
96751:   if (!cancel && !handled) {
    1:     // get selection range enumerator
    1:     nsCOMPtr<nsIEnumerator> enumerator;
99469:     res = selection->GetEnumerator(getter_AddRefs(enumerator));
43805:     NS_ENSURE_SUCCESS(res, res);
43806:     NS_ENSURE_TRUE(enumerator, NS_ERROR_FAILURE);
    1: 
    1:     // loop thru the ranges in the selection
    1:     nsCOMPtr<nsISupports> currentItem;
96751:     for (enumerator->First(); NS_ENUMERATOR_FALSE == enumerator->IsDone();
96751:          enumerator->Next()) {
    1:       res = enumerator->CurrentItem(getter_AddRefs(currentItem));
43805:       NS_ENSURE_SUCCESS(res, res);
43806:       NS_ENSURE_TRUE(currentItem, NS_ERROR_FAILURE);
    1: 
    1:       nsCOMPtr<nsIDOMRange> range(do_QueryInterface(currentItem));
    1: 
96751:       // adjust range to include any ancestors whose children are entirely
96751:       // selected
    1:       res = PromoteInlineRange(range);
43805:       NS_ENSURE_SUCCESS(res, res);
    1: 
    1:       // check for easy case: both range endpoints in same text node
    1:       nsCOMPtr<nsIDOMNode> startNode, endNode;
    1:       res = range->GetStartContainer(getter_AddRefs(startNode));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = range->GetEndContainer(getter_AddRefs(endNode));
43805:       NS_ENSURE_SUCCESS(res, res);
96751:       if (startNode == endNode && IsTextNode(startNode)) {
    1:         PRInt32 startOffset, endOffset;
    1:         range->GetStartOffset(&startOffset);
    1:         range->GetEndOffset(&endOffset);
    1:         nsCOMPtr<nsIDOMCharacterData> nodeAsText = do_QueryInterface(startNode);
96751:         res = SetInlinePropertyOnTextNode(nodeAsText, startOffset, endOffset,
96751:                                           aProperty, &aAttribute, &aValue);
43805:         NS_ENSURE_SUCCESS(res, res);
96751:         continue;
    1:       }
    1: 
96751:       // Not the easy case.  Range not contained in single text node.  There
96751:       // are up to three phases here.  There are all the nodes reported by the
96751:       // subtree iterator to be processed.  And there are potentially a
96751:       // starting textnode and an ending textnode which are only partially
96751:       // contained by the range.
96751: 
96751:       // Let's handle the nodes reported by the iterator.  These nodes are
96751:       // entirely contained in the selection range.  We build up a list of them
96751:       // (since doing operations on the document during iteration would perturb
96751:       // the iterator).
    1: 
    1:       nsCOMPtr<nsIContentIterator> iter =
    1:         do_CreateInstance("@mozilla.org/content/subtree-content-iterator;1", &res);
43805:       NS_ENSURE_SUCCESS(res, res);
43806:       NS_ENSURE_TRUE(iter, NS_ERROR_FAILURE);
    1: 
    1:       nsCOMArray<nsIDOMNode> arrayOfNodes;
    1: 
    1:       // iterate range and build up array
    1:       res = iter->Init(range);
96751:       // Init returns an error if there are no nodes in range.  This can easily
96751:       // happen with the subtree iterator if the selection doesn't contain any
96751:       // *whole* nodes.
96751:       if (NS_SUCCEEDED(res)) {
96751:         nsCOMPtr<nsIDOMNode> node;
96751:         for (; !iter->IsDone(); iter->Next()) {
    1:           node = do_QueryInterface(iter->GetCurrentNode());
43807:           NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
    1: 
96751:           if (IsEditable(node)) {
    1:             arrayOfNodes.AppendObject(node);
    1:           }
    1:         }
    1:       }
    1:       // first check the start parent of the range to see if it needs to
    1:       // be separately handled (it does if it's a text node, due to how the
    1:       // subtree iterator works - it will not have reported it).
96751:       if (IsTextNode(startNode) && IsEditable(startNode)) {
    1:         nsCOMPtr<nsIDOMCharacterData> nodeAsText = do_QueryInterface(startNode);
    1:         PRInt32 startOffset;
    1:         PRUint32 textLen;
    1:         range->GetStartOffset(&startOffset);
    1:         nodeAsText->GetLength(&textLen);
96751:         res = SetInlinePropertyOnTextNode(nodeAsText, startOffset, textLen,
96751:                                           aProperty, &aAttribute, &aValue);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1: 
    1:       // then loop through the list, set the property on each node
    1:       PRInt32 listCount = arrayOfNodes.Count();
    1:       PRInt32 j;
96751:       for (j = 0; j < listCount; j++) {
96751:         res = SetInlinePropertyOnNode(arrayOfNodes[j], aProperty,
96751:                                       &aAttribute, &aValue);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1: 
    1:       // last check the end parent of the range to see if it needs to
    1:       // be separately handled (it does if it's a text node, due to how the
    1:       // subtree iterator works - it will not have reported it).
96751:       if (IsTextNode(endNode) && IsEditable(endNode)) {
    1:         nsCOMPtr<nsIDOMCharacterData> nodeAsText = do_QueryInterface(endNode);
    1:         PRInt32 endOffset;
    1:         range->GetEndOffset(&endOffset);
96751:         res = SetInlinePropertyOnTextNode(nodeAsText, 0, endOffset,
96751:                                           aProperty, &aAttribute, &aValue);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:     }
    1:   }
96751:   if (!cancel) {
96751:     // post-process
96751:     return mRules->DidDoAction(selection, &ruleInfo, res);
    1:   }
96751:   return NS_OK;
    1: }
    1: 
    1: 
    1: 
    1: nsresult
    1: nsHTMLEditor::SetInlinePropertyOnTextNode( nsIDOMCharacterData *aTextNode, 
    1:                                             PRInt32 aStartOffset,
    1:                                             PRInt32 aEndOffset,
    1:                                             nsIAtom *aProperty, 
    1:                                             const nsAString *aAttribute,
    1:                                             const nsAString *aValue)
    1: {
97759:   MOZ_ASSERT(aValue);
43806:   NS_ENSURE_TRUE(aTextNode, NS_ERROR_NULL_POINTER);
    1:   nsCOMPtr<nsIDOMNode> parent;
    1:   nsresult res = aTextNode->GetParentNode(getter_AddRefs(parent));
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
97376:   if (!CanContainTag(parent, aProperty)) {
97376:     return NS_OK;
97376:   }
    1:   
    1:   // don't need to do anything if no characters actually selected
    1:   if (aStartOffset == aEndOffset) return NS_OK;
    1:   
97759:   nsCOMPtr<nsIDOMNode> node = aTextNode;
    1:   
    1:   // don't need to do anything if property already set on node
79445:   bool bHasProp;
89175:   if (IsCSSEnabled() &&
96779:       mHTMLCSSUtils->IsCSSEditableProperty(node, aProperty,
96779:                                            aAttribute, aValue)) {
    1:     // the HTML styles defined by aProperty/aAttribute has a CSS equivalence
    1:     // in this implementation for node; let's check if it carries those css styles
97759:     nsAutoString value(*aValue);
    1:     mHTMLCSSUtils->IsCSSEquivalentToHTMLInlineStyleSet(node, aProperty, aAttribute,
    1:                                                        bHasProp, value,
    1:                                                        COMPUTED_STYLE_TYPE);
97759:   } else {
97458:     IsTextPropertySetByContent(node, aProperty, aAttribute, aValue, bHasProp);
    1:   }
    1: 
    1:   if (bHasProp) return NS_OK;
    1:   
    1:   // do we need to split the text node?
    1:   PRUint32 textLen;
    1:   aTextNode->GetLength(&textLen);
    1: 
97759:   if (PRUint32(aEndOffset) != textLen) {
97759:     // we need to split off back of text node
    1:     nsCOMPtr<nsIDOMNode> tmp;
    1:     res = SplitNode(node, aEndOffset, getter_AddRefs(tmp));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     node = tmp;  // remember left node
    1:   }
97759: 
97759:   if (aStartOffset) {
    1:     // we need to split off front of text node
97759:     nsCOMPtr<nsIDOMNode> tmp;
    1:     res = SplitNode(node, aStartOffset, getter_AddRefs(tmp));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1: 
97759:   nsCOMPtr<nsIContent> content = do_QueryInterface(node);
97759:   NS_ENSURE_STATE(content);
97759: 
97759:   if (aAttribute) {
    1:     // look for siblings that are correct type of node
97759:     nsIContent* sibling = GetPriorHTMLSibling(content);
97759:     if (sibling && sibling->Tag() == aProperty &&
97759:         HasAttrVal(sibling, aAttribute, *aValue) &&
97759:         IsOnlyAttribute(sibling, *aAttribute)) {
    1:       // previous sib is already right kind of inline node; slide this over into it
97759:       return MoveNode(node, sibling->AsDOMNode(), -1);
    1:     }
97759:     sibling = GetNextHTMLSibling(content);
97759:     if (sibling && sibling->Tag() == aProperty &&
97759:         HasAttrVal(sibling, aAttribute, *aValue) &&
97759:         IsOnlyAttribute(sibling, *aAttribute)) {
    1:       // following sib is already right kind of inline node; slide this over into it
97759:       return MoveNode(node, sibling->AsDOMNode(), 0);
97759:     }
    1:   }
    1:   
    1:   // reparent the node inside inline node with appropriate {attribute,value}
    1:   return SetInlinePropertyOnNode(node, aProperty, aAttribute, aValue);
    1: }
    1: 
    1: 
    1: nsresult
97760: nsHTMLEditor::SetInlinePropertyOnNodeImpl(nsIContent* aNode,
    1:                                           nsIAtom* aProperty,
    1:                                           const nsAString* aAttribute,
    1:                                           const nsAString* aValue)
    1: {
96754:   MOZ_ASSERT(aNode && aProperty);
97759:   MOZ_ASSERT(aValue);
    1: 
    1:   nsAutoString tag;
    1:   aProperty->ToString(tag);
    1:   ToLowerCase(tag);
    1: 
96728:   // If this is an element that can't be contained in a span, we have to
96728:   // recurse to its children.
97760:   if (!TagCanContain(nsGkAtoms::span, aNode->AsDOMNode())) {
97760:     if (aNode->HasChildren()) {
97760:       nsCOMArray<nsIContent> arrayOfNodes;
96728: 
97760:       // Populate the list.
97760:       for (nsIContent* child = aNode->GetFirstChild();
97760:            child;
97760:            child = child->GetNextSibling()) {
97760:         if (IsEditable(child)) {
97760:           arrayOfNodes.AppendObject(child);
96728:         }
96728:       }
96728: 
97760:       // Then loop through the list, set the property on each node.
96728:       PRInt32 listCount = arrayOfNodes.Count();
97760:       for (PRInt32 j = 0; j < listCount; ++j) {
97760:         nsresult rv = SetInlinePropertyOnNode(arrayOfNodes[j], aProperty,
96752:                                               aAttribute, aValue);
97760:         NS_ENSURE_SUCCESS(rv, rv);
96728:       }
96728:     }
96752:     return NS_OK;
96728:   }
96728: 
95588:   bool useCSS = (IsCSSEnabled() &&
96779:                  mHTMLCSSUtils->IsCSSEditableProperty(aNode, aProperty,
96779:                                                       aAttribute, aValue)) ||
95588:                 // bgcolor is always done using CSS
95588:                 aAttribute->EqualsLiteral("bgcolor");
95588: 
97760:   nsresult res;
95588:   if (useCSS) {
97760:     nsCOMPtr<nsIDOMNode> tmp = aNode->AsDOMNode();
96755:     // We only add style="" to <span>s with no attributes (bug 746515).  If we
96755:     // don't have one, we need to make one.
97760:     if (!aNode->IsElement() || !aNode->AsElement()->IsHTML(nsGkAtoms::span) ||
97760:         aNode->AsElement()->GetAttrCount()) {
97760:       res = InsertContainerAbove(aNode->AsDOMNode(), address_of(tmp),
96755:                                  NS_LITERAL_STRING("span"),
96752:                                  nsnull, nsnull);
96755:       NS_ENSURE_SUCCESS(res, res);
    1:     }
96754:     // Add the CSS styles corresponding to the HTML style request
    1:     PRInt32 count;
96755:     res = mHTMLCSSUtils->SetCSSEquivalentToHTMLStyle(tmp, aProperty,
96752:                                                      aAttribute, aValue,
96752:                                                      &count, false);
43805:     NS_ENSURE_SUCCESS(res, res);
    1: 
    1:     nsCOMPtr<nsIDOMNode> nextSibling, previousSibling;
    1:     GetNextHTMLSibling(tmp, address_of(nextSibling));
    1:     GetPriorHTMLSibling(tmp, address_of(previousSibling));
96752:     if (nextSibling || previousSibling) {
    1:       nsCOMPtr<nsIDOMNode> mergeParent;
    1:       res = tmp->GetParentNode(getter_AddRefs(mergeParent));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       if (previousSibling &&
    1:           nsEditor::NodeIsType(previousSibling, nsEditProperty::span) &&
96752:           NodesSameType(tmp, previousSibling)) {
    1:         res = JoinNodes(previousSibling, tmp, mergeParent);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:       if (nextSibling &&
    1:           nsEditor::NodeIsType(nextSibling, nsEditProperty::span) &&
96752:           NodesSameType(tmp, nextSibling)) {
    1:         res = JoinNodes(tmp, nextSibling, mergeParent);
96752:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:     }
96752:     return NS_OK;
    1:   }
    1: 
    1:   // is it already the right kind of node, but with wrong attribute?
97760:   if (aNode->Tag() == aProperty) {
96754:     // Just set the attribute on it.
    1:     nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(aNode);
    1:     return SetAttribute(elem, *aAttribute, *aValue);
    1:   }
    1: 
96728:   // Either put it inside a neighboring node, or make a new one.
96752:   // is either of its neighbors the right kind of node?
97760:   if (aAttribute) {
97760:     nsIContent* priorNode = GetPriorHTMLSibling(aNode);
97759:     if (priorNode && priorNode->Tag() == aProperty &&
97759:         HasAttrVal(priorNode, aAttribute, *aValue) &&
97759:         IsOnlyAttribute(priorNode, *aAttribute)) {
    1:       // previous sib is already right kind of inline node; slide this over into it
97760:       return MoveNode(aNode->AsDOMNode(), priorNode->AsDOMNode(), -1);
96754:     }
96754: 
97760:     nsIContent* nextNode = GetNextHTMLSibling(aNode);
97759:     if (nextNode && nextNode->Tag() == aProperty &&
97759:         HasAttrVal(nextNode, aAttribute, *aValue) &&
97990:         IsOnlyAttribute(nextNode, *aAttribute)) {
    1:       // following sib is already right kind of inline node; slide this over into it
97760:       return MoveNode(aNode->AsDOMNode(), nextNode->AsDOMNode(), 0);
97759:     }
96754:   }
96754: 
90153:   // ok, chuck it in its very own container
97760:   nsCOMPtr<nsIDOMNode> tmp;
97760:   return InsertContainerAbove(aNode->AsDOMNode(), address_of(tmp), tag,
97760:                               aAttribute, aValue);
    1: }
96754: 
96754: 
96754: nsresult
96754: nsHTMLEditor::SetInlinePropertyOnNode(nsIDOMNode *aNode,
96754:                                       nsIAtom *aProperty,
96754:                                       const nsAString *aAttribute,
96754:                                       const nsAString *aValue)
96754: {
96754:   // Before setting the property, we remove it if it's already set.
96754:   // RemoveStyleInside might remove the node we're looking at or some of its
96754:   // descendants, however, in which case we want to set the property on
96754:   // whatever wound up in its place.  We have to save the original siblings and
96754:   // parent to figure this out.
96754:   NS_ENSURE_TRUE(aNode && aProperty, NS_ERROR_NULL_POINTER);
96754: 
96754:   nsCOMPtr<nsIContent> node = do_QueryInterface(aNode);
96754:   NS_ENSURE_STATE(node);
97760: 
97760:   return SetInlinePropertyOnNode(node, aProperty, aAttribute, aValue);
97760: }
97760: 
97760: nsresult
97760: nsHTMLEditor::SetInlinePropertyOnNode(nsIContent* aNode,
97760:                                       nsIAtom* aProperty,
97760:                                       const nsAString* aAttribute,
97760:                                       const nsAString* aValue)
97760: {
97760:   MOZ_ASSERT(aNode);
97760:   MOZ_ASSERT(aProperty);
97760: 
97760:   nsCOMPtr<nsIContent> previousSibling = aNode->GetPreviousSibling(),
97760:                        nextSibling = aNode->GetNextSibling();
97760:   nsCOMPtr<nsINode> parent = aNode->GetNodeParent();
96754:   NS_ENSURE_STATE(parent);
96754: 
97760:   nsresult res = RemoveStyleInside(aNode->AsDOMNode(), aProperty, aAttribute);
43805:   NS_ENSURE_SUCCESS(res, res);
96754: 
97760:   if (aNode->GetNodeParent()) {
96754:     // The node is still where it was
96754:     return SetInlinePropertyOnNodeImpl(aNode, aProperty,
96754:                                        aAttribute, aValue);
96754:   }
96754: 
96754:   // It's vanished.  Use the old siblings for reference to construct a
96754:   // list.  But first, verify that the previous/next siblings are still
96754:   // where we expect them; otherwise we have to give up.
96754:   if ((previousSibling && previousSibling->GetNodeParent() != parent) ||
96754:       (nextSibling && nextSibling->GetNodeParent() != parent)) {
96754:     return NS_ERROR_UNEXPECTED;
96754:   }
96754:   nsCOMArray<nsIContent> nodesToSet;
96754:   nsCOMPtr<nsIContent> cur = previousSibling
96754:     ? previousSibling->GetNextSibling() : parent->GetFirstChild();
96754:   while (cur && cur != nextSibling) {
96754:     if (IsEditable(cur)) {
96754:       nodesToSet.AppendObject(cur);
96754:     }
96754:     cur = cur->GetNextSibling();
96754:   }
96754: 
96754:   PRInt32 nodesToSetCount = nodesToSet.Count();
96754:   for (PRInt32 k = 0; k < nodesToSetCount; k++) {
97760:     res = SetInlinePropertyOnNodeImpl(nodesToSet[k], aProperty,
96754:                                       aAttribute, aValue);
96754:     NS_ENSURE_SUCCESS(res, res);
96754:   }
96754: 
96754:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult nsHTMLEditor::SplitStyleAboveRange(nsIDOMRange *inRange, 
    1:                                             nsIAtom *aProperty, 
    1:                                             const nsAString *aAttribute)
    1: {
43806:   NS_ENSURE_TRUE(inRange, NS_ERROR_NULL_POINTER);
    1:   nsresult res;
    1:   nsCOMPtr<nsIDOMNode> startNode, endNode, origStartNode;
86165:   PRInt32 startOffset, endOffset;
    1: 
    1:   res = inRange->GetStartContainer(getter_AddRefs(startNode));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->GetStartOffset(&startOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->GetEndContainer(getter_AddRefs(endNode));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->GetEndOffset(&endOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   origStartNode = startNode;
    1: 
    1:   // split any matching style nodes above the start of range
    1:   {
    1:     nsAutoTrackDOMPoint tracker(mRangeUpdater, address_of(endNode), &endOffset);
    1:     res = SplitStyleAbovePoint(address_of(startNode), &startOffset, aProperty, aAttribute);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1: 
    1:   // second verse, same as the first...
    1:   res = SplitStyleAbovePoint(address_of(endNode), &endOffset, aProperty, aAttribute);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // reset the range
    1:   res = inRange->SetStart(startNode, startOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->SetEnd(endNode, endOffset);
    1:   return res;
    1: }
    1: 
    1: nsresult nsHTMLEditor::SplitStyleAbovePoint(nsCOMPtr<nsIDOMNode> *aNode,
    1:                                            PRInt32 *aOffset,
    1:                                            nsIAtom *aProperty,          // null here means we split all properties
    1:                                            const nsAString *aAttribute,
    1:                                            nsCOMPtr<nsIDOMNode> *outLeftNode,
    1:                                            nsCOMPtr<nsIDOMNode> *outRightNode)
    1: {
43806:   NS_ENSURE_TRUE(aNode && *aNode && aOffset, NS_ERROR_NULL_POINTER);
    1:   if (outLeftNode)  *outLeftNode  = nsnull;
    1:   if (outRightNode) *outRightNode = nsnull;
    1:   // split any matching style nodes above the node/offset
    1:   nsCOMPtr<nsIDOMNode> parent, tmp = *aNode;
    1:   PRInt32 offset;
    1: 
89175:   bool useCSS = IsCSSEnabled();
    1: 
79445:   bool isSet;
    1:   while (tmp && !IsBlockNode(tmp))
    1:   {
80486:     isSet = false;
    1:     if (useCSS && mHTMLCSSUtils->IsCSSEditableProperty(tmp, aProperty, aAttribute)) {
    1:       // the HTML style defined by aProperty/aAttribute has a CSS equivalence
    1:       // in this implementation for the node tmp; let's check if it carries those css styles
    1:       nsAutoString firstValue;
    1:       mHTMLCSSUtils->IsCSSEquivalentToHTMLInlineStyleSet(tmp, aProperty, aAttribute,
    1:                                                          isSet, firstValue,
    1:                                                          SPECIFIED_STYLE_TYPE);
    1:     }
    1:     if ( (aProperty && NodeIsType(tmp, aProperty)) ||   // node is the correct inline prop
    1:          (aProperty == nsEditProperty::href && nsHTMLEditUtils::IsLink(tmp)) ||
    1:                                                         // node is href - test if really <a href=...
    1:          (!aProperty && NodeIsProperty(tmp)) ||         // or node is any prop, and we asked to split them all
    1:          isSet)                                         // or the style is specified in the style attribute
    1:     {
    1:       // found a style node we need to split
80486:       nsresult rv = SplitNodeDeep(tmp, *aNode, *aOffset, &offset, false,
39468:                                   outLeftNode, outRightNode);
39468:       NS_ENSURE_SUCCESS(rv, rv);
    1:       // reset startNode/startOffset
    1:       tmp->GetParentNode(getter_AddRefs(*aNode));
    1:       *aOffset = offset;
    1:     }
    1:     tmp->GetParentNode(getter_AddRefs(parent));
    1:     tmp = parent;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
98853: nsresult
98853: nsHTMLEditor::ClearStyle(nsCOMPtr<nsIDOMNode>* aNode, PRInt32* aOffset,
98853:                          nsIAtom* aProperty, const nsAString* aAttribute)
98853: {
98853:   nsCOMPtr<nsIDOMNode> leftNode, rightNode, tmp;
98853:   nsresult res = SplitStyleAbovePoint(aNode, aOffset, aProperty, aAttribute,
98853:                                       address_of(leftNode),
98853:                                       address_of(rightNode));
98853:   NS_ENSURE_SUCCESS(res, res);
98853:   if (leftNode) {
98853:     bool bIsEmptyNode;
98853:     IsEmptyNode(leftNode, &bIsEmptyNode, false, true);
98853:     if (bIsEmptyNode) {
98853:       // delete leftNode if it became empty
98853:       res = DeleteNode(leftNode);
98853:       NS_ENSURE_SUCCESS(res, res);
98853:     }
98853:   }
98853:   if (rightNode) {
98853:     nsCOMPtr<nsIDOMNode> secondSplitParent = GetLeftmostChild(rightNode);
98853:     // don't try to split non-containers (br's, images, hr's, etc)
98853:     if (!secondSplitParent) {
98853:       secondSplitParent = rightNode;
98853:     }
98853:     nsCOMPtr<nsIDOMNode> savedBR;
98853:     if (!IsContainer(secondSplitParent)) {
98853:       if (nsTextEditUtils::IsBreak(secondSplitParent)) {
98853:         savedBR = secondSplitParent;
98853:       }
98853: 
98853:       secondSplitParent->GetParentNode(getter_AddRefs(tmp));
98853:       secondSplitParent = tmp;
98853:     }
98853:     *aOffset = 0;
98853:     res = SplitStyleAbovePoint(address_of(secondSplitParent),
98853:                                aOffset, aProperty, aAttribute,
98853:                                address_of(leftNode), address_of(rightNode));
98853:     NS_ENSURE_SUCCESS(res, res);
98853:     // should be impossible to not get a new leftnode here
98853:     NS_ENSURE_TRUE(leftNode, NS_ERROR_FAILURE);
98853:     nsCOMPtr<nsIDOMNode> newSelParent = GetLeftmostChild(leftNode);
98853:     if (!newSelParent) {
98853:       newSelParent = leftNode;
98853:     }
98853:     // If rightNode starts with a br, suck it out of right node and into
98853:     // leftNode.  This is so we you don't revert back to the previous style
98853:     // if you happen to click at the end of a line.
98853:     if (savedBR) {
98853:       res = MoveNode(savedBR, newSelParent, 0);
98853:       NS_ENSURE_SUCCESS(res, res);
98853:     }
98853:     bool bIsEmptyNode;
98853:     IsEmptyNode(rightNode, &bIsEmptyNode, false, true);
98853:     if (bIsEmptyNode) {
98853:       // delete rightNode if it became empty
98853:       res = DeleteNode(rightNode);
98853:       NS_ENSURE_SUCCESS(res, res);
98853:     }
98853:     // remove the style on this new hierarchy
98853:     PRInt32 newSelOffset = 0;
98853:     {
98853:       // Track the point at the new hierarchy.  This is so we can know where
98853:       // to put the selection after we call RemoveStyleInside().
98853:       // RemoveStyleInside() could remove any and all of those nodes, so I
98853:       // have to use the range tracking system to find the right spot to put
98853:       // selection.
98853:       nsAutoTrackDOMPoint tracker(mRangeUpdater,
98853:                                   address_of(newSelParent), &newSelOffset);
98853:       res = RemoveStyleInside(leftNode, aProperty, aAttribute);
98853:       NS_ENSURE_SUCCESS(res, res);
98853:     }
98853:     // reset our node offset values to the resulting new sel point
98853:     *aNode = newSelParent;
98853:     *aOffset = newSelOffset;
98853:   }
98853: 
98853:   return NS_OK;
98853: }
98853: 
79445: bool nsHTMLEditor::NodeIsProperty(nsIDOMNode *aNode)
    1: {
80486:   NS_ENSURE_TRUE(aNode, false);
80486:   if (!IsContainer(aNode))  return false;
80486:   if (!IsEditable(aNode))   return false;
80486:   if (IsBlockNode(aNode))   return false;
80486:   if (NodeIsType(aNode, nsEditProperty::a)) return false;
80486:   return true;
    1: }
    1: 
    1: nsresult nsHTMLEditor::ApplyDefaultProperties()
    1: {
    1:   nsresult res = NS_OK;
27986:   PRUint32 j, defcon = mDefaultStyles.Length();
    1:   for (j=0; j<defcon; j++)
    1:   {
27986:     PropItem *propItem = mDefaultStyles[j];
43807:     NS_ENSURE_TRUE(propItem, NS_ERROR_NULL_POINTER);
    1:     res = SetInlineProperty(propItem->tag, propItem->attr, propItem->value);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   return res;
    1: }
    1: 
    1: nsresult nsHTMLEditor::RemoveStyleInside(nsIDOMNode *aNode, 
96729:                                          // null here means remove all properties
96729:                                          nsIAtom *aProperty,
    1:                                          const nsAString *aAttribute,
96729:                                          const bool aChildrenOnly)
    1: {
43806:   NS_ENSURE_TRUE(aNode, NS_ERROR_NULL_POINTER);
96729:   if (IsTextNode(aNode)) {
96729:     return NS_OK;
96729:   }
96729:   nsresult res;
    1: 
    1:   // first process the children
    1:   nsCOMPtr<nsIDOMNode> child, tmp;
    1:   aNode->GetFirstChild(getter_AddRefs(child));
96729:   while (child) {
    1:     // cache next sibling since we might remove child
    1:     child->GetNextSibling(getter_AddRefs(tmp));
    1:     res = RemoveStyleInside(child, aProperty, aAttribute);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     child = tmp;
    1:   }
    1: 
    1:   // then process the node itself
96729:   if (
96729:     (!aChildrenOnly &&
96729:       (
96729:         // node is prop we asked for
96729:         (aProperty && NodeIsType(aNode, aProperty)) ||
96729:         // but check for link (<a href=...)
96729:         (aProperty == nsEditProperty::href && nsHTMLEditUtils::IsLink(aNode)) ||
96729:         // and for named anchors
96729:         (aProperty == nsEditProperty::name && nsHTMLEditUtils::IsNamedAnchor(aNode))
96729:       )
96729:     ) ||
96729:     // or node is any prop and we asked for that
96729:     (!aProperty && NodeIsProperty(aNode))
96729:   ) {
    1:     // if we weren't passed an attribute, then we want to 
    1:     // remove any matching inlinestyles entirely
96729:     if (!aAttribute || aAttribute->IsEmpty()) {
    1:       NS_NAMED_LITERAL_STRING(styleAttr, "style");
    1:       NS_NAMED_LITERAL_STRING(classAttr, "class");
79445:       bool hasStyleAttr = HasAttr(aNode, &styleAttr);
96729:       bool hasClassAttr = HasAttr(aNode, &classAttr);
96729:       if (aProperty && (hasStyleAttr || hasClassAttr)) {
    1:         // aNode carries inline styles or a class attribute so we can't
    1:         // just remove the element... We need to create above the element
    1:         // a span that will carry those styles or class, then we can delete
    1:         // the node.
    1:         nsCOMPtr<nsIDOMNode> spanNode;
    1:         res = InsertContainerAbove(aNode, address_of(spanNode),
    1:                                    NS_LITERAL_STRING("span"));
43808:         NS_ENSURE_SUCCESS(res, res);
    1:         res = CloneAttribute(styleAttr, spanNode, aNode);
43808:         NS_ENSURE_SUCCESS(res, res);
    1:         res = CloneAttribute(classAttr, spanNode, aNode);
43808:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:       res = RemoveContainer(aNode);
96729:       NS_ENSURE_SUCCESS(res, res);
96729:     } else {
    1:       // otherwise we just want to eliminate the attribute
96729:       if (HasAttr(aNode, aAttribute)) {
    1:         // if this matching attribute is the ONLY one on the node,
    1:         // then remove the whole node.  Otherwise just nix the attribute.
96729:         if (IsOnlyAttribute(aNode, aAttribute)) {
    1:           res = RemoveContainer(aNode);
96729:         } else {
    1:           nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(aNode);
43806:           NS_ENSURE_TRUE(elem, NS_ERROR_NULL_POINTER);
    1:           res = RemoveAttribute(elem, *aAttribute);
    1:         }
96729:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:     }
96730:   }
96730: 
96730:   if (!aChildrenOnly &&
89175:       mHTMLCSSUtils->IsCSSEditableProperty(aNode, aProperty, aAttribute)) {
96729:     // the HTML style defined by aProperty/aAttribute has a CSS equivalence in
96729:     // this implementation for the node aNode; let's check if it carries those
96729:     // css styles
    1:     nsAutoString propertyValue;
79445:     bool isSet;
    1:     mHTMLCSSUtils->IsCSSEquivalentToHTMLInlineStyleSet(aNode, aProperty, aAttribute,
    1:                                                        isSet, propertyValue,
    1:                                                        SPECIFIED_STYLE_TYPE);
    1:     if (isSet) {
    1:       // yes, tmp has the corresponding css declarations in its style attribute
    1:       // let's remove them
    1:       mHTMLCSSUtils->RemoveCSSEquivalentToHTMLStyle(aNode,
    1:                                                     aProperty,
    1:                                                     aAttribute,
    1:                                                     &propertyValue,
80486:                                                     false);
96753:       // remove the node if it is a span or font, if its style attribute is
96753:       // empty or absent, and if it does not have a class nor an id
89176:       RemoveElementIfNoStyleOrIdOrClass(aNode);
    1:     }
    1:   }
96729: 
    1:   if (aProperty == nsEditProperty::font &&    // or node is big or small and we are setting font size
    1:       (nsHTMLEditUtils::IsBig(aNode) || nsHTMLEditUtils::IsSmall(aNode)) &&
96729:       aAttribute && aAttribute->LowerCaseEqualsLiteral("size")) {
96729:     return RemoveContainer(aNode);  // if we are setting font size, remove any nested bigs and smalls
    1:   }
96729:   return NS_OK;
    1: }
    1: 
79445: bool nsHTMLEditor::IsOnlyAttribute(nsIDOMNode *aNode, 
    1:                                      const nsAString *aAttribute)
    1: {
80486:   NS_ENSURE_TRUE(aNode && aAttribute, false);  // ooops
97757: 
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
80486:   NS_ENSURE_TRUE(content, false);  // ooops
    1: 
97757:   return IsOnlyAttribute(content, *aAttribute);
97757: }
97757: 
97757: bool
97757: nsHTMLEditor::IsOnlyAttribute(const nsIContent* aContent,
97757:                               const nsAString& aAttribute)
97757: {
97757:   MOZ_ASSERT(aContent);
97757: 
97757:   PRUint32 attrCount = aContent->GetAttrCount();
97757:   for (PRUint32 i = 0; i < attrCount; ++i) {
97757:     const nsAttrName* name = aContent->GetAttrNameAt(i);
    1:     if (!name->NamespaceEquals(kNameSpaceID_None)) {
80486:       return false;
    1:     }
97757: 
97757:     nsAutoString attrString;
    1:     name->LocalName()->ToString(attrString);
    1:     // if it's the attribute we know about, or a special _moz attribute,
    1:     // keep looking
97757:     if (!attrString.Equals(aAttribute, nsCaseInsensitiveStringComparator()) &&
    1:         !StringBeginsWith(attrString, NS_LITERAL_STRING("_moz"))) {
80486:       return false;
    1:     }
    1:   }
    1:   // if we made it through all of them without finding a real attribute
80486:   // other than aAttribute, then return true
80486:   return true;
    1: }
    1: 
79445: bool nsHTMLEditor::HasAttr(nsIDOMNode* aNode,
    1:                            const nsAString* aAttribute)
    1: {
80486:   NS_ENSURE_TRUE(aNode, false);
89177:   if (!aAttribute || aAttribute->IsEmpty()) {
89177:     // everybody has the 'null' attribute
89177:     return true;
89177:   }
    1: 
    1:   // get element
89177:   nsCOMPtr<dom::Element> element = do_QueryInterface(aNode);
89177:   NS_ENSURE_TRUE(element, false);
    1: 
89177:   nsCOMPtr<nsIAtom> atom = do_GetAtom(*aAttribute);
89177:   NS_ENSURE_TRUE(atom, false);
89177: 
89177:   return element->HasAttr(kNameSpaceID_None, atom);
    1: }
    1: 
    1: 
97759: bool nsHTMLEditor::HasAttrVal(const nsIContent* aNode,
    1:                               const nsAString* aAttribute,
97759:                               const nsAString& aValue)
    1: {
97759:   MOZ_ASSERT(aNode);
97759: 
89177:   if (!aAttribute || aAttribute->IsEmpty()) {
89177:     // everybody has the 'null' attribute
89177:     return true;
89177:   }
    1: 
89177:   nsCOMPtr<nsIAtom> atom = do_GetAtom(*aAttribute);
89177:   NS_ENSURE_TRUE(atom, false);
    1: 
97759:   return aNode->AttrValueIs(kNameSpaceID_None, atom, aValue, eIgnoreCase);
    1: }
    1: 
    1: nsresult nsHTMLEditor::PromoteRangeIfStartsOrEndsInNamedAnchor(nsIDOMRange *inRange)
    1: {
43806:   NS_ENSURE_TRUE(inRange, NS_ERROR_NULL_POINTER);
    1:   nsresult res;
    1:   nsCOMPtr<nsIDOMNode> startNode, endNode, parent, tmp;
    1:   PRInt32 startOffset, endOffset, tmpOffset;
    1:   
    1:   res = inRange->GetStartContainer(getter_AddRefs(startNode));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->GetStartOffset(&startOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->GetEndContainer(getter_AddRefs(endNode));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->GetEndOffset(&endOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   tmp = startNode;
    1:   while ( tmp && 
    1:           !nsTextEditUtils::IsBody(tmp) &&
    1:           !nsHTMLEditUtils::IsNamedAnchor(tmp))
    1:   {
    1:     res = GetNodeLocation(tmp, address_of(parent), &tmpOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     tmp = parent;
    1:   }
43806:   NS_ENSURE_TRUE(tmp, NS_ERROR_NULL_POINTER);
    1:   if (nsHTMLEditUtils::IsNamedAnchor(tmp))
    1:   {
    1:     res = GetNodeLocation(tmp, address_of(parent), &tmpOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     startNode = parent;
    1:     startOffset = tmpOffset;
    1:   }
    1: 
    1:   tmp = endNode;
    1:   while ( tmp && 
    1:           !nsTextEditUtils::IsBody(tmp) &&
    1:           !nsHTMLEditUtils::IsNamedAnchor(tmp))
    1:   {
    1:     res = GetNodeLocation(tmp, address_of(parent), &tmpOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     tmp = parent;
    1:   }
43806:   NS_ENSURE_TRUE(tmp, NS_ERROR_NULL_POINTER);
    1:   if (nsHTMLEditUtils::IsNamedAnchor(tmp))
    1:   {
    1:     res = GetNodeLocation(tmp, address_of(parent), &tmpOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     endNode = parent;
    1:     endOffset = tmpOffset + 1;
    1:   }
    1: 
    1:   res = inRange->SetStart(startNode, startOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->SetEnd(endNode, endOffset);
    1:   return res;
    1: }
    1: 
    1: nsresult nsHTMLEditor::PromoteInlineRange(nsIDOMRange *inRange)
    1: {
43806:   NS_ENSURE_TRUE(inRange, NS_ERROR_NULL_POINTER);
    1:   nsresult res;
    1:   nsCOMPtr<nsIDOMNode> startNode, endNode, parent;
    1:   PRInt32 startOffset, endOffset;
    1:   
    1:   res = inRange->GetStartContainer(getter_AddRefs(startNode));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->GetStartOffset(&startOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->GetEndContainer(getter_AddRefs(endNode));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->GetEndOffset(&endOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   while ( startNode && 
    1:           !nsTextEditUtils::IsBody(startNode) && 
30676:           IsEditable(startNode) &&
    1:           IsAtFrontOfNode(startNode, startOffset) )
    1:   {
    1:     res = GetNodeLocation(startNode, address_of(parent), &startOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     startNode = parent;
    1:   }
43806:   NS_ENSURE_TRUE(startNode, NS_ERROR_NULL_POINTER);
    1:   
    1:   while ( endNode && 
    1:           !nsTextEditUtils::IsBody(endNode) && 
30676:           IsEditable(endNode) &&
    1:           IsAtEndOfNode(endNode, endOffset) )
    1:   {
    1:     res = GetNodeLocation(endNode, address_of(parent), &endOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     endNode = parent;
    1:     endOffset++;  // we are AFTER this node
    1:   }
43806:   NS_ENSURE_TRUE(endNode, NS_ERROR_NULL_POINTER);
    1:   
    1:   res = inRange->SetStart(startNode, startOffset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   res = inRange->SetEnd(endNode, endOffset);
    1:   return res;
    1: }
    1: 
79445: bool nsHTMLEditor::IsAtFrontOfNode(nsIDOMNode *aNode, PRInt32 aOffset)
    1: {
80486:   NS_ENSURE_TRUE(aNode, false);  // oops
73978:   if (!aOffset) {
80486:     return true;
73978:   }
    1: 
    1:   if (IsTextNode(aNode))
    1:   {
80486:     return false;
    1:   }
    1:   else
    1:   {
    1:     nsCOMPtr<nsIDOMNode> firstNode;
    1:     GetFirstEditableChild(aNode, address_of(firstNode));
80486:     NS_ENSURE_TRUE(firstNode, true); 
    1:     PRInt32 offset;
    1:     nsEditor::GetChildOffset(firstNode, aNode, offset);
80486:     if (offset < aOffset) return false;
80486:     return true;
    1:   }
    1: }
    1: 
79445: bool nsHTMLEditor::IsAtEndOfNode(nsIDOMNode *aNode, PRInt32 aOffset)
    1: {
80486:   NS_ENSURE_TRUE(aNode, false);  // oops
    1:   PRUint32 len;
    1:   GetLengthOfDOMNode(aNode, len);
80486:   if (aOffset == (PRInt32)len) return true;
    1:   
    1:   if (IsTextNode(aNode))
    1:   {
80486:     return false;
    1:   }
    1:   else
    1:   {
    1:     nsCOMPtr<nsIDOMNode> lastNode;
    1:     GetLastEditableChild(aNode, address_of(lastNode));
80486:     NS_ENSURE_TRUE(lastNode, true); 
    1:     PRInt32 offset;
    1:     nsEditor::GetChildOffset(lastNode, aNode, offset);
80486:     if (offset < aOffset) return true;
80486:     return false;
    1:   }
    1: }
    1: 
    1: 
    1: nsresult
    1: nsHTMLEditor::GetInlinePropertyBase(nsIAtom *aProperty, 
    1:                                     const nsAString *aAttribute,
    1:                                     const nsAString *aValue,
79445:                                     bool *aFirst, 
79445:                                     bool *aAny, 
79445:                                     bool *aAll,
    1:                                     nsAString *outValue,
79445:                                     bool aCheckDefaults)
    1: {
43807:   NS_ENSURE_TRUE(aProperty, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsresult result;
80486:   *aAny = false;
80486:   *aAll = true;
80486:   *aFirst = false;
79445:   bool first = true;
    1: 
    1:   nsCOMPtr<nsISelection> selection;
    1:   result = GetSelection(getter_AddRefs(selection));
43805:   NS_ENSURE_SUCCESS(result, result);
43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
    1:   nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(selection));
    1: 
98815:   bool isCollapsed = selection->Collapsed();
    1:   nsCOMPtr<nsIDOMNode> collapsedNode;
    1:   nsCOMPtr<nsIEnumerator> enumerator;
    1:   result = selPriv->GetEnumerator(getter_AddRefs(enumerator));
43805:   NS_ENSURE_SUCCESS(result, result);
43806:   NS_ENSURE_TRUE(enumerator, NS_ERROR_NULL_POINTER);
    1: 
    1:   enumerator->First(); 
    1:   nsCOMPtr<nsISupports> currentItem;
    1:   result = enumerator->CurrentItem(getter_AddRefs(currentItem));
    1:   // XXX: should be a while loop, to get each separate range
    1:   // XXX: ERROR_HANDLING can currentItem be null?
96732:   if (NS_SUCCEEDED(result) && currentItem) {
79445:     bool firstNodeInRange = true; // for each range, set a flag 
    1:     nsCOMPtr<nsIDOMRange> range(do_QueryInterface(currentItem));
    1: 
96732:     if (isCollapsed) {
    1:       range->GetStartContainer(getter_AddRefs(collapsedNode));
43806:       NS_ENSURE_TRUE(collapsedNode, NS_ERROR_FAILURE);
79445:       bool isSet, theSetting;
97459:       nsString tOutString;
96732:       if (aAttribute) {
97459:         nsString tString(*aAttribute);
96732:         mTypeInState->GetTypingState(isSet, theSetting, aProperty, tString,
96732:                                      &tOutString);
96732:         if (outValue) {
    1:           outValue->Assign(tOutString);
    1:         }
96732:       } else {
    1:         mTypeInState->GetTypingState(isSet, theSetting, aProperty);
96732:       }
96732:       if (isSet) {
    1:         *aFirst = *aAny = *aAll = theSetting;
    1:         return NS_OK;
    1:       }
97459: 
97459:       // Bug 747889: we don't support CSS for fontSize values
97459:       if ((aProperty != nsEditProperty::font ||
97459:            !aAttribute->EqualsLiteral("size")) &&
97459:           mHTMLCSSUtils->IsCSSEditableProperty(collapsedNode, aProperty,
97459:                                                aAttribute)) {
97459:         mHTMLCSSUtils->IsCSSEquivalentToHTMLInlineStyleSet(
97459:           collapsedNode, aProperty, aAttribute, isSet, tOutString,
97459:           COMPUTED_STYLE_TYPE);
97459:         if (outValue) {
97459:           outValue->Assign(tOutString);
97459:         }
97459:         *aFirst = *aAny = *aAll = isSet;
97459:         return NS_OK;
97459:       }
97459: 
    1:       IsTextPropertySetByContent(collapsedNode, aProperty, aAttribute, aValue,
97458:                                  isSet, outValue);
    1:       *aFirst = *aAny = *aAll = isSet;
    1: 
96732:       if (!isSet && aCheckDefaults) {
    1:         // style not set, but if it is a default then it will appear if
96732:         // content is inserted, so we should report it as set (analogous to
96732:         // TypeInState).
    1:         PRInt32 index;
96732:         if (aAttribute && TypeInState::FindPropInList(aProperty, *aAttribute,
96732:                                                       outValue, mDefaultStyles,
96732:                                                       index)) {
80486:           *aFirst = *aAny = *aAll = true;
96732:           if (outValue) {
27986:             outValue->Assign(mDefaultStyles[index]->value);
    1:           }
    1:         }
96732:       }
    1:       return NS_OK;
    1:     }
    1: 
    1:     // non-collapsed selection
    1:     nsCOMPtr<nsIContentIterator> iter =
    1:             do_CreateInstance("@mozilla.org/content/post-content-iterator;1");
43806:     NS_ENSURE_TRUE(iter, NS_ERROR_NULL_POINTER);
    1: 
    1:     nsAutoString firstValue, theValue;
    1: 
    1:     nsCOMPtr<nsIDOMNode> endNode;
    1:     PRInt32 endOffset;
    1:     result = range->GetEndContainer(getter_AddRefs(endNode));
43805:     NS_ENSURE_SUCCESS(result, result);
    1:     result = range->GetEndOffset(&endOffset);
43805:     NS_ENSURE_SUCCESS(result, result);
96732: 
96732:     for (iter->Init(range); !iter->IsDone(); iter->Next()) {
20503:       nsCOMPtr<nsIContent> content = do_QueryInterface(iter->GetCurrentNode());
    1:       nsCOMPtr<nsIDOMNode> node = do_QueryInterface(content);
    1: 
96732:       if (node && nsTextEditUtils::IsBody(node)) {
    1:         break;
96732:       }
    1: 
    1:       nsCOMPtr<nsIDOMCharacterData> text;
    1:       text = do_QueryInterface(content);
    1:       
    1:       // just ignore any non-editable nodes
96732:       if (text && !IsEditable(text)) {
96732:         continue;
    1:       }
96732:       if (text) {
96732:         if (!isCollapsed && first && firstNodeInRange) {
80486:           firstNodeInRange = false;
    1:           PRInt32 startOffset;
    1:           range->GetStartOffset(&startOffset);
    1:           PRUint32 count;
    1:           text->GetLength(&count);
96732:           if (startOffset == (PRInt32)count) {
96732:             continue;
    1:           }
96732:         } else if (node == endNode && !endOffset) {
96732:           continue;
    1:         }
96732:       } else if (content->IsElement()) {
96732:         // handle non-text leaf nodes here
96732:         continue;
    1:       }
96732:       if (node) {
79445:         bool isSet = false;
96732:         if (first) {
96779:           if (mHTMLCSSUtils->IsCSSEditableProperty(node, aProperty,
96779:                                                    aAttribute) &&
96779:               // Bug 747889: we don't support CSS for fontSize values
96779:               (aProperty != nsEditProperty::font ||
96779:                !aAttribute->EqualsLiteral("size"))) {
96732:             // the HTML styles defined by aProperty/aAttribute has a CSS
96732:             // equivalence in this implementation for node; let's check if it
96732:             // carries those css styles
96732:             if (aValue) {
96732:               firstValue.Assign(*aValue);
96732:             }
    1:             mHTMLCSSUtils->IsCSSEquivalentToHTMLInlineStyleSet(node, aProperty, aAttribute,
    1:                                                                isSet, firstValue,
    1:                                                                COMPUTED_STYLE_TYPE);
96732:           } else {
    1:             IsTextPropertySetByContent(node, aProperty, aAttribute, aValue, isSet,
97458:                                        &firstValue);
    1:           }
    1:           *aFirst = isSet;
80486:           first = false;
96732:           if (outValue) {
96732:             *outValue = firstValue;
    1:           }
96732:         } else {
96779:           if (mHTMLCSSUtils->IsCSSEditableProperty(node, aProperty,
96779:                                                    aAttribute) &&
96779:               // Bug 747889: we don't support CSS for fontSize values
96779:               (aProperty != nsEditProperty::font ||
96779:                !aAttribute->EqualsLiteral("size"))) {
    1:             // the HTML styles defined by aProperty/aAttribute has a CSS equivalence
    1:             // in this implementation for node; let's check if it carries those css styles
96732:             if (aValue) {
96732:               theValue.Assign(*aValue);
96732:             }
    1:             mHTMLCSSUtils->IsCSSEquivalentToHTMLInlineStyleSet(node, aProperty, aAttribute,
    1:                                                                isSet, theValue,
    1:                                                                COMPUTED_STYLE_TYPE);
96732:           } else {
    1:             IsTextPropertySetByContent(node, aProperty, aAttribute, aValue, isSet,
97458:                                        &theValue);
    1:           }
96732:           if (firstValue != theValue) {
80486:             *aAll = false;
    1:           }
96732:         }
    1:         
    1:         if (isSet) {
80486:           *aAny = true;
96732:         } else {
80486:           *aAll = false;
    1:         }
    1:       }
    1:     }
    1:   }
96732:   if (!*aAny) {
96732:     // make sure that if none of the selection is set, we don't report all is
96732:     // set
80486:     *aAll = false;
    1:   }
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::GetInlineProperty(nsIAtom *aProperty, 
    1:                                               const nsAString &aAttribute, 
    1:                                               const nsAString &aValue,
79445:                                               bool *aFirst, 
79445:                                               bool *aAny, 
79445:                                               bool *aAll)
    1: {
43807:   NS_ENSURE_TRUE(aProperty && aFirst && aAny && aAll, NS_ERROR_NULL_POINTER);
    1:   const nsAString *att = nsnull;
    1:   if (!aAttribute.IsEmpty())
    1:     att = &aAttribute;
    1:   const nsAString *val = nsnull;
    1:   if (!aValue.IsEmpty())
    1:     val = &aValue;
    1:   return GetInlinePropertyBase( aProperty, att, val, aFirst, aAny, aAll, nsnull);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::GetInlinePropertyWithAttrValue(nsIAtom *aProperty, 
    1:                                               const nsAString &aAttribute, 
    1:                                               const nsAString &aValue,
79445:                                               bool *aFirst, 
79445:                                               bool *aAny, 
79445:                                               bool *aAll,
    1:                                               nsAString &outValue)
    1: {
43807:   NS_ENSURE_TRUE(aProperty && aFirst && aAny && aAll, NS_ERROR_NULL_POINTER);
    1:   const nsAString *att = nsnull;
    1:   if (!aAttribute.IsEmpty())
    1:     att = &aAttribute;
    1:   const nsAString *val = nsnull;
    1:   if (!aValue.IsEmpty())
    1:     val = &aValue;
    1:   return GetInlinePropertyBase( aProperty, att, val, aFirst, aAny, aAll, &outValue);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::RemoveAllInlineProperties()
    1: {
    1:   nsAutoEditBatch batchIt(this);
    1:   nsAutoRules beginRulesSniffing(this, kOpResetTextProperties, nsIEditor::eNext);
    1: 
    1:   nsresult res = RemoveInlinePropertyImpl(nsnull, nsnull);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   return ApplyDefaultProperties();
    1: }
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::RemoveInlineProperty(nsIAtom *aProperty, const nsAString &aAttribute)
    1: {
    1:   return RemoveInlinePropertyImpl(aProperty, &aAttribute);
    1: }
    1: 
    1: nsresult nsHTMLEditor::RemoveInlinePropertyImpl(nsIAtom *aProperty, const nsAString *aAttribute)
    1: {
97756:   MOZ_ASSERT_IF(aProperty, aAttribute);
43806:   NS_ENSURE_TRUE(mRules, NS_ERROR_NOT_INITIALIZED);
    1:   ForceCompositionEnd();
    1: 
    1:   nsresult res;
99469:   nsRefPtr<nsTypedSelection> selection = GetTypedSelection();
43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
    1: 
89175:   bool useCSS = IsCSSEnabled();
98815:   if (selection->Collapsed()) {
    1:     // manipulating text attributes on a collapsed selection only sets state for the next text insertion
    1: 
    1:     // For links, aProperty uses "href", use "a" instead
    1:     if (aProperty == nsEditProperty::href ||
    1:         aProperty == nsEditProperty::name)
    1:       aProperty = nsEditProperty::a;
    1: 
97756:     if (aProperty) {
97756:       mTypeInState->ClearProp(aProperty, *aAttribute);
97756:     } else {
97756:       mTypeInState->ClearAllProps();
    1:     }
97756:     return NS_OK;
97756:   }
97756: 
    1:   nsAutoEditBatch batchIt(this);
    1:   nsAutoRules beginRulesSniffing(this, kOpRemoveTextProperty, nsIEditor::eNext);
    1:   nsAutoSelectionReset selectionResetter(selection, this);
    1:   nsAutoTxnsConserveSelection dontSpazMySelection(this);
    1:   
79445:   bool cancel, handled;
97808:   nsTextRulesInfo ruleInfo(kOpRemoveTextProperty);
    1:   res = mRules->WillDoAction(selection, &ruleInfo, &cancel, &handled);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (!cancel && !handled)
    1:   {
    1:     // get selection range enumerator
    1:     nsCOMPtr<nsIEnumerator> enumerator;
99469:     res = selection->GetEnumerator(getter_AddRefs(enumerator));
43805:     NS_ENSURE_SUCCESS(res, res);
43806:     NS_ENSURE_TRUE(enumerator, NS_ERROR_FAILURE);
    1: 
    1:     // loop thru the ranges in the selection
    1:     enumerator->First(); 
    1:     nsCOMPtr<nsISupports> currentItem;
    1:     while ((NS_ENUMERATOR_FALSE == enumerator->IsDone()))
    1:     {
    1:       res = enumerator->CurrentItem(getter_AddRefs(currentItem));
43805:       NS_ENSURE_SUCCESS(res, res);
43806:       NS_ENSURE_TRUE(currentItem, NS_ERROR_FAILURE);
    1:       
    1:       nsCOMPtr<nsIDOMRange> range( do_QueryInterface(currentItem) );
    1: 
    1:       if (aProperty == nsEditProperty::name)
    1:       {
    1:         // promote range if it starts or end in a named anchor and we
    1:         // want to remove named anchors
    1:         res = PromoteRangeIfStartsOrEndsInNamedAnchor(range);
    1:       }
    1:       else {
    1:         // adjust range to include any ancestors who's children are entirely selected
    1:         res = PromoteInlineRange(range);
    1:       }
43805:       NS_ENSURE_SUCCESS(res, res);
    1: 
    1:       // remove this style from ancestors of our range endpoints, 
    1:       // splitting them as appropriate
    1:       res = SplitStyleAboveRange(range, aProperty, aAttribute);
43805:       NS_ENSURE_SUCCESS(res, res);
    1: 
    1:       // check for easy case: both range endpoints in same text node
    1:       nsCOMPtr<nsIDOMNode> startNode, endNode;
    1:       res = range->GetStartContainer(getter_AddRefs(startNode));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = range->GetEndContainer(getter_AddRefs(endNode));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       if ((startNode == endNode) && IsTextNode(startNode))
    1:       {
    1:         // we're done with this range!
    1:         if (useCSS && mHTMLCSSUtils->IsCSSEditableProperty(startNode, aProperty, aAttribute)) {
    1:           // the HTML style defined by aProperty/aAttribute has a CSS equivalence
    1:           // in this implementation for startNode
    1:           nsAutoString cssValue;
79445:           bool isSet = false;
    1:           mHTMLCSSUtils->IsCSSEquivalentToHTMLInlineStyleSet(startNode,
    1:                                                     aProperty,
    1:                                                     aAttribute,
    1:                                                     isSet ,
    1:                                                     cssValue,
    1:                                                     COMPUTED_STYLE_TYPE);
    1:           if (isSet) {
    1:             // startNode's computed style indicates the CSS equivalence to the HTML style to
    1:             // remove is applied; but we found no element in the ancestors of startNode
    1:             // carrying specified styles; assume it comes from a rule and let's try to
    1:             // insert a span "inverting" the style
    1:             nsAutoString value; value.AssignLiteral("-moz-editor-invert-value");
    1:             PRInt32 startOffset, endOffset;
    1:             range->GetStartOffset(&startOffset);
    1:             range->GetEndOffset(&endOffset);
    1:             nsCOMPtr<nsIDOMCharacterData> nodeAsText = do_QueryInterface(startNode);
    1:             if (mHTMLCSSUtils->IsCSSInvertable(aProperty, aAttribute)) {
    1:               SetInlinePropertyOnTextNode(nodeAsText, startOffset, endOffset, aProperty, aAttribute, &value);
    1:             }
    1:           }
    1:         }
    1:       }
    1:       else
    1:       {
    1:         // not the easy case.  range not contained in single text node. 
    1:         nsCOMPtr<nsIContentIterator> iter =
    1:           do_CreateInstance("@mozilla.org/content/subtree-content-iterator;1", &res);
43805:         NS_ENSURE_SUCCESS(res, res);
43806:         NS_ENSURE_TRUE(iter, NS_ERROR_FAILURE);
    1: 
    1:         nsCOMArray<nsIDOMNode> arrayOfNodes;
    1:         nsCOMPtr<nsIDOMNode> node;
    1:         
    1:         // iterate range and build up array
    1:         iter->Init(range);
    1:         while (!iter->IsDone())
    1:         {
    1:           node = do_QueryInterface(iter->GetCurrentNode());
43807:           NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
    1: 
    1:           if (IsEditable(node))
    1:           { 
    1:             arrayOfNodes.AppendObject(node);
    1:           }
    1: 
    1:           iter->Next();
    1:         }
    1:         
    1:         // loop through the list, remove the property on each node
    1:         PRInt32 listCount = arrayOfNodes.Count();
    1:         PRInt32 j;
    1:         for (j = 0; j < listCount; j++)
    1:         {
    1:           node = arrayOfNodes[j];
    1:           res = RemoveStyleInside(node, aProperty, aAttribute);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           if (useCSS && mHTMLCSSUtils->IsCSSEditableProperty(node, aProperty, aAttribute)) {
    1:             // the HTML style defined by aProperty/aAttribute has a CSS equivalence
    1:             // in this implementation for node
    1:             nsAutoString cssValue;
79445:             bool isSet = false;
    1:             mHTMLCSSUtils->IsCSSEquivalentToHTMLInlineStyleSet(node,
    1:                                                                aProperty,
    1:                                                                aAttribute,
    1:                                                                isSet ,
    1:                                                                cssValue,
    1:                                                                COMPUTED_STYLE_TYPE);
    1:             if (isSet) {
    1:               // startNode's computed style indicates the CSS equivalence to the HTML style to
    1:               // remove is applied; but we found no element in the ancestors of startNode
    1:               // carrying specified styles; assume it comes from a rule and let's try to
    1:               // insert a span "inverting" the style
    1:               if (mHTMLCSSUtils->IsCSSInvertable(aProperty, aAttribute)) {
    1:                 nsAutoString value; value.AssignLiteral("-moz-editor-invert-value");
    1:                 SetInlinePropertyOnNode(node, aProperty, aAttribute, &value);
    1:               }
    1:             }
    1:           }
    1:         }
    1:         arrayOfNodes.Clear();
    1:       }
    1:       enumerator->Next();
    1:     }
    1:   }
    1:   if (!cancel)
    1:   {
    1:     // post-process 
    1:     res = mRules->DidDoAction(selection, &ruleInfo, res);
    1:   }
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::IncreaseFontSize()
    1: {
    1:   return RelativeFontChange(1);
    1: }
    1: 
    1: NS_IMETHODIMP nsHTMLEditor::DecreaseFontSize()
    1: {
    1:   return RelativeFontChange(-1);
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditor::RelativeFontChange( PRInt32 aSizeChange)
    1: {
    1:   // Can only change font size by + or - 1
    1:   if ( !( (aSizeChange==1) || (aSizeChange==-1) ) )
    1:     return NS_ERROR_ILLEGAL_VALUE;
    1:   
    1:   ForceCompositionEnd();
    1: 
    1:   // Get the selection 
    1:   nsCOMPtr<nsISelection>selection;
    1:   nsresult res = GetSelection(getter_AddRefs(selection));
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
    1:   nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(selection));  
    1:   // Is the selection collapsed?
    1:   // if it's collapsed set typing state
98815:   if (selection->Collapsed()) {
    1:     nsCOMPtr<nsIAtom> atom;
    1:     if (aSizeChange==1) atom = nsEditProperty::big;
    1:     else                atom = nsEditProperty::small;
    1: 
    1:     // Let's see in what kind of element the selection is
    1:     PRInt32 offset;
    1:     nsCOMPtr<nsIDOMNode> selectedNode;
99926:     GetStartNodeAndOffset(selection, getter_AddRefs(selectedNode), &offset);
99926:     NS_ENSURE_TRUE(selectedNode, NS_OK);
    1:     if (IsTextNode(selectedNode)) {
    1:       nsCOMPtr<nsIDOMNode> parent;
    1:       res = selectedNode->GetParentNode(getter_AddRefs(parent));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       selectedNode = parent;
    1:     }
97376:     if (!CanContainTag(selectedNode, atom)) {
97376:       return NS_OK;
97376:     }
    1: 
    1:     // manipulating text attributes on a collapsed selection only sets state for the next text insertion
97756:     mTypeInState->SetProp(atom, EmptyString(), EmptyString());
97756:     return NS_OK;
    1:   }
    1:   
    1:   // wrap with txn batching, rules sniffing, and selection preservation code
    1:   nsAutoEditBatch batchIt(this);
    1:   nsAutoRules beginRulesSniffing(this, kOpSetTextProperty, nsIEditor::eNext);
    1:   nsAutoSelectionReset selectionResetter(selection, this);
    1:   nsAutoTxnsConserveSelection dontSpazMySelection(this);
    1: 
    1:   // get selection range enumerator
    1:   nsCOMPtr<nsIEnumerator> enumerator;
    1:   res = selPriv->GetEnumerator(getter_AddRefs(enumerator));
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(enumerator, NS_ERROR_FAILURE);
    1: 
    1:   // loop thru the ranges in the selection
    1:   enumerator->First(); 
    1:   nsCOMPtr<nsISupports> currentItem;
    1:   while ((NS_ENUMERATOR_FALSE == enumerator->IsDone()))
    1:   {
    1:     res = enumerator->CurrentItem(getter_AddRefs(currentItem));
43805:     NS_ENSURE_SUCCESS(res, res);
43806:     NS_ENSURE_TRUE(currentItem, NS_ERROR_FAILURE);
    1:     
    1:     nsCOMPtr<nsIDOMRange> range( do_QueryInterface(currentItem) );
    1: 
    1:     // adjust range to include any ancestors who's children are entirely selected
    1:     res = PromoteInlineRange(range);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     
    1:     // check for easy case: both range endpoints in same text node
    1:     nsCOMPtr<nsIDOMNode> startNode, endNode;
    1:     res = range->GetStartContainer(getter_AddRefs(startNode));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     res = range->GetEndContainer(getter_AddRefs(endNode));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if ((startNode == endNode) && IsTextNode(startNode))
    1:     {
    1:       PRInt32 startOffset, endOffset;
    1:       range->GetStartOffset(&startOffset);
    1:       range->GetEndOffset(&endOffset);
    1:       nsCOMPtr<nsIDOMCharacterData> nodeAsText = do_QueryInterface(startNode);
    1:       res = RelativeFontChangeOnTextNode(aSizeChange, nodeAsText, startOffset, endOffset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     else
    1:     {
    1:       // not the easy case.  range not contained in single text node. 
    1:       // there are up to three phases here.  There are all the nodes
    1:       // reported by the subtree iterator to be processed.  And there
    1:       // are potentially a starting textnode and an ending textnode
    1:       // which are only partially contained by the range.
    1:       
    1:       // lets handle the nodes reported by the iterator.  These nodes
    1:       // are entirely contained in the selection range.  We build up
    1:       // a list of them (since doing operations on the document during
    1:       // iteration would perturb the iterator).
    1: 
    1:       nsCOMPtr<nsIContentIterator> iter =
    1:         do_CreateInstance("@mozilla.org/content/subtree-content-iterator;1", &res);
43805:       NS_ENSURE_SUCCESS(res, res);
43806:       NS_ENSURE_TRUE(iter, NS_ERROR_FAILURE);
    1: 
    1:       // iterate range and build up array
    1:       res = iter->Init(range);
98819:       if (NS_SUCCEEDED(res)) {
98819:         nsCOMArray<nsIContent> arrayOfNodes;
98819:         while (!iter->IsDone()) {
98819:           nsCOMPtr<nsIContent> node = do_QueryInterface(iter->GetCurrentNode());
43807:           NS_ENSURE_TRUE(node, NS_ERROR_FAILURE);
    1: 
98819:           if (IsEditable(node)) {
    1:             arrayOfNodes.AppendObject(node);
    1:           }
    1: 
    1:           iter->Next();
    1:         }
    1:         
    1:         // now that we have the list, do the font size change on each node
    1:         PRInt32 listCount = arrayOfNodes.Count();
98819:         for (PRInt32 j = 0; j < listCount; ++j) {
98819:           nsIContent* node = arrayOfNodes[j];
    1:           res = RelativeFontChangeOnNode(aSizeChange, node);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:         }
    1:         arrayOfNodes.Clear();
    1:       }
    1:       // now check the start and end parents of the range to see if they need to 
    1:       // be separately handled (they do if they are text nodes, due to how the
    1:       // subtree iterator works - it will not have reported them).
    1:       if (IsTextNode(startNode) && IsEditable(startNode))
    1:       {
    1:         nsCOMPtr<nsIDOMCharacterData> nodeAsText = do_QueryInterface(startNode);
    1:         PRInt32 startOffset;
    1:         PRUint32 textLen;
    1:         range->GetStartOffset(&startOffset);
    1:         nodeAsText->GetLength(&textLen);
    1:         res = RelativeFontChangeOnTextNode(aSizeChange, nodeAsText, startOffset, textLen);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:       if (IsTextNode(endNode) && IsEditable(endNode))
    1:       {
    1:         nsCOMPtr<nsIDOMCharacterData> nodeAsText = do_QueryInterface(endNode);
    1:         PRInt32 endOffset;
    1:         range->GetEndOffset(&endOffset);
    1:         res = RelativeFontChangeOnTextNode(aSizeChange, nodeAsText, 0, endOffset);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:     }
    1:     enumerator->Next();
    1:   }
    1:   
    1:   return res;  
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditor::RelativeFontChangeOnTextNode( PRInt32 aSizeChange, 
    1:                                             nsIDOMCharacterData *aTextNode, 
    1:                                             PRInt32 aStartOffset,
    1:                                             PRInt32 aEndOffset)
    1: {
    1:   // Can only change font size by + or - 1
    1:   if ( !( (aSizeChange==1) || (aSizeChange==-1) ) )
    1:     return NS_ERROR_ILLEGAL_VALUE;
43806:   NS_ENSURE_TRUE(aTextNode, NS_ERROR_NULL_POINTER);
    1:   
    1:   // don't need to do anything if no characters actually selected
    1:   if (aStartOffset == aEndOffset) return NS_OK;
    1:   
    1:   nsresult res = NS_OK;
    1:   nsCOMPtr<nsIDOMNode> parent;
    1:   res = aTextNode->GetParentNode(getter_AddRefs(parent));
43805:   NS_ENSURE_SUCCESS(res, res);
97376:   if (!CanContainTag(parent, nsGkAtoms::big)) {
97376:     return NS_OK;
97376:   }
    1: 
    1:   nsCOMPtr<nsIDOMNode> tmp, node = do_QueryInterface(aTextNode);
    1: 
    1:   // do we need to split the text node?
    1:   PRUint32 textLen;
    1:   aTextNode->GetLength(&textLen);
    1:   
    1:   // -1 is a magic value meaning to the end of node
    1:   if (aEndOffset == -1) aEndOffset = textLen;
    1:   
    1:   if ( (PRUint32)aEndOffset != textLen )
    1:   {
    1:     // we need to split off back of text node
    1:     res = SplitNode(node, aEndOffset, getter_AddRefs(tmp));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     node = tmp;  // remember left node
    1:   }
    1:   if ( aStartOffset )
    1:   {
    1:     // we need to split off front of text node
    1:     res = SplitNode(node, aStartOffset, getter_AddRefs(tmp));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1: 
    1:   NS_NAMED_LITERAL_STRING(bigSize, "big");
    1:   NS_NAMED_LITERAL_STRING(smallSize, "small");
 3233:   const nsAString& nodeType = (aSizeChange==1) ? static_cast<const nsAString&>(bigSize) : static_cast<const nsAString&>(smallSize);
    1:   // look for siblings that are correct type of node
    1:   nsCOMPtr<nsIDOMNode> sibling;
    1:   GetPriorHTMLSibling(node, address_of(sibling));
    1:   if (sibling && NodeIsType(sibling, (aSizeChange==1) ? nsEditProperty::big : nsEditProperty::small))
    1:   {
    1:     // previous sib is already right kind of inline node; slide this over into it
    1:     res = MoveNode(node, sibling, -1);
    1:     return res;
    1:   }
    1:   sibling = nsnull;
    1:   GetNextHTMLSibling(node, address_of(sibling));
    1:   if (sibling && NodeIsType(sibling, (aSizeChange==1) ? nsEditProperty::big : nsEditProperty::small))
    1:   {
    1:     // following sib is already right kind of inline node; slide this over into it
    1:     res = MoveNode(node, sibling, 0);
    1:     return res;
    1:   }
    1:   
    1:   // else reparent the node inside font node with appropriate relative size
    1:   res = InsertContainerAbove(node, address_of(tmp), nodeType);
    1:   return res;
    1: }
    1: 
    1: 
    1: nsresult
98817: nsHTMLEditor::RelativeFontChangeHelper(PRInt32 aSizeChange, nsINode* aNode)
    1: {
98817:   MOZ_ASSERT(aNode);
98817: 
    1:   /*  This routine looks for all the font nodes in the tree rooted by aNode,
    1:       including aNode itself, looking for font nodes that have the size attr
    1:       set.  Any such nodes need to have big or small put inside them, since
    1:       they override any big/small that are above them.
    1:   */
    1:   
    1:   // Can only change font size by + or - 1
98817:   if (aSizeChange != 1 && aSizeChange != -1) {
    1:     return NS_ERROR_ILLEGAL_VALUE;
    1:   }
    1: 
98817:   // If this is a font node with size, put big/small inside it.
98817:   if (aNode->IsElement() && aNode->AsElement()->IsHTML(nsGkAtoms::font) &&
98817:       aNode->AsElement()->HasAttr(kNameSpaceID_None, nsGkAtoms::size)) {
98817:     // Cycle through children and adjust relative font size.
98817:     for (nsIContent* child = aNode->GetLastChild();
98817:          child;
98817:          child = child->GetPreviousSibling()) {
98818:       nsresult rv = RelativeFontChangeOnNode(aSizeChange, child);
98817:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:   }
    1: 
98817:   // Now cycle through the children.
98817:   for (nsIContent* child = aNode->GetLastChild();
98817:        child;
98817:        child = child->GetPreviousSibling()) {
98817:     nsresult rv = RelativeFontChangeHelper(aSizeChange, child);
98817:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
98817:   return NS_OK;
97990: }
97990: 
    1: 
    1: nsresult
98818: nsHTMLEditor::RelativeFontChangeOnNode(PRInt32 aSizeChange, nsINode* aNode)
    1: {
98818:   MOZ_ASSERT(aNode);
    1:   // Can only change font size by + or - 1
98818:   if (aSizeChange != 1 && aSizeChange != -1) {
    1:     return NS_ERROR_ILLEGAL_VALUE;
98818:   }
    1: 
97376:   nsIAtom* atom;
97376:   if (aSizeChange == 1) {
97376:     atom = nsGkAtoms::big;
97376:   } else {
97376:     atom = nsGkAtoms::small;
97376:   }
    1:   
98818:   // Is it the opposite of what we want?
98818:   if (aNode->IsElement() &&
98818:       ((aSizeChange == 1 && aNode->AsElement()->IsHTML(nsGkAtoms::small)) ||
98818:        (aSizeChange == -1 && aNode->AsElement()->IsHTML(nsGkAtoms::big)))) {
    1:     // first populate any nested font tags that have the size attr set
98818:     nsresult rv = RelativeFontChangeHelper(aSizeChange, aNode);
98818:     NS_ENSURE_SUCCESS(rv, rv);
    1:     // in that case, just remove this node and pull up the children
98818:     return RemoveContainer(aNode);
    1:   }
98818: 
    1:   // can it be put inside a "big" or "small"?
98818:   if (TagCanContain(atom, aNode->AsDOMNode())) {
    1:     // first populate any nested font tags that have the size attr set
98818:     nsresult rv = RelativeFontChangeHelper(aSizeChange, aNode);
98818:     NS_ENSURE_SUCCESS(rv, rv);
98818: 
    1:     // ok, chuck it in.
    1:     // first look at siblings of aNode for matching bigs or smalls.
    1:     // if we find one, move aNode into it.
98818:     nsIContent* sibling = GetPriorHTMLSibling(aNode);
98818:     if (sibling && sibling->IsHTML(atom)) {
    1:       // previous sib is already right kind of inline node; slide this over into it
98818:       return MoveNode(aNode->AsDOMNode(), sibling->AsDOMNode(), -1);
    1:     }
98818: 
98818:     sibling = GetNextHTMLSibling(aNode);
98818:     if (sibling && sibling->IsHTML(atom)) {
    1:       // following sib is already right kind of inline node; slide this over into it
98818:       return MoveNode(aNode->AsDOMNode(), sibling->AsDOMNode(), 0);
    1:     }
98818: 
    1:     // else insert it above aNode
98818:     nsCOMPtr<nsIDOMNode> tmp;
98818:     return InsertContainerAbove(aNode->AsDOMNode(), address_of(tmp),
98818:                                 nsAtomString(atom));
    1:   }
98818: 
    1:   // none of the above?  then cycle through the children.
    1:   // MOOSE: we should group the children together if possible
    1:   // into a single "big" or "small".  For the moment they are
    1:   // each getting their own.  
98818:   for (nsIContent* child = aNode->GetLastChild();
98818:        child;
98818:        child = child->GetPreviousSibling()) {
98818:     nsresult rv = RelativeFontChangeOnNode(aSizeChange, child);
98818:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
98818: 
98818:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP 
79445: nsHTMLEditor::GetFontFaceState(bool *aMixed, nsAString &outFace)
    1: {
43807:   NS_ENSURE_TRUE(aMixed, NS_ERROR_FAILURE);
80486:   *aMixed = true;
    1:   outFace.Truncate();
    1: 
    1:   nsresult res;
79445:   bool first, any, all;
    1:   
    1:   NS_NAMED_LITERAL_STRING(attr, "face");
    1:   res = GetInlinePropertyBase(nsEditProperty::font, &attr, nsnull, &first, &any, &all, &outFace);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (any && !all) return res; // mixed
    1:   if (all)
    1:   {
80486:     *aMixed = false;
    1:     return res;
    1:   }
    1:   
    1:   // if there is no font face, check for tt
    1:   res = GetInlinePropertyBase(nsEditProperty::tt, nsnull, nsnull, &first, &any, &all,nsnull);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (any && !all) return res; // mixed
    1:   if (all)
    1:   {
80486:     *aMixed = false;
    1:     nsEditProperty::tt->ToString(outFace);
    1:   }
    1:   
    1:   if (!any)
    1:   {
    1:     // there was no font face attrs of any kind.  We are in normal font.
    1:     outFace.Truncate();
80486:     *aMixed = false;
    1:   }
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP 
79445: nsHTMLEditor::GetFontColorState(bool *aMixed, nsAString &aOutColor)
    1: {
43807:   NS_ENSURE_TRUE(aMixed, NS_ERROR_NULL_POINTER);
80486:   *aMixed = true;
    1:   aOutColor.Truncate();
    1:   
    1:   nsresult res;
    1:   NS_NAMED_LITERAL_STRING(colorStr, "color");
79445:   bool first, any, all;
    1:   
    1:   res = GetInlinePropertyBase(nsEditProperty::font, &colorStr, nsnull, &first, &any, &all, &aOutColor);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (any && !all) return res; // mixed
    1:   if (all)
    1:   {
80486:     *aMixed = false;
    1:     return res;
    1:   }
    1:   
    1:   if (!any)
    1:   {
    1:     // there was no font color attrs of any kind..
    1:     aOutColor.Truncate();
80486:     *aMixed = false;
    1:   }
    1:   return res;
    1: }
    1: 
    1: // the return value is true only if the instance of the HTML editor we created
    1: // can handle CSS styles (for instance, Composer can, Messenger can't) and if
    1: // the CSS preference is checked
    1: nsresult
79445: nsHTMLEditor::GetIsCSSEnabled(bool *aIsCSSEnabled)
    1: {
89175:   *aIsCSSEnabled = IsCSSEnabled();
    1:   return NS_OK;
    1: }
    1: 
89176: static bool
89176: HasNonEmptyAttribute(dom::Element* aElement, nsIAtom* aName)
    1: {
89176:   MOZ_ASSERT(aElement);
    1: 
89176:   nsAutoString value;
89176:   return aElement->GetAttr(kNameSpaceID_None, aName, value) && !value.IsEmpty();
89176: }
89176: 
89176: bool
89176: nsHTMLEditor::HasStyleOrIdOrClass(dom::Element* aElement)
89176: {
89176:   MOZ_ASSERT(aElement);
    1: 
    1:   // remove the node if its style attribute is empty or absent,
    1:   // and if it does not have a class nor an id
89176:   return HasNonEmptyAttribute(aElement, nsGkAtoms::style) ||
89176:          HasNonEmptyAttribute(aElement, nsGkAtoms::_class) ||
89176:          HasNonEmptyAttribute(aElement, nsGkAtoms::id);
    1: }
    1: 
    1: nsresult
89176: nsHTMLEditor::RemoveElementIfNoStyleOrIdOrClass(nsIDOMNode* aElement)
    1: {
89176:   nsCOMPtr<dom::Element> element = do_QueryInterface(aElement);
89176:   NS_ENSURE_TRUE(element, NS_ERROR_NULL_POINTER);
    1: 
    1:   // early way out if node is not the right kind of element
96753:   if ((!element->IsHTML(nsGkAtoms::span) &&
96753:        !element->IsHTML(nsGkAtoms::font)) ||
96753:       HasStyleOrIdOrClass(element)) {
    1:     return NS_OK;
    1:   }
89176: 
89176:   return RemoveContainer(element);
    1: }
