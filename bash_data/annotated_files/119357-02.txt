     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 42402: #include "nsHTMLCanvasElement.h"
115564: #include "nsAttrValueInlines.h"
 42402: 
 71465: #include "mozilla/Base64.h"
 98543: #include "mozilla/CheckedInt.h"
     1: #include "nsNetUtil.h"
 54294: #include "nsDOMFile.h"
     1: 
101146: #include "nsICanvasRenderingContextInternal.h"
101146: #include "nsIDOMCanvasRenderingContext2D.h"
     1: #include "nsIScriptSecurityManager.h"
     1: #include "nsIXPConnect.h"
     1: #include "jsapi.h"
103385: #include "jsfriendapi.h"
 75263: #include "nsContentUtils.h"
 59889: #include "nsJSUtils.h"
 70899: #include "nsMathUtils.h"
 89440: #include "nsStreamUtils.h"
 72429: #include "mozilla/Preferences.h"
 78509: #include "mozilla/Telemetry.h"
     1: 
 42402: #include "nsFrameManager.h"
 47740: #include "nsDisplayList.h"
 42402: #include "BasicLayers.h"
 57631: #include "imgIEncoder.h"
111089: #include "nsITimer.h"
111089: #include "nsAsyncDOMEvent.h"
 57631: 
 57631: #include "nsIWritablePropertyBag2.h"
 30125: 
     1: #define DEFAULT_CANVAS_WIDTH 300
     1: #define DEFAULT_CANVAS_HEIGHT 150
     1: 
 42402: using namespace mozilla;
 56805: using namespace mozilla::dom;
 42402: using namespace mozilla::layers;
     1: 
118981: namespace {
118981: 
118981: class ToBlobRunnable : public nsRunnable
118981: {
118981: public:
118981:   ToBlobRunnable(nsIFileCallback* aCallback,
118981:                  nsIDOMBlob* aBlob)
118981:     : mCallback(aCallback),
118981:       mBlob(aBlob)
118981:   {
118981:     NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
118981:   }
118981: 
118981:   NS_IMETHOD Run()
118981:   {
118981:     NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
118981:     mCallback->Receive(mBlob);
118981:     return NS_OK;
118981:   }
118981: private:
118981:   nsCOMPtr<nsIFileCallback> mCallback;
118981:   nsCOMPtr<nsIDOMBlob> mBlob;
118981: };
118981: 
118981: } // anonymous namespace
118981: 
111089: class nsHTMLCanvasPrintState : public nsIDOMMozCanvasPrintState
111089: {
111089: public:
111089:   nsHTMLCanvasPrintState(nsHTMLCanvasElement* aCanvas,
111089:                          nsICanvasRenderingContextInternal* aContext,
111089:                          nsITimerCallback* aCallback)
111089:     : mIsDone(false), mPendingNotify(false), mCanvas(aCanvas),
111089:       mContext(aContext), mCallback(aCallback)
111089:   {
111089:   }
111089: 
111089:   NS_IMETHOD GetContext(nsISupports** aContext)
111089:   {
111089:     NS_ADDREF(*aContext = mContext);
111089:     return NS_OK;
111089:   }
111089: 
111089:   NS_IMETHOD Done()
111089:   {
111089:     if (!mPendingNotify && !mIsDone) {
111089:       // The canvas needs to be invalidated for printing reftests on linux to
111089:       // work.
111089:       if (mCanvas) {
111089:         mCanvas->InvalidateCanvas();
111089:       }
111089:       nsRefPtr<nsRunnableMethod<nsHTMLCanvasPrintState> > doneEvent =
111089:         NS_NewRunnableMethod(this, &nsHTMLCanvasPrintState::NotifyDone);
111089:       if (NS_SUCCEEDED(NS_DispatchToCurrentThread(doneEvent))) {
111089:         mPendingNotify = true;
111089:       }
111089:     }
111089:     return NS_OK;
111089:   }
111089: 
111089:   void NotifyDone()
111089:   {
111089:     mIsDone = true;
111089:     mPendingNotify = false;
111089:     if (mCallback) {
111089:       mCallback->Notify(nullptr);
111089:     }
111089:   }
111089: 
111089:   bool mIsDone;
111089: 
111089:   // CC
111089:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
111089:   NS_DECL_CYCLE_COLLECTION_CLASS(nsHTMLCanvasPrintState)
111089: private:
111089:   virtual ~nsHTMLCanvasPrintState()
111089:   {
111089:   }
111089:   bool mPendingNotify;
111089: 
111089: protected:
111089:   nsRefPtr<nsHTMLCanvasElement> mCanvas;
111089:   nsCOMPtr<nsICanvasRenderingContextInternal> mContext;
111089:   nsCOMPtr<nsITimerCallback> mCallback;
111089: };
111089: 
111089: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsHTMLCanvasPrintState)
111089: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsHTMLCanvasPrintState)
111089: 
111089: DOMCI_DATA(MozCanvasPrintState, nsHTMLCanvasPrintState)
111089: 
111089: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsHTMLCanvasPrintState)
111089:   NS_INTERFACE_MAP_ENTRY(nsISupports)
111089:   NS_INTERFACE_MAP_ENTRY(nsIDOMMozCanvasPrintState)
111089:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(MozCanvasPrintState)
111089: NS_INTERFACE_MAP_END
111089: 
111089: NS_IMPL_CYCLE_COLLECTION_CLASS(nsHTMLCanvasPrintState)
111089: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsHTMLCanvasPrintState)
111089:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mCanvas, nsIDOMHTMLCanvasElement)
111089:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mContext)
111089:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mCallback)
111089: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
111089: 
111089: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsHTMLCanvasPrintState)
111089:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mCanvas)
111089:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mContext)
111089:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mCallback)
111089: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
111089: // ---------------------------------------------------------------------------
111089: 
     1: nsGenericHTMLElement*
 94340: NS_NewHTMLCanvasElement(already_AddRefed<nsINodeInfo> aNodeInfo,
 56805:                         FromParser aFromParser)
     1: {
 11169:   return new nsHTMLCanvasElement(aNodeInfo);
     1: }
     1: 
 94340: nsHTMLCanvasElement::nsHTMLCanvasElement(already_AddRefed<nsINodeInfo> aNodeInfo)
111089:   : nsGenericHTMLElement(aNodeInfo), 
111089:     mWriteOnly(false)
     1: {
     1: }
     1: 
     1: nsHTMLCanvasElement::~nsHTMLCanvasElement()
     1: {
111089:   ResetPrintCallback();
     1: }
 43655: 
 43655: NS_IMPL_CYCLE_COLLECTION_CLASS(nsHTMLCanvasElement)
 43655: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsHTMLCanvasElement,
 43655:                                                   nsGenericHTMLElement)
 43655:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mCurrentContext)
111089:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mPrintCallback)
111089:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mPrintState)
111089:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOriginalCanvas)
 43655: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
     1: 
 72165: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsHTMLCanvasElement,
 72165:                                                 nsGenericHTMLElement)
 72165:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mCurrentContext)
111089:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mPrintCallback)
111089:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mPrintState)
111089:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOriginalCanvas)
 72165: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 72165: 
     1: NS_IMPL_ADDREF_INHERITED(nsHTMLCanvasElement, nsGenericElement)
     1: NS_IMPL_RELEASE_INHERITED(nsHTMLCanvasElement, nsGenericElement)
     1: 
 48124: DOMCI_NODE_DATA(HTMLCanvasElement, nsHTMLCanvasElement)
 40490: 
 43655: NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsHTMLCanvasElement)
 21218:   NS_HTML_CONTENT_INTERFACE_TABLE2(nsHTMLCanvasElement,
  4838:                                    nsIDOMHTMLCanvasElement,
 42402:                                    nsICanvasElementExternal)
 21218:   NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLCanvasElement,
 21218:                                                nsGenericHTMLElement)
  4838: NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLCanvasElement)
     1: 
     1: NS_IMPL_ELEMENT_CLONE(nsHTMLCanvasElement)
     1: 
     1: nsIntSize
     1: nsHTMLCanvasElement::GetWidthHeight()
     1: {
 70071:   nsIntSize size(DEFAULT_CANVAS_WIDTH, DEFAULT_CANVAS_HEIGHT);
     1:   const nsAttrValue* value;
     1: 
     1:   if ((value = GetParsedAttr(nsGkAtoms::width)) &&
     1:       value->Type() == nsAttrValue::eInteger)
     1:   {
     1:       size.width = value->GetIntegerValue();
     1:   }
     1: 
     1:   if ((value = GetParsedAttr(nsGkAtoms::height)) &&
     1:       value->Type() == nsAttrValue::eInteger)
     1:   {
     1:       size.height = value->GetIntegerValue();
     1:   }
     1: 
     1:   return size;
     1: }
     1: 
 63873: NS_IMPL_UINT_ATTR_DEFAULT_VALUE(nsHTMLCanvasElement, Width, width, DEFAULT_CANVAS_WIDTH)
 63873: NS_IMPL_UINT_ATTR_DEFAULT_VALUE(nsHTMLCanvasElement, Height, height, DEFAULT_CANVAS_HEIGHT)
 15234: NS_IMPL_BOOL_ATTR(nsHTMLCanvasElement, MozOpaque, moz_opaque)
     1: 
     1: nsresult
108991: nsHTMLCanvasElement::SetAttr(int32_t aNameSpaceID, nsIAtom* aName,
     1:                              nsIAtom* aPrefix, const nsAString& aValue,
 79445:                              bool aNotify)
     1: {
     1:   nsresult rv = nsGenericHTMLElement::SetAttr(aNameSpaceID, aName, aPrefix, aValue,
     1:                                               aNotify);
     1:   if (NS_SUCCEEDED(rv) && mCurrentContext &&
 15234:       (aName == nsGkAtoms::width || aName == nsGkAtoms::height || aName == nsGkAtoms::moz_opaque))
     1:   {
     1:     rv = UpdateContext();
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
111089: void
111089: nsHTMLCanvasElement::HandlePrintCallback(nsPresContext::nsPresContextType aType)
111089: {
111089:   // Only call the print callback here if 1) we're in a print testing mode or
111089:   // print preview mode, 2) the canvas has a print callback and 3) the callback
111089:   // hasn't already been called. For real printing the callback is handled in
111089:   // nsSimplePageSequenceFrame::PrePrintNextPage.
111089:   nsCOMPtr<nsIPrintCallback> printCallback;
111089:   if ((aType == nsPresContext::eContext_PageLayout ||
111089:        aType == nsPresContext::eContext_PrintPreview) &&
111089:       !mPrintState &&
111089:       NS_SUCCEEDED(GetMozPrintCallback(getter_AddRefs(printCallback))) && printCallback) {
111089:     DispatchPrintCallback(nullptr);
111089:   }
111089: }
111089: 
111089: nsresult
111089: nsHTMLCanvasElement::DispatchPrintCallback(nsITimerCallback* aCallback)
111089: {
111089:   // For print reftests the context may not be initialized yet, so get a context
111089:   // so mCurrentContext is set.
111089:   if (!mCurrentContext) {
111089:     nsresult rv;
111089:     nsCOMPtr<nsISupports> context;
111089:     rv = GetContext(NS_LITERAL_STRING("2d"), JSVAL_VOID,
111089:                     getter_AddRefs(context));
111089:     NS_ENSURE_SUCCESS(rv, rv);
111089:   }
111089:   mPrintState = new nsHTMLCanvasPrintState(this, mCurrentContext, aCallback);
111089: 
111089:   nsRefPtr<nsRunnableMethod<nsHTMLCanvasElement> > renderEvent =
111089:         NS_NewRunnableMethod(this, &nsHTMLCanvasElement::CallPrintCallback);
111089:   return NS_DispatchToCurrentThread(renderEvent);
111089: }
111089: 
111089: void
111089: nsHTMLCanvasElement::CallPrintCallback()
111089: {
111089:   nsCOMPtr<nsIPrintCallback> printCallback;
111089:   GetMozPrintCallback(getter_AddRefs(printCallback));
111089:   printCallback->Render(mPrintState);
111089: }
111089: 
111089: void
111089: nsHTMLCanvasElement::ResetPrintCallback()
111089: {
111089:   if (mPrintState) {
111089:     mPrintState = nullptr;
111089:   }
111089: }
111089: 
111089: bool
111089: nsHTMLCanvasElement::IsPrintCallbackDone()
111089: {
111089:   if (mPrintState == nullptr) {
111089:     return true;
111089:   }
111089: 
111089:   return mPrintState->mIsDone;
111089: }
111089: 
111089: nsIDOMHTMLCanvasElement*
111089: nsHTMLCanvasElement::GetOriginalCanvas()
111089: {
111089:   return mOriginalCanvas ? mOriginalCanvas.get() : this;
111089: }
111089: 
111089: 
 35581: nsresult
103999: nsHTMLCanvasElement::CopyInnerTo(nsGenericElement* aDest)
 35581: {
 35581:   nsresult rv = nsGenericHTMLElement::CopyInnerTo(aDest);
 35581:   NS_ENSURE_SUCCESS(rv, rv);
 80526:   if (aDest->OwnerDoc()->IsStaticDocument()) {
 35581:     nsHTMLCanvasElement* dest = static_cast<nsHTMLCanvasElement*>(aDest);
111089:     nsHTMLCanvasElement* self = const_cast<nsHTMLCanvasElement*>(this);
111089:     dest->mOriginalCanvas = self;
111089: 
 35581:     nsCOMPtr<nsISupports> cxt;
 57631:     dest->GetContext(NS_LITERAL_STRING("2d"), JSVAL_VOID, getter_AddRefs(cxt));
 35581:     nsCOMPtr<nsIDOMCanvasRenderingContext2D> context2d = do_QueryInterface(cxt);
111089:     if (context2d && !self->mPrintCallback) {
111089:       context2d->DrawImage(self,
 35581:                            0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0);
 35581:     }
 35581:   }
 35581:   return rv;
 35581: }
 35581: 
     1: nsChangeHint
     1: nsHTMLCanvasElement::GetAttributeChangeHint(const nsIAtom* aAttribute,
108991:                                             int32_t aModType) const
     1: {
     1:   nsChangeHint retval =
     1:     nsGenericHTMLElement::GetAttributeChangeHint(aAttribute, aModType);
     1:   if (aAttribute == nsGkAtoms::width ||
     1:       aAttribute == nsGkAtoms::height)
     1:   {
     1:     NS_UpdateHint(retval, NS_STYLE_HINT_REFLOW);
 15234:   } else if (aAttribute == nsGkAtoms::moz_opaque)
 15234:   {
 89564:     NS_UpdateHint(retval, NS_STYLE_HINT_VISUAL);
     1:   }
     1:   return retval;
     1: }
     1: 
 79445: bool
108991: nsHTMLCanvasElement::ParseAttribute(int32_t aNamespaceID,
     1:                                     nsIAtom* aAttribute,
     1:                                     const nsAString& aValue,
     1:                                     nsAttrValue& aResult)
     1: {
 41186:   if (aNamespaceID == kNameSpaceID_None &&
 41186:       (aAttribute == nsGkAtoms::width || aAttribute == nsGkAtoms::height)) {
 63873:     return aResult.ParseNonNegativeIntValue(aValue);
     1:   }
     1: 
     1:   return nsGenericHTMLElement::ParseAttribute(aNamespaceID, aAttribute, aValue,
     1:                                               aResult);
     1: }
     1: 
     1: 
     1: // nsHTMLCanvasElement::toDataURL
     1: 
     1: NS_IMETHODIMP
 70899: nsHTMLCanvasElement::ToDataURL(const nsAString& aType, nsIVariant* aParams,
108991:                                uint8_t optional_argc, nsAString& aDataURL)
     1: {
     1:   // do a trust check if this is a write-only canvas
 70899:   if (mWriteOnly && !nsContentUtils::IsCallerTrustedForRead()) {
     1:     return NS_ERROR_DOM_SECURITY_ERR;
     1:   }
     1: 
 47330:   return ToDataURLImpl(aType, aParams, aDataURL);
     1: }
     1: 
 89196: // nsHTMLCanvasElement::mozFetchAsStream
 89196: 
 89196: NS_IMETHODIMP
 89196: nsHTMLCanvasElement::MozFetchAsStream(nsIInputStreamCallback *aCallback,
 89196:                                       const nsAString& aType)
 89196: {
 89196:   if (!nsContentUtils::IsCallerChrome())
 89196:     return NS_ERROR_FAILURE;
 89196: 
 89196:   nsresult rv;
 89196:   bool fellBackToPNG = false;
 89196:   nsCOMPtr<nsIInputStream> inputData;
 89196: 
 89196:   rv = ExtractData(aType, EmptyString(), getter_AddRefs(inputData), fellBackToPNG);
 89196:   NS_ENSURE_SUCCESS(rv, rv);
 89196: 
 89196:   nsCOMPtr<nsIAsyncInputStream> asyncData = do_QueryInterface(inputData, &rv);
 89196:   NS_ENSURE_SUCCESS(rv, rv);
 89196: 
 89440:   nsCOMPtr<nsIThread> mainThread;
 89440:   rv = NS_GetMainThread(getter_AddRefs(mainThread));
 89440:   NS_ENSURE_SUCCESS(rv, rv);
 89440: 
 89440:   nsCOMPtr<nsIInputStreamCallback> asyncCallback;
 89440:   rv = NS_NewInputStreamReadyEvent(getter_AddRefs(asyncCallback), aCallback, mainThread);
 89440:   NS_ENSURE_SUCCESS(rv, rv);
 89440: 
 89440:   return asyncCallback->OnInputStreamReady(asyncData);
 89196: }
 89196: 
111089: NS_IMETHODIMP
111089: nsHTMLCanvasElement::SetMozPrintCallback(nsIPrintCallback *aCallback)
111089: {
111089:   mPrintCallback = aCallback;
111089:   return NS_OK;
111089: }
111089: 
111089: NS_IMETHODIMP
111089: nsHTMLCanvasElement::GetMozPrintCallback(nsIPrintCallback** aCallback)
111089: {
111089:   if (mOriginalCanvas) {
111089:     mOriginalCanvas->GetMozPrintCallback(aCallback);
111089:     return NS_OK;
111089:   }
111089:   NS_IF_ADDREF(*aCallback = mPrintCallback);
111089:   return NS_OK;
111089: }
111089: 
     1: nsresult
 54294: nsHTMLCanvasElement::ExtractData(const nsAString& aType,
 54294:                                  const nsAString& aOptions,
 71465:                                  nsIInputStream** aStream,
 54294:                                  bool& aFellBackToPNG)
     1: {
 57631:   // note that if we don't have a current context, the spec says we're
 57631:   // supposed to just return transparent black pixels of the canvas
 57631:   // dimensions.
 57631:   nsRefPtr<gfxImageSurface> emptyCanvas;
 57631:   nsIntSize size = GetWidthHeight();
 57631:   if (!mCurrentContext) {
 57631:     emptyCanvas = new gfxImageSurface(gfxIntSize(size.width, size.height), gfxASurface::ImageFormatARGB32);
 77274:     if (emptyCanvas->CairoStatus()) {
 77274:       return NS_ERROR_INVALID_ARG;
 77274:     }
 51845:   }
     1: 
 57631:   nsresult rv;
 57631: 
     1:   // get image bytes
     1:   nsCOMPtr<nsIInputStream> imgStream;
 64432:   NS_ConvertUTF16toUTF8 encoderType(aType);
 57631: 
 57631:  try_again:
 57631:   if (mCurrentContext) {
 71728:     rv = mCurrentContext->GetInputStream(encoderType.get(),
 54294:                                          nsPromiseFlatString(aOptions).get(),
     1:                                          getter_AddRefs(imgStream));
 57631:   } else {
 57631:     // no context, so we have to encode the empty image we created above
 57631:     nsCString enccid("@mozilla.org/image/encoder;2?type=");
 57631:     enccid += encoderType;
 57631: 
 71728:     nsCOMPtr<imgIEncoder> encoder = do_CreateInstance(enccid.get(), &rv);
 57631:     if (NS_SUCCEEDED(rv) && encoder) {
 57631:       rv = encoder->InitFromData(emptyCanvas->Data(),
 57631:                                  size.width * size.height * 4,
 57631:                                  size.width,
 57631:                                  size.height,
 57631:                                  size.width * 4,
 57631:                                  imgIEncoder::INPUT_FORMAT_HOSTARGB,
 57631:                                  aOptions);
 57631:       if (NS_SUCCEEDED(rv)) {
 57631:         imgStream = do_QueryInterface(encoder);
 57631:       }
 57631:     } else {
 57631:       rv = NS_ERROR_FAILURE;
 57631:     }
 57631:   }
 57631: 
 57631:   if (NS_FAILED(rv) && !aFellBackToPNG) {
 57631:     // Try image/png instead.
     1:     // XXX ERRMSG we need to report an error to developers here! (bug 329026)
 54294:     aFellBackToPNG = true;
 57631:     encoderType.AssignLiteral("image/png");
 57631:     goto try_again;
 57631:   }
 57631: 
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 82292:   imgStream.forget(aStream);
 54294:   return NS_OK;
 54294: }
 54294: 
 54294: nsresult
 54294: nsHTMLCanvasElement::ToDataURLImpl(const nsAString& aMimeType,
 70899:                                    nsIVariant* aEncoderOptions,
 54294:                                    nsAString& aDataURL)
 54294: {
 54294:   bool fallbackToPNG = false;
 57631: 
 70118:   nsIntSize size = GetWidthHeight();
 70118:   if (size.height == 0 || size.width == 0) {
 70118:     aDataURL = NS_LITERAL_STRING("data:,");
 70118:     return NS_OK;
 70118:   }
 70118: 
 64432:   nsAutoString type;
 93605:   nsresult rv = nsContentUtils::ASCIIToLower(aMimeType, type);
 93605:   if (NS_FAILED(rv)) {
 93605:     return rv;
 93605:   }
 64432: 
 70899:   nsAutoString params;
 70899: 
 70899:   // Quality parameter is only valid for the image/jpeg MIME type
 70899:   if (type.EqualsLiteral("image/jpeg")) {
108991:     uint16_t vartype;
 70899: 
 70899:     if (aEncoderOptions &&
 70899:         NS_SUCCEEDED(aEncoderOptions->GetDataType(&vartype)) &&
 70899:         vartype <= nsIDataType::VTYPE_DOUBLE) {
 70899: 
 70899:       double quality;
 70899:       // Quality must be between 0.0 and 1.0, inclusive
 70899:       if (NS_SUCCEEDED(aEncoderOptions->GetAsDouble(&quality)) &&
 70899:           quality >= 0.0 && quality <= 1.0) {
 70899:         params.AppendLiteral("quality=");
 70899:         params.AppendInt(NS_lround(quality * 100.0));
 70899:       }
 70899:     }
 70899:   }
 70899: 
 77231:   // If we haven't parsed the params check for proprietary options.
 77231:   // The proprietary option -moz-parse-options will take a image lib encoder
 77231:   // parse options string as is and pass it to the encoder.
 79445:   bool usingCustomParseOptions = false;
 77231:   if (params.Length() == 0) {
 77231:     NS_NAMED_LITERAL_STRING(mozParseOptions, "-moz-parse-options:");
 77231:     nsAutoString paramString;
 77231:     if (NS_SUCCEEDED(aEncoderOptions->GetAsAString(paramString)) && 
 77231:         StringBeginsWith(paramString, mozParseOptions)) {
 77231:       nsDependentSubstring parseOptions = Substring(paramString, 
 77231:                                                     mozParseOptions.Length(), 
 77231:                                                     paramString.Length() - 
 77231:                                                     mozParseOptions.Length());
 77231:       params.Append(parseOptions);
 80486:       usingCustomParseOptions = true;
 77231:     }
 77231:   }
 77231: 
 71465:   nsCOMPtr<nsIInputStream> stream;
 93605:   rv = ExtractData(type, params, getter_AddRefs(stream), fallbackToPNG);
 77231: 
 77231:   // If there are unrecognized custom parse options, we should fall back to 
 77231:   // the default values for the encoder without any options at all.
 77231:   if (rv == NS_ERROR_INVALID_ARG && usingCustomParseOptions) {
 77231:     fallbackToPNG = false;
 77231:     rv = ExtractData(type, EmptyString(), getter_AddRefs(stream), fallbackToPNG);
 77231:   }
 77231: 
 54294:   NS_ENSURE_SUCCESS(rv, rv);
 54294: 
     1:   // build data URL string
 47330:   if (fallbackToPNG)
 71465:     aDataURL = NS_LITERAL_STRING("data:image/png;base64,");
 47330:   else
 64432:     aDataURL = NS_LITERAL_STRING("data:") + type +
 71465:       NS_LITERAL_STRING(";base64,");
     1: 
108991:   uint64_t count;
 71465:   rv = stream->Available(&count);
 71465:   NS_ENSURE_SUCCESS(rv, rv);
115367:   NS_ENSURE_TRUE(count <= UINT32_MAX, NS_ERROR_FILE_TOO_BIG);
     1: 
108991:   return Base64EncodeInputStream(stream, aDataURL, (uint32_t)count, aDataURL.Length());
     1: }
     1: 
118981: // XXXkhuey the encoding should be off the main thread, but we're lazy.
118981: NS_IMETHODIMP
118981: nsHTMLCanvasElement::ToBlob(nsIFileCallback* aCallback,
118981:                             const nsAString& aType,
118981:                             nsIVariant* aParams,
118981:                             uint8_t optional_argc)
118981: {
118981:   // do a trust check if this is a write-only canvas
118981:   if (mWriteOnly && !nsContentUtils::IsCallerTrustedForRead()) {
118981:     return NS_ERROR_DOM_SECURITY_ERR;
118981:   }
118981: 
119357:   if (!aCallback) {
119357:     return NS_ERROR_UNEXPECTED;
119357:   }
119357: 
118981:   nsAutoString type;
118981:   nsresult rv = nsContentUtils::ASCIIToLower(aType, type);
118981:   if (NS_FAILED(rv)) {
118981:     return rv;
118981:   }
118981: 
118981:   bool fallbackToPNG = false;
118981: 
118981:   nsCOMPtr<nsIInputStream> stream;
118987:   rv = ExtractData(type, EmptyString(), getter_AddRefs(stream), fallbackToPNG);
118981:   NS_ENSURE_SUCCESS(rv, rv);
118981: 
118981:   if (fallbackToPNG) {
118981:     type.AssignLiteral("image/png");
118981:   }
118981: 
118981:   uint64_t imgSize;
118981:   rv = stream->Available(&imgSize);
118981:   NS_ENSURE_SUCCESS(rv, rv);
118981:   NS_ENSURE_TRUE(imgSize <= UINT32_MAX, NS_ERROR_FILE_TOO_BIG);
118981: 
118981:   void* imgData = nullptr;
118981:   rv = NS_ReadInputStreamToBuffer(stream, &imgData, imgSize);
118981:   NS_ENSURE_SUCCESS(rv, rv);
118981: 
118981:   // The DOMFile takes ownership of the buffer
118981:   nsRefPtr<nsDOMMemoryFile> blob =
118981:     new nsDOMMemoryFile(imgData, imgSize, type);
118981: 
118981:   nsRefPtr<ToBlobRunnable> runnable = new ToBlobRunnable(aCallback, blob);
118981:   return NS_DispatchToCurrentThread(runnable);
118981: }
118981: 
 54294: NS_IMETHODIMP
 54294: nsHTMLCanvasElement::MozGetAsFile(const nsAString& aName,
 54294:                                   const nsAString& aType,
108991:                                   uint8_t optional_argc,
 54294:                                   nsIDOMFile** aResult)
 54294: {
 54294:   // do a trust check if this is a write-only canvas
 54294:   if ((mWriteOnly) &&
 54294:       !nsContentUtils::IsCallerTrustedForRead()) {
 54294:     return NS_ERROR_DOM_SECURITY_ERR;
 54294:   }
 54294: 
 54294:   return MozGetAsFileImpl(aName, aType, aResult);
 54294: }
 54294: 
 54294: nsresult
 54294: nsHTMLCanvasElement::MozGetAsFileImpl(const nsAString& aName,
 54294:                                       const nsAString& aType,
 54294:                                       nsIDOMFile** aResult)
 54294: {
 54294:   bool fallbackToPNG = false;
 54294: 
 71465:   nsCOMPtr<nsIInputStream> stream;
 71465:   nsresult rv = ExtractData(aType, EmptyString(), getter_AddRefs(stream),
 71465:                             fallbackToPNG);
 54294:   NS_ENSURE_SUCCESS(rv, rv);
 54294: 
 54294:   nsAutoString type(aType);
 54294:   if (fallbackToPNG) {
 54294:     type.AssignLiteral("image/png");
 54294:   }
 54294: 
108991:   uint64_t imgSize;
 71465:   rv = stream->Available(&imgSize);
 71465:   NS_ENSURE_SUCCESS(rv, rv);
115367:   NS_ENSURE_TRUE(imgSize <= UINT32_MAX, NS_ERROR_FILE_TOO_BIG);
 71465: 
106838:   void* imgData = nullptr;
108991:   rv = NS_ReadInputStreamToBuffer(stream, &imgData, (uint32_t)imgSize);
 71465:   NS_ENSURE_SUCCESS(rv, rv);
 71465: 
 54294:   // The DOMFile takes ownership of the buffer
 54294:   nsRefPtr<nsDOMMemoryFile> file =
108991:     new nsDOMMemoryFile(imgData, (uint32_t)imgSize, aName, type);
 54294: 
 82292:   file.forget(aResult);
 82292:   return NS_OK;
 54294: }
 54294: 
 46756: nsresult
 46756: nsHTMLCanvasElement::GetContextHelper(const nsAString& aContextId,
 46756:                                       nsICanvasRenderingContextInternal **aContext)
     1: {
 46756:   NS_ENSURE_ARG(aContext);
     1: 
 73612:   NS_ConvertUTF16toUTF8 ctxId(aContextId);
     1: 
     1:   // check that ctxId is clamped to A-Za-z0-9_-
108991:   for (uint32_t i = 0; i < ctxId.Length(); i++) {
     1:     if ((ctxId[i] < 'A' || ctxId[i] > 'Z') &&
     1:         (ctxId[i] < 'a' || ctxId[i] > 'z') &&
     1:         (ctxId[i] < '0' || ctxId[i] > '9') &&
     1:         (ctxId[i] != '-') &&
     1:         (ctxId[i] != '_'))
     1:     {
     1:       // XXX ERRMSG we need to report an error to developers here! (bug 329026)
 47330:       return NS_OK;
     1:     }
     1:   }
     1: 
     1:   nsCString ctxString("@mozilla.org/content/canvas-rendering-context;1?id=");
     1:   ctxString.Append(ctxId);
     1: 
 46756:   nsresult rv;
 46756:   nsCOMPtr<nsICanvasRenderingContextInternal> ctx =
 71728:     do_CreateInstance(ctxString.get(), &rv);
 46756:   if (rv == NS_ERROR_OUT_OF_MEMORY) {
106838:     *aContext = nullptr;
     1:     return NS_ERROR_OUT_OF_MEMORY;
 46756:   }
 46756:   if (NS_FAILED(rv)) {
106838:     *aContext = nullptr;
 42402:     // XXX ERRMSG we need to report an error to developers here! (bug 329026)
 47330:     return NS_OK;
 46756:   }
 42402: 
101146:   ctx->SetCanvasElement(this);
 82292:   ctx.forget(aContext);
101146:   return NS_OK;
 46756: }
 46756: 
 46756: NS_IMETHODIMP
 46756: nsHTMLCanvasElement::GetContext(const nsAString& aContextId,
 98362:                                 const JS::Value& aContextOptions,
 46756:                                 nsISupports **aContext)
 46756: {
 46756:   nsresult rv;
 46756: 
118698:   if (mCurrentContextId.IsEmpty()) {
118698:     rv = GetContextHelper(aContextId, getter_AddRefs(mCurrentContext));
 47720:     NS_ENSURE_SUCCESS(rv, rv);
 47720:     if (!mCurrentContext) {
 47720:       return NS_OK;
 47720:     }
     1: 
 43655:     // Ensure that the context participates in CC.  Note that returning a
 43655:     // CC participant from QI doesn't addref.
106838:     nsXPCOMCycleCollectionParticipant *cp = nullptr;
 43655:     CallQueryInterface(mCurrentContext, &cp);
 43655:     if (!cp) {
106838:       mCurrentContext = nullptr;
 43655:       return NS_ERROR_FAILURE;
 43655:     }
 43655: 
 98362:     // note: if any contexts end up supporting something other
 98362:     // than objects, e.g. plain strings, then we'll need to expand
 98362:     // this to know how to create nsISupportsStrings etc.
 98362: 
 98321:     nsCOMPtr<nsIWritablePropertyBag2> contextProps;
 98820:     if (aContextOptions.isObject()) {
 98321:       JSContext* cx = nsContentUtils::GetCurrentJSContext();
 98321: 
 78815:       contextProps = do_CreateInstance("@mozilla.org/hash-property-bag;1");
 57631: 
 98820:       JSObject& opts = aContextOptions.toObject();
 98820:       JS::AutoIdArray props(cx, JS_Enumerate(cx, &opts));
 86994:       for (size_t i = 0; !!props && i < props.length(); ++i) {
 86994:         jsid propid = props[i];
 57631:         jsval propname, propval;
 57631:         if (!JS_IdToValue(cx, propid, &propname) ||
 98820:             !JS_GetPropertyById(cx, &opts, propid, &propval)) {
 98820:           return NS_ERROR_FAILURE;
 57631:         }
 57631: 
 57631:         JSString *propnameString = JS_ValueToString(cx, propname);
 59889:         nsDependentJSString pstr;
 59889:         if (!propnameString || !pstr.init(cx, propnameString)) {
106838:           mCurrentContext = nullptr;
 59889:           return NS_ERROR_FAILURE;
 59889:         }
 57631: 
 57631:         if (JSVAL_IS_BOOLEAN(propval)) {
 86994:           contextProps->SetPropertyAsBool(pstr, JSVAL_TO_BOOLEAN(propval));
 57631:         } else if (JSVAL_IS_INT(propval)) {
 78815:           contextProps->SetPropertyAsInt32(pstr, JSVAL_TO_INT(propval));
 57631:         } else if (JSVAL_IS_DOUBLE(propval)) {
 78815:           contextProps->SetPropertyAsDouble(pstr, JSVAL_TO_DOUBLE(propval));
 57631:         } else if (JSVAL_IS_STRING(propval)) {
 59889:           JSString *propvalString = JS_ValueToString(cx, propval);
 59889:           nsDependentJSString vstr;
 59889:           if (!propvalString || !vstr.init(cx, propvalString)) {
106838:             mCurrentContext = nullptr;
 59889:             return NS_ERROR_FAILURE;
 59889:           }
 59889: 
 78815:           contextProps->SetPropertyAsAString(pstr, vstr);
 57631:         }
 98362: 
 57631:       }
 57631:     }
 57631: 
 57631:     rv = UpdateContext(contextProps);
  2756:     if (NS_FAILED(rv)) {
  2756:       return rv;
  2756:     }
     1: 
     1:     mCurrentContextId.Assign(aContextId);
 73612:   }
118698: 
 73612:   if (!mCurrentContextId.Equals(aContextId)) {
     1:     //XXX eventually allow for more than one active context on a given canvas
 47330:     return NS_OK;
     1:   }
     1: 
     1:   NS_ADDREF (*aContext = mCurrentContext);
     1:   return NS_OK;
     1: }
     1: 
 46756: NS_IMETHODIMP
 46902: nsHTMLCanvasElement::MozGetIPCContext(const nsAString& aContextId,
 46756:                                       nsISupports **aContext)
 46756: {
 46756:   if(!nsContentUtils::IsCallerTrustedForRead()) {
 46756:     // XXX ERRMSG we need to report an error to developers here! (bug 329026)
 46756:     return NS_ERROR_DOM_SECURITY_ERR;
 46756:   }
 46756: 
 46756:   // We only support 2d shmem contexts for now.
 46756:   if (!aContextId.Equals(NS_LITERAL_STRING("2d")))
 46756:     return NS_ERROR_INVALID_ARG;
 46756: 
 46756:   if (mCurrentContextId.IsEmpty()) {
118698:     nsresult rv = GetContextHelper(aContextId, getter_AddRefs(mCurrentContext));
 47720:     NS_ENSURE_SUCCESS(rv, rv);
 47720:     if (!mCurrentContext) {
 47720:       return NS_OK;
 47720:     }
 46756: 
 80486:     mCurrentContext->SetIsIPC(true);
 46756: 
 46756:     rv = UpdateContext();
 74620:     NS_ENSURE_SUCCESS(rv, rv);
 46756: 
 46756:     mCurrentContextId.Assign(aContextId);
 46756:   } else if (!mCurrentContextId.Equals(aContextId)) {
 46756:     //XXX eventually allow for more than one active context on a given canvas
 46756:     return NS_ERROR_INVALID_ARG;
 46756:   }
 46756: 
 46756:   NS_ADDREF (*aContext = mCurrentContext);
 46756:   return NS_OK;
 46756: }
 46756: 
     1: nsresult
 57631: nsHTMLCanvasElement::UpdateContext(nsIPropertyBag *aNewContextOptions)
     1: {
 57631:   if (!mCurrentContext)
 57631:     return NS_OK;
 57631: 
 70173:   nsIntSize sz = GetWidthHeight();
 57631: 
 82292:   nsresult rv = mCurrentContext->SetIsOpaque(GetIsOpaque());
 70173:   if (NS_FAILED(rv)) {
106838:     mCurrentContext = nullptr;
 82292:     mCurrentContextId.Truncate();
 57631:     return rv;
 70173:   }
 57631: 
 57631:   rv = mCurrentContext->SetContextOptions(aNewContextOptions);
 70173:   if (NS_FAILED(rv)) {
106838:     mCurrentContext = nullptr;
 82292:     mCurrentContextId.Truncate();
 57631:     return rv;
 70173:   }
 57631: 
     1:   rv = mCurrentContext->SetDimensions(sz.width, sz.height);
 70173:   if (NS_FAILED(rv)) {
106838:     mCurrentContext = nullptr;
 82292:     mCurrentContextId.Truncate();
 57631:     return rv;
 70173:   }
     1: 
     1:   return rv;
     1: }
     1: 
 42402: nsIntSize
 42402: nsHTMLCanvasElement::GetSize()
     1: {
 42402:   return GetWidthHeight();
     1: }
     1: 
 79445: bool
     1: nsHTMLCanvasElement::IsWriteOnly()
     1: {
     1:   return mWriteOnly;
     1: }
     1: 
     1: void
     1: nsHTMLCanvasElement::SetWriteOnly()
     1: {
 80486:   mWriteOnly = true;
     1: }
  6313: 
 42402: void
 64542: nsHTMLCanvasElement::InvalidateCanvasContent(const gfxRect* damageRect)
  6313: {
 30125:   // We don't need to flush anything here; if there's no frame or if
 30125:   // we plan to reframe we don't need to invalidate it anyway.
 36655:   nsIFrame *frame = GetPrimaryFrame();
 42402:   if (!frame)
 42402:     return;
  6313: 
 72242:   frame->MarkLayersActive(nsChangeHint(0));
 64542: 
118659:   Layer* layer = nullptr;
 42402:   if (damageRect) {
 27097:     nsIntSize size = GetWidthHeight();
 70071:     if (size.width != 0 && size.height != 0) {
101681: 
 42402:       gfxRect realRect(*damageRect);
 27097:       realRect.RoundOut();
 27097: 
103530:       // then make it a nsRect
115308:       nsIntRect invalRect(realRect.X(), realRect.Y(),
 27097:                           realRect.Width(), realRect.Height());
103530: 
115308:       layer = frame->InvalidateLayer(nsDisplayItem::TYPE_CANVAS, &invalRect);
 70071:     }
 64542:   } else {
115308:     layer = frame->InvalidateLayer(nsDisplayItem::TYPE_CANVAS);
 64542:   }
 64542:   if (layer) {
 64542:     static_cast<CanvasLayer*>(layer)->Updated();
  6313:   }
103275: 
103275:   /*
103275:    * Treat canvas invalidations as animation activity for JS. Frequently
103275:    * invalidating a canvas will feed into heuristics and cause JIT code to be
103275:    * kept around longer, for smoother animations.
103275:    */
103275:   nsIScriptGlobalObject *scope = OwnerDoc()->GetScriptGlobalObject();
103275:   if (scope) {
103275:     JSObject *obj = scope->GetGlobalJSObject();
103275:     if (obj) {
103275:       js::NotifyAnimationActivity(obj);
103275:     }
103275:   }
  6313: }
 14812: 
 64542: void
 64542: nsHTMLCanvasElement::InvalidateCanvas()
 64542: {
 64542:   // We don't need to flush anything here; if there's no frame or if
 64542:   // we plan to reframe we don't need to invalidate it anyway.
 64542:   nsIFrame *frame = GetPrimaryFrame();
 64542:   if (!frame)
 64542:     return;
 64542: 
115305:   frame->InvalidateFrame();
 64542: }
 64542: 
108991: int32_t
 14812: nsHTMLCanvasElement::CountContexts()
 14812: {
 14812:   if (mCurrentContext)
 14812:     return 1;
 14812: 
 14812:   return 0;
 14812: }
 14812: 
 14812: nsICanvasRenderingContextInternal *
108991: nsHTMLCanvasElement::GetContextAtIndex(int32_t index)
 14812: {
 14812:   if (mCurrentContext && index == 0)
 82292:     return mCurrentContext;
 14812: 
 14812:   return NULL;
 14812: }
 25788: 
 79445: bool
 25788: nsHTMLCanvasElement::GetIsOpaque()
 25788: {
 25788:   return HasAttr(kNameSpaceID_None, nsGkAtoms::moz_opaque);
 25788: }
 42402: 
 42402: already_AddRefed<CanvasLayer>
 64542: nsHTMLCanvasElement::GetCanvasLayer(nsDisplayListBuilder* aBuilder,
 64542:                                     CanvasLayer *aOldLayer,
 47731:                                     LayerManager *aManager)
 42402: {
 42402:   if (!mCurrentContext)
106838:     return nullptr;
 42402: 
 64542:   return mCurrentContext->GetCanvasLayer(aBuilder, aOldLayer, aManager);
 42402: }
 42402: 
 79445: bool
 73612: nsHTMLCanvasElement::ShouldForceInactiveLayer(LayerManager *aManager)
 73612: {
 73612:   return !mCurrentContext || mCurrentContext->ShouldForceInactiveLayer(aManager);
 73612: }
 73612: 
 42402: void
 42402: nsHTMLCanvasElement::MarkContextClean()
 42402: {
 42402:   if (!mCurrentContext)
 42402:     return;
 42402: 
 42402:   mCurrentContext->MarkContextClean();
 42402: }
 42402: 
 42402: NS_IMETHODIMP_(nsIntSize)
 42402: nsHTMLCanvasElement::GetSizeExternal()
 42402: {
 42402:   return GetWidthHeight();
 42402: }
 42402: 
 42402: NS_IMETHODIMP
108991: nsHTMLCanvasElement::RenderContextsExternal(gfxContext *aContext, gfxPattern::GraphicsFilter aFilter, uint32_t aFlags)
 42402: {
 42402:   if (!mCurrentContext)
 42402:     return NS_OK;
 42402: 
 93959:   return mCurrentContext->Render(aContext, aFilter, aFlags);
 42402: }
 72429: 
