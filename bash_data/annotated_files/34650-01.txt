    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: #include "nsIDOMHTMLLinkElement.h"
    1: #include "nsIDOMLinkStyle.h"
 1418: #include "nsIDOMEventTarget.h"
    1: #include "nsGenericHTMLElement.h"
    1: #include "nsILink.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsPresContext.h"
    1: #include "nsIDOMStyleSheet.h"
    1: #include "nsIStyleSheet.h"
    1: #include "nsIStyleSheetLinkingElement.h"
    1: #include "nsStyleLinkElement.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsIURL.h"
    1: #include "nsNetUtil.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMEvent.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "nsIDOMDocumentEvent.h"
    1: #include "nsIDOMEventTarget.h"
    1: #include "nsParserUtils.h"
    1: #include "nsContentUtils.h"
    1: #include "nsPIDOMWindow.h"
12014: #include "nsPLDOMEvent.h"
    1: 
34539: #include "Link.h"
34539: using namespace mozilla::dom;
34539: 
    1: class nsHTMLLinkElement : public nsGenericHTMLElement,
    1:                           public nsIDOMHTMLLinkElement,
    1:                           public nsILink,
34539:                           public nsStyleLinkElement,
34539:                           public Link
    1: {
    1: public:
    1:   nsHTMLLinkElement(nsINodeInfo *aNodeInfo);
    1:   virtual ~nsHTMLLinkElement();
    1: 
    1:   // nsISupports
    1:   NS_DECL_ISUPPORTS_INHERITED
    1: 
    1:   // nsIDOMNode
    1:   NS_FORWARD_NSIDOMNODE(nsGenericHTMLElement::)
    1: 
    1:   // nsIDOMElement
    1:   NS_FORWARD_NSIDOMELEMENT(nsGenericHTMLElement::)
    1: 
    1:   // nsIDOMHTMLElement
    1:   NS_FORWARD_NSIDOMHTMLELEMENT(nsGenericHTMLElement::)
    1: 
    1:   // nsIDOMHTMLLinkElement
    1:   NS_DECL_NSIDOMHTMLLINKELEMENT
    1: 
    1:   // nsILink
    1:   NS_IMETHOD    LinkAdded();
    1:   NS_IMETHOD    LinkRemoved();
    1: 
    1:   virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
    1:                               nsIContent* aBindingParent,
    1:                               PRBool aCompileEventHandlers);
    1:   virtual void UnbindFromTree(PRBool aDeep = PR_TRUE,
    1:                               PRBool aNullParent = PR_TRUE);
    1:   void CreateAndDispatchEvent(nsIDocument* aDoc, const nsAString& aEventName);
    1:   nsresult SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                    const nsAString& aValue, PRBool aNotify)
    1:   {
    1:     return SetAttr(aNameSpaceID, aName, nsnull, aValue, aNotify);
    1:   }
    1:   virtual nsresult SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                            nsIAtom* aPrefix, const nsAString& aValue,
    1:                            PRBool aNotify);
    1:   virtual nsresult UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
    1:                              PRBool aNotify);
    1: 
  723:   virtual nsresult PreHandleEvent(nsEventChainPreVisitor& aVisitor);
    1:   virtual nsresult PostHandleEvent(nsEventChainPostVisitor& aVisitor);
    1:   virtual PRBool IsLink(nsIURI** aURI) const;
    1:   virtual void GetLinkTarget(nsAString& aTarget);
30307:   virtual nsLinkState GetLinkState() const;
30307:   virtual void SetLinkState(nsLinkState aState);
30307:   virtual already_AddRefed<nsIURI> GetHrefURI() const;
    1: 
    1:   virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
    1: 
    1: protected:
30794:   virtual already_AddRefed<nsIURI> GetStyleSheetURL(PRBool* aIsInline);
    1:   virtual void GetStyleSheetInfo(nsAString& aTitle,
    1:                                  nsAString& aType,
    1:                                  nsAString& aMedia,
    1:                                  PRBool* aIsAlternate);
    1: };
    1: 
    1: 
    1: NS_IMPL_NS_NEW_HTML_ELEMENT(Link)
    1: 
    1: 
    1: nsHTMLLinkElement::nsHTMLLinkElement(nsINodeInfo *aNodeInfo)
34539:   : nsGenericHTMLElement(aNodeInfo)
    1: {
    1: }
    1: 
    1: nsHTMLLinkElement::~nsHTMLLinkElement()
    1: {
    1: }
    1: 
    1: 
    1: NS_IMPL_ADDREF_INHERITED(nsHTMLLinkElement, nsGenericElement) 
    1: NS_IMPL_RELEASE_INHERITED(nsHTMLLinkElement, nsGenericElement) 
    1: 
    1: 
    1: // QueryInterface implementation for nsHTMLLinkElement
21218: NS_INTERFACE_TABLE_HEAD(nsHTMLLinkElement)
21218:   NS_HTML_CONTENT_INTERFACE_TABLE4(nsHTMLLinkElement,
 4838:                                    nsIDOMHTMLLinkElement,
 4838:                                    nsIDOMLinkStyle,
 4838:                                    nsILink,
 4838:                                    nsIStyleSheetLinkingElement)
21218:   NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLLinkElement,
21218:                                                nsGenericHTMLElement)
 4838: NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLLinkElement)
    1: 
    1: 
    1: NS_IMPL_ELEMENT_CLONE(nsHTMLLinkElement)
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLLinkElement::GetDisabled(PRBool* aDisabled)
    1: {
24412:   nsCOMPtr<nsIDOMStyleSheet> ss(do_QueryInterface(GetStyleSheet()));
    1:   nsresult result = NS_OK;
    1: 
    1:   if (ss) {
    1:     result = ss->GetDisabled(aDisabled);
    1:   } else {
    1:     *aDisabled = PR_FALSE;
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsHTMLLinkElement::SetDisabled(PRBool aDisabled)
    1: {
24412:   nsCOMPtr<nsIDOMStyleSheet> ss(do_QueryInterface(GetStyleSheet()));
    1:   nsresult result = NS_OK;
    1: 
    1:   if (ss) {
    1:     result = ss->SetDisabled(aDisabled);
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMPL_STRING_ATTR(nsHTMLLinkElement, Charset, charset)
    1: NS_IMPL_URI_ATTR(nsHTMLLinkElement, Href, href)
    1: NS_IMPL_STRING_ATTR(nsHTMLLinkElement, Hreflang, hreflang)
    1: NS_IMPL_STRING_ATTR(nsHTMLLinkElement, Media, media)
    1: NS_IMPL_STRING_ATTR(nsHTMLLinkElement, Rel, rel)
    1: NS_IMPL_STRING_ATTR(nsHTMLLinkElement, Rev, rev)
    1: NS_IMPL_STRING_ATTR(nsHTMLLinkElement, Target, target)
    1: NS_IMPL_STRING_ATTR(nsHTMLLinkElement, Type, type)
    1: 
    1: nsresult
    1: nsHTMLLinkElement::BindToTree(nsIDocument* aDocument, nsIContent* aParent,
    1:                               nsIContent* aBindingParent,
    1:                               PRBool aCompileEventHandlers)
    1: {
    1:   nsresult rv = nsGenericHTMLElement::BindToTree(aDocument, aParent,
    1:                                                  aBindingParent,
    1:                                                  aCompileEventHandlers);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
28627:   nsContentUtils::AddScriptRunner(
28627:     new nsRunnableMethod<nsHTMLLinkElement>(this,
28627:                                             &nsHTMLLinkElement::UpdateStyleSheetInternal));
    1: 
    1:   CreateAndDispatchEvent(aDocument, NS_LITERAL_STRING("DOMLinkAdded"));
    1: 
    1:   return rv;  
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLLinkElement::LinkAdded()
    1: {
    1:   CreateAndDispatchEvent(GetOwnerDoc(), NS_LITERAL_STRING("DOMLinkAdded"));
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLLinkElement::LinkRemoved()
    1: {
    1:   CreateAndDispatchEvent(GetOwnerDoc(), NS_LITERAL_STRING("DOMLinkRemoved"));
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsHTMLLinkElement::UnbindFromTree(PRBool aDeep, PRBool aNullParent)
    1: {
34539:   Link::ResetLinkState();
    1: 
14228:   // Once we have XPCOMGC we shouldn't need to call UnbindFromTree during Unlink
14228:   // and so this messy event dispatch can go away.
34539:   nsCOMPtr<nsIDocument> oldDoc = GetCurrentDoc();
    1:   CreateAndDispatchEvent(oldDoc, NS_LITERAL_STRING("DOMLinkRemoved"));
    1:   nsGenericHTMLElement::UnbindFromTree(aDeep, aNullParent);
  681:   UpdateStyleSheetInternal(oldDoc);
    1: }
    1: 
    1: void
    1: nsHTMLLinkElement::CreateAndDispatchEvent(nsIDocument* aDoc,
    1:                                           const nsAString& aEventName)
    1: {
    1:   if (!aDoc)
    1:     return;
    1: 
    1:   // In the unlikely case that both rev is specified *and* rel=stylesheet,
    1:   // this code will cause the event to fire, on the principle that maybe the
24112:   // page really does want to specify that its author is a stylesheet. Since
    1:   // this should never actually happen and the performance hit is minimal,
    1:   // doing the "right" thing costs virtually nothing here, even if it doesn't
    1:   // make much sense.
    1:   static nsIContent::AttrValuesArray strings[] =
    1:     {&nsGkAtoms::_empty, &nsGkAtoms::stylesheet, nsnull};
    1: 
    1:   if (!nsContentUtils::HasNonEmptyAttr(this, kNameSpaceID_None,
    1:                                        nsGkAtoms::rev) &&
    1:       FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::rel,
    1:                       strings, eIgnoreCase) != ATTR_VALUE_NO_MATCH)
    1:     return;
    1: 
25812:   nsRefPtr<nsPLDOMEvent> event = new nsPLDOMEvent(this, aEventName, PR_TRUE);
12014:   if (event) {
34650:     // Always run async in order to avoid running script when the content
34650:     // sink isn't expecting it.
14108:     event->PostDOMEvent();
12014:   }
    1: }
    1: 
    1: nsresult
    1: nsHTMLLinkElement::SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                            nsIAtom* aPrefix, const nsAString& aValue,
    1:                            PRBool aNotify)
    1: {
    1:   if (aName == nsGkAtoms::href && kNameSpaceID_None == aNameSpaceID) {
34539:     Link::ResetLinkState();
    1:   }
    1: 
    1:   nsresult rv = nsGenericHTMLElement::SetAttr(aNameSpaceID, aName, aPrefix,
    1:                                               aValue, aNotify);
    1:   if (NS_SUCCEEDED(rv)) {
  798:     PRBool dropSheet = PR_FALSE;
  798:     if (aNameSpaceID == kNameSpaceID_None && aName == nsGkAtoms::rel &&
24412:         GetStyleSheet()) {
23904:       nsAutoTArray<nsString, 4> linkTypes;
  798:       nsStyleLinkElement::ParseLinkTypes(aValue, linkTypes);
23904:       dropSheet = !linkTypes.Contains(NS_LITERAL_STRING("stylesheet"));
  798:     }
  798:     
  681:     UpdateStyleSheetInternal(nsnull,
  798:                              dropSheet ||
  798:                              (aNameSpaceID == kNameSpaceID_None &&
  798:                               (aName == nsGkAtoms::title ||
    1:                                aName == nsGkAtoms::media ||
  798:                                aName == nsGkAtoms::type)));
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsHTMLLinkElement::UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
    1:                              PRBool aNotify)
    1: {
19120:   if (aAttribute == nsGkAtoms::href && kNameSpaceID_None == aNameSpaceID) {
34539:     Link::ResetLinkState();
19120:   }
19120: 
    1:   nsresult rv = nsGenericHTMLElement::UnsetAttr(aNameSpaceID, aAttribute,
    1:                                                 aNotify);
    1:   if (NS_SUCCEEDED(rv)) {
  681:     UpdateStyleSheetInternal(nsnull,
    1:                              aNameSpaceID == kNameSpaceID_None &&
    1:                              (aAttribute == nsGkAtoms::rel ||
    1:                               aAttribute == nsGkAtoms::title ||
    1:                               aAttribute == nsGkAtoms::media ||
    1:                               aAttribute == nsGkAtoms::type));
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
  723: nsHTMLLinkElement::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
  723: {
  723:   return PreHandleEventForAnchors(aVisitor);
  723: }
  723: 
  723: nsresult
    1: nsHTMLLinkElement::PostHandleEvent(nsEventChainPostVisitor& aVisitor)
    1: {
    1:   return PostHandleEventForAnchors(aVisitor);
    1: }
    1: 
    1: PRBool
    1: nsHTMLLinkElement::IsLink(nsIURI** aURI) const
    1: {
    1:   return IsHTMLLink(aURI);
    1: }
    1: 
    1: void
    1: nsHTMLLinkElement::GetLinkTarget(nsAString& aTarget)
    1: {
  100:   GetAttr(kNameSpaceID_None, nsGkAtoms::target, aTarget);
  100:   if (aTarget.IsEmpty()) {
    1:     GetBaseTarget(aTarget);
    1:   }
    1: }
    1: 
30307: nsLinkState
30307: nsHTMLLinkElement::GetLinkState() const
    1: {
34539:   return Link::GetLinkState();
    1: }
    1: 
30307: void
    1: nsHTMLLinkElement::SetLinkState(nsLinkState aState)
    1: {
34539:   Link::SetLinkState(aState);
    1: }
    1: 
30307: already_AddRefed<nsIURI>
30307: nsHTMLLinkElement::GetHrefURI() const
    1: {
30307:   return GetHrefURIForAnchors();
    1: }
    1: 
30794: already_AddRefed<nsIURI>
30794: nsHTMLLinkElement::GetStyleSheetURL(PRBool* aIsInline)
    1: {
    1:   *aIsInline = PR_FALSE;
30794:   return GetHrefURIForAnchors();
    1: }
    1: 
    1: void
    1: nsHTMLLinkElement::GetStyleSheetInfo(nsAString& aTitle,
    1:                                      nsAString& aType,
    1:                                      nsAString& aMedia,
    1:                                      PRBool* aIsAlternate)
    1: {
    1:   aTitle.Truncate();
    1:   aType.Truncate();
    1:   aMedia.Truncate();
    1:   *aIsAlternate = PR_FALSE;
    1: 
    1:   nsAutoString rel;
23904:   nsAutoTArray<nsString, 4> linkTypes;
    1:   GetAttr(kNameSpaceID_None, nsGkAtoms::rel, rel);
    1:   nsStyleLinkElement::ParseLinkTypes(rel, linkTypes);
    1:   // Is it a stylesheet link?
23904:   if (!linkTypes.Contains(NS_LITERAL_STRING("stylesheet"))) {
    1:     return;
    1:   }
    1: 
    1:   nsAutoString title;
    1:   GetAttr(kNameSpaceID_None, nsGkAtoms::title, title);
    1:   title.CompressWhitespace();
    1:   aTitle.Assign(title);
    1: 
    1:   // If alternate, does it have title?
23904:   if (linkTypes.Contains(NS_LITERAL_STRING("alternate"))) {
    1:     if (aTitle.IsEmpty()) { // alternates must have title
    1:       return;
    1:     } else {
    1:       *aIsAlternate = PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   GetAttr(kNameSpaceID_None, nsGkAtoms::media, aMedia);
    1:   ToLowerCase(aMedia); // HTML4.0 spec is inconsistent, make it case INSENSITIVE
    1: 
    1:   nsAutoString mimeType;
    1:   nsAutoString notUsed;
    1:   GetAttr(kNameSpaceID_None, nsGkAtoms::type, aType);
    1:   nsParserUtils::SplitMimeType(aType, mimeType, notUsed);
    1:   if (!mimeType.IsEmpty() && !mimeType.LowerCaseEqualsLiteral("text/css")) {
    1:     return;
    1:   }
    1: 
    1:   // If we get here we assume that we're loading a css file, so set the
    1:   // type to 'text/css'
    1:   aType.AssignLiteral("text/css");
    1: 
    1:   return;
    1: }
