    1: /* cairo - a vector graphics library with display and print output
    1:  *
    1:  * Copyright © 2002 University of Southern California
    1:  *
    1:  * This library is free software; you can redistribute it and/or
    1:  * modify it either under the terms of the GNU Lesser General Public
    1:  * License version 2.1 as published by the Free Software Foundation
    1:  * (the "LGPL") or, at your option, under the terms of the Mozilla
    1:  * Public License Version 1.1 (the "MPL"). If you do not alter this
    1:  * notice, a recipient may use your version of this file under either
    1:  * the MPL or the LGPL.
    1:  *
    1:  * You should have received a copy of the LGPL along with this library
    1:  * in the file COPYING-LGPL-2.1; if not, write to the Free Software
    1:  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
    1:  * You should have received a copy of the MPL along with this library
    1:  * in the file COPYING-MPL-1.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License
    1:  * Version 1.1 (the "License"); you may not use this file except in
    1:  * compliance with the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY
    1:  * OF ANY KIND, either express or implied. See the LGPL or the MPL for
    1:  * the specific language governing rights and limitations.
    1:  *
    1:  * The Original Code is the cairo graphics library.
    1:  *
    1:  * The Initial Developer of the Original Code is University of Southern
    1:  * California.
    1:  *
    1:  * Contributor(s):
    1:  *	Carl D. Worth <cworth@cworth.org>
    1:  */
    1: 
    1: #include "cairoint.h"
    1: 
41340: #include "cairo-slope-private.h"
41340: 
26419: cairo_bool_t
    1: _cairo_spline_init (cairo_spline_t *spline,
26419: 		    cairo_spline_add_point_func_t add_point_func,
26419: 		    void *closure,
 8452: 		    const cairo_point_t *a, const cairo_point_t *b,
 8452: 		    const cairo_point_t *c, const cairo_point_t *d)
    1: {
26419:     spline->add_point_func = add_point_func;
26419:     spline->closure = closure;
26419: 
 8452:     spline->knots.a = *a;
 8452:     spline->knots.b = *b;
 8452:     spline->knots.c = *c;
 8452:     spline->knots.d = *d;
    1: 
    1:     if (a->x != b->x || a->y != b->y)
 8452: 	_cairo_slope_init (&spline->initial_slope, &spline->knots.a, &spline->knots.b);
    1:     else if (a->x != c->x || a->y != c->y)
 8452: 	_cairo_slope_init (&spline->initial_slope, &spline->knots.a, &spline->knots.c);
    1:     else if (a->x != d->x || a->y != d->y)
 8452: 	_cairo_slope_init (&spline->initial_slope, &spline->knots.a, &spline->knots.d);
    1:     else
26419: 	return FALSE;
    1: 
    1:     if (c->x != d->x || c->y != d->y)
 8452: 	_cairo_slope_init (&spline->final_slope, &spline->knots.c, &spline->knots.d);
    1:     else if (b->x != d->x || b->y != d->y)
 8452: 	_cairo_slope_init (&spline->final_slope, &spline->knots.b, &spline->knots.d);
    1:     else
 8452: 	_cairo_slope_init (&spline->final_slope, &spline->knots.a, &spline->knots.d);
    1: 
26419:     return TRUE;
    1: }
    1: 
    1: static cairo_status_t
26419: _cairo_spline_add_point (cairo_spline_t *spline, cairo_point_t *point)
    1: {
    1:     cairo_point_t *prev;
    1: 
26419:     prev = &spline->last_point;
    1:     if (prev->x == point->x && prev->y == point->y)
    1: 	return CAIRO_STATUS_SUCCESS;
    1: 
26419:     spline->last_point = *point;
26419:     return spline->add_point_func (spline->closure, point);
    1: }
    1: 
    1: static void
 8452: _lerp_half (const cairo_point_t *a, const cairo_point_t *b, cairo_point_t *result)
    1: {
    1:     result->x = a->x + ((b->x - a->x) >> 1);
    1:     result->y = a->y + ((b->y - a->y) >> 1);
    1: }
    1: 
    1: static void
 8452: _de_casteljau (cairo_spline_knots_t *s1, cairo_spline_knots_t *s2)
    1: {
    1:     cairo_point_t ab, bc, cd;
    1:     cairo_point_t abbc, bccd;
    1:     cairo_point_t final;
    1: 
 8452:     _lerp_half (&s1->a, &s1->b, &ab);
 8452:     _lerp_half (&s1->b, &s1->c, &bc);
 8452:     _lerp_half (&s1->c, &s1->d, &cd);
    1:     _lerp_half (&ab, &bc, &abbc);
    1:     _lerp_half (&bc, &cd, &bccd);
    1:     _lerp_half (&abbc, &bccd, &final);
    1: 
 8452:     s2->a = final;
 8452:     s2->b = bccd;
 8452:     s2->c = cd;
 8452:     s2->d = s1->d;
 8452: 
    1:     s1->b = ab;
    1:     s1->c = abbc;
    1:     s1->d = final;
    1: }
    1: 
 8452: /* Return an upper bound on the error (squared) that could result from
 8452:  * approximating a spline as a line segment connecting the two endpoints. */
    1: static double
 8452: _cairo_spline_error_squared (const cairo_spline_knots_t *knots)
    1: {
 8452:     double bdx, bdy, berr;
 8452:     double cdx, cdy, cerr;
    1: 
41340:     /* We are going to compute the distance (squared) between each of the the b
41340:      * and c control points and the segment a-b. The maximum of these two
41340:      * distances will be our approximation error. */
41340: 
 8452:     bdx = _cairo_fixed_to_double (knots->b.x - knots->a.x);
 8452:     bdy = _cairo_fixed_to_double (knots->b.y - knots->a.y);
 8452: 
 8452:     cdx = _cairo_fixed_to_double (knots->c.x - knots->a.x);
 8452:     cdy = _cairo_fixed_to_double (knots->c.y - knots->a.y);
 8452: 
 8452:     if (knots->a.x != knots->d.x || knots->a.y != knots->d.y) {
41340: 	/* Intersection point (px):
41340: 	 *     px = p1 + u(p2 - p1)
41340: 	 *     (p - px) ∙ (p2 - p1) = 0
41340: 	 * Thus:
41340: 	 *     u = ((p - p1) ∙ (p2 - p1)) / ∥p2 - p1∥²;
41340: 	 */
41340: 
 8452: 	double dx, dy, u, v;
 8452: 
 8452: 	dx = _cairo_fixed_to_double (knots->d.x - knots->a.x);
 8452: 	dy = _cairo_fixed_to_double (knots->d.y - knots->a.y);
 8452: 	 v = dx * dx + dy * dy;
 8452: 
 8452: 	u = bdx * dx + bdy * dy;
 8452: 	if (u <= 0) {
 8452: 	    /* bdx -= 0;
 8452: 	     * bdy -= 0;
 8452: 	     */
 8452: 	} else if (u >= v) {
 8452: 	    bdx -= dx;
 8452: 	    bdy -= dy;
 8452: 	} else {
 8452: 	    bdx -= u/v * dx;
 8452: 	    bdy -= u/v * dy;
    1: 	}
    1: 
 8452: 	u = cdx * dx + cdy * dy;
 8452: 	if (u <= 0) {
 8452: 	    /* cdx -= 0;
 8452: 	     * cdy -= 0;
    1: 	     */
 8452: 	} else if (u >= v) {
 8452: 	    cdx -= dx;
 8452: 	    cdy -= dy;
 8452: 	} else {
 8452: 	    cdx -= u/v * dx;
 8452: 	    cdy -= u/v * dy;
 8452: 	}
    1:     }
    1: 
 8452:     berr = bdx * bdx + bdy * bdy;
 8452:     cerr = cdx * cdx + cdy * cdy;
    1:     if (berr > cerr)
    1: 	return berr;
    1:     else
    1: 	return cerr;
    1: }
    1: 
61767: void StoreSpline(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy);
61767: void CrashSpline();
61767: 
    1: static cairo_status_t
 8452: _cairo_spline_decompose_into (cairo_spline_knots_t *s1, double tolerance_squared, cairo_spline_t *result)
    1: {
61767:     static int depth;
 8452:     cairo_spline_knots_t s2;
    1:     cairo_status_t status;
    1: 
61767:     depth++;
61767: #ifdef MOZ_ENABLE_LIBXUL
61767:     if (depth == 200) {
61767:         CrashSpline();
61767:     }
61767: #endif
61767: 
 8452:     if (_cairo_spline_error_squared (s1) < tolerance_squared)
 8452: 	return _cairo_spline_add_point (result, &s1->a);
    1: 
 8452:     _de_casteljau (s1, &s2);
    1: 
 8452:     status = _cairo_spline_decompose_into (s1, tolerance_squared, result);
26419:     if (unlikely (status))
    1: 	return status;
    1: 
61767:     status = _cairo_spline_decompose_into (&s2, tolerance_squared, result);
61767:     depth--;
61767:     return status;
    1: }
    1: 
    1: cairo_status_t
    1: _cairo_spline_decompose (cairo_spline_t *spline, double tolerance)
    1: {
26419:     cairo_spline_knots_t s1;
    1:     cairo_status_t status;
    1: 
61767: #ifdef MOZ_ENABLE_LIBXUL
61767:     StoreSpline(spline->knots.a.x,
61767:                 spline->knots.a.y,
61767:                 spline->knots.b.x,
61767:                 spline->knots.b.y,
61767:                 spline->knots.c.x,
61767:                 spline->knots.c.y,
61767:                 spline->knots.d.x,
61767:                 spline->knots.d.y);
61767: #endif
 8452:     s1 = spline->knots;
26419:     spline->last_point = s1.a;
 8452:     status = _cairo_spline_decompose_into (&s1, tolerance * tolerance, spline);
26419:     if (unlikely (status))
    1: 	return status;
    1: 
26419:     return _cairo_spline_add_point (spline, &spline->knots.d);
26419: }
26419: 
26419: /* Note: this function is only good for computing bounds in device space. */
26419: cairo_status_t
26419: _cairo_spline_bound (cairo_spline_add_point_func_t add_point_func,
26419: 		     void *closure,
26419: 		     const cairo_point_t *p0, const cairo_point_t *p1,
26419: 		     const cairo_point_t *p2, const cairo_point_t *p3)
26419: {
26419:     double x0, x1, x2, x3;
26419:     double y0, y1, y2, y3;
26419:     double a, b, c;
26419:     double t[4];
26419:     int t_num = 0, i;
26419:     cairo_status_t status;
26419: 
26419:     x0 = _cairo_fixed_to_double (p0->x);
26419:     y0 = _cairo_fixed_to_double (p0->y);
26419:     x1 = _cairo_fixed_to_double (p1->x);
26419:     y1 = _cairo_fixed_to_double (p1->y);
26419:     x2 = _cairo_fixed_to_double (p2->x);
26419:     y2 = _cairo_fixed_to_double (p2->y);
26419:     x3 = _cairo_fixed_to_double (p3->x);
26419:     y3 = _cairo_fixed_to_double (p3->y);
26419: 
26419:     /* The spline can be written as a polynomial of the four points:
26419:      *
26419:      *   (1-t)³p0 + 3t(1-t)²p1 + 3t²(1-t)p2 + t³p3
26419:      *
26419:      * for 0≤t≤1.  Now, the X and Y components of the spline follow the
26419:      * same polynomial but with x and y replaced for p.  To find the
26419:      * bounds of the spline, we just need to find the X and Y bounds.
26419:      * To find the bound, we take the derivative and equal it to zero,
26419:      * and solve to find the t's that give the extreme points.
26419:      *
26419:      * Here is the derivative of the curve, sorted on t:
26419:      *
26419:      *   3t²(-p0+3p1-3p2+p3) + 2t(3p0-6p1+3p2) -3p0+3p1
26419:      *
26419:      * Let:
26419:      *
26419:      *   a = -p0+3p1-3p2+p3
26419:      *   b =  p0-2p1+p2
26419:      *   c = -p0+p1
26419:      *
26419:      * Gives:
26419:      *
26419:      *   a.t² + 2b.t + c = 0
26419:      *
26419:      * With:
26419:      *
26419:      *   delta = b*b - a*c
26419:      *
26419:      * the extreme points are at -c/2b if a is zero, at (-b±√delta)/a if
26419:      * delta is positive, and at -b/a if delta is zero.
26419:      */
26419: 
26419: #define ADD(t0) \
26419:     { \
26419: 	double _t0 = (t0); \
26419: 	if (0 < _t0 && _t0 < 1) \
26419: 	    t[t_num++] = _t0; \
26419:     }
26419: 
26419: #define FIND_EXTREMES(a,b,c) \
26419:     { \
26419: 	if (a == 0) { \
26419: 	    if (b != 0) \
26419: 		ADD (-c / (2*b)); \
26419: 	} else { \
26419: 	    double b2 = b * b; \
26419: 	    double delta = b2 - a * c; \
26419: 	    if (delta > 0) { \
26419: 		cairo_bool_t feasible; \
26419: 		double _2ab = 2 * a * b; \
26419: 		/* We are only interested in solutions t that satisfy 0<t<1 \
26419: 		 * here.  We do some checks to avoid sqrt if the solutions \
26419: 		 * are not in that range.  The checks can be derived from: \
26419: 		 * \
26419: 		 *   0 < (-b±√delta)/a < 1 \
26419: 		 */ \
26419: 		if (_2ab >= 0) \
28364: 		    feasible = delta > b2 && delta < a*a + b2 + _2ab; \
26419: 		else if (-b / a >= 1) \
26419: 		    feasible = delta < b2 && delta > a*a + b2 + _2ab; \
26419: 		else \
26419: 		    feasible = delta < b2 || delta < a*a + b2 + _2ab; \
26419: 	        \
26419: 		if (unlikely (feasible)) { \
26419: 		    double sqrt_delta = sqrt (delta); \
26419: 		    ADD ((-b - sqrt_delta) / a); \
26419: 		    ADD ((-b + sqrt_delta) / a); \
26419: 		} \
26419: 	    } else if (delta == 0) { \
26419: 		ADD (-b / a); \
26419: 	    } \
26419: 	} \
26419:     }
26419: 
26419:     /* Find X extremes */
26419:     a = -x0 + 3*x1 - 3*x2 + x3;
26419:     b =  x0 - 2*x1 + x2;
26419:     c = -x0 + x1;
26419:     FIND_EXTREMES (a, b, c);
26419: 
26419:     /* Find Y extremes */
26419:     a = -y0 + 3*y1 - 3*y2 + y3;
26419:     b =  y0 - 2*y1 + y2;
26419:     c = -y0 + y1;
26419:     FIND_EXTREMES (a, b, c);
26419: 
26419:     status = add_point_func (closure, p0);
26419:     if (unlikely (status))
    1: 	return status;
    1: 
26419:     for (i = 0; i < t_num; i++) {
26419: 	cairo_point_t p;
26419: 	double x, y;
26419:         double t_1_0, t_0_1;
26419:         double t_2_0, t_0_2;
26419:         double t_3_0, t_2_1_3, t_1_2_3, t_0_3;
26419: 
26419:         t_1_0 = t[i];          /*      t  */
26419:         t_0_1 = 1 - t_1_0;     /* (1 - t) */
26419: 
26419:         t_2_0 = t_1_0 * t_1_0; /*      t  *      t  */
26419:         t_0_2 = t_0_1 * t_0_1; /* (1 - t) * (1 - t) */
26419: 
26419:         t_3_0   = t_2_0 * t_1_0;     /*      t  *      t  *      t      */
26419:         t_2_1_3 = t_2_0 * t_0_1 * 3; /*      t  *      t  * (1 - t) * 3 */
26419:         t_1_2_3 = t_1_0 * t_0_2 * 3; /*      t  * (1 - t) * (1 - t) * 3 */
26419:         t_0_3   = t_0_1 * t_0_2;     /* (1 - t) * (1 - t) * (1 - t)     */
26419: 
26419:         /* Bezier polynomial */
26419:         x = x0 * t_0_3
26419:           + x1 * t_1_2_3
26419:           + x2 * t_2_1_3
26419:           + x3 * t_3_0;
26419:         y = y0 * t_0_3
26419:           + y1 * t_1_2_3
26419:           + y2 * t_2_1_3
26419:           + y3 * t_3_0;
26419: 
26419: 	p.x = _cairo_fixed_from_double (x);
26419: 	p.y = _cairo_fixed_from_double (y);
26419: 	status = add_point_func (closure, &p);
26419: 	if (unlikely (status))
26419: 	    return status;
    1:     }
26419: 
26419:     return add_point_func (closure, p3);
26419: }
