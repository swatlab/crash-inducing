 29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
     1:  * vim: set sw=4 ts=8 et tw=78:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * JS array class.
 11835:  *
 25888:  * Array objects begin as "dense" arrays, optimized for index-only property
 41782:  * access over a vector of slots with high load factor.  Array methods
 41782:  * optimize for denseness by testing that the object's class is
 77817:  * &ArrayClass, and can then directly manipulate the slots for efficiency.
 11835:  *
 11835:  * We track these pieces of metadata for arrays in dense mode:
 41850:  *  - The array's length property as a uint32, accessible with
 48537:  *    getArrayLength(), setArrayLength().
 41850:  *  - The number of element slots (capacity), gettable with
 41782:  *    getDenseArrayCapacity().
 77343:  *  - The array's initialized length, accessible with
 77343:  *    getDenseArrayInitializedLength().
 11835:  *
 59234:  * In dense mode, holes in the array are represented by
 59234:  * MagicValue(JS_ARRAY_HOLE) invalid values.
 11835:  *
 28242:  * NB: the capacity and length of a dense array are entirely unrelated!  The
 59234:  * length may be greater than, less than, or equal to the capacity. The first
 87811:  * case may occur when the user writes "new Array(100)", in which case the
 59234:  * length is 100 while the capacity remains 0 (indices below length and above
 77343:  * capacity must be treated as holes). See array_length_setter for another
 59234:  * explanation of how the first case may occur.
 28242:  *
 77343:  * The initialized length of a dense array specifies the number of elements
 77343:  * that have been initialized. All elements above the initialized length are
 77343:  * holes in the array, and the memory for all elements between the initialized
 77343:  * length and capacity is left uninitialized. When type inference is disabled,
 77343:  * the initialized length always equals the array's capacity. When inference is
 77343:  * enabled, the initialized length is some value less than or equal to both the
 77343:  * array's length and the array's capacity.
 77343:  *
 77343:  * With inference enabled, there is flexibility in exactly the value the
 77343:  * initialized length must hold, e.g. if an array has length 5, capacity 10,
 77343:  * completely empty, it is valid for the initialized length to be any value
 77343:  * between zero and 5, as long as the in memory values below the initialized
 77343:  * length have been initialized with a hole value. However, in such cases we
 77343:  * want to keep the initialized length as small as possible: if the array is
 77343:  * known to have no hole values below its initialized length, then it is a
 77343:  * "packed" array and can be accessed much faster by JIT code.
 77343:  *
 77817:  * Arrays are converted to use SlowArrayClass when any of these conditions
 11835:  * are met:
 77343:  *  - there are more than MIN_SPARSE_INDEX slots total and the load factor
 77343:  *    (COUNT / capacity) is less than 0.25
 58702:  *  - a property is set that is not indexed (and not "length")
 25475:  *  - a property is defined that has non-default property attributes.
 11835:  *
 25475:  * Dense arrays do not track property creation order, so unlike other native
 25475:  * objects and slow arrays, enumerating an array does not necessarily visit the
 25475:  * properties in the order they were created.  We could instead maintain the
 25475:  * scope to track property enumeration order, but still use the fast slot
 25475:  * access.  That would have the same memory cost as just using a
 77817:  * SlowArrayClass, but have the same performance characteristics as a dense
 25475:  * array for slot accesses, at some cost in code complexity.
     1:  */
 95341: 
 95341: #include "mozilla/FloatingPoint.h"
 95341: #include "mozilla/RangedPtr.h"
 95341: 
 79934: #include <limits.h>
     1: #include <stdlib.h>
     1: #include <string.h>
 79934: 
     1: #include "jstypes.h"
 55477: #include "jsutil.h"
 69827: 
     1: #include "jsapi.h"
     1: #include "jsarray.h"
     1: #include "jsatom.h"
     1: #include "jsbool.h"
     1: #include "jscntxt.h"
 18863: #include "jsversion.h"
     1: #include "jsfun.h"
     1: #include "jsgc.h"
     1: #include "jsinterp.h"
 43281: #include "jsiter.h"
     1: #include "jslock.h"
     1: #include "jsnum.h"
     1: #include "jsobj.h"
 11835: #include "jsscope.h"
 56565: #include "jswrapper.h"
 77343: #include "methodjit/MethodJIT.h"
 77343: #include "methodjit/StubCalls.h"
 77343: #include "methodjit/StubCalls-inl.h"
     1: 
 97569: #include "gc/Marking.h"
 69827: #include "vm/ArgumentsObject.h"
 90523: #include "vm/MethodGuard.h"
 97045: #include "vm/NumericConversions.h"
 93300: #include "vm/StringBuffer.h"
 69827: 
 82461: #include "ds/Sort.h"
 82461: 
 77343: #include "jsarrayinlines.h"
 30283: #include "jsatominlines.h"
 55530: #include "jscntxtinlines.h"
 40796: #include "jsobjinlines.h"
 77343: #include "jsscopeinlines.h"
 64345: #include "jsstrinlines.h"
 30283: 
 69827: #include "vm/ArgumentsObject-inl.h"
 93701: #include "vm/ObjectImpl-inl.h"
 69223: #include "vm/Stack-inl.h"
 69223: 
 79934: using namespace mozilla;
 37741: using namespace js;
 54707: using namespace js::gc;
 77343: using namespace js::types;
 37741: 
 74949: JSBool
 91688: js_GetLengthProperty(JSContext *cx, JSObject *obj, uint32_t *lengthp)
 74949: {
 74949:     if (obj->isArray()) {
 74949:         *lengthp = obj->getArrayLength();
 74949:         return true;
 74949:     }
 74949: 
 74949:     if (obj->isArguments()) {
 86483:         ArgumentsObject &argsobj = obj->asArguments();
 86483:         if (!argsobj.hasOverriddenLength()) {
 86483:             *lengthp = argsobj.initialLength();
 74949:             return true;
 74949:         }
 74949:     }
 74949: 
 99421:     RootedValue value(cx);
 97353:     if (!obj->getProperty(cx, cx->runtime->atomState.lengthAtom, value.address()))
 74949:         return false;
 74949: 
 97353:     if (value.reference().isInt32()) {
 97353:         *lengthp = uint32_t(value.reference().toInt32()); /* uint32_t cast does ToUint32_t */
 74949:         return true;
 74949:     }
 74949: 
 91612: 
 97353:     return ToUint32(cx, value, (uint32_t *)lengthp);
 74949: }
 74949: 
 74949: namespace js {
 74949: 
     1: /*
     1:  * Determine if the id represents an array index or an XML property index.
     1:  *
     1:  * An id is an array index according to ECMA by (15.4):
     1:  *
     1:  * "Array objects give special treatment to a certain class of property names.
     1:  * A property name P (in the form of a string value) is an array index if and
     1:  * only if ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
     1:  * to 2^32-1."
     1:  *
 74949:  * This means the largest allowed index is actually 2^32-2 (4294967294).
 74949:  *
     1:  * In our implementation, it would be sufficient to check for JSVAL_IS_INT(id)
 48470:  * except that by using signed 31-bit integers we miss the top half of the
     1:  * valid range. This function checks the string representation itself; note
     1:  * that calling a standard conversion routine might allow strings such as
     1:  * "08" or "4.0" as array indices, which they are not.
 48470:  *
     1:  */
 80661: JS_FRIEND_API(bool)
 91688: StringIsArrayIndex(JSLinearString *str, uint32_t *indexp)
     1: {
 74949:     const jschar *s = str->chars();
 84755:     uint32_t length = str->length();
 74949:     const jschar *end = s + length;
 74949: 
 74949:     if (length == 0 || length > (sizeof("4294967294") - 1) || !JS7_ISDEC(*s))
 74949:         return false;
 74949: 
 84755:     uint32_t c = 0, previous = 0;
 84755:     uint32_t index = JS7_UNDEC(*s++);
 74949: 
 74949:     /* Don't allow leading zeros. */
 74949:     if (index == 0 && s != end)
 74949:         return false;
 74949: 
 74949:     for (; s < end; s++) {
 74949:         if (!JS7_ISDEC(*s))
 74949:             return false;
 74949: 
 74949:         previous = index;
 74949:         c = JS7_UNDEC(*s);
     1:         index = 10 * index + c;
     1:     }
 74949: 
 74949:     /* Make sure we didn't overflow. */
 74949:     if (previous < (MAX_ARRAY_INDEX / 10) || (previous == (MAX_ARRAY_INDEX / 10) &&
 74949:         c <= (MAX_ARRAY_INDEX % 10))) {
 74949:         JS_ASSERT(index <= MAX_ARRAY_INDEX);
     1:         *indexp = index;
 59890:         return true;
     1:     }
 74949: 
 59890:     return false;
     1: }
     1: 
     1: }
     1: 
     1: static JSBool
 91688: BigIndexToId(JSContext *cx, JSObject *obj, uint32_t index, JSBool createAtom,
     1:              jsid *idp)
     1: {
 91612: 
 48470:     JS_ASSERT(index > JSID_INT_MAX);
     1: 
 77817:     jschar buf[10];
 80468:     jschar *start = ArrayEnd(buf);
     1:     do {
     1:         --start;
     1:         *start = (jschar)('0' + index % 10);
     1:         index /= 10;
     1:     } while (index != 0);
     1: 
     1:     /*
     1:      * Skip the atomization if the class is known to store atoms corresponding
     1:      * to big indexes together with elements. In such case we know that the
     1:      * array does not have an element at the given index if its atom does not
 77817:      * exist.  Dense arrays don't use atoms for any indexes, though it would be
 77817:      * rare to see them have a big index in any case.
     1:      */
 77817:     JSAtom *atom;
 77817:     if (!createAtom && (obj->isSlowArray() || obj->isArguments() || obj->isObject())) {
 80468:         atom = js_GetExistingStringAtom(cx, start, ArrayEnd(buf) - start);
     1:         if (!atom) {
 48470:             *idp = JSID_VOID;
     1:             return JS_TRUE;
     1:         }
     1:     } else {
 80468:         atom = js_AtomizeChars(cx, start, ArrayEnd(buf) - start);
     1:         if (!atom)
     1:             return JS_FALSE;
     1:     }
     1: 
 97828:     *idp = NON_INTEGER_ATOM_TO_JSID(atom);
     1:     return JS_TRUE;
     1: }
     1: 
 58702: bool
 91237: JSObject::willBeSparseDenseArray(unsigned requiredCapacity, unsigned newElementsHint)
 58702: {
 58702:     JS_ASSERT(isDenseArray());
 58702:     JS_ASSERT(requiredCapacity > MIN_SPARSE_INDEX);
 58702: 
 91237:     unsigned cap = getDenseArrayCapacity();
 58702:     JS_ASSERT(requiredCapacity >= cap);
 58702: 
 83247:     if (requiredCapacity >= JSObject::NELEMENTS_LIMIT)
 58702:         return true;
 58702: 
 91237:     unsigned minimalDenseCount = requiredCapacity / 4;
 58702:     if (newElementsHint >= minimalDenseCount)
 58702:         return false;
 58702:     minimalDenseCount -= newElementsHint;
 58702: 
 58702:     if (minimalDenseCount > cap)
 58702:         return true;
 58702: 
 91237:     unsigned len = getDenseArrayInitializedLength();
 74457:     const Value *elems = getDenseArrayElements();
 91237:     for (unsigned i = 0; i < len; i++) {
 58702:         if (!elems[i].isMagic(JS_ARRAY_HOLE) && !--minimalDenseCount)
 58702:             return false;
 58702:     }
 58702:     return true;
 58702: }
 58702: 
 26564: static bool
 90955: ReallyBigIndexToId(JSContext* cx, double index, jsid* idp)
 26564: {
 97828:     return ValueToId(cx, DoubleValue(index), idp);
 26564: }
 26564: 
 26564: static bool
 90955: IndexToId(JSContext* cx, JSObject* obj, double index, JSBool* hole, jsid* idp,
 26564:           JSBool createAtom = JS_FALSE)
 26564: {
 48470:     if (index <= JSID_INT_MAX) {
 33166:         *idp = INT_TO_JSID(int(index));
 26564:         return JS_TRUE;
 26564:     }
 26564: 
 91688:     if (index <= uint32_t(-1)) {
 91688:         if (!BigIndexToId(cx, obj, uint32_t(index), createAtom, idp))
 26564:             return JS_FALSE;
 48470:         if (hole && JSID_IS_VOID(*idp))
 26564:             *hole = JS_TRUE;
 26564:         return JS_TRUE;
 26564:     }
 26564: 
 26564:     return ReallyBigIndexToId(cx, index, idp);
 26564: }
 26564: 
 75504: bool
 75504: JSObject::arrayGetOwnDataElement(JSContext *cx, size_t i, Value *vp)
 75504: {
 75504:     JS_ASSERT(isArray());
 75504: 
 75504:     if (isDenseArray()) {
 75504:         if (i >= getArrayLength())
 75504:             vp->setMagic(JS_ARRAY_HOLE);
 75504:         else
 84755:             *vp = getDenseArrayElement(uint32_t(i));
 75504:         return true;
 75504:     }
 75504: 
 75504:     JSBool hole;
 75504:     jsid id;
 75504:     if (!IndexToId(cx, this, i, &hole, &id))
 75504:         return false;
 75504: 
 78194:     const Shape *shape = nativeLookup(cx, id);
 75504:     if (!shape || !shape->isDataDescriptor())
 75504:         vp->setMagic(JS_ARRAY_HOLE);
 75504:     else
 83221:         *vp = getSlot(shape->slot());
 75504:     return true;
 75504: }
 75504: 
     1: /*
     1:  * If the property at the given index exists, get its value into location
     1:  * pointed by vp and set *hole to false. Otherwise set *hole to true and *vp
     1:  * to JSVAL_VOID. This function assumes that the location pointed by vp is
     1:  * properly rooted and can be used as GC-protected storage for temporaries.
     1:  */
 81416: static inline JSBool
 97353: DoGetElement(JSContext *cx, JSObject *obj_, double index, JSBool *hole, Value *vp)
 81416: {
 99421:     RootedObject obj(cx, obj_);
 99421:     RootedId id(cx);
 81416: 
 81416:     *hole = JS_FALSE;
 97353:     if (!IndexToId(cx, obj, index, hole, id.address()))
 81416:         return JS_FALSE;
 81416:     if (*hole) {
 81416:         vp->setUndefined();
 81416:         return JS_TRUE;
 81416:     }
 81416: 
 81416:     JSObject *obj2;
 81416:     JSProperty *prop;
 97353:     if (!obj->lookupGeneric(cx, id, &obj2, &prop))
 81416:         return JS_FALSE;
 81416:     if (!prop) {
 81416:         vp->setUndefined();
 81416:         *hole = JS_TRUE;
 81416:     } else {
 97353:         if (!obj->getGeneric(cx, id, vp))
 81416:             return JS_FALSE;
 81416:         *hole = JS_FALSE;
 81416:     }
 81416:     return JS_TRUE;
 81416: }
 81416: 
 81416: static inline JSBool
 98960: DoGetElement(JSContext *cx, HandleObject obj, uint32_t index, JSBool *hole, Value *vp)
 81416: {
 81416:     bool present;
 81416:     if (!obj->getElementIfPresent(cx, obj, index, vp, &present))
 81416:         return false;
 81416: 
 81416:     *hole = !present;
 81416:     if (*hole)
 81416:         vp->setUndefined();
 81416: 
 81416:     return true;
 81416: }
 81416: 
 81416: template<typename IndexType>
 94709: static void
 94709: AssertGreaterThanZero(IndexType index)
 94709: {
 94709:     JS_ASSERT(index >= 0);
 94709: }
 94709: 
 94709: template<>
 94709: void
 94709: AssertGreaterThanZero(uint32_t index)
 94709: {
 94709: }
 94709: 
 94709: template<typename IndexType>
     1: static JSBool
 81416: GetElement(JSContext *cx, JSObject *obj, IndexType index, JSBool *hole, Value *vp)
     1: {
 94709:     AssertGreaterThanZero(index);
 77343:     if (obj->isDenseArray() && index < obj->getDenseArrayInitializedLength() &&
 84755:         !(*vp = obj->getDenseArrayElement(uint32_t(index))).isMagic(JS_ARRAY_HOLE)) {
 26564:         *hole = JS_FALSE;
 26564:         return JS_TRUE;
 26564:     }
 69827:     if (obj->isArguments()) {
101075:         if (obj->asArguments().maybeGetElement(uint32_t(index), vp)) {
 55530:             *hole = JS_FALSE;
 70319:             return true;
 55530:         }
 69827:     }
 26564: 
 81416:     return DoGetElement(cx, obj, index, hole, vp);
     1: }
     1: 
 57714: namespace js {
 57714: 
 69827: static bool
 97353: GetElementsSlow(JSContext *cx, HandleObject aobj, uint32_t length, Value *vp)
 69827: {
 84755:     for (uint32_t i = 0; i < length; i++) {
 78347:         if (!aobj->getElement(cx, i, &vp[i]))
 69827:             return false;
 69827:     }
 69827: 
 69827:     return true;
 69827: }
 69827: 
 57714: bool
 97353: GetElements(JSContext *cx, HandleObject aobj, uint32_t length, Value *vp)
 57714: {
 77343:     if (aobj->isDenseArray() && length <= aobj->getDenseArrayInitializedLength() &&
 57744:         !js_PrototypeHasIndexedProperties(cx, aobj)) {
 57744:         /* The prototype does not have indexed properties so hole = undefined */
 74457:         const Value *srcbeg = aobj->getDenseArrayElements();
 74457:         const Value *srcend = srcbeg + length;
 74457:         const Value *src = srcbeg;
 74457:         for (Value *dst = vp; src < srcend; ++dst, ++src)
 57714:             *dst = src->isMagic(JS_ARRAY_HOLE) ? UndefinedValue() : *src;
 69827:         return true;
 69827:     }
 69827: 
 69827:     if (aobj->isArguments()) {
 86483:         ArgumentsObject &argsobj = aobj->asArguments();
 86483:         if (!argsobj.hasOverriddenLength()) {
101075:             if (argsobj.maybeGetElements(0, length, vp))
 69827:                 return true;
 57714:         }
 57714:     }
 57714: 
 69827:     return GetElementsSlow(cx, aobj, length, vp);
 57714: }
 57714: 
 57714: }
 57714: 
     1: /*
     1:  * Set the value of the property at the given index to v assuming v is rooted.
     1:  */
     1: static JSBool
 95355: SetArrayElement(JSContext *cx, HandleObject obj, double index, const Value &v)
     1: {
 26564:     JS_ASSERT(index >= 0);
     1: 
 39928:     if (obj->isDenseArray()) {
 26564:         /* Predicted/prefetched code should favor the remains-dense case. */
 58702:         JSObject::EnsureDenseResult result = JSObject::ED_SPARSE;
 58702:         do {
 91688:             if (index > uint32_t(-1))
 58702:                 break;
 91688:             uint32_t idx = uint32_t(index);
 58702:             result = obj->ensureDenseArrayElements(cx, idx, 1);
 58702:             if (result != JSObject::ED_OK)
 58702:                 break;
 40796:             if (idx >= obj->getArrayLength())
 77343:                 obj->setDenseArrayLength(idx + 1);
 77343:             obj->setDenseArrayElementWithType(cx, idx, v);
 58702:             return true;
 58702:         } while (false);
 58702: 
 58702:         if (result == JSObject::ED_FAILED)
 58702:             return false;
 58702:         JS_ASSERT(result == JSObject::ED_SPARSE);
 95355:         if (!JSObject::makeDenseArraySlow(cx, obj))
 18712:             return JS_FALSE;
 11835:     }
 11835: 
 99421:     RootedId id(cx);
 98960: 
 98960:     if (!IndexToId(cx, obj, index, NULL, id.address(), JS_TRUE))
     1:         return JS_FALSE;
 98960:     JS_ASSERT(!JSID_IS_VOID(id));
 48470: 
 99421:     RootedValue tmp(cx, v);
 98960:     return obj->setGeneric(cx, id, tmp.address(), true);
     1: }
     1: 
 62396: /*
 62396:  * Delete the element |index| from |obj|. If |strict|, do a strict
 62396:  * deletion: throw if the property is not configurable.
 62396:  *
 62396:  * - Return 1 if the deletion succeeds (that is, ES5's [[Delete]] would
 62396:  *   return true)
 62396:  *
 62396:  * - Return 0 if the deletion fails because the property is not
 62396:  *   configurable (that is, [[Delete]] would return false). Note that if
 62396:  *   |strict| is true we will throw, not return zero.
 62396:  *
 62396:  * - Return -1 if an exception occurs (that is, [[Delete]] would throw).
 62396:  */
 62396: static int
 95355: DeleteArrayElement(JSContext *cx, HandleObject obj, double index, bool strict)
     1: {
 26564:     JS_ASSERT(index >= 0);
 86790:     JS_ASSERT(floor(index) == index);
 86790: 
 39928:     if (obj->isDenseArray()) {
 86790:         if (index <= UINT32_MAX) {
 86790:             uint32_t idx = uint32_t(index);
 77343:             if (idx < obj->getDenseArrayInitializedLength()) {
 77343:                 obj->markDenseArrayNotPacked(cx);
 48470:                 obj->setDenseArrayElement(idx, MagicValue(JS_ARRAY_HOLE));
 79934:                 if (!js_SuppressDeletedElement(cx, obj, idx))
 62396:                     return -1;
 26564:             }
 26564:         }
 62396:         return 1;
 26564:     }
 26564: 
 86790:     Value v;
 86790:     if (index <= UINT32_MAX) {
 86790:         if (!obj->deleteElement(cx, uint32_t(index), &v, strict))
 62396:             return -1;
 86790:     } else {
 86790:         if (!obj->deleteByValue(cx, DoubleValue(index), &v, strict))
 62396:             return -1;
 86790:     }
 86790: 
 62396:     return v.isTrue() ? 1 : 0;
     1: }
     1: 
     1: /*
     1:  * When hole is true, delete the property at the given index. Otherwise set
     1:  * its value to v assuming v is rooted.
     1:  */
     1: static JSBool
 95355: SetOrDeleteArrayElement(JSContext *cx, HandleObject obj, double index,
 48470:                         JSBool hole, const Value &v)
     1: {
     1:     if (hole) {
 48470:         JS_ASSERT(v.isUndefined());
 62396:         return DeleteArrayElement(cx, obj, index, true) >= 0;
 11835:     }
     1:     return SetArrayElement(cx, obj, index, v);
     1: }
     1: 
     1: JSBool
 90955: js_SetLengthProperty(JSContext *cx, JSObject *obj, double length)
     1: {
 80625:     Value v = NumberValue(length);
 80625: 
 54169:     /* We don't support read-only array length yet. */
 80625:     return obj->setProperty(cx, cx->runtime->atomState.lengthAtom, &v, false);
     1: }
     1: 
     1: /*
  4182:  * Since SpiderMonkey supports cross-class prototype-based delegation, we have
  4182:  * to be careful about the length getter and setter being called on an object
  4182:  * not of Array class. For the getter, we search obj's prototype chain for the
  4182:  * array that caused this getter to be invoked. In the setter case to overcome
  4182:  * the JSPROP_SHARED attribute, we must define a shadowing length property.
     1:  */
     1: static JSBool
 98960: array_length_getter(JSContext *cx, HandleObject obj_, HandleId id, Value *vp)
     1: {
 98960:     JSObject *obj = obj_;
  4182:     do {
 48470:         if (obj->isArray()) {
 48470:             vp->setNumber(obj->getArrayLength());
 48470:             return JS_TRUE;
 48470:         }
 39928:     } while ((obj = obj->getProto()) != NULL);
  4127:     return JS_TRUE;
     1: }
     1: 
     1: static JSBool
 98960: array_length_setter(JSContext *cx, HandleObject obj, HandleId id, JSBool strict, Value *vp)
     1: {
 39928:     if (!obj->isArray()) {
 80624:         return obj->defineProperty(cx, cx->runtime->atomState.lengthAtom, *vp,
 80624:                                    NULL, NULL, JSPROP_ENUMERATE);
  4182:     }
  4182: 
 84755:     uint32_t newlen;
 84161:     if (!ToUint32(cx, *vp, &newlen))
 40221:         return false;
 59234: 
 90955:     double d;
 73894:     if (!ToNumber(cx, *vp, &d))
 73080:         return false;
 73080: 
 73080:     if (d != newlen) {
 73080:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_ARRAY_LENGTH);
 73080:         return false;
 73080:     }
 73080: 
 84755:     uint32_t oldlen = obj->getArrayLength();
 11835:     if (oldlen == newlen)
 40221:         return true;
 11835: 
 48470:     vp->setNumber(newlen);
 11835:     if (oldlen < newlen) {
 77343:         obj->setArrayLength(cx, newlen);
 40221:         return true;
 11835:     }
 11835: 
 39928:     if (obj->isDenseArray()) {
 48537:         /*
 48537:          * Don't reallocate if we're not actually shrinking our slots. If we do
 77343:          * shrink slots here, shrink the initialized length too.  This permits us
 77343:          * us to disregard length when reading from arrays as long we are within
 77343:          * the initialized capacity.
 48537:          */
 91688:         uint32_t oldcap = obj->getDenseArrayCapacity();
 91688:         uint32_t oldinit = obj->getDenseArrayInitializedLength();
 82129:         if (oldinit > newlen)
 82129:             obj->setDenseArrayInitializedLength(newlen);
 55746:         if (oldcap > newlen)
 83301:             obj->shrinkElements(cx, newlen);
 11835:     } else if (oldlen - newlen < (1 << 24)) {
     1:         do {
     1:             --oldlen;
 54169:             if (!JS_CHECK_OPERATION_LIMIT(cx)) {
 77343:                 obj->setArrayLength(cx, oldlen + 1);
 40221:                 return false;
 54169:             }
 62396:             int deletion = DeleteArrayElement(cx, obj, oldlen, strict);
 62396:             if (deletion <= 0) {
 77343:                 obj->setArrayLength(cx, oldlen + 1);
 62396:                 return deletion >= 0;
 54169:             }
     1:         } while (oldlen != newlen);
     1:     } else {
     1:         /*
     1:          * We are going to remove a lot of indexes in a presumably sparse
     1:          * array. So instead of looping through indexes between newlen and
     1:          * oldlen, we iterate through all properties and remove those that
 11835:          * correspond to indexes in the half-open range [newlen, oldlen).  See
 11835:          * bug 322135.
     1:          */
 40221:         JSObject *iter = JS_NewPropertyIterator(cx, obj);
     1:         if (!iter)
 40221:             return false;
     1: 
 91688:         uint32_t gap = oldlen - newlen;
     1:         for (;;) {
 98960:             jsid nid;
 98960:             if (!JS_CHECK_OPERATION_LIMIT(cx) || !JS_NextProperty(cx, iter, &nid))
 40390:                 return false;
 98960:             if (JSID_IS_VOID(nid))
     1:                 break;
 91688:             uint32_t index;
 73080:             Value junk;
 98960:             if (js_IdIsIndex(nid, &index) && index - newlen < gap &&
 80623:                 !obj->deleteElement(cx, index, &junk, false)) {
 40221:                 return false;
     1:             }
 40390:         }
 41850:     }
 41850: 
 77343:     obj->setArrayLength(cx, newlen);
 40221:     return true;
     1: }
     1: 
 78330: /* Returns true if the dense array has an own property at the index. */
 78330: static inline bool
 84755: IsDenseArrayIndex(JSObject *obj, uint32_t index)
 78330: {
 78330:     JS_ASSERT(obj->isDenseArray());
 78330: 
 78330:     return index < obj->getDenseArrayInitializedLength() &&
 78330:            !obj->getDenseArrayElement(index).isMagic(JS_ARRAY_HOLE);
 78330: }
 78330: 
 27483: /*
 77343:  * We have only indexed properties up to initialized length, plus the
 27483:  * length property. For all else, we delegate to the prototype.
 27483:  */
 27483: static inline bool
 27483: IsDenseArrayId(JSContext *cx, JSObject *obj, jsid id)
 27483: {
 39928:     JS_ASSERT(obj->isDenseArray());
 27483: 
 84755:     uint32_t i;
 48470:     return JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom) ||
 78330:            (js_IdIsIndex(id, &i) && IsDenseArrayIndex(obj, i));
 27483: }
 27483: 
     1: static JSBool
 98960: array_lookupGeneric(JSContext *cx, HandleObject obj, HandleId id, JSObject **objp,
 11835:                     JSProperty **propp)
 11835: {
 39928:     if (!obj->isDenseArray())
 98960:         return baseops::LookupProperty(cx, obj, id, objp, propp);
 11835: 
 27483:     if (IsDenseArrayId(cx, obj, id)) {
 48470:         *propp = (JSProperty *) 1;  /* non-null to indicate found */
 27483:         *objp = obj;
 27483:         return JS_TRUE;
 27483:     }
 27483: 
 39928:     JSObject *proto = obj->getProto();
 11835:     if (!proto) {
 11835:         *objp = NULL;
 11835:         *propp = NULL;
 11835:         return JS_TRUE;
     1:     }
 80442:     return proto->lookupGeneric(cx, id, objp, propp);
 80442: }
 80442: 
 80442: static JSBool
 98960: array_lookupProperty(JSContext *cx, HandleObject obj, HandlePropertyName name, JSObject **objp,
 80442:                      JSProperty **propp)
 80442: {
102586:     Rooted<jsid> id(cx, NameToId(name));
102586:     return array_lookupGeneric(cx, obj, id, objp, propp);
 11835: }
 11835: 
 77980: static JSBool
 98960: array_lookupElement(JSContext *cx, HandleObject obj, uint32_t index, JSObject **objp,
 77980:                     JSProperty **propp)
 77980: {
 78330:     if (!obj->isDenseArray())
 98960:         return baseops::LookupElement(cx, obj, index, objp, propp);
 78330: 
 78330:     if (IsDenseArrayIndex(obj, index)) {
 78330:         *propp = (JSProperty *) 1;  /* non-null to indicate found */
 78330:         *objp = obj;
 78330:         return true;
 78330:     }
 78330: 
 78330:     if (JSObject *proto = obj->getProto())
 78330:         return proto->lookupElement(cx, index, objp, propp);
 78330: 
 78330:     *objp = NULL;
 78330:     *propp = NULL;
 78330:     return true;
 77980: }
 77980: 
 78672: static JSBool
 98960: array_lookupSpecial(JSContext *cx, HandleObject obj, HandleSpecialId sid, JSObject **objp,
 78672:                     JSProperty **propp)
 78672: {
102586:     Rooted<jsid> id(cx, SPECIALID_TO_JSID(sid));
102586:     return array_lookupGeneric(cx, obj, id, objp, propp);
 78672: }
 78672: 
 27483: JSBool
 48470: js_GetDenseArrayElementValue(JSContext *cx, JSObject *obj, jsid id, Value *vp)
 26820: {
 48470:     JS_ASSERT(obj->isDenseArray());
 27483: 
 84755:     uint32_t i;
 27483:     if (!js_IdIsIndex(id, &i)) {
 48470:         JS_ASSERT(JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom));
 48470:         vp->setNumber(obj->getArrayLength());
 48470:         return JS_TRUE;
 27483:     }
 41782:     *vp = obj->getDenseArrayElement(i);
 27483:     return JS_TRUE;
 26820: }
 26820: 
     1: static JSBool
 98960: array_getProperty(JSContext *cx, HandleObject obj, HandleObject receiver, HandlePropertyName name, Value *vp)
 11835: {
 86536:     if (name == cx->runtime->atomState.lengthAtom) {
 48470:         vp->setNumber(obj->getArrayLength());
 86536:         return true;
 86536:     }
 86536: 
102586:     if (!obj->isDenseArray()) {
102586:         Rooted<jsid> id(cx, NameToId(name));
102586:         return baseops::GetProperty(cx, obj, receiver, id, vp);
102586:     }
 86536: 
 39928:     JSObject *proto = obj->getProto();
 11835:     if (!proto) {
 48470:         vp->setUndefined();
 86536:         return true;
 86536:     }
 86536: 
 86536:     return proto->getProperty(cx, receiver, name, vp);
 78675: }
 78675: 
 78675: static JSBool
 98960: array_getElement(JSContext *cx, HandleObject obj, HandleObject receiver, uint32_t index, Value *vp)
 77980: {
 78341:     if (!obj->isDenseArray())
 98960:         return baseops::GetElement(cx, obj, receiver, index, vp);
 86536: 
 86536:     if (index < obj->getDenseArrayInitializedLength()) {
 78341:         *vp = obj->getDenseArrayElement(index);
 86536:         if (!vp->isMagic(JS_ARRAY_HOLE)) {
 86536:             /* Type information for dense array elements must be correct. */
 86536:             JS_ASSERT_IF(!obj->hasSingletonType(),
 86536:                          js::types::TypeHasProperty(cx, obj->type(), JSID_VOID, *vp));
 86536: 
 78341:             return true;
 78341:         }
 86536:     }
 78341: 
 78341:     JSObject *proto = obj->getProto();
 78341:     if (!proto) {
 78341:         vp->setUndefined();
 78341:         return true;
 78341:     }
 78341: 
 81422:     return proto->getElement(cx, receiver, index, vp);
 77980: }
 77980: 
 77980: static JSBool
 98960: array_getSpecial(JSContext *cx, HandleObject obj, HandleObject receiver, HandleSpecialId sid, Value *vp)
 78672: {
 86536:     if (obj->isDenseArray() && !obj->getProto()) {
 86536:         vp->setUndefined();
 86536:         return true;
 86536:     }
 86536: 
102586:     Rooted<jsid> id(cx, SPECIALID_TO_JSID(sid));
102586:     return baseops::GetProperty(cx, obj, receiver, id, vp);
 86536: }
 86536: 
 86536: static JSBool
 98960: array_getGeneric(JSContext *cx, HandleObject obj, HandleObject receiver, HandleId id, Value *vp)
 86536: {
 86536:     Value idval = IdToValue(id);
 86536: 
 86536:     uint32_t index;
 86536:     if (IsDefinitelyIndex(idval, &index))
 86536:         return array_getElement(cx, obj, receiver, index, vp);
 86536: 
102586:     Rooted<SpecialId> sid(cx);
102586:     if (ValueIsSpecial(obj, &idval, sid.address(), cx))
102586:         return array_getSpecial(cx, obj, receiver, sid, vp);
 86536: 
102387:     JSAtom *atom = ToAtom(cx, idval);
102387:     if (!atom)
 86536:         return false;
 86536: 
 86536:     if (atom->isIndex(&index))
 86536:         return array_getElement(cx, obj, receiver, index, vp);
 86536: 
102586:     Rooted<PropertyName*> name(cx, atom->asPropertyName());
102586:     return array_getProperty(cx, obj, receiver, name, vp);
 78672: }
 78672: 
 78672: static JSBool
 98960: slowarray_addProperty(JSContext *cx, HandleObject obj, HandleId id, Value *vp)
     1: {
 91688:     uint32_t index, length;
     1: 
     1:     if (!js_IdIsIndex(id, &index))
     1:         return JS_TRUE;
 40796:     length = obj->getArrayLength();
 11835:     if (index >= length)
 77343:         obj->setArrayLength(cx, index + 1);
     1:     return JS_TRUE;
     1: }
     1: 
 38633: static JSType
 98960: array_typeOf(JSContext *cx, HandleObject obj)
 38633: {
 38633:     return JSTYPE_OBJECT;
 38633: }
 38633: 
     1: static JSBool
 98960: array_setGeneric(JSContext *cx, HandleObject obj, HandleId id, Value *vp, JSBool strict)
     1: {
 48470:     if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom))
 62395:         return array_length_setter(cx, obj, id, strict, vp);
 11835: 
 39928:     if (!obj->isDenseArray())
 98960:         return baseops::SetPropertyHelper(cx, obj, id, 0, vp, strict);
 11835: 
 58702:     do {
 95355:         uint32_t i;
 58702:         if (!js_IdIsIndex(id, &i))
 58702:             break;
 58702:         if (js_PrototypeHasIndexedProperties(cx, obj))
 58702:             break;
 58702: 
 58702:         JSObject::EnsureDenseResult result = obj->ensureDenseArrayElements(cx, i, 1);
 58702:         if (result != JSObject::ED_OK) {
 58702:             if (result == JSObject::ED_FAILED)
 54169:                 return false;
 58702:             JS_ASSERT(result == JSObject::ED_SPARSE);
 58702:             break;
 11835:         }
 11835: 
 40796:         if (i >= obj->getArrayLength())
 77343:             obj->setDenseArrayLength(i + 1);
 77343:         obj->setDenseArrayElementWithType(cx, i, *vp);
 54169:         return true;
 58702:     } while (false);
 58702: 
 95355:     if (!JSObject::makeDenseArraySlow(cx, obj))
 58702:         return false;
 98960:     return baseops::SetPropertyHelper(cx, obj, id, 0, vp, strict);
 11835: }
 11835: 
 77980: static JSBool
 98960: array_setProperty(JSContext *cx, HandleObject obj, HandlePropertyName name, Value *vp, JSBool strict)
 80625: {
102586:     Rooted<jsid> id(cx, NameToId(name));
102586:     return array_setGeneric(cx, obj, id, vp, strict);
 80625: }
 80625: 
 80625: static JSBool
 98960: array_setElement(JSContext *cx, HandleObject obj, uint32_t index, Value *vp, JSBool strict)
 77980: {
 99421:     RootedId id(cx);
 98960:     if (!IndexToId(cx, index, id.address()))
 77980:         return false;
 78346: 
 78346:     if (!obj->isDenseArray())
 98960:         return baseops::SetPropertyHelper(cx, obj, id, 0, vp, strict);
 78346: 
 78346:     do {
 78346:         /*
 78346:          * UINT32_MAX is not an array index and must not affect the length
 78346:          * property, so specifically reject it.
 78346:          */
 78346:         if (index == UINT32_MAX)
 78346:             break;
 78346:         if (js_PrototypeHasIndexedProperties(cx, obj))
 78346:             break;
 78346: 
 78346:         JSObject::EnsureDenseResult result = obj->ensureDenseArrayElements(cx, index, 1);
 78346:         if (result != JSObject::ED_OK) {
 78346:             if (result == JSObject::ED_FAILED)
 78346:                 return false;
 78346:             JS_ASSERT(result == JSObject::ED_SPARSE);
 78346:             break;
 78346:         }
 78346: 
 78346:         if (index >= obj->getArrayLength())
 78346:             obj->setDenseArrayLength(index + 1);
 78346:         obj->setDenseArrayElementWithType(cx, index, *vp);
 78346:         return true;
 78346:     } while (false);
 78346: 
 95355:     if (!JSObject::makeDenseArraySlow(cx, obj))
 78346:         return false;
 98960:     return baseops::SetPropertyHelper(cx, obj, id, 0, vp, strict);
 77980: }
 77980: 
 78672: static JSBool
 98960: array_setSpecial(JSContext *cx, HandleObject obj, HandleSpecialId sid, Value *vp, JSBool strict)
 78672: {
102586:     Rooted<jsid> id(cx, SPECIALID_TO_JSID(sid));
102586:     return array_setGeneric(cx, obj, id, vp, strict);
 78672: }
 78672: 
 25886: JSBool
 25886: js_PrototypeHasIndexedProperties(JSContext *cx, JSObject *obj)
 25883: {
 25883:     /*
 25888:      * Walk up the prototype chain and see if this indexed element already
 25888:      * exists. If we hit the end of the prototype chain, it's safe to set the
 25888:      * element on the original object.
 25883:      */
 32603:     while ((obj = obj->getProto()) != NULL) {
 25883:         /*
 25888:          * If the prototype is a non-native object (possibly a dense array), or
 25888:          * a native object (possibly a slow array) that has indexed properties,
 25888:          * return true.
 25883:          */
 40430:         if (!obj->isNative())
 25888:             return JS_TRUE;
 52503:         if (obj->isIndexed())
 25883:             return JS_TRUE;
 25883:     }
 25883:     return JS_FALSE;
 25883: }
 25883: 
 80624: static JSBool
 98960: array_defineGeneric(JSContext *cx, HandleObject obj, HandleId id, const Value *value,
 91237:                     JSPropertyOp getter, StrictPropertyOp setter, unsigned attrs)
 11835: {
 48470:     if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom))
 11835:         return JS_TRUE;
 11835: 
 59891:     if (!obj->isDenseArray())
102586:         return baseops::DefineGeneric(cx, obj, id, value, getter, setter, attrs);
 59891: 
 59891:     do {
 84755:         uint32_t i = 0;       // init to shut GCC up
 59891:         bool isIndex = js_IdIsIndex(id, &i);
 59891:         if (!isIndex || attrs != JSPROP_ENUMERATE)
 59891:             break;
 59891: 
 59891:         JSObject::EnsureDenseResult result = obj->ensureDenseArrayElements(cx, i, 1);
 59891:         if (result != JSObject::ED_OK) {
 59891:             if (result == JSObject::ED_FAILED)
 59891:                 return false;
 59891:             JS_ASSERT(result == JSObject::ED_SPARSE);
 59891:             break;
 11835:         }
 11835: 
 59891:         if (i >= obj->getArrayLength())
 77343:             obj->setDenseArrayLength(i + 1);
 77343:         obj->setDenseArrayElementWithType(cx, i, *value);
 59891:         return true;
 59891:     } while (false);
 59891: 
 99364:     AutoRooterGetterSetter gsRoot(cx, attrs, &getter, &setter);
 98960: 
 95355:     if (!JSObject::makeDenseArraySlow(cx, obj))
 59891:         return false;
102586:     return baseops::DefineGeneric(cx, obj, id, value, getter, setter, attrs);
 11835: }
 11835: 
 80624: static JSBool
 98960: array_defineProperty(JSContext *cx, HandleObject obj, HandlePropertyName name, const Value *value,
 91237:                      JSPropertyOp getter, StrictPropertyOp setter, unsigned attrs)
 80624: {
102586:     Rooted<jsid> id(cx, NameToId(name));
102586:     return array_defineGeneric(cx, obj, id, value, getter, setter, attrs);
 80624: }
 80624: 
 80624: namespace js {
 80624: 
 77980: /* non-static for direct definition of array elements within the engine */
 77980: JSBool
 98960: array_defineElement(JSContext *cx, HandleObject obj, uint32_t index, const Value *value,
 91237:                     PropertyOp getter, StrictPropertyOp setter, unsigned attrs)
 77980: {
 78345:     if (!obj->isDenseArray())
 98960:         return baseops::DefineElement(cx, obj, index, value, getter, setter, attrs);
 78345: 
 78345:     do {
 78345:         /*
 78345:          * UINT32_MAX is not an array index and must not affect the length
 78345:          * property, so specifically reject it.
 78345:          */
 78345:         if (attrs != JSPROP_ENUMERATE || index == UINT32_MAX)
 78345:             break;
 78345: 
 78345:         JSObject::EnsureDenseResult result = obj->ensureDenseArrayElements(cx, index, 1);
 78345:         if (result != JSObject::ED_OK) {
 78345:             if (result == JSObject::ED_FAILED)
 78345:                 return false;
 78345:             JS_ASSERT(result == JSObject::ED_SPARSE);
 78345:             break;
 78345:         }
 78345: 
 78345:         if (index >= obj->getArrayLength())
 78345:             obj->setDenseArrayLength(index + 1);
 78345:         obj->setDenseArrayElementWithType(cx, index, *value);
 78345:         return true;
 78345:     } while (false);
 78345: 
 99364:     AutoRooterGetterSetter gsRoot(cx, attrs, &getter, &setter);
 97353: 
 98960:     if (!JSObject::makeDenseArraySlow(cx, obj))
 78345:         return false;
 98960:     return baseops::DefineElement(cx, obj, index, value, getter, setter, attrs);
 77980: }
 77980: 
 69826: } // namespace js
 69826: 
 11835: static JSBool
 98960: array_defineSpecial(JSContext *cx, HandleObject obj, HandleSpecialId sid, const Value *value,
 91237:                     PropertyOp getter, StrictPropertyOp setter, unsigned attrs)
 78672: {
102586:     Rooted<jsid> id(cx, SPECIALID_TO_JSID(sid));
102586:     return array_defineGeneric(cx, obj, id, value, getter, setter, attrs);
 78672: }
 78672: 
 78672: static JSBool
 98960: array_getGenericAttributes(JSContext *cx, HandleObject obj, HandleId id, unsigned *attrsp)
 11835: {
 48470:     *attrsp = JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)
 11835:         ? JSPROP_PERMANENT : JSPROP_ENUMERATE;
 80622:     return true;
 80622: }
 80622: 
 80622: static JSBool
 98960: array_getPropertyAttributes(JSContext *cx, HandleObject obj, HandlePropertyName name, unsigned *attrsp)
 80622: {
 80622:     *attrsp = (name == cx->runtime->atomState.lengthAtom)
 80622:               ? JSPROP_PERMANENT
 80622:               : JSPROP_ENUMERATE;
 80622:     return true;
 11835: }
 11835: 
 11835: static JSBool
 98960: array_getElementAttributes(JSContext *cx, HandleObject obj, uint32_t index, unsigned *attrsp)
 77980: {
 78342:     *attrsp = JSPROP_ENUMERATE;
 78342:     return true;
 77980: }
 77980: 
 77980: static JSBool
 98960: array_getSpecialAttributes(JSContext *cx, HandleObject obj, HandleSpecialId sid, unsigned *attrsp)
 78672: {
 80622:     *attrsp = JSPROP_ENUMERATE;
 80622:     return true;
 78672: }
 78672: 
 78672: static JSBool
 98960: array_setGenericAttributes(JSContext *cx, HandleObject obj, HandleId id, unsigned *attrsp)
 80622: {
 80622:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_SET_ARRAY_ATTRS);
 80622:     return false;
 80622: }
 80622: 
 80622: static JSBool
 98960: array_setPropertyAttributes(JSContext *cx, HandleObject obj, HandlePropertyName name, unsigned *attrsp)
 11835: {
 78343:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_SET_ARRAY_ATTRS);
 78343:     return false;
 11835: }
 11835: 
 77980: static JSBool
 98960: array_setElementAttributes(JSContext *cx, HandleObject obj, uint32_t index, unsigned *attrsp)
 77980: {
 78343:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_SET_ARRAY_ATTRS);
 77980:     return false;
 77980: }
 77980: 
 78672: static JSBool
 98960: array_setSpecialAttributes(JSContext *cx, HandleObject obj, HandleSpecialId sid, unsigned *attrsp)
 78672: {
 80622:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_SET_ARRAY_ATTRS);
 80622:     return false;
 78672: }
 78672: 
 80623: static JSBool
 98960: array_deleteProperty(JSContext *cx, HandleObject obj, HandlePropertyName name, Value *rval, JSBool strict)
 11835: {
 39928:     if (!obj->isDenseArray())
 98960:         return baseops::DeleteProperty(cx, obj, name, rval, strict);
 86790: 
 86790:     if (name == cx->runtime->atomState.lengthAtom) {
 48470:         rval->setBoolean(false);
 78344:         return true;
 11835:     }
 11835: 
 48470:     rval->setBoolean(true);
 78344:     return true;
 11835: }
 11835: 
 80623: namespace js {
 80623: 
 77980: /* non-static for direct deletion of array elements within the engine */
 77980: JSBool
 98960: array_deleteElement(JSContext *cx, HandleObject obj, uint32_t index, Value *rval, JSBool strict)
 77980: {
 78344:     if (!obj->isDenseArray())
 98960:         return baseops::DeleteElement(cx, obj, index, rval, strict);
 78344: 
 78344:     if (index < obj->getDenseArrayInitializedLength()) {
 78344:         obj->markDenseArrayNotPacked(cx);
 78344:         obj->setDenseArrayElement(index, MagicValue(JS_ARRAY_HOLE));
 78344:     }
 78344: 
102586:     if (!js_SuppressDeletedElement(cx, obj, index))
 77980:         return false;
 78344: 
 78344:     rval->setBoolean(true);
 78344:     return true;
 77980: }
 77980: 
 69826: } // namespace js
 69826: 
 78672: static JSBool
 98960: array_deleteSpecial(JSContext *cx, HandleObject obj, HandleSpecialId sid, Value *rval, JSBool strict)
 78672: {
 86790:     if (!obj->isDenseArray())
 98960:         return baseops::DeleteSpecial(cx, obj, sid, rval, strict);
 86790: 
 86790:     rval->setBoolean(true);
 86790:     return true;
 78672: }
 78672: 
 11835: static void
 11835: array_trace(JSTracer *trc, JSObject *obj)
 11835: {
 37003:     JS_ASSERT(obj->isDenseArray());
 11835: 
 84755:     uint32_t initLength = obj->getDenseArrayInitializedLength();
 91557:     MarkArraySlots(trc, initLength, obj->getDenseArrayElements(), "element");
 11835: }
 11835: 
 77817: Class js::ArrayClass = {
 48622:     "Array",
 89622:     Class::NON_NATIVE | JSCLASS_HAS_CACHED_PROTO(JSProto_Array) | JSCLASS_FOR_OF_ITERATION,
 78614:     JS_PropertyStub,         /* addProperty */
 78614:     JS_PropertyStub,         /* delProperty */
 78614:     JS_PropertyStub,         /* getProperty */
 78614:     JS_StrictPropertyStub,   /* setProperty */
 78614:     JS_EnumerateStub,
 78614:     JS_ResolveStub,
 78614:     JS_ConvertStub,
 55746:     NULL,
 48622:     NULL,           /* checkAccess */
 48622:     NULL,           /* call        */
 48622:     NULL,           /* construct   */
 48622:     NULL,           /* hasInstance */
 64223:     array_trace,    /* trace       */
 89622:     {
 89622:         NULL,       /* equality    */
 89622:         NULL,       /* outerObject */
 89622:         NULL,       /* innerObject */
 89625:         JS_ElementIteratorStub,
 89622:         NULL,       /* unused      */
 89622:         false,      /* isWrappedNative */
 89622:     },
 48622:     {
 80442:         array_lookupGeneric,
 78672:         array_lookupProperty,
 77980:         array_lookupElement,
 78672:         array_lookupSpecial,
 80624:         array_defineGeneric,
 43290:         array_defineProperty,
 77980:         array_defineElement,
 78672:         array_defineSpecial,
 78675:         array_getGeneric,
 43290:         array_getProperty,
 77980:         array_getElement,
 81417:         NULL, /* getElementIfPresent, because this is hard for now for
 81417:                  slow arrays */
 78672:         array_getSpecial,
 80625:         array_setGeneric,
 43290:         array_setProperty,
 77980:         array_setElement,
 78672:         array_setSpecial,
 80622:         array_getGenericAttributes,
 80622:         array_getPropertyAttributes,
 77980:         array_getElementAttributes,
 78672:         array_getSpecialAttributes,
 80622:         array_setGenericAttributes,
 80622:         array_setPropertyAttributes,
 77980:         array_setElementAttributes,
 78672:         array_setSpecialAttributes,
 43290:         array_deleteProperty,
 77980:         array_deleteElement,
 78672:         array_deleteSpecial,
 48622:         NULL,       /* enumerate      */
 43290:         array_typeOf,
 43290:         NULL,       /* thisObject     */
 48622:         NULL,       /* clear          */
     1:     }
     1: };
     1: 
 77817: Class js::SlowArrayClass = {
 11835:     "Array",
 89622:     JSCLASS_HAS_CACHED_PROTO(JSProto_Array) | JSCLASS_FOR_OF_ITERATION,
 48622:     slowarray_addProperty,
 78614:     JS_PropertyStub,         /* delProperty */
 78614:     JS_PropertyStub,         /* getProperty */
 78614:     JS_StrictPropertyStub,   /* setProperty */
 78614:     JS_EnumerateStub,
 78614:     JS_ResolveStub,
 89622:     JS_ConvertStub,
 89622:     NULL,
 89622:     NULL,           /* checkAccess */
 89622:     NULL,           /* call        */
 89622:     NULL,           /* construct   */
 89622:     NULL,           /* hasInstance */
 89622:     NULL,           /* trace       */
 89622:     {
 89622:         NULL,       /* equality    */
 89622:         NULL,       /* outerObject */
 89622:         NULL,       /* innerObject */
 89625:         JS_ElementIteratorStub,
 89622:         NULL,       /* unused      */
 89622:         false,      /* isWrappedNative */
 89622:     }
     1: };
     1: 
 83231: bool
 83231: JSObject::allocateSlowArrayElements(JSContext *cx)
 83231: {
 83231:     JS_ASSERT(hasClass(&js::SlowArrayClass));
 83231:     JS_ASSERT(elements == emptyObjectElements);
 83231: 
 83275:     ObjectElements *header = cx->new_<ObjectElements>(0, 0);
 83231:     if (!header)
 83231:         return false;
 83231: 
 83231:     elements = header->elements();
 83231:     return true;
 83231: }
 83231: 
 62076: static bool
 62076: AddLengthProperty(JSContext *cx, JSObject *obj)
 62076: {
 83231:     /*
 83231:      * Add the 'length' property for a newly created or converted slow array,
 83231:      * and update the elements to be an empty array owned by the object.
 83231:      * The shared emptyObjectElements singleton cannot be used for slow arrays,
 83231:      * as accesses to 'length' will use the elements header.
 83231:      */
 83231: 
 99421:     RootedId lengthId(cx, NameToId(cx->runtime->atomState.lengthAtom));
 78194:     JS_ASSERT(!obj->nativeLookup(cx, lengthId));
 62076: 
 83231:     if (!obj->allocateSlowArrayElements(cx))
 83231:         return false;
 83231: 
 62076:     return obj->addProperty(cx, lengthId, array_length_getter, array_length_setter,
 62076:                             SHAPE_INVALID_SLOT, JSPROP_PERMANENT | JSPROP_SHARED, 0, 0);
 62076: }
 62076: 
 11835: /*
 11835:  * Convert an array object from fast-and-dense to slow-and-flexible.
 11835:  */
 95355: /* static */ bool
 95355: JSObject::makeDenseArraySlow(JSContext *cx, HandleObject obj)
 11835: {
 95355:     JS_ASSERT(obj->isDenseArray());
 95355: 
 95355:     MarkTypeObjectFlags(cx, obj,
 77343:                         OBJECT_FLAG_NON_PACKED_ARRAY |
 77343:                         OBJECT_FLAG_NON_DENSE_ARRAY);
 83222: 
 95355:     uint32_t arrayCapacity = obj->getDenseArrayCapacity();
 95355:     uint32_t arrayInitialized = obj->getDenseArrayInitializedLength();
 83222: 
 83222:     /*
 83231:      * Get an allocated array of the existing elements, evicting from the fixed
 83231:      * slots if necessary.
 83222:      */
 95355:     if (!obj->hasDynamicElements()) {
 95355:         if (!obj->growElements(cx, arrayCapacity))
 83222:             return false;
 95355:         JS_ASSERT(obj->hasDynamicElements());
 83222:     }
 77343: 
 32652:     /*
 52503:      * Save old map now, before calling InitScopeForObject. We'll have to undo
 77343:      * on error. This is gross, but a better way is not obvious. Note: the
 77343:      * exact contents of the array are not preserved on error.
 52503:      */
 95355:     js::Shape *oldShape = obj->lastProperty();
 52503: 
 57821:     /* Create a native scope. */
 95355:     gc::AllocKind kind = obj->getAllocKind();
 95355:     Shape *shape = EmptyShape::getInitialShape(cx, &SlowArrayClass, obj->getProto(),
 83297:                                                oldShape->getObjectParent(), kind);
 83275:     if (!shape)
 52503:         return false;
 95355:     obj->shape_ = shape;
 83231: 
 83231:     /* Take ownership of the dense elements, reset to an empty dense array. */
 95355:     HeapSlot *elems = obj->elements;
 95355:     obj->elements = emptyObjectElements;
 83231: 
 83231:     /* Root all values in the array during conversion. */
 83301:     AutoValueArray autoArray(cx, (Value *) elems, arrayInitialized);
 55746: 
 48641:     /*
 55746:      * Begin with the length property to share more of the property tree.
 55746:      * The getter/setter here will directly access the object's private value.
 48641:      */
 95355:     if (!AddLengthProperty(cx, obj)) {
 95355:         obj->shape_ = oldShape;
 95355:         if (obj->elements != emptyObjectElements)
 95355:             cx->free_(obj->getElementsHeader());
 95355:         obj->elements = elems;
 52503:         return false;
 43287:     }
 43287: 
 57821:     /*
 57821:      * Create new properties pointing to existing elements. Pack the array to
 57821:      * remove holes, so that shapes use successive slots (as for other objects).
 57821:      */
 84755:     uint32_t next = 0;
 84755:     for (uint32_t i = 0; i < arrayInitialized; i++) {
 77343:         /* Dense array indexes can always fit in a jsid. */
 11835:         jsid id;
 77343:         JS_ALWAYS_TRUE(ValueToId(cx, Int32Value(i), &id));
 77343: 
 83231:         if (elems[i].isMagic(JS_ARRAY_HOLE))
 77343:             continue;
 77343: 
 95355:         if (!obj->addDataProperty(cx, id, next, JSPROP_ENUMERATE)) {
 95355:             obj->shape_ = oldShape;
 95355:             cx->free_(obj->getElementsHeader());
 95355:             obj->elements = elems;
 52503:             return false;
 52503:         }
 52503: 
 95355:         obj->initSlot(next, elems[i]);
 83231: 
 57821:         next++;
 11835:     }
 11835: 
 83231:     ObjectElements *oldheader = ObjectElements::fromElements(elems);
 83231: 
 95355:     obj->getElementsHeader()->length = oldheader->length;
 83231:     cx->free_(oldheader);
 57821: 
 52503:     return true;
 11835: }
 11835: 
 67949: #if JS_HAS_TOSOURCE
 67949: class ArraySharpDetector
 30023: {
 67949:     JSContext *cx;
 90320:     bool success;
 88138:     bool alreadySeen;
 67949:     bool sharp;
 67949: 
 67949:   public:
 67949:     ArraySharpDetector(JSContext *cx)
 67949:       : cx(cx),
 90320:         success(false),
 88138:         alreadySeen(false),
 67949:         sharp(false)
 67949:     {}
 67949: 
 97353:     bool init(HandleObject obj) {
 90320:         success = js_EnterSharpObject(cx, obj, NULL, &alreadySeen, &sharp);
 90320:         if (!success)
 31477:             return false;
 31477:         return true;
 30023:     }
 30023: 
 67949:     bool initiallySharp() const {
 88138:         JS_ASSERT_IF(sharp, alreadySeen);
 67949:         return sharp;
 67949:     }
 67949: 
 67949:     ~ArraySharpDetector() {
 90320:         if (success && !sharp)
 67949:             js_LeaveSharpObject(cx, NULL);
 67949:     }
 67949: };
 67949: 
 30023: static JSBool
 91237: array_toSource(JSContext *cx, unsigned argc, Value *vp)
 30023: {
 31477:     JS_CHECK_RECURSION(cx, return false);
 30023: 
 79387:     CallArgs args = CallArgsFromVp(argc, vp);
 99421:     RootedObject obj(cx, ToObject(cx, &args.thisv()));
 61734:     if (!obj)
 31477:         return false;
 79389:     if (!obj->isArray())
 79779:         return HandleNonGenericMethodClassMismatch(cx, args, array_toSource, &ArrayClass);
 30023: 
 67949:     ArraySharpDetector detector(cx);
 67949:     if (!detector.init(obj))
 31477:         return false;
 67949: 
 60571:     StringBuffer sb(cx);
 30023: 
 67949:     if (detector.initiallySharp()) {
 60571:         if (!sb.append("[]"))
 67949:             return false;
 30023:         goto make_string;
 30023:     }
 30023: 
 60571:     if (!sb.append('['))
 67949:         return false;
 30023: 
 91688:     uint32_t length;
 31477:     if (!js_GetLengthProperty(cx, obj, &length))
 67949:         return false;
 30023: 
 91688:     for (uint32_t index = 0; index < length; index++) {
 30023:         JSBool hole;
 80814:         Value elt;
 31477:         if (!JS_CHECK_OPERATION_LIMIT(cx) ||
 80814:             !GetElement(cx, obj, index, &hole, &elt)) {
 67949:             return false;
 31477:         }
 30023: 
 30023:         /* Get element's character string. */
 30023:         JSString *str;
 30023:         if (hole) {
     1:             str = cx->runtime->emptyString;
     1:         } else {
 80814:             str = js_ValueToSource(cx, elt);
 31477:             if (!str)
 67949:                 return false;
 30023:         }
 30023: 
 30023:         /* Append element to buffer. */
 67949:         if (!sb.append(str))
 67949:             return false;
 30023:         if (index + 1 != length) {
 60571:             if (!sb.append(", "))
 67949:                 return false;
 30023:         } else if (hole) {
 60571:             if (!sb.append(','))
 67949:                 return false;
 30023:         }
 30023:     }
 30023: 
 30023:     /* Finalize the buffer. */
 60571:     if (!sb.append(']'))
 67949:         return false;
 30023: 
 30023:   make_string:
 67949:     JSString *str = sb.finishString();
 67949:     if (!str)
 67949:         return false;
 67949: 
 79387:     args.rval().setString(str);
 67949:     return true;
 30023: }
 30023: #endif
 30023: 
 67950: class AutoArrayCycleDetector
 67950: {
 67950:     JSContext *cx;
 67950:     JSObject *obj;
 84755:     uint32_t genBefore;
 67950:     BusyArraysSet::AddPtr hashPointer;
 67950:     bool cycle;
 67950:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
 67950: 
 67950:   public:
 67950:     AutoArrayCycleDetector(JSContext *cx, JSObject *obj JS_GUARD_OBJECT_NOTIFIER_PARAM)
 67950:       : cx(cx),
 67950:         obj(obj),
 67950:         cycle(true)
 67950:     {
 67950:         JS_GUARD_OBJECT_NOTIFIER_INIT;
 67950:     }
 67950: 
 67950:     bool init()
 67950:     {
 67950:         BusyArraysSet &set = cx->busyArrays;
 67950:         hashPointer = set.lookupForAdd(obj);
 67950:         if (!hashPointer) {
 67950:             if (!set.add(hashPointer, obj))
 67950:                 return false;
 67950:             cycle = false;
 67950:             genBefore = set.generation();
 67950:         }
 67950:         return true;
 67950:     }
 67950: 
 67950:     ~AutoArrayCycleDetector()
 67950:     {
 67950:         if (!cycle) {
 67950:             if (genBefore == cx->busyArrays.generation())
 67950:                 cx->busyArrays.remove(hashPointer);
 67950:             else
 67950:                 cx->busyArrays.remove(obj);
 67950:         }
 67950:     }
 67950: 
 67950:     bool foundCycle() { return cycle; }
 67950: 
 67950:   protected:
 67950: };
 67950: 
 30023: static JSBool
 97353: array_toString_sub(JSContext *cx, HandleObject obj, JSBool locale,
 97353:                    HandleString sepstr, CallArgs &args)
 30023: {
 59890:     static const jschar comma = ',';
 59890:     const jschar *sep;
 59890:     size_t seplen;
 59890:     if (sepstr) {
 97353:         sep = NULL;
 59890:         seplen = sepstr->length();
 59890:     } else {
 59890:         sep = &comma;
 59890:         seplen = 1;
 59890:     }
 59890: 
 67950:     AutoArrayCycleDetector detector(cx, obj);
 67950:     if (!detector.init())
 51451:         return false;
 67950: 
 67950:     if (detector.foundCycle()) {
 80814:         args.rval().setString(cx->runtime->atomState.emptyAtom);
 31477:         return true;
 30023:     }
 30023: 
 91688:     uint32_t length;
 31477:     if (!js_GetLengthProperty(cx, obj, &length))
 67950:         return false;
 67950: 
 67950:     StringBuffer sb(cx);
 67950: 
 67950:     if (!locale && !seplen && obj->isDenseArray() && !js_PrototypeHasIndexedProperties(cx, obj)) {
 87973:         const Value *start = obj->getDenseArrayElements();
 87973:         const Value *end = start + obj->getDenseArrayInitializedLength();
 87973:         const Value *elem;
 87973:         for (elem = start; elem < end; elem++) {
 67950:             if (!JS_CHECK_OPERATION_LIMIT(cx))
 67950:                 return false;
 67950: 
 87973:             /*
 87973:              * Object stringifying is slow; delegate it to a separate loop to
 87973:              * keep this one tight.
 87973:              */
 87973:             if (elem->isObject())
 87973:                 break;
 87973: 
 87973:             if (!elem->isMagic(JS_ARRAY_HOLE) && !elem->isNullOrUndefined()) {
 87973:                 if (!ValueToStringBuffer(cx, *elem, sb))
 87973:                     return false;
 87973:             }
 87973:         }
 87973: 
 87973:         for (uint32_t i = uint32_t(PointerRangeSize(start, elem)); i < length; i++) {
 87973:             if (!JS_CHECK_OPERATION_LIMIT(cx))
 87973:                 return false;
 87973: 
 87973:             JSBool hole;
 87973:             Value v;
 87973:             if (!GetElement(cx, obj, i, &hole, &v))
 87973:                 return false;
 87973:             if (!hole && !v.isNullOrUndefined()) {
 87973:                 if (!ValueToStringBuffer(cx, v, sb))
 67950:                     return false;
 67950:             }
 67950:         }
 67950:     } else {
 91688:         for (uint32_t index = 0; index < length; index++) {
 67950:             if (!JS_CHECK_OPERATION_LIMIT(cx))
 67950:                 return false;
 67950: 
 51451:             JSBool hole;
 80814:             Value elt;
 80814:             if (!GetElement(cx, obj, index, &hole, &elt))
 67950:                 return false;
 67950: 
 80814:             if (!hole && !elt.isNullOrUndefined()) {
 51451:                 if (locale) {
 80814:                     JSObject *robj = ToObject(cx, &elt);
 67921:                     if (!robj)
 67950:                         return false;
 99421:                     RootedId id(cx, NameToId(cx->runtime->atomState.toLocaleStringAtom));
 80814:                     if (!robj->callMethod(cx, id, 0, NULL, &elt))
 67950:                         return false;
 51448:                 }
 80814:                 if (!ValueToStringBuffer(cx, elt, sb))
 67950:                     return false;
     1:             }
 30023: 
 30023:             if (index + 1 != length) {
 97353:                 const jschar *sepchars = sep ? sep : sepstr->getChars(cx);
 97353:                 if (!sepchars || !sb.append(sepchars, seplen))
 67950:                     return false;
     1:             }
 30023:         }
 67950:     }
 67950: 
 67950:     JSString *str = sb.finishString();
 67949:     if (!str)
 67950:         return false;
 80814:     args.rval().setString(str);
 67950:     return true;
     1: }
     1: 
 48486: /* ES5 15.4.4.2. NB: The algorithm here differs from the one in ES3. */
     1: static JSBool
 91237: array_toString(JSContext *cx, unsigned argc, Value *vp)
     1: {
 69228:     JS_CHECK_RECURSION(cx, return false);
 69228: 
 80814:     CallArgs args = CallArgsFromVp(argc, vp);
 99421:     RootedObject obj(cx, ToObject(cx, &args.thisv()));
 48486:     if (!obj)
 48486:         return false;
 48486: 
 80814:     Value join = args.calleev();
 78675:     if (!obj->getProperty(cx, cx->runtime->atomState.joinAtom, &join))
 48486:         return false;
 48486: 
 48486:     if (!js_IsCallable(join)) {
 48486:         JSString *str = obj_toStringHelper(cx, obj);
 48486:         if (!str)
 48486:             return false;
 80814:         args.rval().setString(str);
 48486:         return true;
     1:     }
 30023: 
 80814:     InvokeArgsGuard ag;
 80814:     if (!cx->stack.pushInvokeArgs(cx, 0, &ag))
 48486:         return false;
 48486: 
 80814:     ag.calleev() = join;
 80814:     ag.thisv().setObject(*obj);
 48486: 
 48486:     /* Do the call. */
 80814:     if (!Invoke(cx, ag))
 48486:         return false;
 80814:     args.rval() = ag.rval();
 48486:     return true;
     1: }
     1: 
     1: static JSBool
 91237: array_toLocaleString(JSContext *cx, unsigned argc, Value *vp)
     1: {
 69228:     JS_CHECK_RECURSION(cx, return false);
 69228: 
 80814:     CallArgs args = CallArgsFromVp(argc, vp);
 99421:     RootedObject obj(cx, ToObject(cx, &args.thisv()));
 48486:     if (!obj)
 48486:         return false;
  3287: 
     1:     /*
     1:      *  Passing comma here as the separator. Need a way to get a
     1:      *  locale-specific version.
     1:      */
102586:     Rooted<JSString*> none(cx, NULL);
102586:     return array_toString_sub(cx, obj, JS_TRUE, none, args);
     1: }
     1: 
 77343: static inline bool
 77343: InitArrayTypes(JSContext *cx, TypeObject *type, const Value *vector, unsigned count)
 77343: {
 77343:     if (cx->typeInferenceEnabled() && !type->unknownProperties()) {
 77343:         AutoEnterTypeInference enter(cx);
 77343: 
 77343:         TypeSet *types = type->getProperty(cx, JSID_VOID, true);
 77343:         if (!types)
 77343:             return false;
 77343: 
 77343:         for (unsigned i = 0; i < count; i++) {
 77343:             if (vector[i].isMagic(JS_ARRAY_HOLE))
 77343:                 continue;
 77353:             Type valtype = GetValueType(cx, vector[i]);
 77343:             types->addType(cx, valtype);
 77343:         }
 77343:     }
 77343:     return true;
 77343: }
 77343: 
 82640: enum ShouldUpdateTypes
 82640: {
 82640:     UpdateTypes = true,
 82640:     DontUpdateTypes = false
 82640: };
 82640: 
 82640: static bool
 95355: InitArrayElements(JSContext *cx, HandleObject obj, uint32_t start, uint32_t count, const Value *vector, ShouldUpdateTypes updateTypes)
     1: {
 74949:     JS_ASSERT(count <= MAX_ARRAY_INDEX);
 28242: 
 77343:     if (count == 0)
 82640:         return true;
 77343: 
 77353:     if (updateTypes && !InitArrayTypes(cx, obj->getType(cx), vector, count))
 82640:         return false;
 77343: 
 26564:     /*
 26564:      * Optimize for dense arrays so long as adding the given set of elements
 26564:      * wouldn't otherwise make the array slow.
 26564:      */
 58702:     do {
 58702:         if (!obj->isDenseArray())
 58702:             break;
 58702:         if (js_PrototypeHasIndexedProperties(cx, obj))
 58702:             break;
 58702: 
 58702:         JSObject::EnsureDenseResult result = obj->ensureDenseArrayElements(cx, start, count);
 58702:         if (result != JSObject::ED_OK) {
 58702:             if (result == JSObject::ED_FAILED)
 58702:                 return false;
 58702:             JS_ASSERT(result == JSObject::ED_SPARSE);
 58702:             break;
 58702:         }
 91688:         uint32_t newlen = start + count;
 40796:         if (newlen > obj->getArrayLength())
 77343:             obj->setDenseArrayLength(newlen);
 26564: 
 79934:         JS_ASSERT(count < UINT32_MAX / sizeof(Value));
 74457:         obj->copyDenseArrayElements(start, vector, count);
 48470:         JS_ASSERT_IF(count != 0, !obj->getDenseArrayElement(newlen - 1).isMagic(JS_ARRAY_HOLE));
 58702:         return true;
 58702:     } while (false);
 11835: 
 79934:     const Value* end = vector + count;
 79934:     while (vector < end && start <= MAX_ARRAY_INDEX) {
 25087:         if (!JS_CHECK_OPERATION_LIMIT(cx) ||
     1:             !SetArrayElement(cx, obj, start++, *vector++)) {
 82640:             return false;
     1:         }
     1:     }
 26564: 
 26564:     if (vector == end)
 82640:         return true;
 26564: 
 26564:     /* Finish out any remaining elements past the max array index. */
 95355:     if (obj->isDenseArray() && !JSObject::makeDenseArraySlow(cx, obj))
 82640:         return false;
 26564: 
 74949:     JS_ASSERT(start == MAX_ARRAY_INDEX + 1);
 99421:     RootedValue value(cx);
 99421:     RootedId id(cx);
 74949:     Value idval = DoubleValue(MAX_ARRAY_INDEX + 1);
 26564:     do {
 97353:         value = *vector++;
 97828:         if (!ValueToId(cx, idval, id.address()) ||
 97353:             !obj->setGeneric(cx, id, value.address(), true)) {
 82640:             return false;
 26564:         }
 48470:         idval.getDoubleRef() += 1;
 26564:     } while (vector != end);
 26564: 
 82640:     return true;
     1: }
     1: 
 79934: #if 0
     1: static JSBool
 91688: InitArrayObject(JSContext *cx, JSObject *obj, uint32_t length, const Value *vector)
     1: {
 39928:     JS_ASSERT(obj->isArray());
 11835: 
 41838:     JS_ASSERT(obj->isDenseArray());
 77343:     obj->setArrayLength(cx, length);
 48551:     if (!vector || !length)
 48604:         return true;
 58702: 
 77353:     if (!InitArrayTypes(cx, obj->getType(cx), vector, length))
 77343:         return false;
 77343: 
 58702:     /* Avoid ensureDenseArrayElements to skip sparse array checks there. */
 83231:     if (!obj->ensureElements(cx, length))
 48551:         return false;
 77343: 
 77343:     obj->setDenseArrayInitializedLength(length);
 77343: 
 77343:     bool hole = false;
 91688:     for (uint32_t i = 0; i < length; i++) {
 77343:         obj->setDenseArrayElement(i, vector[i]);
 77343:         hole |= vector[i].isMagic(JS_ARRAY_HOLE);
 77343:     }
 77343:     if (hole)
 77343:         obj->markDenseArrayNotPacked(cx);
 77343: 
 48551:     return true;
     1: }
 79934: #endif
     1: 
     1: /*
     1:  * Perl-inspired join, reverse, and sort.
     1:  */
 20408: static JSBool
 91237: array_join(JSContext *cx, unsigned argc, Value *vp)
     1: {
 69228:     JS_CHECK_RECURSION(cx, return false);
 69228: 
 80814:     CallArgs args = CallArgsFromVp(argc, vp);
 99421:     RootedString str(cx);
 91388:     if (args.hasDefined(0)) {
 84160:         str = ToString(cx, args[0]);
     1:         if (!str)
     1:             return JS_FALSE;
 80814:         args[0].setString(str);
 91388:     } else {
 91388:         str = NULL;
 80814:     }
 99421:     RootedObject obj(cx, ToObject(cx, &args.thisv()));
 61734:     if (!obj)
 61734:         return false;
 80814:     return array_toString_sub(cx, obj, JS_FALSE, str, args);
     1: }
     1: 
     1: static JSBool
 91237: array_reverse(JSContext *cx, unsigned argc, Value *vp)
     1: {
 80814:     CallArgs args = CallArgsFromVp(argc, vp);
 99421:     RootedObject obj(cx, ToObject(cx, &args.thisv()));
 61734:     if (!obj)
 61734:         return false;
 61734: 
 91688:     uint32_t len;
 61734:     if (!js_GetLengthProperty(cx, obj, &len))
 61734:         return false;
 28242: 
 58702:     do {
 58702:         if (!obj->isDenseArray())
 58702:             break;
 58702:         if (js_PrototypeHasIndexedProperties(cx, obj))
 58702:             break;
 58702: 
 28242:         /* An empty array or an array with no elements is already reversed. */
 80814:         if (len == 0 || obj->getDenseArrayCapacity() == 0) {
 80814:             args.rval().setObject(*obj);
 61734:             return true;
 80814:         }
 28242: 
 28242:         /*
 28242:          * It's actually surprisingly complicated to reverse an array due to the
 28242:          * orthogonality of array length and array capacity while handling
 28242:          * leading and trailing holes correctly.  Reversing seems less likely to
 28242:          * be a common operation than other array mass-mutation methods, so for
 28242:          * now just take a probably-small memory hit (in the absence of too many
 28242:          * holes in the array at its start) and ensure that the capacity is
 28242:          * sufficient to hold all the elements in the array if it were full.
 28242:          */
 58702:         JSObject::EnsureDenseResult result = obj->ensureDenseArrayElements(cx, len, 0);
 58702:         if (result != JSObject::ED_OK) {
 58702:             if (result == JSObject::ED_FAILED)
 58702:                 return false;
 58702:             JS_ASSERT(result == JSObject::ED_SPARSE);
 58702:             break;
 58702:         }
 28242: 
 77343:         /* Fill out the array's initialized length to its proper length. */
 77343:         obj->ensureDenseArrayInitializedLength(cx, len, 0);
 77343: 
 84755:         uint32_t lo = 0, hi = len - 1;
 28242:         for (; lo < hi; lo++, hi--) {
 61434:             Value origlo = obj->getDenseArrayElement(lo);
 61434:             Value orighi = obj->getDenseArrayElement(hi);
 61434:             obj->setDenseArrayElement(lo, orighi);
 61434:             if (orighi.isMagic(JS_ARRAY_HOLE) &&
 61434:                 !js_SuppressDeletedProperty(cx, obj, INT_TO_JSID(lo))) {
 61434:                 return false;
 61434:             }
 61434:             obj->setDenseArrayElement(hi, origlo);
 61434:             if (origlo.isMagic(JS_ARRAY_HOLE) &&
 61434:                 !js_SuppressDeletedProperty(cx, obj, INT_TO_JSID(hi))) {
 61434:                 return false;
 61434:             }
 28242:         }
 28242: 
 28242:         /*
 28242:          * Per ECMA-262, don't update the length of the array, even if the new
 28242:          * array has trailing holes (and thus the original array began with
 28242:          * holes).
 28242:          */
 80814:         args.rval().setObject(*obj);
 61434:         return true;
 58702:     } while (false);
     1: 
 80814:     Value lowval, hival;
 91688:     for (uint32_t i = 0, half = len / 2; i < half; i++) {
 33178:         JSBool hole, hole2;
 33178:         if (!JS_CHECK_OPERATION_LIMIT(cx) ||
 80814:             !GetElement(cx, obj, i, &hole, &lowval) ||
 80814:             !GetElement(cx, obj, len - i - 1, &hole2, &hival) ||
 80814:             !SetOrDeleteArrayElement(cx, obj, len - i - 1, hole, lowval) ||
 80814:             !SetOrDeleteArrayElement(cx, obj, i, hole2, hival)) {
 33178:             return false;
 33178:         }
 33178:     }
 80814:     args.rval().setObject(*obj);
 33178:     return true;
     1: }
     1: 
 82461: namespace {
 82461: 
 82461: inline bool
 82461: CompareStringValues(JSContext *cx, const Value &a, const Value &b, bool *lessOrEqualp)
     1: {
 82461:     if (!JS_CHECK_OPERATION_LIMIT(cx))
 82461:         return false;
 82461: 
 82461:     JSString *astr = a.toString();
 82461:     JSString *bstr = b.toString();
 84755:     int32_t result;
 82461:     if (!CompareStrings(cx, astr, bstr, &result))
 82461:         return false;
 82461: 
 82461:     *lessOrEqualp = (result <= 0);
 82461:     return true;
 82461: }
 82461: 
 97663: static uint64_t const powersOf10[] = {
 97663:     1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 1000000000000ULL
 87971: };
 87971: 
 88443: static inline unsigned
 88443: NumDigitsBase10(uint32_t n)
 87971: {
 87971:     /*
 87971:      * This is just floor_log10(n) + 1
 87971:      * Algorithm taken from
 87971:      * http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog10
 87971:      */
 88443:     uint32_t log2, t;
 87971:     JS_CEILING_LOG2(log2, n);
 87971:     t = log2 * 1233 >> 12;
 88443:     return t - (n < powersOf10[t]) + 1;
 88443: }
 88443: 
 88443: static JS_ALWAYS_INLINE uint32_t
 88443: NegateNegativeInt32(int32_t i)
 88443: {
 88443:     /*
 88443:      * We cannot simply return '-i' because this is undefined for INT32_MIN.
 88443:      * 2s complement does actually give us what we want, however.  That is,
 88443:      * ~0x80000000 + 1 = 0x80000000 which is correct when interpreted as a
 88443:      * uint32_t. To avoid undefined behavior, we write out 2s complement
 88443:      * explicitly and rely on the peephole optimizer to generate 'neg'.
 88443:      */
 88443:     return ~uint32_t(i) + 1;
 87971: }
 87971: 
 87971: inline bool
 87971: CompareLexicographicInt32(JSContext *cx, const Value &a, const Value &b, bool *lessOrEqualp)
 87971: {
 87971:     int32_t aint = a.toInt32();
 87971:     int32_t bint = b.toInt32();
 87971: 
 87971:     /*
 87971:      * If both numbers are equal ... trivial
 87971:      * If only one of both is negative --> arithmetic comparison as char code
 87971:      * of '-' is always less than any other digit
 87971:      * If both numbers are negative convert them to positive and continue
 87971:      * handling ...
 87971:      */
 87971:     if (aint == bint) {
 87971:         *lessOrEqualp = true;
 87971:     } else if ((aint < 0) && (bint >= 0)) {
 87971:         *lessOrEqualp = true;
 87971:     } else if ((aint >= 0) && (bint < 0)) {
 87971:         *lessOrEqualp = false;
 87971:     } else {
 88443:         uint32_t auint, buint;
 88443:         if (aint >= 0) {
 88443:             auint = aint;
 88443:             buint = bint;
 88443:         } else {
 88443:             auint = NegateNegativeInt32(aint);
 88443:             buint = NegateNegativeInt32(bint);
 87971:         }
 87971: 
 87971:         /*
 87971:          *  ... get number of digits of both integers.
 87971:          * If they have the same number of digits --> arithmetic comparison.
 87971:          * If digits_a > digits_b: a < b*10e(digits_a - digits_b).
 87971:          * If digits_b > digits_a: a*10e(digits_b - digits_a) <= b.
 87971:          */
 88443:         unsigned digitsa = NumDigitsBase10(auint);
 88443:         unsigned digitsb = NumDigitsBase10(buint);
 97663:         if (digitsa == digitsb) {
 88443:             *lessOrEqualp = (auint <= buint);
 97663:         } else if (digitsa > digitsb) {
 97663:             JS_ASSERT((digitsa - digitsb) < ArrayLength(powersOf10));
 88443:             *lessOrEqualp = (uint64_t(auint) < uint64_t(buint) * powersOf10[digitsa - digitsb]);
 97663:         } else { /* if (digitsb > digitsa) */
 97663:             JS_ASSERT((digitsb - digitsa) < ArrayLength(powersOf10));
 88443:             *lessOrEqualp = (uint64_t(auint) * powersOf10[digitsb - digitsa] <= uint64_t(buint));
 87971:         }
 97663:     }
 87971: 
 87971:     return true;
 87971: }
 87971: 
 87971: inline bool
 87971: CompareSubStringValues(JSContext *cx, const jschar *s1, size_t l1,
 87971:                        const jschar *s2, size_t l2, bool *lessOrEqualp)
 87971: {
 87971:     if (!JS_CHECK_OPERATION_LIMIT(cx))
 87971:         return false;
 87971: 
 87971:     int32_t result;
 87971:     if (!s1 || !s2 || !CompareChars(s1, l1, s2, l2, &result))
 87971:         return false;
 87971: 
 87971:     *lessOrEqualp = (result <= 0);
 87971:     return true;
 87971: }
 87971: 
 87971: struct SortComparatorStrings
 87971: {
 82461:     JSContext   *const cx;
 82461: 
 82461:     SortComparatorStrings(JSContext *cx)
 82461:       : cx(cx) {}
 82461: 
 82461:     bool operator()(const Value &a, const Value &b, bool *lessOrEqualp) {
 82461:         return CompareStringValues(cx, a, b, lessOrEqualp);
 82461:     }
 82461: };
 82461: 
 87971: struct SortComparatorLexicographicInt32
 87971: {
 87971:     JSContext   *const cx;
 87971: 
 87971:     SortComparatorLexicographicInt32(JSContext *cx)
 87971:       : cx(cx) {}
 87971: 
 87971:     bool operator()(const Value &a, const Value &b, bool *lessOrEqualp) {
 87971:         return CompareLexicographicInt32(cx, a, b, lessOrEqualp);
 87971:     }
 82461: };
 82461: 
 87971: struct StringifiedElement
 87971: {
 87971:     size_t charsBegin;
 87971:     size_t charsEnd;
 87971:     size_t elementIndex;
 87971: };
 87971: 
 87971: struct SortComparatorStringifiedElements
 87971: {
 82461:     JSContext           *const cx;
 87971:     const StringBuffer  &sb;
 87971: 
 87971:     SortComparatorStringifiedElements(JSContext *cx, const StringBuffer &sb)
 87971:       : cx(cx), sb(sb) {}
 87971: 
 87971:     bool operator()(const StringifiedElement &a, const StringifiedElement &b, bool *lessOrEqualp) {
 87971:         return CompareSubStringValues(cx, sb.begin() + a.charsBegin, a.charsEnd - a.charsBegin,
 87971:                                       sb.begin() + b.charsBegin, b.charsEnd - b.charsBegin,
 87971:                                       lessOrEqualp);
 82461:     }
 82461: };
 82461: 
 87971: struct SortComparatorFunction
 87971: {
 82461:     JSContext          *const cx;
 82461:     const Value        &fval;
 82461:     InvokeArgsGuard    &ag;
 82461: 
 82461:     SortComparatorFunction(JSContext *cx, const Value &fval, InvokeArgsGuard &ag)
 82461:       : cx(cx), fval(fval), ag(ag) { }
 82461: 
 86484:     bool operator()(const Value &a, const Value &b, bool *lessOrEqualp);
 82461: };
 82461: 
 82460: bool
 82461: SortComparatorFunction::operator()(const Value &a, const Value &b, bool *lessOrEqualp)
 82460: {
 42714:     /*
     1:      * array_sort deals with holes and undefs on its own and they should not
     1:      * come here.
     1:      */
 82461:     JS_ASSERT(!a.isMagic() && !a.isUndefined());
 82461:     JS_ASSERT(!a.isMagic() && !b.isUndefined());
     1: 
 25087:     if (!JS_CHECK_OPERATION_LIMIT(cx))
 82461:         return false;
 82461: 
 80814:     if (!ag.pushed() && !cx->stack.pushInvokeArgs(cx, 2, &ag))
 82461:         return false;
 82461: 
 82461:     ag.setCallee(fval);
 80814:     ag.thisv() = UndefinedValue();
 82461:     ag[0] = a;
 82461:     ag[1] = b;
 80814: 
 80814:     if (!Invoke(cx, ag))
 82461:         return false;
 77917: 
 90955:     double cmp;
 80814:     if (!ToNumber(cx, ag.rval(), &cmp))
 82461:         return false;
  8439: 
     1:     /*
 82461:      * XXX eport some kind of error here if cmp is NaN? ECMA talks about
 82461:      * 'consistent compare functions' that don't return NaN, but is silent
 82461:      * about what the result should be. So we currently ignore it.
     1:      */
 95341:     *lessOrEqualp = (MOZ_DOUBLE_IS_NaN(cmp) || cmp <= 0);
 82461:     return true;
 82461: }
 82461: 
 82461: } /* namespace anonymous */
     1: 
 48676: JSBool
 91237: js::array_sort(JSContext *cx, unsigned argc, Value *vp)
     1: {
 80814:     CallArgs args = CallArgsFromVp(argc, vp);
 99364: 
 99421:     RootedValue fvalRoot(cx);
 99364:     Value &fval = fvalRoot.reference();
 99364: 
 91388:     if (args.hasDefined(0)) {
 80814:         if (args[0].isPrimitive()) {
 40390:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_SORT_ARG);
 40390:             return false;
     1:         }
 80814:         fval = args[0];     /* non-default compare function */
     1:     } else {
 48470:         fval.setNull();
     1:     }
     1: 
 99421:     RootedObject obj(cx, ToObject(cx, &args.thisv()));
 61734:     if (!obj)
 61734:         return false;
 82461: 
 91688:     uint32_t len;
 61734:     if (!js_GetLengthProperty(cx, obj, &len))
 40390:         return false;
     1:     if (len == 0) {
 80814:         args.rval().setObject(*obj);
 40390:         return true;
     1:     }
     1: 
     1:     /*
 48470:      * We need a temporary array of 2 * len Value to hold the array elements
  9015:      * and the scratch space for merge sort. Check that its size does not
  9015:      * overflow size_t, which would allow for indexing beyond the end of the
  9015:      * malloc'd vector.
     1:      */
  9975: #if JS_BITS_PER_WORD == 32
 48470:     if (size_t(len) > size_t(-1) / (2 * sizeof(Value))) {
 12983:         js_ReportAllocationOverflow(cx);
 40390:         return false;
     1:     }
  9975: #endif
     1: 
     1:     /*
     1:      * Initialize vec as a root. We will clear elements of vec one by
 40390:      * one while increasing the rooted amount of vec when we know that the
 40390:      * property at the corresponding index exists and its value must be rooted.
     1:      *
     1:      * In this way when sorting a huge mostly sparse array we will not
     1:      * access the tail of vec corresponding to properties that do not
     1:      * exist, allowing OS to avoiding committing RAM. See bug 330812.
     1:      */
 82461:     size_t n, undefs;
 40390:     {
 82461:         AutoValueVector vec(cx);
 82461:         if (!vec.reserve(2 * size_t(len)))
 40390:             return false;
 40390: 
     1:         /*
     1:          * By ECMA 262, 15.4.4.11, a property that does not exist (which we
     1:          * call a "hole") is always greater than an existing property with
     1:          * value undefined and that is always greater than any other property.
     1:          * Thus to sort holes and undefs we simply count them, sort the rest
     1:          * of elements, append undefs after them and then make holes after
     1:          * undefs.
     1:          */
     1:         undefs = 0;
 40390:         bool allStrings = true;
 87971:         bool allInts = true;
 91688:         for (uint32_t i = 0; i < len; i++) {
 40390:             if (!JS_CHECK_OPERATION_LIMIT(cx))
 40390:                 return false;
     1: 
     1:             /* Clear vec[newlen] before including it in the rooted set. */
 40390:             JSBool hole;
 82461:             Value v;
 82461:             if (!GetElement(cx, obj, i, &hole, &v))
 40390:                 return false;
     1:             if (hole)
     1:                 continue;
 82461:             if (v.isUndefined()) {
     1:                 ++undefs;
     1:                 continue;
     1:             }
 82461:             vec.infallibleAppend(v);
 82461:             allStrings = allStrings && v.isString();
 87971:             allInts = allInts && v.isInt32();
 82461:         }
 82461: 
 82461:         n = vec.length();
 82461:         if (n == 0) {
 80814:             args.rval().setObject(*obj);
 40390:             return true; /* The array has only holes and undefs. */
 58691:         }
  9015: 
 82461:         JS_ALWAYS_TRUE(vec.resize(n * 2));
 82461: 
 82461:         /* Here len == n + undefs + number_of_holes. */
 87971:         Value *result = vec.begin();
 48470:         if (fval.isNull()) {
  9015:             /*
  9015:              * Sort using the default comparator converting all elements to
  9015:              * strings.
  9015:              */
 40390:             if (allStrings) {
 82461:                 if (!MergeSort(vec.begin(), n, vec.begin() + n, SortComparatorStrings(cx)))
 82461:                     return false;
 87971:             } else if (allInts) {
 87971:                 if (!MergeSort(vec.begin(), n, vec.begin() + n,
 87971:                                SortComparatorLexicographicInt32(cx))) {
 87971:                     return false;
 87971:                 }
  9015:             } else {
  9015:                 /*
 87971:                  * Convert all elements to a jschar array in StringBuffer.
 87971:                  * Store the index and length of each stringified element with
 87971:                  * the corresponding index of the element in the array. Sort
 87971:                  * the stringified elements and with this result order the
 87971:                  * original array.
  9015:                  */
 87971:                 StringBuffer sb(cx);
 87971:                 Vector<StringifiedElement, 0, TempAllocPolicy> strElements(cx);
 87971:                 if (!strElements.reserve(2 * n))
 87971:                     return false;
 87971: 
102386:                 size_t cursor = 0;
 87971:                 for (size_t i = 0; i < n; i++) {
 40390:                     if (!JS_CHECK_OPERATION_LIMIT(cx))
 40390:                         return false;
 87971: 
 87971:                     if (!ValueToStringBuffer(cx, vec[i], sb))
 40390:                         return false;
 82461: 
 87971:                     StringifiedElement el = { cursor, sb.length(), i };
 87971:                     strElements.infallibleAppend(el);
 87971:                     cursor = sb.length();
 87971:                 }
 87971: 
 87971:                 /* Resize strElements so we can perform the sorting */
 87971:                 JS_ALWAYS_TRUE(strElements.resize(2 * n));
 87971: 
 87971:                 if (!MergeSort(strElements.begin(), n, strElements.begin() + n,
 87971:                                SortComparatorStringifiedElements(cx, sb))) {
 40390:                     return false;
 87971:                 }
 87971: 
 87971:                 /* Order vec[n:2n-1] using strElements.index */
 87971:                 for (size_t i = 0; i < n; i ++)
 87971:                     vec[n + i] = vec[strElements[i].elementIndex];
 87971: 
 87971:                 result = vec.begin() + n;
  9015:             }
     1:         } else {
 82461:             InvokeArgsGuard args;
 82461:             if (!MergeSort(vec.begin(), n, vec.begin() + n,
 87971:                            SortComparatorFunction(cx, fval, args))) {
 40390:                 return false;
  9015:             }
 42714:         }
     1: 
 91688:         if (!InitArrayElements(cx, obj, 0, uint32_t(n), result, DontUpdateTypes))
 40390:             return false;
 40390:     }
     1: 
     1:     /* Set undefs that sorted after the rest of elements. */
     1:     while (undefs != 0) {
     1:         --undefs;
 82461:         if (!JS_CHECK_OPERATION_LIMIT(cx) || !SetArrayElement(cx, obj, n++, UndefinedValue()))
 40390:             return false;
     1:     }
     1: 
     1:     /* Re-create any holes that sorted to the end of the array. */
 82461:     while (len > n) {
 62396:         if (!JS_CHECK_OPERATION_LIMIT(cx) || DeleteArrayElement(cx, obj, --len, true) < 0)
 54169:             return false;
     1:     }
 80814:     args.rval().setObject(*obj);
 40390:     return true;
     1: }
     1: 
     1: /*
     1:  * Perl-inspired push, pop, shift, unshift, and splice methods.
     1:  */
 80814: static bool
 95355: array_push_slowly(JSContext *cx, HandleObject obj, CallArgs &args)
     1: {
 91688:     uint32_t length;
     1: 
     1:     if (!js_GetLengthProperty(cx, obj, &length))
 80814:         return false;
 82640:     if (!InitArrayElements(cx, obj, length, args.length(), args.array(), UpdateTypes))
 80814:         return false;
     1: 
     1:     /* Per ECMA-262, return the new array length. */
 90955:     double newlength = length + double(args.length());
 80814:     args.rval().setNumber(newlength);
     1:     return js_SetLengthProperty(cx, obj, newlength);
     1: }
     1: 
 80814: static bool
 95355: array_push1_dense(JSContext* cx, HandleObject obj, CallArgs &args)
 19571: {
 80814:     JS_ASSERT(args.length() == 1);
 80814: 
 84755:     uint32_t length = obj->getArrayLength();
 58702:     JSObject::EnsureDenseResult result = obj->ensureDenseArrayElements(cx, length, 1);
 58702:     if (result != JSObject::ED_OK) {
 58702:         if (result == JSObject::ED_FAILED)
 58702:             return false;
 58702:         JS_ASSERT(result == JSObject::ED_SPARSE);
 95355:         if (!JSObject::makeDenseArraySlow(cx, obj))
 58702:             return false;
 80814:         return array_push_slowly(cx, obj, args);
 80814:     }
 80814: 
 80814:     obj->setDenseArrayLength(length + 1);
 80814:     obj->setDenseArrayElementWithType(cx, length, args[0]);
 80814:     args.rval().setNumber(obj->getArrayLength());
 80814:     return true;
 19571: }
 19571: 
 48470: JS_ALWAYS_INLINE JSBool
 98960: NewbornArrayPushImpl(JSContext *cx, HandleObject obj, const Value &v)
 24861: {
 73079:     JS_ASSERT(!v.isMagic());
 73079: 
 84755:     uint32_t length = obj->getArrayLength();
 62932:     if (obj->isSlowArray()) {
 62932:         /* This can happen in one evil case. See bug 630377. */
 99421:         RootedId id(cx);
 98960:         return IndexToId(cx, length, id.address()) &&
102586:                baseops::DefineGeneric(cx, obj, id, &v, NULL, NULL, JSPROP_ENUMERATE);
 62932:     }
 62932: 
 39928:     JS_ASSERT(obj->isDenseArray());
 41782:     JS_ASSERT(length <= obj->getDenseArrayCapacity());
 41782: 
 83231:     if (!obj->ensureElements(cx, length + 1))
 62932:         return false;
 73079: 
 77343:     obj->setDenseArrayInitializedLength(length + 1);
 77343:     obj->setDenseArrayLength(length + 1);
 82129:     obj->initDenseArrayElementWithType(cx, length, v);
 62932:     return true;
 24861: }
 48470: 
 48470: JSBool
 98960: js_NewbornArrayPush(JSContext *cx, HandleObject obj, const Value &vp)
 48470: {
 73079:     return NewbornArrayPushImpl(cx, obj, vp);
 48470: }
 48470: 
 77343: JSBool
 91237: js::array_push(JSContext *cx, unsigned argc, Value *vp)
     1: {
 80814:     CallArgs args = CallArgsFromVp(argc, vp);
 99421:     RootedObject obj(cx, ToObject(cx, &args.thisv()));
 61734:     if (!obj)
 61734:         return false;
 61734: 
  4127:     /* Insist on one argument and obj of the expected class. */
 80814:     if (args.length() != 1 || !obj->isDenseArray())
 80814:         return array_push_slowly(cx, obj, args);
 80814: 
 80814:     return array_push1_dense(cx, obj, args);
  4127: }
 11835: 
 20408: static JSBool
 95355: array_pop_slowly(JSContext *cx, HandleObject obj, CallArgs &args)
  4127: {
 91688:     uint32_t index;
 80814:     if (!js_GetLengthProperty(cx, obj, &index))
 80814:         return false;
 80814: 
 80814:     if (index == 0) {
 80814:         args.rval().setUndefined();
 80814:         return js_SetLengthProperty(cx, obj, index);
 80814:     }
 80814: 
 80814:     index--;
 80814: 
     1:     JSBool hole;
 99421:     RootedValue elt(cx);
 97353:     if (!GetElement(cx, obj, index, &hole, elt.address()))
 80814:         return false;
 80814: 
 80814:     if (!hole && DeleteArrayElement(cx, obj, index, true) < 0)
 80814:         return false;
 80814: 
 80814:     args.rval() = elt;
 80814:     return js_SetLengthProperty(cx, obj, index);
 80814: }
 80814: 
 80814: static JSBool
 95355: array_pop_dense(JSContext *cx, HandleObject obj, CallArgs &args)
 80814: {
 91688:     uint32_t index = obj->getArrayLength();
 80814:     if (index == 0) {
 80814:         args.rval().setUndefined();
101804:         return true;
 80814:     }
 80814: 
 80814:     index--;
 80814: 
 80814:     JSBool hole;
 99421:     RootedValue elt(cx);
 97353:     if (!GetElement(cx, obj, index, &hole, elt.address()))
101804:         return false;
 80814: 
 62396:     if (!hole && DeleteArrayElement(cx, obj, index, true) < 0)
101804:         return false;
101804: 
101804:     args.rval() = elt;
101804:     
101804:     // obj may not be a dense array any more, e.g. if the element was a missing
101804:     // and a getter supplied by the prototype modified the object.
101804:     if (obj->isDenseArray()) {
 83231:         if (obj->getDenseArrayInitializedLength() > index)
 77343:             obj->setDenseArrayInitializedLength(index);
 80814: 
 77343:         obj->setArrayLength(cx, index);
101804:         return true;
101804:     }
101804:     
101804:     return js_SetLengthProperty(cx, obj, index);
 11835: }
 11835: 
 77343: JSBool
 91237: js::array_pop(JSContext *cx, unsigned argc, Value *vp)
 19571: {
 80814:     CallArgs args = CallArgsFromVp(argc, vp);
 99421:     RootedObject obj(cx, ToObject(cx, &args.thisv()));
 19571:     if (!obj)
 61734:         return false;
 39928:     if (obj->isDenseArray())
 80814:         return array_pop_dense(cx, obj, args);
 80814:     return array_pop_slowly(cx, obj, args);
     1: }
     1: 
 80556: #ifdef JS_METHODJIT
 80569: void JS_FASTCALL
 80556: mjit::stubs::ArrayShift(VMFrame &f)
 80556: {
 80556:     JSObject *obj = &f.regs.sp[-1].toObject();
 80556:     JS_ASSERT(obj->isDenseArray());
 80556: 
 80556:     /*
 80556:      * At this point the length and initialized length have already been
 80556:      * decremented and the result fetched, so just shift the array elements
 80556:      * themselves.
 80556:      */
 84755:     uint32_t initlen = obj->getDenseArrayInitializedLength();
 88614:     obj->moveDenseArrayElementsUnbarriered(0, 1, initlen);
 80556: }
 80556: #endif /* JS_METHODJIT */
 80556: 
 80556: JSBool
 91237: js::array_shift(JSContext *cx, unsigned argc, Value *vp)
     1: {
 80814:     CallArgs args = CallArgsFromVp(argc, vp);
 99421:     RootedObject obj(cx, ToObject(cx, &args.thisv()));
 61734:     if (!obj)
 61734:         return JS_FALSE;
 61734: 
 91688:     uint32_t length;
 61734:     if (!js_GetLengthProperty(cx, obj, &length))
     1:         return JS_FALSE;
 40868: 
     1:     if (length == 0) {
 80814:         args.rval().setUndefined();
     1:     } else {
     1:         length--;
     1: 
 39928:         if (obj->isDenseArray() && !js_PrototypeHasIndexedProperties(cx, obj) &&
 77343:             length < obj->getDenseArrayCapacity() &&
 77343:             0 < obj->getDenseArrayInitializedLength()) {
 80814:             args.rval() = obj->getDenseArrayElement(0);
 80814:             if (args.rval().isMagic(JS_ARRAY_HOLE))
 80814:                 args.rval().setUndefined();
 88614:             obj->moveDenseArrayElements(0, 1, obj->getDenseArrayInitializedLength() - 1);
 77343:             obj->setDenseArrayInitializedLength(obj->getDenseArrayInitializedLength() - 1);
 77343:             obj->setArrayLength(cx, length);
 61434:             if (!js_SuppressDeletedProperty(cx, obj, INT_TO_JSID(length)))
 61434:                 return JS_FALSE;
 40868:             return JS_TRUE;
 40868:         }
 40868: 
 61734:         JSBool hole;
 81416:         if (!GetElement(cx, obj, 0u, &hole, &args.rval()))
     1:             return JS_FALSE;
     1: 
  6917:         /* Slide down the array above the first element. */
 99421:         RootedValue value(cx);
 91688:         for (uint32_t i = 0; i < length; i++) {
 28242:             if (!JS_CHECK_OPERATION_LIMIT(cx) ||
 97353:                 !GetElement(cx, obj, i + 1, &hole, value.address()) ||
 97353:                 !SetOrDeleteArrayElement(cx, obj, i, hole, value)) {
     1:                 return JS_FALSE;
 28242:             }
 28242:         }
 28242: 
 28242:         /* Delete the only or last element when it exists. */
 62396:         if (!hole && DeleteArrayElement(cx, obj, length, true) < 0)
     1:             return JS_FALSE;
     1:     }
     1:     return js_SetLengthProperty(cx, obj, length);
     1: }
     1: 
     1: static JSBool
 91237: array_unshift(JSContext *cx, unsigned argc, Value *vp)
     1: {
 80814:     CallArgs args = CallArgsFromVp(argc, vp);
 99421:     RootedObject obj(cx, ToObject(cx, &args.thisv()));
 61734:     if (!obj)
 61734:         return false;
 61734: 
 91688:     uint32_t length;
 61734:     if (!js_GetLengthProperty(cx, obj, &length))
     1:         return JS_FALSE;
 77343: 
 90955:     double newlen = length;
 80814:     if (args.length() > 0) {
 80814:         /* Slide up the array to make room for all args at the bottom. */
     1:         if (length > 0) {
 58702:             bool optimized = false;
 58702:             do {
 58702:                 if (!obj->isDenseArray())
 58702:                     break;
 58702:                 if (js_PrototypeHasIndexedProperties(cx, obj))
 58702:                     break;
 80814:                 JSObject::EnsureDenseResult result = obj->ensureDenseArrayElements(cx, length, args.length());
 58702:                 if (result != JSObject::ED_OK) {
 58702:                     if (result == JSObject::ED_FAILED)
 58702:                         return false;
 58702:                     JS_ASSERT(result == JSObject::ED_SPARSE);
 58702:                     break;
 58702:                 }
 80814:                 obj->moveDenseArrayElements(args.length(), 0, length);
 84755:                 for (uint32_t i = 0; i < args.length(); i++)
 48470:                     obj->setDenseArrayElement(i, MagicValue(JS_ARRAY_HOLE));
 58702:                 optimized = true;
 58702:             } while (false);
 58702: 
 58702:             if (!optimized) {
 90955:                 double last = length;
 90955:                 double upperIndex = last + args.length();
 99421:                 RootedValue value(cx);
     1:                 do {
 28242:                     --last, --upperIndex;
 80814:                     JSBool hole;
 28242:                     if (!JS_CHECK_OPERATION_LIMIT(cx) ||
 97353:                         !GetElement(cx, obj, last, &hole, value.address()) ||
 97353:                         !SetOrDeleteArrayElement(cx, obj, upperIndex, hole, value)) {
 28242:                         return JS_FALSE;
 28242:                     }
  6917:                 } while (last != 0);
 28242:             }
     1:         }
     1: 
 80814:         /* Copy from args to the bottom of the array. */
 82640:         if (!InitArrayElements(cx, obj, 0, args.length(), args.array(), UpdateTypes))
     1:             return JS_FALSE;
     1: 
 80814:         newlen += args.length();
 58298:     }
 26564:     if (!js_SetLengthProperty(cx, obj, newlen))
     1:         return JS_FALSE;
     1: 
     1:     /* Follow Perl by returning the new array length. */
 80814:     args.rval().setNumber(newlen);
 48470:     return JS_TRUE;
     1: }
     1: 
 78457: static inline void
 78457: TryReuseArrayType(JSObject *obj, JSObject *nobj)
 78457: {
 78457:     /*
 78457:      * Try to change the type of a newly created array nobj to the same type
 78457:      * as obj. This can only be performed if the original object is an array
 78457:      * and has the same prototype.
 78457:      */
 78457:     JS_ASSERT(nobj->isDenseArray());
 83230:     JS_ASSERT(nobj->getProto()->hasNewType(nobj->type()));
 78457: 
 78457:     if (obj->isArray() && !obj->hasSingletonType() && obj->getProto() == nobj->getProto())
 78457:         nobj->setType(obj->type());
 78457: }
 78457: 
 79934: /*
 79934:  * Returns true if this is a dense array whose |count| properties starting from
 79934:  * |startingIndex| may be accessed (get, set, delete) directly through its
 79934:  * contiguous vector of elements without fear of getters, setters, etc. along
 80626:  * the prototype chain, or of enumerators requiring notification of
 80626:  * modifications.
 79934:  */
 79934: static inline bool
 84755: CanOptimizeForDenseStorage(JSObject *arr, uint32_t startingIndex, uint32_t count, JSContext *cx)
 79934: {
 80626:     /* If the desired properties overflow dense storage, we can't optimize. */
 80626:     if (UINT32_MAX - startingIndex < count)
 80626:         return false;
 80626: 
 80626:     /* There's no optimizing possible if it's not a dense array. */
 80626:     if (!arr->isDenseArray())
 80626:         return false;
 80626: 
 80626:     /*
 80626:      * Don't optimize if the array might be in the midst of iteration.  We
 80626:      * rely on this to be able to safely move dense array elements around with
 80626:      * just a memmove (see JSObject::moveDenseArrayElements), without worrying
 80626:      * about updating any in-progress enumerators for properties implicitly
 80626:      * deleted if a hole is moved from one location to another location not yet
 80626:      * visited.  See bug 690622.
 80626:      *
 80626:      * Another potential wrinkle: what if the enumeration is happening on an
 80626:      * object which merely has |arr| on its prototype chain?  It turns out this
 80626:      * case can't happen, because any dense array used as the prototype of
 80626:      * another object is first slowified, for type inference's sake.
 80626:      */
 80626:     if (JS_UNLIKELY(arr->getType(cx)->hasAllFlags(OBJECT_FLAG_ITERATED)))
 80626:         return false;
 80626: 
 80626:     /* Now just watch out for getters and setters along the prototype chain. */
 80626:     return !js_PrototypeHasIndexedProperties(cx, arr) &&
 80626:            startingIndex + count <= arr->getDenseArrayInitializedLength();
 79934: }
 79934: 
 79934: /* ES5 15.4.4.12. */
     1: static JSBool
 91237: array_splice(JSContext *cx, unsigned argc, Value *vp)
     1: {
 79934:     CallArgs args = CallArgsFromVp(argc, vp);
 79934: 
 79934:     /* Step 1. */
 99421:     RootedObject obj(cx, ToObject(cx, &args.thisv()));
 61734:     if (!obj)
 61734:         return false;
 61734: 
 79934:     /* Steps 3-4. */
 84755:     uint32_t len;
 79934:     if (!js_GetLengthProperty(cx, obj, &len))
 79934:         return false;
 79934: 
 79934:     /* Step 5. */
 79934:     double relativeStart;
 79934:     if (!ToInteger(cx, argc >= 1 ? args[0] : UndefinedValue(), &relativeStart))
 79934:         return false;
 79934: 
 79934:     /* Step 6. */
 84755:     uint32_t actualStart;
 79934:     if (relativeStart < 0)
 79934:         actualStart = JS_MAX(len + relativeStart, 0);
 79934:     else
 79934:         actualStart = JS_MIN(relativeStart, len);
 79934: 
 79934:     /* Step 7. */
 84755:     uint32_t actualDeleteCount;
 79934:     if (argc != 1) {
 90955:         double deleteCountDouble;
 79934:         if (!ToInteger(cx, argc >= 2 ? args[1] : Int32Value(0), &deleteCountDouble))
 79934:             return false;
 79934:         actualDeleteCount = JS_MIN(JS_MAX(deleteCountDouble, 0), len - actualStart);
 79934:     } else {
 79934:         /*
 79934:          * Non-standard: if start was specified but deleteCount was omitted,
 79934:          * delete to the end of the array.  See bug 668024 for discussion.
 79934:          */
 79934:         actualDeleteCount = len - actualStart;
 79934:     }
 79934: 
 79934:     JS_ASSERT(len - actualStart >= actualDeleteCount);
 79934: 
 79934:     /* Steps 2, 8-9. */
 99421:     RootedObject arr(cx);
 79934:     if (CanOptimizeForDenseStorage(obj, actualStart, actualDeleteCount, cx)) {
 79934:         arr = NewDenseCopiedArray(cx, actualDeleteCount,
 79934:                                   obj->getDenseArrayElements() + actualStart);
 79934:         if (!arr)
 79934:             return false;
 79934:         TryReuseArrayType(obj, arr);
 79934:     } else {
 79934:         arr = NewDenseAllocatedArray(cx, actualDeleteCount);
 79934:         if (!arr)
 79934:             return false;
 79934:         TryReuseArrayType(obj, arr);
 79934: 
 84755:         for (uint32_t k = 0; k < actualDeleteCount; k++) {
 28242:             JSBool hole;
 79934:             Value fromValue;
 79934:             if (!JS_CHECK_OPERATION_LIMIT(cx) ||
 79934:                 !GetElement(cx, obj, actualStart + k, &hole, &fromValue) ||
 79934:                 (!hole && !arr->defineElement(cx, k, fromValue)))
 79934:             {
 79934:                 return false;
 79934:             }
 79934:         }
 79934:     }
 79934: 
 79934:     /* Step 11. */
 84755:     uint32_t itemCount = (argc >= 2) ? (argc - 2) : 0;
 79934: 
 79934:     if (itemCount < actualDeleteCount) {
 79934:         /* Step 12: the array is being shrunk. */
 84755:         uint32_t sourceIndex = actualStart + actualDeleteCount;
 84755:         uint32_t targetIndex = actualStart + itemCount;
 84755:         uint32_t finalLength = len - actualDeleteCount + itemCount;
 79934: 
 79934:         if (CanOptimizeForDenseStorage(obj, 0, len, cx)) {
 79934:             /* Steps 12(a)-(b). */
 79934:             obj->moveDenseArrayElements(targetIndex, sourceIndex, len - sourceIndex);
 79934: 
 79934:             /*
 82129:              * Update the initialized length. Do so before shrinking so that we
 82129:              * can apply the write barrier to the old slots.
 79934:              */
 79934:             if (cx->typeInferenceEnabled())
 79934:                 obj->setDenseArrayInitializedLength(finalLength);
 79934: 
 82129:             /* Steps 12(c)-(d). */
 83301:             obj->shrinkElements(cx, finalLength);
 82129: 
 79934:             /* Fix running enumerators for the deleted items. */
 79934:             if (!js_SuppressDeletedElements(cx, obj, finalLength, len))
 79934:                 return false;
     1:         } else {
 79934:             /*
 79934:              * This is all very slow if the length is very large. We don't yet
 79934:              * have the ability to iterate in sorted order, so we just do the
 79934:              * pessimistic thing and let JS_CHECK_OPERATION_LIMIT handle the
 79934:              * fallout.
 79934:              */
 79934: 
 79934:             /* Steps 12(a)-(b). */
 84755:             for (uint32_t from = sourceIndex, to = targetIndex; from < len; from++, to++) {
 79934:                 JSBool hole;
 79934:                 Value fromValue;
 79934:                 if (!JS_CHECK_OPERATION_LIMIT(cx) ||
 79934:                     !GetElement(cx, obj, from, &hole, &fromValue) ||
 79934:                     !SetOrDeleteArrayElement(cx, obj, to, hole, fromValue))
 79934:                 {
 69230:                     return false;
 79934:                 }
 79934:             }
 79934: 
 79934:             /* Steps 12(c)-(d). */
 84755:             for (uint32_t k = len; k > finalLength; k--) {
 79934:                 if (DeleteArrayElement(cx, obj, k - 1, true) < 0)
 79934:                     return false;
 79934:             }
 79934:         }
 79934:     } else if (itemCount > actualDeleteCount) {
 79934:         /* Step 13. */
 79934: 
 79934:         /*
 79934:          * Optimize only if the array is already dense and we can extend it to
 79934:          * its new length.
 79934:          */
 79934:         if (obj->isDenseArray()) {
 79934:             JSObject::EnsureDenseResult res =
 79934:                 obj->ensureDenseArrayElements(cx, obj->getArrayLength(),
 79934:                                               itemCount - actualDeleteCount);
 79934:             if (res == JSObject::ED_FAILED)
 79934:                 return false;
 79934: 
 79934:             if (res == JSObject::ED_SPARSE) {
 95355:                 if (!JSObject::makeDenseArraySlow(cx, obj))
 79934:                     return false;
 28242:             } else {
 79934:                 JS_ASSERT(res == JSObject::ED_OK);
 79934:             }
 79934:         }
 79934: 
 79934:         if (CanOptimizeForDenseStorage(obj, len, itemCount - actualDeleteCount, cx)) {
 79934:             obj->moveDenseArrayElements(actualStart + itemCount,
 79934:                                         actualStart + actualDeleteCount,
 79934:                                         len - (actualStart + actualDeleteCount));
 79934: 
 79934:             if (cx->typeInferenceEnabled())
 79934:                 obj->setDenseArrayInitializedLength(len + itemCount - actualDeleteCount);
 79934:         } else {
 90955:             for (double k = len - actualDeleteCount; k > actualStart; k--) {
 90955:                 double from = k + actualDeleteCount - 1;
 90955:                 double to = k + itemCount - 1;
 79934: 
 79934:                 JSBool hole;
 79934:                 Value fromValue;
 28242:                 if (!JS_CHECK_OPERATION_LIMIT(cx) ||
 79934:                     !GetElement(cx, obj, from, &hole, &fromValue) ||
 79934:                     !SetOrDeleteArrayElement(cx, obj, to, hole, fromValue))
 79934:                 {
 58702:                     return false;
 79934:                 }
 79934:             }
 79934:         }
 79934:     }
 79934: 
 79934:     /* Step 10. */
 79934:     Value *items = args.array() + 2;
 79934: 
 79934:     /* Steps 14-15. */
 84755:     for (uint32_t k = actualStart, i = 0; i < itemCount; i++, k++) {
 79934:         if (!SetArrayElement(cx, obj, k, items[i]))
 79934:             return false;
 79934:     }
 79934: 
 79934:     /* Step 16. */
 90955:     double finalLength = double(len) - actualDeleteCount + itemCount;
 79934:     if (!js_SetLengthProperty(cx, obj, finalLength))
 79934:         return false;
 79934: 
 79934:     /* Step 17. */
 79934:     args.rval().setObject(*arr);
 79934:     return true;
     1: }
     1: 
 80557: #ifdef JS_METHODJIT
 80557: void JS_FASTCALL
 80557: mjit::stubs::ArrayConcatTwoArrays(VMFrame &f)
 80557: {
 80557:     JSObject *result = &f.regs.sp[-3].toObject();
 80557:     JSObject *obj1 = &f.regs.sp[-2].toObject();
 80557:     JSObject *obj2 = &f.regs.sp[-1].toObject();
 80557: 
 80557:     JS_ASSERT(result->isDenseArray() && obj1->isDenseArray() && obj2->isDenseArray());
 80557: 
 84755:     uint32_t initlen1 = obj1->getDenseArrayInitializedLength();
 80557:     JS_ASSERT(initlen1 == obj1->getArrayLength());
 80557: 
 84755:     uint32_t initlen2 = obj2->getDenseArrayInitializedLength();
 80557:     JS_ASSERT(initlen2 == obj2->getArrayLength());
 80557: 
 80557:     /* No overflow here due to nslots limit. */
 84755:     uint32_t len = initlen1 + initlen2;
 80557: 
 83252:     if (!result->ensureElements(f.cx, len))
 80557:         THROW();
 80557: 
 82129:     JS_ASSERT(!result->getDenseArrayInitializedLength());
 80557:     result->setDenseArrayInitializedLength(len);
 82129: 
 82129:     result->initDenseArrayElements(0, obj1->getDenseArrayElements(), initlen1);
 82129:     result->initDenseArrayElements(initlen1, obj2->getDenseArrayElements(), initlen2);
 82129: 
 80557:     result->setDenseArrayLength(len);
 80557: }
 80557: #endif /* JS_METHODJIT */
 80557: 
     1: /*
     1:  * Python-esque sequence operations.
     1:  */
 80557: JSBool
 91237: js::array_concat(JSContext *cx, unsigned argc, Value *vp)
     1: {
  4127:     /* Treat our |this| object as the first argument; see ECMA 15.4.4.4. */
 48470:     Value *p = JS_ARGV(cx, vp) - 1;
     1: 
  4127:     /* Create a new Array object and root it using *vp. */
 99421:     RootedObject aobj(cx, ToObject(cx, &vp[1]));
 61734:     if (!aobj)
 61734:         return false;
 61734: 
 99421:     RootedObject nobj(cx);
 91688:     uint32_t length;
 39928:     if (aobj->isDenseArray()) {
 40796:         length = aobj->getArrayLength();
 77394:         const Value *vector = aobj->getDenseArrayElements();
 91688:         uint32_t initlen = aobj->getDenseArrayInitializedLength();
 77343:         nobj = NewDenseCopiedArray(cx, initlen, vector);
 11835:         if (!nobj)
 11835:             return JS_FALSE;
 78457:         TryReuseArrayType(aobj, nobj);
 77343:         nobj->setArrayLength(cx, length);
 48470:         vp->setObject(*nobj);
 11835:         if (argc == 0)
 11835:             return JS_TRUE;
 11835:         argc--;
 48470:         p++;
 11835:     } else {
 59234:         nobj = NewDenseEmptyArray(cx);
     1:         if (!nobj)
     1:             return JS_FALSE;
 48470:         vp->setObject(*nobj);
 11835:         length = 0;
 11835:     }
     1: 
     1:     /* Loop over [0, argc] to concat args into nobj, expanding all Arrays. */
 91237:     for (unsigned i = 0; i <= argc; i++) {
 33178:         if (!JS_CHECK_OPERATION_LIMIT(cx))
 33178:             return false;
 48470:         const Value &v = p[i];
 48470:         if (v.isObject()) {
 99421:             RootedObject obj(cx, &v.toObject());
 97353:             if (ObjectClassIs(*obj, ESClass_Array, cx)) {
 91688:                 uint32_t alength;
 97353:                 if (!js_GetLengthProperty(cx, obj, &alength))
 33178:                     return false;
 84755:                 for (uint32_t slot = 0; slot < alength; slot++) {
 73080:                     JSBool hole;
 73080:                     Value tmp;
 97353:                     if (!JS_CHECK_OPERATION_LIMIT(cx) || !GetElement(cx, obj, slot, &hole, &tmp))
 33178:                         return false;
     1: 
     1:                     /*
 42587:                      * Per ECMA 262, 15.4.4.4, step 9, ignore nonexistent
     1:                      * properties.
     1:                      */
 73080:                     if (!hole && !SetArrayElement(cx, nobj, length + slot, tmp))
 33178:                         return false;
     1:                 }
     1:                 length += alength;
     1:                 continue;
     1:             }
     1:         }
     1: 
 33178:         if (!SetArrayElement(cx, nobj, length, v))
 33178:             return false;
     1:         length++;
     1:     }
     1: 
 33178:     return js_SetLengthProperty(cx, nobj, length);
     1: }
     1: 
     1: static JSBool
 91237: array_slice(JSContext *cx, unsigned argc, Value *vp)
     1: {
 91688:     uint32_t length, begin, end, slot;
 28242:     JSBool hole;
     1: 
 80814:     CallArgs args = CallArgsFromVp(argc, vp);
 80814: 
 99421:     RootedObject obj(cx, ToObject(cx, &args.thisv()));
 61734:     if (!obj)
 61734:         return false;
 61734: 
 61734:     if (!js_GetLengthProperty(cx, obj, &length))
     1:         return JS_FALSE;
     1:     begin = 0;
     1:     end = length;
     1: 
 80814:     if (args.length() > 0) {
 90955:         double d;
 80814:         if (!ToInteger(cx, args[0], &d))
 69230:             return false;
     1:         if (d < 0) {
     1:             d += length;
     1:             if (d < 0)
     1:                 d = 0;
     1:         } else if (d > length) {
     1:             d = length;
     1:         }
 91688:         begin = (uint32_t)d;
     1: 
 91388:         if (args.hasDefined(1)) {
 80814:             if (!ToInteger(cx, args[1], &d))
 69230:                 return false;
     1:             if (d < 0) {
     1:                 d += length;
     1:                 if (d < 0)
     1:                     d = 0;
     1:             } else if (d > length) {
     1:                 d = length;
     1:             }
 91688:             end = (uint32_t)d;
     1:         }
     1:     }
     1: 
     1:     if (begin > end)
     1:         begin = end;
     1: 
 99421:     RootedObject nobj(cx);
 95355: 
 77343:     if (obj->isDenseArray() && end <= obj->getDenseArrayInitializedLength() &&
 28242:         !js_PrototypeHasIndexedProperties(cx, obj)) {
 59234:         nobj = NewDenseCopiedArray(cx, end - begin, obj->getDenseArrayElements() + begin);
 11835:         if (!nobj)
 11835:             return JS_FALSE;
 78457:         TryReuseArrayType(obj, nobj);
 80814:         args.rval().setObject(*nobj);
 11835:         return JS_TRUE;
 11835:     }
 11835: 
 59234:     nobj = NewDenseAllocatedArray(cx, end - begin);
 11835:     if (!nobj)
 11835:         return JS_FALSE;
 78457:     TryReuseArrayType(obj, nobj);
 11835: 
 99421:     RootedValue value(cx);
     1:     for (slot = begin; slot < end; slot++) {
 28242:         if (!JS_CHECK_OPERATION_LIMIT(cx) ||
 97353:             !GetElement(cx, obj, slot, &hole, value.address())) {
 28242:             return JS_FALSE;
 28242:         }
 97353:         if (!hole && !SetArrayElement(cx, nobj, slot - begin, value))
 28242:             return JS_FALSE;
 28242:     }
 28242: 
 80814:     args.rval().setObject(*nobj);
 59234:     return JS_TRUE;
     1: }
     1: 
 80814: enum IndexOfKind {
 80814:     IndexOf,
 80814:     LastIndexOf
 80814: };
 80814: 
     1: static JSBool
 80814: array_indexOfHelper(JSContext *cx, IndexOfKind mode, CallArgs &args)
     1: {
 91688:     uint32_t length, i, stop;
 48470:     Value tosearch;
 91450:     int direction;
     1:     JSBool hole;
     1: 
 80814:     JSObject *obj = ToObject(cx, &args.thisv());
 61734:     if (!obj)
 61734:         return false;
 61734:     if (!js_GetLengthProperty(cx, obj, &length))
     1:         return JS_FALSE;
     1:     if (length == 0)
     1:         goto not_found;
     1: 
 80814:     if (args.length() <= 1) {
 80814:         i = (mode == LastIndexOf) ? length - 1 : 0;
 80814:         tosearch = (args.length() != 0) ? args[0] : UndefinedValue();
     1:     } else {
 90955:         double start;
     1: 
 80814:         tosearch = args[0];
 80814:         if (!ToInteger(cx, args[1], &start))
 69230:             return false;
     1:         if (start < 0) {
     1:             start += length;
     1:             if (start < 0) {
 80814:                 if (mode == LastIndexOf)
     1:                     goto not_found;
     1:                 i = 0;
     1:             } else {
 91688:                 i = (uint32_t)start;
     1:             }
     1:         } else if (start >= length) {
 80814:             if (mode == IndexOf)
     1:                 goto not_found;
     1:             i = length - 1;
     1:         } else {
 91688:             i = (uint32_t)start;
     1:         }
     1:     }
     1: 
 80814:     if (mode == LastIndexOf) {
     1:         stop = 0;
     1:         direction = -1;
     1:     } else {
     1:         stop = length - 1;
     1:         direction = 1;
     1:     }
     1: 
     1:     for (;;) {
 80814:         Value elt;
 25087:         if (!JS_CHECK_OPERATION_LIMIT(cx) ||
 91688:             !GetElement(cx, obj, (uint32_t)i, &hole, &elt)) {
     1:             return JS_FALSE;
     1:         }
 59890:         if (!hole) {
 88099:             bool equal;
 80814:             if (!StrictlyEqual(cx, elt, tosearch, &equal))
 88099:                 return false;
 59890:             if (equal) {
 80814:                 args.rval().setNumber(i);
 88099:                 return true;
 48470:             }
 59890:         }
     1:         if (i == stop)
     1:             goto not_found;
     1:         i += direction;
     1:     }
     1: 
     1:   not_found:
 80814:     args.rval().setInt32(-1);
     1:     return JS_TRUE;
     1: }
     1: 
     1: static JSBool
 91237: array_indexOf(JSContext *cx, unsigned argc, Value *vp)
     1: {
 80814:     CallArgs args = CallArgsFromVp(argc, vp);
 80814:     return array_indexOfHelper(cx, IndexOf, args);
     1: }
     1: 
     1: static JSBool
 91237: array_lastIndexOf(JSContext *cx, unsigned argc, Value *vp)
     1: {
 80814:     CallArgs args = CallArgsFromVp(argc, vp);
 80814:     return array_indexOfHelper(cx, LastIndexOf, args);
     1: }
     1: 
 81582: /* ECMA 15.4.4.16-15.4.4.18. */
 81582: class ArrayForEachBehavior
     1: {
 81582:   public:
 81582:     static bool shouldExit(Value &callval, Value *rval) { return false; }
 81582:     static Value lateExitValue() { return UndefinedValue(); }
 81582: };
 81582: 
 81582: class ArrayEveryBehavior
 81582: {
 81582:   public:
 81582:     static bool shouldExit(Value &callval, Value *rval)
 81582:     {
 81582:         if (!js_ValueToBoolean(callval)) {
 81582:             *rval = BooleanValue(false);
 81582:             return true;
 81582:         }
 81582:         return false;
 81582:     }
 81582:     static Value lateExitValue() { return BooleanValue(true); }
 81582: };
 81582: 
 81582: class ArraySomeBehavior
 81582: {
 81582:   public:
 81582:     static bool shouldExit(Value &callval, Value *rval)
 81582:     {
 81582:         if (js_ValueToBoolean(callval)) {
 81582:             *rval = BooleanValue(true);
 81582:             return true;
 81582:         }
 81582:         return false;
 81582:     }
 81582:     static Value lateExitValue() { return BooleanValue(false); }
 81582: };
 81582: 
 81582: template <class Behavior>
 81582: static inline bool
 81582: array_readonlyCommon(JSContext *cx, CallArgs &args)
 81582: {
 81582:     /* Step 1. */
 99421:     RootedObject obj(cx, ToObject(cx, &args.thisv()));
 61734:     if (!obj)
 61734:         return false;
 61734: 
 81582:     /* Step 2-3. */
 84755:     uint32_t len;
 81582:     if (!js_GetLengthProperty(cx, obj, &len))
 81582:         return false;
 81582: 
 81582:     /* Step 4. */
 80814:     if (args.length() == 0) {
 80814:         js_ReportMissingArg(cx, args.calleev(), 0);
 81582:         return false;
 16519:     }
103274:     RootedObject callable(cx, ValueToCallable(cx, &args[0]));
     1:     if (!callable)
 81582:         return false;
 81582: 
 81582:     /* Step 5. */
 81582:     Value thisv = args.length() >= 2 ? args[1] : UndefinedValue();
 81582: 
 81582:     /* Step 6. */
 84755:     uint32_t k = 0;
 81582: 
 81582:     /* Step 7. */
 80814:     InvokeArgsGuard ag;
 81582:     while (k < len) {
 81582:         if (!JS_CHECK_OPERATION_LIMIT(cx))
 77917:             return false;
 77917: 
 81582:         /* Step a, b, and c.i. */
 81582:         Value kValue;
 81582:         JSBool kNotPresent;
 81582:         if (!GetElement(cx, obj, k, &kNotPresent, &kValue))
 81582:             return false;
 81582: 
 81582:         /* Step c.ii-iii. */
 81582:         if (!kNotPresent) {
 81582:             if (!ag.pushed() && !cx->stack.pushInvokeArgs(cx, 3, &ag))
 81582:                 return false;
 82027:             ag.setCallee(ObjectValue(*callable));
 80814:             ag.thisv() = thisv;
 81582:             ag[0] = kValue;
 81582:             ag[1] = NumberValue(k);
 81582:             ag[2] = ObjectValue(*obj);
 81582:             if (!Invoke(cx, ag))
 81582:                 return false;
 81582: 
 81582:             if (Behavior::shouldExit(ag.rval(), &args.rval()))
 81582:                 return true;
 81582:         }
 81582: 
 81582:         /* Step d. */
 81582:         k++;
 81582:     }
 81582: 
 81582:     /* Step 8. */
 81582:     args.rval() = Behavior::lateExitValue();
 81582:     return true;
 81582:  }
 81582: 
 81582: /* ES5 15.4.4.16. */
 81582: static JSBool
 91237: array_every(JSContext *cx, unsigned argc, Value *vp)
 81582: {
 81582:     CallArgs args = CallArgsFromVp(argc, vp);
 81582:     return array_readonlyCommon<ArrayEveryBehavior>(cx, args);
 81582: }
 81582: 
 81582: /* ES5 15.4.4.17. */
 81582: static JSBool
 91237: array_some(JSContext *cx, unsigned argc, Value *vp)
 81582: {
 81582:     CallArgs args = CallArgsFromVp(argc, vp);
 81582:     return array_readonlyCommon<ArraySomeBehavior>(cx, args);
 81582: }
 81582: 
 81582: /* ES5 15.4.4.18. */
 29887: static JSBool
 91237: array_forEach(JSContext *cx, unsigned argc, Value *vp)
     1: {
 80814:     CallArgs args = CallArgsFromVp(argc, vp);
 81582:     return array_readonlyCommon<ArrayForEachBehavior>(cx, args);
 81582: }
 81582: 
 81582: /* ES5 15.4.4.19. */
 29887: static JSBool
 91237: array_map(JSContext *cx, unsigned argc, Value *vp)
     1: {
 80814:     CallArgs args = CallArgsFromVp(argc, vp);
 81582: 
 81582:     /* Step 1. */
 99421:     RootedObject obj(cx, ToObject(cx, &args.thisv()));
 81582:     if (!obj)
 81582:         return false;
 81582: 
 81582:     /* Step 2-3. */
 84755:     uint32_t len;
 81582:     if (!js_GetLengthProperty(cx, obj, &len))
 81582:         return false;
 81582: 
 81582:     /* Step 4. */
 81582:     if (args.length() == 0) {
 81582:         js_ReportMissingArg(cx, args.calleev(), 0);
 81582:         return false;
 81582:     }
103274:     RootedObject callable(cx, ValueToCallable(cx, &args[0]));
 81582:     if (!callable)
 81582:         return false;
 81582: 
 81582:     /* Step 5. */
 81582:     Value thisv = args.length() >= 2 ? args[1] : UndefinedValue();
 81582: 
 81582:     /* Step 6. */
 99421:     RootedObject arr(cx, NewDenseAllocatedArray(cx, len));
 81582:     if (!arr)
 81582:         return false;
 81582:     TypeObject *newtype = GetTypeCallerInitObject(cx, JSProto_Array);
 81582:     if (!newtype)
 81582:         return false;
 81582:     arr->setType(newtype);
 81582: 
 81582:     /* Step 7. */
 84755:     uint32_t k = 0;
 81582: 
 81582:     /* Step 8. */
 81582:     InvokeArgsGuard ag;
 81582:     while (k < len) {
 81582:         if (!JS_CHECK_OPERATION_LIMIT(cx))
 81582:             return false;
 81582: 
 81582:         /* Step a, b, and c.i. */
 81582:         JSBool kNotPresent;
 81582:         Value kValue;
 81582:         if (!GetElement(cx, obj, k, &kNotPresent, &kValue))
 81582:             return false;
 81582: 
 81582:         /* Step c.ii-iii. */
 81582:         if (!kNotPresent) {
 81582:             if (!ag.pushed() && !cx->stack.pushInvokeArgs(cx, 3, &ag))
 81582:                 return false;
 82027:             ag.setCallee(ObjectValue(*callable));
 81582:             ag.thisv() = thisv;
 81582:             ag[0] = kValue;
 81582:             ag[1] = NumberValue(k);
 81582:             ag[2] = ObjectValue(*obj);
 81582:             if (!Invoke(cx, ag))
 81582:                 return false;
 81582:             if(!SetArrayElement(cx, arr, k, ag.rval()))
 81582:                 return false;
 81582:         }
 81582: 
 81582:         /* Step d. */
 81582:         k++;
 81582:     }
 81582: 
 81582:     /* Step 9. */
 81582:     args.rval().setObject(*arr);
 81582:     return true;
 81582: }
 81582: 
 81582: /* ES5 15.4.4.20. */
 81582: static JSBool
 91237: array_filter(JSContext *cx, unsigned argc, Value *vp)
 81582: {
 81582:     CallArgs args = CallArgsFromVp(argc, vp);
 81582: 
 81582:     /* Step 1. */
 99421:     RootedObject obj(cx, ToObject(cx, &args.thisv()));
 81582:     if (!obj)
 81582:         return false;
 81582: 
 81582:     /* Step 2-3. */
 84755:     uint32_t len;
 81582:     if (!js_GetLengthProperty(cx, obj, &len))
 81582:         return false;
 81582: 
 81582:     /* Step 4. */
 81582:     if (args.length() == 0) {
 81582:         js_ReportMissingArg(cx, args.calleev(), 0);
 81582:         return false;
 81582:     }
103274:     RootedObject callable(cx, ValueToCallable(cx, &args[0]));
 81582:     if (!callable)
 81582:         return false;
 81582: 
 81582:     /* Step 5. */
 81582:     Value thisv = args.length() >= 2 ? args[1] : UndefinedValue();
 81582: 
 81582:     /* Step 6. */
 99421:     RootedObject arr(cx, NewDenseAllocatedArray(cx, 0));
 81582:     if (!arr)
 81582:         return false;
 81582:     TypeObject *newtype = GetTypeCallerInitObject(cx, JSProto_Array);
 81582:     if (!newtype)
 81582:         return false;
 81582:     arr->setType(newtype);
 81582: 
 81582:     /* Step 7. */
 84755:     uint32_t k = 0;
 81582: 
 81582:     /* Step 8. */
 84755:     uint32_t to = 0;
 81582: 
 81582:     /* Step 9. */
 81582:     InvokeArgsGuard ag;
 81582:     while (k < len) {
 81582:         if (!JS_CHECK_OPERATION_LIMIT(cx))
 81582:             return false;
 81582: 
 81582:         /* Step a, b, and c.i. */
 81582:         JSBool kNotPresent;
 81582:         Value kValue;
 81582:         if (!GetElement(cx, obj, k, &kNotPresent, &kValue))
 81582:             return false;
 81582: 
 81582:         /* Step c.ii-iii. */
 81582:         if (!kNotPresent) {
 81582:             if (!ag.pushed() && !cx->stack.pushInvokeArgs(cx, 3, &ag))
 81582:                 return false;
 82027:             ag.setCallee(ObjectValue(*callable));
 81582:             ag.thisv() = thisv;
 81582:             ag[0] = kValue;
 81582:             ag[1] = NumberValue(k);
 81582:             ag[2] = ObjectValue(*obj);
 81582:             if (!Invoke(cx, ag))
 81582:                 return false;
 81582: 
 81582:             if (js_ValueToBoolean(ag.rval())) {
 81582:                 if(!SetArrayElement(cx, arr, to, kValue))
 81582:                     return false;
 81582:                 to++;
 81582:             }
 81582:         }
 81582: 
 81582:         /* Step d. */
 81582:         k++;
 81582:     }
 81582: 
 81582:     /* Step 10. */
 81582:     args.rval().setObject(*arr);
 81582:     return true;
 81582: }
 81582: 
 81582: /* ES5 15.4.4.21-15.4.4.22. */
 81582: class ArrayReduceBehavior
 81582: {
 81582:   public:
 84755:     static void initialize(uint32_t len, uint32_t *start, uint32_t *end, int32_t *step)
 81582:     {
 81582:         *start = 0;
 81582:         *step = 1;
 81582:         *end = len;
 81582:     }
 81582: };
 81582: 
 81582: class ArrayReduceRightBehavior
 81582: {
 81582:   public:
 84755:     static void initialize(uint32_t len, uint32_t *start, uint32_t *end, int32_t *step)
 81582:     {
 81582:         *start = len - 1;
 81582:         *step = -1;
 81582:         /*
 81582:          * We rely on (well defined) unsigned integer underflow to check our
 81582:          * end condition after visiting the full range (including 0).
 81582:          */
 84755:         *end = UINT32_MAX;
 81582:     }
 81582: };
 81582: 
 81582: template<class Behavior>
 81582: static inline bool
 81582: array_reduceCommon(JSContext *cx, CallArgs &args)
 81582: {
 81582:     /* Step 1. */
 81582:     JSObject *obj = ToObject(cx, &args.thisv());
 81582:     if (!obj)
 81582:         return false;
 81582: 
 81582:     /* Step 2-3. */
 84755:     uint32_t len;
 81582:     if (!js_GetLengthProperty(cx, obj, &len))
 81582:         return false;
 81582: 
 81582:     /* Step 4. */
 81582:     if (args.length() == 0) {
 81582:         js_ReportMissingArg(cx, args.calleev(), 0);
 81582:         return false;
 81582:     }
103274:     JSObject *callable = ValueToCallable(cx, &args[0]);
 81582:     if (!callable)
 81582:         return false;
 81582: 
 81582:     /* Step 5. */
 81582:     if (len == 0 && args.length() < 2) {
 81582:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_EMPTY_ARRAY_REDUCE);
 81582:         return false;
 81582:     }
 81582: 
 81582:     /* Step 6. */
 84755:     uint32_t k, end;
 84755:     int32_t step;
 81582:     Behavior::initialize(len, &k, &end, &step);
 81582: 
 81582:     /* Step 7-8. */
 81582:     Value accumulator;
 81582:     if (args.length() >= 2) {
 81582:         accumulator = args[1];
 81582:     } else {
 81582:         JSBool kNotPresent = true;
 81582:         while (kNotPresent && k != end) {
 81582:             if (!GetElement(cx, obj, k, &kNotPresent, &accumulator))
 81582:                 return false;
 81582:             k += step;
 81582:         }
 81582:         if (kNotPresent) {
 81582:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_EMPTY_ARRAY_REDUCE);
 81582:             return false;
 81582:         }
 81582:     }
 81582: 
 81582:     /* Step 9. */
 81582:     InvokeArgsGuard ag;
 81582:     while (k != end) {
 81582:         if (!JS_CHECK_OPERATION_LIMIT(cx))
 81582:             return false;
 81582: 
 81582:         /* Step a, b, and c.i. */
 81582:         JSBool kNotPresent;
 81582:         Value kValue;
 81582:         if (!GetElement(cx, obj, k, &kNotPresent, &kValue))
 81582:             return false;
 81582: 
 81582:         /* Step c.ii. */
 81582:         if (!kNotPresent) {
 81582:             if (!ag.pushed() && !cx->stack.pushInvokeArgs(cx, 4, &ag))
 81582:                 return false;
 82027:             ag.setCallee(ObjectValue(*callable));
 81582:             ag.thisv() = UndefinedValue();
 81582:             ag[0] = accumulator;
 81582:             ag[1] = kValue;
 81582:             ag[2] = NumberValue(k);
 81582:             ag[3] = ObjectValue(*obj);
 81582:             if (!Invoke(cx, ag))
 81582:                 return false;
 81582:             accumulator = ag.rval();
 81582:         }
 81582: 
 81582:         /* Step d. */
 81582:         k += step;
 81582:     }
 81582: 
 81582:     /* Step 10. */
 81582:     args.rval() = accumulator;
 81582:     return true;
 81582: }
 81582: 
 81582: /* ES5 15.4.4.21. */
 29887: static JSBool
 91237: array_reduce(JSContext *cx, unsigned argc, Value *vp)
     1: {
 80814:     CallArgs args = CallArgsFromVp(argc, vp);
 81582:     return array_reduceCommon<ArrayReduceBehavior>(cx, args);
 81582: }
 81582: 
 81582: /* ES5 15.4.4.22. */
 29887: static JSBool
 91237: array_reduceRight(JSContext *cx, unsigned argc, Value *vp)
     1: {
 80814:     CallArgs args = CallArgsFromVp(argc, vp);
 81582:     return array_reduceCommon<ArrayReduceRightBehavior>(cx, args);
     1: }
     1: 
 31833: static JSBool
 91237: array_isArray(JSContext *cx, unsigned argc, Value *vp)
 31833: {
 79390:     CallArgs args = CallArgsFromVp(argc, vp);
 89376:     bool isArray = args.length() > 0 && IsObjectWithClass(args[0], ESClass_Array, cx);
 79390:     args.rval().setBoolean(isArray);
 56565:     return true;
 31833: }
 31833: 
 77343: #define GENERIC JSFUN_GENERIC_NATIVE
 77343: 
     1: static JSFunctionSpec array_methods[] = {
     1: #if JS_HAS_TOSOURCE
 16519:     JS_FN(js_toSource_str,      array_toSource,     0,0),
     1: #endif
 41857:     JS_FN(js_toString_str,      array_toString,     0,0),
 16519:     JS_FN(js_toLocaleString_str,array_toLocaleString,0,0),
     1: 
     1:     /* Perl-ish methods. */
 41857:     JS_FN("join",               array_join,         1,JSFUN_GENERIC_NATIVE),
 16519:     JS_FN("reverse",            array_reverse,      0,JSFUN_GENERIC_NATIVE),
 16519:     JS_FN("sort",               array_sort,         1,JSFUN_GENERIC_NATIVE),
 41857:     JS_FN("push",               array_push,         1,JSFUN_GENERIC_NATIVE),
 41857:     JS_FN("pop",                array_pop,          0,JSFUN_GENERIC_NATIVE),
 16519:     JS_FN("shift",              array_shift,        0,JSFUN_GENERIC_NATIVE),
 16519:     JS_FN("unshift",            array_unshift,      1,JSFUN_GENERIC_NATIVE),
 16519:     JS_FN("splice",             array_splice,       2,JSFUN_GENERIC_NATIVE),
     1: 
 11835:     /* Pythonic sequence methods. */
 16519:     JS_FN("concat",             array_concat,       1,JSFUN_GENERIC_NATIVE),
 16519:     JS_FN("slice",              array_slice,        2,JSFUN_GENERIC_NATIVE),
     1: 
 16519:     JS_FN("indexOf",            array_indexOf,      1,JSFUN_GENERIC_NATIVE),
 16519:     JS_FN("lastIndexOf",        array_lastIndexOf,  1,JSFUN_GENERIC_NATIVE),
 16519:     JS_FN("forEach",            array_forEach,      1,JSFUN_GENERIC_NATIVE),
 16519:     JS_FN("map",                array_map,          1,JSFUN_GENERIC_NATIVE),
 16519:     JS_FN("reduce",             array_reduce,       1,JSFUN_GENERIC_NATIVE),
 16519:     JS_FN("reduceRight",        array_reduceRight,  1,JSFUN_GENERIC_NATIVE),
 16519:     JS_FN("filter",             array_filter,       1,JSFUN_GENERIC_NATIVE),
 16519:     JS_FN("some",               array_some,         1,JSFUN_GENERIC_NATIVE),
 16519:     JS_FN("every",              array_every,        1,JSFUN_GENERIC_NATIVE),
     1: 
  4127:     JS_FS_END
     1: };
     1: 
 31833: static JSFunctionSpec array_static_methods[] = {
 31833:     JS_FN("isArray",            array_isArray,      1,0),
 31833:     JS_FS_END
 31833: };
 31833: 
 73080: /* ES5 15.4.2 */
 18300: JSBool
 91237: js_Array(JSContext *cx, unsigned argc, Value *vp)
     1: {
 80814:     CallArgs args = CallArgsFromVp(argc, vp);
 99421:     RootedTypeObject type(cx, GetTypeCallerInitObject(cx, JSProto_Array));
 77343:     if (!type)
 77343:         return JS_FALSE;
 77343: 
 80814:     if (args.length() != 1 || !args[0].isNumber()) {
 80814:         if (!InitArrayTypes(cx, type, args.array(), args.length()))
 77343:             return false;
 80814:         JSObject *obj = (args.length() == 0)
 73080:                         ? NewDenseEmptyArray(cx)
 80814:                         : NewDenseCopiedArray(cx, args.length(), args.array());
 73080:         if (!obj)
 73080:             return false;
 77343:         obj->setType(type);
 80814:         args.rval().setObject(*obj);
 73080:         return true;
 73080:     }
 73080: 
 84755:     uint32_t length;
 80814:     if (args[0].isInt32()) {
 84755:         int32_t i = args[0].toInt32();
 73080:         if (i < 0) {
 73080:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_ARRAY_LENGTH);
 73080:             return false;
 73080:         }
 84755:         length = uint32_t(i);
 59234:     } else {
 90955:         double d = args[0].toDouble();
 97045:         length = ToUint32(d);
 90955:         if (d != double(length)) {
 73080:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_ARRAY_LENGTH);
 73080:             return false;
     1:         }
 73080:     }
 73080: 
 73080:     JSObject *obj = NewDenseUnallocatedArray(cx, length);
 55746:     if (!obj)
 73080:         return false;
 77343: 
 77343:     obj->setType(type);
 77343: 
 77343:     /* If the length calculation overflowed, make sure that is marked for the new type. */
 77343:     if (obj->getArrayLength() > INT32_MAX)
 77343:         obj->setArrayLength(cx, obj->getArrayLength());
 77343: 
 80814:     args.rval().setObject(*obj);
 73080:     return true;
     1: }
     1: 
     1: JSObject *
     1: js_InitArrayClass(JSContext *cx, JSObject *obj)
     1: {
 73996:     JS_ASSERT(obj->isNative());
 73996: 
 99421:     Rooted<GlobalObject*> global(cx);
 86483:     global = &obj->asGlobal();
 86437: 
 99421:     RootedObject arrayProto(cx);
 86437:     arrayProto = global->createBlankPrototype(cx, &SlowArrayClass);
 73996:     if (!arrayProto || !AddLengthProperty(cx, arrayProto))
     1:         return NULL;
 77363:     arrayProto->setArrayLength(cx, 0);
 73996: 
 99421:     RootedFunction ctor(cx);
 97828:     ctor = global->createConstructor(cx, js_Array, CLASS_NAME(cx, Array), 1);
 73996:     if (!ctor)
 73996:         return NULL;
 73996: 
 83312:     /*
 83312:      * The default 'new' type of Array.prototype is required by type inference
 83312:      * to have unknown properties, to simplify handling of e.g. heterogenous
 83312:      * arrays in JSON and script literals and allows setDenseArrayElement to
 83312:      * be used without updating the indexed type set for such default arrays.
 83312:      */
 83286:     if (!arrayProto->setNewTypeUnknown(cx))
 83286:         return NULL;
 77363: 
 73996:     if (!LinkConstructorAndPrototype(cx, ctor, arrayProto))
 73996:         return NULL;
 73996: 
 73996:     if (!DefinePropertiesAndBrand(cx, arrayProto, NULL, array_methods) ||
 73996:         !DefinePropertiesAndBrand(cx, ctor, NULL, array_static_methods))
 73996:     {
 73996:         return NULL;
 73996:     }
 73996: 
 73996:     if (!DefineConstructorAndPrototype(cx, global, JSProto_Array, ctor, arrayProto))
 73996:         return NULL;
 73996: 
 73996:     return arrayProto;
     1: }
     1: 
 59234: /*
 59234:  * Array allocation functions.
 59234:  */
 59234: namespace js {
 59234: 
 83276: static inline bool
 91688: EnsureNewArrayElements(JSContext *cx, JSObject *obj, uint32_t length)
 80814: {
 83252:     /*
 83252:      * If ensureElements creates dynamically allocated slots, then having
 83252:      * fixedSlots is a waste.
 83252:      */
 84755:     DebugOnly<uint32_t> cap = obj->getDenseArrayCapacity();
 83252: 
 83252:     if (!obj->ensureElements(cx, length))
 83276:         return false;
 83276: 
 83276:     JS_ASSERT_IF(cap, !obj->hasDynamicElements());
 83276: 
 83276:     return true;
 83276: }
 83276: 
 59234: template<bool allocateCapacity>
 59234: static JS_ALWAYS_INLINE JSObject *
 99364: NewArray(JSContext *cx, uint32_t length, JSObject *proto_)
 59234: {
 83276:     gc::AllocKind kind = GuessArrayGCKind(length);
 83276:     JS_ASSERT(CanBeFinalizedInBackground(kind, &ArrayClass));
 83276:     kind = GetBackgroundAllocKind(kind);
 83276: 
 99364:     GlobalObject *parent_ = GetCurrentGlobal(cx);
 83313: 
 97465:     NewObjectCache &cache = cx->runtime->newObjectCache;
 83313: 
 83313:     NewObjectCache::EntryIndex entry = -1;
 99364:     if (cache.lookupGlobal(&ArrayClass, parent_, kind, &entry)) {
 83313:         JSObject *obj = cache.newObjectFromHit(cx, entry);
 60255:         if (!obj)
 60255:             return NULL;
 83276:         /* Fixup the elements pointer and length, which may be incorrect. */
 83276:         obj->setFixedElements();
 77343:         obj->setArrayLength(cx, length);
 83276:         if (allocateCapacity && !EnsureNewArrayElements(cx, obj, length))
 59234:             return NULL;
 83276:         return obj;
 83276:     }
 83276: 
 99421:     Rooted<GlobalObject*> parent(cx, parent_);
 99364: 
 99364:     if (!proto_ && !FindProto(cx, &ArrayClass, parent, &proto_))
 83276:         return NULL;
 83276: 
 99421:     RootedObject proto(cx, proto_);
 99421:     RootedTypeObject type(cx);
 86437: 
 86437:     type = proto->getNewType(cx);
 83276:     if (!type)
 83276:         return NULL;
 83276: 
 83321:     /*
 83321:      * Get a shape with zero fixed slots, regardless of the size class.
 83321:      * See JSObject::createDenseArray.
 83321:      */
 99421:     RootedShape shape(cx);
 86437:     shape = EmptyShape::getInitialShape(cx, &ArrayClass, proto,
 86437:                                         parent, gc::FINALIZE_OBJECT0);
 83276:     if (!shape)
 83276:         return NULL;
 83276: 
 83314:     JSObject* obj = JSObject::createDenseArray(cx, kind, shape, type, length);
 83276:     if (!obj)
 83276:         return NULL;
 83276: 
 83313:     if (entry != -1)
 83313:         cache.fillGlobal(entry, &ArrayClass, parent, kind, obj);
 83276: 
 83276:     if (allocateCapacity && !EnsureNewArrayElements(cx, obj, length))
 83276:         return NULL;
 80814: 
 83275:     Probes::createObject(cx, obj);
 59234:     return obj;
 59234: }
 59234: 
 59234: JSObject * JS_FASTCALL
 59234: NewDenseEmptyArray(JSContext *cx, JSObject *proto)
 59234: {
 59234:     return NewArray<false>(cx, 0, proto);
 59234: }
 59234: 
 59234: JSObject * JS_FASTCALL
 84755: NewDenseAllocatedArray(JSContext *cx, uint32_t length, JSObject *proto)
 59234: {
 59234:     return NewArray<true>(cx, length, proto);
 59234: }
 59234: 
 59234: JSObject * JS_FASTCALL
 84755: NewDenseAllocatedEmptyArray(JSContext *cx, uint32_t length, JSObject *proto)
 77343: {
 77343:     return NewArray<true>(cx, length, proto);
 77343: }
 77343: 
 77343: JSObject * JS_FASTCALL
 84755: NewDenseUnallocatedArray(JSContext *cx, uint32_t length, JSObject *proto)
 59234: {
 59234:     return NewArray<false>(cx, length, proto);
 59234: }
 59234: 
 77343: #ifdef JS_METHODJIT
 77343: JSObject * JS_FASTCALL
 84755: mjit::stubs::NewDenseUnallocatedArray(VMFrame &f, uint32_t length)
 77343: {
 77343:     JSObject *proto = (JSObject *) f.scratch;
 77343:     JSObject *obj = NewArray<false>(f.cx, length, proto);
 92002:     if (!obj)
 77343:         THROWV(NULL);
 92002: 
 77343:     return obj;
 77343: }
 77343: #endif
 77343: 
     1: JSObject *
 84755: NewDenseCopiedArray(JSContext *cx, uint32_t length, const Value *vp, JSObject *proto /* = NULL */)
     1: {
 97353:     // XXX vp may be an internal pointer to an object's dense array elements.
 97353:     SkipRoot skip(cx, &vp);
 97353: 
 59234:     JSObject* obj = NewArray<true>(cx, length, proto);
 60255:     if (!obj)
 60255:         return NULL;
 60255: 
 59234:     JS_ASSERT(obj->getDenseArrayCapacity() >= length);
 59234: 
 77394:     obj->setDenseArrayInitializedLength(vp ? length : 0);
 77394: 
 59234:     if (vp)
 82129:         obj->initDenseArrayElements(0, vp, length);
 59234: 
 59234:     return obj;
 59234: }
 59234: 
 59234: JSObject *
 59234: NewSlowEmptyArray(JSContext *cx)
 59234: {
 99421:     RootedObject obj(cx, NewBuiltinClassInstance(cx, &SlowArrayClass));
 62076:     if (!obj || !AddLengthProperty(cx, obj))
     1:         return NULL;
     1: 
 77343:     obj->setArrayLength(cx, 0);
 11835:     return obj;
 11835: }
 11835: 
 59234: }
 59234: 
 59234: 
 54568: #ifdef DEBUG
 11835: JSBool
 91237: js_ArrayInfo(JSContext *cx, unsigned argc, jsval *vp)
 11835: {
 80814:     CallArgs args = CallArgsFromVp(argc, vp);
 11835:     JSObject *array;
 11835: 
 91237:     for (unsigned i = 0; i < args.length(); i++) {
 80814:         Value arg = args[i];
 54568: 
 54568:         char *bytes = DecompileValueGenerator(cx, JSDVG_SEARCH_STACK, arg, NULL);
 11835:         if (!bytes)
 11835:             return JS_FALSE;
 54568:         if (arg.isPrimitive() ||
 54568:             !(array = arg.toObjectOrNull())->isArray()) {
 11835:             fprintf(stderr, "%s: not array\n", bytes);
 64560:             cx->free_(bytes);
 11835:             continue;
 11835:         }
 54568:         fprintf(stderr, "%s: %s (len %u", bytes,
 54568:                 array->isDenseArray() ? "dense" : "sparse",
 40796:                 array->getArrayLength());
 39928:         if (array->isDenseArray()) {
 54568:             fprintf(stderr, ", capacity %u",
 41782:                     array->getDenseArrayCapacity());
 11835:         }
 11835:         fputs(")\n", stderr);
 64560:         cx->free_(bytes);
 11835:     }
 54568: 
 80814:     args.rval().setUndefined();
 54568:     return true;
 11835: }
 11835: #endif
