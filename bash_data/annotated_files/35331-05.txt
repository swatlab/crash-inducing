    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
13496:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jsdbgapi_h___
    1: #define jsdbgapi_h___
    1: /*
    1:  * JS debugger API.
    1:  */
    1: #include "jsapi.h"
    1: #include "jsopcode.h"
    1: #include "jsprvtd.h"
    1: 
    1: JS_BEGIN_EXTERN_C
    1: 
13496: /*
13496:  * Unexported library-private helper used to unpatch all traps in a script.
13496:  * Returns script->code if script has no traps, else a JS_malloc'ed copy of
13496:  * script->code which the caller must JS_free, or null on JS_malloc OOM.
13496:  */
13496: extern jsbytecode *
13496: js_UntrapScriptCode(JSContext *cx, JSScript *script);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_SetTrap(JSContext *cx, JSScript *script, jsbytecode *pc,
    1:            JSTrapHandler handler, void *closure);
    1: 
    1: extern JS_PUBLIC_API(JSOp)
    1: JS_GetTrapOpcode(JSContext *cx, JSScript *script, jsbytecode *pc);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_ClearTrap(JSContext *cx, JSScript *script, jsbytecode *pc,
    1:              JSTrapHandler *handlerp, void **closurep);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_ClearScriptTraps(JSContext *cx, JSScript *script);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_ClearAllTraps(JSContext *cx);
    1: 
    1: extern JS_PUBLIC_API(JSTrapStatus)
    1: JS_HandleTrap(JSContext *cx, JSScript *script, jsbytecode *pc, jsval *rval);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_SetInterrupt(JSRuntime *rt, JSTrapHandler handler, void *closure);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_ClearInterrupt(JSRuntime *rt, JSTrapHandler *handlerp, void **closurep);
    1: 
    1: /************************************************************************/
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_SetWatchPoint(JSContext *cx, JSObject *obj, jsval id,
    1:                  JSWatchPointHandler handler, void *closure);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_ClearWatchPoint(JSContext *cx, JSObject *obj, jsval id,
    1:                    JSWatchPointHandler *handlerp, void **closurep);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_ClearWatchPointsForObject(JSContext *cx, JSObject *obj);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_ClearAllWatchPoints(JSContext *cx);
    1: 
    1: #ifdef JS_HAS_OBJ_WATCHPOINT
    1: /*
    1:  * Hide these non-API function prototypes by testing whether the internal
18863:  * header file "jsversion.h" has been included.
    1:  */
    1: extern void
 5816: js_TraceWatchPoints(JSTracer *trc, JSObject *obj);
 5816: 
 5816: extern void
 5816: js_SweepWatchPoints(JSContext *cx);
    1: 
    1: extern JSScopeProperty *
    1: js_FindWatchPoint(JSRuntime *rt, JSScope *scope, jsid id);
    1: 
    1: /*
    1:  * NB: callers outside of jsdbgapi.c must pass non-null scope.
    1:  */
    1: extern JSPropertyOp
    1: js_GetWatchedSetter(JSRuntime *rt, JSScope *scope,
    1:                     const JSScopeProperty *sprop);
    1: 
29885: extern JSBool
    1: js_watch_set(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
    1: 
29885: extern JSBool
    1: js_watch_set_wrapper(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
    1:                      jsval *rval);
    1: 
    1: extern JSPropertyOp
    1: js_WrapWatchedSetter(JSContext *cx, jsid id, uintN attrs, JSPropertyOp setter);
    1: 
    1: #endif /* JS_HAS_OBJ_WATCHPOINT */
    1: 
    1: /************************************************************************/
    1: 
    1: extern JS_PUBLIC_API(uintN)
    1: JS_PCToLineNumber(JSContext *cx, JSScript *script, jsbytecode *pc);
    1: 
    1: extern JS_PUBLIC_API(jsbytecode *)
    1: JS_LineNumberToPC(JSContext *cx, JSScript *script, uintN lineno);
    1: 
    1: extern JS_PUBLIC_API(JSScript *)
    1: JS_GetFunctionScript(JSContext *cx, JSFunction *fun);
    1: 
    1: extern JS_PUBLIC_API(JSNative)
    1: JS_GetFunctionNative(JSContext *cx, JSFunction *fun);
    1: 
 4127: extern JS_PUBLIC_API(JSFastNative)
 4127: JS_GetFunctionFastNative(JSContext *cx, JSFunction *fun);
 4127: 
    1: extern JS_PUBLIC_API(JSPrincipals *)
    1: JS_GetScriptPrincipals(JSContext *cx, JSScript *script);
    1: 
    1: /*
    1:  * Stack Frame Iterator
    1:  *
    1:  * Used to iterate through the JS stack frames to extract
    1:  * information from the frames.
    1:  */
    1: 
    1: extern JS_PUBLIC_API(JSStackFrame *)
    1: JS_FrameIterator(JSContext *cx, JSStackFrame **iteratorp);
    1: 
    1: extern JS_PUBLIC_API(JSScript *)
    1: JS_GetFrameScript(JSContext *cx, JSStackFrame *fp);
    1: 
    1: extern JS_PUBLIC_API(jsbytecode *)
    1: JS_GetFramePC(JSContext *cx, JSStackFrame *fp);
    1: 
    1: /*
    1:  * Get the closest scripted frame below fp.  If fp is null, start from cx->fp.
    1:  */
    1: extern JS_PUBLIC_API(JSStackFrame *)
    1: JS_GetScriptedCaller(JSContext *cx, JSStackFrame *fp);
    1: 
    1: /*
    1:  * Return a weak reference to fp's principals.  A null return does not denote
    1:  * an error, it means there are no principals.
    1:  */
    1: extern JS_PUBLIC_API(JSPrincipals *)
    1: JS_StackFramePrincipals(JSContext *cx, JSStackFrame *fp);
    1: 
    1: /*
    1:  * This API is like JS_StackFramePrincipals(cx, caller), except that if
    1:  * cx->runtime->findObjectPrincipals is non-null, it returns the weaker of
    1:  * the caller's principals and the object principals of fp's callee function
    1:  * object (fp->argv[-2]), which is eval, Function, or a similar eval-like
    1:  * method.  The caller parameter should be JS_GetScriptedCaller(cx, fp).
    1:  *
    1:  * All eval-like methods must use JS_EvalFramePrincipals to acquire a weak
    1:  * reference to the correct principals for the eval call to be secure, given
    1:  * an embedding that calls JS_SetObjectPrincipalsFinder (see jsapi.h).
    1:  */
    1: extern JS_PUBLIC_API(JSPrincipals *)
    1: JS_EvalFramePrincipals(JSContext *cx, JSStackFrame *fp, JSStackFrame *caller);
    1: 
    1: extern JS_PUBLIC_API(void *)
    1: JS_GetFrameAnnotation(JSContext *cx, JSStackFrame *fp);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_SetFrameAnnotation(JSContext *cx, JSStackFrame *fp, void *annotation);
    1: 
    1: extern JS_PUBLIC_API(void *)
    1: JS_GetFramePrincipalArray(JSContext *cx, JSStackFrame *fp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_IsNativeFrame(JSContext *cx, JSStackFrame *fp);
    1: 
    1: /* this is deprecated, use JS_GetFrameScopeChain instead */
    1: extern JS_PUBLIC_API(JSObject *)
    1: JS_GetFrameObject(JSContext *cx, JSStackFrame *fp);
    1: 
    1: extern JS_PUBLIC_API(JSObject *)
    1: JS_GetFrameScopeChain(JSContext *cx, JSStackFrame *fp);
    1: 
    1: extern JS_PUBLIC_API(JSObject *)
    1: JS_GetFrameCallObject(JSContext *cx, JSStackFrame *fp);
    1: 
    1: extern JS_PUBLIC_API(JSObject *)
    1: JS_GetFrameThis(JSContext *cx, JSStackFrame *fp);
    1: 
    1: extern JS_PUBLIC_API(JSFunction *)
    1: JS_GetFrameFunction(JSContext *cx, JSStackFrame *fp);
    1: 
    1: extern JS_PUBLIC_API(JSObject *)
    1: JS_GetFrameFunctionObject(JSContext *cx, JSStackFrame *fp);
    1: 
    1: /* XXXrginda Initially published with typo */
    1: #define JS_IsContructorFrame JS_IsConstructorFrame
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_IsConstructorFrame(JSContext *cx, JSStackFrame *fp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_IsDebuggerFrame(JSContext *cx, JSStackFrame *fp);
    1: 
    1: extern JS_PUBLIC_API(jsval)
    1: JS_GetFrameReturnValue(JSContext *cx, JSStackFrame *fp);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_SetFrameReturnValue(JSContext *cx, JSStackFrame *fp, jsval rval);
    1: 
    1: /**
 4127:  * Return fp's callee function object (fp->callee) if it has one.
    1:  */
    1: extern JS_PUBLIC_API(JSObject *)
    1: JS_GetFrameCalleeObject(JSContext *cx, JSStackFrame *fp);
    1: 
    1: /************************************************************************/
    1: 
    1: extern JS_PUBLIC_API(const char *)
    1: JS_GetScriptFilename(JSContext *cx, JSScript *script);
    1: 
    1: extern JS_PUBLIC_API(uintN)
    1: JS_GetScriptBaseLineNumber(JSContext *cx, JSScript *script);
    1: 
    1: extern JS_PUBLIC_API(uintN)
    1: JS_GetScriptLineExtent(JSContext *cx, JSScript *script);
    1: 
    1: extern JS_PUBLIC_API(JSVersion)
    1: JS_GetScriptVersion(JSContext *cx, JSScript *script);
    1: 
    1: /************************************************************************/
    1: 
    1: /*
    1:  * Hook setters for script creation and destruction, see jsprvtd.h for the
    1:  * typedefs.  These macros provide binary compatibility and newer, shorter
    1:  * synonyms.
    1:  */
    1: #define JS_SetNewScriptHook     JS_SetNewScriptHookProc
    1: #define JS_SetDestroyScriptHook JS_SetDestroyScriptHookProc
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_SetNewScriptHook(JSRuntime *rt, JSNewScriptHook hook, void *callerdata);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_SetDestroyScriptHook(JSRuntime *rt, JSDestroyScriptHook hook,
    1:                         void *callerdata);
    1: 
    1: /************************************************************************/
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_EvaluateUCInStackFrame(JSContext *cx, JSStackFrame *fp,
    1:                           const jschar *chars, uintN length,
    1:                           const char *filename, uintN lineno,
    1:                           jsval *rval);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_EvaluateInStackFrame(JSContext *cx, JSStackFrame *fp,
    1:                         const char *bytes, uintN length,
    1:                         const char *filename, uintN lineno,
    1:                         jsval *rval);
    1: 
    1: /************************************************************************/
    1: 
    1: typedef struct JSPropertyDesc {
    1:     jsval           id;         /* primary id, a string or int */
    1:     jsval           value;      /* property value */
    1:     uint8           flags;      /* flags, see below */
    1:     uint8           spare;      /* unused */
    1:     uint16          slot;       /* argument/variable slot */
    1:     jsval           alias;      /* alias id if JSPD_ALIAS flag */
    1: } JSPropertyDesc;
    1: 
    1: #define JSPD_ENUMERATE  0x01    /* visible to for/in loop */
    1: #define JSPD_READONLY   0x02    /* assignment is error */
    1: #define JSPD_PERMANENT  0x04    /* property cannot be deleted */
    1: #define JSPD_ALIAS      0x08    /* property has an alias id */
    1: #define JSPD_ARGUMENT   0x10    /* argument to function */
    1: #define JSPD_VARIABLE   0x20    /* local variable in function */
    1: #define JSPD_EXCEPTION  0x40    /* exception occurred fetching the property, */
    1:                                 /* value is exception */
    1: #define JSPD_ERROR      0x80    /* native getter returned JS_FALSE without */
    1:                                 /* throwing an exception */
    1: 
    1: typedef struct JSPropertyDescArray {
    1:     uint32          length;     /* number of elements in array */
    1:     JSPropertyDesc  *array;     /* alloc'd by Get, freed by Put */
    1: } JSPropertyDescArray;
    1: 
    1: extern JS_PUBLIC_API(JSScopeProperty *)
    1: JS_PropertyIterator(JSObject *obj, JSScopeProperty **iteratorp);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_GetPropertyDesc(JSContext *cx, JSObject *obj, JSScopeProperty *sprop,
    1:                    JSPropertyDesc *pd);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_GetPropertyDescArray(JSContext *cx, JSObject *obj, JSPropertyDescArray *pda);
    1: 
    1: extern JS_PUBLIC_API(void)
    1: JS_PutPropertyDescArray(JSContext *cx, JSPropertyDescArray *pda);
    1: 
    1: /************************************************************************/
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_SetDebuggerHandler(JSRuntime *rt, JSTrapHandler handler, void *closure);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_SetSourceHandler(JSRuntime *rt, JSSourceHandler handler, void *closure);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_SetExecuteHook(JSRuntime *rt, JSInterpreterHook hook, void *closure);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_SetCallHook(JSRuntime *rt, JSInterpreterHook hook, void *closure);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_SetObjectHook(JSRuntime *rt, JSObjectHook hook, void *closure);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_SetThrowHook(JSRuntime *rt, JSTrapHandler hook, void *closure);
    1: 
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_SetDebugErrorHook(JSRuntime *rt, JSDebugErrorHook hook, void *closure);
    1: 
    1: /************************************************************************/
    1: 
    1: extern JS_PUBLIC_API(size_t)
    1: JS_GetObjectTotalSize(JSContext *cx, JSObject *obj);
    1: 
    1: extern JS_PUBLIC_API(size_t)
    1: JS_GetFunctionTotalSize(JSContext *cx, JSFunction *fun);
    1: 
    1: extern JS_PUBLIC_API(size_t)
    1: JS_GetScriptTotalSize(JSContext *cx, JSScript *script);
    1: 
    1: /*
    1:  * Get the top-most running script on cx starting from fp, or from the top of
    1:  * cx's frame stack if fp is null, and return its script filename flags.  If
    1:  * the script has a null filename member, return JSFILENAME_NULL.
    1:  */
    1: extern JS_PUBLIC_API(uint32)
    1: JS_GetTopScriptFilenameFlags(JSContext *cx, JSStackFrame *fp);
    1: 
    1: /*
    1:  * Get the script filename flags for the script.  If the script doesn't have a
    1:  * filename, return JSFILENAME_NULL.
    1:  */
    1: extern JS_PUBLIC_API(uint32)
    1: JS_GetScriptFilenameFlags(JSScript *script);
    1: 
    1: /*
    1:  * Associate flags with a script filename prefix in rt, so that any subsequent
    1:  * script compilation will inherit those flags if the script's filename is the
    1:  * same as prefix, or if prefix is a substring of the script's filename.
    1:  *
    1:  * The API defines only one flag bit, JSFILENAME_SYSTEM, leaving the remaining
    1:  * 31 bits up to the API client to define.  The union of all 32 bits must not
    1:  * be a legal combination, however, in order to preserve JSFILENAME_NULL as a
    1:  * unique value.  API clients may depend on JSFILENAME_SYSTEM being a set bit
    1:  * in JSFILENAME_NULL -- a script with a null filename member is presumed to
    1:  * be a "system" script.
    1:  */
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_FlagScriptFilenamePrefix(JSRuntime *rt, const char *prefix, uint32 flags);
    1: 
    1: #define JSFILENAME_NULL         0xffffffff      /* null script filename */
    1: #define JSFILENAME_SYSTEM       0x00000001      /* "system" script, see below */
 9531: #define JSFILENAME_PROTECTED    0x00000002      /* scripts need protection */
    1: 
    1: /*
 7987:  * Return true if obj is a "system" object, that is, one created by
 7987:  * JS_NewSystemObject with the system flag set and not JS_NewObject.
 7987:  *
 7987:  * What "system" means is up to the API client, but it can be used to implement
 7987:  * access control policies based on script filenames and their prefixes, using
 7987:  * JS_FlagScriptFilenamePrefix and JS_GetTopScriptFilenameFlags.
    1:  */
    1: extern JS_PUBLIC_API(JSBool)
    1: JS_IsSystemObject(JSContext *cx, JSObject *obj);
    1: 
    1: /*
 7987:  * Call JS_NewObject(cx, clasp, proto, parent) and, if system is true, mark the
 7987:  * result as a system object, that is an object for which JS_IsSystemObject
 7987:  * returns true.
    1:  */
 7987: extern JS_PUBLIC_API(JSObject *)
 7987: JS_NewSystemObject(JSContext *cx, JSClass *clasp, JSObject *proto,
 7987:                    JSObject *parent, JSBool system);
    1: 
 2433: /************************************************************************/
 2433: 
35331: extern JS_PUBLIC_API(const JSDebugHooks *)
 2433: JS_GetGlobalDebugHooks(JSRuntime *rt);
 2433: 
 2433: extern JS_PUBLIC_API(JSDebugHooks *)
35331: JS_SetContextDebugHooks(JSContext *cx, const JSDebugHooks *hooks);
 2433: 
10339: #ifdef MOZ_SHARK
10339: 
13496: extern JS_PUBLIC_API(JSBool)
13496: JS_StartChudRemote();
10339: 
13496: extern JS_PUBLIC_API(JSBool)
13496: JS_StopChudRemote();
10339: 
13496: extern JS_PUBLIC_API(JSBool)
13496: JS_ConnectShark();
13496: 
13496: extern JS_PUBLIC_API(JSBool)
13496: JS_DisconnectShark();
13496: 
13496: extern JS_FRIEND_API(JSBool)
13496: js_StopShark(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
10339:              jsval *rval);
10339: 
13496: extern JS_FRIEND_API(JSBool)
13496: js_StartShark(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
10339:               jsval *rval);
13496: 
13496: extern JS_FRIEND_API(JSBool)
13496: js_ConnectShark(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
13496:                 jsval *rval);
13496: 
13496: extern JS_FRIEND_API(JSBool)
13496: js_DisconnectShark(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
13496:                    jsval *rval);
13496: 
10339: #endif /* MOZ_SHARK */
10339: 
15763: #ifdef MOZ_CALLGRIND
15763: 
15763: extern JS_FRIEND_API(JSBool)
15763: js_StopCallgrind(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
15763:                  jsval *rval);
15763: 
15763: extern JS_FRIEND_API(JSBool)
15763: js_StartCallgrind(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
15763:                   jsval *rval);
15763: 
15763: extern JS_FRIEND_API(JSBool)
15763: js_DumpCallgrind(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
15763:                  jsval *rval);
15763: 
15763: #endif /* MOZ_CALLGRIND */
15763: 
16288: #ifdef MOZ_VTUNE
16288: 
16288: extern JS_FRIEND_API(JSBool)
16288: js_StartVtune(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
16288:               jsval *rval);
16288: 
16288: extern JS_FRIEND_API(JSBool)
16288: js_StopVtune(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
16288:              jsval *rval);
16288: 
16288: extern JS_FRIEND_API(JSBool)
16288: js_PauseVtune(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
16288:               jsval *rval);
16288: 
16288: extern JS_FRIEND_API(JSBool)
16288: js_ResumeVtune(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
16288:                jsval *rval);
16288: 
16288: #endif /* MOZ_VTUNE */
16288: 
31063: #ifdef MOZ_TRACEVIS
31063: extern JS_FRIEND_API(JSBool)
31063: js_InitEthogram(JSContext *cx, JSObject *obj,
31063:                 uintN argc, jsval *argv, jsval *rval);
31063: extern JS_FRIEND_API(JSBool)
31063: js_ShutdownEthogram(JSContext *cx, JSObject *obj,
31063:                     uintN argc, jsval *argv, jsval *rval);
31063: #endif /* MOZ_TRACEVIS */
31063: 
    1: JS_END_EXTERN_C
    1: 
    1: #endif /* jsdbgapi_h___ */
