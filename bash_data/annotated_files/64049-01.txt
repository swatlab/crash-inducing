    1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   John Bandhauer <jband@netscape.com> (original author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* Per JSRuntime object */
    1: 
    1: #include "xpcprivate.h"
55577: #include "WrapperFactory.h"
22842: #include "dom_quickstubs.h"
    1: 
47427: #include "jsgcchunk.h"
47427: #include "nsIMemoryReporter.h"
42480: #include "mozilla/FunctionTimer.h"
58047: #include "prsystem.h"
42480: 
    1: /***************************************************************************/
    1: 
    1: const char* XPCJSRuntime::mStrings[] = {
    1:     "constructor",          // IDX_CONSTRUCTOR
    1:     "toString",             // IDX_TO_STRING
    1:     "toSource",             // IDX_TO_SOURCE
    1:     "lastResult",           // IDX_LAST_RESULT
    1:     "returnCode",           // IDX_RETURN_CODE
    1:     "value",                // IDX_VALUE
    1:     "QueryInterface",       // IDX_QUERY_INTERFACE
    1:     "Components",           // IDX_COMPONENTS
    1:     "wrappedJSObject",      // IDX_WRAPPED_JSOBJECT
    1:     "Object",               // IDX_OBJECT
    1:     "Function",             // IDX_FUNCTION
    1:     "prototype",            // IDX_PROTOTYPE
    1:     "createInstance",       // IDX_CREATE_INSTANCE
 6464:     "item",                 // IDX_ITEM
 6464:     "__proto__",            // IDX_PROTO
30625:     "__iterator__",         // IDX_ITERATOR
55629:     "__exposedProps__",     // IDX_EXPOSEDPROPS
55629:     "__scriptOnly__"        // IDX_SCRIPTONLY
    1: };
    1: 
    1: /***************************************************************************/
    1: 
    1: // data holder class for the enumerator callback below
    1: struct JSDyingJSObjectData
    1: {
    1:     JSContext* cx;
26582:     nsTArray<nsXPCWrappedJS*>* array;
    1: };
    1: 
18907: static JSDHashOperator
    1: WrappedJSDyingJSObjectFinder(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                 uint32 number, void *arg)
    1: {
    1:     JSDyingJSObjectData* data = (JSDyingJSObjectData*) arg;
    1:     nsXPCWrappedJS* wrapper = ((JSObject2WrappedJSMap::Entry*)hdr)->value;
    1:     NS_ASSERTION(wrapper, "found a null JS wrapper!");
    1: 
    1:     // walk the wrapper chain and find any whose JSObject is to be finalized
    1:     while(wrapper)
    1:     {
    1:         if(wrapper->IsSubjectToFinalization())
    1:         {
62690:             js::SwitchToCompartment sc(data->cx,
62690:                                        wrapper->GetJSObjectPreserveColor());
62690:             if(JS_IsAboutToBeFinalized(data->cx,
62690:                                        wrapper->GetJSObjectPreserveColor()))
    1:                 data->array->AppendElement(wrapper);
    1:         }
    1:         wrapper = wrapper->GetNextWrapper();
    1:     }
    1:     return JS_DHASH_NEXT;
    1: }
    1: 
    1: struct CX_AND_XPCRT_Data
    1: {
    1:     JSContext* cx;
    1:     XPCJSRuntime* rt;
    1: };
    1: 
18907: static JSDHashOperator
    1: NativeInterfaceSweeper(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                        uint32 number, void *arg)
    1: {
    1:     XPCNativeInterface* iface = ((IID2NativeInterfaceMap::Entry*)hdr)->value;
    1:     if(iface->IsMarked())
    1:     {
    1:         iface->Unmark();
    1:         return JS_DHASH_NEXT;
    1:     }
    1: 
    1: #ifdef XPC_REPORT_NATIVE_INTERFACE_AND_SET_FLUSHING
57721:     fputs("- Destroying XPCNativeInterface for ", stdout);
57721:     JS_PutString(JSVAL_TO_STRING(iface->GetName()), stdout);
57721:     putc('\n', stdout);
    1: #endif
    1: 
31395:     XPCNativeInterface::DestroyInstance(iface);
    1:     return JS_DHASH_REMOVE;
    1: }
    1: 
    1: // *Some* NativeSets are referenced from mClassInfo2NativeSetMap.
    1: // *All* NativeSets are referenced from mNativeSetMap.
    1: // So, in mClassInfo2NativeSetMap we just clear references to the unmarked.
    1: // In mNativeSetMap we clear the references to the unmarked *and* delete them.
    1: 
18907: static JSDHashOperator
    1: NativeUnMarkedSetRemover(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                          uint32 number, void *arg)
    1: {
    1:     XPCNativeSet* set = ((ClassInfo2NativeSetMap::Entry*)hdr)->value;
    1:     if(set->IsMarked())
    1:         return JS_DHASH_NEXT;
    1:     return JS_DHASH_REMOVE;
    1: }
    1: 
18907: static JSDHashOperator
    1: NativeSetSweeper(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                  uint32 number, void *arg)
    1: {
    1:     XPCNativeSet* set = ((NativeSetMap::Entry*)hdr)->key_value;
    1:     if(set->IsMarked())
    1:     {
    1:         set->Unmark();
    1:         return JS_DHASH_NEXT;
    1:     }
    1: 
    1: #ifdef XPC_REPORT_NATIVE_INTERFACE_AND_SET_FLUSHING
    1:     printf("- Destroying XPCNativeSet for:\n");
    1:     PRUint16 count = set->GetInterfaceCount();
    1:     for(PRUint16 k = 0; k < count; k++)
    1:     {
    1:         XPCNativeInterface* iface = set->GetInterfaceAt(k);
57721:         fputs("    ", stdout);
57721:         JS_PutString(JSVAL_TO_STRING(iface->GetName()), stdout);
57721:         putc('\n', stdout);
    1:     }
    1: #endif
    1: 
    1:     XPCNativeSet::DestroyInstance(set);
    1:     return JS_DHASH_REMOVE;
    1: }
    1: 
18907: static JSDHashOperator
    1: JSClassSweeper(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                uint32 number, void *arg)
    1: {
    1:     XPCNativeScriptableShared* shared =
    1:         ((XPCNativeScriptableSharedMap::Entry*) hdr)->key;
    1:     if(shared->IsMarked())
    1:     {
    1: #ifdef off_XPC_REPORT_JSCLASS_FLUSHING
    1:         printf("+ Marked XPCNativeScriptableShared for: %s @ %x\n",
    1:                shared->GetJSClass()->name,
    1:                shared->GetJSClass());
    1: #endif
    1:         shared->Unmark();
    1:         return JS_DHASH_NEXT;
    1:     }
    1: 
    1: #ifdef XPC_REPORT_JSCLASS_FLUSHING
    1:     printf("- Destroying XPCNativeScriptableShared for: %s @ %x\n",
    1:            shared->GetJSClass()->name,
    1:            shared->GetJSClass());
    1: #endif
    1: 
    1:     delete shared;
    1:     return JS_DHASH_REMOVE;
    1: }
    1: 
18907: static JSDHashOperator
    1: DyingProtoKiller(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                  uint32 number, void *arg)
    1: {
    1:     XPCWrappedNativeProto* proto =
    1:         (XPCWrappedNativeProto*)((JSDHashEntryStub*)hdr)->key;
    1:     delete proto;
    1:     return JS_DHASH_REMOVE;
    1: }
    1: 
18907: static JSDHashOperator
    1: DetachedWrappedNativeProtoMarker(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                                  uint32 number, void *arg)
    1: {
    1:     XPCWrappedNativeProto* proto = 
    1:         (XPCWrappedNativeProto*)((JSDHashEntryStub*)hdr)->key;
    1: 
    1:     proto->Mark();
    1:     return JS_DHASH_NEXT;
    1: }
    1: 
    1: // GCCallback calls are chained
18907: static JSBool
    1: ContextCallback(JSContext *cx, uintN operation)
    1: {
20312:     XPCJSRuntime* self = nsXPConnect::GetRuntimeInstance();
    1:     if(self)
    1:     {
    1:         if(operation == JSCONTEXT_NEW)
    1:         {
20312:             if(!self->OnJSContextNew(cx))
20312:                 return JS_FALSE;
20312:         }
20312:         else if(operation == JSCONTEXT_DESTROY)
    1:         {
20312:             delete XPCContext::GetXPCContext(cx);
    1:         }
    1:     }
20312:     return JS_TRUE;
    1: }
    1: 
58722: xpc::CompartmentPrivate::~CompartmentPrivate()
58722: {
58722:     if (waiverWrapperMap)
58722:         delete waiverWrapperMap;
61214:     if (expandoMap)
61214:         delete expandoMap;
58722: }
58722: 
48503: static JSBool
48503: CompartmentCallback(JSContext *cx, JSCompartment *compartment, uintN op)
48503: {
48503:     if(op == JSCOMPARTMENT_NEW)
48503:         return JS_TRUE;
48503: 
48503:     XPCJSRuntime* self = nsXPConnect::GetRuntimeInstance();
48503:     if(!self)
48503:         return JS_TRUE;
48503: 
55675:     nsAutoPtr<xpc::CompartmentPrivate> priv(
55675:         static_cast<xpc::CompartmentPrivate*>(JS_SetCompartmentPrivate(cx, compartment, nsnull)));
55675:     if(!priv)
55675:         return JS_TRUE;
55675: 
56703:     if(xpc::PtrAndPrincipalHashKey *key = priv->key)
56703:     {
56703:         XPCCompartmentMap &map = self->GetCompartmentMap();
48503: #ifdef DEBUG
48503:         {
48503:             JSCompartment *current;
56703:             NS_ASSERTION(map.Get(key, &current), "no compartment?");
48503:             NS_ASSERTION(current == compartment, "compartment mismatch");
48503:         }
48503: #endif
56703:         map.Remove(key);
56703:     }
56703:     else
56703:     {
56703:         nsISupports *ptr = priv->ptr;
56703:         XPCMTCompartmentMap &map = self->GetMTCompartmentMap();
56703: #ifdef DEBUG
56703:         {
56703:             JSCompartment *current;
56703:             NS_ASSERTION(map.Get(ptr, &current), "no compartment?");
56703:             NS_ASSERTION(current == compartment, "compartment mismatch");
56703:         }
56703: #endif
56703:         map.Remove(ptr);
56703:     }
48503: 
48503:     return JS_TRUE;
48503: }
48503: 
 7230: struct ObjectHolder : public JSDHashEntryHdr
 7230: {
 7230:     void *holder;
 7230:     nsScriptObjectTracer* tracer;
 7230: };
 7230: 
 7230: nsresult
 7230: XPCJSRuntime::AddJSHolder(void* aHolder, nsScriptObjectTracer* aTracer)
 7230: {
 7230:     if(!mJSHolders.ops)
 7230:         return NS_ERROR_OUT_OF_MEMORY;
 7230: 
 7230:     ObjectHolder *entry =
 7230:         reinterpret_cast<ObjectHolder*>(JS_DHashTableOperate(&mJSHolders,
 7230:                                                              aHolder,
 7230:                                                              JS_DHASH_ADD));
 7230:     if(!entry)
 7230:         return NS_ERROR_OUT_OF_MEMORY;
 7230: 
 7230:     entry->holder = aHolder;
 7230:     entry->tracer = aTracer;
 7230: 
 7230:     return NS_OK;
 7230: }
 7230: 
 7230: nsresult
 7230: XPCJSRuntime::RemoveJSHolder(void* aHolder)
 7230: {
 7230:     if(!mJSHolders.ops)
 7230:         return NS_ERROR_OUT_OF_MEMORY;
 7230: 
 7230:     JS_DHashTableOperate(&mJSHolders, aHolder, JS_DHASH_REMOVE);
 7230: 
 7230:     return NS_OK;
 7230: }
 7230: 
    1: // static
 1476: void XPCJSRuntime::TraceJS(JSTracer* trc, void* data)
 1025: {
 1476:     XPCJSRuntime* self = (XPCJSRuntime*)data;
 1476: 
 1025:     // Skip this part if XPConnect is shutting down. We get into
 1025:     // bad locking problems with the thread iteration otherwise.
 1025:     if(!self->GetXPConnect()->IsShuttingDown())
 1025:     {
 1025:         PRLock* threadLock = XPCPerThreadData::GetLock();
 1025:         if(threadLock)
 1025:         { // scoped lock
 1025:             nsAutoLock lock(threadLock);
 1025: 
 1025:             XPCPerThreadData* iterp = nsnull;
 1025:             XPCPerThreadData* thread;
 1025: 
 1025:             while(nsnull != (thread =
 1025:                              XPCPerThreadData::IterateThreads(&iterp)))
 1025:             {
 1025:                 // Trace those AutoMarkingPtr lists!
 1025:                 thread->TraceJS(trc);
 1025:             }
 1025:         }
 1025:     }
 1476: 
57794:     {
57794:         XPCAutoLock lock(self->mMapLock);
57794: 
57794:         // XPCJSObjectHolders don't participate in cycle collection, so always
57794:         // trace them here.
57794:         XPCRootSetElem *e;
57794:         for(e = self->mObjectHolderRoots; e; e = e->GetNextRoot())
 7230:             static_cast<XPCJSObjectHolder*>(e)->TraceJS(trc);
57794:     }
 7227: 
48479:     // Mark these roots as gray so the CC can walk them later.
48583:     js::GCMarker *gcmarker = NULL;
48583:     if (IS_GC_MARKING_TRACER(trc)) {
48583:         gcmarker = static_cast<js::GCMarker *>(trc);
48583:         JS_ASSERT(gcmarker->getMarkColor() == XPC_GC_COLOR_BLACK);
48583:         gcmarker->setMarkColor(XPC_GC_COLOR_GRAY);
48583:     }
 7230:     self->TraceXPConnectRoots(trc);
48583:     if (gcmarker)
48583:         gcmarker->setMarkColor(XPC_GC_COLOR_BLACK);
 7286: }
 7230: 
20261: static void
 7230: TraceJSObject(PRUint32 aLangID, void *aScriptThing, void *aClosure)
 7230: {
 7230:     if(aLangID == nsIProgrammingLanguage::JAVASCRIPT)
 7230:     {
 7230:         JS_CALL_TRACER(static_cast<JSTracer*>(aClosure), aScriptThing,
 8005:                        js_GetGCThingTraceKind(aScriptThing),
 7230:                        "JSObjectHolder");
 7230:     }
 7230: }
 7230: 
18907: static JSDHashOperator
 7230: TraceJSHolder(JSDHashTable *table, JSDHashEntryHdr *hdr, uint32 number,
 7230:               void *arg)
 7230: {
 7230:     ObjectHolder* entry = reinterpret_cast<ObjectHolder*>(hdr);
 7230: 
 7230:     entry->tracer->Trace(entry->holder, TraceJSObject, arg);
 7230: 
 7230:     return JS_DHASH_NEXT;
 7230: }
 7230: 
 7286: struct ClearedGlobalObject : public JSDHashEntryHdr
 7286: {
 7286:     JSContext* mContext;
 7286:     JSObject* mGlobalObject;
 7286: };
 7286: 
61214: static PLDHashOperator
61809: TraceExpandos(XPCWrappedNative *wn, JSObject *&expando, void *aClosure)
61214: {
61809:     if(wn->IsWrapperExpired())
61809:         return PL_DHASH_REMOVE;
61214:     JS_CALL_OBJECT_TRACER(static_cast<JSTracer *>(aClosure), expando, "expando object");
61214:     return PL_DHASH_NEXT;
61214: }
61214: 
61214: static PLDHashOperator
61809: TraceCompartment(xpc::PtrAndPrincipalHashKey *aKey, JSCompartment *compartment, void *aClosure)
61214: {
61214:     xpc::CompartmentPrivate *priv = (xpc::CompartmentPrivate *)
61214:         JS_GetCompartmentPrivate(static_cast<JSTracer *>(aClosure)->context, compartment);
61214:     if (priv->expandoMap)
61809:         priv->expandoMap->Enumerate(TraceExpandos, aClosure);
61214:     return PL_DHASH_NEXT;
61214: }
61214: 
48479: void XPCJSRuntime::TraceXPConnectRoots(JSTracer *trc)
 7286: {
 7286:     JSContext *iter = nsnull, *acx;
48479:     while ((acx = JS_ContextIterator(GetJSRuntime(), &iter))) {
61450:         JS_ASSERT(acx->hasRunOption(JSOPTION_UNROOTED_GLOBAL));
48479:         if (acx->globalObject)
48479:             JS_CALL_OBJECT_TRACER(trc, acx->globalObject, "global object");
22795:     }
 7286: 
57794:     XPCAutoLock lock(mMapLock);
57794: 
 7230:     XPCWrappedNativeScope::TraceJS(trc, this);
 7230: 
 7230:     for(XPCRootSetElem *e = mVariantRoots; e ; e = e->GetNextRoot())
 7227:         static_cast<XPCTraceableVariant*>(e)->TraceJS(trc);
 7227: 
 7230:     for(XPCRootSetElem *e = mWrappedJSRoots; e ; e = e->GetNextRoot())
 7227:         static_cast<nsXPCWrappedJS*>(e)->TraceJS(trc);
 7227: 
 7230:     if(mJSHolders.ops)
 7230:         JS_DHashTableEnumerate(&mJSHolders, TraceJSHolder, trc);
61214: 
61214:     // Trace compartments.
61809:     GetCompartmentMap().EnumerateRead(TraceCompartment, trc);
 1025: }
 1025: 
56709: struct Closure
56709: {
56709:     JSContext *cx;
56709:     bool cycleCollectionEnabled;
56709:     nsCycleCollectionTraversalCallback *cb;
56709: };
56709: 
56709: static void
56709: CheckParticipatesInCycleCollection(PRUint32 aLangID, void *aThing, void *aClosure)
56709: {
56709:     Closure *closure = static_cast<Closure*>(aClosure);
56709: 
56709:     if(!closure->cycleCollectionEnabled &&
56709:        aLangID == nsIProgrammingLanguage::JAVASCRIPT &&
56709:        js_GetGCThingTraceKind(aThing) == JSTRACE_OBJECT)
56709:     {
56709:         closure->cycleCollectionEnabled =
56709:             xpc::ParticipatesInCycleCollection(closure->cx,
56709:                                                static_cast<JSObject*>(aThing));
56709:     }
56709: }
56709: 
18907: static JSDHashOperator
 7286: NoteJSHolder(JSDHashTable *table, JSDHashEntryHdr *hdr, uint32 number,
 7286:              void *arg)
 7286: {
 7286:     ObjectHolder* entry = reinterpret_cast<ObjectHolder*>(hdr);
56709:     Closure *closure = static_cast<Closure*>(arg);
 7286: 
56709:     closure->cycleCollectionEnabled = PR_FALSE;
56709:     entry->tracer->Trace(entry->holder, CheckParticipatesInCycleCollection,
56709:                          closure);
56709:     if(!closure->cycleCollectionEnabled)
56709:         return JS_DHASH_NEXT;
56709: 
56709:     closure->cb->NoteRoot(nsIProgrammingLanguage::CPLUSPLUS, entry->holder,
 7286:                           entry->tracer);
 7286: 
 7286:     return JS_DHASH_NEXT;
 7286: }
 7286: 
61809: // static
61809: void
61809: XPCJSRuntime::SuspectWrappedNative(JSContext *cx, XPCWrappedNative *wrapper,
61809:                                    nsCycleCollectionTraversalCallback &cb)
61809: {
61809:     if(!wrapper->IsValid() || wrapper->IsWrapperExpired())
61809:         return;
61809: 
61809:     NS_ASSERTION(NS_IsMainThread() || NS_IsCycleCollectorThread(), 
61809:                  "Suspecting wrapped natives from non-CC thread");
61809: 
61809:     // Only suspect wrappedJSObjects that are in a compartment that
61809:     // participates in cycle collection.
62690:     JSObject* obj = wrapper->GetFlatJSObjectPreserveColor();
61809:     if(!xpc::ParticipatesInCycleCollection(cx, obj))
61809:         return;
61809: 
61809:     // Only record objects that might be part of a cycle as roots, unless
61809:     // the callback wants all traces (a debug feature).
62690:     if(xpc_IsGrayGCThing(obj) || cb.WantAllTraces())
61809:         cb.NoteRoot(nsIProgrammingLanguage::JAVASCRIPT, obj,
61809:                     nsXPConnect::GetXPConnect());
61809: }
61809: 
61809: static PLDHashOperator
61809: SuspectExpandos(XPCWrappedNative *wrapper, JSObject *&expando, void *arg)
61809: {
61809:     Closure* closure = static_cast<Closure*>(arg);
61809:     XPCJSRuntime::SuspectWrappedNative(closure->cx, wrapper, *closure->cb);
61809: 
61809:     return PL_DHASH_NEXT;
61809: }
61809: 
61809: static PLDHashOperator
61809: SuspectCompartment(xpc::PtrAndPrincipalHashKey *key, JSCompartment *compartment, void *arg)
61809: {
61809:     Closure* closure = static_cast<Closure*>(arg);
61809:     xpc::CompartmentPrivate *priv = (xpc::CompartmentPrivate *)
61809:         JS_GetCompartmentPrivate(closure->cx, compartment);
61809:     if (priv->expandoMap)
61809:         priv->expandoMap->Enumerate(SuspectExpandos, arg);
61809:     return PL_DHASH_NEXT;
61809: }
 7286: 
56709: void
56709: XPCJSRuntime::AddXPConnectRoots(JSContext* cx,
 7286:                                 nsCycleCollectionTraversalCallback &cb)
 7286: {
 7286:     // For all JS objects that are held by native objects but aren't held
 7286:     // through rooting or locking, we need to add all the native objects that
 7286:     // hold them so that the JS objects are colored correctly in the cycle
 7286:     // collector. This includes JSContexts that don't have outstanding requests,
 7286:     // because their global object wasn't marked by the JS GC. All other JS
 7286:     // roots were marked by the JS GC and will be colored correctly in the cycle
 7286:     // collector.
 7286: 
 7286:     JSContext *iter = nsnull, *acx;
 7286:     while((acx = JS_ContextIterator(GetJSRuntime(), &iter)))
 7286:     {
30096:         // Only skip JSContexts with outstanding requests if the
30096:         // callback does not want all traces (a debug feature).
30096:         // Otherwise, we do want to know about all JSContexts to get
30096:         // better graphs and explanations.
53548:         if(!cb.WantAllTraces() && nsXPConnect::GetXPConnect()->GetOutstandingRequests(acx))
 7286:             continue;
 7286:         cb.NoteRoot(nsIProgrammingLanguage::CPLUSPLUS, acx,
 7286:                     nsXPConnect::JSContextParticipant());
 7286:     }
 7286: 
56709:     XPCAutoLock lock(mMapLock);
56709: 
 7286:     XPCWrappedNativeScope::SuspectAllWrappers(this, cx, cb);
 7286: 
 7286:     for(XPCRootSetElem *e = mVariantRoots; e ; e = e->GetNextRoot())
 7286:         cb.NoteXPCOMRoot(static_cast<XPCTraceableVariant*>(e));
 7286: 
 7286:     for(XPCRootSetElem *e = mWrappedJSRoots; e ; e = e->GetNextRoot())
 7286:     {
56709:         nsXPCWrappedJS *wrappedJS = static_cast<nsXPCWrappedJS*>(e);
62690:         JSObject *obj = wrappedJS->GetJSObjectPreserveColor();
56709: 
56709:         // Only suspect wrappedJSObjects that are in a compartment that
56709:         // participates in cycle collection.
56709:         if(!xpc::ParticipatesInCycleCollection(cx, obj))
56709:             continue;
56709: 
56709:         cb.NoteXPCOMRoot(static_cast<nsIXPConnectWrappedJS *>(wrappedJS));
 7286:     }
 7286: 
61809:     Closure closure = { cx, PR_TRUE, &cb };
 7286:     if(mJSHolders.ops)
56709:     {
56709:         JS_DHashTableEnumerate(&mJSHolders, NoteJSHolder, &closure);
56709:     }
61809: 
61809:     // Suspect wrapped natives with expando objects.
61809:     GetCompartmentMap().EnumerateRead(SuspectCompartment, &closure);
 7286: }
 7286: 
48479: void
48479: XPCJSRuntime::ClearWeakRoots()
 7286: {
 7286:     JSContext *iter = nsnull, *acx;
48479: 
 7286:     while((acx = JS_ContextIterator(GetJSRuntime(), &iter)))
 7286:     {
37182:         if(XPCPerThreadData::IsMainThread(acx) &&
53548:            !nsXPConnect::GetXPConnect()->GetOutstandingRequests(acx))
 7286:         {
 7286:             JS_ClearNewbornRoots(acx);
 7286:         }
 7286:     }
 7286: }
23650: 
27445: template<class T> static void
27445: DoDeferredRelease(nsTArray<T> &array)
27445: {
27445:     while(1)
27445:     {
27445:         PRUint32 count = array.Length();
27445:         if(!count)
27445:         {
27445:             array.Compact();
27445:             break;
27445:         }
27445:         T wrapper = array[count-1];
27445:         array.RemoveElementAt(count-1);
27445:         NS_RELEASE(wrapper);
27445:     }
27445: }
27445: 
58722: static JSDHashOperator
58722: SweepWaiverWrappers(JSDHashTable *table, JSDHashEntryHdr *hdr,
58722:                     uint32 number, void *arg)
58722: {
60258:     JSContext *cx = (JSContext *)arg;
58722:     JSObject *key = ((JSObject2JSObjectMap::Entry *)hdr)->key;
58722:     JSObject *value = ((JSObject2JSObjectMap::Entry *)hdr)->value;
60258:     if(IsAboutToBeFinalized(cx, key) || IsAboutToBeFinalized(cx, value))
58722:         return JS_DHASH_REMOVE;
58722:     return JS_DHASH_NEXT;
58722: }
58722: 
58722: static PLDHashOperator
61214: SweepExpandos(XPCWrappedNative *wn, JSObject *&expando, void *arg)
61214: {
61214:     JSContext *cx = (JSContext *)arg;
62690:     return IsAboutToBeFinalized(cx, wn->GetFlatJSObjectPreserveColor())
61214:            ? PL_DHASH_REMOVE
61214:            : PL_DHASH_NEXT;
61214: }
61214: 
61214: static PLDHashOperator
58722: SweepCompartment(nsCStringHashKey& aKey, JSCompartment *compartment, void *aClosure)
58722: {
58722:     xpc::CompartmentPrivate *priv = (xpc::CompartmentPrivate *)
58722:         JS_GetCompartmentPrivate((JSContext *)aClosure, compartment);
58722:     if (priv->waiverWrapperMap)
60258:         priv->waiverWrapperMap->Enumerate(SweepWaiverWrappers, (JSContext *)aClosure);
61214:     if (priv->expandoMap)
61214:         priv->expandoMap->Enumerate(SweepExpandos, (JSContext *)aClosure);
58722:     return PL_DHASH_NEXT;
58722: }
58722: 
 1025: // static
    1: JSBool XPCJSRuntime::GCCallback(JSContext *cx, JSGCStatus status)
    1: {
20312:     XPCJSRuntime* self = nsXPConnect::GetRuntimeInstance();
64049:     if(!self)
64049:         return JS_TRUE;
64049: 
    1:     switch(status)
    1:     {
    1:         case JSGC_BEGIN:
    1:         {
 9740:             if(!NS_IsMainThread())
    1:             {
    1:                 return JS_FALSE;
    1:             }
49128: 
49128:             // We seem to sometime lose the unrooted global flag. Restore it
49128:             // here. FIXME: bug 584495.
49128:             JSContext *iter = nsnull, *acx;
49128: 
49128:             while((acx = JS_ContextIterator(cx->runtime, &iter))) {
61450:                 if (!acx->hasRunOption(JSOPTION_UNROOTED_GLOBAL))
49128:                     JS_ToggleOptions(acx, JSOPTION_UNROOTED_GLOBAL);
49128:             }
    1:             break;
    1:         }
    1:         case JSGC_MARK_END:
    1:         {
    1:             NS_ASSERTION(!self->mDoingFinalization, "bad state");
    1: 
    1:             // mThreadRunningGC indicates that GC is running
    1:             { // scoped lock
    1:                 XPCAutoLock lock(self->GetMapLock());
    1:                 NS_ASSERTION(!self->mThreadRunningGC, "bad state");
    1:                 self->mThreadRunningGC = PR_GetCurrentThread();
    1:             }
    1: 
27445:             nsTArray<nsXPCWrappedJS*>* dyingWrappedJSArray =
27445:                 &self->mWrappedJSToReleaseArray;
 9740: 
    1:             {
    1:                 JSDyingJSObjectData data = {cx, dyingWrappedJSArray};
    1: 
    1:                 // Add any wrappers whose JSObjects are to be finalized to
26582:                 // this array. Note that we do not want to be changing the
26582:                 // refcount of these wrappers.
    1:                 // We add them to the array now and Release the array members
    1:                 // later to avoid the posibility of doing any JS GCThing
    1:                 // allocations during the gc cycle.
    1:                 self->mWrappedJSMap->
    1:                     Enumerate(WrappedJSDyingJSObjectFinder, &data);
    1:             }
    1: 
58722:             // Find dying scopes.
    1:             XPCWrappedNativeScope::FinishedMarkPhaseOfGC(cx, self);
    1: 
58722:             // Sweep compartments.
58722:             self->GetCompartmentMap().EnumerateRead(
58722:                 (XPCCompartmentMap::EnumReadFunction)
58722:                 SweepCompartment, cx);
58722: 
    1:             self->mDoingFinalization = JS_TRUE;
    1:             break;
    1:         }
    1:         case JSGC_FINALIZE_END:
    1:         {
    1:             NS_ASSERTION(self->mDoingFinalization, "bad state");
    1:             self->mDoingFinalization = JS_FALSE;
    1: 
    1:             // Release all the members whose JSObjects are now known
    1:             // to be dead.
27445:             DoDeferredRelease(self->mWrappedJSToReleaseArray);
    1: 
    1: #ifdef XPC_REPORT_NATIVE_INTERFACE_AND_SET_FLUSHING
    1:             printf("--------------------------------------------------------------\n");
    1:             int setsBefore = (int) self->mNativeSetMap->Count();
    1:             int ifacesBefore = (int) self->mIID2NativeInterfaceMap->Count();
    1: #endif
    1: 
    1:             // We use this occasion to mark and sweep NativeInterfaces,
    1:             // NativeSets, and the WrappedNativeJSClasses...
    1: 
    1:             // Do the marking...
    1:             XPCWrappedNativeScope::MarkAllWrappedNativesAndProtos();
    1: 
    1:             self->mDetachedWrappedNativeProtoMap->
    1:                 Enumerate(DetachedWrappedNativeProtoMarker, nsnull);
    1: 
22842:             DOM_MarkInterfaces();
22842: 
    1:             // Mark the sets used in the call contexts. There is a small
    1:             // chance that a wrapper's set will change *while* a call is
    1:             // happening which uses that wrapper's old interfface set. So,
    1:             // we need to do this marking to avoid collecting those sets
    1:             // that might no longer be otherwise reachable from the wrappers
    1:             // or the wrapperprotos.
    1: 
    1:             // Skip this part if XPConnect is shutting down. We get into
    1:             // bad locking problems with the thread iteration otherwise.
    1:             if(!self->GetXPConnect()->IsShuttingDown())
    1:             {
    1:                 PRLock* threadLock = XPCPerThreadData::GetLock();
    1:                 if(threadLock)
    1:                 { // scoped lock
    1:                     nsAutoLock lock(threadLock);
    1: 
    1:                     XPCPerThreadData* iterp = nsnull;
    1:                     XPCPerThreadData* thread;
    1: 
    1:                     while(nsnull != (thread =
    1:                                  XPCPerThreadData::IterateThreads(&iterp)))
    1:                     {
    1:                         // Mark those AutoMarkingPtr lists!
    1:                         thread->MarkAutoRootsAfterJSFinalize();
    1: 
    1:                         XPCCallContext* ccxp = thread->GetCallContext();
    1:                         while(ccxp)
    1:                         {
    1:                             // Deal with the strictness of callcontext that
    1:                             // complains if you ask for a set when
    1:                             // it is in a state where the set could not
    1:                             // possibly be valid.
    1:                             if(ccxp->CanGetSet())
    1:                             {
    1:                                 XPCNativeSet* set = ccxp->GetSet();
    1:                                 if(set)
    1:                                     set->Mark();
    1:                             }
    1:                             if(ccxp->CanGetInterface())
    1:                             {
    1:                                 XPCNativeInterface* iface = ccxp->GetInterface();
    1:                                 if(iface)
    1:                                     iface->Mark();
    1:                             }
    1:                             ccxp = ccxp->GetPrevCallContext();
    1:                         }
    1:                     }
    1:                 }
    1:             }
    1: 
    1:             // Do the sweeping...
    1: 
    1:             // We don't want to sweep the JSClasses at shutdown time.
    1:             // At this point there may be JSObjects using them that have
    1:             // been removed from the other maps.
    1:             if(!self->GetXPConnect()->IsShuttingDown())
    1:             {
    1:                 self->mNativeScriptableSharedMap->
    1:                     Enumerate(JSClassSweeper, nsnull);
    1:             }
    1: 
    1:             self->mClassInfo2NativeSetMap->
    1:                 Enumerate(NativeUnMarkedSetRemover, nsnull);
    1: 
    1:             self->mNativeSetMap->
    1:                 Enumerate(NativeSetSweeper, nsnull);
    1: 
    1:             self->mIID2NativeInterfaceMap->
31395:                 Enumerate(NativeInterfaceSweeper, nsnull);
    1: 
    1: #ifdef DEBUG
    1:             XPCWrappedNativeScope::ASSERT_NoInterfaceSetsAreMarked();
    1: #endif
    1: 
    1: #ifdef XPC_REPORT_NATIVE_INTERFACE_AND_SET_FLUSHING
    1:             int setsAfter = (int) self->mNativeSetMap->Count();
    1:             int ifacesAfter = (int) self->mIID2NativeInterfaceMap->Count();
    1: 
    1:             printf("\n");
    1:             printf("XPCNativeSets:        before: %d  collected: %d  remaining: %d\n",
    1:                    setsBefore, setsBefore - setsAfter, setsAfter);
    1:             printf("XPCNativeInterfaces:  before: %d  collected: %d  remaining: %d\n",
    1:                    ifacesBefore, ifacesBefore - ifacesAfter, ifacesAfter);
    1:             printf("--------------------------------------------------------------\n");
    1: #endif
    1: 
    1:             // Sweep scopes needing cleanup
    1:             XPCWrappedNativeScope::FinishedFinalizationPhaseOfGC(cx);
    1: 
    1:             // Now we are going to recycle any unused WrappedNativeTearoffs.
    1:             // We do this by iterating all the live callcontexts (on all
    1:             // threads!) and marking the tearoffs in use. And then we
    1:             // iterate over all the WrappedNative wrappers and sweep their
    1:             // tearoffs.
    1:             //
    1:             // This allows us to perhaps minimize the growth of the
    1:             // tearoffs. And also makes us not hold references to interfaces
    1:             // on our wrapped natives that we are not actually using.
    1:             //
    1:             // XXX We may decide to not do this on *every* gc cycle.
    1: 
    1:             // Skip this part if XPConnect is shutting down. We get into
    1:             // bad locking problems with the thread iteration otherwise.
    1:             if(!self->GetXPConnect()->IsShuttingDown())
    1:             {
    1:                 PRLock* threadLock = XPCPerThreadData::GetLock();
    1:                 if(threadLock)
    1:                 {
    1:                     // Do the marking...
    1:                     
    1:                     { // scoped lock
    1:                         nsAutoLock lock(threadLock);
    1: 
    1:                         XPCPerThreadData* iterp = nsnull;
    1:                         XPCPerThreadData* thread;
    1: 
    1:                         while(nsnull != (thread =
    1:                                  XPCPerThreadData::IterateThreads(&iterp)))
    1:                         {
    1:                             XPCCallContext* ccxp = thread->GetCallContext();
    1:                             while(ccxp)
    1:                             {
    1:                                 // Deal with the strictness of callcontext that
    1:                                 // complains if you ask for a tearoff when
    1:                                 // it is in a state where the tearoff could not
    1:                                 // possibly be valid.
    1:                                 if(ccxp->CanGetTearOff())
    1:                                 {
    1:                                     XPCWrappedNativeTearOff* to = 
    1:                                         ccxp->GetTearOff();
    1:                                     if(to)
    1:                                         to->Mark();
    1:                                 }
    1:                                 ccxp = ccxp->GetPrevCallContext();
    1:                             }
    1:                         }
    1:                     }
    1: 
    1:                     // Do the sweeping...
    1:                     XPCWrappedNativeScope::SweepAllWrappedNativeTearOffs();
    1:                 }
    1:             }
    1: 
    1:             // Now we need to kill the 'Dying' XPCWrappedNativeProtos.
    1:             // We transfered these native objects to this table when their
    1:             // JSObject's were finalized. We did not destroy them immediately
    1:             // at that point because the ordering of JS finalization is not
    1:             // deterministic and we did not yet know if any wrappers that
    1:             // might still be referencing the protos where still yet to be
    1:             // finalized and destroyed. We *do* know that the protos'
    1:             // JSObjects would not have been finalized if there were any
    1:             // wrappers that referenced the proto but where not themselves
    1:             // slated for finalization in this gc cycle. So... at this point
    1:             // we know that any and all wrappers that might have been
    1:             // referencing the protos in the dying list are themselves dead.
    1:             // So, we can safely delete all the protos in the list.
    1: 
    1:             self->mDyingWrappedNativeProtoMap->
    1:                 Enumerate(DyingProtoKiller, nsnull);
    1: 
    1: 
    1:             // mThreadRunningGC indicates that GC is running.
    1:             // Clear it and notify waiters.
    1:             { // scoped lock
    1:                 XPCAutoLock lock(self->GetMapLock());
    1:                 NS_ASSERTION(self->mThreadRunningGC == PR_GetCurrentThread(), "bad state");
    1:                 self->mThreadRunningGC = nsnull;
    1:                 xpc_NotifyAll(self->GetMapLock());
    1:             }
    1: 
    1:             break;
    1:         }
    1:         case JSGC_END:
    1:         {
    1:             // NOTE that this event happens outside of the gc lock in
    1:             // the js engine. So this could be simultaneous with the
    1:             // events above.
    1: 
    1:             // Do any deferred released of native objects.
    1: #ifdef XPC_TRACK_DEFERRED_RELEASES
    1:             printf("XPC - Begin deferred Release of %d nsISupports pointers\n",
27914:                    self->mNativesToReleaseArray.Length());
    1: #endif
27445:             DoDeferredRelease(self->mNativesToReleaseArray);
    1: #ifdef XPC_TRACK_DEFERRED_RELEASES
    1:             printf("XPC - End deferred Releases\n");
    1: #endif
    1:             break;
    1:         }
    1:         default:
    1:             break;
    1:     }
    1: 
36094:     nsTArray<JSGCCallback> callbacks(self->extraGCCallbacks);
39337:     for (PRUint32 i = 0; i < callbacks.Length(); ++i) {
36094:         if (!callbacks[i](cx, status))
36094:             return JS_FALSE;
36094:     }
36094: 
20312:     return JS_TRUE;
    1: }
    1: 
56706: // Auto JS GC lock helper.
56706: class AutoLockJSGC
56706: {
56706: public:
56706:     AutoLockJSGC(JSRuntime* rt) : mJSRuntime(rt) { JS_LOCK_GC(mJSRuntime); }
56706:     ~AutoLockJSGC() { JS_UNLOCK_GC(mJSRuntime); }
56706: private:
56706:     JSRuntime* mJSRuntime;
56706: 
56706:     // Disable copy or assignment semantics.
56706:     AutoLockJSGC(const AutoLockJSGC&);
56706:     void operator=(const AutoLockJSGC&);
56706: };
56706: 
25087: //static
25087: void
25087: XPCJSRuntime::WatchdogMain(void *arg)
25087: {
25087:     XPCJSRuntime* self = static_cast<XPCJSRuntime*>(arg);
25087: 
25087:     // Lock lasts until we return
25087:     AutoLockJSGC lock(self->mJSRuntime);
25087: 
50462:     PRIntervalTime sleepInterval;
25087:     while (self->mWatchdogThread)
25087:     {
50462:         // Sleep only 1 second if recently (or currently) active; otherwise, hibernate
50462:         if (self->mLastActiveTime == -1 || PR_Now() - self->mLastActiveTime <= 2*PR_USEC_PER_SEC)
50462:             sleepInterval = PR_TicksPerSecond();
50462:         else
50462:         {
50462:             sleepInterval = PR_INTERVAL_NO_TIMEOUT;
50462:             self->mWatchdogHibernating = PR_TRUE;
50462:         }
25087: #ifdef DEBUG
25087:         PRStatus status =
25087: #endif
50462:             PR_WaitCondVar(self->mWatchdogWakeup, sleepInterval);
25087:         JS_ASSERT(status == PR_SUCCESS);
25087:         JSContext* cx = nsnull;
25087:         while((cx = js_NextActiveContext(self->mJSRuntime, cx)))
25087:         {
56559:             js::TriggerOperationCallback(cx);
25087:         }
25087:     }
25087: 
25087:     /* Wake up the main thread waiting for the watchdog to terminate. */
25087:     PR_NotifyCondVar(self->mWatchdogWakeup);
25087: }
25087: 
50462: //static
50462: void
50462: XPCJSRuntime::ActivityCallback(void *arg, PRBool active)
50462: {
50462:     XPCJSRuntime* self = static_cast<XPCJSRuntime*>(arg);
50462:     if (active) {
50462:         self->mLastActiveTime = -1;
50462:         if (self->mWatchdogHibernating)
50462:         {
50462:             self->mWatchdogHibernating = PR_FALSE;
50462:             PR_NotifyCondVar(self->mWatchdogWakeup);
50462:         }
50462:     } else {
50462:         self->mLastActiveTime = PR_Now();
50462:     }
50462: }
50462: 
25087: 
    1: /***************************************************************************/
    1: 
    1: #ifdef XPC_CHECK_WRAPPERS_AT_SHUTDOWN
18907: static JSDHashOperator
    1: DEBUG_WrapperChecker(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                      uint32 number, void *arg)
    1: {
    1:     XPCWrappedNative* wrapper = (XPCWrappedNative*)((JSDHashEntryStub*)hdr)->key;
    1:     NS_ASSERTION(!wrapper->IsValid(), "found a 'valid' wrapper!");
    1:     ++ *((int*)arg);
    1:     return JS_DHASH_NEXT;
    1: }
    1: #endif
    1: 
18907: static JSDHashOperator
    1: WrappedJSShutdownMarker(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                         uint32 number, void *arg)
    1: {
    1:     JSRuntime* rt = (JSRuntime*) arg;
    1:     nsXPCWrappedJS* wrapper = ((JSObject2WrappedJSMap::Entry*)hdr)->value;
    1:     NS_ASSERTION(wrapper, "found a null JS wrapper!");
    1:     NS_ASSERTION(wrapper->IsValid(), "found an invalid JS wrapper!");
    1:     wrapper->SystemIsBeingShutDown(rt);
    1:     return JS_DHASH_NEXT;
    1: }
    1: 
18907: static JSDHashOperator
    1: DetachedWrappedNativeProtoShutdownMarker(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                                          uint32 number, void *arg)
    1: {
    1:     XPCWrappedNativeProto* proto = 
    1:         (XPCWrappedNativeProto*)((JSDHashEntryStub*)hdr)->key;
    1: 
 2991:     proto->SystemIsBeingShutDown((JSContext*)arg);
    1:     return JS_DHASH_NEXT;
    1: }
    1: 
 2991: void XPCJSRuntime::SystemIsBeingShutDown(JSContext* cx)
    1: {
22842:     DOM_ClearInterfaces();
22842: 
    1:     if(mDetachedWrappedNativeProtoMap)
    1:         mDetachedWrappedNativeProtoMap->
 2991:             Enumerate(DetachedWrappedNativeProtoShutdownMarker, cx);
    1: }
    1: 
    1: XPCJSRuntime::~XPCJSRuntime()
    1: {
25087:     if (mWatchdogWakeup)
25087:     {
25087:         // If the watchdog thread is running, tell it to terminate waking it
25087:         // up if necessary and wait until it signals that it finished. As we
25087:         // must release the lock before calling PR_DestroyCondVar, we use an
25087:         // extra block here.
25087:         {
25087:             AutoLockJSGC lock(mJSRuntime);
25087:             if (mWatchdogThread) {
25087:                 mWatchdogThread = nsnull;
25087:                 PR_NotifyCondVar(mWatchdogWakeup);
25087:                 PR_WaitCondVar(mWatchdogWakeup, PR_INTERVAL_NO_TIMEOUT);
25087:             }
25087:         }
25087:         PR_DestroyCondVar(mWatchdogWakeup);
25087:         mWatchdogWakeup = nsnull;
25087:     }
25087: 
    1: #ifdef XPC_DUMP_AT_SHUTDOWN
    1:     {
    1:     // count the total JSContexts in use
    1:     JSContext* iter = nsnull;
    1:     int count = 0;
    1:     while(JS_ContextIterator(mJSRuntime, &iter))
    1:         count ++;
    1:     if(count)
    1:         printf("deleting XPCJSRuntime with %d live JSContexts\n", count);
    1:     }
    1: #endif
    1: 
    1:     // clean up and destroy maps...
    1:     if(mWrappedJSMap)
    1:     {
    1: #ifdef XPC_DUMP_AT_SHUTDOWN
    1:         uint32 count = mWrappedJSMap->Count();
    1:         if(count)
    1:             printf("deleting XPCJSRuntime with %d live wrapped JSObject\n", (int)count);
    1: #endif
    1:         mWrappedJSMap->Enumerate(WrappedJSShutdownMarker, mJSRuntime);
    1:         delete mWrappedJSMap;
    1:     }
    1: 
    1:     if(mWrappedJSClassMap)
    1:     {
    1: #ifdef XPC_DUMP_AT_SHUTDOWN
    1:         uint32 count = mWrappedJSClassMap->Count();
    1:         if(count)
    1:             printf("deleting XPCJSRuntime with %d live nsXPCWrappedJSClass\n", (int)count);
    1: #endif
    1:         delete mWrappedJSClassMap;
    1:     }
    1: 
    1:     if(mIID2NativeInterfaceMap)
    1:     {
    1: #ifdef XPC_DUMP_AT_SHUTDOWN
    1:         uint32 count = mIID2NativeInterfaceMap->Count();
    1:         if(count)
    1:             printf("deleting XPCJSRuntime with %d live XPCNativeInterfaces\n", (int)count);
    1: #endif
    1:         delete mIID2NativeInterfaceMap;
    1:     }
    1: 
    1:     if(mClassInfo2NativeSetMap)
    1:     {
    1: #ifdef XPC_DUMP_AT_SHUTDOWN
    1:         uint32 count = mClassInfo2NativeSetMap->Count();
    1:         if(count)
    1:             printf("deleting XPCJSRuntime with %d live XPCNativeSets\n", (int)count);
    1: #endif
    1:         delete mClassInfo2NativeSetMap;
    1:     }
    1: 
    1:     if(mNativeSetMap)
    1:     {
    1: #ifdef XPC_DUMP_AT_SHUTDOWN
    1:         uint32 count = mNativeSetMap->Count();
    1:         if(count)
    1:             printf("deleting XPCJSRuntime with %d live XPCNativeSets\n", (int)count);
    1: #endif
    1:         delete mNativeSetMap;
    1:     }
    1: 
    1:     if(mMapLock)
    1:         XPCAutoLock::DestroyLock(mMapLock);
    1: 
    1:     if(mThisTranslatorMap)
    1:     {
    1: #ifdef XPC_DUMP_AT_SHUTDOWN
    1:         uint32 count = mThisTranslatorMap->Count();
    1:         if(count)
    1:             printf("deleting XPCJSRuntime with %d live ThisTranslator\n", (int)count);
    1: #endif
    1:         delete mThisTranslatorMap;
    1:     }
    1: 
    1: #ifdef XPC_CHECK_WRAPPERS_AT_SHUTDOWN
    1:     if(DEBUG_WrappedNativeHashtable)
    1:     {
    1:         int LiveWrapperCount = 0;
    1:         JS_DHashTableEnumerate(DEBUG_WrappedNativeHashtable,
    1:                                DEBUG_WrapperChecker, &LiveWrapperCount);
    1:         if(LiveWrapperCount)
    1:             printf("deleting XPCJSRuntime with %d live XPCWrappedNative (found in wrapper check)\n", (int)LiveWrapperCount);
    1:         JS_DHashTableDestroy(DEBUG_WrappedNativeHashtable);
    1:     }
    1: #endif
    1: 
    1:     if(mNativeScriptableSharedMap)
    1:     {
    1: #ifdef XPC_DUMP_AT_SHUTDOWN
    1:         uint32 count = mNativeScriptableSharedMap->Count();
    1:         if(count)
    1:             printf("deleting XPCJSRuntime with %d live XPCNativeScriptableShared\n", (int)count);
    1: #endif
    1:         delete mNativeScriptableSharedMap;
    1:     }
    1: 
    1:     if(mDyingWrappedNativeProtoMap)
    1:     {
    1: #ifdef XPC_DUMP_AT_SHUTDOWN
    1:         uint32 count = mDyingWrappedNativeProtoMap->Count();
    1:         if(count)
    1:             printf("deleting XPCJSRuntime with %d live but dying XPCWrappedNativeProto\n", (int)count);
    1: #endif
    1:         delete mDyingWrappedNativeProtoMap;
    1:     }
    1: 
    1:     if(mDetachedWrappedNativeProtoMap)
    1:     {
    1: #ifdef XPC_DUMP_AT_SHUTDOWN
    1:         uint32 count = mDetachedWrappedNativeProtoMap->Count();
    1:         if(count)
    1:             printf("deleting XPCJSRuntime with %d live detached XPCWrappedNativeProto\n", (int)count);
    1: #endif
    1:         delete mDetachedWrappedNativeProtoMap;
    1:     }
    1: 
    1:     if(mExplicitNativeWrapperMap)
    1:     {
    1: #ifdef XPC_DUMP_AT_SHUTDOWN
    1:         uint32 count = mExplicitNativeWrapperMap->Count();
    1:         if(count)
    1:             printf("deleting XPCJSRuntime with %d live explicit XPCNativeWrapper\n", (int)count);
    1: #endif
    1:         delete mExplicitNativeWrapperMap;
    1:     }
    1: 
    1:     // unwire the readable/JSString sharing magic
    1:     XPCStringConvert::ShutdownDOMStringFinalizer();
    1: 
    1:     XPCConvert::RemoveXPCOMUCStringFinalizer();
    1: 
 7230:     if(mJSHolders.ops)
 7230:     {
 7230:         JS_DHashTableFinish(&mJSHolders);
 7230:         mJSHolders.ops = nsnull;
 7230:     }
20312: 
20312:     if(mJSRuntime)
20312:     {
20312:         JS_DestroyRuntime(mJSRuntime);
20312:         JS_ShutDown();
20312: #ifdef DEBUG_shaver_off
20312:         fprintf(stderr, "nJRSI: destroyed runtime %p\n", (void *)mJSRuntime);
20312: #endif
    1:     }
    1: 
20312:     XPCPerThreadData::ShutDown();
20312: }
20312: 
47427: class XPConnectGCChunkAllocator
47427:     : public js::GCChunkAllocator
47427: {
47427: public:
47427:     XPConnectGCChunkAllocator() {}
47427: 
47427:     static PRInt64 GetGCChunkBytesInUse(void *data) {
47427:         XPConnectGCChunkAllocator *allocator =
47427:             static_cast<XPConnectGCChunkAllocator*>(data);
47427:         return allocator->mNumGCChunksInUse * js::GC_CHUNK_SIZE;
47427:     }
47427: private:
47427:     virtual void *doAlloc() {
56946:         void *chunk;
47427: #ifdef MOZ_MEMORY
56946:         // posix_memalign returns zero on success, nonzero on failure.
56946:         if (posix_memalign(&chunk, js::GC_CHUNK_SIZE, js::GC_CHUNK_SIZE))
56946:             chunk = 0;
47427: #else
47427:         chunk = js::AllocGCChunk();
47427: #endif
47427:         if (chunk)
47427:             mNumGCChunksInUse++;
47427:         return chunk;
47427:     }
47427: 
47427:     virtual void doFree(void *chunk) {
47427:         mNumGCChunksInUse--;
47427: #ifdef MOZ_MEMORY
47427:         free(chunk);
47427: #else
47427:         js::FreeGCChunk(chunk);
47427: #endif
47427:     }
47427: 
47427: protected:
47427:     PRUint32 mNumGCChunksInUse;
47427: };
47427: 
47427: static XPConnectGCChunkAllocator gXPCJSChunkAllocator;
47427: 
47427: NS_MEMORY_REPORTER_IMPLEMENT(XPConnectJSRuntimeGCChunks,
60207:                              "js/gc-heap",
60207:                              "Main JS GC heap",
47427:                              XPConnectGCChunkAllocator::GetGCChunkBytesInUse,
47427:                              &gXPCJSChunkAllocator)
47427: 
60207: /* FIXME: use API provided by bug 623271 */
60207: #include "jscntxt.h"
60207: 
60207: static PRInt64
60207: GetJSMethodJitCodeMemoryInUse(void *data)
60207: {
60207:     JSRuntime *rt = nsXPConnect::GetRuntimeInstance()->GetJSRuntime();
60207: #ifdef JS_METHODJIT
60207:     return rt->mjitMemoryUsed;
60207: #else
60207:     return 0;
60207: #endif
60207: }
60207: 
60207: NS_MEMORY_REPORTER_IMPLEMENT(XPConnectJSMethodJitCode,
60207:                              "js/mjit-code",
60207:                              "Memory in use by method-JIT for compiled code",
60207:                              GetJSMethodJitCodeMemoryInUse,
60207:                              NULL)
60207: 
60215: static PRInt64
60215: GetJSStringMemoryInUse(void *data)
60215: {
60215:     JSRuntime *rt = nsXPConnect::GetRuntimeInstance()->GetJSRuntime();
60215:     return rt->stringMemoryUsed;
60215: }
60215: 
60215: NS_MEMORY_REPORTER_IMPLEMENT(XPConnectJSStringMemory,
60215:                              "js/string-data",
60215:                              "Memory in use for string data",
60215:                              GetJSStringMemoryInUse,
60215:                              NULL)
60215: 
20312: XPCJSRuntime::XPCJSRuntime(nsXPConnect* aXPConnect)
    1:  : mXPConnect(aXPConnect),
    1:    mJSRuntime(nsnull),
    1:    mWrappedJSMap(JSObject2WrappedJSMap::newMap(XPC_JS_MAP_SIZE)),
    1:    mWrappedJSClassMap(IID2WrappedJSClassMap::newMap(XPC_JS_CLASS_MAP_SIZE)),
    1:    mIID2NativeInterfaceMap(IID2NativeInterfaceMap::newMap(XPC_NATIVE_INTERFACE_MAP_SIZE)),
    1:    mClassInfo2NativeSetMap(ClassInfo2NativeSetMap::newMap(XPC_NATIVE_SET_MAP_SIZE)),
    1:    mNativeSetMap(NativeSetMap::newMap(XPC_NATIVE_SET_MAP_SIZE)),
    1:    mThisTranslatorMap(IID2ThisTranslatorMap::newMap(XPC_THIS_TRANSLATOR_MAP_SIZE)),
    1:    mNativeScriptableSharedMap(XPCNativeScriptableSharedMap::newMap(XPC_NATIVE_JSCLASS_MAP_SIZE)),
    1:    mDyingWrappedNativeProtoMap(XPCWrappedNativeProtoMap::newMap(XPC_DYING_NATIVE_PROTO_MAP_SIZE)),
    1:    mDetachedWrappedNativeProtoMap(XPCWrappedNativeProtoMap::newMap(XPC_DETACHED_NATIVE_PROTO_MAP_SIZE)),
    1:    mExplicitNativeWrapperMap(XPCNativeWrapperMap::newMap(XPC_NATIVE_WRAPPER_MAP_SIZE)),
    1:    mMapLock(XPCAutoLock::NewLock("XPCJSRuntime::mMapLock")),
    1:    mThreadRunningGC(nsnull),
    1:    mWrappedJSToReleaseArray(),
    1:    mNativesToReleaseArray(),
 2072:    mDoingFinalization(JS_FALSE),
 2072:    mVariantRoots(nsnull),
 2072:    mWrappedJSRoots(nsnull),
22795:    mObjectHolderRoots(nsnull),
25087:    mWatchdogWakeup(nsnull),
50462:    mWatchdogThread(nsnull),
50462:    mWatchdogHibernating(PR_FALSE),
50462:    mLastActiveTime(-1)
    1: {
    1: #ifdef XPC_CHECK_WRAPPERS_AT_SHUTDOWN
    1:     DEBUG_WrappedNativeHashtable =
    1:         JS_NewDHashTable(JS_DHashGetStubOps(), nsnull,
    1:                          sizeof(JSDHashEntryStub), 128);
    1: #endif
42480:     NS_TIME_FUNCTION;
    1: 
22842:     DOM_InitInterfaces();
22842: 
    1:     // these jsids filled in later when we have a JSContext to work with.
48470:     mStrIDs[0] = JSID_VOID;
    1: 
20312:     mJSRuntime = JS_NewRuntime(32L * 1024L * 1024L); // pref ?
62680:     if (!mJSRuntime)
62680:         NS_RUNTIMEABORT("JS_NewRuntime failed.");
62680: 
    1:     {
20312:         // Unconstrain the runtime's threshold on nominal heap size, to avoid
20312:         // triggering GC too often if operating continuously near an arbitrary
20312:         // finite threshold (0xffffffff is infinity for uint32 parameters).
20312:         // This leaves the maximum-JS_malloc-bytes threshold still in effect
20312:         // to cause period, and we hope hygienic, last-ditch GCs from within
20312:         // the GC's allocator.
20312:         JS_SetGCParameter(mJSRuntime, JSGC_MAX_BYTES, 0xffffffff);
20312:         JS_SetContextCallback(mJSRuntime, ContextCallback);
48503:         JS_SetCompartmentCallback(mJSRuntime, CompartmentCallback);
20312:         JS_SetGCCallbackRT(mJSRuntime, GCCallback);
 1476:         JS_SetExtraGCRoots(mJSRuntime, TraceJS, this);
55628:         JS_SetWrapObjectCallbacks(mJSRuntime,
55628:                                   xpc::WrapperFactory::Rewrap,
55628:                                   xpc::WrapperFactory::PrepareForWrapping);
25087:         mWatchdogWakeup = JS_NEW_CONDVAR(mJSRuntime->gcLock);
62680:         if (!mWatchdogWakeup)
62680:             NS_RUNTIMEABORT("JS_NEW_CONDVAR failed.");
47427: 
50462:         mJSRuntime->setActivityCallback(ActivityCallback, this);
50462: 
47427:         mJSRuntime->setCustomGCChunkAllocator(&gXPCJSChunkAllocator);
47427: 
47427:         NS_RegisterMemoryReporter(new NS_MEMORY_REPORTER_NAME(XPConnectJSRuntimeGCChunks));
60215:         NS_RegisterMemoryReporter(new NS_MEMORY_REPORTER_NAME(XPConnectJSStringMemory));
60207:         NS_RegisterMemoryReporter(new NS_MEMORY_REPORTER_NAME(XPConnectJSMethodJitCode));
    1:     }
    1: 
 7230:     if(!JS_DHashTableInit(&mJSHolders, JS_DHashGetStubOps(), nsnull,
 7230:                           sizeof(ObjectHolder), 512))
 7230:         mJSHolders.ops = nsnull;
 7230: 
48503:     mCompartmentMap.Init();
56703:     mMTCompartmentMap.Init();
48503: 
    1:     // Install a JavaScript 'debugger' keyword handler in debug builds only
    1: #ifdef DEBUG
 2433:     if(mJSRuntime && !JS_GetGlobalDebugHooks(mJSRuntime)->debuggerHandler)
    1:         xpc_InstallJSDebuggerKeywordHandler(mJSRuntime);
    1: #endif
25087: 
30576:     if (mWatchdogWakeup) {
25087:         AutoLockJSGC lock(mJSRuntime);
25087: 
25087:         mWatchdogThread = PR_CreateThread(PR_USER_THREAD, WatchdogMain, this,
25087:                                           PR_PRIORITY_NORMAL, PR_LOCAL_THREAD,
25087:                                           PR_UNJOINABLE_THREAD, 0);
62680:         if (!mWatchdogThread)
62680:             NS_RUNTIMEABORT("PR_CreateThread failed!");
    1:     }
30576: }
    1: 
    1: // static
    1: XPCJSRuntime*
20312: XPCJSRuntime::newXPCJSRuntime(nsXPConnect* aXPConnect)
    1: {
    1:     NS_PRECONDITION(aXPConnect,"bad param");
    1: 
20312:     XPCJSRuntime* self = new XPCJSRuntime(aXPConnect);
    1: 
    1:     if(self                                  &&
    1:        self->GetJSRuntime()                  &&
    1:        self->GetWrappedJSMap()               &&
    1:        self->GetWrappedJSClassMap()          &&
    1:        self->GetIID2NativeInterfaceMap()     &&
    1:        self->GetClassInfo2NativeSetMap()     &&
    1:        self->GetNativeSetMap()               &&
    1:        self->GetThisTranslatorMap()          &&
    1:        self->GetNativeScriptableSharedMap()  &&
    1:        self->GetDyingWrappedNativeProtoMap() &&
    1:        self->GetExplicitNativeWrapperMap()   &&
25087:        self->GetMapLock()                    &&
25087:        self->mWatchdogThread)
    1:     {
    1:         return self;
    1:     }
62680: 
62680:     NS_RUNTIMEABORT("new XPCJSRuntime failed to initialize.");
62680: 
    1:     delete self;
    1:     return nsnull;
    1: }
    1: 
20312: JSBool
20312: XPCJSRuntime::OnJSContextNew(JSContext *cx)
    1: {
42480:     NS_TIME_FUNCTION;
42480: 
    1:     // if it is our first context then we need to generate our string ids
20312:     JSBool ok = JS_TRUE;
48470:     if(JSID_IS_VOID(mStrIDs[0]))
    1:     {
27884:         JS_SetGCParameterForThread(cx, JSGC_MAX_CODE_CACHE_BYTES, 16 * 1024 * 1024);
20312:         JSAutoRequest ar(cx);
    1:         for(uintN i = 0; i < IDX_TOTAL_COUNT; i++)
    1:         {
    1:             JSString* str = JS_InternString(cx, mStrings[i]);
    1:             if(!str || !JS_ValueToId(cx, STRING_TO_JSVAL(str), &mStrIDs[i]))
    1:             {
48470:                 mStrIDs[0] = JSID_VOID;
20312:                 ok = JS_FALSE;
20312:                 break;
    1:             }
    1:             mStrJSVals[i] = STRING_TO_JSVAL(str);
    1:         }
20312:     }
20312:     if (!ok)
20312:         return JS_FALSE;
20312: 
20312:     XPCPerThreadData* tls = XPCPerThreadData::GetData(cx);
20312:     if(!tls)
20312:         return JS_FALSE;
20312: 
20312:     XPCContext* xpc = new XPCContext(this, cx);
20312:     if (!xpc)
20312:         return JS_FALSE;
20312: 
47994:     JS_SetNativeStackQuota(cx, 128 * sizeof(size_t) * 1024);
58047:     PRInt64 totalMemory = PR_GetPhysicalMemorySize();
62408:     size_t quota = PR_MIN(PR_UINT32_MAX, PR_MAX(25 * sizeof(size_t) * 1024 * 1024,
58047:                                                 totalMemory / 4));
62408:     JS_SetScriptStackQuota(cx, quota);
48479: 
48479:     // we want to mark the global object ourselves since we use a different color
48479:     JS_ToggleOptions(cx, JSOPTION_UNROOTED_GLOBAL);
48479: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSBool
    1: XPCJSRuntime::DeferredRelease(nsISupports* obj)
    1: {
    1:     NS_ASSERTION(obj, "bad param");
    1: 
26582:     if(mNativesToReleaseArray.IsEmpty())
    1:     {
    1:         // This array sometimes has 1000's
    1:         // of entries, and usually has 50-200 entries. Avoid lots
    1:         // of incremental grows.  We compact it down when we're done.
26582:         mNativesToReleaseArray.SetCapacity(256);
    1:     }
26582:     return mNativesToReleaseArray.AppendElement(obj) != nsnull;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: #ifdef DEBUG
18907: static JSDHashOperator
    1: WrappedJSClassMapDumpEnumerator(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                                 uint32 number, void *arg)
    1: {
    1:     ((IID2WrappedJSClassMap::Entry*)hdr)->value->DebugDump(*(PRInt16*)arg);
    1:     return JS_DHASH_NEXT;
    1: }
18907: static JSDHashOperator
    1: WrappedJSMapDumpEnumerator(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                            uint32 number, void *arg)
    1: {
    1:     ((JSObject2WrappedJSMap::Entry*)hdr)->value->DebugDump(*(PRInt16*)arg);
    1:     return JS_DHASH_NEXT;
    1: }
18907: static JSDHashOperator
    1: NativeSetDumpEnumerator(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                         uint32 number, void *arg)
    1: {
    1:     ((NativeSetMap::Entry*)hdr)->key_value->DebugDump(*(PRInt16*)arg);
    1:     return JS_DHASH_NEXT;
    1: }
    1: #endif
    1: 
    1: void
    1: XPCJSRuntime::DebugDump(PRInt16 depth)
    1: {
    1: #ifdef DEBUG
    1:     depth--;
    1:     XPC_LOG_ALWAYS(("XPCJSRuntime @ %x", this));
    1:         XPC_LOG_INDENT();
    1:         XPC_LOG_ALWAYS(("mXPConnect @ %x", mXPConnect));
    1:         XPC_LOG_ALWAYS(("mJSRuntime @ %x", mJSRuntime));
    1:         XPC_LOG_ALWAYS(("mMapLock @ %x", mMapLock));
    1: 
    1:         XPC_LOG_ALWAYS(("mWrappedJSToReleaseArray @ %x with %d wrappers(s)", \
    1:                          &mWrappedJSToReleaseArray,
26582:                          mWrappedJSToReleaseArray.Length()));
    1: 
20312:         int cxCount = 0;
20312:         JSContext* iter = nsnull;
20312:         while(JS_ContextIterator(mJSRuntime, &iter))
20312:             ++cxCount;
20312:         XPC_LOG_ALWAYS(("%d JS context(s)", cxCount));
20312: 
20312:         iter = nsnull;
20312:         while(JS_ContextIterator(mJSRuntime, &iter))
    1:         {
20312:             XPCContext *xpc = XPCContext::GetXPCContext(iter);
    1:             XPC_LOG_INDENT();
20312:             xpc->DebugDump(depth);
    1:             XPC_LOG_OUTDENT();
    1:         }
    1: 
    1:         XPC_LOG_ALWAYS(("mWrappedJSClassMap @ %x with %d wrapperclasses(s)", \
    1:                          mWrappedJSClassMap, mWrappedJSClassMap ? \
    1:                                             mWrappedJSClassMap->Count() : 0));
    1:         // iterate wrappersclasses...
    1:         if(depth && mWrappedJSClassMap && mWrappedJSClassMap->Count())
    1:         {
    1:             XPC_LOG_INDENT();
    1:             mWrappedJSClassMap->Enumerate(WrappedJSClassMapDumpEnumerator, &depth);
    1:             XPC_LOG_OUTDENT();
    1:         }
    1:         XPC_LOG_ALWAYS(("mWrappedJSMap @ %x with %d wrappers(s)", \
    1:                          mWrappedJSMap, mWrappedJSMap ? \
    1:                                             mWrappedJSMap->Count() : 0));
    1:         // iterate wrappers...
    1:         if(depth && mWrappedJSMap && mWrappedJSMap->Count())
    1:         {
    1:             XPC_LOG_INDENT();
    1:             mWrappedJSMap->Enumerate(WrappedJSMapDumpEnumerator, &depth);
    1:             XPC_LOG_OUTDENT();
    1:         }
    1: 
    1:         XPC_LOG_ALWAYS(("mIID2NativeInterfaceMap @ %x with %d interface(s)", \
    1:                          mIID2NativeInterfaceMap, mIID2NativeInterfaceMap ? \
    1:                                     mIID2NativeInterfaceMap->Count() : 0));
    1: 
    1:         XPC_LOG_ALWAYS(("mClassInfo2NativeSetMap @ %x with %d sets(s)", \
    1:                          mClassInfo2NativeSetMap, mClassInfo2NativeSetMap ? \
    1:                                     mClassInfo2NativeSetMap->Count() : 0));
    1: 
    1:         XPC_LOG_ALWAYS(("mThisTranslatorMap @ %x with %d translator(s)", \
    1:                          mThisTranslatorMap, mThisTranslatorMap ? \
    1:                                     mThisTranslatorMap->Count() : 0));
    1: 
    1:         XPC_LOG_ALWAYS(("mNativeSetMap @ %x with %d sets(s)", \
    1:                          mNativeSetMap, mNativeSetMap ? \
    1:                                     mNativeSetMap->Count() : 0));
    1: 
    1:         // iterate sets...
    1:         if(depth && mNativeSetMap && mNativeSetMap->Count())
    1:         {
    1:             XPC_LOG_INDENT();
    1:             mNativeSetMap->Enumerate(NativeSetDumpEnumerator, &depth);
    1:             XPC_LOG_OUTDENT();
    1:         }
    1: 
    1:         XPC_LOG_OUTDENT();
    1: #endif
    1: }
    1: 
 2072: /***************************************************************************/
 2072: 
 2072: void
57794: XPCRootSetElem::AddToRootSet(XPCLock *lock, XPCRootSetElem **listHead)
 2072: {
 2072:     NS_ASSERTION(!mSelfp, "Must be not linked");
25087: 
57794:     XPCAutoLock autoLock(lock);
57794: 
 2072:     mSelfp = listHead;
 2072:     mNext = *listHead;
 2072:     if(mNext)
 2072:     {
 2072:         NS_ASSERTION(mNext->mSelfp == listHead, "Must be list start");
 2072:         mNext->mSelfp = &mNext;
 2072:     }
 2072:     *listHead = this;
 2072: }
 2072: 
 2072: void
57794: XPCRootSetElem::RemoveFromRootSet(XPCLock *lock)
 2072: {
 2072:     NS_ASSERTION(mSelfp, "Must be linked");
25087: 
57794:     XPCAutoLock autoLock(lock);
57794: 
 2072:     NS_ASSERTION(*mSelfp == this, "Link invariant");
 2072:     *mSelfp = mNext;
 2072:     if(mNext)
 2072:         mNext->mSelfp = mSelfp;
 2072: #ifdef DEBUG
 2072:     mSelfp = nsnull;
 2072:     mNext = nsnull;
 2072: #endif
 2072: }
36094: 
36094: void
36094: XPCJSRuntime::AddGCCallback(JSGCCallback cb)
36094: {
36094:     NS_ASSERTION(cb, "null callback");
36094:     extraGCCallbacks.AppendElement(cb);
36094: }
36094: 
36094: void
36094: XPCJSRuntime::RemoveGCCallback(JSGCCallback cb)
36094: {
36094:     NS_ASSERTION(cb, "null callback");
36094:     PRBool found = extraGCCallbacks.RemoveElement(cb);
36094:     if (!found) {
36094:         NS_ERROR("Removing a callback which was never added.");
36094:     }
36094: }
