    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2003
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Original Author: Aaron Leventhal (aaronl@netscape.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsAccessibleWrap.h"
    1: #include "nsAccessibilityAtoms.h"
  563: 
  563: #include "nsIAccessibleDocument.h"
    1: #include "nsIAccessibleSelectable.h"
  563: #include "nsIAccessibleEvent.h"
    1: #include "nsIAccessibleWin32Object.h"
    1: 
    1: #include "Accessible2_i.c"
    1: #include "AccessibleStates.h"
    1: 
    1: #include "nsIMutableArray.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIFrame.h"
    1: #include "nsIScrollableFrame.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsINodeInfo.h"
    1: #include "nsIPrefService.h"
 1249: #include "nsRootAccessible.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsTextFormatter.h"
    1: #include "nsIView.h"
    1: #include "nsRoleMap.h"
  563: #include "nsEventMap.h"
    1: #include "nsArrayUtils.h"
    1: 
    1: /* For documentation of the accessibility architecture,
    1:  * see http://lxr.mozilla.org/seamonkey/source/accessible/accessible-docs.html
    1:  */
    1: 
    1: //#define DEBUG_LEAKS
    1: 
    1: #ifdef DEBUG_LEAKS
    1: static gAccessibles = 0;
    1: #endif
    1: 
    1: EXTERN_C GUID CDECL CLSID_Accessible =
    1: { 0x61044601, 0xa811, 0x4e2b, { 0xbb, 0xba, 0x17, 0xbf, 0xab, 0xd3, 0x29, 0xd7 } };
    1: 
15720: static const PRInt32 kIEnumVariantDisconnected = -1;
15720: 
    1: /*
    1:  * Class nsAccessibleWrap
    1:  */
    1: 
    1: //-----------------------------------------------------
    1: // construction
    1: //-----------------------------------------------------
    1: nsAccessibleWrap::nsAccessibleWrap(nsIDOMNode* aNode, nsIWeakReference *aShell):
    1:   nsAccessible(aNode, aShell), mEnumVARIANTPosition(0)
    1: {
    1: }
    1: 
    1: //-----------------------------------------------------
    1: // destruction
    1: //-----------------------------------------------------
    1: nsAccessibleWrap::~nsAccessibleWrap()
    1: {
    1: }
    1: 
  966: NS_IMPL_ISUPPORTS_INHERITED0(nsAccessibleWrap, nsAccessible);
  966: 
    1: //-----------------------------------------------------
    1: // IUnknown interface methods - see iunknown.h for documentation
    1: //-----------------------------------------------------
    1: 
    1: // Microsoft COM QueryInterface
    1: STDMETHODIMP nsAccessibleWrap::QueryInterface(REFIID iid, void** ppv)
    1: {
11440: __try {
    1:   *ppv = NULL;
    1: 
    1:   if (IID_IUnknown == iid || IID_IDispatch == iid || IID_IAccessible == iid)
 3233:     *ppv = static_cast<IAccessible*>(this);
    1:   else if (IID_IEnumVARIANT == iid && !gIsEnumVariantSupportDisabled) {
    1:     long numChildren;
    1:     get_accChildCount(&numChildren);
    1:     if (numChildren > 0)  // Don't support this interface for leaf elements
 3233:       *ppv = static_cast<IEnumVARIANT*>(this);
    1:   } else if (IID_IServiceProvider == iid)
 3233:     *ppv = static_cast<IServiceProvider*>(this);
16515:   else if (IID_IAccessible2 == iid && !gIsIA2Disabled)
 3233:     *ppv = static_cast<IAccessible2*>(this);
 1507: 
 1507:   if (NULL == *ppv) {
 1509:     HRESULT hr = CAccessibleComponent::QueryInterface(iid, ppv);
 1509:     if (SUCCEEDED(hr))
 1509:       return hr;
 1509:   }
 1509: 
 1509:   if (NULL == *ppv) {
 1507:     HRESULT hr = CAccessibleHyperlink::QueryInterface(iid, ppv);
 1507:     if (SUCCEEDED(hr))
 1507:       return hr;
 1507:   }
    1: 
 1304:   if (NULL == *ppv) {
 1304:     HRESULT hr = CAccessibleValue::QueryInterface(iid, ppv);
 1304:     if (SUCCEEDED(hr))
 1304:       return hr;
 1304:   }
 1304: 
    1:   if (NULL == *ppv)
    1:     return nsAccessNodeWrap::QueryInterface(iid, ppv);
    1: 
 3233:   (reinterpret_cast<IUnknown*>(*ppv))->AddRef();
11440: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1:   return S_OK;
    1: }
    1: 
    1: //-----------------------------------------------------
    1: // IAccessible methods
    1: //-----------------------------------------------------
    1: 
    1: 
    1: STDMETHODIMP nsAccessibleWrap::AccessibleObjectFromWindow(HWND hwnd,
    1:                                                           DWORD dwObjectID,
    1:                                                           REFIID riid,
    1:                                                           void **ppvObject)
    1: {
    1:   // open the dll dynamically
    1:   if (!gmAccLib)
18477:     gmAccLib =::LoadLibraryW(L"OLEACC.DLL");
    1: 
    1:   if (gmAccLib) {
    1:     if (!gmAccessibleObjectFromWindow)
    1:       gmAccessibleObjectFromWindow = (LPFNACCESSIBLEOBJECTFROMWINDOW)GetProcAddress(gmAccLib,"AccessibleObjectFromWindow");
    1: 
    1:     if (gmAccessibleObjectFromWindow)
    1:       return gmAccessibleObjectFromWindow(hwnd, dwObjectID, riid, ppvObject);
    1:   }
    1: 
    1:   return E_FAIL;
    1: }
    1: 
    1: STDMETHODIMP nsAccessibleWrap::NotifyWinEvent(DWORD event,
    1:                                               HWND hwnd,
    1:                                               LONG idObjectType,
    1:                                               LONG idObject)
    1: {
    1:   if (gmNotifyWinEvent)
    1:     return gmNotifyWinEvent(event, hwnd, idObjectType, idObject);
    1: 
    1:   return E_FAIL;
    1: }
    1: 
    1: STDMETHODIMP nsAccessibleWrap::get_accParent( IDispatch __RPC_FAR *__RPC_FAR *ppdispParent)
    1: {
11440: __try {
    1:   *ppdispParent = NULL;
    1:   if (!mWeakShell)
    1:     return E_FAIL;  // We've been shut down
    1: 
    1:   nsIFrame *frame = GetFrame();
    1:   HWND hwnd = 0;
    1:   if (frame) {
    1:     nsIView *view = frame->GetViewExternal();
    1:     if (view) {
    1:       // This code is essentially our implementation of WindowFromAccessibleObject,
    1:       // because MSAA iterates get_accParent() until it sees an object of ROLE_WINDOW
    1:       // to know where the window for a given accessible is. We must expose the native
    1:       // window accessible that MSAA creates for us. This must be done for the document
    1:       // object as well as any layout that creates its own window (e.g. via overflow: scroll)
    1:       nsIWidget *widget = view->GetWidget();
    1:       if (widget) {
    1:         hwnd = (HWND)widget->GetNativeData(NS_NATIVE_WINDOW);
    1:         NS_ASSERTION(hwnd, "No window handle for window");
29121: 
29121:         nsIViewManager* viewManager = view->GetViewManager();
29121:         if (!viewManager)
29121:           return E_UNEXPECTED;
29121: 
    1:         nsIView *rootView;
29121:         viewManager->GetRootView(rootView);
    1:         if (rootView == view) {
    1:           // If the current object has a widget but was created by an
    1:           // outer object with its own outer window, then
    1:           // we want the native accessible for that outer window
    1:           hwnd = ::GetParent(hwnd);
    1:           NS_ASSERTION(hwnd, "No window handle for window");
    1:         }
    1:       }
    1:       else {
    1:         // If a frame is a scrollable frame, then it has one window for the client area,
    1:         // not an extra parent window for just the scrollbars
23554:         nsIScrollableFrame *scrollFrame = do_QueryFrame(frame);
    1:         if (scrollFrame) {
    1:           hwnd = (HWND)scrollFrame->GetScrolledFrame()->GetWindow()->GetNativeData(NS_NATIVE_WINDOW);
    1:           NS_ASSERTION(hwnd, "No window handle for window");
    1:         }
    1:       }
    1:     }
    1: 
    1:     if (hwnd && SUCCEEDED(AccessibleObjectFromWindow(hwnd, OBJID_WINDOW, IID_IAccessible,
    1:                                               (void**)ppdispParent))) {
    1:       return S_OK;
    1:     }
    1:   }
    1: 
    1:   nsCOMPtr<nsIAccessible> xpParentAccessible(GetParent());
    1:   NS_ASSERTION(xpParentAccessible, "No parent accessible where we're not direct child of window");
    1:   if (!xpParentAccessible) {
    1:     return E_UNEXPECTED;
    1:   }
    1:   *ppdispParent = NativeAccessible(xpParentAccessible);
    1: 
11440: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1:   return S_OK;
    1: }
    1: 
    1: STDMETHODIMP nsAccessibleWrap::get_accChildCount( long __RPC_FAR *pcountChildren)
    1: {
11440: __try {
    1:   *pcountChildren = 0;
20566:   if (nsAccUtils::MustPrune(this))
    1:     return NS_OK;
    1: 
    1:   PRInt32 numChildren;
    1:   GetChildCount(&numChildren);
    1:   *pcountChildren = numChildren;
11440: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return S_OK;
    1: }
    1: 
    1: STDMETHODIMP nsAccessibleWrap::get_accChild(
    1:       /* [in] */ VARIANT varChild,
    1:       /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispChild)
    1: {
11440: __try {
    1:   *ppdispChild = NULL;
    1:   if (!mWeakShell || varChild.vt != VT_I4)
    1:     return E_FAIL;
    1: 
    1:   if (varChild.lVal == CHILDID_SELF) {
 3233:     *ppdispChild = static_cast<IDispatch*>(this);
    1:     AddRef();
    1:     return S_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIAccessible> childAccessible;
20566:   if (!nsAccUtils::MustPrune(this)) {
    1:     GetChildAt(varChild.lVal - 1, getter_AddRefs(childAccessible));
 1581:     if (childAccessible) {
    1:       *ppdispChild = NativeAccessible(childAccessible);
    1:     }
 1581:   }
11440: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return (*ppdispChild)? S_OK: E_FAIL;
    1: }
    1: 
    1: STDMETHODIMP nsAccessibleWrap::get_accName(
    1:       /* [optional][in] */ VARIANT varChild,
    1:       /* [retval][out] */ BSTR __RPC_FAR *pszName)
    1: {
11440: __try {
    1:   *pszName = NULL;
    1:   nsCOMPtr<nsIAccessible> xpAccessible;
    1:   GetXPAccessibleFor(varChild, getter_AddRefs(xpAccessible));
14656:   if (!xpAccessible)
14656:     return E_FAIL;
    1:   nsAutoString name;
14656:   nsresult rv = xpAccessible->GetName(name);
14656:   if (NS_FAILED(rv))
14656:     return GetHRESULT(rv);
14656:     
14656:   if (name.IsVoid()) {
14656:     // Valid return value for the name:
14656:     // The name was not provided, e.g. no alt attribute for an image.
14656:     // A screen reader may choose to invent its own accessible name, e.g. from
14656:     // an image src attribute.
14656:     // See nsHTMLImageAccessible::GetName()
14656:     return S_OK;
14656:   }
13128: 
13128:   *pszName = ::SysAllocStringLen(name.get(), name.Length());
13128:   if (!*pszName)
13128:     return E_OUTOFMEMORY;
13128: 
    1: #ifdef DEBUG_A11Y
    1:   NS_ASSERTION(mIsInitialized, "Access node was not initialized");
    1: #endif
11440: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return S_OK;
    1: }
    1: 
    1: 
    1: STDMETHODIMP nsAccessibleWrap::get_accValue(
    1:       /* [optional][in] */ VARIANT varChild,
    1:       /* [retval][out] */ BSTR __RPC_FAR *pszValue)
    1: {
11440: __try {
    1:   *pszValue = NULL;
    1:   nsCOMPtr<nsIAccessible> xpAccessible;
    1:   GetXPAccessibleFor(varChild, getter_AddRefs(xpAccessible));
    1:   if (xpAccessible) {
    1:     nsAutoString value;
13128:     if (NS_FAILED(xpAccessible->GetValue(value)))
13128:       return E_FAIL;
13128: 
15520:     // see bug 438784: Need to expose URL on doc's value attribute.
15520:     // For this, reverting part of fix for bug 425693 to make this MSAA method 
15520:     // behave IAccessible2-style.
15520:     if (value.IsEmpty())
15520:       return S_FALSE;
15520: 
13128:     *pszValue = ::SysAllocStringLen(value.get(), value.Length());
13128:     if (!*pszValue)
13128:       return E_OUTOFMEMORY;
    1:   }
11440: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1:   return S_OK;
    1: }
    1: 
  144: STDMETHODIMP
  144: nsAccessibleWrap::get_accDescription(VARIANT varChild,
  144:                                      BSTR __RPC_FAR *pszDescription)
    1: {
11440: __try {
  144:   *pszDescription = NULL;
11440: 
  144:   nsCOMPtr<nsIAccessible> xpAccessible;
  144:   GetXPAccessibleFor(varChild, getter_AddRefs(xpAccessible));
  144:   if (!xpAccessible)
  144:     return E_FAIL;
    1: 
  144:   // For items that are a choice in a list of choices, use MSAA description
  144:   // field to shoehorn positional info, it's becoming a defacto standard use for
  144:   // the field.
    1: 
  144:   nsAutoString description;
  144: 
 6099:   // Try to get group attributes to make a positional description string. We
 6099:   // can't use nsIAccessible::groupPosition because the method isn't supposed
 6099:   // to work with elements exposing 'level' attribute only (like HTML headings).
 6099:   nsCOMPtr<nsIPersistentProperties> attributes;
 6099:   nsresult rv = xpAccessible->GetAttributes(getter_AddRefs(attributes));
 6099:   NS_ENSURE_SUCCESS(rv, rv);
 6099:   if (!attributes)
 6099:     return NS_ERROR_FAILURE;
  144: 
 6099:   PRInt32 groupLevel = 0;
 6099:   PRInt32 itemsInGroup = 0;
 6099:   PRInt32 positionInGroup = 0;
20536:   nsAccUtils::GetAccGroupAttrs(attributes, &groupLevel, &positionInGroup,
 6099:                                &itemsInGroup);
 6099: 
  579:   if (positionInGroup > 0) {
  579:     if (groupLevel > 0) {
  401:       // XXX: How do we calculate the number of children? Now we append
  401:       // " with [numChildren]c" for tree item. In the future we may need to
  401:       // use the ARIA owns property to calculate that if it's present.
  401:       PRInt32 numChildren = 0;
  401: 
25822:       PRUint32 currentRole = nsAccUtils::Role(xpAccessible);
25822:       if (currentRole == nsIAccessibleRole::ROLE_OUTLINEITEM) {
  401:         nsCOMPtr<nsIAccessible> child;
  401:         xpAccessible->GetFirstChild(getter_AddRefs(child));
  401:         while (child) {
25822:           currentRole = nsAccUtils::Role(child);
  401:           if (currentRole == nsIAccessibleRole::ROLE_GROUPING) {
  401:             nsCOMPtr<nsIAccessible> groupChild;
  401:             child->GetFirstChild(getter_AddRefs(groupChild));
  401:             while (groupChild) {
25822:               currentRole = nsAccUtils::Role(groupChild);
  401:               numChildren +=
  401:                 (currentRole == nsIAccessibleRole::ROLE_OUTLINEITEM);
  401:               nsCOMPtr<nsIAccessible> nextGroupChild;
  401:               groupChild->GetNextSibling(getter_AddRefs(nextGroupChild));
  401:               groupChild.swap(nextGroupChild);
  401:             }
  401:             break;
  401:           }
  401:           nsCOMPtr<nsIAccessible> nextChild;
  401:           child->GetNextSibling(getter_AddRefs(nextChild));
  401:           child.swap(nextChild);
  401:         }
  401:       }
  401: 
  401:       if (numChildren) {
  401:         nsTextFormatter::ssprintf(description,
  401:                                   NS_LITERAL_STRING("L%d, %d of %d with %d").get(),
 6099:                                   groupLevel, positionInGroup, itemsInGroup,
 6099:                                   numChildren);
  401:       } else {
  144:         nsTextFormatter::ssprintf(description,
  144:                                   NS_LITERAL_STRING("L%d, %d of %d").get(),
 6099:                                   groupLevel, positionInGroup, itemsInGroup);
  401:       }
  144:     } else { // Position has no level
  144:       nsTextFormatter::ssprintf(description,
  144:                                 NS_LITERAL_STRING("%d of %d").get(),
 6099:                                 positionInGroup, itemsInGroup);
 6099:     }
 6099:   } else if (groupLevel > 0) {
 6099:     nsTextFormatter::ssprintf(description, NS_LITERAL_STRING("L%d").get(),
 6099:                               groupLevel);
    1:   }
  144: 
 6099:   if (!description.IsEmpty()) {
13128:     *pszDescription = ::SysAllocStringLen(description.get(),
13128:                                           description.Length());
13128:     return *pszDescription ? S_OK : E_OUTOFMEMORY;
    1:   }
    1: 
  144:   xpAccessible->GetDescription(description);
    1:   if (!description.IsEmpty()) {
    1:     // Signal to screen readers that this description is speakable
    1:     // and is not a formatted positional information description
    1:     // Don't localize the "Description: " part of this string, it will be
    1:     // parsed out by assistive technologies.
  144:     description = NS_LITERAL_STRING("Description: ") + description;
    1:   }
    1: 
13128:   *pszDescription = ::SysAllocStringLen(description.get(),
13128:                                         description.Length());
13128:   return *pszDescription ? S_OK : E_OUTOFMEMORY;
13128: 
11440: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
13128:   return E_FAIL;
    1: }
    1: 
    1: STDMETHODIMP nsAccessibleWrap::get_accRole(
    1:       /* [optional][in] */ VARIANT varChild,
    1:       /* [retval][out] */ VARIANT __RPC_FAR *pvarRole)
    1: {
11440: __try {
    1:   VariantInit(pvarRole);
    1: 
    1:   nsCOMPtr<nsIAccessible> xpAccessible;
    1:   GetXPAccessibleFor(varChild, getter_AddRefs(xpAccessible));
    1: 
    1:   if (!xpAccessible)
    1:     return E_FAIL;
    1: 
    1: #ifdef DEBUG_A11Y
20566:   NS_ASSERTION(nsAccUtils::IsTextInterfaceSupportCorrect(xpAccessible),
20566:                "Does not support nsIAccessibleText when it should");
    1: #endif
    1: 
    1:   PRUint32 xpRole = 0, msaaRole = 0;
25822:   if (NS_FAILED(xpAccessible->GetRole(&xpRole)))
    1:     return E_FAIL;
    1: 
    1:   msaaRole = gWindowsRoleMap[xpRole].msaaRole;
    1:   NS_ASSERTION(gWindowsRoleMap[nsIAccessibleRole::ROLE_LAST_ENTRY].msaaRole == ROLE_WINDOWS_LAST_ENTRY,
    1:                "MSAA role map skewed");
    1: 
 3122:   // Special case, if there is a ROLE_ROW inside of a ROLE_TREE_TABLE, then call the MSAA role
 3122:   // a ROLE_OUTLINEITEM for consistency and compatibility.
 3122:   // We need this because ARIA has a role of "row" for both grid and treegrid
 3122:   if (xpRole == nsIAccessibleRole::ROLE_ROW) {
 3122:     nsCOMPtr<nsIAccessible> parent = GetParent();
20566:     if (nsAccUtils::Role(parent) == nsIAccessibleRole::ROLE_TREE_TABLE)
 3122:       msaaRole = ROLE_SYSTEM_OUTLINEITEM;
 3122:   }
 3122:   
    1:   // -- Try enumerated role
    1:   if (msaaRole != USE_ROLE_STRING) {
    1:     pvarRole->vt = VT_I4;
    1:     pvarRole->lVal = msaaRole;  // Normal enumerated role
    1:     return S_OK;
    1:   }
    1: 
    1:   // -- Try BSTR role
    1:   // Could not map to known enumerated MSAA role like ROLE_BUTTON
    1:   // Use BSTR role to expose role attribute or tag name + namespace
    1:   nsCOMPtr<nsIDOMNode> domNode;
    1:   nsCOMPtr<nsIAccessNode> accessNode(do_QueryInterface(xpAccessible));
    1:   if (!accessNode)
    1:     return E_FAIL;
    1: 
    1:   accessNode->GetDOMNode(getter_AddRefs(domNode));
20566:   nsIContent *content = nsCoreUtils::GetRoleContent(domNode);
    1:   if (!content)
    1:     return E_FAIL;
    1: 
    1:   if (content->IsNodeOfType(nsINode::eELEMENT)) {
    1:     nsAutoString roleString;
 8937:     if (msaaRole != ROLE_SYSTEM_CLIENT &&
 8937:         !content->GetAttr(kNameSpaceID_None, nsAccessibilityAtoms::role, roleString)) {
    1:       nsINodeInfo *nodeInfo = content->NodeInfo();
    1:       nodeInfo->GetName(roleString);
    1:       nsAutoString nameSpaceURI;
    1:       nodeInfo->GetNamespaceURI(nameSpaceURI);
    1:       if (!nameSpaceURI.IsEmpty()) {
    1:         // Only append name space if different from that of current document
    1:         roleString += NS_LITERAL_STRING(", ") + nameSpaceURI;
    1:       }
    1:     }
    1:     if (!roleString.IsEmpty()) {
    1:       pvarRole->vt = VT_BSTR;
    1:       pvarRole->bstrVal = ::SysAllocString(roleString.get());
    1:       return S_OK;
    1:     }
    1:   }
11440: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1:   return E_FAIL;
    1: }
    1: 
    1: STDMETHODIMP nsAccessibleWrap::get_accState(
    1:       /* [optional][in] */ VARIANT varChild,
    1:       /* [retval][out] */ VARIANT __RPC_FAR *pvarState)
    1: {
11440: __try {
    1:   VariantInit(pvarState);
    1:   pvarState->vt = VT_I4;
    1:   pvarState->lVal = 0;
    1: 
    1:   nsCOMPtr<nsIAccessible> xpAccessible;
    1:   GetXPAccessibleFor(varChild, getter_AddRefs(xpAccessible));
    1:   if (!xpAccessible)
    1:     return E_FAIL;
    1: 
 5425:   PRUint32 state = 0;
21256:   if (NS_FAILED(xpAccessible->GetState(&state, nsnull)))
    1:     return E_FAIL;
    1: 
    1:   pvarState->lVal = state;
11440: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1:   return S_OK;
    1: }
    1: 
    1: 
    1: STDMETHODIMP nsAccessibleWrap::get_accHelp(
    1:       /* [optional][in] */ VARIANT varChild,
    1:       /* [retval][out] */ BSTR __RPC_FAR *pszHelp)
    1: {
    1:   *pszHelp = NULL;
    1:   return S_FALSE;
    1: }
    1: 
    1: STDMETHODIMP nsAccessibleWrap::get_accHelpTopic(
    1:       /* [out] */ BSTR __RPC_FAR *pszHelpFile,
    1:       /* [optional][in] */ VARIANT varChild,
    1:       /* [retval][out] */ long __RPC_FAR *pidTopic)
    1: {
    1:   *pszHelpFile = NULL;
    1:   *pidTopic = 0;
    1:   return E_NOTIMPL;
    1: }
    1: 
    1: STDMETHODIMP nsAccessibleWrap::get_accKeyboardShortcut(
    1:       /* [optional][in] */ VARIANT varChild,
    1:       /* [retval][out] */ BSTR __RPC_FAR *pszKeyboardShortcut)
    1: {
11440: __try {
    1:   *pszKeyboardShortcut = NULL;
    1:   nsCOMPtr<nsIAccessible> xpAccessible;
    1:   GetXPAccessibleFor(varChild, getter_AddRefs(xpAccessible));
    1:   if (xpAccessible) {
    1:     nsAutoString shortcut;
    1:     nsresult rv = xpAccessible->GetKeyboardShortcut(shortcut);
    1:     if (NS_FAILED(rv))
13128:       return E_FAIL;
13128: 
13128:     *pszKeyboardShortcut = ::SysAllocStringLen(shortcut.get(),
13128:                                                shortcut.Length());
13128:     return *pszKeyboardShortcut ? S_OK : E_OUTOFMEMORY;
    1:   }
11440: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
13128:   return E_FAIL;
    1: }
    1: 
    1: STDMETHODIMP nsAccessibleWrap::get_accFocus(
    1:       /* [retval][out] */ VARIANT __RPC_FAR *pvarChild)
    1: {
    1:   // VT_EMPTY:    None. This object does not have the keyboard focus itself
    1:   //              and does not contain a child that has the keyboard focus.
    1:   // VT_I4:       lVal is CHILDID_SELF. The object itself has the keyboard focus.
    1:   // VT_I4:       lVal contains the child ID of the child element with the keyboard focus.
    1:   // VT_DISPATCH: pdispVal member is the address of the IDispatch interface
    1:   //              for the child object with the keyboard focus.
11440: __try {
    1:   if (!mDOMNode) {
    1:     return E_FAIL; // This node is shut down
    1:   }
    1: 
    1:   VariantInit(pvarChild);
    1: 
    1:   // Return the current IAccessible child that has focus
    1:   nsCOMPtr<nsIAccessible> focusedAccessible;
    1:   GetFocusedChild(getter_AddRefs(focusedAccessible));
    1:   if (focusedAccessible == this) {
    1:     pvarChild->vt = VT_I4;
    1:     pvarChild->lVal = CHILDID_SELF;
    1:   }
    1:   else if (focusedAccessible) {
    1:     pvarChild->vt = VT_DISPATCH;
    1:     pvarChild->pdispVal = NativeAccessible(focusedAccessible);
    1:   }
    1:   else {
    1:     pvarChild->vt = VT_EMPTY;   // No focus or focus is not a child
    1:   }
    1: 
11440: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1:   return S_OK;
    1: }
    1: 
    1: // This helper class implements IEnumVARIANT for a nsIArray containing nsIAccessible objects.
    1: 
    1: class AccessibleEnumerator : public IEnumVARIANT
    1: {
    1: public:
    1:   AccessibleEnumerator(nsIArray* aArray) : mArray(aArray), mCurIndex(0) { }
    1:   AccessibleEnumerator(const AccessibleEnumerator& toCopy) :
    1:     mArray(toCopy.mArray), mCurIndex(toCopy.mCurIndex) { }
    1:   ~AccessibleEnumerator() { }
    1: 
    1:   // IUnknown
    1:   STDMETHODIMP QueryInterface(REFIID iid, void ** ppvObject);
    1:   STDMETHODIMP_(ULONG) AddRef(void);
    1:   STDMETHODIMP_(ULONG) Release(void);
    1: 
    1:   // IEnumVARIANT
    1:   STDMETHODIMP Next(unsigned long celt, VARIANT FAR* rgvar, unsigned long FAR* pceltFetched);
    1:   STDMETHODIMP Skip(unsigned long celt);
    1:   STDMETHODIMP Reset()
    1:   {
    1:     mCurIndex = 0;
    1:     return S_OK;
    1:   }
    1:   STDMETHODIMP Clone(IEnumVARIANT FAR* FAR* ppenum);
    1: 
    1: private:
    1:   nsCOMPtr<nsIArray> mArray;
    1:   PRUint32 mCurIndex;
    1:   nsAutoRefCnt mRefCnt;
    1: };
    1: 
    1: HRESULT
    1: AccessibleEnumerator::QueryInterface(REFIID iid, void ** ppvObject)
    1: {
11440: __try {
    1:   if (iid == IID_IEnumVARIANT) {
    1:     *ppvObject = static_cast<IEnumVARIANT*>(this);
    1:     AddRef();
    1:     return S_OK;
    1:   }
    1:   if (iid == IID_IUnknown) {
    1:     *ppvObject = static_cast<IUnknown*>(this);
    1:     AddRef();
    1:     return S_OK;
    1:   }
    1: 
    1:   *ppvObject = NULL;
11440: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1:   return E_NOINTERFACE;
    1: }
    1: 
    1: STDMETHODIMP_(ULONG)
    1: AccessibleEnumerator::AddRef(void)
    1: {
    1:   return ++mRefCnt;
    1: }
    1: 
    1: STDMETHODIMP_(ULONG)
    1: AccessibleEnumerator::Release(void)
    1: {
    1:   ULONG r = --mRefCnt;
    1:   if (r == 0)
    1:     delete this;
    1:   return r;
    1: }
    1: 
    1: STDMETHODIMP
    1: AccessibleEnumerator::Next(unsigned long celt, VARIANT FAR* rgvar, unsigned long FAR* pceltFetched)
    1: {
11440: __try {
    1:   PRUint32 length = 0;
    1:   mArray->GetLength(&length);
    1: 
    1:   HRESULT hr = S_OK;
    1: 
    1:   // Can't get more elements than there are...
    1:   if (celt > length - mCurIndex) {
    1:     hr = S_FALSE;
    1:     celt = length - mCurIndex;
    1:   }
    1: 
    1:   for (PRUint32 i = 0; i < celt; ++i, ++mCurIndex) {
    1:     // Copy the elements of the array into rgvar
    1:     nsCOMPtr<nsIAccessible> accel(do_QueryElementAt(mArray, mCurIndex));
    1:     NS_ASSERTION(accel, "Invalid pointer in mArray");
    1: 
    1:     if (accel) {
    1:       rgvar[i].vt = VT_DISPATCH;
    1:       rgvar[i].pdispVal = nsAccessibleWrap::NativeAccessible(accel);
    1:     }
    1:   }
    1: 
    1:   if (pceltFetched)
    1:     *pceltFetched = celt;
    1: 
    1:   return hr;
11440: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
11440: 
11440:   return S_OK;
    1: }
    1: 
    1: STDMETHODIMP
    1: AccessibleEnumerator::Clone(IEnumVARIANT FAR* FAR* ppenum)
    1: {
11440: __try {
    1:   *ppenum = new AccessibleEnumerator(*this);
    1:   if (!*ppenum)
    1:     return E_OUTOFMEMORY;
    1:   NS_ADDREF(*ppenum);
11440: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1:   return S_OK;
    1: }
    1: 
    1: STDMETHODIMP
    1: AccessibleEnumerator::Skip(unsigned long celt)
    1: {
11440: __try {
    1:   PRUint32 length = 0;
    1:   mArray->GetLength(&length);
    1:   // Check if we can skip the requested number of elements
    1:   if (celt > length - mCurIndex) {
    1:     mCurIndex = length;
    1:     return S_FALSE;
    1:   }
    1:   mCurIndex += celt;
11440: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1:   return S_OK;
    1: }
    1: 
    1: /**
    1:   * This method is called when a client wants to know which children of a node
    1:   *  are selected. Note that this method can only find selected children for
    1:   *  nsIAccessible object which implement nsIAccessibleSelectable.
    1:   *
    1:   * The VARIANT return value arguement is expected to either contain a single IAccessible
    1:   *  or an IEnumVARIANT of IAccessibles. We return the IEnumVARIANT regardless of the number
    1:   *  of children selected, unless there are none selected in which case we return an empty
    1:   *  VARIANT.
    1:   *
    1:   * We get the selected options from the select's accessible object and wrap
    1:   *  those in an AccessibleEnumerator which we then put in the return VARIANT.
    1:   *
    1:   * returns a VT_EMPTY VARIANT if:
    1:   *  - there are no selected children for this object
    1:   *  - the object is not the type that can have children selected
    1:   */
    1: STDMETHODIMP nsAccessibleWrap::get_accSelection(VARIANT __RPC_FAR *pvarChildren)
    1: {
11440: __try {
    1:   VariantInit(pvarChildren);
    1:   pvarChildren->vt = VT_EMPTY;
    1: 
    1:   nsCOMPtr<nsIAccessibleSelectable> 
 3233:     select(do_QueryInterface(static_cast<nsIAccessible*>(this)));
    1: 
    1:   if (select) {  // do we have an nsIAccessibleSelectable?
    1:     // we have an accessible that can have children selected
    1:     nsCOMPtr<nsIArray> selectedOptions;
    1:     // gets the selected options as nsIAccessibles.
    1:     select->GetSelectedChildren(getter_AddRefs(selectedOptions));
    1:     if (selectedOptions) { // false if the select has no children or none are selected
    1:       // 1) Create and initialize the enumeration
    1:       nsRefPtr<AccessibleEnumerator> pEnum = new AccessibleEnumerator(selectedOptions);
    1: 
    1:       // 2) Put the enumerator in the VARIANT
    1:       if (!pEnum)
    1:         return E_OUTOFMEMORY;
    1:       pvarChildren->vt = VT_UNKNOWN;    // this must be VT_UNKNOWN for an IEnumVARIANT
    1:       NS_ADDREF(pvarChildren->punkVal = pEnum);
    1:     }
    1:   }
11440: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1:   return S_OK;
    1: }
    1: 
    1: STDMETHODIMP nsAccessibleWrap::get_accDefaultAction(
    1:       /* [optional][in] */ VARIANT varChild,
    1:       /* [retval][out] */ BSTR __RPC_FAR *pszDefaultAction)
    1: {
11440: __try {
    1:   *pszDefaultAction = NULL;
    1:   nsCOMPtr<nsIAccessible> xpAccessible;
    1:   GetXPAccessibleFor(varChild, getter_AddRefs(xpAccessible));
    1:   if (xpAccessible) {
    1:     nsAutoString defaultAction;
    1:     if (NS_FAILED(xpAccessible->GetActionName(0, defaultAction)))
13128:       return E_FAIL;
13128: 
13128:     *pszDefaultAction = ::SysAllocStringLen(defaultAction.get(),
13128:                                             defaultAction.Length());
13128:     return *pszDefaultAction ? S_OK : E_OUTOFMEMORY;
    1:   }
    1: 
11440: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
13128:   return E_FAIL;
    1: }
    1: 
    1: STDMETHODIMP nsAccessibleWrap::accSelect(
    1:       /* [in] */ long flagsSelect,
    1:       /* [optional][in] */ VARIANT varChild)
    1: {
11440: __try {
    1:   // currently only handle focus and selection
    1:   nsCOMPtr<nsIAccessible> xpAccessible;
    1:   GetXPAccessibleFor(varChild, getter_AddRefs(xpAccessible));
 2136:   NS_ENSURE_TRUE(xpAccessible, E_FAIL);
    1: 
    1:   if (flagsSelect & (SELFLAG_TAKEFOCUS|SELFLAG_TAKESELECTION|SELFLAG_REMOVESELECTION))
    1:   {
    1:     if (flagsSelect & SELFLAG_TAKEFOCUS)
    1:       xpAccessible->TakeFocus();
    1: 
    1:     if (flagsSelect & SELFLAG_TAKESELECTION)
    1:       xpAccessible->TakeSelection();
    1: 
    1:     if (flagsSelect & SELFLAG_ADDSELECTION)
    1:       xpAccessible->SetSelected(PR_TRUE);
    1: 
    1:     if (flagsSelect & SELFLAG_REMOVESELECTION)
    1:       xpAccessible->SetSelected(PR_FALSE);
    1: 
    1:     if (flagsSelect & SELFLAG_EXTENDSELECTION)
    1:       xpAccessible->ExtendSelection();
    1: 
    1:     return S_OK;
    1:   }
    1: 
11440: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1:   return E_FAIL;
    1: }
    1: 
    1: STDMETHODIMP nsAccessibleWrap::accLocation(
    1:       /* [out] */ long __RPC_FAR *pxLeft,
    1:       /* [out] */ long __RPC_FAR *pyTop,
    1:       /* [out] */ long __RPC_FAR *pcxWidth,
    1:       /* [out] */ long __RPC_FAR *pcyHeight,
    1:       /* [optional][in] */ VARIANT varChild)
    1: {
11440: __try {
    1:   nsCOMPtr<nsIAccessible> xpAccessible;
    1:   GetXPAccessibleFor(varChild, getter_AddRefs(xpAccessible));
    1: 
    1:   if (xpAccessible) {
    1:     PRInt32 x, y, width, height;
    1:     if (NS_FAILED(xpAccessible->GetBounds(&x, &y, &width, &height)))
    1:       return E_FAIL;
    1: 
    1:     *pxLeft = x;
    1:     *pyTop = y;
    1:     *pcxWidth = width;
    1:     *pcyHeight = height;
    1:     return S_OK;
    1:   }
11440: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return E_FAIL;
    1: }
    1: 
    1: STDMETHODIMP nsAccessibleWrap::accNavigate(
    1:       /* [in] */ long navDir,
    1:       /* [optional][in] */ VARIANT varStart,
    1:       /* [retval][out] */ VARIANT __RPC_FAR *pvarEndUpAt)
    1: {
11440: __try {
    1:   nsCOMPtr<nsIAccessible> xpAccessibleStart, xpAccessibleResult;
    1:   GetXPAccessibleFor(varStart, getter_AddRefs(xpAccessibleStart));
    1:   if (!xpAccessibleStart)
    1:     return E_FAIL;
    1: 
    1:   VariantInit(pvarEndUpAt);
    1:   PRUint32 xpRelation = 0;
    1: 
    1:   switch(navDir) {
    1:     case NAVDIR_DOWN:
    1:       xpAccessibleStart->GetAccessibleBelow(getter_AddRefs(xpAccessibleResult));
    1:       break;
    1:     case NAVDIR_FIRSTCHILD:
20566:       if (!nsAccUtils::MustPrune(xpAccessibleStart))
    1:         xpAccessibleStart->GetFirstChild(getter_AddRefs(xpAccessibleResult));
    1:       break;
    1:     case NAVDIR_LASTCHILD:
20566:       if (!nsAccUtils::MustPrune(xpAccessibleStart))
    1:         xpAccessibleStart->GetLastChild(getter_AddRefs(xpAccessibleResult));
    1:       break;
    1:     case NAVDIR_LEFT:
    1:       xpAccessibleStart->GetAccessibleToLeft(getter_AddRefs(xpAccessibleResult));
    1:       break;
    1:     case NAVDIR_NEXT:
    1:       xpAccessibleStart->GetNextSibling(getter_AddRefs(xpAccessibleResult));
    1:       break;
    1:     case NAVDIR_PREVIOUS:
    1:       xpAccessibleStart->GetPreviousSibling(getter_AddRefs(xpAccessibleResult));
    1:       break;
    1:     case NAVDIR_RIGHT:
    1:       xpAccessibleStart->GetAccessibleToRight(getter_AddRefs(xpAccessibleResult));
    1:       break;
    1:     case NAVDIR_UP:
    1:       xpAccessibleStart->GetAccessibleAbove(getter_AddRefs(xpAccessibleResult));
    1:       break;
 1628: 
    1:     // MSAA relationship extensions to accNavigate
 1628:     case NAVRELATION_CONTROLLED_BY:
 1628:       xpRelation = nsIAccessibleRelation::RELATION_CONTROLLED_BY;
 1628:       break;
 1628:     case NAVRELATION_CONTROLLER_FOR:
 1628:       xpRelation = nsIAccessibleRelation::RELATION_CONTROLLER_FOR;
 1628:       break;
 1628:     case NAVRELATION_LABEL_FOR:
 1628:       xpRelation = nsIAccessibleRelation::RELATION_LABEL_FOR;
 1628:       break;
 1628:     case NAVRELATION_LABELLED_BY:
 1628:       xpRelation = nsIAccessibleRelation::RELATION_LABELLED_BY;
 1628:       break;
 1628:     case NAVRELATION_MEMBER_OF:
 1628:       xpRelation = nsIAccessibleRelation::RELATION_MEMBER_OF;
 1628:       break;
 1628:     case NAVRELATION_NODE_CHILD_OF:
 1628:       xpRelation = nsIAccessibleRelation::RELATION_NODE_CHILD_OF;
 1628:       break;
 1628:     case NAVRELATION_FLOWS_TO:
 1628:       xpRelation = nsIAccessibleRelation::RELATION_FLOWS_TO;
 1628:       break;
 1628:     case NAVRELATION_FLOWS_FROM:
 1628:       xpRelation = nsIAccessibleRelation::RELATION_FLOWS_FROM;
 1628:       break;
 1628:     case NAVRELATION_SUBWINDOW_OF:
 1628:       xpRelation = nsIAccessibleRelation::RELATION_SUBWINDOW_OF;
 1628:       break;
 1628:     case NAVRELATION_EMBEDS:
 1628:       xpRelation = nsIAccessibleRelation::RELATION_EMBEDS;
 1628:       break;
 1628:     case NAVRELATION_EMBEDDED_BY:
 1628:       xpRelation = nsIAccessibleRelation::RELATION_EMBEDDED_BY;
 1628:       break;
 1628:     case NAVRELATION_POPUP_FOR:
 1628:       xpRelation = nsIAccessibleRelation::RELATION_POPUP_FOR;
 1628:       break;
 1628:     case NAVRELATION_PARENT_WINDOW_OF:
 1628:       xpRelation = nsIAccessibleRelation::RELATION_PARENT_WINDOW_OF;
 1628:       break;
 1628:     case NAVRELATION_DEFAULT_BUTTON:
 1628:       xpRelation = nsIAccessibleRelation::RELATION_DEFAULT_BUTTON;
 1628:       break;
 1628:     case NAVRELATION_DESCRIBED_BY:
 1628:       xpRelation = nsIAccessibleRelation::RELATION_DESCRIBED_BY;
 1628:       break;
 1628:     case NAVRELATION_DESCRIPTION_FOR:
 1628:       xpRelation = nsIAccessibleRelation::RELATION_DESCRIPTION_FOR;
 1628:       break;
    1:   }
    1: 
    1:   pvarEndUpAt->vt = VT_EMPTY;
    1: 
24822:   if (xpRelation)
24822:     xpAccessibleResult = nsRelUtils::GetRelatedAccessible(this, xpRelation);
    1: 
    1:   if (xpAccessibleResult) {
    1:     pvarEndUpAt->pdispVal = NativeAccessible(xpAccessibleResult);
    1:     pvarEndUpAt->vt = VT_DISPATCH;
    1:     return NS_OK;
    1:   }
11440: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1:   return E_FAIL;
    1: }
    1: 
    1: STDMETHODIMP nsAccessibleWrap::accHitTest(
    1:       /* [in] */ long xLeft,
    1:       /* [in] */ long yTop,
    1:       /* [retval][out] */ VARIANT __RPC_FAR *pvarChild)
    1: {
11440: __try {
    1:   VariantInit(pvarChild);
    1: 
    1:   // convert to window coords
    1:   nsCOMPtr<nsIAccessible> xpAccessible;
    1: 
    1:   xLeft = xLeft;
    1:   yTop = yTop;
    1: 
20566:   if (nsAccUtils::MustPrune(this)) {
    1:     xpAccessible = this;
    1:   }
    1:   else {
    1:     GetChildAtPoint(xLeft, yTop, getter_AddRefs(xpAccessible));
    1:   }
    1: 
    1:   // if we got a child
    1:   if (xpAccessible) {
    1:     // if the child is us
 3233:     if (xpAccessible == static_cast<nsIAccessible*>(this)) {
    1:       pvarChild->vt = VT_I4;
    1:       pvarChild->lVal = CHILDID_SELF;
    1:     } else { // its not create an Accessible for it.
    1:       pvarChild->vt = VT_DISPATCH;
    1:       pvarChild->pdispVal = NativeAccessible(xpAccessible);
    1:       nsCOMPtr<nsIAccessNode> accessNode(do_QueryInterface(xpAccessible));
    1:       NS_ASSERTION(accessNode, "Unable to QI to nsIAccessNode");
    1:       nsCOMPtr<nsIDOMNode> domNode;
    1:       accessNode->GetDOMNode(getter_AddRefs(domNode));
    1:       if (!domNode) {
    1:         // Has already been shut down
    1:         pvarChild->vt = VT_EMPTY;
    1:         return E_FAIL;
    1:       }
    1:     }
    1:   } else {
    1:     // no child at that point
    1:     pvarChild->vt = VT_EMPTY;
 6089:     return S_FALSE;
    1:   }
11440: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return S_OK;
    1: }
    1: 
    1: STDMETHODIMP nsAccessibleWrap::accDoDefaultAction(
    1:       /* [optional][in] */ VARIANT varChild)
    1: {
11440: __try {
    1:   nsCOMPtr<nsIAccessible> xpAccessible;
    1:   GetXPAccessibleFor(varChild, getter_AddRefs(xpAccessible));
    1: 
    1:   if (!xpAccessible || FAILED(xpAccessible->DoAction(0))) {
    1:     return E_FAIL;
    1:   }
11440: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1:   return S_OK;
    1: }
    1: 
    1: STDMETHODIMP nsAccessibleWrap::put_accName(
    1:       /* [optional][in] */ VARIANT varChild,
    1:       /* [in] */ BSTR szName)
    1: {
    1:   return E_NOTIMPL;
    1: }
    1: 
    1: STDMETHODIMP nsAccessibleWrap::put_accValue(
    1:       /* [optional][in] */ VARIANT varChild,
    1:       /* [in] */ BSTR szValue)
    1: {
    1:   return E_NOTIMPL;
    1: }
    1: 
    1: #include "mshtml.h"
    1: 
15720: ////////////////////////////////////////////////////////////////////////////////
15720: // nsAccessibleWrap. IEnumVariant
15720: 
    1: STDMETHODIMP
15720: nsAccessibleWrap::Next(ULONG aNumElementsRequested, VARIANT FAR* aPVar,
15720:                        ULONG FAR* aNumElementsFetched)
    1: {
    1:   // Children already cached via QI to IEnumVARIANT
11440: __try {
    1:   *aNumElementsFetched = 0;
    1: 
15720:   if (aNumElementsRequested <= 0 || !aPVar)
15720:     return E_INVALIDARG;
    1: 
15720:   if (mEnumVARIANTPosition == kIEnumVariantDisconnected)
15720:     return CO_E_OBJNOTCONNECTED;
15720: 
15720:   nsCOMPtr<nsIAccessible> traversedAcc;
15720:   nsresult rv = GetChildAt(mEnumVARIANTPosition, getter_AddRefs(traversedAcc));
15720:   if (!traversedAcc)
15720:     return S_FALSE;
15720: 
15720:   for (PRUint32 i = 0; i < aNumElementsRequested; i++) {
15720:     VariantInit(&aPVar[i]);
15720: 
15720:     aPVar[i].pdispVal = NativeAccessible(traversedAcc);
15720:     aPVar[i].vt = VT_DISPATCH;
15720:     (*aNumElementsFetched)++;
15720: 
15720:     nsCOMPtr<nsIAccessible> nextAcc;
15720:     traversedAcc->GetNextSibling(getter_AddRefs(nextAcc));
15720:     if (!nextAcc)
15720:       break;
15720: 
15720:     traversedAcc = nextAcc;
    1:   }
    1: 
15720:   mEnumVARIANTPosition += *aNumElementsFetched;
15720:   return (*aNumElementsFetched) < aNumElementsRequested ? S_FALSE : S_OK;
    1: 
11440: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
15720:   return E_FAIL;
    1: }
    1: 
    1: STDMETHODIMP
    1: nsAccessibleWrap::Skip(ULONG aNumElements)
    1: {
11440: __try {
15720:   if (mEnumVARIANTPosition == kIEnumVariantDisconnected)
15720:     return CO_E_OBJNOTCONNECTED;
15720: 
15720:   mEnumVARIANTPosition += aNumElements;
    1: 
    1:   PRInt32 numChildren;
    1:   GetChildCount(&numChildren);
    1: 
    1:   if (mEnumVARIANTPosition > numChildren)
    1:   {
    1:     mEnumVARIANTPosition = numChildren;
    1:     return S_FALSE;
    1:   }
11440: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1:   return NOERROR;
    1: }
    1: 
    1: STDMETHODIMP
    1: nsAccessibleWrap::Reset(void)
    1: {
    1:   mEnumVARIANTPosition = 0;
    1:   return NOERROR;
    1: }
    1: 
15720: STDMETHODIMP
15720: nsAccessibleWrap::Clone(IEnumVARIANT FAR* FAR* ppenum)
15720: {
15720: __try {
15720:   *ppenum = nsnull;
    1:   
15720:   nsCOMPtr<nsIArray> childArray;
15720:   nsresult rv = GetChildren(getter_AddRefs(childArray));
15720: 
15720:   *ppenum = new AccessibleEnumerator(childArray);
15720:   if (!*ppenum)
15720:     return E_OUTOFMEMORY;
15720:   NS_ADDREF(*ppenum);
15720: 
15720: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
15720:   return NOERROR;
15720: }
15720: 
15720: ////////////////////////////////////////////////////////////////////////////////
15720: // nsAccessibleWrap. IAccessible2
    1: 
    1: STDMETHODIMP
 1828: nsAccessibleWrap::get_nRelations(long *aNRelations)
    1: {
11440: __try {
 1828:   PRUint32 count = 0;
 1828:   nsresult rv = GetRelationsCount(&count);
 1828:   *aNRelations = count;
 1828: 
13730:   return GetHRESULT(rv);
13730: 
13730: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
11440:   return E_FAIL;
    1: }
    1: 
    1: STDMETHODIMP
 1828: nsAccessibleWrap::get_relation(long aRelationIndex,
 1828:                                IAccessibleRelation **aRelation)
    1: {
11440: __try {
13730:   *aRelation = NULL;
13730: 
 1828:   nsCOMPtr<nsIAccessibleRelation> relation;
 1828:   nsresult rv = GetRelation(aRelationIndex, getter_AddRefs(relation));
 1828:   if (NS_FAILED(rv))
13730:     return GetHRESULT(rv);
 1828: 
 1828:   nsCOMPtr<nsIWinAccessNode> winAccessNode(do_QueryInterface(relation));
 1828:   if (!winAccessNode)
 1828:     return E_FAIL;
 1828: 
 1828:   void *instancePtr = NULL;
 1828:   rv =  winAccessNode->QueryNativeInterface(IID_IAccessibleRelation,
 1828:                                             &instancePtr);
 1828:   if (NS_FAILED(rv))
13730:     return GetHRESULT(rv);
 1828: 
 3233:   *aRelation = static_cast<IAccessibleRelation*>(instancePtr);
13730:   return S_OK;
13730: 
11440: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
13730:   return E_FAIL;
    1: }
    1: 
    1: STDMETHODIMP
 1828: nsAccessibleWrap::get_relations(long aMaxRelations,
 1828:                                 IAccessibleRelation **aRelation,
 1828:                                 long *aNRelations)
    1: {
11440: __try {
13730:   *aRelation = NULL;
 1828:   *aNRelations = 0;
 1828: 
 1828:   nsCOMPtr<nsIArray> relations;
 1828:   nsresult rv = GetRelations(getter_AddRefs(relations));
 1828:   if (NS_FAILED(rv))
13730:     return GetHRESULT(rv);
 1828: 
 1828:   PRUint32 length = 0;
 1828:   rv = relations->GetLength(&length);
 1828:   if (NS_FAILED(rv))
13730:     return GetHRESULT(rv);
13730: 
13730:   if (length == 0)
13730:     return S_FALSE;
 1828: 
 1828:   PRUint32 count = length < (PRUint32)aMaxRelations ? length : aMaxRelations;
 1828: 
 1828:   PRUint32 index = 0;
 1828:   for (; index < count; index++) {
13730:     nsCOMPtr<nsIWinAccessNode> winAccessNode =
13730:       do_QueryElementAt(relations, index, &rv);
13730:     if (NS_FAILED(rv))
 1828:       break;
 1828: 
 1828:     void *instancePtr = NULL;
 1828:     nsresult rv =  winAccessNode->QueryNativeInterface(IID_IAccessibleRelation,
 1828:                                                        &instancePtr);
 1828:     if (NS_FAILED(rv))
 1828:       break;
 1828: 
 3233:     aRelation[index] = static_cast<IAccessibleRelation*>(instancePtr);
 1828:   }
 1828: 
 1828:   if (NS_FAILED(rv)) {
 1828:     for (PRUint32 index2 = 0; index2 < index; index2++) {
 1828:       aRelation[index2]->Release();
 1828:       aRelation[index2] = NULL;
 1828:     }
13730:     return GetHRESULT(rv);
13730:   }
13730: 
13730:   *aNRelations = count;
13730:   return S_OK;
13730: 
13730: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
 1828:   return E_FAIL;
 1828: }
 1828: 
    1: STDMETHODIMP
13730: nsAccessibleWrap::role(long *aRole)
    1: {
11440: __try {
13730:   *aRole = 0;
13730: 
    1:   PRUint32 xpRole = 0;
25822:   nsresult rv = GetRole(&xpRole);
13730:   if (NS_FAILED(rv))
13730:     return GetHRESULT(rv);
    1: 
    1:   NS_ASSERTION(gWindowsRoleMap[nsIAccessibleRole::ROLE_LAST_ENTRY].ia2Role == ROLE_WINDOWS_LAST_ENTRY,
    1:                "MSAA role map skewed");
    1: 
13730:   *aRole = gWindowsRoleMap[xpRole].ia2Role;
13730:   return S_OK;
13730: 
11440: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
13730:   return E_FAIL;
    1: }
    1: 
    1: STDMETHODIMP
  497: nsAccessibleWrap::scrollTo(enum IA2ScrollType aScrollType)
    1: {
11440: __try {
13730:   nsresult rv = ScrollTo(aScrollType);
13730:   return GetHRESULT(rv);
13730: 
11440: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1:   return E_FAIL;
    1: }
    1: 
    1: STDMETHODIMP
 6286: nsAccessibleWrap::scrollToPoint(enum IA2CoordinateType aCoordType,
 6286:                                 long aX, long aY)
  404: {
11440: __try {
 6286:   PRUint32 geckoCoordType = (aCoordType == IA2_COORDTYPE_SCREEN_RELATIVE) ?
 6286:     nsIAccessibleCoordinateType::COORDTYPE_SCREEN_RELATIVE :
 6286:     nsIAccessibleCoordinateType::COORDTYPE_PARENT_RELATIVE;
 6286: 
13730:   nsresult rv = ScrollToPoint(geckoCoordType, aX, aY);
13730:   return GetHRESULT(rv);
13730: 
11440: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
13730:   return E_FAIL;
  404: }
  404: 
  404: STDMETHODIMP
  144: nsAccessibleWrap::get_groupPosition(long *aGroupLevel,
  144:                                     long *aSimilarItemsInGroup,
  144:                                     long *aPositionInGroup)
    1: {
11440: __try {
  144:   PRInt32 groupLevel = 0;
  144:   PRInt32 similarItemsInGroup = 0;
  144:   PRInt32 positionInGroup = 0;
  144:   nsresult rv = GroupPosition(&groupLevel, &similarItemsInGroup,
  144:                               &positionInGroup);
  144: 
  144:   *aGroupLevel = groupLevel;
  144:   *aSimilarItemsInGroup = similarItemsInGroup;
  144:   *aPositionInGroup = positionInGroup;
13730: 
13730:   if (NS_FAILED(rv))
13730:     return GetHRESULT(rv);
13730: 
13730:   if (groupLevel ==0 && similarItemsInGroup == 0 && positionInGroup == 0)
13730:     return S_FALSE;
  144:   return S_OK;
  144: 
11440: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
  144:   return E_FAIL;
    1: }
    1: 
    1: STDMETHODIMP
    1: nsAccessibleWrap::get_states(AccessibleStates *aStates)
    1: {
11440: __try {
    1:   *aStates = 0;
    1: 
    1:   // XXX: bug 344674 should come with better approach that we have here.
    1: 
  262:   PRUint32 states = 0, extraStates = 0;
21256:   nsresult rv = GetState(&states, &extraStates);
    1:   if (NS_FAILED(rv))
13730:     return GetHRESULT(rv);
    1: 
    1:   if (states & nsIAccessibleStates::STATE_INVALID)
    1:     *aStates |= IA2_STATE_INVALID_ENTRY;
 4469:   if (states & nsIAccessibleStates::STATE_REQUIRED)
    1:     *aStates |= IA2_STATE_REQUIRED;
    1: 
    1:   // The following IA2 states are not supported by Gecko
    1:   // IA2_STATE_ARMED
 4469:   // IA2_STATE_MANAGES_DESCENDANTS
    1:   // IA2_STATE_ICONIFIED
 4469:   // IA2_STATE_INVALID // This is not a state, it is the absence of a state
    1: 
  262:   if (extraStates & nsIAccessibleStates::EXT_STATE_ACTIVE)
    1:     *aStates |= IA2_STATE_ACTIVE;
 4469:   if (extraStates & nsIAccessibleStates::EXT_STATE_DEFUNCT)
    1:     *aStates |= IA2_STATE_DEFUNCT;
 4469:   if (extraStates & nsIAccessibleStates::EXT_STATE_EDITABLE)
    1:     *aStates |= IA2_STATE_EDITABLE;
 4469:   if (extraStates & nsIAccessibleStates::EXT_STATE_HORIZONTAL)
    1:     *aStates |= IA2_STATE_HORIZONTAL;
 4469:   if (extraStates & nsIAccessibleStates::EXT_STATE_MODAL)
    1:     *aStates |= IA2_STATE_MODAL;
 4469:   if (extraStates & nsIAccessibleStates::EXT_STATE_MULTI_LINE)
    1:     *aStates |= IA2_STATE_MULTI_LINE;
 4469:   if (extraStates & nsIAccessibleStates::EXT_STATE_OPAQUE)
    1:     *aStates |= IA2_STATE_OPAQUE;
 4469:   if (extraStates & nsIAccessibleStates::EXT_STATE_SELECTABLE_TEXT)
    1:     *aStates |= IA2_STATE_SELECTABLE_TEXT;
 4469:   if (extraStates & nsIAccessibleStates::EXT_STATE_SINGLE_LINE)
    1:     *aStates |= IA2_STATE_SINGLE_LINE;
 4469:   if (extraStates & nsIAccessibleStates::EXT_STATE_STALE)
    1:     *aStates |= IA2_STATE_STALE;
 4469:   if (extraStates & nsIAccessibleStates::EXT_STATE_SUPPORTS_AUTOCOMPLETION)
    1:     *aStates |= IA2_STATE_SUPPORTS_AUTOCOMPLETION;
 4469:   if (extraStates & nsIAccessibleStates::EXT_STATE_TRANSIENT)
    1:     *aStates |= IA2_STATE_TRANSIENT;
 4469:   if (extraStates & nsIAccessibleStates::EXT_STATE_VERTICAL)
    1:     *aStates |= IA2_STATE_VERTICAL;
    1: 
13730:   return S_OK;
13730: 
11440: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
13730:   return E_FAIL;
    1: }
    1: 
    1: STDMETHODIMP
13128: nsAccessibleWrap::get_extendedRole(BSTR *aExtendedRole)
    1: {
13128: __try {
13128:   *aExtendedRole = NULL;
13128: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
13128: 
    1:   return E_NOTIMPL;
    1: }
    1: 
    1: STDMETHODIMP
13128: nsAccessibleWrap::get_localizedExtendedRole(BSTR *aLocalizedExtendedRole)
    1: {
13128: __try {
13128:   *aLocalizedExtendedRole = NULL;
13128: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
13128: 
    1:   return E_NOTIMPL;
    1: }
    1: 
    1: STDMETHODIMP
13128: nsAccessibleWrap::get_nExtendedStates(long *aNExtendedStates)
    1: {
13128: __try {
13128:   *aNExtendedStates = 0;
13128: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
13128: 
    1:   return E_NOTIMPL;
    1: }
    1: 
    1: STDMETHODIMP
13128: nsAccessibleWrap::get_extendedStates(long aMaxExtendedStates,
13128:                                      BSTR **aExtendedStates,
13128:                                      long *aNExtendedStates)
    1: {
13128: __try {
13128:   *aExtendedStates = NULL;
13128:   *aNExtendedStates = 0;
13128: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
13128: 
    1:   return E_NOTIMPL;
    1: }
    1: 
    1: STDMETHODIMP
13128: nsAccessibleWrap::get_localizedExtendedStates(long aMaxLocalizedExtendedStates,
13128:                                               BSTR **aLocalizedExtendedStates,
13128:                                               long *aNLocalizedExtendedStates)
    1: {
13128: __try {
13128:   *aLocalizedExtendedStates = NULL;
13128:   *aNLocalizedExtendedStates = 0;
13128: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
13128: 
    1:   return E_NOTIMPL;
    1: }
    1: 
    1: STDMETHODIMP
    1: nsAccessibleWrap::get_uniqueID(long *uniqueID)
    1: {
11440: __try {
12698:   void *id = nsnull;
13730:   nsresult rv = GetUniqueID(&id);
13730:   if (NS_FAILED(rv))
13730:     return GetHRESULT(rv);
13730: 
 9901:   *uniqueID = - reinterpret_cast<long>(id);
    1:   return S_OK;
13730: 
11440: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1:   return E_FAIL;
    1: }
    1: 
    1: STDMETHODIMP
13730: nsAccessibleWrap::get_windowHandle(HWND *aWindowHandle)
    1: {
11440: __try {
13730:   *aWindowHandle = 0;
13730: 
12286:   if (!mDOMNode)
12286:     return E_FAIL;
13730: 
 8863:   void *handle = nsnull;
 8863:   nsresult rv = GetOwnerWindow(&handle);
 8863:   if (NS_FAILED(rv))
13730:     return GetHRESULT(rv);
13730: 
13730:   *aWindowHandle = reinterpret_cast<HWND>(handle);
13730:   return S_OK;
13730: 
13730: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
 8863:   return E_FAIL;
    1: }
    1: 
    1: STDMETHODIMP
13730: nsAccessibleWrap::get_indexInParent(long *aIndexInParent)
    1: {
11440: __try {
13730:   *aIndexInParent = -1;
13730: 
13730:   PRInt32 index = -1;
13730:   nsresult rv = GetIndexInParent(&index);
13730:   if (NS_FAILED(rv))
13730:     return GetHRESULT(rv);
13730: 
13730:   if (index == -1)
13730:     return S_FALSE;
13730: 
13730:   *aIndexInParent = index;
    1:   return S_OK;
13730: 
11440: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1:   return E_FAIL;
    1: }
    1: 
    1: STDMETHODIMP
 8526: nsAccessibleWrap::get_locale(IA2Locale *aLocale)
    1: {
11440: __try {
 8526:   // Language codes consist of a primary code and a possibly empty series of
 8526:   // subcodes: language-code = primary-code ( "-" subcode )*
 8526:   // Two-letter primary codes are reserved for [ISO639] language abbreviations.
 8526:   // Any two-letter subcode is understood to be a [ISO3166] country code.
 8526: 
 8526:   nsAutoString lang;
 8526:   nsresult rv = GetLanguage(lang);
 8526:   if (NS_FAILED(rv))
13730:     return GetHRESULT(rv);
 8526: 
 8526:   // If primary code consists from two letters then expose it as language.
 8526:   PRInt32 offset = lang.FindChar('-', 0);
 8526:   if (offset == -1) {
 8526:     if (lang.Length() == 2) {
 8526:       aLocale->language = ::SysAllocString(lang.get());
 8526:       return S_OK;
 8526:     }
 8526:   } else if (offset == 2) {
 8526:     aLocale->language = ::SysAllocStringLen(lang.get(), 2);
 8526: 
 8526:     // If the first subcode consists from two letters then expose it as
 8526:     // country.
 8526:     offset = lang.FindChar('-', 3);
 8526:     if (offset == -1) {
 8526:       if (lang.Length() == 5) {
 8526:         aLocale->country = ::SysAllocString(lang.get() + 3);
 8526:         return S_OK;
 8526:       }
 8526:     } else if (offset == 5) {
 8526:       aLocale->country = ::SysAllocStringLen(lang.get() + 3, 2);
 8526:     }
 8526:   }
 8526: 
 8526:   // Expose as a string if primary code or subcode cannot point to language or
 8526:   // country abbreviations or if there are more than one subcode.
 8526:   aLocale->variant = ::SysAllocString(lang.get());
13730:   return S_OK;
13730: 
11440: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
13730:   return E_FAIL;
    1: }
    1: 
    1: STDMETHODIMP
  665: nsAccessibleWrap::get_attributes(BSTR *aAttributes)
    1: {
  665:   // The format is name:value;name:value; with \ for escaping these
  665:   // characters ":;=,\".
11440: __try {
12838:   *aAttributes = NULL;
12838: 
  665:   nsCOMPtr<nsIPersistentProperties> attributes;
13730:   nsresult rv = GetAttributes(getter_AddRefs(attributes));
13730:   if (NS_FAILED(rv))
13730:     return GetHRESULT(rv);
  665: 
16001:   return ConvertToIA2Attributes(attributes, aAttributes);
12698: 
11440: } __except(nsAccessNodeWrap::FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
13730:   return E_FAIL;
    1: }
    1: 
    1: // For IDispatch support
    1: STDMETHODIMP
    1: nsAccessibleWrap::GetTypeInfoCount(UINT *p)
    1: {
    1:   *p = 0;
    1:   return E_NOTIMPL;
    1: }
    1: 
    1: // For IDispatch support
    1: STDMETHODIMP nsAccessibleWrap::GetTypeInfo(UINT i, LCID lcid, ITypeInfo **ppti)
    1: {
    1:   *ppti = 0;
    1:   return E_NOTIMPL;
    1: }
    1: 
    1: // For IDispatch support
    1: STDMETHODIMP
    1: nsAccessibleWrap::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames,
    1:                            UINT cNames, LCID lcid, DISPID *rgDispId)
    1: {
    1:   return E_NOTIMPL;
    1: }
    1: 
    1: // For IDispatch support
    1: STDMETHODIMP nsAccessibleWrap::Invoke(DISPID dispIdMember, REFIID riid,
    1:     LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
    1:     VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
    1: {
    1:   return E_NOTIMPL;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsAccessibleWrap::GetNativeInterface(void **aOutAccessible)
    1: {
 3233:   *aOutAccessible = static_cast<IAccessible*>(this);
    1:   NS_ADDREF_THIS();
    1:   return NS_OK;
    1: }
    1: 
  563: // nsPIAccessible
  563: 
  563: NS_IMETHODIMP
  563: nsAccessibleWrap::FireAccessibleEvent(nsIAccessibleEvent *aEvent)
  563: {
  563:   NS_ENSURE_ARG(aEvent);
  563: 
  563:   nsresult rv = nsAccessible::FireAccessibleEvent(aEvent);
  563:   NS_ENSURE_SUCCESS(rv, rv);
  563: 
15375:   return FirePlatformEvent(aEvent);
15375: }
15375: 
15375: nsresult
15375: nsAccessibleWrap::FirePlatformEvent(nsIAccessibleEvent *aEvent)
15375: {
  563:   PRUint32 eventType = 0;
  563:   aEvent->GetEventType(&eventType);
  563: 
  563:   NS_ENSURE_TRUE(eventType > 0 &&
  563:                  eventType < nsIAccessibleEvent::EVENT_LAST_ENTRY,
  563:                  NS_ERROR_FAILURE);
  563: 
  563:   PRUint32 winLastEntry = gWinEventMap[nsIAccessibleEvent::EVENT_LAST_ENTRY];
  563:   NS_ASSERTION(winLastEntry == kEVENT_LAST_ENTRY,
  563:                "MSAA event map skewed");
  563: 
  563:   PRUint32 winEvent = gWinEventMap[eventType];
  563:   if (!winEvent)
  563:     return NS_OK;
  563: 
  563:   // Means we're not active.
  563:   NS_ENSURE_TRUE(mWeakShell, NS_ERROR_FAILURE);
  563: 
  563:   nsCOMPtr<nsIAccessible> accessible;
  563:   aEvent->GetAccessible(getter_AddRefs(accessible));
  563:   if (!accessible)
  563:     return NS_OK;
  563: 
 2395:   if (eventType == nsIAccessibleEvent::EVENT_TEXT_CARET_MOVED ||
 2395:       eventType == nsIAccessibleEvent::EVENT_FOCUS) {
 2395:     UpdateSystemCaret();
  563:   }
  563:  
 1250:   PRInt32 childID = GetChildIDFor(accessible); // get the id for the accessible
 1250:   if (!childID)
 1250:     return NS_OK; // Can't fire an event without a child ID
 1250: 
 1250:   // See if we're in a scrollable area with its own window
 1250:   nsCOMPtr<nsIAccessible> newAccessible;
 4516:   if (eventType == nsIAccessibleEvent::EVENT_ASYNCH_HIDE ||
 4516:       eventType == nsIAccessibleEvent::EVENT_DOM_DESTROY) {
 1250:     // Don't use frame from current accessible when we're hiding that
 1250:     // accessible.
 1250:     accessible->GetParent(getter_AddRefs(newAccessible));
 1250:   } else {
 1250:     newAccessible = accessible;
 1250:   }
 1249: 
13347:   HWND hWnd = GetHWNDFor(newAccessible);
 2950:   NS_ENSURE_TRUE(hWnd, NS_ERROR_FAILURE);
  563: 
  563:   // Gecko uses two windows for every scrollable area. One window contains
  563:   // scrollbars and the child window contains only the client area.
  563:   // Details of the 2 window system:
  563:   // * Scrollbar window: caret drawing window & return value for WindowFromAccessibleObject()
  563:   // * Client area window: text drawing window & MSAA event window
  563: 
  563:   // Fire MSAA event for client area window.
 1249:   NotifyWinEvent(winEvent, hWnd, OBJID_CLIENT, childID);
  563: 
15720:   // If the accessible children are changed then drop the IEnumVariant current
15720:   // position of the accessible.
15720:   if (eventType == nsIAccessibleEvent::EVENT_REORDER)
15720:     UnattachIEnumVariant();
15720: 
  563:   return NS_OK;
  563: }
    1: 
    1: //------- Helper methods ---------
    1: 
  563: PRInt32 nsAccessibleWrap::GetChildIDFor(nsIAccessible* aAccessible)
  563: {
  563:   // A child ID of the window is required, when we use NotifyWinEvent,
  563:   // so that the 3rd party application can call back and get the IAccessible
  563:   // the event occured on.
  563: 
12698:   void *uniqueID = nsnull;
  563:   nsCOMPtr<nsIAccessNode> accessNode(do_QueryInterface(aAccessible));
  563:   if (!accessNode) {
  563:     return 0;
  563:   }
  563:   accessNode->GetUniqueID(&uniqueID);
  563: 
  563:   // Yes, this means we're only compatibible with 32 bit
  563:   // MSAA is only available for 32 bit windows, so it's okay
  563:   return - NS_PTR_TO_INT32(uniqueID);
  563: }
  563: 
 2950: HWND
 2950: nsAccessibleWrap::GetHWNDFor(nsIAccessible *aAccessible)
 2950: {
21169:   nsRefPtr<nsAccessNode> accessNode = nsAccUtils::QueryAccessNode(aAccessible);
21169:   if (!accessNode)
 2950:     return 0;
 2950: 
 2950:   HWND hWnd = 0;
21169:   nsIFrame *frame = accessNode->GetFrame();
 2950:   if (frame) {
 2950:     nsIWidget *window = frame->GetWindow();
 2950:     PRBool isVisible;
 2950:     window->IsVisible(isVisible);
 2950:     if (isVisible) {
 2950:       // Short explanation:
 2950:       // If HWND for frame is inside a hidden window, fire the event on the
 2950:       // containing document's visible window.
 2950:       //
 2950:       // Long explanation:
 2950:       // This is really just to fix combo boxes with JAWS. Window-Eyes already
 2950:       // worked with combo boxes because they use the value change event in
 2950:       // the closed combo box case. JAWS will only pay attention to the focus
 2950:       // events on the list items. The JAWS developers haven't fixed that, so
 2950:       // we'll use the focus events to make JAWS work. However, JAWS is
 2950:       // ignoring events on a hidden window. So, in order to fix the bug where
 2950:       // JAWS doesn't echo the current option as it changes in a closed
 2950:       // combo box, we need to use an ensure that we never fire an event with
 2950:       // an HWND for a hidden window.
 2950:       hWnd = (HWND)frame->GetWindow()->GetNativeData(NS_NATIVE_WINDOW);
 2950:     }
 2950:   }
 2950: 
 2950:   if (!hWnd) {
 2950:     void* handle = nsnull;
 2950:     nsCOMPtr<nsIAccessibleDocument> accessibleDoc;
 2950:     accessNode->GetAccessibleDocument(getter_AddRefs(accessibleDoc));
 2950:     if (!accessibleDoc)
 2950:       return 0;
 2950: 
 2950:     accessibleDoc->GetWindowHandle(&handle);
 2950:     hWnd = (HWND)handle;
 2950:   }
 2950: 
 2950:   return hWnd;
 2950: }
 2950: 
16001: HRESULT
16001: nsAccessibleWrap::ConvertToIA2Attributes(nsIPersistentProperties *aAttributes,
16001:                                          BSTR *aIA2Attributes)
16001: {
16001:   *aIA2Attributes = NULL;
16001: 
16001:   // The format is name:value;name:value; with \ for escaping these
16001:   // characters ":;=,\".
16001: 
16001:   if (!aAttributes)
16001:     return S_FALSE;
16001: 
16001:   nsCOMPtr<nsISimpleEnumerator> propEnum;
16001:   aAttributes->Enumerate(getter_AddRefs(propEnum));
16001:   if (!propEnum)
16001:     return E_FAIL;
16001: 
16001:   nsAutoString strAttrs;
16001: 
16001:   const char kCharsToEscape[] = ":;=,\\";
16001: 
16001:   PRBool hasMore = PR_FALSE;
16001:   while (NS_SUCCEEDED(propEnum->HasMoreElements(&hasMore)) && hasMore) {
16001:     nsCOMPtr<nsISupports> propSupports;
16001:     propEnum->GetNext(getter_AddRefs(propSupports));
16001: 
16001:     nsCOMPtr<nsIPropertyElement> propElem(do_QueryInterface(propSupports));
16001:     if (!propElem)
16001:       return E_FAIL;
16001: 
16001:     nsCAutoString name;
16001:     if (NS_FAILED(propElem->GetKey(name)))
16001:       return E_FAIL;
16001: 
16001:     PRUint32 offset = 0;
16001:     while ((offset = name.FindCharInSet(kCharsToEscape, offset)) != kNotFound) {
16001:       name.Insert('\\', offset);
16001:       offset += 2;
16001:     }
16001: 
16001:     nsAutoString value;
16001:     if (NS_FAILED(propElem->GetValue(value)))
16001:       return E_FAIL;
16001: 
16001:     offset = 0;
16001:     while ((offset = value.FindCharInSet(kCharsToEscape, offset)) != kNotFound) {
16001:       value.Insert('\\', offset);
16001:       offset += 2;
16001:     }
16001: 
16001:     AppendUTF8toUTF16(name, strAttrs);
16001:     strAttrs.Append(':');
16001:     strAttrs.Append(value);
16001:     strAttrs.Append(';');
16001:   }
16001: 
16001:   if (strAttrs.IsEmpty())
16001:     return S_FALSE;
16001: 
16001:   *aIA2Attributes = ::SysAllocStringLen(strAttrs.get(), strAttrs.Length());
16001:   return *aIA2Attributes ? S_OK : E_OUTOFMEMORY;
16001: }
16001: 
    1: IDispatch *nsAccessibleWrap::NativeAccessible(nsIAccessible *aXPAccessible)
    1: {
 1581:   if (!aXPAccessible) {
 1581:    NS_WARNING("Not passing in an aXPAccessible");
 1581:    return NULL;
 1581:   }
 1581: 
    1:   nsCOMPtr<nsIAccessibleWin32Object> accObject(do_QueryInterface(aXPAccessible));
    1:   if (accObject) {
12698:     void* hwnd = nsnull;
    1:     accObject->GetHwnd(&hwnd);
    1:     if (hwnd) {
    1:       IDispatch *retval = nsnull;
 3233:       AccessibleObjectFromWindow(reinterpret_cast<HWND>(hwnd),
    1:         OBJID_WINDOW, IID_IAccessible, (void **) &retval);
    1:       return retval;
    1:     }
    1:   }
    1: 
    1:   IAccessible *msaaAccessible;
    1:   aXPAccessible->GetNativeInterface((void**)&msaaAccessible);
    1: 
 3233:   return static_cast<IDispatch*>(msaaAccessible);
    1: }
    1: 
15720: void
15720: nsAccessibleWrap::UnattachIEnumVariant()
15720: {
15720:   if (mEnumVARIANTPosition > 0)
15720:     mEnumVARIANTPosition = kIEnumVariantDisconnected;
15720: }
    1: 
    1: void nsAccessibleWrap::GetXPAccessibleFor(const VARIANT& aVarChild, nsIAccessible **aXPAccessible)
    1: {
    1:   *aXPAccessible = nsnull;
    1:   if (!mWeakShell)
    1:     return; // Fail, we don't want to do anything after we've shut down
    1: 
    1:   // if its us real easy - this seems to always be the case
    1:   if (aVarChild.lVal == CHILDID_SELF) {
 3233:     *aXPAccessible = static_cast<nsIAccessible*>(this);
    1:   }
20566:   else if (nsAccUtils::MustPrune(this)) {
    1:     return;
    1:   }
    1:   else {
    1:     // XXX It is rare to use a VARIANT with a child num
    1:     // so optimizing this is not a priority
    1:     // We can come back it do it later, if there are perf problems
    1:     // with a specific assistive technology
    1:     nsCOMPtr<nsIAccessible> xpAccessible, nextAccessible;
    1:     GetFirstChild(getter_AddRefs(xpAccessible));
    1:     for (PRInt32 index = 0; xpAccessible; index ++) {
    1:       if (!xpAccessible)
    1:         break; // Failed
    1:       if (aVarChild.lVal == index) {
    1:         *aXPAccessible = xpAccessible;
    1:         break;
    1:       }
    1:       nextAccessible = xpAccessible;
    1:       nextAccessible->GetNextSibling(getter_AddRefs(xpAccessible));
    1:     }
    1:   }
    1:   NS_IF_ADDREF(*aXPAccessible);
    1: }
    1: 
 2395: void nsAccessibleWrap::UpdateSystemCaret()
 2395: {
 2395:   // Move the system caret so that Windows Tablet Edition and tradional ATs with 
 2395:   // off-screen model can follow the caret
 2395:   ::DestroyCaret();
 2395: 
 2395:   nsRefPtr<nsRootAccessible> rootAccessible = GetRootAccessible();
 2395:   if (!rootAccessible) {
 2395:     return;
 2395:   }
 2395: 
 2395:   nsRefPtr<nsCaretAccessible> caretAccessible = rootAccessible->GetCaretAccessible();
 2395:   if (!caretAccessible) {
 2395:     return;
 2395:   }
 2395: 
 2395:   nsIWidget *widget;
23738:   nsIntRect caretRect = caretAccessible->GetCaretRect(&widget);
 2395:   HWND caretWnd; 
 2395:   if (caretRect.IsEmpty() || !(caretWnd = (HWND)widget->GetNativeData(NS_NATIVE_WINDOW))) {
 2395:     return;
 2395:   }
 2395: 
 2395:   // Create invisible bitmap for caret, otherwise its appearance interferes
 2395:   // with Gecko caret
 2395:   HBITMAP caretBitMap = CreateBitmap(1, caretRect.height, 1, 1, NULL);
 2395:   if (::CreateCaret(caretWnd, caretBitMap, 1, caretRect.height)) {  // Also destroys the last caret
 2395:     ::ShowCaret(caretWnd);
 2395:     RECT windowRect;
 2395:     ::GetWindowRect(caretWnd, &windowRect);
 2395:     ::SetCaretPos(caretRect.x - windowRect.left, caretRect.y - windowRect.top);
 2395:     ::DeleteObject(caretBitMap);
 2395:   }
 2395: }
