41954: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
41954: /* vim:set ts=2 sw=2 sts=2 et cindent: */
41954: /* ***** BEGIN LICENSE BLOCK *****
41954:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
41954:  *
41954:  * The contents of this file are subject to the Mozilla Public License Version
41954:  * 1.1 (the "License"); you may not use this file except in compliance with
41954:  * the License. You may obtain a copy of the License at
41954:  * http://www.mozilla.org/MPL/
41954:  *
41954:  * Software distributed under the License is distributed on an "AS IS" basis,
41954:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
41954:  * for the specific language governing rights and limitations under the
41954:  * License.
41954:  *
41954:  * The Original Code is Mozilla code.
41954:  *
41954:  * The Initial Developer of the Original Code is the Mozilla Corporation.
41954:  * Portions created by the Initial Developer are Copyright (C) 2007
41954:  * the Initial Developer. All Rights Reserved.
41954:  *
41954:  * Contributor(s):
41954:  *  Chris Double <chris.double@double.co.nz>
41954:  *  Chris Pearce <chris@pearce.org.nz>
41954:  *
41954:  * Alternatively, the contents of this file may be used under the terms of
41954:  * either the GNU General Public License Version 2 or later (the "GPL"), or
41954:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
41954:  * in which case the provisions of the GPL or the LGPL are applicable instead
41954:  * of those above. If you wish to allow use of your version of this file only
41954:  * under the terms of either the GPL or the LGPL, and not to allow others to
41954:  * use your version of this file under the terms of the MPL, indicate your
41954:  * decision by deleting the provisions above and replace them with the notice
41954:  * and other provisions required by the GPL or the LGPL. If you do not delete
41954:  * the provisions above, a recipient may use your version of this file under
41954:  * the terms of any one of the MPL, the GPL or the LGPL.
41954:  *
41954:  * ***** END LICENSE BLOCK ***** */
41954: #include "nsError.h"
41954: #include "nsBuiltinDecoderStateMachine.h"
41954: #include "nsBuiltinDecoder.h"
41954: #include "nsOggReader.h"
41954: #include "VideoUtils.h"
41954: #include "theora/theoradec.h"
51394: #include "nsTimeRanges.h"
63612: #include "mozilla/TimeStamp.h"
41954: 
41954: using namespace mozilla;
41954: 
41954: // Un-comment to enable logging of seek bisections.
41954: //#define SEEK_LOGGING
41954: 
41954: #ifdef PR_LOGGING
41954: extern PRLogModuleInfo* gBuiltinDecoderLog;
41954: #define LOG(type, msg) PR_LOG(gBuiltinDecoderLog, type, msg)
41954: #ifdef SEEK_LOGGING
41954: #define SEEK_LOG(type, msg) PR_LOG(gBuiltinDecoderLog, type, msg)
41954: #else
41954: #define SEEK_LOG(type, msg)
41954: #endif
41954: #else
41954: #define LOG(type, msg)
41954: #define SEEK_LOG(type, msg)
41954: #endif
41954: 
50947: // If we don't have a Theora video stream, then during seeking, if a seek
50947: // target is less than SEEK_DECODE_MARGIN ahead of the current playback
50947: // position, we'll just decode forwards rather than performing a bisection
50947: // search. If we have Theora video we use the maximum keyframe interval as
50947: // this value, rather than SEEK_DECODE_MARGIN. This makes small seeks faster.
68450: #define SEEK_DECODE_MARGIN 2000000
50947: 
68450: // The number of microseconds of "fuzz" we use in a bisection search over
50947: // HTTP. When we're seeking with fuzz, we'll stop the search if a bisection
68450: // lands between the seek target and SEEK_FUZZ_USECS microseconds before the
50947: // seek target.  This is becaue it's usually quicker to just keep downloading
50947: // from an exisiting connection than to do another bisection inside that
50947: // small range, which would open a new HTTP connetion.
68450: #define SEEK_FUZZ_USECS 500000
50947: 
50947: enum PageSyncResult {
50947:   PAGE_SYNC_ERROR = 1,
50947:   PAGE_SYNC_END_OF_RANGE= 2,
50947:   PAGE_SYNC_OK = 3
50947: };
50947: 
50947: // Reads a page from the media stream.
50947: static PageSyncResult
50947: PageSync(nsMediaStream* aStream,
50947:          ogg_sync_state* aState,
50947:          PRBool aCachedDataOnly,
50947:          PRInt64 aOffset,
50947:          PRInt64 aEndOffset,
50947:          ogg_page* aPage,
50947:          int& aSkippedBytes);
50947: 
41954: // Chunk size to read when reading Ogg files. Average Ogg page length
41954: // is about 4300 bytes, so we read the file in chunks larger than that.
41954: static const int PAGE_STEP = 8192;
41954: 
69456: class nsAutoReleasePacket {
69456: public:
69456:   nsAutoReleasePacket(ogg_packet* aPacket) : mPacket(aPacket) { }
69456:   ~nsAutoReleasePacket() {
69456:     nsOggCodecState::ReleasePacket(mPacket);
69456:   }
69456: private:
69456:   ogg_packet* mPacket;
69456: };
69456: 
41954: nsOggReader::nsOggReader(nsBuiltinDecoder* aDecoder)
41954:   : nsBuiltinDecoderReader(aDecoder),
41954:     mTheoraState(nsnull),
41954:     mVorbisState(nsnull),
50947:     mSkeletonState(nsnull),
59429:     mVorbisSerial(0),
59429:     mTheoraSerial(0),
69456:     mPageOffset(0)
41954: {
41954:   MOZ_COUNT_CTOR(nsOggReader);
72348:   memset(&mTheoraInfo, 0, sizeof(mTheoraInfo));
41954: }
41954: 
41954: nsOggReader::~nsOggReader()
41954: {
41954:   ogg_sync_clear(&mOggState);
41954:   MOZ_COUNT_DTOR(nsOggReader);
41954: }
41954: 
54993: nsresult nsOggReader::Init(nsBuiltinDecoderReader* aCloneDonor) {
41954:   PRBool init = mCodecStates.Init();
41954:   NS_ASSERTION(init, "Failed to initialize mCodecStates");
41954:   if (!init) {
41954:     return NS_ERROR_FAILURE;
41954:   }
41954:   int ret = ogg_sync_init(&mOggState);
41954:   NS_ENSURE_TRUE(ret == 0, NS_ERROR_FAILURE);
41954:   return NS_OK;
41954: }
41954: 
41954: nsresult nsOggReader::ResetDecode()
41954: {
73698:   NS_ASSERTION(mDecoder->OnDecodeThread(), "Should be on decode thread.");
41954:   nsresult res = NS_OK;
41954: 
41954:   if (NS_FAILED(nsBuiltinDecoderReader::ResetDecode())) {
41954:     res = NS_ERROR_FAILURE;
41954:   }
41954: 
41954:   // Discard any previously buffered packets/pages.
41954:   ogg_sync_reset(&mOggState);
41954:   if (mVorbisState && NS_FAILED(mVorbisState->Reset())) {
41954:     res = NS_ERROR_FAILURE;
41954:   }
41954:   if (mTheoraState && NS_FAILED(mTheoraState->Reset())) {
41954:     res = NS_ERROR_FAILURE;
41954:   }
41954: 
41954:   return res;
41954: }
41954: 
69456: PRBool nsOggReader::ReadHeaders(nsOggCodecState* aState)
69456: {
69456:   while (!aState->DoneReadingHeaders()) {
69456:     ogg_packet* packet = NextOggPacket(aState);
69456:     nsAutoReleasePacket autoRelease(packet);
69456:     if (!packet || !aState->IsHeader(packet)) {
69456:       aState->Deactivate();
69456:     } else {
69456:       aState->DecodeHeader(packet);
41954:     }
41954:   }
69456:   return aState->Init();
41954: }
41954: 
63857: nsresult nsOggReader::ReadMetadata(nsVideoInfo* aInfo)
41954: {
73696:   NS_ASSERTION(mDecoder->OnDecodeThread(), "Should be on decode thread.");
41954: 
41954:   // We read packets until all bitstreams have read all their header packets.
41954:   // We record the offset of the first non-header page so that we know
41954:   // what page to seek to when seeking to the media start.
41954: 
41954:   ogg_page page;
41954:   nsAutoTArray<nsOggCodecState*,4> bitstreams;
41954:   PRBool readAllBOS = PR_FALSE;
69456:   while (!readAllBOS) {
69456:     PRInt64 pageOffset = ReadOggPage(&page);
41954:     if (pageOffset == -1) {
41954:       // Some kind of error...
41954:       break;
41954:     }
41954: 
41954:     int serial = ogg_page_serialno(&page);
41954:     nsOggCodecState* codecState = 0;
41954: 
41954:     if (ogg_page_bos(&page)) {
41954:       NS_ASSERTION(!readAllBOS, "We shouldn't encounter another BOS page");
41954:       codecState = nsOggCodecState::Create(&page);
64059: 
64059: #ifdef DEBUG
64059:       PRBool r =
64059: #endif
64059:       mCodecStates.Put(serial, codecState);
41954:       NS_ASSERTION(r, "Failed to insert into mCodecStates");
41954:       bitstreams.AppendElement(codecState);
59429:       mKnownStreams.AppendElement(serial);
41954:       if (codecState &&
41954:           codecState->GetType() == nsOggCodecState::TYPE_VORBIS &&
41954:           !mVorbisState)
41954:       {
41954:         // First Vorbis bitstream, we'll play this one. Subsequent Vorbis
41954:         // bitstreams will be ignored.
41954:         mVorbisState = static_cast<nsVorbisState*>(codecState);
41954:       }
41954:       if (codecState &&
41954:           codecState->GetType() == nsOggCodecState::TYPE_THEORA &&
41954:           !mTheoraState)
41954:       {
41954:         // First Theora bitstream, we'll play this one. Subsequent Theora
41954:         // bitstreams will be ignored.
41954:         mTheoraState = static_cast<nsTheoraState*>(codecState);
41954:       }
50947:       if (codecState &&
50947:           codecState->GetType() == nsOggCodecState::TYPE_SKELETON &&
50947:           !mSkeletonState)
50947:       {
50947:         mSkeletonState = static_cast<nsSkeletonState*>(codecState);
50947:       }
41954:     } else {
41954:       // We've encountered the a non Beginning Of Stream page. No more
41954:       // BOS pages can follow in this Ogg segment, so there will be no other
41954:       // bitstreams in the Ogg (unless it's invalid).
41954:       readAllBOS = PR_TRUE;
41954:     }
41954: 
41954:     mCodecStates.Get(serial, &codecState);
41954:     NS_ENSURE_TRUE(codecState, NS_ERROR_FAILURE);
41954: 
69456:     if (NS_FAILED(codecState->PageIn(&page))) {
69456:       return NS_ERROR_FAILURE;
69456:     }
69456:   }
41954: 
69456:   // We've read all BOS pages, so we know the streams contained in the media.
69456:   // Now process all available header packets in the active Theora, Vorbis and
69456:   // Skeleton streams.
69456: 
41954:   // Deactivate any non-primary bitstreams.
41954:   for (PRUint32 i = 0; i < bitstreams.Length(); i++) {
41954:     nsOggCodecState* s = bitstreams[i];
50947:     if (s != mVorbisState && s != mTheoraState && s != mSkeletonState) {
41954:       s->Deactivate();
41954:     }
41954:   }
41954: 
69456:   if (mTheoraState && ReadHeaders(mTheoraState)) {
72348:     nsIntRect picture = nsIntRect(mTheoraState->mInfo.pic_x,
61490:                                   mTheoraState->mInfo.pic_y,
61490:                                   mTheoraState->mInfo.pic_width,
61490:                                   mTheoraState->mInfo.pic_height);
72348: 
72348:     nsIntSize displaySize = nsIntSize(mTheoraState->mInfo.pic_width,
72348:                                       mTheoraState->mInfo.pic_height);
72348: 
72348:     // Apply the aspect ratio to produce the intrinsic display size we report
72348:     // to the element.
72348:     ScaleDisplayByAspectRatio(displaySize, mTheoraState->mPixelAspectRatio);
72348: 
72348:     nsIntSize frameSize(mTheoraState->mInfo.frame_width,
61490:                         mTheoraState->mInfo.frame_height);
72348:     if (nsVideoInfo::ValidateVideoRegion(frameSize, picture, displaySize)) {
72348:       // Video track's frame sizes will not overflow. Activate the video track.
72348:       mInfo.mHasVideo = PR_TRUE;
72348:       mInfo.mDisplay = displaySize;
72348:       mPicture = picture;
72348: 
72348:       mDecoder->SetVideoData(gfxIntSize(displaySize.width, displaySize.height),
69456:                              nsnull,
69456:                              TimeStamp::Now());
72348: 
69456:       // Copy Theora info data for time computations on other threads.
69456:       memcpy(&mTheoraInfo, &mTheoraState->mInfo, sizeof(mTheoraInfo));
69456:       mTheoraSerial = mTheoraState->mSerial;
72348:     }
41954:   }
41954: 
69456:   if (mVorbisState && ReadHeaders(mVorbisState)) {
69456:     mInfo.mHasAudio = PR_TRUE;
69456:     mInfo.mAudioRate = mVorbisState->mInfo.rate;
69456:     mInfo.mAudioChannels = mVorbisState->mInfo.channels;
69456:     // Copy Vorbis info data for time computations on other threads.
69456:     memcpy(&mVorbisInfo, &mVorbisState->mInfo, sizeof(mVorbisInfo));
69456:     mVorbisInfo.codec_setup = NULL;
69456:     mVorbisSerial = mVorbisState->mSerial;
69456:   } else {
69456:     memset(&mVorbisInfo, 0, sizeof(mVorbisInfo));
69456:   }
69456: 
69456:   if (mSkeletonState) {
69456:     if (!HasAudio() && !HasVideo()) {
69456:       // We have a skeleton track, but no audio or video, may as well disable
69456:       // the skeleton, we can't do anything useful with this media.
69456:       mSkeletonState->Deactivate();
69456:     } else if (ReadHeaders(mSkeletonState) && mSkeletonState->HasIndex()) {
50947:       // Extract the duration info out of the index, so we don't need to seek to
50947:       // the end of stream to get it.
50947:       nsAutoTArray<PRUint32, 2> tracks;
50947:       if (HasVideo()) {
50947:         tracks.AppendElement(mTheoraState->mSerial);
50947:       }
50947:       if (HasAudio()) {
50947:         tracks.AppendElement(mVorbisState->mSerial);
50947:       }
50947:       PRInt64 duration = 0;
50947:       if (NS_SUCCEEDED(mSkeletonState->GetDuration(tracks, duration))) {
73698:         ReentrantMonitorAutoEnter mon(mDecoder->GetReentrantMonitor());
50947:         mDecoder->GetStateMachine()->SetDuration(duration);
50947:         LOG(PR_LOG_DEBUG, ("Got duration from Skeleton index %lld", duration));
50947:       }
50947:     }
59429:   }
59429: 
69475:   {
73698:     ReentrantMonitorAutoEnter mon(mDecoder->GetReentrantMonitor());
69475: 
69475:     nsMediaStream* stream = mDecoder->GetCurrentStream();
69475:     if (mDecoder->GetStateMachine()->GetDuration() == -1 &&
69475:         mDecoder->GetStateMachine()->GetState() != nsDecoderStateMachine::DECODER_STATE_SHUTDOWN &&
69475:         stream->GetLength() >= 0 &&
69475:         mDecoder->GetStateMachine()->GetSeekable())
69475:     {
69475:       // We didn't get a duration from the index or a Content-Duration header.
69475:       // Seek to the end of file to find the end time.
69475:       PRInt64 length = stream->GetLength();
69475:       NS_ASSERTION(length > 0, "Must have a content length to get end time");
69475: 
69475:       PRInt64 endTime = 0;
69475:       {
69475:         ReentrantMonitorAutoExit exitMon(mDecoder->GetReentrantMonitor());
69475:         endTime = RangeEndTime(length);
69475:       }
69475:       if (endTime != -1) {
69475:         mDecoder->GetStateMachine()->SetEndTime(endTime);
69475:         LOG(PR_LOG_DEBUG, ("Got Ogg duration from seeking to end %lld", endTime));
69475:       }
69475:     }
69475:   }
63857:   *aInfo = mInfo;
63857: 
41954:   return NS_OK;
41954: }
41954: 
69456: nsresult nsOggReader::DecodeVorbis(ogg_packet* aPacket) {
69456:   NS_ASSERTION(aPacket->granulepos != -1, "Must know vorbis granulepos!");
69456: 
41954:   if (vorbis_synthesis(&mVorbisState->mBlock, aPacket) != 0) {
41954:     return NS_ERROR_FAILURE;
41954:   }
41954:   if (vorbis_synthesis_blockin(&mVorbisState->mDsp,
41954:                                &mVorbisState->mBlock) != 0)
41954:   {
41954:     return NS_ERROR_FAILURE;
41954:   }
41954: 
56070:   VorbisPCMValue** pcm = 0;
50359:   PRInt32 samples = 0;
41954:   PRUint32 channels = mVorbisState->mInfo.channels;
69456:   ogg_int64_t endSample = aPacket->granulepos;
41954:   while ((samples = vorbis_synthesis_pcmout(&mVorbisState->mDsp, &pcm)) > 0) {
69456:     mVorbisState->ValidateVorbisPacketSamples(aPacket, samples);
56070:     SoundDataValue* buffer = new SoundDataValue[samples * channels];
56070:     for (PRUint32 j = 0; j < channels; ++j) {
56070:       VorbisPCMValue* channel = pcm[j];
53765:       for (PRUint32 i = 0; i < PRUint32(samples); ++i) {
56070:         buffer[i*channels + j] = MOZ_CONVERT_VORBIS_SAMPLE(channel[i]);
41954:       }
41954:     }
41954: 
41954:     PRInt64 duration = mVorbisState->Time((PRInt64)samples);
69456:     PRInt64 startTime = mVorbisState->Time(endSample - samples);
41954:     SoundData* s = new SoundData(mPageOffset,
41954:                                  startTime,
41954:                                  duration,
41954:                                  samples,
41954:                                  buffer,
41954:                                  channels);
69456:     mAudioQueue.Push(s);
69456:     endSample -= samples;
41954:     if (vorbis_synthesis_read(&mVorbisState->mDsp, samples) != 0) {
41954:       return NS_ERROR_FAILURE;
41954:     }
41954:   }
41954:   return NS_OK;
41954: }
41954: 
41954: PRBool nsOggReader::DecodeAudioData()
41954: {
73697:   NS_ASSERTION(mDecoder->OnDecodeThread(), "Should be on decode thread.");
41954:   NS_ASSERTION(mVorbisState!=0, "Need Vorbis state to decode audio");
41954: 
69456:   // Read the next data packet. Skip any non-data packets we encounter.
69456:   ogg_packet* packet = 0;
69456:   do {
69456:     if (packet) {
69456:       nsOggCodecState::ReleasePacket(packet);
41954:     }
69456:     packet = NextOggPacket(mVorbisState);
69456:   } while (packet && mVorbisState->IsHeader(packet));
69456:   if (!packet) {
69456:     mAudioQueue.Finish();
69456:     return PR_FALSE;
41954:   }
41954: 
69456:   NS_ASSERTION(packet && packet->granulepos != -1,
69456:     "Must have packet with known granulepos");
69456:   nsAutoReleasePacket autoRelease(packet);
69456:   DecodeVorbis(packet);
69456:   if (packet->e_o_s) {
41954:     // We've encountered an end of bitstream packet, or we've hit the end of
41954:     // file while trying to decode, so inform the audio queue that there'll
41954:     // be no more samples.
41954:     mAudioQueue.Finish();
41954:     return PR_FALSE;
41954:   }
41954: 
41954:   return PR_TRUE;
41954: }
41954: 
71446: nsresult nsOggReader::DecodeTheora(ogg_packet* aPacket, PRInt64 aTimeThreshold)
41954: {
69456:   NS_ASSERTION(aPacket->granulepos >= TheoraVersion(&mTheoraState->mInfo,3,2,1),
69456:     "Packets must have valid granulepos and packetno");
69456: 
41954:   int ret = th_decode_packetin(mTheoraState->mCtx, aPacket, 0);
41954:   if (ret != 0 && ret != TH_DUPFRAME) {
41954:     return NS_ERROR_FAILURE;
41954:   }
68450:   PRInt64 time = mTheoraState->StartTime(aPacket->granulepos);
69456: 
69456:   // Don't use the frame if it's outside the bounds of the presentation
69456:   // start time in the skeleton track. Note we still must submit the frame
69456:   // to the decoder (via th_decode_packetin), as the frames which are
69456:   // presentable may depend on this frame's data.
69456:   if (mSkeletonState && !mSkeletonState->IsPresentable(time)) {
69456:     return NS_OK;
69456:   }
69456: 
68450:   PRInt64 endTime = mTheoraState->Time(aPacket->granulepos);
71446:   if (endTime < aTimeThreshold) {
71446:     // The end time of this frame is already before the current playback
71446:     // position. It will never be displayed, don't bother enqueing it.
71446:     return NS_OK;
71446:   }
71446: 
41954:   if (ret == TH_DUPFRAME) {
53829:     VideoData* v = VideoData::CreateDuplicate(mPageOffset,
41954:                                               time,
47961:                                               endTime,
53829:                                               aPacket->granulepos);
69456:     mVideoQueue.Push(v);
41954:   } else if (ret == 0) {
41954:     th_ycbcr_buffer buffer;
41954:     ret = th_decode_ycbcr_out(mTheoraState->mCtx, buffer);
41954:     NS_ASSERTION(ret == 0, "th_decode_ycbcr_out failed");
41954:     PRBool isKeyframe = th_packet_iskeyframe(aPacket) == 1;
41954:     VideoData::YCbCrBuffer b;
41954:     for (PRUint32 i=0; i < 3; ++i) {
41954:       b.mPlanes[i].mData = buffer[i].data;
41954:       b.mPlanes[i].mHeight = buffer[i].height;
41954:       b.mPlanes[i].mWidth = buffer[i].width;
41954:       b.mPlanes[i].mStride = buffer[i].stride;
41954:     }
63857: 
42438:     VideoData *v = VideoData::Create(mInfo,
42438:                                      mDecoder->GetImageContainer(),
42438:                                      mPageOffset,
41954:                                      time,
47961:                                      endTime,
41954:                                      b,
41954:                                      isKeyframe,
72348:                                      aPacket->granulepos,
72348:                                      mPicture);
41954:     if (!v) {
42438:       // There may be other reasons for this error, but for
42438:       // simplicity just assume the worst case: out of memory.
41954:       NS_WARNING("Failed to allocate memory for video frame");
41954:       return NS_ERROR_OUT_OF_MEMORY;
41954:     }
69456:     mVideoQueue.Push(v);
41954:   }
41954:   return NS_OK;
41954: }
41954: 
41954: PRBool nsOggReader::DecodeVideoFrame(PRBool &aKeyframeSkip,
41954:                                      PRInt64 aTimeThreshold)
41954: {
73697:   NS_ASSERTION(mDecoder->OnDecodeThread(), "Should be on decode thread.");
63611: 
63611:   // Record number of frames decoded and parsed. Automatically update the
63611:   // stats counters using the AutoNotifyDecoded stack-based class.
63611:   PRUint32 parsed = 0, decoded = 0;
63611:   nsMediaDecoder::AutoNotifyDecoded autoNotify(mDecoder, parsed, decoded);
63611: 
69456:   // Read the next data packet. Skip any non-data packets we encounter.
69456:   ogg_packet* packet = 0;
41954:   do {
69456:     if (packet) {
69456:       nsOggCodecState::ReleasePacket(packet);
69456:     }
69456:     packet = NextOggPacket(mTheoraState);
69456:   } while (packet && mTheoraState->IsHeader(packet));
69456:   if (!packet) {
41954:     mVideoQueue.Finish();
41954:     return PR_FALSE;
41954:   }
69456:   nsAutoReleasePacket autoRelease(packet);
69456: 
63611:   parsed++;
69456:   NS_ASSERTION(packet && packet->granulepos != -1,
69456:                 "Must know first packet's granulepos");
69456:   PRBool eos = packet->e_o_s;
69456:   PRInt64 frameEndTime = mTheoraState->Time(packet->granulepos);
69456:   if (!aKeyframeSkip ||
69456:      (th_packet_iskeyframe(packet) && frameEndTime >= aTimeThreshold))
69456:   {
69456:     aKeyframeSkip = PR_FALSE;
71446:     nsresult res = DecodeTheora(packet, aTimeThreshold);
69456:     decoded++;
69456:     if (NS_FAILED(res)) {
69456:       return PR_FALSE;
69456:     }
41954:   }
41954: 
69456:   if (eos) {
69456:     // We've encountered an end of bitstream packet. Inform the queue that
69456:     // there will be no more frames.
69456:     mVideoQueue.Finish();
41954:     return PR_FALSE;
41954:   }
41954: 
69456:   return PR_TRUE;
41954: }
41954: 
41954: PRInt64 nsOggReader::ReadOggPage(ogg_page* aPage)
41954: {
73697:   NS_ASSERTION(mDecoder->OnDecodeThread(), "Should be on decode thread.");
41954: 
41954:   int ret = 0;
41954:   while((ret = ogg_sync_pageseek(&mOggState, aPage)) <= 0) {
41954:     if (ret < 0) {
41954:       // Lost page sync, have to skip up to next page.
41954:       mPageOffset += -ret;
41954:       continue;
41954:     }
41954:     // Returns a buffer that can be written too
41954:     // with the given size. This buffer is stored
41954:     // in the ogg synchronisation structure.
41954:     char* buffer = ogg_sync_buffer(&mOggState, 4096);
41954:     NS_ASSERTION(buffer, "ogg_sync_buffer failed");
41954: 
41954:     // Read from the stream into the buffer
41954:     PRUint32 bytesRead = 0;
41954: 
41954:     nsresult rv = mDecoder->GetCurrentStream()->Read(buffer, 4096, &bytesRead);
41954:     if (NS_FAILED(rv) || (bytesRead == 0 && ret == 0)) {
41954:       // End of file.
41954:       return -1;
41954:     }
41954: 
41954:     mDecoder->NotifyBytesConsumed(bytesRead);
41954:     // Update the synchronisation layer with the number
41954:     // of bytes written to the buffer
41954:     ret = ogg_sync_wrote(&mOggState, bytesRead);
41954:     NS_ENSURE_TRUE(ret == 0, -1);    
41954:   }
41954:   PRInt64 offset = mPageOffset;
41954:   mPageOffset += aPage->header_len + aPage->body_len;
41954:   
41954:   return offset;
41954: }
41954: 
69456: ogg_packet* nsOggReader::NextOggPacket(nsOggCodecState* aCodecState)
41954: {
73697:   NS_ASSERTION(mDecoder->OnDecodeThread(), "Should be on decode thread.");
41954: 
41954:   if (!aCodecState || !aCodecState->mActive) {
69456:     return nsnull;
41954:   }
41954: 
69456:   ogg_packet* packet;
69456:   while ((packet = aCodecState->PacketOut()) == nsnull) {
41954:     // The codec state does not have any buffered pages, so try to read another
41954:     // page from the channel.
69456:     ogg_page page;
41954:     if (ReadOggPage(&page) == -1) {
69456:       return nsnull;
41954:     }
41954: 
41954:     PRUint32 serial = ogg_page_serialno(&page);
41954:     nsOggCodecState* codecState = nsnull;
41954:     mCodecStates.Get(serial, &codecState);
69456:     if (codecState && NS_FAILED(codecState->PageIn(&page))) {
69456:       return nsnull;
41954:     }
41954:   }
41954: 
69456:   return packet;
41954: }
41954: 
41954: // Returns an ogg page's checksum.
41954: static ogg_uint32_t
41954: GetChecksum(ogg_page* page)
41954: {
41954:   if (page == 0 || page->header == 0 || page->header_len < 25) {
41954:     return 0;
41954:   }
41954:   const unsigned char* p = page->header + 22;
41954:   PRUint32 c =  p[0] +
41954:                (p[1] << 8) + 
41954:                (p[2] << 16) +
41954:                (p[3] << 24);
41954:   return c;
41954: }
41954: 
69475: PRInt64 nsOggReader::RangeStartTime(PRInt64 aOffset)
42513: {
73698:   NS_ASSERTION(mDecoder->OnDecodeThread(), "Should be on decode thread.");
42513:   nsMediaStream* stream = mDecoder->GetCurrentStream();
48904:   NS_ENSURE_TRUE(stream != nsnull, nsnull);
69456:   nsresult res = stream->Seek(nsISeekableStream::NS_SEEK_SET, aOffset);
48904:   NS_ENSURE_SUCCESS(res, nsnull);
69475:   PRInt64 startTime = 0;
69475:   nsBuiltinDecoderReader::FindStartTime(startTime);
69475:   return startTime;
42513: }
42513: 
69475: struct nsAutoOggSyncState {
69475:   nsAutoOggSyncState() {
69475:     ogg_sync_init(&mState);
69475:   }
69475:   ~nsAutoOggSyncState() {
69475:     ogg_sync_clear(&mState);
69475:   }
69475:   ogg_sync_state mState;
69475: };
69475: 
69475: PRInt64 nsOggReader::RangeEndTime(PRInt64 aEndOffset)
41954: {
73696:   NS_ASSERTION(mDecoder->OnStateMachineThread() || mDecoder->OnDecodeThread(),
73696:                "Should be on state machine or decode thread.");
69475: 
48904:   nsMediaStream* stream = mDecoder->GetCurrentStream();
48904:   NS_ENSURE_TRUE(stream != nsnull, -1);
69475:   PRInt64 position = stream->Tell();
69475:   PRInt64 endTime = RangeEndTime(0, aEndOffset, PR_FALSE);
69475:   nsresult res = stream->Seek(nsISeekableStream::NS_SEEK_SET, position);
48904:   NS_ENSURE_SUCCESS(res, -1);
48904:   return endTime;
48904: }
41954: 
69475: PRInt64 nsOggReader::RangeEndTime(PRInt64 aStartOffset,
63616:                                   PRInt64 aEndOffset,
69475:                                   PRBool aCachedDataOnly)
48904: {
41954:   nsMediaStream* stream = mDecoder->GetCurrentStream();
69475:   nsAutoOggSyncState sync;
41954: 
41954:   // We need to find the last page which ends before aEndOffset that
41954:   // has a granulepos that we can convert to a timestamp. We do this by
41954:   // backing off from aEndOffset until we encounter a page on which we can
41954:   // interpret the granulepos. If while backing off we encounter a page which
41954:   // we've previously encountered before, we'll either backoff again if we
41954:   // haven't found an end time yet, or return the last end time found.
41954:   const int step = 5000;
48904:   PRInt64 readStartOffset = aEndOffset;
48904:   PRInt64 readHead = aEndOffset;
41954:   PRInt64 endTime = -1;
41954:   PRUint32 checksumAfterSeek = 0;
41954:   PRUint32 prevChecksumAfterSeek = 0;
41954:   PRBool mustBackOff = PR_FALSE;
41954:   while (PR_TRUE) {
41954:     ogg_page page;    
69475:     int ret = ogg_sync_pageseek(&sync.mState, &page);
41954:     if (ret == 0) {
41954:       // We need more data if we've not encountered a page we've seen before,
41954:       // or we've read to the end of file.
63616:       if (mustBackOff || readHead == aEndOffset || readHead == aStartOffset) {
53767:         if (endTime != -1 || readStartOffset == 0) {
41954:           // We have encountered a page before, or we're at the end of file.
41954:           break;
41954:         }
41954:         mustBackOff = PR_FALSE;
41954:         prevChecksumAfterSeek = checksumAfterSeek;
41954:         checksumAfterSeek = 0;
69475:         ogg_sync_reset(&sync.mState);
48904:         readStartOffset = NS_MAX(static_cast<PRInt64>(0), readStartOffset - step);
63616:         readHead = NS_MAX(aStartOffset, readStartOffset);
41954:       }
41954: 
41954:       PRInt64 limit = NS_MIN(static_cast<PRInt64>(PR_UINT32_MAX),
48904:                              aEndOffset - readHead);
41954:       limit = NS_MAX(static_cast<PRInt64>(0), limit);
41954:       limit = NS_MIN(limit, static_cast<PRInt64>(step));
41954:       PRUint32 bytesToRead = static_cast<PRUint32>(limit);
41954:       PRUint32 bytesRead = 0;
69475:       char* buffer = ogg_sync_buffer(&sync.mState, bytesToRead);
41954:       NS_ASSERTION(buffer, "Must have buffer");
48904:       nsresult res;
48904:       if (aCachedDataOnly) {
48904:         res = stream->ReadFromCache(buffer, readHead, bytesToRead);
63616:         NS_ENSURE_SUCCESS(res, -1);
48904:         bytesRead = bytesToRead;
48904:       } else {
48904:         NS_ASSERTION(readHead < aEndOffset,
48904:                      "Stream pos must be before range end");
48904:         res = stream->Seek(nsISeekableStream::NS_SEEK_SET, readHead);
63616:         NS_ENSURE_SUCCESS(res, -1);
48904:         res = stream->Read(buffer, bytesToRead, &bytesRead);
63616:         NS_ENSURE_SUCCESS(res, -1);
48904:       }
48904:       readHead += bytesRead;
41954: 
41954:       // Update the synchronisation layer with the number
41954:       // of bytes written to the buffer
69475:       ret = ogg_sync_wrote(&sync.mState, bytesRead);
41954:       if (ret != 0) {
41954:         endTime = -1;
41954:         break;
41954:       }
41954: 
41954:       continue;
41954:     }
41954: 
41954:     if (ret < 0 || ogg_page_granulepos(&page) < 0) {
41954:       continue;
41954:     }
41954: 
41954:     PRUint32 checksum = GetChecksum(&page);
41954:     if (checksumAfterSeek == 0) {
41954:       // This is the first page we've decoded after a backoff/seek. Remember
41954:       // the page checksum. If we backoff further and encounter this page
41954:       // again, we'll know that we won't find a page with an end time after
41954:       // this one, so we'll know to back off again.
41954:       checksumAfterSeek = checksum;
41954:     }
41954:     if (checksum == prevChecksumAfterSeek) {
41954:       // This page has the same checksum as the first page we encountered
41954:       // after the last backoff/seek. Since we've already scanned after this
41954:       // page and failed to find an end time, we may as well backoff again and
41954:       // try to find an end time from an earlier page.
41954:       mustBackOff = PR_TRUE;
41954:       continue;
41954:     }
41954: 
41954:     PRInt64 granulepos = ogg_page_granulepos(&page);
41954:     int serial = ogg_page_serialno(&page);
41954: 
41954:     nsOggCodecState* codecState = nsnull;
41954:     mCodecStates.Get(serial, &codecState);
41954: 
41954:     if (!codecState) {
41954:       // This page is from a bitstream which we haven't encountered yet.
41954:       // It's probably from a new "link" in a "chained" ogg. Don't
41954:       // bother even trying to find a duration...
47254:       endTime = -1;
41954:       break;
41954:     }
41954: 
47254:     PRInt64 t = codecState->Time(granulepos);
41954:     if (t != -1) {
41954:       endTime = t;
41954:     }
41954:   }
41954: 
41954:   return endTime;
41954: }
41954: 
63625: nsresult nsOggReader::GetSeekRanges(nsTArray<SeekRange>& aRanges)
63625: {
73697:   NS_ASSERTION(mDecoder->OnDecodeThread(), "Should be on decode thread.");
63628:   nsTArray<nsByteRange> cached;
63628:   nsresult res = mDecoder->GetCurrentStream()->GetCachedRanges(cached);
63628:   NS_ENSURE_SUCCESS(res, res);
63628: 
68873:   for (PRUint32 index = 0; index < cached.Length(); index++) {
63628:     nsByteRange& range = cached[index];
63625:     PRInt64 startTime = -1;
63625:     PRInt64 endTime = -1;
63625:     if (NS_FAILED(ResetDecode())) {
63625:       return NS_ERROR_FAILURE;
63625:     }
69456:     PRInt64 startOffset = range.mStart;
69456:     PRInt64 endOffset = range.mEnd;
69475:     startTime = RangeStartTime(startOffset);
63625:     if (startTime != -1 &&
69475:         ((endTime = RangeEndTime(endOffset)) != -1))
63625:     {
63625:       NS_ASSERTION(startTime < endTime,
63625:                    "Start time must be before end time");
63625:       aRanges.AppendElement(SeekRange(startOffset,
63625:                                       endOffset,
63625:                                       startTime,
63625:                                       endTime));
63625:      }
63625:   }
63625:   if (NS_FAILED(ResetDecode())) {
63625:     return NS_ERROR_FAILURE;
63625:   }
63625:   return NS_OK;
63625: }
63625: 
63625: nsOggReader::SeekRange
63625: nsOggReader::SelectSeekRange(const nsTArray<SeekRange>& ranges,
63625:                              PRInt64 aTarget,
63625:                              PRInt64 aStartTime,
63625:                              PRInt64 aEndTime,
63625:                              PRBool aExact)
63625: {
73697:   NS_ASSERTION(mDecoder->OnDecodeThread(), "Should be on decode thread.");
69456:   PRInt64 so = 0;
63625:   PRInt64 eo = mDecoder->GetCurrentStream()->GetLength();
63625:   PRInt64 st = aStartTime;
63625:   PRInt64 et = aEndTime;
63625:   for (PRUint32 i = 0; i < ranges.Length(); i++) {
63625:     const SeekRange &r = ranges[i];
63625:     if (r.mTimeStart < aTarget) {
63625:       so = r.mOffsetStart;
63625:       st = r.mTimeStart;
63625:     }
63625:     if (r.mTimeEnd >= aTarget && r.mTimeEnd < et) {
63625:       eo = r.mOffsetEnd;
63625:       et = r.mTimeEnd;
63625:     }
63625: 
63625:     if (r.mTimeStart < aTarget && aTarget <= r.mTimeEnd) {
63625:       // Target lies exactly in this range.
63625:       return ranges[i];
63625:     }
63625:   }
74277:   if (aExact || eo == -1) {
74277:     return SeekRange();
74277:   }
74277:   return SeekRange(so, eo, st, et);
63625: }
63625: 
50947: nsOggReader::IndexedSeekResult nsOggReader::RollbackIndexedSeek(PRInt64 aOffset)
41954: {
50947:   mSkeletonState->Deactivate();
41954:   nsMediaStream* stream = mDecoder->GetCurrentStream();
50947:   NS_ENSURE_TRUE(stream != nsnull, SEEK_FATAL_ERROR);
50947:   nsresult res = stream->Seek(nsISeekableStream::NS_SEEK_SET, aOffset);
50947:   NS_ENSURE_SUCCESS(res, SEEK_FATAL_ERROR);
50947:   return SEEK_INDEX_FAIL;
41954: }
41954:  
50947: nsOggReader::IndexedSeekResult nsOggReader::SeekToKeyframeUsingIndex(PRInt64 aTarget)
50947: {
50947:   nsMediaStream* stream = mDecoder->GetCurrentStream();
50947:   NS_ENSURE_TRUE(stream != nsnull, SEEK_FATAL_ERROR);
50947:   if (!HasSkeleton() || !mSkeletonState->HasIndex()) {
50947:     return SEEK_INDEX_FAIL;
50947:   }
50947:   // We have an index from the Skeleton track, try to use it to seek.
50947:   nsAutoTArray<PRUint32, 2> tracks;
50947:   if (HasVideo()) {
50947:     tracks.AppendElement(mTheoraState->mSerial);
50947:   }
50947:   if (HasAudio()) {
50947:     tracks.AppendElement(mVorbisState->mSerial);
50947:   }
50947:   nsSkeletonState::nsSeekTarget keyframe;
50947:   if (NS_FAILED(mSkeletonState->IndexedSeekTarget(aTarget,
50947:                                                   tracks,
50947:                                                   keyframe)))
50947:   {
50947:     // Could not locate a keypoint for the target in the index.
50947:     return SEEK_INDEX_FAIL;
50947:   }
41954: 
50947:   // Remember original stream read cursor position so we can rollback on failure.
50947:   PRInt64 tell = stream->Tell();
50947: 
50947:   // Seek to the keypoint returned by the index.
50947:   if (keyframe.mKeyPoint.mOffset > stream->GetLength() ||
50947:       keyframe.mKeyPoint.mOffset < 0)
50947:   {
50947:     // Index must be invalid.
50947:     return RollbackIndexedSeek(tell);
50947:   }
50947:   LOG(PR_LOG_DEBUG, ("Seeking using index to keyframe at offset %lld\n",
50947:                      keyframe.mKeyPoint.mOffset));
50947:   nsresult res = stream->Seek(nsISeekableStream::NS_SEEK_SET,
50947:                               keyframe.mKeyPoint.mOffset);
50947:   NS_ENSURE_SUCCESS(res, SEEK_FATAL_ERROR);
50947:   mPageOffset = keyframe.mKeyPoint.mOffset;
50947: 
50947:   // We've moved the read set, so reset decode.
50947:   res = ResetDecode();
50947:   NS_ENSURE_SUCCESS(res, SEEK_FATAL_ERROR);
50947: 
50947:   // Check that the page the index thinks is exactly here is actually exactly
50947:   // here. If not, the index is invalid.
50947:   ogg_page page;
50947:   int skippedBytes = 0;
50947:   PageSyncResult syncres = PageSync(stream,
50947:                                     &mOggState,
50947:                                     PR_FALSE,
50947:                                     mPageOffset,
50947:                                     stream->GetLength(),
50947:                                     &page,
50947:                                     skippedBytes);
50947:   NS_ENSURE_TRUE(syncres != PAGE_SYNC_ERROR, SEEK_FATAL_ERROR);
50947:   if (syncres != PAGE_SYNC_OK || skippedBytes != 0) {
50947:     LOG(PR_LOG_DEBUG, ("Indexed-seek failure: Ogg Skeleton Index is invalid "
50947:                        "or sync error after seek"));
50947:     return RollbackIndexedSeek(tell);
50947:   }
50947:   PRUint32 serial = ogg_page_serialno(&page);
50947:   if (serial != keyframe.mSerial) {
50947:     // Serialno of page at offset isn't what the index told us to expect.
50947:     // Assume the index is invalid.
50947:     return RollbackIndexedSeek(tell);
50947:   }
50947:   nsOggCodecState* codecState = nsnull;
50947:   mCodecStates.Get(serial, &codecState);
50947:   if (codecState &&
50947:       codecState->mActive &&
50947:       ogg_stream_pagein(&codecState->mState, &page) != 0)
50947:   {
50947:     // Couldn't insert page into the ogg stream, or somehow the stream
50947:     // is no longer active.
50947:     return RollbackIndexedSeek(tell);
50947:   }      
50947:   mPageOffset = keyframe.mKeyPoint.mOffset + page.header_len + page.body_len;
50947:   return SEEK_OK;
50947: }
50947: 
50947: nsresult nsOggReader::SeekInBufferedRange(PRInt64 aTarget,
50947:                                           PRInt64 aStartTime,
50947:                                           PRInt64 aEndTime,
63625:                                           const nsTArray<SeekRange>& aRanges,
63625:                                           const SeekRange& aRange)
50947: {
73834:   LOG(PR_LOG_DEBUG, ("%p Seeking in buffered data to %lld using bisection search", mDecoder, aTarget));
50947: 
50947:   // We know the exact byte range in which the target must lie. It must
50947:   // be buffered in the media cache. Seek there.
50947:   nsresult res = SeekBisection(aTarget, aRange, 0);
50947:   if (NS_FAILED(res) || !HasVideo()) {
50947:     return res;
50947:   }
50947: 
41954:   // We have an active Theora bitstream. Decode the next Theora frame, and
41954:   // extract its keyframe's time.
41954:   PRBool eof;
41954:   do {
41954:     PRBool skip = PR_FALSE;
41954:     eof = !DecodeVideoFrame(skip, 0);
41954:     {
73698:       ReentrantMonitorAutoEnter mon(mDecoder->GetReentrantMonitor());
41954:       if (mDecoder->GetDecodeState() == nsBuiltinDecoderStateMachine::DECODER_STATE_SHUTDOWN) {
41954:         return NS_ERROR_FAILURE;
41954:       }
41954:     }
41954:   } while (!eof &&
41954:            mVideoQueue.GetSize() == 0);
41954: 
41954:   VideoData* video = mVideoQueue.PeekFront();
41954:   if (video && !video->mKeyframe) {
41954:     // First decoded frame isn't a keyframe, seek back to previous keyframe,
41954:     // otherwise we'll get visual artifacts.
41954:     NS_ASSERTION(video->mTimecode != -1, "Must have a granulepos");
41954:     int shift = mTheoraState->mInfo.keyframe_granule_shift;
41954:     PRInt64 keyframeGranulepos = (video->mTimecode >> shift) << shift;
41954:     PRInt64 keyframeTime = mTheoraState->StartTime(keyframeGranulepos);
41954:     SEEK_LOG(PR_LOG_DEBUG, ("Keyframe for %lld is at %lld, seeking back to it",
41954:                             video->mTime, keyframeTime));
63625:     SeekRange k = SelectSeekRange(aRanges,
41954:                                   keyframeTime,
41954:                                   aStartTime,
41954:                                   aEndTime,
41954:                                   PR_FALSE);
68450:     res = SeekBisection(keyframeTime, k, SEEK_FUZZ_USECS);
41954:   }
50947:   return res;
41954: }
41954: 
50947: nsresult nsOggReader::SeekInUnbuffered(PRInt64 aTarget,
50947:                                        PRInt64 aStartTime,
50947:                                        PRInt64 aEndTime,
63625:                                        const nsTArray<SeekRange>& aRanges)
50947: {
73834:   LOG(PR_LOG_DEBUG, ("%p Seeking in unbuffered data to %lld using bisection search", mDecoder, aTarget));
41954:   
41954:   // If we've got an active Theora bitstream, determine the maximum possible
68450:   // time in usecs which a keyframe could be before a given interframe. We
41954:   // subtract this from our seek target, seek to the new target, and then
50947:   // will decode forward to the original seek target. We should encounter a
41954:   // keyframe in that interval. This prevents us from needing to run two
41954:   // bisections; one for the seek target frame, and another to find its
41954:   // keyframe. It's usually faster to just download this extra data, rather
41954:   // tham perform two bisections to find the seek target's keyframe. We
50947:   // don't do this offsetting when seeking in a buffered range,
42263:   // as the extra decoding causes a noticeable speed hit when all the data
50947:   // is buffered (compared to just doing a bisection to exactly find the
50947:   // keyframe).
41954:   PRInt64 keyframeOffsetMs = 0;
41954:   if (HasVideo() && mTheoraState) {
41954:     keyframeOffsetMs = mTheoraState->MaxKeyframeOffset();
41954:   }
41954:   PRInt64 seekTarget = NS_MAX(aStartTime, aTarget - keyframeOffsetMs);
50947:   // Minimize the bisection search space using the known timestamps from the
50947:   // buffered ranges.
63625:   SeekRange k = SelectSeekRange(aRanges, seekTarget, aStartTime, aEndTime, PR_FALSE);
69456:   return SeekBisection(seekTarget, k, SEEK_FUZZ_USECS);
50761: }
50947: 
50947: nsresult nsOggReader::Seek(PRInt64 aTarget,
50947:                            PRInt64 aStartTime,
50947:                            PRInt64 aEndTime,
50947:                            PRInt64 aCurrentTime)
50947: {
73697:   NS_ASSERTION(mDecoder->OnDecodeThread(), "Should be on decode thread.");
73834:   LOG(PR_LOG_DEBUG, ("%p About to seek to %lld", mDecoder, aTarget));
50947:   nsresult res;
50947:   nsMediaStream* stream = mDecoder->GetCurrentStream();
50947:   NS_ENSURE_TRUE(stream != nsnull, NS_ERROR_FAILURE);
50947: 
50947:   if (aTarget == aStartTime) {
50947:     // We've seeked to the media start. Just seek to the offset of the first
50947:     // content page.
69456:     res = stream->Seek(nsISeekableStream::NS_SEEK_SET, 0);
50947:     NS_ENSURE_SUCCESS(res,res);
50947: 
69456:     mPageOffset = 0;
50947:     res = ResetDecode();
50947:     NS_ENSURE_SUCCESS(res,res);
50947: 
50947:     NS_ASSERTION(aStartTime != -1, "mStartTime should be known");
50947:     {
73698:       ReentrantMonitorAutoEnter mon(mDecoder->GetReentrantMonitor());
50947:       mDecoder->UpdatePlaybackPosition(aStartTime);
50761:     }
50947:   } else {
50947:     IndexedSeekResult sres = SeekToKeyframeUsingIndex(aTarget);
50947:     NS_ENSURE_TRUE(sres != SEEK_FATAL_ERROR, NS_ERROR_FAILURE);
50947:     if (sres == SEEK_INDEX_FAIL) {
50947:       // No index or other non-fatal index-related failure. Try to seek
50947:       // using a bisection search. Determine the already downloaded data
50947:       // in the media cache, so we can try to seek in the cached data first.
63625:       nsAutoTArray<SeekRange, 16> ranges;
63625:       res = GetSeekRanges(ranges);
50947:       NS_ENSURE_SUCCESS(res,res);
50947: 
50947:       // Figure out if the seek target lies in a buffered range.
63625:       SeekRange r = SelectSeekRange(ranges, aTarget, aStartTime, aEndTime, PR_TRUE);
50947: 
50947:       if (!r.IsNull()) {
50947:         // We know the buffered range in which the seek target lies, do a
50947:         // bisection search in that buffered range.
50947:         res = SeekInBufferedRange(aTarget, aStartTime, aEndTime, ranges, r);
50947:         NS_ENSURE_SUCCESS(res,res);
50947:       } else {
50947:         // The target doesn't lie in a buffered range. Perform a bisection
50947:         // search over the whole media, using the known buffered ranges to
50947:         // reduce the search space.
50947:         res = SeekInUnbuffered(aTarget, aStartTime, aEndTime, ranges);
50947:         NS_ENSURE_SUCCESS(res,res);
50947:       }
50947:     }
50947:   }
50947: 
50947:   // The decode position must now be either close to the seek target, or
50947:   // we've seeked to before the keyframe before the seek target. Decode
50947:   // forward to the seek target frame.
50761:   return DecodeToTarget(aTarget);
41954: }
50751: 
41954: // Reads a page from the media stream.
41954: static PageSyncResult
48904: PageSync(nsMediaStream* aStream,
48904:          ogg_sync_state* aState,
48904:          PRBool aCachedDataOnly,
48904:          PRInt64 aOffset,
41954:          PRInt64 aEndOffset,
41954:          ogg_page* aPage,
41954:          int& aSkippedBytes)
41954: {
41954:   aSkippedBytes = 0;
41954:   // Sync to the next page.
41954:   int ret = 0;
41954:   PRUint32 bytesRead = 0;
48904:   PRInt64 readHead = aOffset;
41954:   while (ret <= 0) {
41954:     ret = ogg_sync_pageseek(aState, aPage);
41954:     if (ret == 0) {
41954:       char* buffer = ogg_sync_buffer(aState, PAGE_STEP);
41954:       NS_ASSERTION(buffer, "Must have a buffer");
41954: 
41954:       // Read from the file into the buffer
74277:       PRInt64 bytesToRead = NS_MIN(static_cast<PRInt64>(PAGE_STEP),
74277:                                    aEndOffset - readHead);
74277:       NS_ASSERTION(bytesToRead <= PR_UINT32_MAX, "bytesToRead range check");
41954:       if (bytesToRead <= 0) {
41954:         return PAGE_SYNC_END_OF_RANGE;
41954:       }
48904:       nsresult rv = NS_OK;
48904:       if (aCachedDataOnly) {
74277:         rv = aStream->ReadFromCache(buffer, readHead,
74277:                                     static_cast<PRUint32>(bytesToRead));
48904:         NS_ENSURE_SUCCESS(rv,PAGE_SYNC_ERROR);
74277:         bytesRead = static_cast<PRUint32>(bytesToRead);
48904:       } else {
48904:         rv = aStream->Seek(nsISeekableStream::NS_SEEK_SET, readHead);
48904:         NS_ENSURE_SUCCESS(rv,PAGE_SYNC_ERROR);
48904:         rv = aStream->Read(buffer,
41954:                            static_cast<PRUint32>(bytesToRead),
41954:                            &bytesRead);
48904:         NS_ENSURE_SUCCESS(rv,PAGE_SYNC_ERROR);
41954:       }
41954:       if (bytesRead == 0 && NS_SUCCEEDED(rv)) {
41954:         // End of file.
41954:         return PAGE_SYNC_END_OF_RANGE;
41954:       }
48904:       readHead += bytesRead;
41954: 
41954:       // Update the synchronisation layer with the number
41954:       // of bytes written to the buffer
41954:       ret = ogg_sync_wrote(aState, bytesRead);
41954:       NS_ENSURE_TRUE(ret == 0, PAGE_SYNC_ERROR);    
41954:       continue;
41954:     }
41954: 
41954:     if (ret < 0) {
41954:       NS_ASSERTION(aSkippedBytes >= 0, "Offset >= 0");
41954:       aSkippedBytes += -ret;
41954:       NS_ASSERTION(aSkippedBytes >= 0, "Offset >= 0");
41954:       continue;
41954:     }
41954:   }
41954:   
41954:   return PAGE_SYNC_OK;
41954: }
41954: 
41954: nsresult nsOggReader::SeekBisection(PRInt64 aTarget,
63625:                                     const SeekRange& aRange,
41954:                                     PRUint32 aFuzz)
41954: {
73697:   NS_ASSERTION(mDecoder->OnDecodeThread(), "Should be on decode thread.");
48904:   nsresult res;
41954:   nsMediaStream* stream = mDecoder->GetCurrentStream();
41954: 
41954:   if (aTarget == aRange.mTimeStart) {
41954:     if (NS_FAILED(ResetDecode())) {
41954:       return NS_ERROR_FAILURE;
41954:     }
69456:     res = stream->Seek(nsISeekableStream::NS_SEEK_SET, 0);
48904:     NS_ENSURE_SUCCESS(res,res);
69456:     mPageOffset = 0;
41954:     return NS_OK;
41954:   }
41954: 
41954:   // Bisection search, find start offset of last page with end time less than
41954:   // the seek target.
41954:   ogg_int64_t startOffset = aRange.mOffsetStart;
41954:   ogg_int64_t startTime = aRange.mTimeStart;
62622:   ogg_int64_t startLength = 0; // Length of the page at startOffset.
41954:   ogg_int64_t endOffset = aRange.mOffsetEnd;
41954:   ogg_int64_t endTime = aRange.mTimeEnd;
41954: 
41954:   ogg_int64_t seekTarget = aTarget;
41954:   PRInt64 seekLowerBound = NS_MAX(static_cast<PRInt64>(0), aTarget - aFuzz);
41954:   int hops = 0;
41954:   ogg_int64_t previousGuess = -1;
62622:   int backsteps = 0;
41954:   const int maxBackStep = 10;
41954:   NS_ASSERTION(static_cast<PRUint64>(PAGE_STEP) * pow(2.0, maxBackStep) < PR_INT32_MAX,
41954:                "Backstep calculation must not overflow");
62622: 
62622:   // Seek via bisection search. Loop until we find the offset where the page
62622:   // before the offset is before the seek target, and the page after the offset
62622:   // is after the seek target.
41954:   while (PR_TRUE) {
41954:     ogg_int64_t duration = 0;
41954:     double target = 0;
41954:     ogg_int64_t interval = 0;
41954:     ogg_int64_t guess = 0;
41954:     ogg_page page;
41954:     int skippedBytes = 0;
41954:     ogg_int64_t pageOffset = 0;
41954:     ogg_int64_t pageLength = 0;
41954:     ogg_int64_t granuleTime = -1;
62622:     PRBool mustBackoff = PR_FALSE;
41954: 
41954:     // Guess where we should bisect to, based on the bit rate and the time
62622:     // remaining in the interval. Loop until we can determine the time at
62622:     // the guess offset.
41954:     while (PR_TRUE) {
41954:   
41954:       // Discard any previously buffered packets/pages.
41954:       if (NS_FAILED(ResetDecode())) {
41954:         return NS_ERROR_FAILURE;
41954:       }
41954: 
62622:       interval = endOffset - startOffset - startLength;
62622:       if (interval == 0) {
62622:         // Our interval is empty, we've found the optimal seek point, as the
62622:         // page at the start offset is before the seek target, and the page
62622:         // at the end offset is after the seek target.
62622:         SEEK_LOG(PR_LOG_DEBUG, ("Interval narrowed, terminating bisection."));
62622:         break;
62622:       }
62622: 
41954:       // Guess bisection point.
41954:       duration = endTime - startTime;
41954:       target = (double)(seekTarget - startTime) / (double)duration;
41954:       guess = startOffset + startLength +
62622:               static_cast<ogg_int64_t>((double)interval * target);
41954:       guess = NS_MIN(guess, endOffset - PAGE_STEP);
62622:       if (mustBackoff) {
62622:         // We previously failed to determine the time at the guess offset,
62622:         // probably because we ran out of data to decode. This usually happens
62622:         // when we guess very close to the end offset. So reduce the guess
62622:         // offset using an exponential backoff until we determine the time.
62622:         SEEK_LOG(PR_LOG_DEBUG, ("Backing off %d bytes, backsteps=%d",
62622:           static_cast<PRInt32>(PAGE_STEP * pow(2.0, backsteps)), backsteps));
63624:         guess -= PAGE_STEP * static_cast<ogg_int64_t>(pow(2.0, backsteps));
73498: 
73498:         if (guess <= startOffset) {
73498:           // We've tried to backoff to before the start offset of our seek
73498:           // range. This means we couldn't find a seek termination position
73498:           // near the end of the seek range, so just set the seek termination
73498:           // condition, and break out of the bisection loop. We'll begin
73498:           // decoding from the start of the seek range.
73498:           interval = 0;
73498:           break;
73498:         }
73498: 
62622:         backsteps = NS_MIN(backsteps + 1, maxBackStep);
62622:         // We reset mustBackoff. If we still need to backoff further, it will
62622:         // be set to PR_TRUE again.
62622:         mustBackoff = PR_FALSE;
62622:       } else {
62622:         backsteps = 0;
62622:       }
41954:       guess = NS_MAX(guess, startOffset + startLength);
41954: 
62622:       SEEK_LOG(PR_LOG_DEBUG, ("Seek loop start[o=%lld..%lld t=%lld] "
62622:                               "end[o=%lld t=%lld] "
62622:                               "interval=%lld target=%lf guess=%lld",
62622:                               startOffset, (startOffset+startLength), startTime,
62622:                               endOffset, endTime, interval, target, guess));
41954: 
41954:       NS_ASSERTION(guess >= startOffset + startLength, "Guess must be after range start");
41954:       NS_ASSERTION(guess < endOffset, "Guess must be before range end");
74277:       NS_ASSERTION(guess != previousGuess, "Guess should be different to previous");
41954:       previousGuess = guess;
41954: 
41954:       hops++;
41954:     
48904:       // Locate the next page after our seek guess, and then figure out the
48904:       // granule time of the audio and video bitstreams there. We can then
48904:       // make a bisection decision based on our location in the media.
48904:       PageSyncResult res = PageSync(stream,
48904:                                     &mOggState,
48904:                                     PR_FALSE,
48904:                                     guess,
41954:                                     endOffset,
41954:                                     &page,
41954:                                     skippedBytes);
50947:       NS_ENSURE_TRUE(res != PAGE_SYNC_ERROR, NS_ERROR_FAILURE);
41954: 
41954:       // We've located a page of length |ret| at |guess + skippedBytes|.
41954:       // Remember where the page is located.
41954:       pageOffset = guess + skippedBytes;
41954:       pageLength = page.header_len + page.body_len;
41954:       mPageOffset = pageOffset + pageLength;
41954: 
62622:       if (res == PAGE_SYNC_END_OF_RANGE) {
41954:         // Our guess was too close to the end, we've ended up reading the end
41954:         // page. Backoff exponentially from the end point, in case the last
41954:         // page/frame/sample is huge.
62622:         mustBackoff = PR_TRUE;
62622:         SEEK_LOG(PR_LOG_DEBUG, ("Hit the end of range, backing off"));
41954:         continue;
41954:       }
41954: 
41954:       // Read pages until we can determine the granule time of the audio and 
41954:       // video bitstream.
41954:       ogg_int64_t audioTime = -1;
41954:       ogg_int64_t videoTime = -1;
62622:       do {
41954:         // Add the page to its codec state, determine its granule time.
41954:         PRUint32 serial = ogg_page_serialno(&page);
41954:         nsOggCodecState* codecState = nsnull;
41954:         mCodecStates.Get(serial, &codecState);
41954:         if (codecState && codecState->mActive) {
62622:           int ret = ogg_stream_pagein(&codecState->mState, &page);
41954:           NS_ENSURE_TRUE(ret == 0, NS_ERROR_FAILURE);
41954:         }
41954: 
41954:         ogg_int64_t granulepos = ogg_page_granulepos(&page);
41954: 
41954:         if (HasAudio() &&
73497:             granulepos > 0 &&
41954:             serial == mVorbisState->mSerial &&
41954:             audioTime == -1) {
41954:           audioTime = mVorbisState->Time(granulepos);
41954:         }
41954:         
41954:         if (HasVideo() &&
73497:             granulepos > 0 &&
41954:             serial == mTheoraState->mSerial &&
41954:             videoTime == -1) {
41954:           videoTime = mTheoraState->StartTime(granulepos);
41954:         }
41954: 
62622:         if (mPageOffset == endOffset) {
62622:           // Hit end of readable data.
62622:           break;
62622:         }
62622: 
41954:         if (ReadOggPage(&page) == -1) {
41954:           break;
41954:         }
62622:         
62622:       } while ((mVorbisState && audioTime == -1) ||
62622:                (mTheoraState && videoTime == -1));
62622: 
62622:       NS_ASSERTION(mPageOffset <= endOffset, "Page read cursor should be inside range");
41954: 
41954:       if ((HasAudio() && audioTime == -1) ||
41954:           (HasVideo() && videoTime == -1)) 
41954:       {
62622:         // We don't have timestamps for all active tracks...
62622:         if (pageOffset == startOffset + startLength && mPageOffset == endOffset) {
62622:           // We read the entire interval without finding timestamps for all
62622:           // active tracks. We know the interval start offset is before the seek
62622:           // target, and the interval end is after the seek target, and we can't
62622:           // terminate inside the interval, so we terminate the seek at the
62622:           // start of the interval.
62622:           interval = 0;
62622:           break;
62622:         }
62622: 
62622:         // We should backoff; cause the guess to back off from the end, so
62622:         // that we've got more room to capture.
62622:         mustBackoff = PR_TRUE;
41954:         continue;
41954:       }
41954: 
41954:       // We've found appropriate time stamps here. Proceed to bisect
41954:       // the search space.
41954:       granuleTime = NS_MAX(audioTime, videoTime);
41954:       NS_ASSERTION(granuleTime > 0, "Must get a granuletime");
41954:       break;
62622:     } // End of "until we determine time at guess offset" loop.
41954: 
41954:     if (interval == 0) {
41954:       // Seek termination condition; we've found the page boundary of the
41954:       // last page before the target, and the first page after the target.
62622:       SEEK_LOG(PR_LOG_DEBUG, ("Terminating seek at offset=%lld", startOffset));
41954:       NS_ASSERTION(startTime < aTarget, "Start time must always be less than target");
48904:       res = stream->Seek(nsISeekableStream::NS_SEEK_SET, startOffset);
48904:       NS_ENSURE_SUCCESS(res,res);
41954:       mPageOffset = startOffset;
41954:       if (NS_FAILED(ResetDecode())) {
41954:         return NS_ERROR_FAILURE;
41954:       }
41954:       break;
41954:     }
41954: 
73834:     SEEK_LOG(PR_LOG_DEBUG, ("Time at offset %lld is %lld", guess, granuleTime));
41954:     if (granuleTime < seekTarget && granuleTime > seekLowerBound) {
41954:       // We're within the fuzzy region in which we want to terminate the search.
62622:       res = stream->Seek(nsISeekableStream::NS_SEEK_SET, pageOffset);
48904:       NS_ENSURE_SUCCESS(res,res);
62622:       mPageOffset = pageOffset;
41954:       if (NS_FAILED(ResetDecode())) {
41954:         return NS_ERROR_FAILURE;
41954:       }
62622:       SEEK_LOG(PR_LOG_DEBUG, ("Terminating seek at offset=%lld", mPageOffset));
41954:       break;
41954:     }
41954: 
41954:     if (granuleTime >= seekTarget) {
41954:       // We've landed after the seek target.
47700:       NS_ASSERTION(pageOffset < endOffset, "offset_end must decrease");
41954:       endOffset = pageOffset;
41954:       endTime = granuleTime;
41954:     } else if (granuleTime < seekTarget) {
41954:       // Landed before seek target.
73834:       NS_ASSERTION(pageOffset >= startOffset + startLength,
73834:         "Bisection point should be at or after end of first page in interval");
41954:       startOffset = pageOffset;
41954:       startLength = pageLength;
41954:       startTime = granuleTime;
41954:     }
41954:     NS_ASSERTION(startTime < seekTarget, "Must be before seek target");
41954:     NS_ASSERTION(endTime >= seekTarget, "End must be after seek target");
41954:   }
41954: 
41954:   SEEK_LOG(PR_LOG_DEBUG, ("Seek complete in %d bisections.", hops));
41954: 
41954:   return NS_OK;
41954: }
41954: 
51394: nsresult nsOggReader::GetBuffered(nsTimeRanges* aBuffered, PRInt64 aStartTime)
48902: {
53767:   // HasAudio and HasVideo are not used here as they take a lock and cause
53767:   // a deadlock. Accessing mInfo doesn't require a lock - it doesn't change
53767:   // after metadata is read and GetBuffered isn't called before metadata is
53767:   // read.
53767:   if (!mInfo.mHasVideo && !mInfo.mHasAudio) {
53767:     // No need to search through the file if there are no audio or video tracks
53767:     return NS_OK;
53767:   }
53767: 
48904:   nsMediaStream* stream = mDecoder->GetCurrentStream();
63628:   nsTArray<nsByteRange> ranges;
63628:   nsresult res = stream->GetCachedRanges(ranges);
63628:   NS_ENSURE_SUCCESS(res, res);
48904: 
48904:   // Traverse across the buffered byte ranges, determining the time ranges
48904:   // they contain. nsMediaStream::GetNextCachedData(offset) returns -1 when
48904:   // offset is after the end of the media stream, or there's no more cached
48904:   // data after the offset. This loop will run until we've checked every
48904:   // buffered range in the media, in increasing order of offset.
69475:   nsAutoOggSyncState sync;
63628:   for (PRUint32 index = 0; index < ranges.Length(); index++) {
63628:     // Ensure the offsets are after the header pages.
69456:     PRInt64 startOffset = ranges[index].mStart;
69456:     PRInt64 endOffset = ranges[index].mEnd;
48904: 
48904:     // Because the granulepos time is actually the end time of the page,
69456:     // we special-case (startOffset == 0) so that the first
63628:     // buffered range always appears to be buffered from the media start
63628:     // time, rather than from the end-time of the first page.
69456:     PRInt64 startTime = (startOffset == 0) ? aStartTime : -1;
63628: 
63628:     // Find the start time of the range. Read pages until we find one with a
63628:     // granulepos which we can convert into a timestamp to use as the time of
63628:     // the start of the buffered range.
69475:     ogg_sync_reset(&sync.mState);
48904:     while (startTime == -1) {
48904:       ogg_page page;
48904:       PRInt32 discard;
48904:       PageSyncResult res = PageSync(stream,
69475:                                     &sync.mState,
48904:                                     PR_TRUE,
48904:                                     startOffset,
48904:                                     endOffset,
48904:                                     &page,
48904:                                     discard);
48904:       if (res == PAGE_SYNC_ERROR) {
48904:         return NS_ERROR_FAILURE;
48904:       } else if (res == PAGE_SYNC_END_OF_RANGE) {
48904:         // Hit the end of range without reading a page, give up trying to
48904:         // find a start time for this buffered range, skip onto the next one.
48904:         break;
48904:       }
48904: 
48904:       PRInt64 granulepos = ogg_page_granulepos(&page);
48904:       if (granulepos == -1) {
48904:         // Page doesn't have an end time, advance to the next page
48904:         // until we find one.
48904:         startOffset += page.header_len + page.body_len;
48904:         continue;
48904:       }
48904: 
48904:       PRUint32 serial = ogg_page_serialno(&page);
62621:       if (mVorbisState && serial == mVorbisSerial) {
72860:         startTime = nsVorbisState::Time(&mVorbisInfo, granulepos);
48904:         NS_ASSERTION(startTime > 0, "Must have positive start time");
48904:       }
62621:       else if (mTheoraState && serial == mTheoraSerial) {
72860:         startTime = nsTheoraState::Time(&mTheoraInfo, granulepos);
59429:         NS_ASSERTION(startTime > 0, "Must have positive start time");
59429:       }
59429:       else if (IsKnownStream(serial)) {
59429:         // Stream is not the theora or vorbis stream we're playing,
59429:         // but is one that we have header data for.
53767:         startOffset += page.header_len + page.body_len;
53767:         continue;
53767:       }
53767:       else {
53767:         // Page is for a stream we don't know about (possibly a chained
53767:         // ogg), return an error.
53767:         return PAGE_SYNC_ERROR;
53767:       }
48904:     }
48904: 
48904:     if (startTime != -1) {
48904:       // We were able to find a start time for that range, see if we can
48904:       // find an end time.
69475:       PRInt64 endTime = RangeEndTime(startOffset, endOffset, PR_TRUE);
48904:       if (endTime != -1) {
72860:         aBuffered->Add((startTime - aStartTime) / static_cast<double>(USECS_PER_S),
68450:                        (endTime - aStartTime) / static_cast<double>(USECS_PER_S));
48904:       }
48904:     }
48904:   }
48904: 
48902:   return NS_OK;
48902: }
59429: 
59429: PRBool nsOggReader::IsKnownStream(PRUint32 aSerial)
59429: {
59429:   for (PRUint32 i = 0; i < mKnownStreams.Length(); i++) {
59429:     PRUint32 serial = mKnownStreams[i];
59429:     if (serial == aSerial) {
59429:       return PR_TRUE;
59429:     }
59429:   }
59429: 
59429:   return PR_FALSE;
59429: }
