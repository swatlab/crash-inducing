29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
25100:  * vim: set ts=8 sw=4 et tw=79:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS object implementation.
    1:  */
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
55477: #include "jsarena.h"
    1: #include "jsbit.h"
55477: #include "jsutil.h"
55477: #include "jshash.h"
    1: #include "jsdhash.h"
    1: #include "jsprf.h"
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
    1: #include "jsbool.h"
20408: #include "jsbuiltins.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
 8444: #include "jsemit.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
43281: #include "jsiter.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
 8444: #include "jsparse.h"
42733: #include "jsproxy.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
24499: #include "jsstaticcheck.h"
33160: #include "jsstdint.h"
    1: #include "jsstr.h"
24499: #include "jstracer.h"
25215: #include "jsdbgapi.h"
51457: #include "json.h"
58714: #include "jswrapper.h"
    1: 
53840: #include "jsinterpinlines.h"
34349: #include "jsscopeinlines.h"
34349: #include "jsscriptinlines.h"
40858: #include "jsobjinlines.h"
34349: 
    1: #if JS_HAS_GENERATORS
    1: #include "jsiter.h"
    1: #endif
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: #include "jsxml.h"
    1: #endif
    1: 
    1: #if JS_HAS_XDR
    1: #include "jsxdrapi.h"
    1: #endif
    1: 
53555: #include "jsprobes.h"
30283: #include "jsatominlines.h"
35117: #include "jsobjinlines.h"
32737: #include "jsscriptinlines.h"
30283: 
15453: #include "jsautooplen.h"
15453: 
37741: using namespace js;
54707: using namespace js::gc;
37741: 
59729: JS_FRIEND_DATA(const JSObjectMap) JSObjectMap::sharedNonNative(JSObjectMap::SHAPELESS);
    1: 
48470: Class js_ObjectClass = {
    1:     js_Object_str,
53557:     JSCLASS_HAS_CACHED_PROTO(JSProto_Object),
48622:     PropertyStub,         /* addProperty */
48622:     PropertyStub,         /* delProperty */
48622:     PropertyStub,         /* getProperty */
62395:     StrictPropertyStub,   /* setProperty */
48622:     EnumerateStub,
48622:     ResolveStub,
48622:     ConvertStub
    1: };
    1: 
48622: JS_FRIEND_API(JSObject *)
48622: js_ObjectToOuterObject(JSContext *cx, JSObject *obj)
48622: {
48622:     OBJ_TO_OUTER_OBJECT(cx, obj);
48622:     return obj;
48622: }
48622: 
    1: #if JS_HAS_OBJ_PROTO_PROP
    1: 
    1: static JSBool
48470: obj_getProto(JSContext *cx, JSObject *obj, jsid id, Value *vp);
    1: 
    1: static JSBool
62395: obj_setProto(JSContext *cx, JSObject *obj, jsid id, JSBool strict, Value *vp);
    1: 
    1: static JSPropertySpec object_props[] = {
48470:     {js_proto_str, 0, JSPROP_PERMANENT|JSPROP_SHARED, Jsvalify(obj_getProto), Jsvalify(obj_setProto)},
    1:     {0,0,0,0,0}
    1: };
    1: 
    1: static JSBool
48470: obj_getProto(JSContext *cx, JSObject *obj, jsid id, Value *vp)
41968: {
47455:     /* Let CheckAccess get the slot's value, based on the access mode. */
    1:     uintN attrs;
41968:     id = ATOM_TO_JSID(cx->runtime->atomState.protoAtom);
50518:     return CheckAccess(cx, obj, id, JSACC_PROTO, vp, &attrs);
    1: }
    1: 
    1: static JSBool
62395: obj_setProto(JSContext *cx, JSObject *obj, jsid id, JSBool strict, Value *vp)
48470: {
54563:     /* ECMAScript 5 8.6.2 forbids changing [[Prototype]] if not [[Extensible]]. */
54563:     if (!obj->isExtensible()) {
54587:         obj->reportNotExtensible(cx);
54563:         return false;
54563:     }
54563: 
48470:     if (!vp->isObjectOrNull())
    1:         return JS_TRUE;
41968: 
48470:     JSObject *pobj = vp->toObjectOrNull();
    1:     if (pobj) {
    1:         /*
    1:          * Innerize pobj here to avoid sticking unwanted properties on the
    1:          * outer object. This ensures that any with statements only grant
    1:          * access to the inner object.
    1:          */
    1:         OBJ_TO_INNER_OBJECT(cx, pobj);
    1:         if (!pobj)
    1:             return JS_FALSE;
    1:     }
41968: 
41968:     uintN attrs;
41968:     id = ATOM_TO_JSID(cx->runtime->atomState.protoAtom);
50518:     if (!CheckAccess(cx, obj, id, JSAccessMode(JSACC_PROTO|JSACC_WRITE), vp, &attrs))
41968:         return JS_FALSE;
41968: 
47465:     return SetProto(cx, obj, pobj, JS_TRUE);
    1: }
    1: 
    1: #else  /* !JS_HAS_OBJ_PROTO_PROP */
    1: 
    1: #define object_props NULL
    1: 
    1: #endif /* !JS_HAS_OBJ_PROTO_PROP */
    1: 
18907: static JSHashNumber
    1: js_hash_object(const void *key)
    1: {
48470:     return JSHashNumber(uintptr_t(key) >> JS_GCTHING_ALIGN);
    1: }
    1: 
    1: static JSHashEntry *
    1: MarkSharpObjects(JSContext *cx, JSObject *obj, JSIdArray **idap)
    1: {
    1:     JSSharpObjectMap *map;
    1:     JSHashTable *table;
    1:     JSHashNumber hash;
    1:     JSHashEntry **hep, *he;
    1:     jsatomid sharpid;
    1:     JSIdArray *ida;
    1:     JSBool ok;
    1:     jsint i, length;
    1:     jsid id;
    1:     JSObject *obj2;
    1:     JSProperty *prop;
11139: 
11139:     JS_CHECK_RECURSION(cx, return NULL);
    1: 
    1:     map = &cx->sharpObjectMap;
23915:     JS_ASSERT(map->depth >= 1);
    1:     table = map->table;
    1:     hash = js_hash_object(obj);
    1:     hep = JS_HashTableRawLookup(table, hash, obj);
    1:     he = *hep;
    1:     if (!he) {
    1:         sharpid = 0;
40292:         he = JS_HashTableRawAdd(table, hep, hash, obj, (void *) sharpid);
    1:         if (!he) {
    1:             JS_ReportOutOfMemory(cx);
    1:             return NULL;
    1:         }
    1: 
    1:         ida = JS_Enumerate(cx, obj);
    1:         if (!ida)
    1:             return NULL;
    1: 
    1:         ok = JS_TRUE;
    1:         for (i = 0, length = ida->length; i < length; i++) {
    1:             id = ida->vector[i];
31501:             ok = obj->lookupProperty(cx, id, &obj2, &prop);
    1:             if (!ok)
    1:                 break;
    1:             if (!prop)
    1:                 continue;
42834:             bool hasGetter, hasSetter;
48470:             AutoValueRooter v(cx);
48470:             AutoValueRooter setter(cx);
43202:             if (obj2->isNative()) {
52503:                 const Shape *shape = (Shape *) prop;
52503:                 hasGetter = shape->hasGetterValue();
52503:                 hasSetter = shape->hasSetterValue();
42834:                 if (hasGetter)
52503:                     v.set(shape->getterValue());
42834:                 if (hasSetter)
52503:                     setter.set(shape->setterValue());
42834:             } else {
42834:                 hasGetter = hasSetter = false;
42834:             }
42834:             if (hasSetter) {
    1:                 /* Mark the getter, then set val to setter. */
48470:                 if (hasGetter && v.value().isObject()) {
48470:                     ok = !!MarkSharpObjects(cx, &v.value().toObject(), NULL);
    1:                     if (!ok)
    1:                         break;
42834:                 }
42834:                 v.set(setter.value());
42834:             } else if (!hasGetter) {
42834:                 ok = obj->getProperty(cx, id, v.addr());
42834:                 if (!ok)
42834:                     break;
42834:             }
48470:             if (v.value().isObject() &&
48470:                 !MarkSharpObjects(cx, &v.value().toObject(), NULL)) {
    1:                 ok = JS_FALSE;
    1:                 break;
    1:             }
    1:         }
    1:         if (!ok || !idap)
    1:             JS_DestroyIdArray(cx, ida);
    1:         if (!ok)
    1:             return NULL;
    1:     } else {
40292:         sharpid = uintptr_t(he->value);
    1:         if (sharpid == 0) {
    1:             sharpid = ++map->sharpgen << SHARP_ID_SHIFT;
40292:             he->value = (void *) sharpid;
    1:         }
    1:         ida = NULL;
    1:     }
    1:     if (idap)
    1:         *idap = ida;
    1:     return he;
    1: }
    1: 
    1: JSHashEntry *
    1: js_EnterSharpObject(JSContext *cx, JSObject *obj, JSIdArray **idap,
    1:                     jschar **sp)
    1: {
    1:     JSSharpObjectMap *map;
    1:     JSHashTable *table;
    1:     JSIdArray *ida;
    1:     JSHashNumber hash;
    1:     JSHashEntry *he, **hep;
    1:     jsatomid sharpid;
    1:     char buf[20];
    1:     size_t len;
    1: 
25087:     if (!JS_CHECK_OPERATION_LIMIT(cx))
    1:         return NULL;
    1: 
    1:     /* Set to null in case we return an early error. */
    1:     *sp = NULL;
    1:     map = &cx->sharpObjectMap;
    1:     table = map->table;
    1:     if (!table) {
    1:         table = JS_NewHashTable(8, js_hash_object, JS_CompareValues,
    1:                                 JS_CompareValues, NULL, NULL);
    1:         if (!table) {
    1:             JS_ReportOutOfMemory(cx);
    1:             return NULL;
    1:         }
    1:         map->table = table;
    1:         JS_KEEP_ATOMS(cx->runtime);
    1:     }
    1: 
    1:     /* From this point the control must flow either through out: or bad:. */
    1:     ida = NULL;
    1:     if (map->depth == 0) {
23915:         /*
23915:          * Although MarkSharpObjects tries to avoid invoking getters,
23915:          * it ends up doing so anyway under some circumstances; for
23915:          * example, if a wrapped object has getters, the wrapper will
23915:          * prevent MarkSharpObjects from recognizing them as such.
23915:          * This could lead to js_LeaveSharpObject being called while
23915:          * MarkSharpObjects is still working.
23915:          *
23915:          * Increment map->depth while we call MarkSharpObjects, to
23915:          * ensure that such a call doesn't free the hash table we're
23915:          * still using.
23915:          */
23915:         ++map->depth;
    1:         he = MarkSharpObjects(cx, obj, &ida);
23915:         --map->depth;
    1:         if (!he)
    1:             goto bad;
40292:         JS_ASSERT((uintptr_t(he->value) & SHARP_BIT) == 0);
    1:         if (!idap) {
    1:             JS_DestroyIdArray(cx, ida);
    1:             ida = NULL;
    1:         }
    1:     } else {
    1:         hash = js_hash_object(obj);
    1:         hep = JS_HashTableRawLookup(table, hash, obj);
    1:         he = *hep;
    1: 
    1:         /*
    1:          * It's possible that the value of a property has changed from the
    1:          * first time the object's properties are traversed (when the property
    1:          * ids are entered into the hash table) to the second (when they are
31501:          * converted to strings), i.e., the JSObject::getProperty() call is not
    1:          * idempotent.
    1:          */
    1:         if (!he) {
    1:             he = JS_HashTableRawAdd(table, hep, hash, obj, NULL);
    1:             if (!he) {
    1:                 JS_ReportOutOfMemory(cx);
    1:                 goto bad;
    1:             }
    1:             sharpid = 0;
    1:             goto out;
    1:         }
    1:     }
    1: 
40292:     sharpid = uintptr_t(he->value);
    1:     if (sharpid != 0) {
    1:         len = JS_snprintf(buf, sizeof buf, "#%u%c",
    1:                           sharpid >> SHARP_ID_SHIFT,
    1:                           (sharpid & SHARP_BIT) ? '#' : '=');
    1:         *sp = js_InflateString(cx, buf, &len);
    1:         if (!*sp) {
    1:             if (ida)
    1:                 JS_DestroyIdArray(cx, ida);
    1:             goto bad;
    1:         }
    1:     }
    1: 
    1: out:
    1:     JS_ASSERT(he);
    1:     if ((sharpid & SHARP_BIT) == 0) {
    1:         if (idap && !ida) {
    1:             ida = JS_Enumerate(cx, obj);
    1:             if (!ida) {
    1:                 if (*sp) {
30851:                     cx->free(*sp);
    1:                     *sp = NULL;
    1:                 }
    1:                 goto bad;
    1:             }
    1:         }
    1:         map->depth++;
    1:     }
    1: 
    1:     if (idap)
    1:         *idap = ida;
    1:     return he;
    1: 
    1: bad:
    1:     /* Clean up the sharpObjectMap table on outermost error. */
    1:     if (map->depth == 0) {
    1:         JS_UNKEEP_ATOMS(cx->runtime);
    1:         map->sharpgen = 0;
    1:         JS_HashTableDestroy(map->table);
    1:         map->table = NULL;
    1:     }
    1:     return NULL;
    1: }
    1: 
    1: void
    1: js_LeaveSharpObject(JSContext *cx, JSIdArray **idap)
    1: {
    1:     JSSharpObjectMap *map;
    1:     JSIdArray *ida;
    1: 
    1:     map = &cx->sharpObjectMap;
    1:     JS_ASSERT(map->depth > 0);
    1:     if (--map->depth == 0) {
    1:         JS_UNKEEP_ATOMS(cx->runtime);
    1:         map->sharpgen = 0;
    1:         JS_HashTableDestroy(map->table);
    1:         map->table = NULL;
    1:     }
    1:     if (idap) {
    1:         ida = *idap;
    1:         if (ida) {
    1:             JS_DestroyIdArray(cx, ida);
    1:             *idap = NULL;
    1:         }
    1:     }
    1: }
    1: 
18907: static intN
    1: gc_sharp_table_entry_marker(JSHashEntry *he, intN i, void *arg)
    1: {
54707:     MarkObject((JSTracer *)arg, *(JSObject *)he->key, "sharp table entry");
    1:     return JS_DHASH_NEXT;
    1: }
    1: 
    1: void
  583: js_TraceSharpMap(JSTracer *trc, JSSharpObjectMap *map)
    1: {
    1:     JS_ASSERT(map->depth > 0);
    1:     JS_ASSERT(map->table);
    1: 
    1:     /*
    1:      * During recursive calls to MarkSharpObjects a non-native object or
    1:      * object with a custom getProperty method can potentially return an
    1:      * unrooted value or even cut from the object graph an argument of one of
    1:      * MarkSharpObjects recursive invocations. So we must protect map->table
    1:      * entries against GC.
    1:      *
    1:      * We can not simply use JSTempValueRooter to mark the obj argument of
    1:      * MarkSharpObjects during recursion as we have to protect *all* entries
    1:      * in JSSharpObjectMap including those that contains otherwise unreachable
    1:      * objects just allocated through custom getProperty. Otherwise newer
    1:      * allocations can re-use the address of an object stored in the hashtable
    1:      * confusing js_EnterSharpObject. So to address the problem we simply
    1:      * mark all objects from map->table.
    1:      *
    1:      * An alternative "proper" solution is to use JSTempValueRooter in
    1:      * MarkSharpObjects with code to remove during finalization entries
    1:      * with otherwise unreachable objects. But this is way too complex
    1:      * to justify spending efforts.
    1:      */
  583:     JS_HashTableEnumerateEntries(map->table, gc_sharp_table_entry_marker, trc);
    1: }
    1: 
    1: #if JS_HAS_TOSOURCE
 4127: static JSBool
48470: obj_toSource(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSBool ok;
    1:     JSHashEntry *he;
    1:     JSIdArray *ida;
    1:     jschar *chars, *ochars, *vsharp;
    1:     const jschar *idstrchars, *vchars;
    1:     size_t nchars, idstrlength, gsoplength, vlength, vsharplength, curlen;
16069:     const char *comma;
    1:     JSObject *obj2;
    1:     JSProperty *prop;
48470:     Value *val;
    1:     JSString *gsop[2];
59890:     JSString *valstr, *str;
59890:     JSLinearString *idstr;
11139: 
11139:     JS_CHECK_RECURSION(cx, return JS_FALSE);
    1: 
48470:     Value localroot[4];
48470:     PodArrayZero(localroot);
40388:     AutoArrayRooter tvr(cx, JS_ARRAY_LENGTH(localroot), localroot);
    1: 
    1:     /* If outermost, we need parentheses to be an expression, not a block. */
61734:     JSBool outermost = (cx->sharpObjectMap.depth == 0);
61734: 
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
61734:     if (!(he = js_EnterSharpObject(cx, obj, &ida, &chars))) {
 6917:         ok = JS_FALSE;
 6917:         goto out;
 6917:     }
    1:     if (IS_SHARP(he)) {
    1:         /*
    1:          * We didn't enter -- obj is already "sharp", meaning we've visited it
    1:          * already in our depth first search, and therefore chars contains a
    1:          * string of the form "#n#".
    1:          */
    1:         JS_ASSERT(!ida);
    1: #if JS_HAS_SHARP_VARS
    1:         nchars = js_strlen(chars);
    1: #else
    1:         chars[0] = '{';
    1:         chars[1] = '}';
    1:         chars[2] = 0;
    1:         nchars = 2;
    1: #endif
    1:         goto make_string;
    1:     }
    1:     JS_ASSERT(ida);
    1:     ok = JS_TRUE;
    1: 
    1:     if (!chars) {
    1:         /* If outermost, allocate 4 + 1 for "({})" and the terminator. */
53592:         chars = (jschar *) cx->runtime->malloc(((outermost ? 4 : 2) + 1) * sizeof(jschar));
    1:         nchars = 0;
    1:         if (!chars)
    1:             goto error;
    1:         if (outermost)
    1:             chars[nchars++] = '(';
    1:     } else {
    1:         /* js_EnterSharpObject returned a string of the form "#n=" in chars. */
    1:         MAKE_SHARP(he);
    1:         nchars = js_strlen(chars);
    1:         chars = (jschar *)
30851:             js_realloc((ochars = chars), (nchars + 2 + 1) * sizeof(jschar));
    1:         if (!chars) {
30851:             js_free(ochars);
    1:             goto error;
    1:         }
    1:         if (outermost) {
    1:             /*
    1:              * No need for parentheses around the whole shebang, because #n=
    1:              * unambiguously begins an object initializer, and never a block
    1:              * statement.
    1:              */
    1:             outermost = JS_FALSE;
    1:         }
    1:     }
    1: 
    1:     chars[nchars++] = '{';
    1: 
    1:     comma = NULL;
    1: 
    1:     /*
    1:      * We have four local roots for cooked and raw value GC safety.  Hoist the
 6917:      * "localroot + 2" out of the loop using the val local, which refers to
 6917:      * the raw (unconverted, "uncooked") values.
    1:      */
 6917:     val = localroot + 2;
    1: 
40855:     for (jsint i = 0, length = ida->length; i < length; i++) {
 4127:         /* Get strings for id and value and GC-root them via vp. */
40855:         jsid id = ida->vector[i];
40855: 
31501:         ok = obj->lookupProperty(cx, id, &obj2, &prop);
    1:         if (!ok)
    1:             goto error;
  969: 
  969:         /*
48470:          * Convert id to a value and then to a string.  Decide early whether we
  969:          * prefer get/set or old getter/setter syntax.
  969:          */
59890:         JSString *s = js_ValueToString(cx, IdToValue(id));
59890:         if (!s || !(idstr = s->ensureLinear(cx))) {
  969:             ok = JS_FALSE;
  969:             goto error;
  969:         }
48470:         vp->setString(idstr);                           /* local root */
40855: 
40855:         jsint valcnt = 0;
    1:         if (prop) {
43183:             bool doGet = true;
43202:             if (obj2->isNative()) {
52503:                 const Shape *shape = (Shape *) prop;
52503:                 unsigned attrs = shape->attributes();
    1:                 if (attrs & JSPROP_GETTER) {
43183:                     doGet = false;
52503:                     val[valcnt] = shape->getterValue();
40855:                     gsop[valcnt] = ATOM_TO_STRING(cx->runtime->atomState.getAtom);
 1677:                     valcnt++;
    1:                 }
    1:                 if (attrs & JSPROP_SETTER) {
43183:                     doGet = false;
52503:                     val[valcnt] = shape->setterValue();
40855:                     gsop[valcnt] = ATOM_TO_STRING(cx->runtime->atomState.setAtom);
    1:                     valcnt++;
 1677:                 }
43183:             }
43183:             if (doGet) {
    1:                 valcnt = 1;
    1:                 gsop[0] = NULL;
31501:                 ok = obj->getProperty(cx, id, &val[0]);
    1:                 if (!ok)
    1:                     goto error;
43183:             }
43183:         }
    1: 
    1:         /*
40855:          * If id is a string that's not an identifier, or if it's a negative
40855:          * integer, then it must be quoted.
    1:          */
59890:         bool idIsLexicalIdentifier = js_IsIdentifier(idstr);
 4529:         if (JSID_IS_ATOM(id)
  969:             ? !idIsLexicalIdentifier
 4529:             : (!JSID_IS_INT(id) || JSID_TO_INT(id) < 0)) {
59890:             s = js_QuoteString(cx, idstr, jschar('\''));
59890:             if (!s || !(idstr = s->ensureLinear(cx))) {
    1:                 ok = JS_FALSE;
    1:                 goto error;
    1:             }
48470:             vp->setString(idstr);                       /* local root */
    1:         }
59890:         idstrlength = idstr->length();
59890:         idstrchars = idstr->getChars(cx);
59890:         if (!idstrchars) {
59890:             ok = JS_FALSE;
59890:             goto error;
59890:         }
    1: 
40855:         for (jsint j = 0; j < valcnt; j++) {
40855:             /*
40855:              * Censor an accessor descriptor getter or setter part if it's
40855:              * undefined.
40855:              */
48470:             if (gsop[j] && val[j].isUndefined())
40855:                 continue;
40855: 
    1:             /* Convert val[j] to its canonical source form. */
    1:             valstr = js_ValueToSource(cx, val[j]);
    1:             if (!valstr) {
    1:                 ok = JS_FALSE;
    1:                 goto error;
    1:             }
48470:             localroot[j].setString(valstr);             /* local root */
59890:             vchars = valstr->getChars(cx);
59890:             if (!vchars) {
59890:                 ok = JS_FALSE;
59890:                 goto error;
59890:             }
59890:             vlength = valstr->length();
    1: 
40855:             /*
40855:              * If val[j] is a non-sharp object, and we're not serializing an
40855:              * accessor (ECMA syntax can't accommodate sharpened accessors),
40855:              * consider sharpening it.
40855:              */
    1:             vsharp = NULL;
    1:             vsharplength = 0;
    1: #if JS_HAS_SHARP_VARS
48470:             if (!gsop[j] && val[j].isObject() && vchars[0] != '#') {
48470:                 he = js_EnterSharpObject(cx, &val[j].toObject(), NULL, &vsharp);
    1:                 if (!he) {
    1:                     ok = JS_FALSE;
    1:                     goto error;
    1:                 }
    1:                 if (IS_SHARP(he)) {
    1:                     vchars = vsharp;
    1:                     vlength = js_strlen(vchars);
    1:                 } else {
    1:                     if (vsharp) {
    1:                         vsharplength = js_strlen(vsharp);
    1:                         MAKE_SHARP(he);
    1:                     }
    1:                     js_LeaveSharpObject(cx, NULL);
    1:                 }
    1:             }
    1: #endif
    1: 
 2149:             /*
 2149:              * Remove '(function ' from the beginning of valstr and ')' from the
 2149:              * end so that we can put "get" in front of the function definition.
 2149:              */
48470:             if (gsop[j] && IsFunctionObject(val[j])) {
 2149:                 const jschar *start = vchars;
 2149:                 const jschar *end = vchars + vlength;
 2149: 
 2149:                 uint8 parenChomp = 0;
 2149:                 if (vchars[0] == '(') {
 2149:                     vchars++;
 2149:                     parenChomp = 1;
 2149:                 }
 2149: 
 2149:                 /* Try to jump "function" keyword. */
 2149:                 if (vchars)
 2149:                     vchars = js_strchr_limit(vchars, ' ', end);
 2149: 
40855:                 /*
40855:                  * Jump over the function's name: it can't be encoded as part
40855:                  * of an ECMA getter or setter.
40855:                  */
40855:                 if (vchars)
40855:                     vchars = js_strchr_limit(vchars, '(', end);
40855: 
 2149:                 if (vchars) {
 2149:                     if (*vchars == ' ')
 2149:                         vchars++;
 2149:                     vlength = end - vchars - parenChomp;
 2149:                 } else {
 2149:                     gsop[j] = NULL;
 2149:                     vchars = start;
 2149:                 }
 2149:             }
 2149: 
    1: #define SAFE_ADD(n)                                                          \
    1:     JS_BEGIN_MACRO                                                           \
    1:         size_t n_ = (n);                                                     \
    1:         curlen += n_;                                                        \
    1:         if (curlen < n_)                                                     \
    1:             goto overflow;                                                   \
    1:     JS_END_MACRO
    1: 
    1:             curlen = nchars;
    1:             if (comma)
    1:                 SAFE_ADD(2);
    1:             SAFE_ADD(idstrlength + 1);
    1:             if (gsop[j])
29366:                 SAFE_ADD(gsop[j]->length() + 1);
    1:             SAFE_ADD(vsharplength);
    1:             SAFE_ADD(vlength);
    1:             /* Account for the trailing null. */
    1:             SAFE_ADD((outermost ? 2 : 1) + 1);
    1: #undef SAFE_ADD
    1: 
40855:             if (curlen > size_t(-1) / sizeof(jschar))
    1:                 goto overflow;
    1: 
    1:             /* Allocate 1 + 1 at end for closing brace and terminating 0. */
40855:             chars = (jschar *) js_realloc((ochars = chars), curlen * sizeof(jschar));
    1:             if (!chars) {
59890:                 chars = ochars;
59890:                 goto overflow;
    1:             }
    1: 
    1:             if (comma) {
    1:                 chars[nchars++] = comma[0];
    1:                 chars[nchars++] = comma[1];
    1:             }
    1:             comma = ", ";
    1: 
    1:             if (gsop[j]) {
29366:                 gsoplength = gsop[j]->length();
59890:                 const jschar *gsopchars = gsop[j]->getChars(cx);
59890:                 if (!gsopchars)
59890:                     goto overflow;
59890:                 js_strncpy(&chars[nchars], gsopchars, gsoplength);
    1:                 nchars += gsoplength;
    1:                 chars[nchars++] = ' ';
    1:             }
    1:             js_strncpy(&chars[nchars], idstrchars, idstrlength);
    1:             nchars += idstrlength;
  969:             /* Extraneous space after id here will be extracted later */
    1:             chars[nchars++] = gsop[j] ? ' ' : ':';
 1490: 
    1:             if (vsharplength) {
    1:                 js_strncpy(&chars[nchars], vsharp, vsharplength);
    1:                 nchars += vsharplength;
    1:             }
    1:             js_strncpy(&chars[nchars], vchars, vlength);
    1:             nchars += vlength;
    1: 
    1:             if (vsharp)
30851:                 cx->free(vsharp);
    1:         }
    1:     }
    1: 
    1:     chars[nchars++] = '}';
    1:     if (outermost)
    1:         chars[nchars++] = ')';
    1:     chars[nchars] = 0;
    1: 
    1:   error:
    1:     js_LeaveSharpObject(cx, &ida);
    1: 
    1:     if (!ok) {
    1:         if (chars)
30851:             js_free(chars);
 6917:         goto out;
    1:     }
    1: 
    1:     if (!chars) {
    1:         JS_ReportOutOfMemory(cx);
 6917:         ok = JS_FALSE;
 6917:         goto out;
    1:     }
    1:   make_string:
 4718:     str = js_NewString(cx, chars, nchars);
    1:     if (!str) {
30851:         js_free(chars);
 6917:         ok = JS_FALSE;
 6917:         goto out;
    1:     }
48470:     vp->setString(str);
 6917:     ok = JS_TRUE;
 6917:   out:
 6917:     return ok;
    1: 
    1:   overflow:
30851:     cx->free(vsharp);
30851:     js_free(chars);
    1:     chars = NULL;
    1:     goto error;
    1: }
    1: #endif /* JS_HAS_TOSOURCE */
    1: 
47498: namespace js {
47498: 
47498: JSString *
47498: obj_toStringHelper(JSContext *cx, JSObject *obj)
47498: {
47498:     if (obj->isProxy())
47498:         return JSProxy::obj_toString(cx, obj);
47498: 
56565:     const char *clazz = obj->getClass()->name;
47498:     size_t nchars = 9 + strlen(clazz); /* 9 for "[object ]" */
47498:     jschar *chars = (jschar *) cx->malloc((nchars + 1) * sizeof(jschar));
    1:     if (!chars)
47498:         return NULL;
47498: 
47498:     const char *prefix = "[object ";
    1:     nchars = 0;
    1:     while ((chars[nchars] = (jschar)*prefix) != 0)
    1:         nchars++, prefix++;
    1:     while ((chars[nchars] = (jschar)*clazz) != 0)
    1:         nchars++, clazz++;
    1:     chars[nchars++] = ']';
    1:     chars[nchars] = 0;
    1: 
47498:     JSString *str = js_NewString(cx, chars, nchars);
47498:     if (!str)
30851:         cx->free(chars);
47498:     return str;
47498: }
47498: 
47498: }
47498: 
55714: /* ES5 15.2.4.2.  Note steps 1 and 2 are errata. */
47498: static JSBool
48470: obj_toString(JSContext *cx, uintN argc, Value *vp)
48470: {
55714:     Value &thisv = vp[1];
55714: 
61734:     /* Step 1. */
55714:     if (thisv.isUndefined()) {
55714:         vp->setString(ATOM_TO_STRING(cx->runtime->atomState.objectUndefinedAtom));
55714:         return true;
55714:     }
55714: 
61734:     /* Step 2. */
55714:     if (thisv.isNull()) {
55714:         vp->setString(ATOM_TO_STRING(cx->runtime->atomState.objectNullAtom));
55714:         return true;
55714:     }
55714: 
61734:     /* Step 3. */
61734:     JSObject *obj = ToObject(cx, &thisv);
61734:     if (!obj)
47498:         return false;
47498: 
61734:     /* Steps 4-5. */
61734:     JSString *str = js::obj_toStringHelper(cx, obj);
47498:     if (!str)
47498:         return false;
48470:     vp->setString(str);
47498:     return true;
    1: }
    1: 
    1: static JSBool
48470: obj_toLocaleString(JSContext *cx, uintN argc, Value *vp)
48470: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
61734:     JSString *str = js_ValueToString(cx, ObjectValue(*obj));
    1:     if (!str)
    1:         return JS_FALSE;
    1: 
48470:     vp->setString(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
48470: obj_valueOf(JSContext *cx, uintN argc, Value *vp)
48470: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734:     vp->setObject(*obj);
61734:     return true;
    1: }
    1: 
    1: /*
39061:  * Check if CSP allows new Function() or eval() to run in the current
39061:  * principals.
39061:  */
39061: JSBool
61215: js_CheckContentSecurityPolicy(JSContext *cx, JSObject *scopeobj)
61215: {
61215:     // CSP is static per document, so if our check said yes before, that
61215:     // answer is still valid.
61215:     JSObject *global = scopeobj->getGlobal();
61215:     Value v = global->getReservedSlot(JSRESERVED_GLOBAL_EVAL_ALLOWED);
61215:     if (v.isUndefined()) {
42656:         JSSecurityCallbacks *callbacks = JS_GetSecurityCallbacks(cx);
39061: 
39061:         // if there are callbacks, make sure that the CSP callback is installed and
39061:         // that it permits eval().
61215:         v.setBoolean((!callbacks || !callbacks->contentSecurityPolicyAllows) ||
61215:                      callbacks->contentSecurityPolicyAllows(cx));
61215: 
61215:         // update the cache in the global object for the result of the security check
61215:         js_SetReservedSlot(cx, global, JSRESERVED_GLOBAL_EVAL_ALLOWED, v);
61215:     }
61215:     return !v.isFalse();
39061: }
39061: 
39061: /*
    1:  * Check whether principals subsumes scopeobj's principals, and return true
    1:  * if so (or if scopeobj has no principals, for backward compatibility with
    1:  * the JS API, which does not require principals), and false otherwise.
    1:  */
    1: JSBool
    1: js_CheckPrincipalsAccess(JSContext *cx, JSObject *scopeobj,
    1:                          JSPrincipals *principals, JSAtom *caller)
    1: {
18870:     JSSecurityCallbacks *callbacks;
    1:     JSPrincipals *scopePrincipals;
    1: 
18870:     callbacks = JS_GetSecurityCallbacks(cx);
18870:     if (callbacks && callbacks->findObjectPrincipals) {
18870:         scopePrincipals = callbacks->findObjectPrincipals(cx, scopeobj);
    1:         if (!principals || !scopePrincipals ||
    1:             !principals->subsume(principals, scopePrincipals)) {
57812:             JSAutoByteString callerstr;
57812:             if (!js_AtomToPrintableString(cx, caller, &callerstr))
    1:                 return JS_FALSE;
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
57812:                                  JSMSG_BAD_INDIRECT_CALL, callerstr.ptr());
    1:             return JS_FALSE;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
56775: static bool
56775: CheckScopeChainValidity(JSContext *cx, JSObject *scopeobj)
56775: {
56775:     JSObject *inner = scopeobj;
56775:     OBJ_TO_INNER_OBJECT(cx, inner);
56775:     if (!inner)
56775:         return false;
56775:     JS_ASSERT(inner == scopeobj);
    1: 
48622:     /* XXX This is an awful gross hack. */
    1:     while (scopeobj) {
48622:         JSObjectOp op = scopeobj->getClass()->ext.innerObject;
56775:         if (op && op(cx, scopeobj) != scopeobj) {
56775:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_INDIRECT_CALL,
56775:                                  js_eval_str);
56775:             return false;
56775:         }
39930:         scopeobj = scopeobj->getParent();
    1:     }
    1: 
56775:     return true;
    1: }
    1: 
12690: const char *
12690: js_ComputeFilename(JSContext *cx, JSStackFrame *caller,
12690:                    JSPrincipals *principals, uintN *linenop)
12690: {
12690:     uint32 flags;
18870: #ifdef DEBUG
18870:     JSSecurityCallbacks *callbacks = JS_GetSecurityCallbacks(cx);
18870: #endif
18870: 
18870:     JS_ASSERT(principals || !(callbacks  && callbacks->findObjectPrincipals));
53840:     flags = JS_GetScriptFilenameFlags(caller->script());
12690:     if ((flags & JSFILENAME_PROTECTED) &&
18472:         principals &&
12690:         strcmp(principals->codebase, "[System Principal]")) {
12690:         *linenop = 0;
12690:         return principals->codebase;
12690:     }
12690: 
42717:     jsbytecode *pc = caller->pc(cx);
53840:     if (pc && js_GetOpcode(cx, caller->script(), pc) == JSOP_EVAL) {
53840:         JS_ASSERT(js_GetOpcode(cx, caller->script(), pc + JSOP_EVAL_LENGTH) == JSOP_LINENO);
42717:         *linenop = GET_UINT16(pc + JSOP_EVAL_LENGTH);
13504:     } else {
21685:         *linenop = js_FramePCToLineNumber(cx, caller);
13504:     }
53840:     return caller->script()->filename;
12690: }
12690: 
24375: #ifndef EVAL_CACHE_CHAIN_LIMIT
24375: # define EVAL_CACHE_CHAIN_LIMIT 4
24375: #endif
24375: 
24375: static inline JSScript **
59890: EvalCacheHash(JSContext *cx, JSLinearString *str)
59890: {
59890:     const jschar *s = str->chars();
59890:     size_t n = str->length();
59890: 
24375:     if (n > 100)
24375:         n = 100;
59890:     uint32 h;
24375:     for (h = 0; n; s++, n--)
24375:         h = JS_ROTATE_LEFT32(h, 4) ^ *s;
24375: 
24375:     h *= JS_GOLDEN_RATIO;
24375:     h >>= 32 - JS_EVAL_CACHE_SHIFT;
24375:     return &JS_SCRIPTS_TO_GC(cx)[h];
24375: }
24375: 
55553: static JS_ALWAYS_INLINE JSScript *
59890: EvalCacheLookup(JSContext *cx, JSLinearString *str, JSStackFrame *caller, uintN staticLevel,
55560:                 JSPrincipals *principals, JSObject *scopeobj, JSScript **bucket)
55553: {
55553:     /*
55553:      * Cache local eval scripts indexed by source qualified by scope.
55553:      *
55553:      * An eval cache entry should never be considered a hit unless its
55553:      * strictness matches that of the new eval code. The existing code takes
55553:      * care of this, because hits are qualified by the function from which
59939:      * eval was called, whose strictness doesn't change. (We don't cache evals
59939:      * in eval code, so the calling function corresponds to the calling script,
59939:      * and its strictness never varies.) Scripts produced by calls to eval from
59939:      * global code aren't cached.
59939:      *
59939:      * FIXME bug 620141: Qualify hits by calling script rather than function.
59939:      * Then we wouldn't need the unintuitive !isEvalFrame() hack in EvalKernel
59939:      * to avoid caching nested evals in functions (thus potentially mismatching
59939:      * on strict mode), and we could cache evals in global code if desired.
55553:      */
55553:     uintN count = 0;
55553:     JSScript **scriptp = bucket;
55553: 
55553:     EVAL_CACHE_METER(probe);
55553:     JSVersion version = cx->findVersion();
55553:     JSScript *script;
55553:     while ((script = *scriptp) != NULL) {
55553:         if (script->savedCallerFun &&
55553:             script->staticLevel == staticLevel &&
61450:             script->getVersion() == version &&
59962:             !script->hasSingletons &&
55553:             (script->principals == principals ||
55553:              (principals->subsume(principals, script->principals) &&
55553:               script->principals->subsume(script->principals, principals)))) {
55553:             /*
55553:              * Get the prior (cache-filling) eval's saved caller function.
55553:              * See Compiler::compileScript in jsparse.cpp.
55553:              */
55553:             JSFunction *fun = script->getFunction(0);
55553: 
55553:             if (fun == caller->fun()) {
55553:                 /*
55553:                  * Get the source string passed for safekeeping in the
55553:                  * atom map by the prior eval to Compiler::compileScript.
55553:                  */
59890:                 JSAtom *src = script->atomMap.vector[0];
59890: 
59890:                 if (src == str || EqualStrings(src, str)) {
55553:                     /*
55553:                      * Source matches, qualify by comparing scopeobj to the
55553:                      * COMPILE_N_GO-memoized parent of the first literal
55553:                      * function or regexp object if any. If none, then this
55553:                      * script has no compiled-in dependencies on the prior
55553:                      * eval's scopeobj.
55553:                      */
55553:                     JSObjectArray *objarray = script->objects();
55553:                     int i = 1;
55553: 
55553:                     if (objarray->length == 1) {
59221:                         if (JSScript::isValidOffset(script->regexpsOffset)) {
55553:                             objarray = script->regexps();
55553:                             i = 0;
55553:                         } else {
55553:                             EVAL_CACHE_METER(noscope);
55553:                             i = -1;
55553:                         }
55553:                     }
55553:                     if (i < 0 ||
55553:                         objarray->vector[i]->getParent() == scopeobj) {
55553:                         JS_ASSERT(staticLevel == script->staticLevel);
55553:                         EVAL_CACHE_METER(hit);
55553:                         *scriptp = script->u.nextToGC;
55553:                         script->u.nextToGC = NULL;
55553:                         return script;
55553:                     }
55553:                 }
55553:             }
55553:         }
55553: 
55553:         if (++count == EVAL_CACHE_CHAIN_LIMIT)
55553:             return NULL;
55553:         EVAL_CACHE_METER(step);
55553:         scriptp = &script->u.nextToGC;
55553:     }
55553:     return NULL;
55553: }
55553: 
56556: /* ES5 15.1.2.1. */
20408: static JSBool
56556: eval(JSContext *cx, uintN argc, Value *vp)
38586: {
56775:     /*
56775:      * NB: This method handles only indirect eval: direct eval is handled by
56775:      *     JSOP_EVAL.
56775:      */
38586: 
38592:     JSStackFrame *caller = js_GetScriptedCaller(cx, NULL);
56775: 
56775:     /* FIXME Bug 602994: This really should be perfectly cromulent. */
55532:     if (!caller) {
55549:         /* Eval code needs to inherit principals from the caller. */
55532:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
55532:                              JSMSG_BAD_INDIRECT_CALL, js_eval_str);
55553:         return false;
55532:     }
55532: 
56775:     return EvalKernel(cx, argc, vp, INDIRECT_EVAL, caller, vp[0].toObject().getGlobal());
56775: }
56775: 
56775: namespace js {
56775: 
56775: bool
56775: EvalKernel(JSContext *cx, uintN argc, Value *vp, EvalType evalType, JSStackFrame *caller,
56775:            JSObject *scopeobj)
56775: {
 2112:     /*
56775:      * FIXME Bug 602994: Calls with no scripted caller should be permitted and
56775:      *       should be implemented as indirect calls.
55482:      */
56775:     JS_ASSERT(caller);
56775:     JS_ASSERT(scopeobj);
    1: 
48589:     /*
48589:      * We once supported a second argument to eval to use as the scope chain
48589:      * when evaluating the code string.  Warn when such uses are seen so that
48589:      * authors will know that support for eval(s, o) has been removed.
48589:      */
56775:     JSScript *callerScript = caller->script();
56775:     if (argc > 1 && !callerScript->warnedAboutTwoArgumentEval) {
48589:         static const char TWO_ARGUMENT_WARNING[] =
48589:             "Support for eval(code, scopeObject) has been removed. "
48589:             "Use |with (scopeObject) eval(code);| instead.";
48589:         if (!JS_ReportWarning(cx, TWO_ARGUMENT_WARNING))
55553:             return false;
56775:         callerScript->warnedAboutTwoArgumentEval = true;
56775:     }
55549: 
55549:     /*
55549:      * CSP check: Is eval() allowed at all?
55549:      * Report errors via CSP is done in the script security mgr.
55549:      */
61215:     if (!js_CheckContentSecurityPolicy(cx, scopeobj)) {
39061:         JS_ReportError(cx, "call to eval() blocked by CSP");
55553:         return false;
39061:     }
39061: 
56775:     /* ES5 15.1.2.1 step 1. */
56775:     if (argc < 1) {
56775:         vp->setUndefined();
56775:         return true;
56775:     }
56775:     if (!vp[2].isString()) {
56775:         *vp = vp[2];
56775:         return true;
56775:     }
56775:     JSString *str = vp[2].toString();
56775: 
56775:     /* ES5 15.1.2.1 steps 2-8. */
56775:     JSObject *callee = JSVAL_TO_OBJECT(JS_CALLEE(cx, Jsvalify(vp)));
56775:     JS_ASSERT(IsBuiltinEvalFunction(callee->getFunctionPrivate()));
38586:     JSPrincipals *principals = js_EvalFramePrincipals(cx, callee, caller);
56775: 
56775:     /*
56775:      * Per ES5, indirect eval runs in the global scope. (eval is specified this
56775:      * way so that the compiler can make assumptions about what bindings may or
56775:      * may not exist in the current frame if it doesn't see 'eval'.)
56775:      */
56775:     uintN staticLevel;
56775:     if (evalType == DIRECT_EVAL) {
56775:         staticLevel = caller->script()->staticLevel + 1;
56775: 
56775: #ifdef DEBUG
56775:         jsbytecode *callerPC = caller->pc(cx);
56775:         JS_ASSERT_IF(caller->isFunctionFrame(), caller->hasCallObj());
56775:         JS_ASSERT(callerPC && js_GetOpcode(cx, caller->script(), callerPC) == JSOP_EVAL);
56775: #endif
56775:     } else {
56775:         /* Pretend that we're top level. */
56775:         staticLevel = 0;
56775: 
56775:         JS_ASSERT(scopeobj == scopeobj->getGlobal());
56775:         JS_ASSERT(scopeobj->isGlobal());
56775:     }
56775: 
56775:     /* Ensure we compile this eval with the right object in the scope chain. */
56775:     if (!CheckScopeChainValidity(cx, scopeobj))
56775:         return false;
55532: 
59890:     JSLinearString *linearStr = str->ensureLinear(cx);
59890:     if (!linearStr)
59890:         return false;
59890:     const jschar *chars = linearStr->chars();
59890:     size_t length = linearStr->length();
51457: 
51457:     /*
51457:      * If the eval string starts with '(' and ends with ')', it may be JSON.
51457:      * Try the JSON parser first because it's much faster.  If the eval string
51457:      * isn't JSON, JSON parsing will probably fail quickly, so little time
51457:      * will be lost.
51457:      */
51457:     if (length > 2 && chars[0] == '(' && chars[length - 1] == ')') {
51457:         JSONParser *jp = js_BeginJSONParse(cx, vp, /* suppressErrors = */true);
56775:         if (jp != NULL) {
51457:             /* Run JSON-parser on string inside ( and ). */
57776:             bool ok = js_ConsumeJSONText(cx, jp, chars + 1, length - 2);
51457:             ok &= js_FinishJSONParse(cx, jp, NullValue());
51457:             if (ok)
55553:                 return true;
55553:         }
55553:     }
55553: 
56775:     /*
56775:      * Direct calls to eval are supposed to see the caller's |this|. If we
56775:      * haven't wrapped that yet, do so now, before we make a copy of it for
56775:      * the eval code to use.
56775:      */
56775:     if (evalType == DIRECT_EVAL && !caller->computeThis(cx))
56775:         return false;
56775: 
56775:     JSScript *script = NULL;
59890:     JSScript **bucket = EvalCacheHash(cx, linearStr);
62571:     if (evalType == DIRECT_EVAL && caller->isFunctionFrame() && !caller->isEvalFrame()) {
59890:         script = EvalCacheLookup(cx, linearStr, caller, staticLevel, principals, scopeobj, bucket);
24375: 
33281:         /*
62571:          * Although the eval cache keeps a script alive from the perspective of
62571:          * the JS engine, from a jsdbgapi user's perspective each eval()
62571:          * creates and destroys a script. This hides implementation details and
62571:          * allows jsdbgapi clients to avoid calling JS_GetScriptObject after a
62571:          * script has been returned to the eval cache, which is invalid since
62571:          * script->u.object aliases script->u.nextToGC.
62571:          */
62571:         if (script) {
62571:             js_CallNewScriptHook(cx, script, NULL);
62571:             MUST_FLOW_THROUGH("destroy");
62571:         }
62571:     }
62571: 
62571:     /*
56775:      * We can't have a callerFrame (down in js::Execute's terms) if we're in
56775:      * global code (or if we're an indirect eval).
33281:      */
38586:     JSStackFrame *callerFrame = (staticLevel != 0) ? caller : NULL;
24375:     if (!script) {
56775:         uintN lineno;
56775:         const char *filename = js_ComputeFilename(cx, caller, principals, &lineno);
56775: 
52555:         uint32 tcflags = TCF_COMPILE_N_GO | TCF_NEED_MUTABLE_SCRIPT | TCF_COMPILE_FOR_EVAL;
40860:         script = Compiler::compileScript(cx, scopeobj, callerFrame,
59890:                                          principals, tcflags, chars, length,
61450:                                          filename, lineno, cx->findVersion(),
61450:                                          linearStr, staticLevel);
38586:         if (!script)
55553:             return false;
    1:     }
    1: 
55482:     assertSameCompartment(cx, scopeobj, script);
55482: 
    1:     /*
    1:      * Belt-and-braces: check that the lesser of eval's principals and the
    1:      * caller's principals has access to scopeobj.
    1:      */
38586:     JSBool ok = js_CheckPrincipalsAccess(cx, scopeobj, principals,
38586:                                          cx->runtime->atomState.evalAtom) &&
48470:                 Execute(cx, scopeobj, script, callerFrame, JSFRAME_EVAL, vp);
    1: 
62571:     MUST_FLOW_LABEL(destroy);
62571:     js_CallDestroyScriptHook(cx, script);
62571: 
24375:     script->u.nextToGC = *bucket;
24375:     *bucket = script;
18316: #ifdef CHECK_SCRIPT_OWNER
18316:     script->owner = NULL;
18316: #endif
 6766: 
    1:     return ok;
    1: }
    1: 
61449: JS_FRIEND_API(bool)
56556: IsBuiltinEvalFunction(JSFunction *fun)
56556: {
56556:     return fun->maybeNative() == eval;
56556: }
56556: 
56556: }
56556: 
    1: #if JS_HAS_OBJ_WATCHPOINT
    1: 
    1: static JSBool
48470: obj_watch_handler(JSContext *cx, JSObject *obj, jsid id, jsval old,
48470:                   jsval *nvp, void *closure)
    1: {
    1:     JSObject *callable;
18870:     JSSecurityCallbacks *callbacks;
    1:     JSStackFrame *caller;
    1:     JSPrincipals *subject, *watcher;
    1:     JSResolvingKey key;
    1:     JSResolvingEntry *entry;
    1:     uint32 generation;
48470:     Value argv[3];
    1:     JSBool ok;
    1: 
    1:     callable = (JSObject *) closure;
    1: 
18870:     callbacks = JS_GetSecurityCallbacks(cx);
18870:     if (callbacks && callbacks->findObjectPrincipals) {
    1:         /* Skip over any obj_watch_* frames between us and the real subject. */
22652:         caller = js_GetScriptedCaller(cx, NULL);
    1:         if (caller) {
    1:             /*
    1:              * Only call the watch handler if the watcher is allowed to watch
    1:              * the currently executing script.
    1:              */
18870:             watcher = callbacks->findObjectPrincipals(cx, callable);
53557:             subject = js_StackFramePrincipals(cx, caller);
    1: 
    1:             if (watcher && subject && !watcher->subsume(watcher, subject)) {
    1:                 /* Silently don't call the watch handler. */
    1:                 return JS_TRUE;
    1:             }
    1:         }
    1:     }
    1: 
    1:     /* Avoid recursion on (obj, id) already being watched on cx. */
    1:     key.obj = obj;
    1:     key.id = id;
    1:     if (!js_StartResolving(cx, &key, JSRESFLAG_WATCH, &entry))
    1:         return JS_FALSE;
    1:     if (!entry)
    1:         return JS_TRUE;
    1:     generation = cx->resolvingTable->generation;
    1: 
48470:     argv[0] = IdToValue(id);
48470:     argv[1] = Valueify(old);
48470:     argv[2] = Valueify(*nvp);
61734:     ok = ExternalInvoke(cx, ObjectValue(*obj), ObjectOrNullValue(callable), 3, argv,
61734:                         Valueify(nvp));
    1:     js_StopResolving(cx, &key, JSRESFLAG_WATCH, entry, generation);
    1:     return ok;
    1: }
    1: 
    1: static JSBool
48470: obj_watch(JSContext *cx, uintN argc, Value *vp)
48470: {
16519:     if (argc <= 1) {
48470:         js_ReportMissingArg(cx, *vp, 1);
50518:         return JS_FALSE;
16519:     }
16519: 
48470:     JSObject *callable = js_ValueToCallableObject(cx, &vp[3], 0);
    1:     if (!callable)
50518:         return JS_FALSE;
    1: 
    1:     /* Compute the unique int/atom symbol id needed by js_LookupProperty. */
48470:     jsid propid;
48470:     if (!ValueToId(cx, vp[2], &propid))
50518:         return JS_FALSE;
    1: 
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
48470:     Value tmp;
48470:     uintN attrs;
61734:     if (!CheckAccess(cx, obj, propid, JSACC_WATCH, &tmp, &attrs))
50518:         return JS_FALSE;
40878: 
48470:     vp->setUndefined();
40878: 
    1:     if (attrs & JSPROP_READONLY)
50518:         return JS_TRUE;
43287:     if (obj->isDenseArray() && !obj->makeDenseArraySlow(cx))
50518:         return JS_FALSE;
48470:     return JS_SetWatchPoint(cx, obj, propid, obj_watch_handler, callable);
    1: }
    1: 
    1: static JSBool
48470: obj_unwatch(JSContext *cx, uintN argc, Value *vp)
48470: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
11809:     if (!obj)
61734:         return false;
48470:     vp->setUndefined();
48470:     jsid id;
48470:     if (argc != 0) {
48470:         if (!ValueToId(cx, vp[2], &id))
48470:             return JS_FALSE;
48470:     } else {
48470:         id = JSID_VOID;
48470:     }
48470:     return JS_ClearWatchPoint(cx, obj, id, NULL, NULL);
    1: }
    1: 
    1: #endif /* JS_HAS_OBJ_WATCHPOINT */
    1: 
    1: /*
    1:  * Prototype and property query methods, to complement the 'in' and
    1:  * 'instanceof' operators.
    1:  */
    1: 
    1: /* Proposed ECMA 15.2.4.5. */
20408: static JSBool
48470: obj_hasOwnProperty(JSContext *cx, uintN argc, Value *vp)
48470: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734:     return js_HasOwnPropertyHelper(cx, obj->getOps()->lookupProperty, argc, vp);
    1: }
    1: 
    1: JSBool
54746: js_HasOwnPropertyHelper(JSContext *cx, LookupPropOp lookup, uintN argc,
48470:                         Value *vp)
    1: {
    1:     jsid id;
48470:     if (!ValueToId(cx, argc != 0 ? vp[2] : UndefinedValue(), &id))
    1:         return JS_FALSE;
32721: 
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
36991:     JSObject *obj2;
36991:     JSProperty *prop;
42733:     if (obj->isProxy()) {
42733:         bool has;
42733:         if (!JSProxy::hasOwn(cx, obj, id, &has))
42733:             return false;
48470:         vp->setBoolean(has);
42733:         return true;
42733:     }
42733:     if (!js_HasOwnProperty(cx, lookup, obj, id, &obj2, &prop))
36991:         return JS_FALSE;
56568:     vp->setBoolean(!!prop);
32721:     return JS_TRUE;
18062: }
18062: 
18062: JSBool
54746: js_HasOwnProperty(JSContext *cx, LookupPropOp lookup, JSObject *obj, jsid id,
36991:                   JSObject **objp, JSProperty **propp)
36991: {
43285:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED | JSRESOLVE_DETECTING);
48622:     if (!(lookup ? lookup : js_LookupProperty)(cx, obj, id, objp, propp))
40327:         return false;
36991:     if (!*propp)
40327:         return true;
36991: 
36991:     if (*objp == obj)
40327:         return true;
36991: 
48470:     Class *clasp = (*objp)->getClass();
48622:     JSObject *outer = NULL;
48622:     if (JSObjectOp op = (*objp)->getClass()->ext.outerObject) {
48622:         outer = op(cx, *objp);
 4780:         if (!outer)
40327:             return false;
40327:     }
40327: 
36991:     if (outer != *objp) {
40430:         if ((*objp)->isNative() && obj->getClass() == clasp) {
    1:             /*
    1:              * The combination of JSPROP_SHARED and JSPROP_PERMANENT in a
    1:              * delegated property makes that property appear to be direct in
    1:              * all delegating instances of the same native class.  This hack
    1:              * avoids bloating every function instance with its own 'length'
    1:              * (AKA 'arity') property.  But it must not extend across class
    1:              * boundaries, to avoid making hasOwnProperty lie (bug 320854).
    1:              *
    1:              * It's not really a hack, of course: a permanent property can't
    1:              * be deleted, and JSPROP_SHARED means "don't allocate a slot in
    1:              * any instance, prototype or delegating".  Without a slot, and
    1:              * without the ability to remove and recreate (with differences)
    1:              * the property, there is no way to tell whether it is directly
    1:              * owned, or indirectly delegated.
    1:              */
52503:             Shape *shape = reinterpret_cast<Shape *>(*propp);
52503:             if (shape->isSharedPermanent())
40327:                 return true;
40327:         }
40327: 
36991:         *propp = NULL;
36991:     }
40327:     return true;
    1: }
    1: 
61734: /* ES5 15.2.4.6. */
    1: static JSBool
48470: obj_isPrototypeOf(JSContext *cx, uintN argc, Value *vp)
48470: {
61734:     /* Step 1. */
61734:     if (argc < 1 || !vp[2].isObject()) {
61734:         vp->setBoolean(false);
61734:         return true;
61734:     }
61734: 
61734:     /* Step 2. */
61734:     JSObject *obj = ToObject(cx, &vp[1]);
40880:     if (!obj)
61734:         return false;
61734: 
61734:     /* Step 3. */
61734:     vp->setBoolean(js_IsDelegate(cx, obj, vp[2]));
61734:     return true;
61734: }
61734: 
61734: /* ES5 15.2.4.7. */
20408: static JSBool
48470: obj_propertyIsEnumerable(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     /* Step 1. */
    1:     jsid id;
48470:     if (!ValueToId(cx, argc != 0 ? vp[2] : UndefinedValue(), &id))
61734:         return false;
61734: 
61734:     /* Step 2. */
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
61734:     /* Steps 3-5. */
61734:     return js_PropertyIsEnumerable(cx, obj, id, vp);
18062: }
18062: 
18062: JSBool
48470: js_PropertyIsEnumerable(JSContext *cx, JSObject *obj, jsid id, Value *vp)
18062: {
18062:     JSObject *pobj;
    1:     JSProperty *prop;
31501:     if (!obj->lookupProperty(cx, id, &pobj, &prop))
    1:         return JS_FALSE;
    1: 
    1:     if (!prop) {
48470:         vp->setBoolean(false);
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     /*
    1:      * XXX ECMA spec error compatible: return false unless hasOwnProperty.
    1:      * The ECMA spec really should be fixed so propertyIsEnumerable and the
    1:      * for..in loop agree on whether prototype properties are enumerable,
    1:      * obviously by fixing this method (not by breaking the for..in loop!).
    1:      *
    1:      * We check here for shared permanent prototype properties, which should
    1:      * be treated as if they are local to obj.  They are an implementation
    1:      * technique used to satisfy ECMA requirements; users should not be able
    1:      * to distinguish a shared permanent proto-property from a local one.
    1:      */
43290:     bool shared;
43290:     uintN attrs;
43290:     if (pobj->isNative()) {
52503:         Shape *shape = (Shape *) prop;
52503:         shared = shape->isSharedPermanent();
52503:         attrs = shape->attributes();
43290:     } else {
43290:         shared = false;
43290:         if (!pobj->getAttributes(cx, id, &attrs))
43290:             return false;
43290:     }
43290:     if (pobj != obj && !shared) {
48470:         vp->setBoolean(false);
43290:         return true;
43290:     }
48470:     vp->setBoolean((attrs & JSPROP_ENUMERATE) != 0);
43290:     return true;
    1: }
    1: 
40855: #if OLD_GETTER_SETTER_METHODS
40855: 
40855: const char js_defineGetter_str[] = "__defineGetter__";
40855: const char js_defineSetter_str[] = "__defineSetter__";
40855: const char js_lookupGetter_str[] = "__lookupGetter__";
40855: const char js_lookupSetter_str[] = "__lookupSetter__";
40855: 
24145: JS_FRIEND_API(JSBool)
48470: js_obj_defineGetter(JSContext *cx, uintN argc, Value *vp)
48470: {
61734:     if (!BoxThisForVp(cx, vp))
61734:         return false;
61734:     JSObject *obj = &vp[1].toObject();
61734: 
38638:     if (argc <= 1 || !js_IsCallable(vp[3])) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_BAD_GETTER_OR_SETTER,
    1:                              js_getter_str);
    1:         return JS_FALSE;
    1:     }
48470:     PropertyOp getter = CastAsPropertyOp(&vp[3].toObject());
48470: 
48470:     jsid id;
48470:     if (!ValueToId(cx, vp[2], &id))
    1:         return JS_FALSE;
62411:     if (!CheckRedeclaration(cx, obj, id, JSPROP_GETTER))
    1:         return JS_FALSE;
50518:     /*
50518:      * Getters and setters are just like watchpoints from an access
50518:      * control point of view.
50518:      */
48470:     Value junk;
48470:     uintN attrs;
50518:     if (!CheckAccess(cx, obj, id, JSACC_WATCH, &junk, &attrs))
    1:         return JS_FALSE;
48470:     vp->setUndefined();
62395:     return obj->defineProperty(cx, id, UndefinedValue(), getter, StrictPropertyStub,
32573:                                JSPROP_ENUMERATE | JSPROP_GETTER | JSPROP_SHARED);
    1: }
    1: 
24145: JS_FRIEND_API(JSBool)
48470: js_obj_defineSetter(JSContext *cx, uintN argc, Value *vp)
48470: {
61734:     if (!BoxThisForVp(cx, vp))
61734:         return false;
61734:     JSObject *obj = &vp[1].toObject();
61734: 
38638:     if (argc <= 1 || !js_IsCallable(vp[3])) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_BAD_GETTER_OR_SETTER,
    1:                              js_setter_str);
    1:         return JS_FALSE;
    1:     }
62395:     StrictPropertyOp setter = CastAsStrictPropertyOp(&vp[3].toObject());
48470: 
48470:     jsid id;
48470:     if (!ValueToId(cx, vp[2], &id))
    1:         return JS_FALSE;
62411:     if (!CheckRedeclaration(cx, obj, id, JSPROP_SETTER))
    1:         return JS_FALSE;
50518:     /*
50518:      * Getters and setters are just like watchpoints from an access
50518:      * control point of view.
50518:      */
48470:     Value junk;
48470:     uintN attrs;
50518:     if (!CheckAccess(cx, obj, id, JSACC_WATCH, &junk, &attrs))
    1:         return JS_FALSE;
48470:     vp->setUndefined();
48470:     return obj->defineProperty(cx, id, UndefinedValue(), PropertyStub, setter,
32573:                                JSPROP_ENUMERATE | JSPROP_SETTER | JSPROP_SHARED);
    1: }
    1: 
    1: static JSBool
48470: obj_lookupGetter(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     jsid id;
48470:     if (!ValueToId(cx, argc != 0 ? vp[2] : UndefinedValue(), &id))
48470:         return JS_FALSE;
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return JS_FALSE;
48470:     JSObject *pobj;
    1:     JSProperty *prop;
61734:     if (!obj->lookupProperty(cx, id, &pobj, &prop))
    1:         return JS_FALSE;
48470:     vp->setUndefined();
    1:     if (prop) {
40430:         if (pobj->isNative()) {
52503:             Shape *shape = (Shape *) prop;
52503:             if (shape->hasGetterValue())
52503:                 *vp = shape->getterValue();
43290:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
48470: obj_lookupSetter(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     jsid id;
48470:     if (!ValueToId(cx, argc != 0 ? vp[2] : UndefinedValue(), &id))
48470:         return JS_FALSE;
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return JS_FALSE;
48470:     JSObject *pobj;
    1:     JSProperty *prop;
61734:     if (!obj->lookupProperty(cx, id, &pobj, &prop))
    1:         return JS_FALSE;
48470:     vp->setUndefined();
    1:     if (prop) {
40430:         if (pobj->isNative()) {
52503:             Shape *shape = (Shape *) prop;
52503:             if (shape->hasSetterValue())
52503:                 *vp = shape->setterValue();
43290:         }
    1:     }
    1:     return JS_TRUE;
    1: }
40855: #endif /* OLD_GETTER_SETTER_METHODS */
    1: 
16380: JSBool
48470: obj_getPrototypeOf(JSContext *cx, uintN argc, Value *vp)
48470: {
16519:     if (argc == 0) {
48470:         js_ReportMissingArg(cx, *vp, 0);
16519:         return JS_FALSE;
16519:     }
16519: 
48470:     if (vp[2].isPrimitive()) {
50457:         char *bytes = DecompileValueGenerator(cx, JSDVG_SEARCH_STACK, vp[2], NULL);
31844:         if (!bytes)
16380:             return JS_FALSE;
31844:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
31844:                              JSMSG_UNEXPECTED_TYPE, bytes, "not an object");
31844:         JS_free(cx, bytes);
31844:         return JS_FALSE;
31844:     }
31844: 
48470:     JSObject *obj = &vp[2].toObject();
48470:     uintN attrs;
50518:     return CheckAccess(cx, obj, ATOM_TO_JSID(cx->runtime->atomState.protoAtom),
16380:                        JSACC_PROTO, vp, &attrs);
16380: }
16380: 
42733: extern JSBool
48470: js_NewPropertyDescriptorObject(JSContext *cx, jsid id, uintN attrs,
48470:                                const Value &getter, const Value &setter,
48470:                                const Value &value, Value *vp)
42733: {
42733:     /* We have our own property, so start creating the descriptor. */
47497:     JSObject *desc = NewBuiltinClassInstance(cx, &js_ObjectClass);
42733:     if (!desc)
42733:         return false;
48470:     vp->setObject(*desc);    /* Root and return. */
42733: 
42733:     const JSAtomState &atomState = cx->runtime->atomState;
42733:     if (attrs & (JSPROP_GETTER | JSPROP_SETTER)) {
42733:         if (!desc->defineProperty(cx, ATOM_TO_JSID(atomState.getAtom), getter,
62395:                                   PropertyStub, StrictPropertyStub, JSPROP_ENUMERATE) ||
42733:             !desc->defineProperty(cx, ATOM_TO_JSID(atomState.setAtom), setter,
62395:                                   PropertyStub, StrictPropertyStub, JSPROP_ENUMERATE)) {
42733:             return false;
42733:         }
42733:     } else {
42733:         if (!desc->defineProperty(cx, ATOM_TO_JSID(atomState.valueAtom), value,
62395:                                   PropertyStub, StrictPropertyStub, JSPROP_ENUMERATE) ||
42733:             !desc->defineProperty(cx, ATOM_TO_JSID(atomState.writableAtom),
48470:                                   BooleanValue((attrs & JSPROP_READONLY) == 0),
62395:                                   PropertyStub, StrictPropertyStub, JSPROP_ENUMERATE)) {
42733:             return false;
42733:         }
42733:     }
42733: 
42733:     return desc->defineProperty(cx, ATOM_TO_JSID(atomState.enumerableAtom),
48470:                                 BooleanValue((attrs & JSPROP_ENUMERATE) != 0),
62395:                                 PropertyStub, StrictPropertyStub, JSPROP_ENUMERATE) &&
42733:            desc->defineProperty(cx, ATOM_TO_JSID(atomState.configurableAtom),
48470:                                 BooleanValue((attrs & JSPROP_PERMANENT) == 0),
62395:                                 PropertyStub, StrictPropertyStub, JSPROP_ENUMERATE);
42733: }
42733: 
40356: JSBool
48470: js_GetOwnPropertyDescriptor(JSContext *cx, JSObject *obj, jsid id, Value *vp)
40356: {
56606:     if (obj->isProxy())
56606:         return JSProxy::getOwnPropertyDescriptor(cx, obj, id, false, vp);
42733: 
36991:     JSObject *pobj;
36991:     JSProperty *prop;
48622:     if (!js_HasOwnProperty(cx, obj->getOps()->lookupProperty, obj, id, &pobj, &prop))
40356:         return false;
36991:     if (!prop) {
48470:         vp->setUndefined();
40356:         return true;
32721:     }
32721: 
48470:     Value roots[] = { UndefinedValue(), UndefinedValue(), UndefinedValue() };
40221:     AutoArrayRooter tvr(cx, JS_ARRAY_LENGTH(roots), roots);
43290:     unsigned attrs;
43290:     bool doGet = true;
43290:     if (pobj->isNative()) {
52503:         Shape *shape = (Shape *) prop;
52503:         attrs = shape->attributes();
35098:         if (attrs & (JSPROP_GETTER | JSPROP_SETTER)) {
43290:             doGet = false;
35098:             if (attrs & JSPROP_GETTER)
52503:                 roots[0] = shape->getterValue();
35098:             if (attrs & JSPROP_SETTER)
52503:                 roots[1] = shape->setterValue();
35098:         }
54713:     } else {
54713:         if (!pobj->getAttributes(cx, id, &attrs))
40356:             return false;
35098:     }
35098: 
43290:     if (doGet && !obj->getProperty(cx, id, &roots[2]))
43290:         return false;
43290: 
42733:     return js_NewPropertyDescriptorObject(cx, id,
42733:                                           attrs,
42733:                                           roots[0], /* getter */
42733:                                           roots[1], /* setter */
42733:                                           roots[2], /* value */
42733:                                           vp);
32721: }
32721: 
47569: static bool
48470: GetFirstArgumentAsObject(JSContext *cx, uintN argc, Value *vp, const char *method, JSObject **objp)
47569: {
47569:     if (argc == 0) {
47569:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_MORE_ARGS_NEEDED,
47569:                              method, "0", "s");
47569:         return false;
47569:     }
47569: 
48470:     const Value &v = vp[2];
54564:     if (!v.isObject()) {
48470:         char *bytes = DecompileValueGenerator(cx, JSDVG_SEARCH_STACK, v, NULL);
47569:         if (!bytes)
47569:             return false;
47569:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_UNEXPECTED_TYPE,
47569:                              bytes, "not an object");
47569:         JS_free(cx, bytes);
47569:         return false;
47569:     }
47569: 
48470:     *objp = &v.toObject();
47569:     return true;
47569: }
47569: 
33155: static JSBool
48470: obj_getOwnPropertyDescriptor(JSContext *cx, uintN argc, Value *vp)
40356: {
47569:     JSObject *obj;
47569:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.getOwnPropertyDescriptor", &obj))
47569:         return JS_FALSE;
40388:     AutoIdRooter nameidr(cx);
48470:     if (!ValueToId(cx, argc >= 2 ? vp[3] : UndefinedValue(), nameidr.addr()))
40356:         return JS_FALSE;
40356:     return js_GetOwnPropertyDescriptor(cx, obj, nameidr.id(), vp);
40356: }
40356: 
40356: static JSBool
48470: obj_keys(JSContext *cx, uintN argc, Value *vp)
33155: {
47569:     JSObject *obj;
47569:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.keys", &obj))
57759:         return false;
42733: 
48470:     AutoIdVector props(cx);
54562:     if (!GetPropertyNames(cx, obj, JSITER_OWNONLY, &props))
57759:         return false;
33155: 
48470:     AutoValueVector vals(cx);
57759:     if (!vals.reserve(props.length()))
57759:         return false;
48463:     for (size_t i = 0, len = props.length(); i < len; i++) {
48470:         jsid id = props[i];
48470:         if (JSID_IS_STRING(id)) {
57759:             JS_ALWAYS_TRUE(vals.append(StringValue(JSID_TO_STRING(id))));
57759:         } else if (JSID_IS_INT(id)) {
48470:             JSString *str = js_IntToString(cx, JSID_TO_INT(id));
48470:             if (!str)
57759:                 return false;
57759:             JS_ALWAYS_TRUE(vals.append(StringValue(str)));
57759:         } else {
57759:             JS_ASSERT(JSID_IS_OBJECT(id));
48470:         }
48463:     }
48463: 
48463:     JS_ASSERT(props.length() <= UINT32_MAX);
59234:     JSObject *aobj = NewDenseCopiedArray(cx, jsuint(vals.length()), vals.begin());
33155:     if (!aobj)
57759:         return false;
48470:     vp->setObject(*aobj);
33155: 
57759:     return true;
33155: }
33155: 
54713: static bool
54713: HasProperty(JSContext* cx, JSObject* obj, jsid id, Value* vp, bool *foundp)
54713: {
54713:     if (!obj->hasProperty(cx, id, foundp, JSRESOLVE_QUALIFIED | JSRESOLVE_DETECTING))
54713:         return false;
54713:     if (!*foundp) {
48470:         vp->setUndefined();
54713:         return true;
54713:     }
54713: 
54713:     /*
54713:      * We must go through the method read barrier in case id is 'get' or 'set'.
54713:      * There is no obvious way to defer cloning a joined function object whose
54713:      * identity will be used by DefinePropertyOnObject, e.g., or reflected via
54713:      * js_GetOwnPropertyDescriptor, as the getter or setter callable object.
54713:      */
54713:     return !!obj->getProperty(cx, id, vp);
48470: }
48470: 
48470: PropDesc::PropDesc()
48470:   : pd(UndefinedValue()),
48470:     id(INT_TO_JSID(0)),
48470:     value(UndefinedValue()),
48470:     get(UndefinedValue()),
48470:     set(UndefinedValue()),
36991:     attrs(0),
36991:     hasGet(false),
36991:     hasSet(false),
36991:     hasValue(false),
36991:     hasWritable(false),
36991:     hasEnumerable(false),
36991:     hasConfigurable(false)
36991: {
36991: }
36991: 
36991: bool
48470: PropDesc::initialize(JSContext* cx, jsid id, const Value &origval)
48470: {
48470:     Value v = origval;
36991:     this->id = id;
36991: 
36991:     /* 8.10.5 step 1 */
48470:     if (v.isPrimitive()) {
37010:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_NONNULL_OBJECT);
36991:         return false;
36991:     }
48470:     JSObject* desc = &v.toObject();
36991: 
42733:     /* Make a copy of the descriptor. We might need it later. */
42733:     pd = v;
42733: 
36991:     /* Start with the proper defaults. */
36991:     attrs = JSPROP_PERMANENT | JSPROP_READONLY;
36991: 
54713:     bool found;
36991: 
36991:     /* 8.10.5 step 3 */
60142: #ifdef __GNUC__ /* quell GCC overwarning */
60142:     found = false;
60142: #endif
54713:     if (!HasProperty(cx, desc, ATOM_TO_JSID(cx->runtime->atomState.enumerableAtom), &v, &found))
36991:         return false;
54713:     if (found) {
36991:         hasEnumerable = JS_TRUE;
36991:         if (js_ValueToBoolean(v))
36991:             attrs |= JSPROP_ENUMERATE;
36991:     }
36991: 
36991:     /* 8.10.5 step 4 */
54713:     if (!HasProperty(cx, desc, ATOM_TO_JSID(cx->runtime->atomState.configurableAtom), &v, &found))
36991:         return false;
54713:     if (found) {
36991:         hasConfigurable = JS_TRUE;
36991:         if (js_ValueToBoolean(v))
36991:             attrs &= ~JSPROP_PERMANENT;
36991:     }
36991: 
36991:     /* 8.10.5 step 5 */
54713:     if (!HasProperty(cx, desc, ATOM_TO_JSID(cx->runtime->atomState.valueAtom), &v, &found))
36991:         return false;
54713:     if (found) {
36991:         hasValue = true;
36991:         value = v;
36991:     }
36991: 
36991:     /* 8.10.6 step 6 */
54713:     if (!HasProperty(cx, desc, ATOM_TO_JSID(cx->runtime->atomState.writableAtom), &v, &found))
36991:         return false;
54713:     if (found) {
36991:         hasWritable = JS_TRUE;
36991:         if (js_ValueToBoolean(v))
36991:             attrs &= ~JSPROP_READONLY;
36991:     }
36991: 
36991:     /* 8.10.7 step 7 */
54713:     if (!HasProperty(cx, desc, ATOM_TO_JSID(cx->runtime->atomState.getAtom), &v, &found))
36991:         return false;
54713:     if (found) {
48470:         if ((v.isPrimitive() || !js_IsCallable(v)) && !v.isUndefined()) {
40831:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_GET_SET_FIELD,
36991:                                  js_getter_str);
36991:             return false;
36991:         }
36991:         hasGet = true;
36991:         get = v;
36991:         attrs |= JSPROP_GETTER | JSPROP_SHARED;
36991:     }
36991: 
36991:     /* 8.10.7 step 8 */
54713:     if (!HasProperty(cx, desc, ATOM_TO_JSID(cx->runtime->atomState.setAtom), &v, &found))
36991:         return false;
54713:     if (found) {
48470:         if ((v.isPrimitive() || !js_IsCallable(v)) && !v.isUndefined()) {
40831:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_GET_SET_FIELD,
36991:                                  js_setter_str);
36991:             return false;
36991:         }
36991:         hasSet = true;
36991:         set = v;
36991:         attrs |= JSPROP_SETTER | JSPROP_SHARED;
36991:     }
36991: 
36991:     /* 8.10.7 step 9 */
36991:     if ((hasGet || hasSet) && (hasValue || hasWritable)) {
36991:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INVALID_DESCRIPTOR);
36991:         return false;
36991:     }
36991: 
36991:     return true;
36991: }
36991: 
36991: static JSBool
36991: Reject(JSContext *cx, uintN errorNumber, bool throwError, jsid id, bool *rval)
36991: {
36991:     if (throwError) {
36991:         jsid idstr;
48470:         if (!js_ValueToStringId(cx, IdToValue(id), &idstr))
36991:            return JS_FALSE;
57812:         JSAutoByteString bytes(cx, JSID_TO_STRING(idstr));
57812:         if (!bytes)
57812:             return JS_FALSE;
57812:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, errorNumber, bytes.ptr());
36991:         return JS_FALSE;
36991:     }
36991: 
36991:     *rval = false;
36991:     return JS_TRUE;
36991: }
36991: 
36991: static JSBool
54587: Reject(JSContext *cx, JSObject *obj, uintN errorNumber, bool throwError, bool *rval)
36991: {
36991:     if (throwError) {
54587:         if (js_ErrorFormatString[errorNumber].argCount == 1) {
54587:             js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,
54587:                                      JSDVG_IGNORE_STACK, ObjectValue(*obj),
54587:                                      NULL, NULL, NULL);
54587:         } else {
54587:             JS_ASSERT(js_ErrorFormatString[errorNumber].argCount == 0);
36991:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, errorNumber);
54587:         }
36991:         return JS_FALSE;
36991:     }
36991: 
36991:     *rval = false;
36991:     return JS_TRUE;
36991: }
36991: 
36991: static JSBool
48470: DefinePropertyOnObject(JSContext *cx, JSObject *obj, const PropDesc &desc,
36991:                        bool throwError, bool *rval)
36991: {
36991:     /* 8.12.9 step 1. */
36991:     JSProperty *current;
36991:     JSObject *obj2;
48622:     JS_ASSERT(!obj->getOps()->lookupProperty);
48622:     if (!js_HasOwnProperty(cx, NULL, obj, desc.id, &obj2, &current))
36991:         return JS_FALSE;
36991: 
48622:     JS_ASSERT(!obj->getOps()->defineProperty);
36991: 
59914:     /*
59914:      * If we find a shared permanent property in a different object obj2 from
59914:      * obj, then if the property is shared permanent (an old hack to optimize
59914:      * per-object properties into one prototype property), ignore that lookup
59914:      * result (null current).
59914:      *
59914:      * FIXME: bug 575997 (see also bug 607863).
59914:      */
59914:     if (current && obj2 != obj && obj2->isNative()) {
59914:         /* See same assertion with comment further below. */
59914:         JS_ASSERT(obj2->getClass() == obj->getClass());
59914: 
59914:         Shape *shape = (Shape *) current;
59914:         if (shape->isSharedPermanent())
59914:             current = NULL;
59914:     }
59914: 
36991:     /* 8.12.9 steps 2-4. */
36991:     if (!current) {
54563:         if (!obj->isExtensible())
54587:             return Reject(cx, obj, JSMSG_OBJECT_NOT_EXTENSIBLE, throwError, rval);
36991: 
36991:         *rval = true;
36991: 
36991:         if (desc.isGenericDescriptor() || desc.isDataDescriptor()) {
48622:             JS_ASSERT(!obj->getOps()->defineProperty);
48470:             return js_DefineProperty(cx, obj, desc.id, &desc.value,
62395:                                      PropertyStub, StrictPropertyStub, desc.attrs);
36991:         }
36991: 
36991:         JS_ASSERT(desc.isAccessorDescriptor());
36991: 
50518:         /*
50518:          * Getters and setters are just like watchpoints from an access
50518:          * control point of view.
50518:          */
48470:         Value dummy;
36991:         uintN dummyAttrs;
50518:         if (!CheckAccess(cx, obj, desc.id, JSACC_WATCH, &dummy, &dummyAttrs))
36991:             return JS_FALSE;
36991: 
48470:         Value tmp = UndefinedValue();
48470:         return js_DefineProperty(cx, obj, desc.id, &tmp,
41860:                                  desc.getter(), desc.setter(), desc.attrs);
36991:     }
36991: 
36991:     /* 8.12.9 steps 5-6 (note 5 is merely a special case of 6). */
48470:     Value v = UndefinedValue();
36991: 
36991:     /*
36991:      * In the special case of shared permanent properties, the "own" property
36991:      * can be found on a different object.  In that case the returned property
36991:      * might not be native, except: the shared permanent property optimization
36991:      * is not applied if the objects have different classes (bug 320854), as
52503:      * must be enforced by js_HasOwnProperty for the Shape cast below to be
52503:      * safe.
36991:      */
36991:     JS_ASSERT(obj->getClass() == obj2->getClass());
36991: 
52503:     const Shape *shape = reinterpret_cast<Shape *>(current);
36991:     do {
36991:         if (desc.isAccessorDescriptor()) {
52503:             if (!shape->isAccessorDescriptor())
36991:                 break;
36991: 
59890:             if (desc.hasGet) {
59890:                 JSBool same;
59890:                 if (!SameValue(cx, desc.getterValue(), shape->getterOrUndefined(), &same))
59890:                     return JS_FALSE;
59890:                 if (!same)
36991:                     break;
36991:             }
36991: 
59890:             if (desc.hasSet) {
59890:                 JSBool same;
59890:                 if (!SameValue(cx, desc.setterValue(), shape->setterOrUndefined(), &same))
59890:                     return JS_FALSE;
59890:                 if (!same)
36991:                     break;
36991:             }
36991:         } else {
36991:             /*
36991:              * Determine the current value of the property once, if the current
36991:              * value might actually need to be used or preserved later.  NB: we
36991:              * guard on whether the current property is a data descriptor to
36991:              * avoid calling a getter; we won't need the value if it's not a
36991:              * data descriptor.
36991:              */
52503:             if (shape->isDataDescriptor()) {
36991:                 /*
61685:                  * We must rule out a non-configurable js::PropertyOp-guarded
61685:                  * property becoming a writable unguarded data property, since
61685:                  * such a property can have its value changed to one the getter
61685:                  * and setter preclude.
36991:                  *
61685:                  * A desc lacking writable but with value is a data descriptor
61685:                  * and we must reject it as if it had writable: true if current
61685:                  * is writable.
36991:                  */
52503:                 if (!shape->configurable() &&
61685:                     (!shape->hasDefaultGetter() || !shape->hasDefaultSetter()) &&
61685:                     desc.isDataDescriptor() &&
61685:                     (desc.hasWritable ? desc.writable() : shape->writable()))
61685:                 {
56567:                     return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, desc.id, rval);
36991:                 }
36991: 
61685:                 if (!js_NativeGet(cx, obj, obj2, shape, JSGET_NO_METHOD_BARRIER, &v))
36991:                     return JS_FALSE;
36991:             }
36991: 
36991:             if (desc.isDataDescriptor()) {
52503:                 if (!shape->isDataDescriptor())
36991:                     break;
36991: 
59890:                 JSBool same;
59890:                 if (desc.hasValue) {
59890:                     if (!SameValue(cx, desc.value, v, &same))
59890:                         return JS_FALSE;
61689:                     if (!same) {
61689:                         /*
61689:                          * Insist that a non-configurable js::PropertyOp data
61689:                          * property is frozen at exactly the last-got value.
61689:                          *
61689:                          * Duplicate the first part of the big conjunction that
61689:                          * we tested above, rather than add a local bool flag.
61689:                          * Likewise, don't try to keep shape->writable() in a
61689:                          * flag we veto from true to false for non-configurable
61689:                          * PropertyOp-based data properties and test before the
61689:                          * SameValue check later on in order to re-use that "if
61689:                          * (!SameValue) Reject" logic.
61689:                          *
61689:                          * This function is large and complex enough that it
61689:                          * seems best to repeat a small bit of code and return
61689:                          * Reject(...) ASAP, instead of being clever.
61689:                          */
61689:                         if (!shape->configurable() &&
61689:                             (!shape->hasDefaultGetter() || !shape->hasDefaultSetter()))
61689:                         {
61689:                             return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, desc.id, rval);
61689:                         }
36991:                         break;
59890:                     }
61689:                 }
52503:                 if (desc.hasWritable && desc.writable() != shape->writable())
36991:                     break;
36991:             } else {
36991:                 /* The only fields in desc will be handled below. */
36991:                 JS_ASSERT(desc.isGenericDescriptor());
36991:             }
36991:         }
36991: 
52503:         if (desc.hasConfigurable && desc.configurable() != shape->configurable())
36991:             break;
52503:         if (desc.hasEnumerable && desc.enumerable() != shape->enumerable())
36991:             break;
36991: 
36991:         /* The conditions imposed by step 5 or step 6 apply. */
36991:         *rval = true;
36991:         return JS_TRUE;
36991:     } while (0);
36991: 
36991:     /* 8.12.9 step 7. */
52503:     if (!shape->configurable()) {
36991:         /*
36991:          * Since [[Configurable]] defaults to false, we don't need to check
36991:          * whether it was specified.  We can't do likewise for [[Enumerable]]
36991:          * because its putative value is used in a comparison -- a comparison
36991:          * whose result must always be false per spec if the [[Enumerable]]
36991:          * field is not present.  Perfectly pellucid logic, eh?
36991:          */
36991:         JS_ASSERT_IF(!desc.hasConfigurable, !desc.configurable());
36991:         if (desc.configurable() ||
52503:             (desc.hasEnumerable && desc.enumerable() != shape->enumerable())) {
56567:             return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, desc.id, rval);
36991:         }
36991:     }
36991: 
55492:     bool callDelProperty = false;
55492: 
36991:     if (desc.isGenericDescriptor()) {
36991:         /* 8.12.9 step 8, no validation required */
52503:     } else if (desc.isDataDescriptor() != shape->isDataDescriptor()) {
36991:         /* 8.12.9 step 9. */
54587:         if (!shape->configurable())
56567:             return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, desc.id, rval);
41860:     } else if (desc.isDataDescriptor()) {
36991:         /* 8.12.9 step 10. */
52503:         JS_ASSERT(shape->isDataDescriptor());
52503:         if (!shape->configurable() && !shape->writable()) {
59890:             if (desc.hasWritable && desc.writable())
59890:                 return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, desc.id, rval);
59890:             if (desc.hasValue) {
59890:                 JSBool same;
59890:                 if (!SameValue(cx, desc.value, v, &same))
59890:                     return JS_FALSE;
59890:                 if (!same)
56567:                     return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, desc.id, rval);
36991:             }
36991:         }
55492: 
55492:         callDelProperty = !shape->hasDefaultGetter() || !shape->hasDefaultSetter();
36991:     } else {
36991:         /* 8.12.9 step 11. */
52503:         JS_ASSERT(desc.isAccessorDescriptor() && shape->isAccessorDescriptor());
52503:         if (!shape->configurable()) {
59890:             if (desc.hasSet) {
59890:                 JSBool same;
59890:                 if (!SameValue(cx, desc.setterValue(), shape->setterOrUndefined(), &same))
59890:                     return JS_FALSE;
59890:                 if (!same)
59890:                     return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, desc.id, rval);
59890:             }
59890: 
59890:             if (desc.hasGet) {
59890:                 JSBool same;
59890:                 if (!SameValue(cx, desc.getterValue(), shape->getterOrUndefined(), &same))
59890:                     return JS_FALSE;
59890:                 if (!same)
56567:                     return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, desc.id, rval);
36991:             }
36991:         }
36991:     }
36991: 
36991:     /* 8.12.9 step 12. */
36991:     uintN attrs;
62395:     PropertyOp getter;
62395:     StrictPropertyOp setter;
36991:     if (desc.isGenericDescriptor()) {
36991:         uintN changed = 0;
36991:         if (desc.hasConfigurable)
36991:             changed |= JSPROP_PERMANENT;
36991:         if (desc.hasEnumerable)
36991:             changed |= JSPROP_ENUMERATE;
36991: 
52503:         attrs = (shape->attributes() & ~changed) | (desc.attrs & changed);
52503:         if (shape->isMethod()) {
42784:             JS_ASSERT(!(attrs & (JSPROP_GETTER | JSPROP_SETTER)));
62395:             getter = PropertyStub;
62395:             setter = StrictPropertyStub;
42784:         } else {
52503:             getter = shape->getter();
52503:             setter = shape->setter();
42784:         }
36991:     } else if (desc.isDataDescriptor()) {
36991:         uintN unchanged = 0;
36991:         if (!desc.hasConfigurable)
36991:             unchanged |= JSPROP_PERMANENT;
36991:         if (!desc.hasEnumerable)
36991:             unchanged |= JSPROP_ENUMERATE;
36991:         if (!desc.hasWritable)
36991:             unchanged |= JSPROP_READONLY;
36991: 
36991:         if (desc.hasValue)
36991:             v = desc.value;
52503:         attrs = (desc.attrs & ~unchanged) | (shape->attributes() & unchanged);
62395:         getter = PropertyStub;
62395:         setter = StrictPropertyStub;
36991:     } else {
36991:         JS_ASSERT(desc.isAccessorDescriptor());
36991: 
50518:         /*
50518:          * Getters and setters are just like watchpoints from an access
50518:          * control point of view.
50518:          */
48470:         Value dummy;
56567:         if (!CheckAccess(cx, obj2, desc.id, JSACC_WATCH, &dummy, &attrs))
36991:              return JS_FALSE;
36991: 
52503:         JS_ASSERT_IF(shape->isMethod(), !(attrs & (JSPROP_GETTER | JSPROP_SETTER)));
48498: 
36991:         /* 8.12.9 step 12. */
36991:         uintN changed = 0;
36991:         if (desc.hasConfigurable)
36991:             changed |= JSPROP_PERMANENT;
36991:         if (desc.hasEnumerable)
36991:             changed |= JSPROP_ENUMERATE;
36991:         if (desc.hasGet)
36991:             changed |= JSPROP_GETTER | JSPROP_SHARED;
36991:         if (desc.hasSet)
36991:             changed |= JSPROP_SETTER | JSPROP_SHARED;
36991: 
52503:         attrs = (desc.attrs & changed) | (shape->attributes() & ~changed);
41860:         if (desc.hasGet) {
41860:             getter = desc.getter();
41860:         } else {
52503:             getter = (shape->isMethod() || (shape->hasDefaultGetter() && !shape->hasGetterValue()))
48470:                      ? PropertyStub
52503:                      : shape->getter();
41860:         }
41860:         if (desc.hasSet) {
41860:             setter = desc.setter();
41860:         } else {
52503:             setter = (shape->hasDefaultSetter() && !shape->hasSetterValue())
62395:                      ? StrictPropertyStub
52503:                      : shape->setter();
41860:         }
36991:     }
36991: 
36991:     *rval = true;
55492: 
55492:     /*
55492:      * Since "data" properties implemented using native C functions may rely on
55492:      * side effects during setting, we must make them aware that they have been
55492:      * "assigned"; deleting the property before redefining it does the trick.
55492:      * See bug 539766, where we ran into problems when we redefined
55492:      * arguments.length without making the property aware that its value had
55492:      * been changed (which would have happened if we had deleted it before
55492:      * redefining it or we had invoked its setter to change its value).
55492:      */
55492:     if (callDelProperty) {
61707:         Value dummy = UndefinedValue();
55492:         if (!CallJSPropertyOp(cx, obj2->getClass()->delProperty, obj2, desc.id, &dummy))
55492:             return false;
55492:     }
55492: 
48470:     return js_DefineProperty(cx, obj, desc.id, &v, getter, setter, attrs);
36991: }
36991: 
36991: static JSBool
48470: DefinePropertyOnArray(JSContext *cx, JSObject *obj, const PropDesc &desc,
36991:                       bool throwError, bool *rval)
36991: {
36991:     /*
36991:      * We probably should optimize dense array property definitions where
36991:      * the descriptor describes a traditional array property (enumerable,
36991:      * configurable, writable, numeric index or length without altering its
36991:      * attributes).  Such definitions are probably unlikely, so we don't bother
36991:      * for now.
36991:      */
43287:     if (obj->isDenseArray() && !obj->makeDenseArraySlow(cx))
36991:         return JS_FALSE;
36991: 
40796:     jsuint oldLen = obj->getArrayLength();
36991: 
48470:     if (JSID_IS_ATOM(desc.id, cx->runtime->atomState.lengthAtom)) {
36991:         /*
36991:          * Our optimization of storage of the length property of arrays makes
36991:          * it very difficult to properly implement defining the property.  For
36991:          * now simply throw an exception (NB: not merely Reject) on any attempt
36991:          * to define the "length" property, rather than attempting to implement
36991:          * some difficult-for-authors-to-grasp subset of that functionality.
36991:          */
54587:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_DEFINE_ARRAY_LENGTH);
36991:         return JS_FALSE;
36991:     }
36991: 
36991:     uint32 index;
36991:     if (js_IdIsIndex(desc.id, &index)) {
36991:         /*
36991:         // Disabled until we support defining "length":
36991:         if (index >= oldLen && lengthPropertyNotWritable())
54587:             return ThrowTypeError(cx, JSMSG_CANT_APPEND_TO_ARRAY);
36991:          */
41860:         if (!DefinePropertyOnObject(cx, obj, desc, false, rval))
36991:             return JS_FALSE;
36991:         if (!*rval)
54587:             return Reject(cx, obj, JSMSG_CANT_DEFINE_ARRAY_INDEX, throwError, rval);
36991: 
36991:         if (index >= oldLen) {
36991:             JS_ASSERT(index != UINT32_MAX);
48537:             obj->setArrayLength(index + 1);
36991:         }
36991: 
36991:         *rval = true;
36991:         return JS_TRUE;
36991:     }
36991: 
41860:     return DefinePropertyOnObject(cx, obj, desc, throwError, rval);
36991: }
36991: 
36991: static JSBool
48470: DefineProperty(JSContext *cx, JSObject *obj, const PropDesc &desc, bool throwError,
36991:                bool *rval)
36991: {
39928:     if (obj->isArray())
41860:         return DefinePropertyOnArray(cx, obj, desc, throwError, rval);
36991: 
48622:     if (obj->getOps()->lookupProperty) {
42733:         if (obj->isProxy())
42733:             return JSProxy::defineProperty(cx, obj, desc.id, desc.pd);
54587:         return Reject(cx, obj, JSMSG_OBJECT_NOT_EXTENSIBLE, throwError, rval);
42733:     }
36991: 
41860:     return DefinePropertyOnObject(cx, obj, desc, throwError, rval);
36991: }
36991: 
40356: JSBool
48470: js_DefineOwnProperty(JSContext *cx, JSObject *obj, jsid id,
48470:                      const Value &descriptor, JSBool *bp)
48470: {
48470:     AutoPropDescArrayRooter descs(cx);
48470:     PropDesc *desc = descs.append();
40356:     if (!desc || !desc->initialize(cx, id, descriptor))
40356:         return false;
40356: 
40356:     bool rval;
40356:     if (!DefineProperty(cx, obj, *desc, true, &rval))
40356:         return false;
40356:     *bp = !!rval;
40356:     return true;
40356: }
40356: 
36991: /* ES5 15.2.3.6: Object.defineProperty(O, P, Attributes) */
36991: static JSBool
48470: obj_defineProperty(JSContext* cx, uintN argc, Value* vp)
36991: {
36991:     /* 15.2.3.6 steps 1 and 5. */
47569:     JSObject *obj;
47569:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.defineProperty", &obj))
36991:         return JS_FALSE;
48470:     vp->setObject(*obj);
36991: 
36991:     /* 15.2.3.6 step 2. */
40221:     AutoIdRooter nameidr(cx);
48470:     if (!ValueToId(cx, argc >= 2 ? vp[3] : UndefinedValue(), nameidr.addr()))
36991:         return JS_FALSE;
36991: 
36991:     /* 15.2.3.6 step 3. */
48470:     const Value &descval = argc >= 3 ? vp[4] : UndefinedValue();
36991: 
36991:     /* 15.2.3.6 step 4 */
40356:     JSBool junk;
40356:     return js_DefineOwnProperty(cx, obj, nameidr.id(), descval, &junk);
36991: }
36991: 
42733: static bool
42733: DefineProperties(JSContext *cx, JSObject *obj, JSObject *props)
42733: {
40388:     AutoIdArray ida(cx, JS_Enumerate(cx, props));
36991:     if (!ida)
42733:         return false;
36991: 
48470:      AutoPropDescArrayRooter descs(cx);
36991:      size_t len = ida.length();
36991:      for (size_t i = 0; i < len; i++) {
36991:          jsid id = ida[i];
48470:          PropDesc* desc = descs.append();
42733:          AutoValueRooter tvr(cx);
42733:          if (!desc ||
48470:              !JS_GetPropertyById(cx, props, id, tvr.jsval_addr()) ||
42733:              !desc->initialize(cx, id, tvr.value())) {
42733:              return false;
42733:          }
42733:      }
42733: 
36991:      bool dummy;
36991:      for (size_t i = 0; i < len; i++) {
36991:          if (!DefineProperty(cx, obj, descs[i], true, &dummy))
42733:              return false;
42733:      }
42733: 
42733:      return true;
42733: }
42733: 
42733: extern JSBool
42733: js_PopulateObject(JSContext *cx, JSObject *newborn, JSObject *props)
42733: {
42733:     return DefineProperties(cx, newborn, props);
42733: }
42733: 
42733: /* ES5 15.2.3.7: Object.defineProperties(O, Properties) */
42733: static JSBool
48470: obj_defineProperties(JSContext* cx, uintN argc, Value* vp)
42733: {
42733:     /* 15.2.3.6 steps 1 and 5. */
47569:     JSObject *obj;
47569:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.defineProperties", &obj))
47569:         return false;
48470:     vp->setObject(*obj);
47569: 
42733:     if (argc < 2) {
42733:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_MORE_ARGS_NEEDED,
42733:                              "Object.defineProperties", "0", "s");
42733:         return false;
42733:     }
42733: 
42733:     JSObject* props = js_ValueToNonNullObject(cx, vp[3]);
42733:     if (!props)
42733:         return false;
48470:     vp[3].setObject(*props);
42733: 
42733:     return DefineProperties(cx, obj, props);
36991: }
36991: 
37000: /* ES5 15.2.3.5: Object.create(O [, Properties]) */
37000: static JSBool
48470: obj_create(JSContext *cx, uintN argc, Value *vp)
37000: {
37000:     if (argc == 0) {
37000:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_MORE_ARGS_NEEDED,
37000:                              "Object.create", "0", "s");
37000:         return JS_FALSE;
37000:     }
37000: 
48470:     const Value &v = vp[2];
48470:     if (!v.isObjectOrNull()) {
48470:         char *bytes = DecompileValueGenerator(cx, JSDVG_SEARCH_STACK, v, NULL);
37000:         if (!bytes)
37000:             return JS_FALSE;
37000:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_UNEXPECTED_TYPE,
37000:                              bytes, "not an object or null");
37000:         JS_free(cx, bytes);
37000:         return JS_FALSE;
37000:     }
37000: 
37000:     /*
47497:      * Use the callee's global as the parent of the new object to avoid dynamic
47497:      * scoping (i.e., using the caller's global).
37000:      */
50450:     JSObject *obj = NewNonFunction<WithProto::Given>(cx, &js_ObjectClass, v.toObjectOrNull(),
48470:                                                         vp->toObject().getGlobal());
37000:     if (!obj)
37000:         return JS_FALSE;
48470:     vp->setObject(*obj); /* Root and prepare for eventual return. */
37000: 
37000:     /* 15.2.3.5 step 4. */
48470:     if (argc > 1 && !vp[3].isUndefined()) {
48470:         if (vp[3].isPrimitive()) {
37010:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_NONNULL_OBJECT);
37000:             return JS_FALSE;
37000:         }
37000: 
48470:         JSObject *props = &vp[3].toObject();
40388:         AutoIdArray ida(cx, JS_Enumerate(cx, props));
37000:         if (!ida)
37000:             return JS_FALSE;
37000: 
48470:         AutoPropDescArrayRooter descs(cx);
37000:         size_t len = ida.length();
37000:         for (size_t i = 0; i < len; i++) {
37000:             jsid id = ida[i];
48470:             PropDesc *desc = descs.append();
48470:             if (!desc || !JS_GetPropertyById(cx, props, id, Jsvalify(&vp[1])) ||
37001:                 !desc->initialize(cx, id, vp[1])) {
37000:                 return JS_FALSE;
37000:             }
37000:         }
37000: 
37000:         bool dummy;
37000:         for (size_t i = 0; i < len; i++) {
37000:             if (!DefineProperty(cx, obj, descs[i], true, &dummy))
37000:                 return JS_FALSE;
37000:         }
37000:     }
37000: 
37000:     /* 5. Return obj. */
37000:     return JS_TRUE;
37000: }
37000: 
47569: static JSBool
48470: obj_getOwnPropertyNames(JSContext *cx, uintN argc, Value *vp)
47569: {
47569:     JSObject *obj;
47569:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.getOwnPropertyNames", &obj))
47569:         return false;
47569: 
48470:     AutoIdVector keys(cx);
54562:     if (!GetPropertyNames(cx, obj, JSITER_OWNONLY | JSITER_HIDDEN, &keys))
47569:         return false;
47569: 
48470:     AutoValueVector vals(cx);
48470:     if (!vals.resize(keys.length()))
48470:         return false;
48470: 
48470:     for (size_t i = 0, len = keys.length(); i < len; i++) {
48470:          jsid id = keys[i];
48470:          if (JSID_IS_INT(id)) {
48470:              JSString *str = js_ValueToString(cx, Int32Value(JSID_TO_INT(id)));
47569:              if (!str)
47569:                  return false;
48470:              vals[i].setString(str);
48470:          } else if (JSID_IS_ATOM(id)) {
48470:              vals[i].setString(JSID_TO_STRING(id));
48470:          } else {
48470:              vals[i].setObject(*JSID_TO_OBJECT(id));
48470:          }
48470:     }
48470: 
59234:     JSObject *aobj = NewDenseCopiedArray(cx, vals.length(), vals.begin());
47569:     if (!aobj)
47569:         return false;
47569: 
48470:     vp->setObject(*aobj);
47569:     return true;
47569: }
47569: 
54563: static JSBool
54563: obj_isExtensible(JSContext *cx, uintN argc, Value *vp)
54563: {
54563:     JSObject *obj;
54563:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.isExtensible", &obj))
54563:         return false;
54563: 
54563:     vp->setBoolean(obj->isExtensible());
54563:     return true;
54563: }
54563: 
54563: static JSBool
54563: obj_preventExtensions(JSContext *cx, uintN argc, Value *vp)
54563: {
54563:     JSObject *obj;
54563:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.preventExtensions", &obj))
54563:         return false;
54563: 
54563:     vp->setObject(*obj);
57813:     if (!obj->isExtensible())
57813:         return true;
54563: 
54563:     AutoIdVector props(cx);
54563:     return obj->preventExtensions(cx, &props);
54563: }
54563: 
54563: bool
57813: JSObject::sealOrFreeze(JSContext *cx, ImmutabilityType it)
54563: {
54563:     assertSameCompartment(cx, this);
57813:     JS_ASSERT(it == SEAL || it == FREEZE);
54563: 
54563:     AutoIdVector props(cx);
54563:     if (isExtensible()) {
54563:         if (!preventExtensions(cx, &props))
54563:             return false;
54563:     } else {
54563:         if (!GetPropertyNames(cx, this, JSITER_HIDDEN | JSITER_OWNONLY, &props))
54563:             return false;
54563:     }
54563: 
54563:     /* preventExtensions must slowify dense arrays, so we can assign to holes without checks. */
54563:     JS_ASSERT(!isDenseArray());
54563: 
54563:     for (size_t i = 0, len = props.length(); i < len; i++) {
54563:         jsid id = props[i];
54563: 
54563:         uintN attrs;
54563:         if (!getAttributes(cx, id, &attrs))
54563:             return false;
54563: 
54563:         /* Make all attributes permanent; if freezing, make data attributes read-only. */
54563:         uintN new_attrs;
57813:         if (it == FREEZE && !(attrs & (JSPROP_GETTER | JSPROP_SETTER)))
54563:             new_attrs = JSPROP_PERMANENT | JSPROP_READONLY;
54563:         else
54563:             new_attrs = JSPROP_PERMANENT;
54563: 
54563:         /* If we already have the attributes we need, skip the setAttributes call. */
54563:         if ((attrs | new_attrs) == attrs)
54563:             continue;
54563: 
54563:         attrs |= new_attrs;
54563:         if (!setAttributes(cx, id, &attrs))
54563:             return false;
54563:     }
54563: 
54563:     return true;
54563: }
32721: 
54564: static JSBool
54564: obj_freeze(JSContext *cx, uintN argc, Value *vp)
54564: {
54564:     JSObject *obj;
54564:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.freeze", &obj))
54564:         return false;
54564: 
54564:     vp->setObject(*obj);
54564: 
54564:     return obj->freeze(cx);
54564: }
54564: 
54564: static JSBool
54564: obj_isFrozen(JSContext *cx, uintN argc, Value *vp)
54564: {
54564:     JSObject *obj;
54564:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.preventExtensions", &obj))
54564:         return false;
54564: 
54564:     vp->setBoolean(false);
54564: 
54564:     if (obj->isExtensible())
54564:         return true; /* The JavaScript value returned is false. */
54564: 
54564:     AutoIdVector props(cx);
54564:     if (!GetPropertyNames(cx, obj, JSITER_HIDDEN | JSITER_OWNONLY, &props))
54564:         return false;
54564: 
54564:     for (size_t i = 0, len = props.length(); i < len; i++) {
54564:         jsid id = props[i];
54564: 
54564:         uintN attrs = 0;
54564:         if (!obj->getAttributes(cx, id, &attrs))
54564:             return false;
54564: 
54564:         /* The property must be non-configurable and either read-only or an accessor. */
54564:         if (!(attrs & JSPROP_PERMANENT) ||
54564:             !(attrs & (JSPROP_READONLY | JSPROP_GETTER | JSPROP_SETTER)))
54564:             return true; /* The JavaScript value returned is false. */
54564:     }
54564: 
54565:     /* It really was sealed, so return true. */
54565:     vp->setBoolean(true);
54565:     return true;
54565: }
54565: 
54565: static JSBool
54565: obj_seal(JSContext *cx, uintN argc, Value *vp)
54565: {
54565:     JSObject *obj;
54565:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.seal", &obj))
54565:         return false;
54565: 
54565:     vp->setObject(*obj);
54565: 
54565:     return obj->seal(cx);
54565: }
54565: 
54565: static JSBool
54565: obj_isSealed(JSContext *cx, uintN argc, Value *vp)
54565: {
54565:     JSObject *obj;
54565:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.isSealed", &obj))
54565:         return false;
54565: 
54565:     /* Assume not sealed until proven otherwise. */
54565:     vp->setBoolean(false);
54565: 
54565:     if (obj->isExtensible())
54565:         return true; /* The JavaScript value returned is false. */
54565: 
54565:     AutoIdVector props(cx);
54565:     if (!GetPropertyNames(cx, obj, JSITER_HIDDEN | JSITER_OWNONLY, &props))
54565:         return false;
54565: 
54565:     for (size_t i = 0, len = props.length(); i < len; i++) {
54565:         jsid id = props[i];
54565: 
54565:         uintN attrs;
54565:         if (!obj->getAttributes(cx, id, &attrs))
54565:             return false;
54565: 
54565:         if (!(attrs & JSPROP_PERMANENT))
54565:             return true; /* The JavaScript value returned is false. */
54565:     }
54565: 
54565:     /* It really was sealed, so return true. */
54564:     vp->setBoolean(true);
54564:     return true;
54564: }
54564: 
    1: #if JS_HAS_OBJ_WATCHPOINT
    1: const char js_watch_str[] = "watch";
    1: const char js_unwatch_str[] = "unwatch";
    1: #endif
    1: const char js_hasOwnProperty_str[] = "hasOwnProperty";
    1: const char js_isPrototypeOf_str[] = "isPrototypeOf";
    1: const char js_propertyIsEnumerable_str[] = "propertyIsEnumerable";
    1: 
    1: static JSFunctionSpec object_methods[] = {
    1: #if JS_HAS_TOSOURCE
16519:     JS_FN(js_toSource_str,             obj_toSource,                0,0),
    1: #endif
59941:     JS_FN(js_toString_str,             obj_toString,                0,0),
16519:     JS_FN(js_toLocaleString_str,       obj_toLocaleString,          0,0),
41856:     JS_FN(js_valueOf_str,              obj_valueOf,                 0,0),
    1: #if JS_HAS_OBJ_WATCHPOINT
16519:     JS_FN(js_watch_str,                obj_watch,                   2,0),
16519:     JS_FN(js_unwatch_str,              obj_unwatch,                 1,0),
    1: #endif
41856:     JS_FN(js_hasOwnProperty_str,       obj_hasOwnProperty,          1,0),
16519:     JS_FN(js_isPrototypeOf_str,        obj_isPrototypeOf,           1,0),
41856:     JS_FN(js_propertyIsEnumerable_str, obj_propertyIsEnumerable,    1,0),
40855: #if OLD_GETTER_SETTER_METHODS
24145:     JS_FN(js_defineGetter_str,         js_obj_defineGetter,         2,0),
24145:     JS_FN(js_defineSetter_str,         js_obj_defineSetter,         2,0),
16519:     JS_FN(js_lookupGetter_str,         obj_lookupGetter,            1,0),
16519:     JS_FN(js_lookupSetter_str,         obj_lookupSetter,            1,0),
    1: #endif
 4127:     JS_FS_END
    1: };
    1: 
16380: static JSFunctionSpec object_static_methods[] = {
16519:     JS_FN("getPrototypeOf",            obj_getPrototypeOf,          1,0),
32721:     JS_FN("getOwnPropertyDescriptor",  obj_getOwnPropertyDescriptor,2,0),
33155:     JS_FN("keys",                      obj_keys,                    1,0),
36991:     JS_FN("defineProperty",            obj_defineProperty,          3,0),
36991:     JS_FN("defineProperties",          obj_defineProperties,        2,0),
37000:     JS_FN("create",                    obj_create,                  2,0),
47569:     JS_FN("getOwnPropertyNames",       obj_getOwnPropertyNames,     1,0),
54563:     JS_FN("isExtensible",              obj_isExtensible,            1,0),
54563:     JS_FN("preventExtensions",         obj_preventExtensions,       1,0),
54564:     JS_FN("freeze",                    obj_freeze,                  1,0),
54564:     JS_FN("isFrozen",                  obj_isFrozen,                1,0),
54565:     JS_FN("seal",                      obj_seal,                    1,0),
54565:     JS_FN("isSealed",                  obj_isSealed,                1,0),
16380:     JS_FS_END
16380: };
16380: 
30439: JSBool
50489: js_Object(JSContext *cx, uintN argc, Value *vp)
50489: {
50489:     JSObject *obj;
30439:     if (argc == 0) {
30439:         /* Trigger logic below to construct a blank object. */
30439:         obj = NULL;
30439:     } else {
30439:         /* If argv[0] is null or undefined, obj comes back null. */
50489:         if (!js_ValueToObjectOrNull(cx, vp[2], &obj))
30439:             return JS_FALSE;
30439:     }
30439:     if (!obj) {
50489:         /* Make an object whether this was called with 'new' or not. */
50489:         JS_ASSERT(!argc || vp[2].isNull() || vp[2].isUndefined());
55746:         gc::FinalizeKind kind = NewObjectGCKind(cx, &js_ObjectClass);
55746:         obj = NewBuiltinClassInstance(cx, &js_ObjectClass, kind);
30439:         if (!obj)
30439:             return JS_FALSE;
30439:     }
50489:     vp->setObject(*obj);
30439:     return JS_TRUE;
30439: }
30439: 
53557: JSObject*
55503: js_CreateThis(JSContext *cx, JSObject *callee)
53557: {
53557:     Class *clasp = callee->getClass();
53557: 
53557:     Class *newclasp = &js_ObjectClass;
53557:     if (clasp == &js_FunctionClass) {
53557:         JSFunction *fun = callee->getFunctionPrivate();
53557:         if (fun->isNative() && fun->u.n.clasp)
53557:             newclasp = fun->u.n.clasp;
53557:     }
53557: 
53557:     Value protov;
53557:     if (!callee->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom), &protov))
53557:         return NULL;
53557: 
53557:     JSObject *proto = protov.isObjectOrNull() ? protov.toObjectOrNull() : NULL;
53557:     JSObject *parent = callee->getParent();
55746:     gc::FinalizeKind kind = NewObjectGCKind(cx, newclasp);
57806:     JSObject *obj = NewObject<WithProto::Class>(cx, newclasp, proto, parent, kind);
57806:     if (obj)
57806:         obj->syncSpecialEquality();
57806:     return obj;
53557: }
53557: 
55503: JSObject *
55503: js_CreateThisForFunctionWithProto(JSContext *cx, JSObject *callee, JSObject *proto)
55503: {
55746:     gc::FinalizeKind kind = NewObjectGCKind(cx, &js_ObjectClass);
55746:     return NewNonFunction<WithProto::Class>(cx, &js_ObjectClass, proto, callee->getParent(), kind);
55503: }
55503: 
55503: JSObject *
55503: js_CreateThisForFunction(JSContext *cx, JSObject *callee)
55503: {
55503:     Value protov;
55503:     if (!callee->getProperty(cx,
55503:                              ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom),
55503:                              &protov)) {
55503:         return NULL;
55503:     }
55503:     JSObject *proto = protov.isObject() ? &protov.toObject() : NULL;
55503:     return js_CreateThisForFunctionWithProto(cx, callee, proto);
55503: }
55503: 
32615: #ifdef JS_TRACER
32615: 
53638: static JS_ALWAYS_INLINE JSObject*
53638: NewObjectWithClassProto(JSContext *cx, Class *clasp, JSObject *proto,
55746:                         /*gc::FinalizeKind*/ unsigned _kind)
35117: {
48622:     JS_ASSERT(clasp->isNative());
55746:     gc::FinalizeKind kind = gc::FinalizeKind(_kind);
55746: 
55746:     JSObject* obj = js_NewGCObject(cx, kind);
35117:     if (!obj)
35117:         return NULL;
35117: 
55746:     if (!obj->initSharingEmptyShape(cx, clasp, proto, proto->getParent(), NULL, kind))
55746:         return NULL;
35117:     return obj;
35117: }
35117: 
35117: JSObject* FASTCALL
35117: js_Object_tn(JSContext* cx, JSObject* proto)
35117: {
35117:     JS_ASSERT(!(js_ObjectClass.flags & JSCLASS_HAS_PRIVATE));
55746:     return NewObjectWithClassProto(cx, &js_ObjectClass, proto, FINALIZE_OBJECT8);
35117: }
35117: 
35117: JS_DEFINE_TRCINFO_1(js_Object,
39910:     (2, (extern, CONSTRUCTOR_RETRY, js_Object_tn, CONTEXT, CALLEE_PROTOTYPE, 0,
48613:          nanojit::ACCSET_STORE_ANY)))
35117: 
37035: JSObject* FASTCALL
58056: js_InitializerObject(JSContext* cx, JSObject *proto, JSObject *baseobj)
58056: {
58056:     if (!baseobj) {
58056:         gc::FinalizeKind kind = GuessObjectGCKind(0, false);
58056:         return NewObjectWithClassProto(cx, &js_ObjectClass, proto, kind);
58056:     }
58056: 
58056:     return CopyInitializerObject(cx, baseobj);
58056: }
58056: 
58056: JS_DEFINE_CALLINFO_3(extern, OBJECT, js_InitializerObject, CONTEXT, OBJECT, OBJECT,
58056:                      0, nanojit::ACCSET_STORE_ANY)
37035: 
32615: JSObject* FASTCALL
53638: js_String_tn(JSContext* cx, JSObject* proto, JSString* str)
53638: {
53638:     JS_ASSERT(JS_ON_TRACE(cx));
55746:     JSObject *obj = NewObjectWithClassProto(cx, &js_StringClass, proto, FINALIZE_OBJECT2);
55746:     if (!obj)
55746:         return NULL;
55746:     obj->setPrimitiveThis(StringValue(str));
55746:     return obj;
53638: }
53638: JS_DEFINE_CALLINFO_3(extern, OBJECT, js_String_tn, CONTEXT, CALLEE_PROTOTYPE, STRING, 0,
53638:                      nanojit::ACCSET_STORE_ANY)
53638: 
53638: JSObject * FASTCALL
62590: js_CreateThisFromTrace(JSContext *cx, JSObject *ctor, uintN protoSlot)
62590: {
62590: #ifdef DEBUG
40430:     JS_ASSERT(ctor->isFunction());
62590:     JS_ASSERT(ctor->getFunctionPrivate()->isInterpreted());
62590:     jsid id = ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom);
62590:     const Shape *shape = ctor->nativeLookup(id);
62590:     JS_ASSERT(shape->slot == protoSlot);
62590:     JS_ASSERT(!shape->configurable());
62590:     JS_ASSERT(!shape->isMethod());
62590: #endif
32615: 
47497:     JSObject *parent = ctor->getParent();
32615:     JSObject *proto;
62590:     const Value &protov = ctor->getSlotRef(protoSlot);
62590:     if (protov.isObject()) {
62590:         proto = &protov.toObject();
47497:     } else {
62590:         /*
62590:          * GetInterpretedFunctionPrototype found that ctor.prototype is
62590:          * primitive. Use Object.prototype for proto, per ES5 13.2.2 step 7.
62590:          */
47497:         if (!js_GetClassPrototype(cx, parent, JSProto_Object, &proto))
47497:             return NULL;
62590:     }
62590: 
62590:     gc::FinalizeKind kind = NewObjectGCKind(cx, &js_ObjectClass);
62590:     return NewNativeClassInstance(cx, &js_ObjectClass, proto, parent, kind);
62590: }
62590: JS_DEFINE_CALLINFO_3(extern, CONSTRUCTOR_RETRY, js_CreateThisFromTrace, CONTEXT, OBJECT, UINTN, 0,
48613:                      nanojit::ACCSET_STORE_ANY)
32615: 
32615: #else  /* !JS_TRACER */
32615: 
32615: # define js_Object_trcinfo NULL
32615: 
32615: #endif /* !JS_TRACER */
32615: 
    1: /*
23435:  * Given pc pointing after a property accessing bytecode, return true if the
23435:  * access is "object-detecting" in the sense used by web scripts, e.g., when
23435:  * checking whether document.all is defined.
23435:  */
30034: JS_REQUIRES_STACK JSBool
23435: Detecting(JSContext *cx, jsbytecode *pc)
23435: {
23435:     JSScript *script;
25474:     jsbytecode *endpc;
23435:     JSOp op;
23435:     JSAtom *atom;
23435: 
53840:     script = cx->fp()->script();
25474:     endpc = script->code + script->length;
25215:     for (;; pc += js_CodeSpec[op].length) {
53840:         JS_ASSERT_IF(!cx->fp()->hasImacropc(), script->code <= pc && pc < endpc);
25474: 
23435:         /* General case: a branch or equality op follows the access. */
25215:         op = js_GetOpcode(cx, script, pc);
23435:         if (js_CodeSpec[op].format & JOF_DETECTING)
23435:             return JS_TRUE;
23435: 
23435:         switch (op) {
23435:           case JSOP_NULL:
23435:             /*
23435:              * Special case #1: handle (document.all == null).  Don't sweat
23435:              * about JS1.2's revision of the equality operators here.
23435:              */
25474:             if (++pc < endpc) {
25215:                 op = js_GetOpcode(cx, script, pc);
25474:                 return *pc == JSOP_EQ || *pc == JSOP_NE;
25474:             }
25474:             return JS_FALSE;
23435: 
52825:           case JSOP_GETGNAME:
23435:           case JSOP_NAME:
23435:             /*
23435:              * Special case #2: handle (document.all == undefined).  Don't
23435:              * worry about someone redefining undefined, which was added by
23435:              * Edition 3, so is read/write for backward compatibility.
23435:              */
23435:             GET_ATOM_FROM_BYTECODE(script, pc, 0, atom);
25474:             if (atom == cx->runtime->atomState.typeAtoms[JSTYPE_VOID] &&
25474:                 (pc += js_CodeSpec[op].length) < endpc) {
25215:                 op = js_GetOpcode(cx, script, pc);
23435:                 return op == JSOP_EQ || op == JSOP_NE ||
23435:                        op == JSOP_STRICTEQ || op == JSOP_STRICTNE;
23435:             }
23435:             return JS_FALSE;
23435: 
23435:           default:
23435:             /*
23435:              * At this point, anything but an extended atom index prefix means
23435:              * we're not detecting.
23435:              */
23435:             if (!(js_CodeSpec[op].format & JOF_INDEXBASE))
23435:                 return JS_FALSE;
23435:             break;
23435:         }
23435:     }
23435: }
23435: 
23435: /*
23435:  * Infer lookup flags from the currently executing bytecode. This does
23435:  * not attempt to infer JSRESOLVE_WITH, because the current bytecode
23435:  * does not indicate whether we are in a with statement. Return defaultFlags
23435:  * if a currently executing bytecode cannot be determined.
23435:  */
30034: uintN
30034: js_InferFlags(JSContext *cx, uintN defaultFlags)
23435: {
30035: #ifdef JS_TRACER
30034:     if (JS_ON_TRACE(cx))
62033:         return JS_TRACE_MONITOR_ON_TRACE(cx)->bailExit->lookupFlags;
30035: #endif
30034: 
30034:     JS_ASSERT_NOT_ON_TRACE(cx);
30034: 
23435:     jsbytecode *pc;
23435:     const JSCodeSpec *cs;
23435:     uint32 format;
23435:     uintN flags = 0;
23435: 
42717:     JSStackFrame *const fp = js_GetTopStackFrame(cx);
42717:     if (!fp || !(pc = cx->regs->pc))
23435:         return defaultFlags;
53840:     cs = &js_CodeSpec[js_GetOpcode(cx, fp->script(), pc)];
23435:     format = cs->format;
23435:     if (JOF_MODE(format) != JOF_NAME)
23435:         flags |= JSRESOLVE_QUALIFIED;
53840:     if ((format & (JOF_SET | JOF_FOR)) || fp->isAssigning()) {
23435:         flags |= JSRESOLVE_ASSIGNING;
32680:     } else if (cs->length >= 0) {
23435:         pc += cs->length;
53840:         JSScript *script = cx->fp()->script();
51446:         if (pc < script->code + script->length && Detecting(cx, pc))
23435:             flags |= JSRESOLVE_DETECTING;
23435:     }
23435:     if (format & JOF_DECLARING)
23435:         flags |= JSRESOLVE_DECLARING;
23435:     return flags;
23435: }
23435: 
23435: /*
    1:  * ObjectOps and Class for with-statement stack objects.
    1:  */
    1: static JSBool
    1: with_LookupProperty(JSContext *cx, JSObject *obj, jsid id, JSObject **objp,
    1:                     JSProperty **propp)
    1: {
23435:     /* Fixes bug 463997 */
23435:     uintN flags = cx->resolveFlags;
23435:     if (flags == JSRESOLVE_INFER)
30034:         flags = js_InferFlags(cx, flags);
23435:     flags |= JSRESOLVE_WITH;
23435:     JSAutoResolveFlags rf(cx, flags);
47417:     return obj->getProto()->lookupProperty(cx, id, objp, propp);
    1: }
    1: 
    1: static JSBool
56817: with_GetProperty(JSContext *cx, JSObject *obj, JSObject *receiver, jsid id, Value *vp)
    1: {
47417:     return obj->getProto()->getProperty(cx, id, vp);
    1: }
    1: 
    1: static JSBool
56760: with_SetProperty(JSContext *cx, JSObject *obj, jsid id, Value *vp, JSBool strict)
54169: {
54169:     return obj->getProto()->setProperty(cx, id, vp, strict);
    1: }
    1: 
    1: static JSBool
43290: with_GetAttributes(JSContext *cx, JSObject *obj, jsid id, uintN *attrsp)
    1: {
47417:     return obj->getProto()->getAttributes(cx, id, attrsp);
    1: }
    1: 
    1: static JSBool
43290: with_SetAttributes(JSContext *cx, JSObject *obj, jsid id, uintN *attrsp)
    1: {
47417:     return obj->getProto()->setAttributes(cx, id, attrsp);
    1: }
    1: 
    1: static JSBool
54169: with_DeleteProperty(JSContext *cx, JSObject *obj, jsid id, Value *rval, JSBool strict)
54169: {
54169:     return obj->getProto()->deleteProperty(cx, id, rval, strict);
    1: }
    1: 
    1: static JSBool
    1: with_Enumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
48470:                Value *statep, jsid *idp)
    1: {
47417:     return obj->getProto()->enumerate(cx, enum_op, statep, idp);
    1: }
    1: 
38633: static JSType
38633: with_TypeOf(JSContext *cx, JSObject *obj)
38633: {
38633:     return JSTYPE_OBJECT;
38633: }
38633: 
    1: static JSObject *
    1: with_ThisObject(JSContext *cx, JSObject *obj)
    1: {
47417:     return obj->getWithThis();
    1: }
    1: 
48622: Class js_WithClass = {
48622:     "With",
48622:     JSCLASS_HAS_PRIVATE | JSCLASS_HAS_RESERVED_SLOTS(2) | JSCLASS_IS_ANONYMOUS,
48622:     PropertyStub,         /* addProperty */
48622:     PropertyStub,         /* delProperty */
48622:     PropertyStub,         /* getProperty */
62395:     StrictPropertyStub,   /* setProperty */
48622:     EnumerateStub,
48622:     ResolveStub,
48622:     ConvertStub,
48622:     NULL,                 /* finalize */
48622:     NULL,                 /* reserved    */
48622:     NULL,                 /* checkAccess */
48622:     NULL,                 /* call        */
48622:     NULL,                 /* construct   */
48622:     NULL,                 /* xdrObject   */
48622:     NULL,                 /* hasInstance */
48622:     NULL,                 /* mark        */
48622:     JS_NULL_CLASS_EXT,
48622:     {
43290:         with_LookupProperty,
48622:         NULL,             /* defineProperty */
43290:         with_GetProperty,
43290:         with_SetProperty,
43290:         with_GetAttributes,
43290:         with_SetAttributes,
43290:         with_DeleteProperty,
43290:         with_Enumerate,
43290:         with_TypeOf,
48622:         NULL,             /* trace */
54563:         NULL,             /* fix   */
43290:         with_ThisObject,
48622:         NULL,             /* clear */
48622:     }
    1: };
    1: 
22652: JS_REQUIRES_STACK JSObject *
    1: js_NewWithObject(JSContext *cx, JSObject *proto, JSObject *parent, jsint depth)
    1: {
    1:     JSObject *obj;
    1: 
55746:     obj = js_NewGCObject(cx, FINALIZE_OBJECT2);
    1:     if (!obj)
    1:         return NULL;
52503: 
55746:     JSStackFrame *priv = js_FloatingFrameIfGenerator(cx, cx->fp());
55746: 
55746:     obj->init(cx, &js_WithClass, proto, parent, priv, false);
62077:     obj->setMap(cx->compartment->emptyWithShape);
    1:     OBJ_SET_BLOCK_DEPTH(cx, obj, depth);
47417: 
47417:     AutoObjectRooter tvr(cx, obj);
47417:     JSObject *thisp = proto->thisObject(cx);
47417:     if (!thisp)
47417:         return NULL;
52503: 
55482:     assertSameCompartment(cx, obj, thisp);
55482: 
47417:     obj->setWithThis(thisp);
    1:     return obj;
    1: }
    1: 
    1: JSObject *
    1: js_NewBlockObject(JSContext *cx)
    1: {
    1:     /*
    1:      * Null obj's proto slot so that Object.prototype.* does not pollute block
28093:      * scopes and to give the block object its own scope.
    1:      */
55746:     JSObject *blockObj = js_NewGCObject(cx, FINALIZE_OBJECT2);
47497:     if (!blockObj)
47497:         return NULL;
52503: 
55746:     blockObj->init(cx, &js_BlockClass, NULL, NULL, NULL, false);
62077:     blockObj->setMap(cx->compartment->emptyBlockShape);
28093:     return blockObj;
    1: }
    1: 
    1: JSObject *
30645: js_CloneBlockObject(JSContext *cx, JSObject *proto, JSStackFrame *fp)
    1: {
53650:     JS_ASSERT(proto->isStaticBlock());
30645: 
55746:     size_t count = OBJ_BLOCK_COUNT(cx, proto);
55746:     gc::FinalizeKind kind = gc::GetGCObjectKind(count + 1);
55746: 
55746:     JSObject *clone = js_NewGCObject(cx, kind);
    1:     if (!clone)
    1:         return NULL;
30645: 
53638:     JSStackFrame *priv = js_FloatingFrameIfGenerator(cx, fp);
48470: 
37766:     /* The caller sets parent on its own. */
61713:     clone->init(cx, &js_BlockClass, proto, NULL, priv, false);
61713: 
61713:     clone->setMap(proto->map);
55746:     if (!clone->ensureInstanceReservedSlots(cx, count + 1))
47497:         return NULL;
53650: 
55746:     clone->setSlot(JSSLOT_BLOCK_DEPTH, proto->getSlot(JSSLOT_BLOCK_DEPTH));
55746: 
53650:     JS_ASSERT(clone->isClonedBlock());
    1:     return clone;
    1: }
    1: 
22652: JS_REQUIRES_STACK JSBool
11859: js_PutBlockObject(JSContext *cx, JSBool normalUnwind)
    1: {
51446:     JSStackFrame *const fp = cx->fp();
53840:     JSObject *obj = &fp->scopeChain();
53650:     JS_ASSERT(obj->isClonedBlock());
51446:     JS_ASSERT(obj->getPrivate() == js_FloatingFrameIfGenerator(cx, cx->fp()));
14860: 
47497:     /* Block objects should have all reserved slots allocated early. */
47497:     uintN count = OBJ_BLOCK_COUNT(cx, obj);
55746:     JS_ASSERT(obj->numSlots() >= JSSLOT_BLOCK_DEPTH + 1 + count);
14860: 
14860:     /* The block and its locals must be on the current stack for GC safety. */
42717:     uintN depth = OBJ_BLOCK_DEPTH(cx, obj);
52503:     JS_ASSERT(depth <= size_t(cx->regs->sp - fp->base()));
52503:     JS_ASSERT(count <= size_t(cx->regs->sp - fp->base() - depth));
14860: 
32725:     /* See comments in CheckDestructuring from jsparse.cpp. */
14860:     JS_ASSERT(count >= 1);
14860: 
52503:     if (normalUnwind) {
54840:         uintN slot = JSSLOT_BLOCK_FIRST_FREE_SLOT;
53840:         depth += fp->numFixed();
55746:         memcpy(obj->getSlots() + slot, fp->slots() + depth, count * sizeof(Value));
14860:     }
14860: 
11758:     /* We must clear the private slot even with errors. */
31452:     obj->setPrivate(NULL);
53840:     fp->setScopeChainNoCallObj(*obj->getParent());
11758:     return normalUnwind;
    1: }
    1: 
    1: static JSBool
48470: block_getProperty(JSContext *cx, JSObject *obj, jsid id, Value *vp)
    1: {
32717:     /*
32717:      * Block objects are never exposed to script, and the engine handles them
32717:      * with care. So unlike other getters, this one can assert (rather than
32717:      * check) certain invariants about obj.
32717:      */
53650:     JS_ASSERT(obj->isClonedBlock());
48470:     uintN index = (uintN) JSID_TO_INT(id);
32717:     JS_ASSERT(index < OBJ_BLOCK_COUNT(cx, obj));
32717: 
31452:     JSStackFrame *fp = (JSStackFrame *) obj->getPrivate();
14860:     if (fp) {
42714:         fp = js_LiveFrameIfGenerator(fp);
53840:         index += fp->numFixed() + OBJ_BLOCK_DEPTH(cx, obj);
53840:         JS_ASSERT(index < fp->numSlots());
42714:         *vp = fp->slots()[index];
32717:         return true;
32717:     }
32717: 
53650:     /* Values are in slots immediately following the class-reserved ones. */
53650:     JS_ASSERT(obj->getSlot(JSSLOT_FREE(&js_BlockClass) + index) == *vp);
32717:     return true;
14860: }
14860: 
14860: static JSBool
62395: block_setProperty(JSContext *cx, JSObject *obj, jsid id, JSBool strict, Value *vp)
14860: {
53650:     JS_ASSERT(obj->isClonedBlock());
48470:     uintN index = (uintN) JSID_TO_INT(id);
32717:     JS_ASSERT(index < OBJ_BLOCK_COUNT(cx, obj));
32717: 
31452:     JSStackFrame *fp = (JSStackFrame *) obj->getPrivate();
14860:     if (fp) {
42714:         fp = js_LiveFrameIfGenerator(fp);
53840:         index += fp->numFixed() + OBJ_BLOCK_DEPTH(cx, obj);
53840:         JS_ASSERT(index < fp->numSlots());
42714:         fp->slots()[index] = *vp;
32717:         return true;
32717:     }
32717: 
53650:     /*
53650:      * The value in *vp will be written back to the slot in obj that was
53650:      * allocated when this let binding was defined.
53650:      */
32717:     return true;
32717: }
32717: 
53650: const Shape *
53650: JSObject::defineBlockVariable(JSContext *cx, jsid id, intN index)
53650: {
53650:     JS_ASSERT(isStaticBlock());
32717: 
32717:     /* Use JSPROP_ENUMERATE to aid the disassembler. */
53650:     uint32 slot = JSSLOT_FREE(&js_BlockClass) + index;
53650:     const Shape *shape = addProperty(cx, id,
53650:                                      block_getProperty, block_setProperty,
53650:                                      slot, JSPROP_ENUMERATE | JSPROP_PERMANENT,
53650:                                      Shape::HAS_SHORTID, index);
53650:     if (!shape)
53650:         return NULL;
53650:     if (slot >= numSlots() && !growSlots(cx, slot + 1))
53650:         return NULL;
53650:     return shape;
    1: }
    1: 
42832: static size_t
42832: GetObjectSize(JSObject *obj)
42832: {
42832:     return (obj->isFunction() && !obj->getPrivate())
42832:            ? sizeof(JSFunction)
55746:            : sizeof(JSObject) + sizeof(js::Value) * obj->numFixedSlots();
42832: }
42832: 
58714: bool
58714: JSObject::copyPropertiesFrom(JSContext *cx, JSObject *obj)
58714: {
58714:     // If we're not native, then we cannot copy properties.
58714:     JS_ASSERT(isNative() == obj->isNative());
58714:     if (!isNative())
58714:         return true;
58714: 
62363:     AutoShapeVector shapes(cx);
58714:     for (Shape::Range r(obj->lastProperty()); !r.empty(); r.popFront()) {
58714:         if (!shapes.append(&r.front()))
58714:             return false;
58714:     }
58714: 
58714:     size_t n = shapes.length();
58714:     while (n > 0) {
58714:         const Shape *shape = shapes[--n];
58714:         uintN attrs = shape->attributes();
58714:         PropertyOp getter = shape->getter();
58714:         if ((attrs & JSPROP_GETTER) && !cx->compartment->wrap(cx, &getter))
58714:             return false;
62395:         StrictPropertyOp setter = shape->setter();
58714:         if ((attrs & JSPROP_SETTER) && !cx->compartment->wrap(cx, &setter))
58714:             return false;
58714:         Value v = shape->hasSlot() ? obj->getSlot(shape->slot) : UndefinedValue();
58714:         if (!cx->compartment->wrap(cx, &v))
58714:             return false;
58714:         if (!defineProperty(cx, shape->id, v, getter, setter, attrs))
58714:             return false;
58714:     }
58714:     return true;
58714: }
58714: 
58714: static bool
58714: CopySlots(JSContext *cx, JSObject *from, JSObject *to)
58714: {
58714:     JS_ASSERT(!from->isNative() && !to->isNative());
58714:     size_t nslots = from->numSlots();
58714:     if (to->ensureSlots(cx, nslots))
58714:         return false;
58714: 
58714:     size_t n = 0;
58714:     if (to->isWrapper() &&
58714:         (JSWrapper::wrapperHandler(to)->flags() & JSWrapper::CROSS_COMPARTMENT)) {
58714:         to->slots[0] = from->slots[0];
58714:         to->slots[1] = from->slots[1];
58714:         n = 2;
58714:     }
58714: 
58714:     for (; n < nslots; ++n) {
58714:         Value v = from->slots[n];
58714:         if (!cx->compartment->wrap(cx, &v))
58714:             return false;
58714:         to->slots[n] = v;
58714:     }
58714:     return true;
58714: }
58714: 
58714: JSObject *
58714: JSObject::clone(JSContext *cx, JSObject *proto, JSObject *parent)
58714: {
58714:     /*
58714:      * We can only clone native objects and proxies. Dense arrays are slowified if
58714:      * we try to clone them.
58714:      */
58714:     if (!isNative()) {
58714:         if (isDenseArray()) {
58714:             if (!makeDenseArraySlow(cx))
58714:                 return NULL;
58714:         } else if (!isProxy()) {
58714:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
58714:                                  JSMSG_CANT_CLONE_OBJECT);
58714:             return NULL;
58714:         }
58714:     }
58714:     JSObject *clone = NewObject<WithProto::Given>(cx, getClass(),
58714:                                                   proto, parent,
58714:                                                   gc::FinalizeKind(finalizeKind()));
58714:     if (!clone)
58714:         return NULL;
58714:     if (isNative()) {
58714:         if (clone->isFunction() && (compartment() != clone->compartment())) {
58714:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
58714:                                  JSMSG_CANT_CLONE_OBJECT);
58714:             return NULL;
58714:         }
58714: 
58714:         if (getClass()->flags & JSCLASS_HAS_PRIVATE)
58714:             clone->setPrivate(getPrivate());
58714:     } else {
58714:         JS_ASSERT(isProxy());
58714:         if (!CopySlots(cx, this, clone))
58714:             return NULL;
58714:     }
58714:     return clone;
58714: }
58714: 
58714: static void
58714: TradeGuts(JSObject *a, JSObject *b)
58714: {
58714:     JS_ASSERT(a->compartment() == b->compartment());
58714:     JS_ASSERT(a->isFunction() == b->isFunction());
58714: 
60168:     /*
60168:      * Regexp guts are more complicated -- we would need to migrate the
60168:      * refcounted JIT code blob for them across compartments instead of just
60168:      * swapping guts.
60168:      */
60168:     JS_ASSERT(!a->isRegExp() && !b->isRegExp());
60168: 
58714:     bool aInline = !a->hasSlotsArray();
58714:     bool bInline = !b->hasSlotsArray();
58714: 
58714:     /* Trade the guts of the objects. */
58714:     const size_t size = GetObjectSize(a);
58714:     if (size == GetObjectSize(b)) {
58714:         /*
58714:          * If the objects are the same size, then we make no assumptions about
58714:          * whether they have dynamically allocated slots and instead just copy
58714:          * them over wholesale.
58714:          */
58714:         char tmp[tl::Max<sizeof(JSFunction), sizeof(JSObject_Slots16)>::result];
58714:         JS_ASSERT(size <= sizeof(tmp));
58714: 
58714:         memcpy(tmp, a, size);
58714:         memcpy(a, b, size);
58714:         memcpy(b, tmp, size);
58714: 
58714:         /* Fixup pointers for inline slots on the objects. */
58714:         if (aInline)
58714:             b->slots = b->fixedSlots();
58714:         if (bInline)
58714:             a->slots = a->fixedSlots();
58714:     } else {
58714:         /*
58714:          * If the objects are of differing sizes, then we only copy over the
58714:          * JSObject portion (things like class, etc.) and leave it to
58714:          * JSObject::clone to copy over the dynamic slots for us.
58714:          */
58714:         if (a->isFunction()) {
58714:             JSFunction tmp;
58714:             memcpy(&tmp, a, sizeof tmp);
58714:             memcpy(a, b, sizeof tmp);
58714:             memcpy(b, &tmp, sizeof tmp);
58714:         } else {
58714:             JSObject tmp;
58714:             memcpy(&tmp, a, sizeof tmp);
58714:             memcpy(a, b, sizeof tmp);
58714:             memcpy(b, &tmp, sizeof tmp);
58714:         }
58714: 
58714:         JS_ASSERT(!aInline);
58714:         JS_ASSERT(!bInline);
58714:     }
58714: }
58714: 
42733: /*
42733:  * Use this method with extreme caution. It trades the guts of two objects and updates
42733:  * scope ownership. This operation is not thread-safe, just as fast array to slow array
42733:  * transitions are inherently not thread-safe. Don't perform a swap operation on objects
42733:  * shared across threads or, or bad things will happen. You have been warned.
42733:  */
55746: bool
55746: JSObject::swap(JSContext *cx, JSObject *other)
42733: {
55746:     /*
58714:      * If we are swapping objects with a different number of builtin slots, force
58714:      * both to not use their inline slots.
55746:      */
58714:     if (GetObjectSize(this) != GetObjectSize(other)) {
55746:         if (!hasSlotsArray()) {
55746:             if (!allocSlots(cx, numSlots()))
55746:                 return false;
55746:         }
55746:         if (!other->hasSlotsArray()) {
55746:             if (!other->allocSlots(cx, other->numSlots()))
55746:                 return false;
55746:         }
55746:     }
55746: 
58714:     if (this->compartment() == other->compartment()) {
58714:         TradeGuts(this, other);
58714:         return true;
58714:     }
58714: 
58714:     JSObject *thisClone;
58714:     JSObject *otherClone;
58714:     {
58714:         AutoCompartment ac(cx, other);
58714:         if (!ac.enter())
58714:             return false;
58714:         thisClone = this->clone(cx, other->getProto(), other->getParent());
58714:         if (!thisClone || !thisClone->copyPropertiesFrom(cx, this))
58714:             return false;
58714:     }
58714:     {
58714:         AutoCompartment ac(cx, this);
58714:         if (!ac.enter())
58714:             return false;
58714:         otherClone = other->clone(cx, other->getProto(), other->getParent());
58714:         if (!otherClone || !otherClone->copyPropertiesFrom(cx, other))
58714:             return false;
58714:     }
58714:     TradeGuts(this, otherClone);
58714:     TradeGuts(other, thisClone);
55746: 
55746:     return true;
42733: }
42733: 
    1: #if JS_HAS_XDR
    1: 
 3235: #define NO_PARENT_INDEX ((uint32)-1)
 3235: 
 3235: uint32
 3235: FindObjectIndex(JSObjectArray *array, JSObject *obj)
    1: {
    1:     size_t i;
 3235: 
 3235:     if (array) {
 3235:         i = array->length;
 3235:         do {
 3235: 
 3235:             if (array->vector[--i] == obj)
    1:                 return i;
 3235:         } while (i != 0);
    1:     }
    1: 
    1:     return NO_PARENT_INDEX;
    1: }
    1: 
28093: JSBool
28093: js_XDRBlockObject(JSXDRState *xdr, JSObject **objp)
    1: {
    1:     JSContext *cx;
 3235:     uint32 parentId;
    1:     JSObject *obj, *parent;
53650:     uintN depth, count;
53650:     uint32 depthAndCount;
52503:     const Shape *shape;
    1: 
    1:     cx = xdr->cx;
    1: #ifdef __GNUC__
    1:     obj = NULL;         /* quell GCC overwarning */
    1: #endif
    1: 
    1:     if (xdr->mode == JSXDR_ENCODE) {
    1:         obj = *objp;
39930:         parent = obj->getParent();
59221:         parentId = JSScript::isValidOffset(xdr->script->objectsOffset)
59221:                    ? FindObjectIndex(xdr->script->objects(), parent)
59221:                    : NO_PARENT_INDEX;
 2531:         depth = (uint16)OBJ_BLOCK_DEPTH(cx, obj);
 2531:         count = (uint16)OBJ_BLOCK_COUNT(cx, obj);
53650:         depthAndCount = (uint32)(depth << 16) | count;
    1:     }
    1: #ifdef __GNUC__ /* suppress bogus gcc warnings */
    1:     else count = 0;
    1: #endif
    1: 
    1:     /* First, XDR the parent atomid. */
    1:     if (!JS_XDRUint32(xdr, &parentId))
    1:         return JS_FALSE;
    1: 
    1:     if (xdr->mode == JSXDR_DECODE) {
    1:         obj = js_NewBlockObject(cx);
    1:         if (!obj)
    1:             return JS_FALSE;
    1:         *objp = obj;
    1: 
    1:         /*
    1:          * If there's a parent id, then get the parent out of our script's
 3235:          * object array. We know that we XDR block object in outer-to-inner
 3235:          * order, which means that getting the parent now will work.
    1:          */
 3235:         if (parentId == NO_PARENT_INDEX)
    1:             parent = NULL;
 3235:         else
32723:             parent = xdr->script->getObject(parentId);
39930:         obj->setParent(parent);
    1:     }
    1: 
48470:     AutoObjectRooter tvr(cx, obj);
33178: 
53650:     if (!JS_XDRUint32(xdr, &depthAndCount))
33178:         return false;
    1: 
    1:     if (xdr->mode == JSXDR_DECODE) {
53650:         depth = (uint16)(depthAndCount >> 16);
53650:         count = (uint16)depthAndCount;
48470:         obj->setSlot(JSSLOT_BLOCK_DEPTH, Value(Int32Value(depth)));
    1: 
    1:         /*
    1:          * XDR the block object's properties. We know that there are 'count'
53650:          * properties to XDR, stored as id/shortid pairs.
    1:          */
53650:         for (uintN i = 0; i < count; i++) {
53650:             JSAtom *atom;
53650:             uint16 shortid;
53650: 
53844:             /* XDR the real id, then the shortid. */
53844:             if (!js_XDRAtom(xdr, &atom) || !JS_XDRUint16(xdr, &shortid))
53844:                 return false;
53844: 
53844:             if (!obj->defineBlockVariable(cx, ATOM_TO_JSID(atom), shortid))
53844:                 return false;
53844:         }
53844:     } else {
62363:         AutoShapeVector shapes(cx);
62363:         shapes.growBy(count);
53844: 
53844:         for (Shape::Range r(obj->lastProperty()); !r.empty(); r.popFront()) {
53844:             shape = &r.front();
53844:             shapes[shape->shortid] = shape;
53844:         }
53844: 
53844:         /*
53844:          * XDR the block object's properties. We know that there are 'count'
53844:          * properties to XDR, stored as id/shortid pairs.
53844:          */
53844:         for (uintN i = 0; i < count; i++) {
53650:             shape = shapes[i];
52503:             JS_ASSERT(shape->getter() == block_getProperty);
53650: 
53650:             jsid propid = shape->id;
    1:             JS_ASSERT(JSID_IS_ATOM(propid));
53844:             JSAtom *atom = JSID_TO_ATOM(propid);
53844: 
53844:             uint16 shortid = uint16(shape->shortid);
53650:             JS_ASSERT(shortid == i);
    1: 
    1:             /* XDR the real id, then the shortid. */
53844:             if (!js_XDRAtom(xdr, &atom) || !JS_XDRUint16(xdr, &shortid))
33178:                 return false;
    1:         }
    1:     }
33178:     return true;
    1: }
    1: 
    1: #endif
    1: 
48470: Class js_BlockClass = {
    1:     "Block",
28093:     JSCLASS_HAS_PRIVATE | JSCLASS_HAS_RESERVED_SLOTS(1) | JSCLASS_IS_ANONYMOUS,
48622:     PropertyStub,         /* addProperty */
48622:     PropertyStub,         /* delProperty */
48622:     PropertyStub,         /* getProperty */
62395:     StrictPropertyStub,   /* setProperty */
48622:     EnumerateStub,
48622:     ResolveStub,
48622:     ConvertStub
    1: };
    1: 
    1: JSObject *
43236: js_InitObjectClass(JSContext *cx, JSObject *obj)
43236: {
53557:     JSObject *proto = js_InitClass(cx, obj, NULL, &js_ObjectClass, js_Object, 1,
43236:                                    object_props, object_methods, NULL, object_static_methods);
43236:     if (!proto)
43236:         return NULL;
43236: 
 2112:     /* ECMA (15.1.2.1) says 'eval' is a property of the global object. */
57721:     jsid id = ATOM_TO_JSID(cx->runtime->atomState.evalAtom);
57721:     if (!js_DefineFunction(cx, obj, id, eval, 1, JSFUN_STUB_GSOPS))
    1:         return NULL;
    1: 
43236:     return proto;
    1: }
    1: 
42772: static bool
42772: DefineStandardSlot(JSContext *cx, JSObject *obj, JSProtoKey key, JSAtom *atom,
48470:                    const Value &v, uint32 attrs, bool &named)
42772: {
42772:     jsid id = ATOM_TO_JSID(atom);
42772: 
42772:     if (key != JSProto_Null) {
42772:         /*
42772:          * Initializing an actual standard class on a global object. If the
42772:          * property is not yet present, force it into a new one bound to a
42772:          * reserved slot. Otherwise, go through the normal property path.
42772:          */
60566:         JS_ASSERT(obj->isGlobal());
42772:         JS_ASSERT(obj->isNative());
42772: 
56567:         if (!obj->ensureClassReservedSlots(cx))
42772:             return false;
42772: 
52503:         const Shape *shape = obj->nativeLookup(id);
52503:         if (!shape) {
55746:             uint32 slot = 2 * JSProto_LIMIT + key;
56567:             if (!js_SetReservedSlot(cx, obj, slot, v))
42772:                 return false;
62395:             if (!obj->addProperty(cx, id, PropertyStub, StrictPropertyStub, slot, attrs, 0, 0))
42772:                 return false;
42772: 
42772:             named = true;
42772:             return true;
42772:         }
42772:     }
42772: 
62395:     named = obj->defineProperty(cx, id, v, PropertyStub, StrictPropertyStub, attrs);
42772:     return named;
42772: }
42772: 
61705: namespace js {
61705: 
25897: JSObject *
61705: DefineConstructorAndPrototype(JSContext *cx, JSObject *obj, JSProtoKey key, JSAtom *atom,
61705:                               JSObject *protoProto, Class *clasp,
61705:                               Native constructor, uintN nargs,
25897:                               JSPropertySpec *ps, JSFunctionSpec *fs,
28086:                               JSPropertySpec *static_ps, JSFunctionSpec *static_fs)
25897: {
47497:     /*
47497:      * Create a prototype object for this class.
47497:      *
47497:      * FIXME: lazy standard (built-in) class initialization and even older
47497:      * eager boostrapping code rely on all of these properties:
47497:      *
47497:      * 1. NewObject attempting to compute a default prototype object when
47497:      *    passed null for proto; and
47497:      *
47497:      * 2. NewObject tolerating no default prototype (null proto slot value)
47497:      *    due to this js_InitClass call coming from js_InitFunctionClass on an
47497:      *    otherwise-uninitialized global.
47497:      *
47497:      * 3. NewObject allocating a JSFunction-sized GC-thing when clasp is
47497:      *    &js_FunctionClass, not a JSObject-sized (smaller) GC-thing.
47497:      *
47497:      * The JS_NewObjectForGivenProto and JS_NewObject APIs also allow clasp to
47497:      * be &js_FunctionClass (we could break compatibility easily). But fixing
47497:      * (3) is not enough without addressing the bootstrapping dependency on (1)
47497:      * and (2).
47497:      */
61705:     JSObject *proto = NewObject<WithProto::Class>(cx, clasp, protoProto, obj);
25897:     if (!proto)
25897:         return NULL;
25897: 
57806:     proto->syncSpecialEquality();
57806: 
25897:     /* After this point, control must exit via label bad or out. */
48470:     AutoObjectRooter tvr(cx, proto);
48470: 
48470:     JSObject *ctor;
61705:     bool named = false;
25897:     if (!constructor) {
25897:         /*
25897:          * Lacking a constructor, name the prototype (e.g., Math) unless this
25897:          * class (a) is anonymous, i.e. for internal use only; (b) the class
25897:          * of obj (the global object) is has a reserved slot indexed by key;
25897:          * and (c) key is not the null key.
25897:          */
60566:         if (!(clasp->flags & JSCLASS_IS_ANONYMOUS) || !obj->isGlobal() || key == JSProto_Null) {
42772:             uint32 attrs = (clasp->flags & JSCLASS_IS_ANONYMOUS)
25897:                            ? JSPROP_READONLY | JSPROP_PERMANENT
42772:                            : 0;
48470:             if (!DefineStandardSlot(cx, obj, key, atom, ObjectValue(*proto), attrs, named))
25897:                 goto bad;
25897:         }
25897: 
25897:         ctor = proto;
25897:     } else {
61705:         JSFunction *fun = js_NewFunction(cx, NULL, constructor, nargs, JSFUN_CONSTRUCTOR, obj, atom);
25897:         if (!fun)
25897:             goto bad;
25897: 
48470:         AutoValueRooter tvr2(cx, ObjectValue(*fun));
42772:         if (!DefineStandardSlot(cx, obj, key, atom, tvr2.value(), 0, named))
42772:             goto bad;
42772: 
25897:         /*
25897:          * Remember the class this function is a constructor for so that
25897:          * we know to create an object of this class when we call the
48641:          * constructor.
25897:          */
48641:         FUN_CLASP(fun) = clasp;
25897: 
25897:         /*
25897:          * Optionally construct the prototype object, before the class has
25897:          * been fully initialized.  Allow the ctor to replace proto with a
25897:          * different object, as is done for operator new -- and as at least
25897:          * XML support requires.
25897:          */
25897:         ctor = FUN_OBJECT(fun);
25897:         if (clasp->flags & JSCLASS_CONSTRUCT_PROTOTYPE) {
48470:             Value rval;
53557:             if (!InvokeConstructorWithGivenThis(cx, proto, ObjectOrNullValue(ctor),
53557:                                                 0, NULL, &rval)) {
25897:                 goto bad;
53557:             }
48470:             if (rval.isObject() && &rval.toObject() != proto)
48470:                 proto = &rval.toObject();
25897:         }
25897: 
25897:         /* Connect constructor and prototype by named properties. */
25897:         if (!js_SetClassPrototype(cx, ctor, proto,
25897:                                   JSPROP_READONLY | JSPROP_PERMANENT)) {
25897:             goto bad;
25897:         }
25897: 
25897:         /* Bootstrap Function.prototype (see also JS_InitStandardClasses). */
40826:         if (ctor->getClass() == clasp)
39928:             ctor->setProto(proto);
25897:     }
25897: 
25897:     /* Add properties and methods to the prototype and the constructor. */
25897:     if ((ps && !JS_DefineProperties(cx, proto, ps)) ||
25897:         (fs && !JS_DefineFunctions(cx, proto, fs)) ||
25897:         (static_ps && !JS_DefineProperties(cx, ctor, static_ps)) ||
25897:         (static_fs && !JS_DefineFunctions(cx, ctor, static_fs))) {
25897:         goto bad;
25897:     }
25897: 
35117:     /*
57748:      * Pre-brand the prototype and constructor if they have built-in methods.
57748:      * This avoids extra shape guard branch exits in the tracejitted code.
57748:      */
59227:     if (fs)
59227:         proto->brand(cx);
59227:     if (ctor != proto && static_fs)
59227:         ctor->brand(cx);
57748: 
57748:     /*
52503:      * Make sure proto's emptyShape is available to be shared by objects of
52503:      * this class.  JSObject::emptyShape is a one-slot cache. If we omit this,
52503:      * some other class could snap it up. (The risk is particularly great for
52503:      * Object.prototype.)
35117:      *
52503:      * All callers of JSObject::initSharingEmptyShape depend on this.
52513:      *
52513:      * FIXME: bug 592296 -- js_InitArrayClass should pass &js_SlowArrayClass
52513:      * and make the Array.prototype slow from the start.
35117:      */
52513:     JS_ASSERT_IF(proto->clasp != clasp,
52513:                  clasp == &js_ArrayClass && proto->clasp == &js_SlowArrayClass);
55746:     if (!proto->getEmptyShape(cx, proto->clasp, FINALIZE_OBJECT0))
35117:         goto bad;
35117: 
56574:     if (clasp->flags & (JSCLASS_FREEZE_PROTO|JSCLASS_FREEZE_CTOR)) {
56576:         JS_ASSERT_IF(ctor == proto, !(clasp->flags & JSCLASS_FREEZE_CTOR));
56574:         if (proto && (clasp->flags & JSCLASS_FREEZE_PROTO) && !proto->freeze(cx))
56574:             goto bad;
56574:         if (ctor && (clasp->flags & JSCLASS_FREEZE_CTOR) && !ctor->freeze(cx))
56574:             goto bad;
56574:     }
56574: 
25897:     /* If this is a standard class, cache its prototype. */
43258:     if (key != JSProto_Null && !js_SetClassObject(cx, obj, key, ctor, proto))
25897:         goto bad;
25897: 
25897:     return proto;
25897: 
25897: bad:
48470:     if (named) {
48470:         Value rval;
54169:         obj->deleteProperty(cx, ATOM_TO_JSID(atom), &rval, false);
48470:     }
48470:     return NULL;
25897: }
25897: 
61705: }
61705: 
61705: JSObject *
61705: js_InitClass(JSContext *cx, JSObject *obj, JSObject *protoProto,
61705:              Class *clasp, Native constructor, uintN nargs,
61705:              JSPropertySpec *ps, JSFunctionSpec *fs,
61705:              JSPropertySpec *static_ps, JSFunctionSpec *static_fs)
61705: {
61705:     JSAtom *atom = js_Atomize(cx, clasp->name, strlen(clasp->name), 0);
61705:     if (!atom)
61705:         return NULL;
61705: 
61705:     /*
61705:      * All instances of the class will inherit properties from the prototype
61705:      * object we are about to create (in DefineConstructorAndPrototype), which
61705:      * in turn will inherit from protoProto.
61705:      *
61705:      * When initializing a standard class (other than Object), if protoProto is
61705:      * null, default to the Object prototype object. The engine's internal uses
61705:      * of js_InitClass depend on this nicety. Note that in
61705:      * js_InitFunctionAndObjectClasses, we specially hack the resolving table
61705:      * and then depend on js_GetClassPrototype here leaving protoProto NULL and
61705:      * returning true.
61705:      */
61705:     JSProtoKey key = JSCLASS_CACHED_PROTO_KEY(clasp);
61705:     if (key != JSProto_Null &&
61705:         !protoProto &&
61705:         !js_GetClassPrototype(cx, obj, JSProto_Object, &protoProto)) {
61705:         return NULL;
61705:     }
61705: 
61705:     return DefineConstructorAndPrototype(cx, obj, key, atom, protoProto, clasp, constructor, nargs,
61705:                                          ps, fs, static_ps, static_fs);
61705: }
61705: 
40858: bool
55746: JSObject::allocSlots(JSContext *cx, size_t newcap)
55746: {
55746:     uint32 oldcap = numSlots();
55746: 
55746:     JS_ASSERT(newcap >= oldcap && !hasSlotsArray());
55746: 
55746:     if (newcap > NSLOTS_LIMIT) {
55746:         if (!JS_ON_TRACE(cx))
55746:             js_ReportAllocationOverflow(cx);
41117:         return false;
55746:     }
55746: 
55746:     Value *tmpslots = (Value*) cx->malloc(newcap * sizeof(Value));
55746:     if (!tmpslots)
55746:         return false;  /* Leave slots at inline buffer. */
55746:     slots = tmpslots;
55746:     capacity = newcap;
55746: 
55746:     /* Copy over anything from the inline buffer. */
55746:     memcpy(slots, fixedSlots(), oldcap * sizeof(Value));
55746:     ClearValueRange(slots + oldcap, newcap - oldcap, isDenseArray());
30454:     return true;
30454: }
30454: 
30454: bool
55746: JSObject::growSlots(JSContext *cx, size_t newcap)
30454: {
    1:     /*
55746:      * When an object with CAPACITY_DOUBLING_MAX or fewer slots needs to
55746:      * grow, double its capacity, to add N elements in amortized O(N) time.
55746:      *
55746:      * Above this limit, grow by 12.5% each time. Speed is still amortized
55746:      * O(N), with a higher constant factor, and we waste less space.
    1:      */
55746:     static const size_t CAPACITY_DOUBLING_MAX = 1024 * 1024;
55746:     static const size_t CAPACITY_CHUNK = CAPACITY_DOUBLING_MAX / sizeof(Value);
55746: 
55746:     uint32 oldcap = numSlots();
55746:     JS_ASSERT(oldcap < newcap);
55746: 
55746:     uint32 nextsize = (oldcap <= CAPACITY_DOUBLING_MAX)
55746:                     ? oldcap * 2
55746:                     : oldcap + (oldcap >> 3);
55746: 
55746:     uint32 actualCapacity = JS_MAX(newcap, nextsize);
55746:     if (actualCapacity >= CAPACITY_CHUNK)
55746:         actualCapacity = JS_ROUNDUP(actualCapacity, CAPACITY_CHUNK);
55746:     else if (actualCapacity < SLOT_CAPACITY_MIN)
55746:         actualCapacity = SLOT_CAPACITY_MIN;
52503: 
53650:     /* Don't let nslots get close to wrapping around uint32. */
55746:     if (actualCapacity >= NSLOTS_LIMIT) {
52503:         JS_ReportOutOfMemory(cx);
52503:         return false;
52503:     }
30454: 
55746:     /* If nothing was allocated yet, treat it as initial allocation. */
55746:     if (!hasSlotsArray())
55746:         return allocSlots(cx, actualCapacity);
55746: 
59001:     Value *tmpslots = (Value*) cx->realloc(slots, oldcap * sizeof(Value), actualCapacity * sizeof(Value));
55746:     if (!tmpslots)
55746:         return false;    /* Leave dslots as its old size. */
55746:     slots = tmpslots;
55746:     capacity = actualCapacity;
30454: 
30454:     /* Initialize the additional slots we added. */
55746:     ClearValueRange(slots + oldcap, actualCapacity - oldcap, isDenseArray());
30454:     return true;
30454: }
30454: 
30454: void
55746: JSObject::shrinkSlots(JSContext *cx, size_t newcap)
55746: {
55746:     uint32 oldcap = numSlots();
55746:     JS_ASSERT(newcap <= oldcap);
55746:     JS_ASSERT(newcap >= slotSpan());
55746: 
55746:     if (oldcap <= SLOT_CAPACITY_MIN || !hasSlotsArray()) {
55746:         /* We won't shrink the slots any more.  Clear excess holes. */
55746:         ClearValueRange(slots + newcap, oldcap - newcap, isDenseArray());
30454:         return;
55746:     }
55746: 
55746:     uint32 fill = newcap;
55746:     if (newcap < SLOT_CAPACITY_MIN)
55746:         newcap = SLOT_CAPACITY_MIN;
58051:     if (newcap < numFixedSlots())
58051:         newcap = numFixedSlots();
55746: 
55746:     Value *tmpslots = (Value*) cx->realloc(slots, newcap * sizeof(Value));
55746:     if (!tmpslots)
55746:         return;  /* Leave slots at its old size. */
55746:     slots = tmpslots;
55746:     capacity = newcap;
55746: 
55746:     if (fill < newcap) {
55746:         /* Clear any excess holes if we tried to shrink below SLOT_CAPACITY_MIN. */
55746:         ClearValueRange(slots + fill, newcap - fill, isDenseArray());
30454:     }
    1: }
    1: 
30732: bool
52503: JSObject::ensureInstanceReservedSlots(JSContext *cx, size_t nreserved)
52503: {
52503:     JS_ASSERT_IF(isNative(),
54410:                  isBlock() || isCall() || (isFunction() && isBoundFunction()));
52503: 
52503:     uintN nslots = JSSLOT_FREE(clasp) + nreserved;
53650:     return nslots <= numSlots() || allocSlots(cx, nslots);
30732: }
30732: 
18907: static JSObject *
    1: js_InitNullClass(JSContext *cx, JSObject *obj)
    1: {
    1:     JS_ASSERT(0);
    1:     return NULL;
    1: }
    1: 
    1: #define JS_PROTO(name,code,init) extern JSObject *init(JSContext *, JSObject *);
    1: #include "jsproto.tbl"
    1: #undef JS_PROTO
    1: 
    1: static JSObjectOp lazy_prototype_init[JSProto_LIMIT] = {
    1: #define JS_PROTO(name,code,init) init,
    1: #include "jsproto.tbl"
    1: #undef JS_PROTO
    1: };
    1: 
47465: namespace js {
47465: 
47465: bool
47465: SetProto(JSContext *cx, JSObject *obj, JSObject *proto, bool checkForCycles)
47465: {
47465:     JS_ASSERT_IF(!checkForCycles, obj != proto);
54563:     JS_ASSERT(obj->isExtensible());
47465: 
47465:     if (obj->isNative()) {
56567:         if (!obj->ensureClassReservedSlots(cx))
47465:             return false;
47465:     }
47465: 
47465:     /*
47465:      * Regenerate property cache shape ids for all of the scopes along the
47465:      * old prototype chain to invalidate their property cache entries, in
47465:      * case any entries were filled by looking up through obj.
47465:      */
47465:     JSObject *oldproto = obj;
47465:     while (oldproto && oldproto->isNative()) {
52503:         oldproto->protoShapeChange(cx);
56567:         oldproto = oldproto->getProto();
47465:     }
47465: 
47465:     if (!proto || !checkForCycles) {
47465:         obj->setProto(proto);
47465:     } else if (!SetProtoCheckingForCycles(cx, obj, proto)) {
47465:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CYCLIC_VALUE, js_proto_str);
47465:         return false;
47465:     }
47465:     return true;
47465: }
47465: 
43258: }
43258: 
    1: JSBool
    1: js_GetClassObject(JSContext *cx, JSObject *obj, JSProtoKey key,
    1:                   JSObject **objp)
    1: {
60566:     JSObject *cobj;
    1:     JSResolvingKey rkey;
    1:     JSResolvingEntry *rentry;
    1:     uint32 generation;
    1:     JSObjectOp init;
48470:     Value v;
    1: 
60566:     obj = obj->getGlobal();
60566:     if (!obj->isGlobal()) {
    1:         *objp = NULL;
    1:         return JS_TRUE;
    1:     }
    1: 
47404:     v = obj->getReservedSlot(key);
48470:     if (v.isObject()) {
48470:         *objp = &v.toObject();
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     rkey.obj = obj;
    1:     rkey.id = ATOM_TO_JSID(cx->runtime->atomState.classAtoms[key]);
    1:     if (!js_StartResolving(cx, &rkey, JSRESFLAG_LOOKUP, &rentry))
    1:         return JS_FALSE;
    1:     if (!rentry) {
    1:         /* Already caching key in obj -- suppress recursion. */
    1:         *objp = NULL;
    1:         return JS_TRUE;
    1:     }
    1:     generation = cx->resolvingTable->generation;
    1: 
43258:     JSBool ok = true;
    1:     cobj = NULL;
    1:     init = lazy_prototype_init[key];
    1:     if (init) {
    1:         if (!init(cx, obj)) {
    1:             ok = JS_FALSE;
    1:         } else {
47404:             v = obj->getReservedSlot(key);
48470:             if (v.isObject())
48470:                 cobj = &v.toObject();
    1:         }
    1:     }
    1: 
    1:     js_StopResolving(cx, &rkey, JSRESFLAG_LOOKUP, rentry, generation);
    1:     *objp = cobj;
    1:     return ok;
    1: }
    1: 
    1: JSBool
43258: js_SetClassObject(JSContext *cx, JSObject *obj, JSProtoKey key, JSObject *cobj, JSObject *proto)
    1: {
39930:     JS_ASSERT(!obj->getParent());
60566:     if (!obj->isGlobal())
    1:         return JS_TRUE;
    1: 
48470:     return js_SetReservedSlot(cx, obj, key, ObjectOrNullValue(cobj)) &&
48470:            js_SetReservedSlot(cx, obj, JSProto_LIMIT + key, ObjectOrNullValue(proto));
    1: }
    1: 
    1: JSBool
38604: js_FindClassObject(JSContext *cx, JSObject *start, JSProtoKey protoKey,
48470:                    Value *vp, Class *clasp)
    1: {
62953:     JSStackFrame *fp;
    1:     JSObject *obj, *cobj, *pobj;
38604:     jsid id;
    1:     JSProperty *prop;
52503:     const Shape *shape;
    1: 
62953:     /*
62953:      * Find the global object. Use cx->fp() directly to avoid falling off
62953:      * trace; all JIT-elided stack frames have the same global object as
62953:      * cx->fp().
62953:      */
62953:     VOUCH_DOES_NOT_REQUIRE_STACK();
62953:     if (!start && (fp = cx->maybefp()) != NULL)
62953:         start = &fp->scopeChain();
62953: 
22652:     if (start) {
62953:         /* Find the topmost object in the scope chain. */
62953:         do {
62953:             obj = start;
62953:             start = obj->getParent();
62953:         } while (start);
    1:     } else {
62953:         obj = cx->globalObject;
62953:         if (!obj) {
62953:             vp->setUndefined();
62953:             return JS_TRUE;
62953:         }
    1:     }
    1: 
    1:     OBJ_TO_INNER_OBJECT(cx, obj);
    1:     if (!obj)
    1:         return JS_FALSE;
    1: 
38604:     if (protoKey != JSProto_Null) {
38604:         JS_ASSERT(JSProto_Null < protoKey);
38604:         JS_ASSERT(protoKey < JSProto_LIMIT);
38604:         if (!js_GetClassObject(cx, obj, protoKey, &cobj))
    1:             return JS_FALSE;
    1:         if (cobj) {
48470:             vp->setObject(*cobj);
    1:             return JS_TRUE;
    1:         }
38604:         id = ATOM_TO_JSID(cx->runtime->atomState.classAtoms[protoKey]);
38604:     } else {
38604:         JSAtom *atom = js_Atomize(cx, clasp->name, strlen(clasp->name), 0);
38604:         if (!atom)
38604:             return false;
38604:         id = ATOM_TO_JSID(atom);
    1:     }
    1: 
40430:     JS_ASSERT(obj->isNative());
10217:     if (js_LookupPropertyWithFlags(cx, obj, id, JSRESOLVE_CLASSNAME,
10217:                                    &pobj, &prop) < 0) {
    1:         return JS_FALSE;
    1:     }
48470:     Value v = UndefinedValue();
43290:     if (prop && pobj->isNative()) {
52503:         shape = (Shape *) prop;
52503:         if (pobj->containsSlot(shape->slot)) {
56567:             v = pobj->nativeGetSlot(shape->slot);
48470:             if (v.isPrimitive())
48470:                 v.setUndefined();
 8893:         }
 8893:     }
 8893:     *vp = v;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSObject *
48470: js_ConstructObject(JSContext *cx, Class *clasp, JSObject *proto, JSObject *parent,
48470:                    uintN argc, Value *argv)
48470: {
40388:     AutoArrayRooter argtvr(cx, argc, argv);
    1: 
38604:     JSProtoKey protoKey = GetClassProtoKey(clasp);
48470: 
48470:     /* Protect constructor in case a crazy getter for .prototype uproots it. */
48470:     AutoValueRooter tvr(cx);
48470:     if (!js_FindClassObject(cx, parent, protoKey, tvr.addr(), clasp))
    1:         return NULL;
    1: 
48470:     const Value &cval = tvr.value();
48470:     if (tvr.value().isPrimitive()) {
48470:         js_ReportIsNotFunction(cx, tvr.addr(), JSV2F_CONSTRUCT | JSV2F_SEARCH_STACK);
    1:         return NULL;
    1:     }
    1: 
    1:     /*
41968:      * If proto is NULL, set it to Constructor.prototype, just like JSOP_NEW
41968:      * does, likewise for the new object's parent.
    1:      */
48470:     JSObject *ctor = &cval.toObject();
    1:     if (!parent)
39930:         parent = ctor->getParent();
    1:     if (!proto) {
48470:         Value rval;
31501:         if (!ctor->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom),
    1:                                &rval)) {
33178:             return NULL;
    1:         }
48470:         if (rval.isObjectOrNull())
48470:             proto = rval.toObjectOrNull();
48470:     }
48470: 
50450:     JSObject *obj = NewObject<WithProto::Class>(cx, clasp, proto, parent);
    1:     if (!obj)
33178:         return NULL;
    1: 
57806:     obj->syncSpecialEquality();
57806: 
48470:     Value rval;
53557:     if (!InvokeConstructorWithGivenThis(cx, obj, cval, argc, argv, &rval))
33178:         return NULL;
    1: 
48470:     if (rval.isPrimitive())
33178:         return obj;
    1: 
    1:     /*
    1:      * If the instance's class differs from what was requested, throw a type
    1:      * error.  If the given class has both the JSCLASS_HAS_PRIVATE and the
    1:      * JSCLASS_CONSTRUCT_PROTOTYPE flags, and the instance does not have its
    1:      * private data set at this point, then the constructor was replaced and
    1:      * we should throw a type error.
    1:      */
48470:     obj = &rval.toObject();
40826:     if (obj->getClass() != clasp ||
    1:         (!(~clasp->flags & (JSCLASS_HAS_PRIVATE |
    1:                             JSCLASS_CONSTRUCT_PROTOTYPE)) &&
31452:          !obj->getPrivate())) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_WRONG_CONSTRUCTOR, clasp->name);
33178:         return NULL;
33178:     }
    1:     return obj;
    1: }
    1: 
52503: bool
52503: JSObject::allocSlot(JSContext *cx, uint32 *slotp)
52503: {
53652:     uint32 slot = slotSpan();
53650:     JS_ASSERT(slot >= JSSLOT_FREE(clasp));
53650: 
53650:     /*
53650:      * If this object is in dictionary mode and it has a property table, try to
53650:      * pull a free slot from the property table's slot-number freelist.
53650:      */
62399:     if (inDictionaryMode() && lastProp->hasTable()) {
62399:         uint32 &last = lastProp->getTable()->freelist;
53546:         if (last != SHAPE_INVALID_SLOT) {
53650: #ifdef DEBUG
53650:             JS_ASSERT(last < slot);
53650:             uint32 next = getSlot(last).toPrivateUint32();
53650:             JS_ASSERT_IF(next != SHAPE_INVALID_SLOT, next < slot);
53650: #endif
53650: 
53546:             *slotp = last;
53546: 
53546:             Value &vref = getSlotRef(last);
53546:             last = vref.toPrivateUint32();
53546:             vref.setUndefined();
53546:             return true;
53546:         }
53546:     }
53546: 
53650:     if (slot >= numSlots() && !growSlots(cx, slot + 1))
52503:         return false;
52503: 
52503:     /* JSObject::growSlots or JSObject::freeSlot should set the free slots to void. */
53650:     JS_ASSERT(getSlot(slot).isUndefined());
53650:     *slotp = slot;
52503:     return true;
    1: }
    1: 
58749: bool
52503: JSObject::freeSlot(JSContext *cx, uint32 slot)
52503: {
53652:     uint32 limit = slotSpan();
53650:     JS_ASSERT(slot < limit);
52503: 
53546:     Value &vref = getSlotRef(slot);
62399:     if (inDictionaryMode() && lastProp->hasTable()) {
62399:         uint32 &last = lastProp->getTable()->freelist;
53546: 
53650:         /* Can't afford to check the whole freelist, but let's check the head. */
53650:         JS_ASSERT_IF(last != SHAPE_INVALID_SLOT, last < limit && last != slot);
53650: 
53650:         /*
53650:          * Freeing a slot other than the last one mapped by this object's
54416:          * shape (and not a reserved slot; see bug 595230): push the slot onto
54416:          * the dictionary property table's freelist. We want to let the last
54416:          * slot be freed by shrinking the dslots vector; see js_TraceObject.
53650:          */
54416:         if (JSSLOT_FREE(clasp) <= slot && slot + 1 < limit) {
53652:             JS_ASSERT_IF(last != SHAPE_INVALID_SLOT, last < slotSpan());
53546:             vref.setPrivateUint32(last);
53546:             last = slot;
58749:             return true;
53546:         }
53546:     }
53546:     vref.setUndefined();
58749:     return false;
52503: }
30270: 
48470: /* JSBOXEDWORD_INT_MAX as a string */
48470: #define JSBOXEDWORD_INT_MAX_STRING "1073741823"
30270: 
30270: /*
30270:  * Convert string indexes that convert to int jsvals as ints to save memory.
30270:  * Care must be taken to use this macro every time a property name is used, or
30270:  * else double-sets, incorrect property cache misses, or other mistakes could
30270:  * occur.
30270:  */
11524: jsid
30270: js_CheckForStringIndex(jsid id)
    1: {
30270:     if (!JSID_IS_ATOM(id))
30270:         return id;
30270: 
30270:     JSAtom *atom = JSID_TO_ATOM(id);
30270:     JSString *str = ATOM_TO_STRING(atom);
30270:     const jschar *s = str->flatChars();
30270:     jschar ch = *s;
30270: 
30270:     JSBool negative = (ch == '-');
30270:     if (negative)
30270:         ch = *++s;
30270: 
30270:     if (!JS7_ISDEC(ch))
30270:         return id;
30270: 
30270:     size_t n = str->flatLength() - negative;
48470:     if (n > sizeof(JSBOXEDWORD_INT_MAX_STRING) - 1)
30270:         return id;
30270: 
30270:     const jschar *cp = s;
30270:     const jschar *end = s + n;
30270: 
    1:     jsuint index = JS7_UNDEC(*cp++);
    1:     jsuint oldIndex = 0;
    1:     jsuint c = 0;
    1: 
    1:     if (index != 0) {
    1:         while (JS7_ISDEC(*cp)) {
    1:             oldIndex = index;
    1:             c = JS7_UNDEC(*cp);
    1:             index = 10 * index + c;
    1:             cp++;
    1:         }
    1:     }
22608: 
22608:     /*
22608:      * Non-integer indexes can't be represented as integers.  Also, distinguish
48470:      * index "-0" from "0", because JSBOXEDWORD_INT cannot.
22608:      */
22608:     if (cp != end || (negative && index == 0))
22608:         return id;
30270: 
55493:     if (negative) {
55493:         if (oldIndex < -(JSID_INT_MIN / 10) ||
55493:             (oldIndex == -(JSID_INT_MIN / 10) && c <= (-JSID_INT_MIN % 10)))
55493:         {
57776:             id = INT_TO_JSID(-jsint(index));
55493:         }
55493:     } else {
48470:         if (oldIndex < JSID_INT_MAX / 10 ||
55493:             (oldIndex == JSID_INT_MAX / 10 && c <= (JSID_INT_MAX % 10)))
55493:         {
55493:             id = INT_TO_JSID(jsint(index));
55493:         }
    1:     }
30270: 
    1:     return id;
    1: }
    1: 
    1: static JSBool
11377: PurgeProtoChain(JSContext *cx, JSObject *obj, jsid id)
    1: {
52503:     const Shape *shape;
11377: 
11377:     while (obj) {
40430:         if (!obj->isNative()) {
39928:             obj = obj->getProto();
11377:             continue;
11377:         }
52503:         shape = obj->nativeLookup(id);
52503:         if (shape) {
18308:             PCMETER(JS_PROPERTY_CACHE(cx).pcpurges++);
52503:             obj->shadowingShapeChange(cx, *shape);
27019: 
39930:             if (!obj->getParent()) {
27019:                 /*
27019:                  * All scope chains end in a global object, so this will change
27019:                  * the global shape. jstracer.cpp assumes that the global shape
27019:                  * never changes on trace, so we must deep-bail here.
27019:                  */
37741:                 LeaveTrace(cx);
27019:             }
11377:             return JS_TRUE;
11377:         }
32603:         obj = obj->getProto();
11377:     }
    1:     return JS_FALSE;
11377: }
11377: 
25936: void
25936: js_PurgeScopeChainHelper(JSContext *cx, JSObject *obj, jsid id)
    1: {
32603:     JS_ASSERT(obj->isDelegate());
32603:     PurgeProtoChain(cx, obj->getProto(), id);
28397: 
28397:     /*
28397:      * We must purge the scope chain only for Call objects as they are the only
28397:      * kind of cacheable non-global object that can gain properties after outer
28397:      * properties with the same names have been cached or traced. Call objects
28397:      * may gain such properties via eval introducing new vars; see bug 490364.
28397:      */
52503:     if (obj->isCall()) {
39930:         while ((obj = obj->getParent()) != NULL) {
11377:             if (PurgeProtoChain(cx, obj, id))
28397:                 break;
28397:         }
11377:     }
    1: }
    1: 
52503: const Shape *
    1: js_AddNativeProperty(JSContext *cx, JSObject *obj, jsid id,
62395:                      PropertyOp getter, StrictPropertyOp setter, uint32 slot,
    1:                      uintN attrs, uintN flags, intN shortid)
    1: {
52503:     JS_ASSERT(!(flags & Shape::METHOD));
32658: 
11377:     /*
11377:      * Purge the property cache of now-shadowed id in obj's scope chain. Do
11377:      * this optimistically (assuming no failure below) before locking obj, so
11377:      * we can lock the shadowed scope.
11377:      */
25936:     js_PurgeScopeChain(cx, obj, id);
11377: 
56567:     if (!obj->ensureClassReservedSlots(cx))
56567:         return NULL;
56567: 
11377:     /* Convert string indices to integers if appropriate. */
30270:     id = js_CheckForStringIndex(id);
56567:     return obj->putProperty(cx, id, getter, setter, slot, attrs, flags, shortid);
52503: }
52503: 
52503: const Shape *
    1: js_ChangeNativePropertyAttrs(JSContext *cx, JSObject *obj,
52503:                              const Shape *shape, uintN attrs, uintN mask,
62395:                              PropertyOp getter, StrictPropertyOp setter)
    1: {
56567:     if (!obj->ensureClassReservedSlots(cx))
56567:         return NULL;
62790: 
62790:     /*
62790:      * Check for freezing an object with shape-memoized methods here, on a
62790:      * shape-by-shape basis. Note that getter may be a pun of the method's
62790:      * joined function object value, to indicate "no getter change". In this
62790:      * case we must null getter to get the desired PropertyStub behavior.
62790:      */
62790:     if ((attrs & JSPROP_READONLY) && shape->isMethod()) {
62790:         JSObject *funobj = &shape->methodObject();
62790:         Value v = ObjectValue(*funobj);
62790: 
62790:         shape = obj->methodReadBarrier(cx, *shape, &v);
62790:         if (!shape)
62790:             return NULL;
62790: 
62790:         if (CastAsObject(getter) == funobj) {
62790:             JS_ASSERT(!(attrs & JSPROP_GETTER));
62790:             getter = NULL;
62790:         }
62790:     }
62790: 
56567:     return obj->changeProperty(cx, shape, attrs, mask, getter, setter);
    1: }
    1: 
    1: JSBool
48470: js_DefineProperty(JSContext *cx, JSObject *obj, jsid id, const Value *value,
62395:                   PropertyOp getter, StrictPropertyOp setter, uintN attrs)
48470: {
48470:     return js_DefineNativeProperty(cx, obj, id, *value, getter, setter, attrs,
32573:                                    0, 0, NULL);
    1: }
    1: 
    1: /*
    1:  * Backward compatibility requires allowing addProperty hooks to mutate the
53650:  * nominal initial value of a slotful property, while GC safety wants that
    1:  * value to be stored before the call-out through the hook.  Optimize to do
    1:  * both while saving cycles for classes that stub their addProperty hook.
    1:  */
32658: static inline bool
52503: CallAddPropertyHook(JSContext *cx, Class *clasp, JSObject *obj, const Shape *shape, Value *vp)
48470: {
48470:     if (clasp->addProperty != PropertyStub) {
48470:         Value nominal = *vp;
32658: 
59898:         if (!CallJSPropertyOp(cx, clasp->addProperty, obj, shape->id, vp))
32658:             return false;
32658:         if (*vp != nominal) {
52503:             if (obj->containsSlot(shape->slot))
56567:                 obj->nativeSetSlot(shape->slot, *vp);
32658:         }
32658:     }
32658:     return true;
32658: }
    1: 
27932: JSBool
48470: js_DefineNativeProperty(JSContext *cx, JSObject *obj, jsid id, const Value &value,
62395:                         PropertyOp getter, StrictPropertyOp setter, uintN attrs,
24852:                         uintN flags, intN shortid, JSProperty **propp,
28397:                         uintN defineHow /* = 0 */)
    1: {
32658:     JS_ASSERT((defineHow & ~(JSDNP_CACHE_RESULT | JSDNP_DONT_PURGE | JSDNP_SET_METHOD)) == 0);
37741:     LeaveTraceIfGlobalObject(cx, obj);
27492: 
11377:     /* Convert string indices to integers if appropriate. */
30270:     id = js_CheckForStringIndex(id);
    1: 
    1:     /*
    1:      * If defining a getter or setter, we must check for its counterpart and
    1:      * update the attributes and property ops.  A getter or setter is really
    1:      * only half of a property.
    1:      */
62034:     const Shape *shape = NULL;
    1:     if (attrs & (JSPROP_GETTER | JSPROP_SETTER)) {
    1:         JSObject *pobj;
    1:         JSProperty *prop;
    1: 
    1:         /*
    1:          * If JS_THREADSAFE and id is found, js_LookupProperty returns with
52503:          * shape non-null and pobj locked.  If pobj == obj, the property is
    1:          * already in obj and obj has its own (mutable) scope.  So if we are
    1:          * defining a getter whose setter was already defined, or vice versa,
52503:          * finish the job via obj->changeProperty, and refresh the property
52503:          * cache line for (obj, id) to map shape.
    1:          */
    1:         if (!js_LookupProperty(cx, obj, id, &pobj, &prop))
27932:             return JS_FALSE;
52503:         shape = (Shape *) prop;
52503:         if (shape && pobj == obj && shape->isAccessorDescriptor()) {
52503:             shape = obj->changeProperty(cx, shape, attrs,
33152:                                         JSPROP_GETTER | JSPROP_SETTER,
    1:                                         (attrs & JSPROP_GETTER)
    1:                                         ? getter
52503:                                         : shape->getter(),
    1:                                         (attrs & JSPROP_SETTER)
    1:                                         ? setter
52503:                                         : shape->setter());
    1: 
52503:             if (!shape)
56567:                 return false;
14646:         } else if (prop) {
    1:             prop = NULL;
52503:             shape = NULL;
    1:         }
    1:     }
    1: 
11377:     /*
28397:      * Purge the property cache of any properties named by id that are about
28397:      * to be shadowed in obj's scope chain unless it is known a priori that it
28397:      * is not possible. We do this before locking obj to avoid nesting locks.
28312:      */
28397:     if (!(defineHow & JSDNP_DONT_PURGE))
28312:         js_PurgeScopeChain(cx, obj, id);
28312: 
28312:     /*
28312:      * Check whether a readonly property or setter is being defined on a known
28312:      * prototype object. See the comment in jscntxt.h before protoHazardShape's
28312:      * member declaration.
11377:      */
32603:     if (obj->isDelegate() && (attrs & (JSPROP_READONLY | JSPROP_SETTER)))
62077:         cx->runtime->protoHazardShape = js_GenerateShape(cx);
11377: 
    1:     /* Use the object's class getter and setter by default. */
62034:     Class *clasp = obj->getClass();
32658:     if (!(defineHow & JSDNP_SET_METHOD)) {
41860:         if (!getter && !(attrs & JSPROP_GETTER))
    1:             getter = clasp->getProperty;
41860:         if (!setter && !(attrs & JSPROP_SETTER))
    1:             setter = clasp->setProperty;
32658:     }
    1: 
    1:     /* Get obj's own scope if it has one, or create a new one for obj. */
52503:     if (!obj->ensureClassReservedSlots(cx))
56567:         return false;
    1: 
62790:     /*
62790:      * Make a local copy of value, in case a method barrier needs to update the
62790:      * value to define, and just so addProperty can mutate its inout parameter.
62790:      */
62790:     Value valueCopy = value;
62790:     bool adding = false;
62790: 
52503:     if (!shape) {
18750:         /* Add a new property, or replace an existing one of the same id. */
32658:         if (defineHow & JSDNP_SET_METHOD) {
32658:             JS_ASSERT(clasp == &js_ObjectClass);
48470:             JS_ASSERT(IsFunctionObject(value));
32658:             JS_ASSERT(!(attrs & (JSPROP_GETTER | JSPROP_SETTER)));
32658:             JS_ASSERT(!getter && !setter);
32658: 
48470:             JSObject *funobj = &value.toObject();
32658:             if (FUN_OBJECT(GET_FUNCTION_PRIVATE(cx, funobj)) == funobj) {
52503:                 flags |= Shape::METHOD;
41860:                 getter = CastAsPropertyOp(funobj);
32658:             }
32658:         }
32658: 
62034:         if (const Shape *existingShape = obj->nativeLookup(id)) {
62034:             if (existingShape->hasSlot())
62034:                 AbortRecordingIfUnexpectedGlobalWrite(cx, obj, existingShape->slot);
62790: 
62790:             if (existingShape->isMethod() &&
62790:                 ObjectValue(existingShape->methodObject()) == valueCopy)
62790:             {
62790:                 /*
62790:                  * Redefining an existing shape-memoized method object without
62790:                  * changing the property's value, perhaps to change attributes.
62790:                  * Clone now via the method read barrier.
62790:                  *
62790:                  * But first, assert that our caller is not trying to preserve
62790:                  * the joined function object value as the getter object for
62790:                  * the redefined property. The joined function object cannot
62790:                  * yet have leaked, so only an internal code path could attempt
62790:                  * such a thing. Any such path would be a bug to fix.
62790:                  */
62790:                 JS_ASSERT(existingShape->getter() != getter);
62790: 
62790:                 if (!obj->methodReadBarrier(cx, *existingShape, &valueCopy))
62936:                     return false;
62790:             }
62034:         } else {
62790:             adding = true;
62034:         }
62034: 
52503:         uint32 oldShape = obj->shape();
52503:         shape = obj->putProperty(cx, id, getter, setter, SHAPE_INVALID_SLOT,
35334:                                  attrs, flags, shortid);
52503:         if (!shape)
56567:             return false;
41851: 
41851:         /*
62790:          * If shape is a joined method, the above call to putProperty suffices
62790:          * to update the object's shape id if need be (because the shape's hash
62790:          * identity includes the method value).
62790:          *
62790:          * But if scope->branded(), the object's shape id may not have changed
62790:          * and we may be overwriting a cached function-valued property (note
62790:          * how methodWriteBarrier checks previous vs. would-be current value).
62790:          * See bug 560998.
41851:          */
60797:         if (obj->shape() == oldShape && obj->branded() && shape->slot != SHAPE_INVALID_SLOT) {
60797: #ifdef DEBUG
60797:             const Shape *newshape =
60797: #endif
62790:                 obj->methodWriteBarrier(cx, *shape, valueCopy);
60797:             JS_ASSERT(newshape == shape);
60797:         }
14646:     }
    1: 
62790:     /* Store valueCopy before calling addProperty, in case the latter GC's. */
62034:     if (obj->containsSlot(shape->slot))
62790:         obj->nativeSetSlot(shape->slot, valueCopy);
    1: 
    1:     /* XXXbe called with lock held */
52503:     if (!CallAddPropertyHook(cx, clasp, obj, shape, &valueCopy)) {
52503:         obj->removeProperty(cx, id);
56567:         return false;
32658:     }
    1: 
28397:     if (defineHow & JSDNP_CACHE_RESULT) {
59009:         JS_ASSERT_NOT_ON_TRACE(cx);
62790:         if (adding) {
59009:             JS_PROPERTY_CACHE(cx).fill(cx, obj, 0, 0, obj, shape, true);
60780:             TRACE_1(AddProperty, obj);
59009:         }
24852:     }
    1:     if (propp)
52503:         *propp = (JSProperty *) shape;
56567:     return true;
56567: 
58283: #ifdef JS_TRACER
60780:   error: // TRACE_1 jumps here on error.
58283: #endif
56567:     return false;
    1: }
    1: 
16072: #define SCOPE_DEPTH_ACCUM(bs,val)                                             \
16072:     JS_SCOPE_DEPTH_METERING(JS_BASIC_STATS_ACCUM(bs, val))
10217: 
    1: /*
43260:  * Call obj's resolve hook. obj is a native object and the caller holds its
43260:  * scope lock.
43260:  *
43260:  * cx, start, id, and flags are the parameters initially passed to the ongoing
43260:  * lookup; objp and propp are its out parameters. obj is an object along
43260:  * start's prototype chain.
43260:  *
43260:  * There are four possible outcomes:
43260:  *
43260:  *   - On failure, report an error or exception, unlock obj, and return false.
43260:  *
43260:  *   - If we are alrady resolving a property of *curobjp, set *recursedp = true,
43260:  *     unlock obj, and return true.
43260:  *
43260:  *   - If the resolve hook finds or defines the sought property, set *objp and
43260:  *     *propp appropriately, set *recursedp = false, and return true with *objp's
43260:  *     lock held.
43260:  *
43260:  *   - Otherwise no property was resolved. Set *propp = NULL and *recursedp = false
43260:  *     and return true.
43260:  */
43260: static JSBool
43260: CallResolveOp(JSContext *cx, JSObject *start, JSObject *obj, jsid id, uintN flags,
43260:               JSObject **objp, JSProperty **propp, bool *recursedp)
43260: {
48470:     Class *clasp = obj->getClass();
43260:     JSResolveOp resolve = clasp->resolve;
43260: 
43260:     /*
43260:      * Avoid recursion on (obj, id) already being resolved on cx.
43260:      *
    1:      * Once we have successfully added an entry for (obj, key) to
    1:      * cx->resolvingTable, control must go through cleanup: before
    1:      * returning.  But note that JS_DHASH_ADD may find an existing
    1:      * entry, in which case we bail to suppress runaway recursion.
    1:      */
43260:     JSResolvingKey key = {obj, id};
43260:     JSResolvingEntry *entry;
56567:     if (!js_StartResolving(cx, &key, JSRESFLAG_LOOKUP, &entry))
43260:         return false;
    1:     if (!entry) {
    1:         /* Already resolving id in obj -- suppress recursion. */
43260:         *recursedp = true;
43260:         return true;
43260:     }
43260:     uint32 generation = cx->resolvingTable->generation;
43260:     *recursedp = false;
43260: 
    1:     *propp = NULL;
    1: 
43260:     JSBool ok;
52503:     const Shape *shape = NULL;
    1:     if (clasp->flags & JSCLASS_NEW_RESOLVE) {
43260:         JSNewResolveOp newresolve = (JSNewResolveOp)resolve;
23435:         if (flags == JSRESOLVE_INFER)
52503:             flags = js_InferFlags(cx, 0);
43260:         JSObject *obj2 = (clasp->flags & JSCLASS_NEW_RESOLVE_GETS_START) ? start : NULL;
    1: 
40840:         {
    1:             /* Protect id and all atoms from a GC nested in resolve. */
40840:             AutoKeepAtoms keep(cx->runtime);
48470:             ok = newresolve(cx, obj, id, flags, &obj2);
40840:         }
    1:         if (!ok)
    1:             goto cleanup;
    1: 
    1:         if (obj2) {
56567:             /* Resolved: lookup id again for backward compatibility. */
40430:             if (!obj2->isNative()) {
    1:                 /* Whoops, newresolve handed back a foreign obj2. */
    1:                 JS_ASSERT(obj2 != obj);
31501:                 ok = obj2->lookupProperty(cx, id, objp, propp);
    1:                 if (!ok || *propp)
    1:                     goto cleanup;
    1:             } else {
    1:                 /*
52503:                  * Require that obj2 not be empty now, as we do for old-style
52503:                  * resolve.  If it doesn't, then id was not truly resolved, and
52503:                  * we'll find it in the proto chain, or miss it if obj2's proto
52503:                  * is not on obj's proto chain.  That last case is a "too bad!"
52503:                  * case.
    1:                  */
52503:                 if (!obj2->nativeEmpty())
52503:                     shape = obj2->nativeLookup(id);
52503:             }
52503:             if (shape) {
52503:                 JS_ASSERT(!obj2->nativeEmpty());
    1:                 obj = obj2;
    1:             }
    1:         }
    1:     } else {
    1:         /*
52503:          * Old resolve always requires id re-lookup if obj is not empty after
52503:          * resolve returns.
    1:          */
48470:         ok = resolve(cx, obj, id);
    1:         if (!ok)
    1:             goto cleanup;
40430:         JS_ASSERT(obj->isNative());
52503:         if (!obj->nativeEmpty())
52503:             shape = obj->nativeLookup(id);
    1:     }
    1: 
    1: cleanup:
52503:     if (ok && shape) {
43260:         *objp = obj;
52503:         *propp = (JSProperty *) shape;
43260:     }
    1:     js_StopResolving(cx, &key, JSRESFLAG_LOOKUP, entry, generation);
43260:     return ok;
43260: }
43260: 
55535: static JS_ALWAYS_INLINE int
55535: js_LookupPropertyWithFlagsInline(JSContext *cx, JSObject *obj, jsid id, uintN flags,
43260:                                  JSObject **objp, JSProperty **propp)
43260: {
56740:     /* We should not get string indices which aren't already integers here. */
56740:     JS_ASSERT(id == js_CheckForStringIndex(id));
43260: 
43260:     /* Search scopes starting with obj and following the prototype link. */
43260:     JSObject *start = obj;
43260:     int protoIndex;
43260:     for (protoIndex = 0; ; protoIndex++) {
52503:         const Shape *shape = obj->nativeLookup(id);
52503:         if (shape) {
10217:             SCOPE_DEPTH_ACCUM(&cx->runtime->protoLookupDepthStats, protoIndex);
30645:             *objp = obj;
52503:             *propp = (JSProperty *) shape;
10217:             return protoIndex;
    1:         }
    1: 
43260:         /* Try obj's class resolve hook if id was not found in obj's scope. */
52503:         if (!shape && obj->getClass()->resolve != JS_ResolveStub) {
43260:             bool recursed;
43260:             if (!CallResolveOp(cx, start, obj, id, flags, objp, propp, &recursed))
43260:                 return -1;
43260:             if (recursed)
43260:                 break;
43260:             if (*propp) {
43260:                 /* Recalculate protoIndex in case it was resolved on some other object. */
43260:                 protoIndex = 0;
43260:                 for (JSObject *proto = start; proto && proto != *objp; proto = proto->getProto())
43260:                     protoIndex++;
43260:                 SCOPE_DEPTH_ACCUM(&cx->runtime->protoLookupDepthStats, protoIndex);
43260:                 return protoIndex;
43260:             }
43260:         }
43260: 
43260:         JSObject *proto = obj->getProto();
    1:         if (!proto)
    1:             break;
40430:         if (!proto->isNative()) {
31501:             if (!proto->lookupProperty(cx, id, objp, propp))
10217:                 return -1;
60172: #ifdef DEBUG
60172:             /*
60172:              * Non-native objects must have either non-native lookup results,
60172:              * or else native results from the non-native's prototype chain.
60172:              *
60172:              * See JSStackFrame::getValidCalleeObject, where we depend on this
60172:              * fact to force a prototype-delegated joined method accessed via
60172:              * arguments.callee through the delegating |this| object's method
60172:              * read barrier.
60172:              */
60172:             if (*propp && (*objp)->isNative()) {
60172:                 while ((proto = proto->getProto()) != *objp)
60172:                     JS_ASSERT(proto);
60172:             }
60172: #endif
12495:             return protoIndex + 1;
10217:         }
30645: 
    1:         obj = proto;
    1:     }
    1: 
    1:     *objp = NULL;
    1:     *propp = NULL;
10217:     return protoIndex;
10217: }
10217: 
56740: JS_FRIEND_API(JSBool)
56740: js_LookupProperty(JSContext *cx, JSObject *obj, jsid id, JSObject **objp,
56740:                   JSProperty **propp)
56740: {
56740:     /* Convert string indices to integers if appropriate. */
56740:     id = js_CheckForStringIndex(id);
56740: 
56740:     return js_LookupPropertyWithFlagsInline(cx, obj, id, cx->resolveFlags, objp, propp) >= 0;
56740: }
56740: 
55535: int
55535: js_LookupPropertyWithFlags(JSContext *cx, JSObject *obj, jsid id, uintN flags,
55535:                            JSObject **objp, JSProperty **propp)
55535: {
56740:     /* Convert string indices to integers if appropriate. */
56740:     id = js_CheckForStringIndex(id);
56740: 
55535:     return js_LookupPropertyWithFlagsInline(cx, obj, id, flags, objp, propp);
55535: }
55535: 
40362: PropertyCacheEntry *
27575: js_FindPropertyHelper(JSContext *cx, jsid id, JSBool cacheResult,
27575:                       JSObject **objp, JSObject **pobjp, JSProperty **propp)
    1: {
27539:     JSObject *scopeChain, *obj, *parent, *pobj;
40362:     PropertyCacheEntry *entry;
11377:     int scopeIndex, protoIndex;
    1:     JSProperty *prop;
27575: 
27575:     JS_ASSERT_IF(cacheResult, !JS_ON_TRACE(cx));
53840:     scopeChain = &js_GetTopStackFrame(cx)->scopeChain();
27539: 
27539:     /* Scan entries on the scope chain that we can cache across. */
27575:     entry = JS_NO_PROP_CACHE_FILL;
27539:     obj = scopeChain;
39930:     parent = obj->getParent();
27539:     for (scopeIndex = 0;
27539:          parent
63085:          ? IsCacheableNonGlobalScope(obj)
48622:          : !obj->getOps()->lookupProperty;
27539:          ++scopeIndex) {
11377:         protoIndex =
19712:             js_LookupPropertyWithFlags(cx, obj, id, cx->resolveFlags,
19712:                                        &pobj, &prop);
21979:         if (protoIndex < 0)
27575:             return NULL;
27539: 
27539:         if (prop) {
27539: #ifdef DEBUG
27539:             if (parent) {
48470:                 Class *clasp = obj->getClass();
40430:                 JS_ASSERT(pobj->isNative());
40826:                 JS_ASSERT(pobj->getClass() == clasp);
27539:                 if (clasp == &js_BlockClass) {
27539:                     /*
53650:                      * A block instance on the scope chain is immutable and it
53650:                      * shares its shapes with its compile-time prototype.
27539:                      */
53650:                     JS_ASSERT(pobj == obj);
53650:                     JS_ASSERT(pobj->isClonedBlock());
53650:                     JS_ASSERT(protoIndex == 0);
11377:                 } else {
27539:                     /* Call and DeclEnvClass objects have no prototypes. */
39928:                     JS_ASSERT(!obj->getProto());
27539:                     JS_ASSERT(protoIndex == 0);
27539:                 }
42726:             } else {
42726:                 JS_ASSERT(obj->isNative());
27539:             }
27539: #endif
42726:             /*
42726:              * We must check if pobj is native as a global object can have
42726:              * non-native prototype.
42726:              */
42726:             if (cacheResult && pobj->isNative()) {
42726:                 entry = JS_PROPERTY_CACHE(cx).fill(cx, scopeChain, scopeIndex,
42726:                                                    protoIndex, pobj,
52503:                                                    (Shape *) prop);
27539:             }
36418:             SCOPE_DEPTH_ACCUM(&cx->runtime->scopeSearchDepthStats, scopeIndex);
27539:             goto out;
27539:         }
27539: 
27539:         if (!parent) {
27539:             pobj = NULL;
27539:             goto out;
27539:         }
27539:         obj = parent;
39930:         parent = obj->getParent();
27539:     }
27539: 
27539:     for (;;) {
31501:         if (!obj->lookupProperty(cx, id, &pobj, &prop))
27575:             return NULL;
27539:         if (prop) {
11377:             PCMETER(JS_PROPERTY_CACHE(cx).nofills++);
27539:             goto out;
27539:         }
27539: 
27539:         /*
27539:          * We conservatively assume that a resolve hook could mutate the scope
31501:          * chain during JSObject::lookupProperty. So we read parent here again.
27539:          */
39930:         parent = obj->getParent();
27539:         if (!parent) {
27539:             pobj = NULL;
27539:             break;
27539:         }
27539:         obj = parent;
27539:     }
27539: 
27539:   out:
27539:     JS_ASSERT(!!pobj == !!prop);
    1:     *objp = obj;
    1:     *pobjp = pobj;
    1:     *propp = prop;
27575:     return entry;
    1: }
    1: 
57125: /*
57125:  * On return, if |*pobjp| is a native object, then |*propp| is a |Shape *|.
57125:  * Otherwise, its type and meaning depends on the host object's implementation.
57125:  */
    1: JS_FRIEND_API(JSBool)
    1: js_FindProperty(JSContext *cx, jsid id, JSObject **objp, JSObject **pobjp,
    1:                 JSProperty **propp)
    1: {
27575:     return !!js_FindPropertyHelper(cx, id, false, objp, pobjp, propp);
    1: }
    1: 
27319: JSObject *
27575: js_FindIdentifierBase(JSContext *cx, JSObject *scopeChain, jsid id)
    1: {
27237:     /*
27237:      * This function should not be called for a global object or from the
27237:      * trace and should have a valid cache entry for native scopeChain.
27237:      */
39930:     JS_ASSERT(scopeChain->getParent());
27237:     JS_ASSERT(!JS_ON_TRACE(cx));
27237: 
27319:     JSObject *obj = scopeChain;
27319: 
27237:     /*
27319:      * Loop over cacheable objects on the scope chain until we find a
27319:      * property. We also stop when we reach the global object skipping any
27319:      * farther checks or lookups. For details see the JSOP_BINDNAME case of
27319:      * js_Interpret.
41775:      *
63085:      * The test order here matters because IsCacheableNonGlobalScope
41775:      * must not be passed a global object (i.e. one with null parent).
27237:      */
41775:     for (int scopeIndex = 0;
63085:          !obj->getParent() || IsCacheableNonGlobalScope(obj);
41775:          scopeIndex++) {
27237:         JSObject *pobj;
27236:         JSProperty *prop;
27319:         int protoIndex = js_LookupPropertyWithFlags(cx, obj, id,
27319:                                                     cx->resolveFlags,
27237:                                                     &pobj, &prop);
27237:         if (protoIndex < 0)
27237:             return NULL;
27237:         if (prop) {
42726:             if (!pobj->isNative()) {
42726:                 JS_ASSERT(!obj->getParent());
42726:                 return obj;
42726:             }
42726:             JS_ASSERT_IF(obj->getParent(), pobj->getClass() == obj->getClass());
27575: #ifdef DEBUG
40362:             PropertyCacheEntry *entry =
27575: #endif
40362:                 JS_PROPERTY_CACHE(cx).fill(cx, scopeChain, scopeIndex, protoIndex, pobj,
52503:                                            (Shape *) prop);
27575:             JS_ASSERT(entry);
27237:             return obj;
27237:         }
27237: 
41775:         JSObject *parent = obj->getParent();
41775:         if (!parent)
27237:             return obj;
41775:         obj = parent;
27237:     }
27319: 
27319:     /* Loop until we find a property or reach the global object. */
27237:     do {
27237:         JSObject *pobj;
27237:         JSProperty *prop;
31501:         if (!obj->lookupProperty(cx, id, &pobj, &prop))
    1:             return NULL;
56567:         if (prop)
27237:             break;
27319: 
27319:         /*
27319:          * We conservatively assume that a resolve hook could mutate the scope
31501:          * chain during JSObject::lookupProperty. So we must check if parent is
31501:          * not null here even if it wasn't before the lookup.
27319:          */
39930:         JSObject *parent = obj->getParent();
27319:         if (!parent)
27319:             break;
27237:         obj = parent;
39930:     } while (obj->getParent());
    1:     return obj;
    1: }
    1: 
55535: static JS_ALWAYS_INLINE JSBool
57739: js_NativeGetInline(JSContext *cx, JSObject *receiver, JSObject *obj, JSObject *pobj,
57739:                    const Shape *shape, uintN getHow, Value *vp)
    1: {
37741:     LeaveTraceIfGlobalObject(cx, pobj);
27490: 
27490:     uint32 slot;
27490:     int32 sample;
27490: 
40430:     JS_ASSERT(pobj->isNative());
52503: 
52503:     slot = shape->slot;
55746:     if (slot != SHAPE_INVALID_SLOT) {
56567:         *vp = pobj->nativeGetSlot(slot);
55746:         JS_ASSERT(!vp->isMagic());
55746:     } else {
48470:         vp->setUndefined();
55746:     }
52503:     if (shape->hasDefaultGetter())
32658:         return true;
32658: 
52503:     if (JS_UNLIKELY(shape->isMethod()) && (getHow & JSGET_NO_METHOD_BARRIER)) {
52503:         JS_ASSERT(&shape->methodObject() == &vp->toObject());
32658:         return true;
32658:     }
27490: 
27490:     sample = cx->runtime->propertyRemovals;
52503:     {
52503:         AutoShapeRooter tvr(cx, shape);
48470:         AutoObjectRooter tvr2(cx, pobj);
57739:         if (!shape->get(cx, receiver, obj, pobj, vp))
32658:             return false;
40221:     }
52503: 
52503:     if (pobj->containsSlot(slot) &&
    1:         (JS_LIKELY(cx->runtime->propertyRemovals == sample) ||
52503:          pobj->nativeContains(*shape))) {
56567:         if (!pobj->methodWriteBarrier(cx, *shape, *vp))
32658:             return false;
56567:         pobj->nativeSetSlot(slot, *vp);
32658:     }
32658: 
32658:     return true;
    1: }
    1: 
    1: JSBool
55535: js_NativeGet(JSContext *cx, JSObject *obj, JSObject *pobj, const Shape *shape, uintN getHow,
55535:              Value *vp)
55535: {
57739:     return js_NativeGetInline(cx, obj, obj, pobj, shape, getHow, vp);
55535: }
55535: 
55535: JSBool
62395: js_NativeSet(JSContext *cx, JSObject *obj, const Shape *shape, bool added, bool strict, Value *vp)
    1: {
37741:     LeaveTraceIfGlobalObject(cx, obj);
27490: 
27490:     uint32 slot;
27490:     int32 sample;
27490: 
40430:     JS_ASSERT(obj->isNative());
52503: 
52503:     slot = shape->slot;
52503:     if (slot != SHAPE_INVALID_SLOT) {
56567:         JS_ASSERT(obj->containsSlot(slot));
27490: 
52503:         /* If shape has a stub setter, keep obj locked and just store *vp. */
52503:         if (shape->hasDefaultSetter()) {
62034:             if (!added) {
62034:                 AbortRecordingIfUnexpectedGlobalWrite(cx, obj, slot);
62381: 
62381:                 /* FIXME: This should pass *shape, not slot, but see bug 630354. */
62381:                 if (!obj->methodWriteBarrier(cx, slot, *vp))
32658:                     return false;
62034:             }
56567:             obj->nativeSetSlot(slot, *vp);
32658:             return true;
32658:         }
27490:     } else {
    1:         /*
    1:          * Allow API consumers to create shared properties with stub setters.
36491:          * Such properties effectively function as data descriptors which are
36491:          * not writable, so attempting to set such a property should do nothing
36491:          * or throw if we're in strict mode.
    1:          */
52503:         if (!shape->hasGetterValue() && shape->hasDefaultSetter())
36491:             return js_ReportGetterOnlyAssignment(cx);
    1:     }
27490: 
27490:     sample = cx->runtime->propertyRemovals;
52503:     {
52503:         AutoShapeRooter tvr(cx, shape);
62395:         if (!shape->set(cx, obj, strict, vp))
32658:             return false;
60552: 
60552:         JS_ASSERT_IF(!obj->inDictionaryMode(), shape->slot == slot);
60552:         slot = shape->slot;
40221:     }
    1: 
52503:     if (obj->containsSlot(slot) &&
    1:         (JS_LIKELY(cx->runtime->propertyRemovals == sample) ||
52503:          obj->nativeContains(*shape))) {
62034:         if (!added) {
62034:             AbortRecordingIfUnexpectedGlobalWrite(cx, obj, slot);
62034:             if (!obj->methodWriteBarrier(cx, *shape, *vp))
32658:                 return false;
62034:         }
56567:         obj->setSlot(slot, *vp);
32658:     }
32658: 
32658:     return true;
    1: }
    1: 
54177: static JS_ALWAYS_INLINE bool
56817: js_GetPropertyHelperWithShapeInline(JSContext *cx, JSObject *obj, JSObject *receiver, jsid id,
54172:                                     uintN getHow, Value *vp,
54172:                                     const Shape **shapeOut, JSObject **holderOut)
    1: {
25942:     JSObject *aobj, *obj2;
11377:     int protoIndex;
    1:     JSProperty *prop;
52503:     const Shape *shape;
    1: 
32658:     JS_ASSERT_IF(getHow & JSGET_CACHE_RESULT, !JS_ON_TRACE(cx));
32658: 
54172:     *shapeOut = NULL;
54172: 
11377:     /* Convert string indices to integers if appropriate. */
30270:     id = js_CheckForStringIndex(id);
11377: 
39928:     aobj = js_GetProtoIfDenseArray(obj);
55535:     /* This call site is hot -- use the always-inlined variant of js_LookupPropertyWithFlags(). */
55535:     protoIndex = js_LookupPropertyWithFlagsInline(cx, aobj, id, cx->resolveFlags,
19712:                                                   &obj2, &prop);
11377:     if (protoIndex < 0)
    1:         return JS_FALSE;
54172: 
54172:     *holderOut = obj2;
54172: 
    1:     if (!prop) {
48470:         vp->setUndefined();
48470: 
52503:         if (!CallJSPropertyOp(cx, obj->getClass()->getProperty, obj, id, vp))
    1:             return JS_FALSE;
    1: 
32658:         PCMETER(getHow & JSGET_CACHE_RESULT && JS_PROPERTY_CACHE(cx).nofills++);
11377: 
    1:         /*
    1:          * Give a strict warning if foo.bar is evaluated by a script for an
    1:          * object foo with no property named 'bar'.
    1:          */
24598:         jsbytecode *pc;
48470:         if (vp->isUndefined() && ((pc = js_GetCurrentBytecodePC(cx)) != NULL)) {
    1:             JSOp op;
    1:             uintN flags;
    1: 
 3164:             op = (JSOp) *pc;
25215:             if (op == JSOP_TRAP) {
25215:                 JS_ASSERT_NOT_ON_TRACE(cx);
53840:                 op = JS_GetTrapOpcode(cx, cx->fp()->script(), pc);
25215:             }
    1:             if (op == JSOP_GETXPROP) {
    1:                 flags = JSREPORT_ERROR;
    1:             } else {
61450:                 if (!cx->hasStrictOption() ||
31814:                     (op != JSOP_GETPROP && op != JSOP_GETELEM) ||
31911:                     js_CurrentPCIsInImacro(cx)) {
    1:                     return JS_TRUE;
    1:                 }
    1: 
    1:                 /*
    1:                  * XXX do not warn about missing __iterator__ as the function
    1:                  * may be called from JS_GetMethodById. See bug 355145.
    1:                  */
48470:                 if (JSID_IS_ATOM(id, cx->runtime->atomState.iteratorAtom))
    1:                     return JS_TRUE;
    1: 
25213:                 /* Do not warn about tests like (obj[prop] == undefined). */
25213:                 if (cx->resolveFlags == JSRESOLVE_INFER) {
37741:                     LeaveTrace(cx);
    1:                     pc += js_CodeSpec[op].length;
    1:                     if (Detecting(cx, pc))
    1:                         return JS_TRUE;
25213:                 } else if (cx->resolveFlags & JSRESOLVE_DETECTING) {
25213:                     return JS_TRUE;
25213:                 }
    1: 
    1:                 flags = JSREPORT_WARNING | JSREPORT_STRICT;
    1:             }
    1: 
    1:             /* Ok, bad undefined property reference: whine about it. */
    1:             if (!js_ReportValueErrorFlags(cx, flags, JSMSG_UNDEFINED_PROP,
48470:                                           JSDVG_IGNORE_STACK, IdToValue(id),
    1:                                           NULL, NULL, NULL)) {
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1:         return JS_TRUE;
    1:     }
    1: 
56817:     if (!obj2->isNative()) {
56817:         return obj2->isProxy()
56817:                ? JSProxy::get(cx, obj2, receiver, id, vp)
56817:                : obj2->getProperty(cx, id, vp);
56817:     }
    1: 
52503:     shape = (Shape *) prop;
54172:     *shapeOut = shape;
27490: 
32658:     if (getHow & JSGET_CACHE_RESULT) {
24499:         JS_ASSERT_NOT_ON_TRACE(cx);
52503:         JS_PROPERTY_CACHE(cx).fill(cx, aobj, 0, protoIndex, obj2, shape);
52503:     }
52503: 
55535:     /* This call site is hot -- use the always-inlined variant of js_NativeGet(). */
57739:     if (!js_NativeGetInline(cx, receiver, obj, obj2, shape, getHow, vp))
27932:         return JS_FALSE;
27932: 
27490:     return JS_TRUE;
    1: }
    1: 
56817: bool
56817: js_GetPropertyHelperWithShape(JSContext *cx, JSObject *obj, JSObject *receiver, jsid id,
54177:                               uint32 getHow, Value *vp,
54172:                               const Shape **shapeOut, JSObject **holderOut)
54172: {
56817:     return js_GetPropertyHelperWithShapeInline(cx, obj, receiver, id, getHow, vp,
56817:                                                shapeOut, holderOut);
54172: }
54172: 
55535: static JS_ALWAYS_INLINE JSBool
56817: js_GetPropertyHelperInline(JSContext *cx, JSObject *obj, JSObject *receiver, jsid id,
56817:                            uint32 getHow, Value *vp)
54172: {
54172:     const Shape *shape;
54172:     JSObject *holder;
56817:     return js_GetPropertyHelperWithShapeInline(cx, obj, receiver, id, getHow, vp, &shape, &holder);
56817: }
56817: 
56817: JSBool
56760: js_GetPropertyHelper(JSContext *cx, JSObject *obj, jsid id, uint32 getHow, Value *vp)
56760: {
56817:     return js_GetPropertyHelperInline(cx, obj, obj, id, getHow, vp);
56757: }
56757: 
56757: JSBool
56817: js_GetProperty(JSContext *cx, JSObject *obj, JSObject *receiver, jsid id, Value *vp)
    1: {
55535:     /* This call site is hot -- use the always-inlined variant of js_GetPropertyHelper(). */
56817:     return js_GetPropertyHelperInline(cx, obj, receiver, id, JSGET_METHOD_BARRIER, vp);
11377: }
11377: 
11377: JSBool
57734: js::GetPropertyDefault(JSContext *cx, JSObject *obj, jsid id, const Value &def, Value *vp)
56211: {
56211:     JSProperty *prop;
56211:     JSObject *obj2;
56211:     if (js_LookupPropertyWithFlags(cx, obj, id, JSRESOLVE_QUALIFIED, &obj2, &prop) < 0)
56211:         return false;
56211: 
56211:     if (!prop) {
56211:         *vp = def;
56211:         return true;
56211:     }
56211: 
56211:     return js_GetProperty(cx, obj2, id, vp);
56211: }
56211: 
56211: JSBool
48470: js_GetMethod(JSContext *cx, JSObject *obj, jsid id, uintN getHow, Value *vp)
26187: {
29913:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
29913: 
48622:     PropertyIdOp op = obj->getOps()->getProperty;
48622:     if (!op) {
48622: #if JS_HAS_XML_SUPPORT
48622:         JS_ASSERT(!obj->isXML());
48622: #endif
32658:         return js_GetPropertyHelper(cx, obj, id, getHow, vp);
32658:     }
39928:     JS_ASSERT_IF(getHow & JSGET_CACHE_RESULT, obj->isDenseArray());
26187: #if JS_HAS_XML_SUPPORT
42693:     if (obj->isXML())
26187:         return js_GetXMLMethod(cx, obj, id, vp);
26187: #endif
56817:     return op(cx, obj, obj, id, vp);
26187: }
26187: 
35308: JS_FRIEND_API(bool)
48470: js_CheckUndeclaredVarAssignment(JSContext *cx, JSString *propname)
27372: {
42717:     JSStackFrame *const fp = js_GetTopStackFrame(cx);
35308:     if (!fp)
35308:         return true;
35308: 
35308:     /* If neither cx nor the code is strict, then no check is needed. */
53840:     if (!(fp->isScriptFrame() && fp->script()->strictModeCode) &&
61450:         !cx->hasStrictOption()) {
35308:         return true;
35308:     }
35308: 
57812:     JSAutoByteString bytes(cx, propname);
57812:     return !!bytes &&
35308:            JS_ReportErrorFlagsAndNumber(cx,
35308:                                         (JSREPORT_WARNING | JSREPORT_STRICT
35308:                                          | JSREPORT_STRICT_MODE_ERROR),
27372:                                         js_GetErrorMessage, NULL,
57812:                                         JSMSG_UNDECLARED_VAR, bytes.ptr());
27372: }
27372: 
54587: bool
54587: JSObject::reportReadOnly(JSContext* cx, jsid id, uintN report)
54587: {
54587:     return js_ReportValueErrorFlags(cx, report, JSMSG_READ_ONLY,
48470:                                     JSDVG_IGNORE_STACK, IdToValue(id), NULL,
40832:                                     NULL, NULL);
40832: }
40832: 
54587: bool
54587: JSObject::reportNotConfigurable(JSContext* cx, jsid id, uintN report)
54587: {
54587:     return js_ReportValueErrorFlags(cx, report, JSMSG_CANT_DELETE,
54169:                                     JSDVG_IGNORE_STACK, IdToValue(id), NULL,
54169:                                     NULL, NULL);
54169: }
54169: 
54587: bool
54587: JSObject::reportNotExtensible(JSContext *cx, uintN report)
54587: {
54587:     return js_ReportValueErrorFlags(cx, report, JSMSG_OBJECT_NOT_EXTENSIBLE,
54587:                                     JSDVG_IGNORE_STACK, ObjectValue(*this),
54587:                                     NULL, NULL, NULL);
40832: }
40832: 
27932: JSBool
56760: js_SetPropertyHelper(JSContext *cx, JSObject *obj, jsid id, uintN defineHow,
54169:                      Value *vp, JSBool strict)
11377: {
11377:     int protoIndex;
    1:     JSObject *pobj;
    1:     JSProperty *prop;
52503:     const Shape *shape;
    1:     uintN attrs, flags;
    1:     intN shortid;
48470:     Class *clasp;
62395:     PropertyOp getter;
62395:     StrictPropertyOp setter;
27930:     bool added;
    1: 
41776:     JS_ASSERT((defineHow &
41776:                ~(JSDNP_CACHE_RESULT | JSDNP_SET_METHOD | JSDNP_UNQUALIFIED)) == 0);
32658:     if (defineHow & JSDNP_CACHE_RESULT)
28398:         JS_ASSERT_NOT_ON_TRACE(cx);
28398: 
11377:     /* Convert string indices to integers if appropriate. */
30270:     id = js_CheckForStringIndex(id);
11377: 
19712:     protoIndex = js_LookupPropertyWithFlags(cx, obj, id, cx->resolveFlags,
19712:                                             &pobj, &prop);
11377:     if (protoIndex < 0)
27932:         return JS_FALSE;
27237:     if (prop) {
56817:         if (!pobj->isNative()) {
56817:             if (pobj->isProxy()) {
56817:                 AutoPropertyDescriptorRooter pd(cx);
60344:                 if (!JSProxy::getPropertyDescriptor(cx, pobj, id, true, &pd))
56817:                     return false;
56817: 
63292:                 if (pd.attrs & JSPROP_SHARED)
63292:                     return CallSetter(cx, obj, id, pd.setter, pd.attrs, pd.shortid, strict, vp);
56817: 
56817:                 if (pd.attrs & JSPROP_READONLY) {
56817:                     if (strict)
56817:                         return obj->reportReadOnly(cx, id);
61450:                     if (cx->hasStrictOption())
56817:                         return obj->reportReadOnly(cx, id, JSREPORT_STRICT | JSREPORT_WARNING);
56817:                     return true;
56817:                 }
56817:             }
56817: 
    1:             prop = NULL;
56817:         }
27237:     } else {
27237:         /* We should never add properties to lexical blocks.  */
53650:         JS_ASSERT(!obj->isBlock());
27237: 
41774:         if (!obj->getParent() &&
41774:             (defineHow & JSDNP_UNQUALIFIED) &&
48470:             !js_CheckUndeclaredVarAssignment(cx, JSID_TO_STRING(id))) {
41774:             return JS_FALSE;
41774:         }
27237:     }
52503:     shape = (Shape *) prop;
    1: 
    1:     /*
52503:      * Now either shape is null, meaning id was not found in obj or one of its
52503:      * prototypes; or shape is non-null, meaning id was found directly in pobj.
    1:      */
    1:     attrs = JSPROP_ENUMERATE;
    1:     flags = 0;
    1:     shortid = 0;
40826:     clasp = obj->getClass();
    1:     getter = clasp->getProperty;
    1:     setter = clasp->setProperty;
    1: 
52503:     if (shape) {
40832:         /* ES5 8.12.4 [[Put]] step 2. */
52503:         if (shape->isAccessorDescriptor()) {
60780:             if (shape->hasDefaultSetter())
40832:                 return js_ReportGetterOnlyAssignment(cx);
40832:         } else {
52503:             JS_ASSERT(shape->isDataDescriptor());
52503: 
52503:             if (!shape->writable()) {
32658:                 PCMETER((defineHow & JSDNP_CACHE_RESULT) && JS_PROPERTY_CACHE(cx).rofills++);
41247: 
54169:                 /* Error in strict mode code, warn with strict option, otherwise do nothing. */
54169:                 if (strict)
54587:                     return obj->reportReadOnly(cx, id);
61450:                 if (cx->hasStrictOption())
54587:                     return obj->reportReadOnly(cx, id, JSREPORT_STRICT | JSREPORT_WARNING);
27932:                 return JS_TRUE;
    1:             }
40832:         }
    1: 
52503:         attrs = shape->attributes();
56760:         if (pobj != obj) {
    1:             /*
    1:              * We found id in a prototype object: prepare to share or shadow.
    1:              */
59898:             if (!shape->shadowable()) {
60780:                 if (defineHow & JSDNP_CACHE_RESULT)
52503:                     JS_PROPERTY_CACHE(cx).fill(cx, obj, 0, protoIndex, pobj, shape);
52503: 
52503:                 if (shape->hasDefaultSetter() && !shape->hasGetterValue())
27932:                     return JS_TRUE;
27932: 
62395:                 return shape->set(cx, obj, strict, vp);
    1:             }
    1: 
    1:             /*
59898:              * Preserve attrs except JSPROP_SHARED, getter, and setter when
59898:              * shadowing any property that has no slot (is shared). We must
59898:              * clear the shared attribute for the shadowing shape so that the
59898:              * property in obj that it defines has a slot to retain the value
59898:              * being set, in case the setter simply cannot operate on instances
59898:              * of obj's class by storing the value in some class-specific
59898:              * location.
59898:              *
59898:              * A subset of slotless shared properties is the set of properties
59898:              * with shortids, which must be preserved too. An old API requires
59898:              * that the property's getter and setter receive the shortid, not
59898:              * id, when they are called on the shadowing property that we are
52503:              * about to create in obj.
    1:              */
59898:             if (!shape->hasSlot()) {
59898:                 defineHow &= ~JSDNP_SET_METHOD;
52503:                 if (shape->hasShortID()) {
52503:                     flags = Shape::HAS_SHORTID;
52503:                     shortid = shape->shortid;
59898:                 }
59898:                 attrs &= ~JSPROP_SHARED;
52503:                 getter = shape->getter();
52503:                 setter = shape->setter();
59898:             } else {
59898:                 /* Restore attrs to the ECMA default for new properties. */
59898:                 attrs = JSPROP_ENUMERATE;
    1:             }
    1: 
    1:             /*
    1:              * Forget we found the proto-property now that we've copied any
    1:              * needed member values.
    1:              */
52503:             shape = NULL;
52503:         }
53577: 
59009:         JS_ASSERT_IF(shape && shape->isMethod(), pobj->hasMethodBarrier());
59009:         JS_ASSERT_IF(shape && shape->isMethod(),
59009:                      &pobj->getSlot(shape->slot).toObject() == &shape->methodObject());
59009:         if (shape && (defineHow & JSDNP_SET_METHOD)) {
59009:             /*
59009:              * JSOP_SETMETHOD is assigning to an existing own property. If it
59009:              * is an identical method property, do nothing. Otherwise downgrade
59009:              * to ordinary assignment. Either way, do not fill the property
59009:              * cache, as the interpreter has no fast path for these unusual
59009:              * cases.
59009:              */
59009:             bool identical = shape->isMethod() && &shape->methodObject() == &vp->toObject();
59009:             if (!identical) {
60797:                 shape = obj->methodShapeChange(cx, *shape);
60797:                 if (!shape)
59009:                     return false;
59009: 
53577:                 JSObject *funobj = &vp->toObject();
60797:                 JSFunction *fun = funobj->getFunctionPrivate();
53577:                 if (fun == funobj) {
53577:                     funobj = CloneFunctionObject(cx, fun, fun->parent);
53577:                     if (!funobj)
53577:                         return JS_FALSE;
53577:                     vp->setObject(*funobj);
53577:                 }
53577:             }
62395:             return identical || js_NativeSet(cx, obj, shape, false, strict, vp);
53577:         }
    1:     }
    1: 
27930:     added = false;
52503:     if (!shape) {
54563:         if (!obj->isExtensible()) {
54563:             /* Error in strict mode code, warn with strict option, otherwise do nothing. */
54563:             if (strict)
54587:                 return obj->reportNotExtensible(cx);
61450:             if (cx->hasStrictOption())
54587:                 return obj->reportNotExtensible(cx, JSREPORT_STRICT | JSREPORT_WARNING);
54563:             return JS_TRUE;
54563:         }
54563: 
11377:         /*
11377:          * Purge the property cache of now-shadowed id in obj's scope chain.
11377:          * Do this early, before locking obj to avoid nesting locks.
11377:          */
25936:         js_PurgeScopeChain(cx, obj, id);
11377: 
    1:         /* Find or make a property descriptor with the right heritage. */
56567:         if (!obj->ensureClassReservedSlots(cx))
27932:             return JS_FALSE;
32658: 
32658:         /*
32658:          * Check for Object class here to avoid defining a method on a class
32658:          * with magic resolve, addProperty, getProperty, etc. hooks.
32658:          */
48676:         if ((defineHow & JSDNP_SET_METHOD) && obj->canHaveMethodBarrier()) {
48470:             JS_ASSERT(IsFunctionObject(*vp));
32658:             JS_ASSERT(!(attrs & (JSPROP_GETTER | JSPROP_SETTER)));
32658: 
48470:             JSObject *funobj = &vp->toObject();
48676:             JSFunction *fun = GET_FUNCTION_PRIVATE(cx, funobj);
48676:             if (fun == funobj) {
52503:                 flags |= Shape::METHOD;
41860:                 getter = CastAsPropertyOp(funobj);
32658:             }
32658:         }
32658: 
52503:         shape = obj->putProperty(cx, id, getter, setter, SHAPE_INVALID_SLOT,
35334:                                  attrs, flags, shortid);
56567:         if (!shape)
27932:             return JS_FALSE;
    1: 
60780:         if (defineHow & JSDNP_CACHE_RESULT)
60780:             TRACE_1(AddProperty, obj);
60780: 
    1:         /*
    1:          * Initialize the new property value (passed to setter) to undefined.
    1:          * Note that we store before calling addProperty, to match the order
    1:          * in js_DefineNativeProperty.
    1:          */
52503:         if (obj->containsSlot(shape->slot))
56567:             obj->nativeSetSlot(shape->slot, UndefinedValue());
    1: 
    1:         /* XXXbe called with obj locked */
52503:         if (!CallAddPropertyHook(cx, clasp, obj, shape, vp)) {
52503:             obj->removeProperty(cx, id);
32658:             return JS_FALSE;
32658:         }
27930:         added = true;
    1:     }
    1: 
60780:     if (defineHow & JSDNP_CACHE_RESULT)
60780:         JS_PROPERTY_CACHE(cx).fill(cx, obj, 0, 0, obj, shape, added);
60780: 
62395:     return js_NativeSet(cx, obj, shape, added, strict, vp);
60780: 
48470: #ifdef JS_TRACER
60780:   error: // TRACE_1 jumps here in case of error.
60780:     return JS_FALSE;
48470: #endif
    1: }
    1: 
    1: JSBool
56760: js_SetProperty(JSContext *cx, JSObject *obj, jsid id, Value *vp, JSBool strict)
56760: {
56760:     return js_SetPropertyHelper(cx, obj, id, 0, vp, strict);
11377: }
11377: 
11377: JSBool
43290: js_GetAttributes(JSContext *cx, JSObject *obj, jsid id, uintN *attrsp)
43290: {
43290:     JSProperty *prop;
    1:     if (!js_LookupProperty(cx, obj, id, &obj, &prop))
43290:         return false;
    1:     if (!prop) {
    1:         *attrsp = 0;
43290:         return true;
43290:     }
43290:     if (!obj->isNative())
43290:         return obj->getAttributes(cx, id, attrsp);
43290: 
52503:     const Shape *shape = (Shape *)prop;
52503:     *attrsp = shape->attributes();
43290:     return true;
    1: }
    1: 
    1: JSBool
52503: js_SetNativeAttributes(JSContext *cx, JSObject *obj, Shape *shape, uintN attrs)
43290: {
43290:     JS_ASSERT(obj->isNative());
56567:     return !!js_ChangeNativePropertyAttrs(cx, obj, shape, attrs, 0,
52503:                                           shape->getter(), shape->setter());
43290: }
43290: 
43290: JSBool
43290: js_SetAttributes(JSContext *cx, JSObject *obj, jsid id, uintN *attrsp)
43290: {
43290:     JSProperty *prop;
    1:     if (!js_LookupProperty(cx, obj, id, &obj, &prop))
43290:         return false;
    1:     if (!prop)
43290:         return true;
43290:     return obj->isNative()
52503:            ? js_SetNativeAttributes(cx, obj, (Shape *) prop, *attrsp)
43290:            : obj->setAttributes(cx, id, attrsp);
    1: }
    1: 
    1: JSBool
54169: js_DeleteProperty(JSContext *cx, JSObject *obj, jsid id, Value *rval, JSBool strict)
    1: {
    1:     JSObject *proto;
    1:     JSProperty *prop;
52503:     const Shape *shape;
    1: 
48470:     rval->setBoolean(true);
    1: 
11377:     /* Convert string indices to integers if appropriate. */
30270:     id = js_CheckForStringIndex(id);
11377: 
    1:     if (!js_LookupProperty(cx, obj, id, &proto, &prop))
54169:         return false;
    1:     if (!prop || proto != obj) {
    1:         /*
    1:          * If the property was found in a native prototype, check whether it's
    1:          * shared and permanent.  Such a property stands for direct properties
    1:          * in all delegating objects, matching ECMA semantics without bloating
    1:          * each delegating object.
    1:          */
54169:         if (prop && proto->isNative()) {
52503:             shape = (Shape *)prop;
54169:             if (shape->isSharedPermanent()) {
54169:                 if (strict)
54587:                     return obj->reportNotConfigurable(cx, id);
48470:                 rval->setBoolean(false);
54169:                 return true;
54169:             }
43290:         }
    1: 
    1:         /*
    1:          * If no property, or the property comes unshared or impermanent from
    1:          * a prototype, call the class's delProperty hook, passing rval as the
    1:          * result parameter.
    1:          */
52503:         return CallJSPropertyOp(cx, obj->getClass()->delProperty, obj, id, rval);
52503:     }
52503: 
52503:     shape = (Shape *)prop;
52503:     if (!shape->configurable()) {
54169:         if (strict)
54587:             return obj->reportNotConfigurable(cx, id);
48470:         rval->setBoolean(false);
54169:         return true;
    1:     }
    1: 
56567:     if (!CallJSPropertyOp(cx, obj->getClass()->delProperty, obj, SHAPE_USERID(shape), rval))
54169:         return false;
    1: 
52503:     if (obj->containsSlot(shape->slot)) {
56567:         const Value &v = obj->nativeGetSlot(shape->slot);
48676:         GC_POKE(cx, v);
48676: 
48676:         /*
48676:          * Delete is rare enough that we can take the hit of checking for an
48676:          * active cloned method function object that must be homed to a callee
48676:          * slot on the active stack frame before this delete completes, in case
48676:          * someone saved the clone and checks it against foo.caller for a foo
48676:          * called from the active method.
48676:          *
48676:          * We do not check suspended frames. They can't be reached via caller,
48676:          * so the only way they could have the method's joined function object
48676:          * as callee is through an API abusage. We break any such edge case.
48676:          */
52503:         if (obj->hasMethodBarrier()) {
48676:             JSObject *funobj;
48676: 
48676:             if (IsFunctionObject(v, &funobj)) {
48676:                 JSFunction *fun = GET_FUNCTION_PRIVATE(cx, funobj);
48676: 
48676:                 if (fun != funobj) {
53840:                     for (JSStackFrame *fp = cx->maybefp(); fp; fp = fp->prev()) {
53840:                         if (fp->isFunctionFrame() &&
53840:                             &fp->callee() == &fun->compiledFunObj() &&
60172:                             fp->thisValue().isObject())
60172:                         {
60172:                             JSObject *tmp = &fp->thisValue().toObject();
60172:                             do {
60172:                                 if (tmp == obj) {
53840:                                     fp->calleeValue().setObject(*funobj);
60172:                                     break;
60172:                                 }
60172:                             } while ((tmp = tmp->getProto()) != NULL);
48676:                         }
48676:                     }
48676:                 }
48676:             }
48676:         }
48676:     }
    1: 
56567:     return obj->removeProperty(cx, id) && js_SuppressDeletedProperty(cx, obj, id);
    1: }
    1: 
47607: namespace js {
47607: 
57686: JSObject *
57686: HasNativeMethod(JSObject *obj, jsid methodid, Native native)
57686: {
57686:     const Shape *shape = obj->nativeLookup(methodid);
57686:     if (!shape || !shape->hasDefaultGetter() || !obj->containsSlot(shape->slot))
57686:         return NULL;
57686: 
57686:     const Value &fval = obj->nativeGetSlot(shape->slot);
57686:     JSObject *funobj;
57686:     if (!IsFunctionObject(fval, &funobj) || funobj->getFunctionPrivate()->maybeNative() != native)
57686:         return NULL;
57686: 
57686:     return funobj;
57686: }
57686: 
57686: bool
55737: DefaultValue(JSContext *cx, JSObject *obj, JSType hint, Value *vp)
55737: {
55737:     JS_ASSERT(hint != JSTYPE_OBJECT && hint != JSTYPE_FUNCTION);
55737: 
55737:     Value v = ObjectValue(*obj);
55737:     if (hint == JSTYPE_STRING) {
55737:         /* Optimize (new String(...)).toString(). */
55737:         if (obj->getClass() == &js_StringClass &&
56216:             ClassMethodIsNative(cx, obj,
56216:                                  &js_StringClass,
55737:                                  ATOM_TO_JSID(cx->runtime->atomState.toStringAtom),
55737:                                  js_str_toString)) {
40901:             *vp = obj->getPrimitiveThis();
55737:             return true;
55737:         }
55737: 
55737:         if (!js_TryMethod(cx, obj, cx->runtime->atomState.toStringAtom, 0, NULL, &v))
55737:             return false;
48470:         if (!v.isPrimitive()) {
40826:             if (!obj->getClass()->convert(cx, obj, hint, &v))
55737:                 return false;
    1:         }
48470:     } else {
55737:         /* Optimize (new String(...)).valueOf(). */
56216:         Class *clasp = obj->getClass();
56216:         if ((clasp == &js_StringClass &&
56216:              ClassMethodIsNative(cx, obj, &js_StringClass,
55737:                                  ATOM_TO_JSID(cx->runtime->atomState.valueOfAtom),
56216:                                  js_str_toString)) ||
56216:             (clasp == &js_NumberClass &&
56216:              ClassMethodIsNative(cx, obj, &js_NumberClass,
56216:                                  ATOM_TO_JSID(cx->runtime->atomState.valueOfAtom),
56216:                                  js_num_valueOf))) {
55737:             *vp = obj->getPrimitiveThis();
55737:             return true;
55737:         }
55737: 
40826:         if (!obj->getClass()->convert(cx, obj, hint, &v))
55737:             return false;
48470:         if (v.isObject()) {
48470:             JS_ASSERT(hint != TypeOfValue(cx, v));
40867:             if (!js_TryMethod(cx, obj, cx->runtime->atomState.toStringAtom, 0, NULL, &v))
55737:                 return false;
    1:         }
48470:     }
48470:     if (v.isObject()) {
    1:         /* Avoid recursive death when decompiling in js_ReportValueError. */
48470:         JSString *str;
    1:         if (hint == JSTYPE_STRING) {
40826:             str = JS_InternString(cx, obj->getClass()->name);
    1:             if (!str)
55737:                 return false;
    1:         } else {
    1:             str = NULL;
    1:         }
48470:         vp->setObject(*obj);
    1:         js_ReportValueError2(cx, JSMSG_CANT_CONVERT_TO,
48470:                              JSDVG_SEARCH_STACK, *vp, str,
    1:                              (hint == JSTYPE_VOID)
    1:                              ? "primitive type"
 4342:                              : JS_TYPE_STR(hint));
55737:         return false;
    1:     }
    1:     *vp = v;
55737:     return true;
    1: }
    1: 
47607: } /* namespace js */
47607: 
48622: JS_FRIEND_API(JSBool)
48470: js_Enumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op, Value *statep, jsid *idp)
42641: {
42641:     /* If the class has a custom JSCLASS_NEW_ENUMERATE hook, call it. */
48470:     Class *clasp = obj->getClass();
33128:     JSEnumerateOp enumerate = clasp->enumerate;
11835:     if (clasp->flags & JSCLASS_NEW_ENUMERATE) {
11835:         JS_ASSERT(enumerate != JS_EnumerateStub);
48470:         return ((NewEnumerateOp) enumerate)(cx, obj, enum_op, statep, idp);
11835:     }
    1: 
    1:     if (!enumerate(cx, obj))
33128:         return false;
15677: 
42641:     /* Tell InitNativeIterator to treat us like a native object. */
47569:     JS_ASSERT(enum_op == JSENUMERATE_INIT || enum_op == JSENUMERATE_INIT_ALL);
48470:     statep->setMagic(JS_NATIVE_ENUMERATE);
33128:     return true;
    1: }
    1: 
47455: namespace js {
47455: 
    1: JSBool
47455: CheckAccess(JSContext *cx, JSObject *obj, jsid id, JSAccessMode mode,
48470:             Value *vp, uintN *attrsp)
    1: {
    1:     JSBool writing;
    1:     JSObject *pobj;
    1:     JSProperty *prop;
48470:     Class *clasp;
52503:     const Shape *shape;
18870:     JSSecurityCallbacks *callbacks;
48470:     CheckAccessOp check;
    1: 
47455:     while (JS_UNLIKELY(obj->getClass() == &js_WithClass))
47455:         obj = obj->getProto();
47455: 
    1:     writing = (mode & JSACC_WRITE) != 0;
    1:     switch (mode & JSACC_TYPEMASK) {
    1:       case JSACC_PROTO:
    1:         pobj = obj;
    1:         if (!writing)
48470:             vp->setObjectOrNull(obj->getProto());
    1:         *attrsp = JSPROP_PERMANENT;
    1:         break;
    1: 
    1:       case JSACC_PARENT:
    1:         JS_ASSERT(!writing);
    1:         pobj = obj;
48470:         vp->setObject(*obj->getParent());
    1:         *attrsp = JSPROP_READONLY | JSPROP_PERMANENT;
    1:         break;
    1: 
    1:       default:
31501:         if (!obj->lookupProperty(cx, id, &pobj, &prop))
    1:             return JS_FALSE;
    1:         if (!prop) {
    1:             if (!writing)
48470:                 vp->setUndefined();
    1:             *attrsp = 0;
11842:             pobj = obj;
11842:             break;
11842:         }
11842: 
40430:         if (!pobj->isNative()) {
16403:             if (!writing) {
48470:                     vp->setUndefined();
16403:                 *attrsp = 0;
16403:             }
11842:             break;
11961:         }
    1: 
52503:         shape = (Shape *)prop;
52503:         *attrsp = shape->attributes();
    1:         if (!writing) {
52503:             if (pobj->containsSlot(shape->slot))
56567:                 *vp = pobj->nativeGetSlot(shape->slot);
48470:             else
48470:                 vp->setUndefined();
    1:         }
    1:     }
    1: 
    1:     /*
    1:      * If obj's class has a stub (null) checkAccess hook, use the per-runtime
    1:      * checkObjectAccess callback, if configured.
    1:      *
    1:      * We don't want to require all classes to supply a checkAccess hook; we
    1:      * need that hook only for certain classes used when precompiling scripts
    1:      * and functions ("brutal sharing").  But for general safety of built-in
41968:      * magic properties like __proto__, we route all access checks, even for
41968:      * classes that stub out checkAccess, through the global checkObjectAccess
41968:      * hook.  This covers precompilation-based sharing and (possibly
41968:      * unintended) runtime sharing across trust boundaries.
    1:      */
40826:     clasp = pobj->getClass();
    1:     check = clasp->checkAccess;
18870:     if (!check) {
18870:         callbacks = JS_GetSecurityCallbacks(cx);
48470:         check = callbacks ? Valueify(callbacks->checkObjectAccess) : NULL;
48470:     }
48470:     return !check || check(cx, pobj, id, mode, vp);
    1: }
    1: 
47455: }
47455: 
38633: JSType
38633: js_TypeOf(JSContext *cx, JSObject *obj)
38633: {
38633:     /*
38633:      * ECMA 262, 11.4.3 says that any native object that implements
38633:      * [[Call]] should be of type "function". However, RegExp is of
38633:      * type "object", not "function", for Web compatibility.
38633:      */
38638:     if (obj->isCallable()) {
38633:         return (obj->getClass() != &js_RegExpClass)
38633:                ? JSTYPE_FUNCTION
38633:                : JSTYPE_OBJECT;
38633:     }
38633: 
38633:     return JSTYPE_OBJECT;
38633: }
38633: 
48470: bool
48470: js_IsDelegate(JSContext *cx, JSObject *obj, const Value &v)
48470: {
48470:     if (v.isPrimitive())
48470:         return false;
56565:     JSObject *obj2 = &v.toObject();
39928:     while ((obj2 = obj2->getProto()) != NULL) {
48470:         if (obj2 == obj)
48470:             return true;
48470:     }
48470:     return false;
    1: }
    1: 
47497: bool
52503: js::FindClassPrototype(JSContext *cx, JSObject *scopeobj, JSProtoKey protoKey,
52503:                        JSObject **protop, Class *clasp)
48470: {
48470:     Value v;
52503:     if (!js_FindClassObject(cx, scopeobj, protoKey, &v, clasp))
47497:         return false;
47497: 
48470:     if (IsFunctionObject(v)) {
48470:         JSObject *ctor = &v.toObject();
47497:         if (!ctor->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom), &v))
47497:             return false;
47497:     }
47497: 
48470:     *protop = v.isObject() ? &v.toObject() : NULL;
47497:     return true;
47497: }
47497: 
47497: /*
47497:  * The first part of this function has been hand-expanded and optimized into
47497:  * NewBuiltinClassInstance in jsobjinlines.h.
47497:  */
    1: JSBool
52503: js_GetClassPrototype(JSContext *cx, JSObject *scopeobj, JSProtoKey protoKey,
48470:                      JSObject **protop, Class *clasp)
38604: {
38604:     VOUCH_DOES_NOT_REQUIRE_STACK();
38604:     JS_ASSERT(JSProto_Null <= protoKey);
38604:     JS_ASSERT(protoKey < JSProto_LIMIT);
38604: 
38604:     if (protoKey != JSProto_Null) {
52503:         if (!scopeobj) {
62953:             if (cx->hasfp())
62953:                 scopeobj = &cx->fp()->scopeChain();
62953:             if (!scopeobj) {
62953:                 scopeobj = cx->globalObject;
62953:                 if (!scopeobj) {
62953:                     *protop = NULL;
62953:                     return true;
62953:                 }
62953:             }
38604:         }
52503:         scopeobj = scopeobj->getGlobal();
60566:         if (scopeobj->isGlobal()) {
52503:             const Value &v = scopeobj->getReservedSlot(JSProto_LIMIT + protoKey);
48470:             if (v.isObject()) {
48470:                 *protop = &v.toObject();
38604:                 return true;
38604:             }
38604:         }
43258:     }
38604: 
52503:     return FindClassPrototype(cx, scopeobj, protoKey, protop, clasp);
    1: }
    1: 
    1: JSBool
48470: js_SetClassPrototype(JSContext *cx, JSObject *ctor, JSObject *proto, uintN attrs)
    1: {
    1:     /*
    1:      * Use the given attributes for the prototype property of the constructor,
    1:      * as user-defined constructors have a DontDelete prototype (which may be
    1:      * reset), while native or "system" constructors have DontEnum | ReadOnly |
    1:      * DontDelete.
    1:      */
31501:     if (!ctor->defineProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom),
62395:                               ObjectOrNullValue(proto), PropertyStub, StrictPropertyStub, attrs)) {
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     /*
    1:      * ECMA says that Object.prototype.constructor, or f.prototype.constructor
    1:      * for a user-defined function f, is DontEnum.
    1:      */
31501:     return proto->defineProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.constructorAtom),
62395:                                  ObjectOrNullValue(ctor), PropertyStub, StrictPropertyStub, 0);
    1: }
    1: 
61734: JSObject *
61734: PrimitiveToObject(JSContext *cx, const Value &v)
61734: {
48470:     JS_ASSERT(v.isPrimitive());
48470: 
48470:     Class *clasp;
55712:     if (v.isNumber()) {
48470:         clasp = &js_NumberClass;
55712:     } else if (v.isString()) {
48470:         clasp = &js_StringClass;
55712:     } else {
55712:         JS_ASSERT(v.isBoolean());
48470:         clasp = &js_BooleanClass;
55712:     }
48470: 
48470:     JSObject *obj = NewBuiltinClassInstance(cx, clasp);
 2383:     if (!obj)
61734:         return NULL;
48470: 
48470:     obj->setPrimitiveThis(v);
61734:     return obj;
61734: }
61734: 
61734: JSBool
61734: js_PrimitiveToObject(JSContext *cx, Value *vp)
61734: {
61734:     JSObject *obj = PrimitiveToObject(cx, *vp);
61734:     if (!obj)
61734:         return false;
61734: 
48470:     vp->setObject(*obj);
61734:     return true;
 2383: }
 2383: 
 2383: JSBool
48470: js_ValueToObjectOrNull(JSContext *cx, const Value &v, JSObject **objp)
    1: {
    1:     JSObject *obj;
    1: 
48470:     if (v.isObjectOrNull()) {
48470:         obj = v.toObjectOrNull();
48470:     } else if (v.isUndefined()) {
    1:         obj = NULL;
    1:     } else {
61734:         obj = PrimitiveToObject(cx, v);
61734:         if (!obj)
61734:             return false;
    1:     }
    1:     *objp = obj;
61734:     return true;
61734: }
61734: 
61734: namespace js {
61734: 
61734: /* Callers must handle the already-object case . */
61734: JSObject *
61734: ToObjectSlow(JSContext *cx, Value *vp)
61734: {
61734:     JS_ASSERT(!vp->isMagic());
61734:     JS_ASSERT(!vp->isObject());
61734: 
61734:     if (vp->isNullOrUndefined()) {
61734:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_CONVERT_TO,
61734:                             vp->isNull() ? "null" : "undefined", "object");
61734:         return NULL;
61734:     }
61734: 
61734:     JSObject *obj = PrimitiveToObject(cx, *vp);
61734:     if (obj)
61734:         vp->setObject(*obj);
61734:     return obj;
61734: }
61734: 
    1: }
    1: 
    1: JSObject *
48470: js_ValueToNonNullObject(JSContext *cx, const Value &v)
    1: {
    1:     JSObject *obj;
    1: 
48470:     if (!js_ValueToObjectOrNull(cx, v, &obj))
    1:         return NULL;
 7897:     if (!obj)
 7897:         js_ReportIsNullOrUndefined(cx, JSDVG_SEARCH_STACK, v, NULL);
    1:     return obj;
    1: }
    1: 
    1: JSBool
48470: js_TryValueOf(JSContext *cx, JSObject *obj, JSType type, Value *rval)
48470: {
48470:     Value argv[1];
48470: 
48470:     argv[0].setString(ATOM_TO_STRING(cx->runtime->atomState.typeAtoms[type]));
48470:     return js_TryMethod(cx, obj, cx->runtime->atomState.valueOfAtom,
48470:                         1, argv, rval);
    1: }
    1: 
    1: JSBool
    1: js_TryMethod(JSContext *cx, JSObject *obj, JSAtom *atom,
48470:              uintN argc, Value *argv, Value *rval)
48470: {
11139:     JS_CHECK_RECURSION(cx, return JS_FALSE);
    1: 
    1:     /*
    1:      * Report failure only if an appropriate method was found, and calling it
    1:      * returned failure.  We propagate failure in this case to make exceptions
    1:      * behave properly.
    1:      */
48470:     JSErrorReporter older = JS_SetErrorReporter(cx, NULL);
48470:     jsid id = ATOM_TO_JSID(atom);
48470:     Value fval;
48470:     JSBool ok = js_GetMethod(cx, obj, id, JSGET_NO_METHOD_BARRIER, &fval);
38621:     JS_SetErrorReporter(cx, older);
38619:     if (!ok)
38621:         return false;
    1: 
48470:     if (fval.isPrimitive())
24499:         return JS_TRUE;
61734:     return ExternalInvoke(cx, ObjectValue(*obj), fval, argc, argv, rval);
    1: }
    1: 
    1: #if JS_HAS_XDR
    1: 
    1: JSBool
    1: js_XDRObject(JSXDRState *xdr, JSObject **objp)
    1: {
    1:     JSContext *cx;
    1:     JSAtom *atom;
48470:     Class *clasp;
    1:     uint32 classId, classDef;
    1:     JSProtoKey protoKey;
    1:     JSObject *proto;
    1: 
    1:     cx = xdr->cx;
    1:     atom = NULL;
    1:     if (xdr->mode == JSXDR_ENCODE) {
40826:         clasp = (*objp)->getClass();
    1:         classId = JS_XDRFindClassIdByName(xdr, clasp->name);
    1:         classDef = !classId;
    1:         if (classDef) {
48470:             if (!JS_XDRRegisterClass(xdr, Jsvalify(clasp), &classId))
    1:                 return JS_FALSE;
    1:             protoKey = JSCLASS_CACHED_PROTO_KEY(clasp);
    1:             if (protoKey != JSProto_Null) {
    1:                 classDef |= (protoKey << 1);
    1:             } else {
    1:                 atom = js_Atomize(cx, clasp->name, strlen(clasp->name), 0);
    1:                 if (!atom)
    1:                     return JS_FALSE;
    1:             }
    1:         }
    1:     } else {
    1:         clasp = NULL;           /* quell GCC overwarning */
    1:         classDef = 0;
    1:     }
    1: 
    1:     /*
    1:      * XDR a flag word, which could be 0 for a class use, in which case no
    1:      * name follows, only the id in xdr's class registry; 1 for a class def,
    1:      * in which case the flag word is followed by the class name transferred
    1:      * from or to atom; or a value greater than 1, an odd number that when
    1:      * divided by two yields the JSProtoKey for class.  In the last case, as
    1:      * in the 0 classDef case, no name is transferred via atom.
    1:      */
    1:     if (!JS_XDRUint32(xdr, &classDef))
    1:         return JS_FALSE;
48480:     if (classDef == 1 && !js_XDRAtom(xdr, &atom))
    1:         return JS_FALSE;
    1: 
    1:     if (!JS_XDRUint32(xdr, &classId))
    1:         return JS_FALSE;
    1: 
    1:     if (xdr->mode == JSXDR_DECODE) {
    1:         if (classDef) {
    1:             /* NB: we know that JSProto_Null is 0 here, for backward compat. */
 3164:             protoKey = (JSProtoKey) (classDef >> 1);
38604:             if (!js_GetClassPrototype(cx, NULL, protoKey, &proto, clasp))
    1:                 return JS_FALSE;
40826:             clasp = proto->getClass();
48470:             if (!JS_XDRRegisterClass(xdr, Jsvalify(clasp), &classId))
    1:                 return JS_FALSE;
    1:         } else {
48470:             clasp = Valueify(JS_XDRFindClassById(xdr, classId));
    1:             if (!clasp) {
    1:                 char numBuf[12];
    1:                 JS_snprintf(numBuf, sizeof numBuf, "%ld", (long)classId);
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_CANT_FIND_CLASS, numBuf);
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1:     }
    1: 
    1:     if (!clasp->xdrObject) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_CANT_XDR_CLASS, clasp->name);
    1:         return JS_FALSE;
    1:     }
    1:     return clasp->xdrObject(xdr, objp);
    1: }
    1: 
    1: #endif /* JS_HAS_XDR */
    1: 
10217: #ifdef JS_DUMP_SCOPE_METERS
    1: 
    1: #include <stdio.h>
10217: 
10217: JSBasicStats js_entry_count_bs = JS_INIT_STATIC_BASIC_STATS;
    1: 
    1: static void
    1: MeterEntryCount(uintN count)
    1: {
10217:     JS_BASIC_STATS_ACCUM(&js_entry_count_bs, count);
10217: }
10217: 
    1: void
    1: js_DumpScopeMeters(JSRuntime *rt)
    1: {
    1:     static FILE *logfp;
    1:     if (!logfp)
    1:         logfp = fopen("/tmp/scope.stats", "a");
    1: 
    1:     {
10217:         double mean, sigma;
10217: 
10217:         mean = JS_MeanAndStdDevBS(&js_entry_count_bs, &sigma);
10217: 
10217:         fprintf(logfp, "scopes %u entries %g mean %g sigma %g max %u",
10217:                 js_entry_count_bs.num, js_entry_count_bs.sum, mean, sigma,
10217:                 js_entry_count_bs.max);
10217:     }
10217: 
10217:     JS_DumpHistogram(&js_entry_count_bs, logfp);
10217:     JS_BASIC_STATS_INIT(&js_entry_count_bs);
    1:     fflush(logfp);
    1: }
    1: #endif
    1: 
  583: #ifdef DEBUG
11835: void
11835: js_PrintObjectSlotName(JSTracer *trc, char *buf, size_t bufsize)
  583: {
32684:     JS_ASSERT(trc->debugPrinter == js_PrintObjectSlotName);
32684: 
32684:     JSObject *obj = (JSObject *)trc->debugPrintArg;
32684:     uint32 slot = (uint32)trc->debugPrintIndex;
32684: 
52503:     const Shape *shape;
40430:     if (obj->isNative()) {
52503:         shape = obj->lastProperty();
52503:         while (shape->previous() && shape->slot != slot)
52503:             shape = shape->previous();
55683:         if (shape->slot != slot)
55683:             shape = NULL;
11835:     } else {
52503:         shape = NULL;
52503:     }
52503: 
52503:     if (!shape) {
32684:         const char *slotname = NULL;
60566:         if (obj->isGlobal()) {
  583: #define JS_PROTO(name,code,init)                                              \
55746:     if ((code) == slot) { slotname = js_##name##_str; goto found; }
  583: #include "jsproto.tbl"
  583: #undef JS_PROTO
  583:         }
  583:       found:
  583:         if (slotname)
  583:             JS_snprintf(buf, bufsize, "CLASS_OBJECT(%s)", slotname);
  583:         else
  583:             JS_snprintf(buf, bufsize, "**UNKNOWN SLOT %ld**", (long)slot);
  583:     } else {
52503:         jsid id = shape->id;
48470:         if (JSID_IS_INT(id)) {
48470:             JS_snprintf(buf, bufsize, "%ld", (long)JSID_TO_INT(id));
48470:         } else if (JSID_IS_ATOM(id)) {
59890:             PutEscapedString(buf, bufsize, JSID_TO_ATOM(id), 0);
  583:         } else {
  583:             JS_snprintf(buf, bufsize, "**FINALIZED ATOM KEY**");
  583:         }
  583:     }
  583: }
  583: #endif
  583: 
  583: void
  583: js_TraceObject(JSTracer *trc, JSObject *obj)
    1: {
40430:     JS_ASSERT(obj->isNative());
32684: 
32684:     JSContext *cx = trc->context;
55746:     if (obj->hasSlotsArray() && !obj->nativeEmpty() && IS_GC_MARKING_TRACER(trc)) {
11377:         /*
52503:          * Trim overlong dslots allocations from the GC, to avoid thrashing in
52503:          * case of delete-happy code that settles down at a given population.
52503:          * The !obj->nativeEmpty() guard above is due to the bug described by
52503:          * the FIXME comment below.
11377:          */
53652:         size_t slots = obj->slotSpan();
40410:         if (obj->numSlots() != slots)
41978:             obj->shrinkSlots(cx, slots);
30454:     }
30454: 
10217: #ifdef JS_DUMP_SCOPE_METERS
52503:     MeterEntryCount(obj->propertyCount);
    1: #endif
    1: 
52503:     obj->trace(trc);
    1: 
 5816:     if (!JS_CLIST_IS_EMPTY(&cx->runtime->watchPointList))
 5816:         js_TraceWatchPoints(trc, obj);
    1: 
    1:     /* No one runs while the GC is running, so we can use LOCKED_... here. */
48470:     Class *clasp = obj->getClass();
  583:     if (clasp->mark) {
  583:         if (clasp->flags & JSCLASS_MARK_IS_TRACE)
11377:             ((JSTraceOp) clasp->mark)(trc, obj);
  583:         else if (IS_GC_MARKING_TRACER(trc))
  583:             (void) clasp->mark(cx, obj, trc);
  583:     }
47498:     if (clasp->flags & JSCLASS_IS_GLOBAL) {
56578:         JSCompartment *compartment = obj->getCompartment();
62077:         compartment->mark(trc);
47498:     }
    1: 
    1:     /*
62045:      * NB: clasp->mark could mutate something (which would be a bug, but we are
62045:      * defensive), so don't hoist this above calling clasp->mark.
    1:      */
61754:     uint32 nslots = Min(obj->numSlots(), obj->slotSpan());
55746:     for (uint32 i = 0; i != nslots; ++i) {
48470:         const Value &v = obj->getSlot(i);
11835:         JS_SET_TRACING_DETAILS(trc, js_PrintObjectSlotName, obj, i);
48470:         MarkValueRaw(trc, v);
  583:     }
    1: }
    1: 
    1: void
48622: js_ClearNative(JSContext *cx, JSObject *obj)
    1: {
    1:     /*
52503:      * Clear obj of all obj's properties. FIXME: we do not clear reserved slots
52503:      * lying below JSSLOT_FREE(clasp). JS_ClearScope does that.
    1:      */
52503:     if (!obj->nativeEmpty()) {
52503:         /* Now that we're done using real properties, clear obj. */
52503:         obj->clear(cx);
    1: 
53652:         /* Clear slot values since obj->clear reset our shape to empty. */
48649:         uint32 freeslot = JSSLOT_FREE(obj->getClass());
48649:         uint32 n = obj->numSlots();
48649:         for (uint32 i = freeslot; i < n; ++i)
48470:             obj->setSlot(i, UndefinedValue());
    1:     }
    1: }
    1: 
32603: bool
55746: js_GetReservedSlot(JSContext *cx, JSObject *obj, uint32 slot, Value *vp)
32603: {
40430:     if (!obj->isNative()) {
48470:         vp->setUndefined();
32603:         return true;
32603:     }
32603: 
48470:     if (slot < obj->numSlots())
48470:         *vp = obj->getSlot(slot);
48470:     else
48470:         vp->setUndefined();
32603:     return true;
32603: }
32603: 
32603: bool
55746: js_SetReservedSlot(JSContext *cx, JSObject *obj, uint32 slot, const Value &v)
    1: {
40430:     if (!obj->isNative())
32603:         return true;
32603: 
48470:     Class *clasp = obj->getClass();
41804: 
41978:     if (slot >= obj->numSlots()) {
32603:         uint32 nslots = JSSLOT_FREE(clasp);
    1:         JS_ASSERT(slot < nslots);
56567:         if (!obj->allocSlots(cx, nslots))
32603:             return false;
    1:     }
    1: 
40410:     obj->setSlot(slot, v);
25939:     GC_POKE(cx, JS_NULL);
32603:     return true;
    1: }
    1: 
12674: JSObject *
51090: JSObject::getGlobal() const
51090: {
51090:     JSObject *obj = const_cast<JSObject *>(this);
40424:     while (JSObject *parent = obj->getParent())
40424:         obj = parent;
40424:     return obj;
40424: }
40424: 
36491: JSBool
27641: js_ReportGetterOnlyAssignment(JSContext *cx)
27641: {
36491:     return JS_ReportErrorFlagsAndNumber(cx,
36491:                                         JSREPORT_WARNING | JSREPORT_STRICT |
36491:                                         JSREPORT_STRICT_MODE_ERROR,
36491:                                         js_GetErrorMessage, NULL,
36491:                                         JSMSG_GETTER_ONLY);
27641: }
27641: 
27641: JS_FRIEND_API(JSBool)
62395: js_GetterOnlyPropertyStub(JSContext *cx, JSObject *obj, jsid id, JSBool strict, jsval *vp)
27641: {
36491:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_GETTER_ONLY);
27641:     return JS_FALSE;
27641: }
27641: 
24294: #ifdef DEBUG
19714: 
19714: /*
19714:  * Routines to print out values during debugging.  These are FRIEND_API to help
19714:  * the debugger find them and to support temporarily hacking js_Dump* calls
19714:  * into other code.
19714:  */
19714: 
19714: void
19714: dumpChars(const jschar *s, size_t n)
19714: {
19714:     size_t i;
19714: 
19714:     if (n == (size_t) -1) {
19714:         while (s[++n]) ;
19714:     }
19714: 
    1:     fputc('"', stderr);
19714:     for (i = 0; i < n; i++) {
19714:         if (s[i] == '\n')
19714:             fprintf(stderr, "\\n");
19714:         else if (s[i] == '\t')
19714:             fprintf(stderr, "\\t");
19714:         else if (s[i] >= 32 && s[i] < 127)
19714:             fputc(s[i], stderr);
19714:         else if (s[i] <= 255)
19714:             fprintf(stderr, "\\x%02x", (unsigned int) s[i]);
19714:         else
19714:             fprintf(stderr, "\\u%04x", (unsigned int) s[i]);
19714:     }
19714:     fputc('"', stderr);
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpChars(const jschar *s, size_t n)
19714: {
19714:     fprintf(stderr, "jschar * (%p) = ", (void *) s);
19714:     dumpChars(s, n);
    1:     fputc('\n', stderr);
    1: }
    1: 
19714: void
19714: dumpString(JSString *str)
19714: {
59890:     if (const jschar *chars = str->getChars(NULL))
59890:         dumpChars(chars, str->length());
59890:     else
59890:         fprintf(stderr, "(oom in dumpString)");
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpString(JSString *str)
19714: {
59890:     if (const jschar *chars = str->getChars(NULL)) {
19714:         fprintf(stderr, "JSString* (%p) = jschar * (%p) = ",
59890:                 (void *) str, (void *) chars);
19714:         dumpString(str);
59890:     } else {
59890:         fprintf(stderr, "(oom in JS_DumpString)");
59890:     }
    1:     fputc('\n', stderr);
    1: }
    1: 
19714: JS_FRIEND_API(void)
19714: js_DumpAtom(JSAtom *atom)
19714: {
19714:     fprintf(stderr, "JSAtom* (%p) = ", (void *) atom);
48470:     js_DumpString(ATOM_TO_STRING(atom));
19714: }
19714: 
19714: void
48470: dumpValue(const Value &v)
48470: {
48470:     if (v.isNull())
19714:         fprintf(stderr, "null");
48470:     else if (v.isUndefined())
19714:         fprintf(stderr, "undefined");
48470:     else if (v.isInt32())
48470:         fprintf(stderr, "%d", v.toInt32());
48470:     else if (v.isDouble())
48470:         fprintf(stderr, "%g", v.toDouble());
48470:     else if (v.isString())
48470:         dumpString(v.toString());
48470:     else if (v.isObject() && v.toObject().isFunction()) {
48470:         JSObject *funobj = &v.toObject();
31452:         JSFunction *fun = GET_FUNCTION_PRIVATE(cx, funobj);
57721:         if (fun->atom) {
57721:             fputs("<function ", stderr);
57721:             FileEscapedString(stderr, ATOM_TO_STRING(fun->atom), 0);
57721:         } else {
57721:             fputs("<unnamed function", stderr);
57721:         }
59062:         if (fun->isInterpreted()) {
59062:             JSScript *script = fun->script();
59062:             fprintf(stderr, " (%s:%u)",
59062:                     script->filename ? script->filename : "", script->lineno);
59062:         }
57721:         fprintf(stderr, " at %p (JSFunction at %p)>", (void *) funobj, (void *) fun);
48470:     } else if (v.isObject()) {
48470:         JSObject *obj = &v.toObject();
48470:         Class *clasp = obj->getClass();
19714:         fprintf(stderr, "<%s%s at %p>",
47480:                 clasp->name,
48676:                 (clasp == &js_ObjectClass) ? "" : " object",
25218:                 (void *) obj);
48470:     } else if (v.isBoolean()) {
48470:         if (v.toBoolean())
19714:             fprintf(stderr, "true");
48470:         else
19714:             fprintf(stderr, "false");
48470:     } else if (v.isMagic()) {
48470:         fprintf(stderr, "<invalid");
48470: #ifdef DEBUG
48470:         switch (v.whyMagic()) {
48470:           case JS_ARRAY_HOLE:        fprintf(stderr, " array hole");         break;
48470:           case JS_ARGS_HOLE:         fprintf(stderr, " args hole");          break;
48470:           case JS_NATIVE_ENUMERATE:  fprintf(stderr, " native enumeration"); break;
48470:           case JS_NO_ITER_VALUE:     fprintf(stderr, " no iter value");      break;
48470:           case JS_GENERATOR_CLOSING: fprintf(stderr, " generator closing");  break;
48470:           default:                   fprintf(stderr, " ?!");                 break;
48470:         }
48470: #endif
48470:         fprintf(stderr, ">");
19714:     } else {
48470:         fprintf(stderr, "unexpected value");
19714:     }
19714: }
19714: 
19714: JS_FRIEND_API(void)
48470: js_DumpValue(const Value &val)
48470: {
19714:     dumpValue(val);
19714:     fputc('\n', stderr);
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpId(jsid id)
19714: {
48470:     fprintf(stderr, "jsid %p = ", (void *) JSID_BITS(id));
48470:     dumpValue(IdToValue(id));
19714:     fputc('\n', stderr);
19714: }
19714: 
20208: static void
62931: DumpProperty(JSObject *obj, const Shape &shape)
52503: {
52503:     jsid id = shape.id;
52503:     uint8 attrs = shape.attributes();
19714: 
62931:     fprintf(stderr, "    ((Shape *) %p) ", (void *) &shape);
19714:     if (attrs & JSPROP_ENUMERATE) fprintf(stderr, "enumerate ");
19714:     if (attrs & JSPROP_READONLY) fprintf(stderr, "readonly ");
19714:     if (attrs & JSPROP_PERMANENT) fprintf(stderr, "permanent ");
19714:     if (attrs & JSPROP_SHARED) fprintf(stderr, "shared ");
52503:     if (shape.isAlias()) fprintf(stderr, "alias ");
62931:     if (shape.isMethod()) fprintf(stderr, "method=%p ", (void *) &shape.methodObject());
62931: 
62931:     if (shape.hasGetterValue())
62931:         fprintf(stderr, "getterValue=%p ", (void *) shape.getterObject());
62931:     else if (!shape.hasDefaultGetter())
62936:         fprintf(stderr, "getterOp=%p ", JS_FUNC_TO_DATA_PTR(void *, shape.getterOp()));
62931: 
62931:     if (shape.hasSetterValue())
62931:         fprintf(stderr, "setterValue=%p ", (void *) shape.setterObject());
62931:     else if (shape.setterOp() == js_watch_set)
62931:         fprintf(stderr, "setterOp=js_watch_set ");
62931:     else if (!shape.hasDefaultSetter())
62936:         fprintf(stderr, "setterOp=%p ", JS_FUNC_TO_DATA_PTR(void *, shape.setterOp()));
59009: 
19714:     if (JSID_IS_ATOM(id))
48470:         dumpString(JSID_TO_STRING(id));
19714:     else if (JSID_IS_INT(id))
19714:         fprintf(stderr, "%d", (int) JSID_TO_INT(id));
19714:     else
48470:         fprintf(stderr, "unknown jsid %p", (void *) JSID_BITS(id));
52503:     fprintf(stderr, ": slot %d", shape.slot);
62931:     if (obj->containsSlot(shape.slot)) {
62931:         fprintf(stderr, " = ");
62931:         dumpValue(obj->getSlot(shape.slot));
62931:     } else if (shape.slot != SHAPE_INVALID_SLOT) {
62931:         fprintf(stderr, " (INVALID!)");
62931:     }
19714:     fprintf(stderr, "\n");
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpObject(JSObject *obj)
19714: {
13437:     fprintf(stderr, "object %p\n", (void *) obj);
55747:     Class *clasp = obj->getClass();
    1:     fprintf(stderr, "class %p %s\n", (void *)clasp, clasp->name);
19714: 
52503:     fprintf(stderr, "flags:");
52503:     uint32 flags = obj->flags;
52503:     if (flags & JSObject::DELEGATE) fprintf(stderr, " delegate");
52503:     if (flags & JSObject::SYSTEM) fprintf(stderr, " system");
62931:     if (flags & JSObject::NOT_EXTENSIBLE) fprintf(stderr, " not_extensible");
52503:     if (flags & JSObject::BRANDED) fprintf(stderr, " branded");
52503:     if (flags & JSObject::GENERIC) fprintf(stderr, " generic");
52503:     if (flags & JSObject::METHOD_BARRIER) fprintf(stderr, " method_barrier");
52503:     if (flags & JSObject::INDEXED) fprintf(stderr, " indexed");
52503:     if (flags & JSObject::OWN_SHAPE) fprintf(stderr, " own_shape");
56192:     if (flags & JSObject::HAS_EQUALITY) fprintf(stderr, " has_equality");
54563: 
52503:     bool anyFlags = flags != 0;
53569:     if (obj->isNative()) {
52503:         if (obj->inDictionaryMode()) {
52503:             fprintf(stderr, " inDictionaryMode");
52503:             anyFlags = true;
52503:         }
52503:         if (obj->hasPropertyTable()) {
52503:             fprintf(stderr, " hasPropertyTable");
52503:             anyFlags = true;
52503:         }
53569:     }
52503:     if (!anyFlags)
52503:         fprintf(stderr, " none");
52503:     fprintf(stderr, "\n");
52503: 
37003:     if (obj->isDenseArray()) {
55748:         unsigned slots = JS_MIN(obj->getArrayLength(), obj->getDenseArrayCapacity());
19714:         fprintf(stderr, "elements\n");
55748:         for (unsigned i = 0; i < slots; i++) {
19714:             fprintf(stderr, " %3d: ", i);
41782:             dumpValue(obj->getDenseArrayElement(i));
19714:             fprintf(stderr, "\n");
19714:             fflush(stderr);
19714:         }
13437:         return;
13437:     }
13437: 
31452:     fprintf(stderr, "proto ");
48470:     dumpValue(ObjectOrNullValue(obj->getProto()));
31452:     fputc('\n', stderr);
31452: 
31452:     fprintf(stderr, "parent ");
48470:     dumpValue(ObjectOrNullValue(obj->getParent()));
31452:     fputc('\n', stderr);
31452: 
55746:     if (clasp->flags & JSCLASS_HAS_PRIVATE)
31452:         fprintf(stderr, "private %p\n", obj->getPrivate());
31452: 
62931:     if (!obj->isNative())
62931:         fprintf(stderr, "not native\n");
62931: 
55748:     unsigned reservedEnd = JSCLASS_RESERVED_SLOTS(clasp);
55748:     unsigned slots = obj->slotSpan();
62931:     unsigned stop = obj->isNative() ? reservedEnd : slots;
62931:     if (stop > 0)
62931:         fprintf(stderr, obj->isNative() ? "reserved slots:\n" : "slots:\n");
62931:     for (unsigned i = 0; i < stop; i++) {
19714:         fprintf(stderr, " %3d ", i);
31452:         if (i < reservedEnd)
19714:             fprintf(stderr, "(reserved) ");
19714:         fprintf(stderr, "= ");
40410:         dumpValue(obj->getSlot(i));
19714:         fputc('\n', stderr);
19714:     }
62931: 
62931:     if (obj->isNative()) {
62931:         fprintf(stderr, "properties:\n");
62931:         Vector<const Shape *, 8, SystemAllocPolicy> props;
62931:         for (Shape::Range r = obj->lastProperty()->all(); !r.empty(); r.popFront())
62931:             props.append(&r.front());
62931:         for (size_t i = props.length(); i-- != 0;)
62931:             DumpProperty(obj, *props[i]);
62931:     }
19714:     fputc('\n', stderr);
    1: }
    1: 
28665: static void
28665: MaybeDumpObject(const char *name, JSObject *obj)
28665: {
28665:     if (obj) {
28665:         fprintf(stderr, "  %s: ", name);
48470:         dumpValue(ObjectValue(*obj));
28665:         fputc('\n', stderr);
28665:     }
28665: }
28665: 
32774: static void
48470: MaybeDumpValue(const char *name, const Value &v)
48470: {
48470:     if (!v.isNull()) {
32774:         fprintf(stderr, "  %s: ", name);
32774:         dumpValue(v);
32774:         fputc('\n', stderr);
32774:     }
32774: }
32774: 
28665: JS_FRIEND_API(void)
42717: js_DumpStackFrame(JSContext *cx, JSStackFrame *start)
42717: {
42717:     /* This should only called during live debugging. */
42717:     VOUCH_DOES_NOT_REQUIRE_STACK();
42717: 
42717:     if (!start)
51446:         start = cx->maybefp();
42717:     FrameRegsIter i(cx);
42717:     while (!i.done() && i.fp() != start)
42717:         ++i;
42717: 
42717:     if (i.done()) {
42717:         fprintf(stderr, "fp = %p not found in cx = %p\n", (void *)start, (void *)cx);
42717:         return;
42717:     }
42717: 
42717:     for (; !i.done(); ++i) {
42717:         JSStackFrame *const fp = i.fp();
42717: 
28665:         fprintf(stderr, "JSStackFrame at %p\n", (void *) fp);
53840:         if (fp->isFunctionFrame()) {
53840:             fprintf(stderr, "callee fun: ");
53840:             dumpValue(ObjectValue(fp->callee()));
42717:         } else {
28665:             fprintf(stderr, "global frame, no callee");
42717:         }
28665:         fputc('\n', stderr);
28665: 
53840:         if (fp->isScriptFrame()) {
51056:             fprintf(stderr, "file %s line %u\n",
53840:                     fp->script()->filename, (unsigned) fp->script()->lineno);
51056:         }
28665: 
42717:         if (jsbytecode *pc = i.pc()) {
53840:             if (!fp->isScriptFrame()) {
42717:                 fprintf(stderr, "*** pc && !script, skipping frame\n\n");
28665:                 continue;
28665:             }
53840:             if (fp->hasImacropc()) {
28665:                 fprintf(stderr, "  pc in imacro at %p\n  called from ", pc);
53840:                 pc = fp->imacropc();
28665:             } else {
28665:                 fprintf(stderr, "  ");
28665:             }
28665:             fprintf(stderr, "pc = %p\n", pc);
28665:             fprintf(stderr, "  current op: %s\n", js_CodeName[*pc]);
28665:         }
48470:         Value *sp = i.sp();
42714:         fprintf(stderr, "  slots: %p\n", (void *) fp->slots());
42714:         fprintf(stderr, "  sp:    %p = slots + %u\n", (void *) sp, (unsigned) (sp - fp->slots()));
42714:         if (sp - fp->slots() < 10000) { // sanity
48470:             for (Value *p = fp->slots(); p < sp; p++) {
28665:                 fprintf(stderr, "    %p: ", (void *) p);
28665:                 dumpValue(*p);
28665:                 fputc('\n', stderr);
28665:             }
28665:         }
53840:         if (fp->isFunctionFrame() && !fp->isEvalFrame()) {
53840:             fprintf(stderr, "  actuals: %p (%u) ", (void *) fp->actualArgs(), (unsigned) fp->numActualArgs());
53840:             fprintf(stderr, "  formals: %p (%u)\n", (void *) fp->formalArgs(), (unsigned) fp->numFormalArgs());
53840:         }
50510:         MaybeDumpObject("callobj", fp->maybeCallObj());
50510:         MaybeDumpObject("argsobj", fp->maybeArgsObj());
55608:         if (!fp->isDummyFrame()) {
53840:             MaybeDumpValue("this", fp->thisValue());
28665:             fprintf(stderr, "  rval: ");
53840:             dumpValue(fp->returnValue());
55608:         } else {
55608:             fprintf(stderr, "dummy frame");
55608:         }
28665:         fputc('\n', stderr);
28665: 
28665:         fprintf(stderr, "  flags:");
53840:         if (fp->isConstructing())
28665:             fprintf(stderr, " constructing");
53840:         if (fp->hasOverriddenArgs())
53840:             fprintf(stderr, " overridden_args");
53840:         if (fp->isAssigning())
28665:             fprintf(stderr, " assigning");
53840:         if (fp->isDebuggerFrame())
28665:             fprintf(stderr, " debugger");
53840:         if (fp->isEvalFrame())
28665:             fprintf(stderr, " eval");
53840:         if (fp->isYielding())
28665:             fprintf(stderr, " yielding");
53840:         if (fp->isGeneratorFrame())
28665:             fprintf(stderr, " generator");
28665:         fputc('\n', stderr);
28665: 
53840:         fprintf(stderr, "  scopeChain: (JSObject *) %p\n", (void *) &fp->scopeChain());
28665: 
28665:         fputc('\n', stderr);
28665:     }
28665: }
28665: 
53013: #endif /* DEBUG */
53013: 
