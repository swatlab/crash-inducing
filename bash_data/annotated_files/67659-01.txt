 4306: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 4306: /* vim:set tw=80 expandtab softtabstop=2 ts=2 sw=2: */
 4306: /* ***** BEGIN LICENSE BLOCK *****
 4306:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 4306:  *
 4306:  * The contents of this file are subject to the Mozilla Public License Version
 4306:  * 1.1 (the "License"); you may not use this file except in compliance with
 4306:  * the License. You may obtain a copy of the License at
 4306:  * http://www.mozilla.org/MPL/
 4306:  *
 4306:  * Software distributed under the License is distributed on an "AS IS" basis,
 4306:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 4306:  * for the specific language governing rights and limitations under the
 4306:  * License.
 4306:  *
 4306:  * The Original Code is Mozilla Communicator client code.
 4306:  *
 4306:  * The Initial Developer of the Original Code is
 4306:  * Netscape Communications Corporation.
 4306:  * Portions created by the Initial Developer are Copyright (C) 1998
 4306:  * the Initial Developer. All Rights Reserved.
 4306:  *
 4306:  * Contributor(s):
 4306:  *   Mats Palmgren <mats.palmgren@bredband.net>
 4306:  *   Daniel Kraft <d@domob.eu>
 4306:  *
 4306:  * Alternatively, the contents of this file may be used under the terms of
 4306:  * either of the GNU General Public License Version 2 or later (the "GPL"),
 4306:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 4306:  * in which case the provisions of the GPL or the LGPL are applicable instead
 4306:  * of those above. If you wish to allow use of your version of this file only
 4306:  * under the terms of either the GPL or the LGPL, and not to allow others to
 4306:  * use your version of this file under the terms of the MPL, indicate your
 4306:  * decision by deleting the provisions above and replace them with the notice
 4306:  * and other provisions required by the GPL or the LGPL. If you do not delete
 4306:  * the provisions above, a recipient may use your version of this file under
 4306:  * the terms of any one of the MPL, the GPL or the LGPL.
 4306:  *
 4306:  * ***** END LICENSE BLOCK ***** */
 4306: 
 4306: #include "nsStyledElement.h"
 4306: #include "nsGkAtoms.h"
 4306: #include "nsAttrValue.h"
 4306: #include "nsGenericElement.h"
 4306: #include "nsMutationEvent.h"
 4306: #include "nsDOMCSSDeclaration.h"
27107: #include "nsDOMCSSAttrDeclaration.h"
 4306: #include "nsServiceManagerUtils.h"
 4306: #include "nsIDocument.h"
63693: #include "mozilla/css/StyleRule.h"
38849: #include "nsCSSParser.h"
47937: #include "mozilla/css/Loader.h"
38453: #include "nsIDOMMutationEvent.h"
48944: #include "nsXULElement.h"
 4314: 
 4314: #ifdef MOZ_SVG
 4306: #include "nsIDOMSVGStylable.h"
 4314: #endif
 4306: 
63693: namespace css = mozilla::css;
63693: 
 4306: //----------------------------------------------------------------------
 4306: // nsIContent methods
 4306: 
 4306: nsIAtom*
67659: nsStyledElementNotElementCSSInlineStyle::GetClassAttributeName() const
 4306: {
 4306:   return nsGkAtoms::_class;
 4306: }
 4306: 
 4306: nsIAtom*
67659: nsStyledElementNotElementCSSInlineStyle::GetIDAttributeName() const
 4306: {
 4306:   return nsGkAtoms::id;
 4306: }
 4306: 
43079: nsIAtom*
67659: nsStyledElementNotElementCSSInlineStyle::DoGetID() const
43079: {
43079:   NS_ASSERTION(HasFlag(NODE_HAS_ID), "Unexpected call");
43079: 
43079:   // The nullcheck here is needed because nsGenericElement::UnsetAttr calls
43079:   // out to various code between removing the attribute and we get a chance to
43079:   // clear the NODE_HAS_ID flag.
43079: 
43079:   const nsAttrValue* attr = mAttrsAndChildren.GetAttr(nsGkAtoms::id);
43079: 
43079:   return attr ? attr->GetAtomValue() : nsnull;
43079: }
43079: 
 4306: const nsAttrValue*
67659: nsStyledElementNotElementCSSInlineStyle::DoGetClasses() const
 4306: {
19132:   NS_ASSERTION(HasFlag(NODE_MAY_HAVE_CLASS), "Unexpected call");
 5540:   return mAttrsAndChildren.GetAttr(nsGkAtoms::_class);
 4306: }
 4306: 
 4306: PRBool
67659: nsStyledElementNotElementCSSInlineStyle::ParseAttribute(PRInt32 aNamespaceID,
67659:                                                         nsIAtom* aAttribute,
67659:                                                         const nsAString& aValue,
67659:                                                         nsAttrValue& aResult)
 4306: {
 4306:   if (aNamespaceID == kNameSpaceID_None) {
 4306:     if (aAttribute == nsGkAtoms::style) {
 6041:       SetFlags(NODE_MAY_HAVE_STYLE);
38452:       ParseStyleAttribute(aValue, aResult, PR_FALSE);
 4306:       return PR_TRUE;
 4306:     }
 4306:     if (aAttribute == nsGkAtoms::_class) {
 6041:       SetFlags(NODE_MAY_HAVE_CLASS);
 4306:       aResult.ParseAtomArray(aValue);
 4306:       return PR_TRUE;
 4306:     }
43079:     if (aAttribute == nsGkAtoms::id) {
43079:       // Store id as an atom.  id="" means that the element has no id,
43079:       // not that it has an emptystring as the id.
43079:       RemoveFromIdTable();
43079:       if (aValue.IsEmpty()) {
43079:         UnsetFlags(NODE_HAS_ID);
43079:         return PR_FALSE;
43079:       }
43079:       aResult.ParseAtom(aValue);
43079:       SetFlags(NODE_HAS_ID);
43079:       AddToIdTable(aResult.GetAtomValue());
43079:       return PR_TRUE;
43079:     }
 4306:   }
 4306: 
 4306:   return nsStyledElementBase::ParseAttribute(aNamespaceID, aAttribute, aValue,
 4306:                                              aResult);
 4306: }
 4306: 
43079: nsresult
67659: nsStyledElementNotElementCSSInlineStyle::UnsetAttr(PRInt32 aNameSpaceID,
67659:                                                    nsIAtom* aAttribute,
43079:                                                    PRBool aNotify)
43079: {
63259:   nsAutoRemovableScriptBlocker scriptBlocker;
43079:   if (aAttribute == nsGkAtoms::id && aNameSpaceID == kNameSpaceID_None) {
43079:     // Have to do this before clearing flag. See RemoveFromIdTable
43079:     RemoveFromIdTable();
43079:   }
43079: 
51985:   return nsGenericElement::UnsetAttr(aNameSpaceID, aAttribute, aNotify);
51985: }
51858: 
51985: nsresult
67659: nsStyledElementNotElementCSSInlineStyle::AfterSetAttr(PRInt32 aNamespaceID,
67659:                                                       nsIAtom* aAttribute,
67659:                                                       const nsAString* aValue,
67659:                                                       PRBool aNotify)
51985: {
51985:   if (aNamespaceID == kNameSpaceID_None && !aValue &&
51985:       aAttribute == nsGkAtoms::id) {
51985:     // The id has been removed when calling UnsetAttr but we kept it because
51985:     // the id is used for some layout stuff between UnsetAttr and AfterSetAttr.
51985:     // Now. the id is really removed so it would not be safe to keep this flag.
43079:     UnsetFlags(NODE_HAS_ID);
43079:   }
43079: 
51985:   return nsGenericElement::AfterSetAttr(aNamespaceID, aAttribute, aValue,
51985:                                         aNotify);
43079: }
43079: 
 4306: NS_IMETHODIMP
67659: nsStyledElementNotElementCSSInlineStyle::SetInlineStyleRule(css::StyleRule* aStyleRule,
67659:                                                             PRBool aNotify)
 4306: {
 6041:   SetFlags(NODE_MAY_HAVE_STYLE);
 4306:   PRBool modification = PR_FALSE;
 4306:   nsAutoString oldValueStr;
 4306: 
 4306:   PRBool hasListeners = aNotify &&
 4306:     nsContentUtils::HasMutationListeners(this,
 4306:                                          NS_EVENT_BITS_MUTATION_ATTRMODIFIED,
 4306:                                          this);
 4306: 
 4306:   // There's no point in comparing the stylerule pointers since we're always
 4306:   // getting a new stylerule here. And we can't compare the stringvalues of
 4306:   // the old and the new rules since both will point to the same declaration
 4306:   // and thus will be the same.
 4306:   if (hasListeners) {
 4306:     // save the old attribute so we can set up the mutation event properly
 4306:     // XXXbz if the old rule points to the same declaration as the new one,
 4306:     // this is getting the new attr value, not the old one....
 4306:     modification = GetAttr(kNameSpaceID_None, nsGkAtoms::style,
 4306:                            oldValueStr);
 4306:   }
 4306:   else if (aNotify && IsInDoc()) {
 4306:     modification = !!mAttrsAndChildren.GetAttr(nsGkAtoms::style);
 4306:   }
 4306: 
50380:   nsAttrValue attrValue(aStyleRule, nsnull);
 4306: 
38453:   // XXXbz do we ever end up with ADDITION here?  I doubt it.
38453:   PRUint8 modType = modification ?
38453:     static_cast<PRUint8>(nsIDOMMutationEvent::MODIFICATION) :
38453:     static_cast<PRUint8>(nsIDOMMutationEvent::ADDITION);
38453: 
 4306:   return SetAttrAndNotify(kNameSpaceID_None, nsGkAtoms::style, nsnull,
38453:                           oldValueStr, attrValue, modType, hasListeners,
22222:                           aNotify, nsnull);
 4306: }
 4306: 
63693: css::StyleRule*
67659: nsStyledElementNotElementCSSInlineStyle::GetInlineStyleRule()
 4306: {
 6041:   if (!HasFlag(NODE_MAY_HAVE_STYLE)) {
 6041:     return nsnull;
 6041:   }
 4306:   const nsAttrValue* attrVal = mAttrsAndChildren.GetAttr(nsGkAtoms::style);
 4306: 
 4306:   if (attrVal && attrVal->Type() == nsAttrValue::eCSSStyleRule) {
 4306:     return attrVal->GetCSSStyleRuleValue();
 4306:   }
 4306: 
 4306:   return nsnull;
 4306: }
 4306: 
 4306: nsresult
67659: nsStyledElementNotElementCSSInlineStyle::BindToTree(nsIDocument* aDocument,
67659:                                                     nsIContent* aParent,
 4306:                                                     nsIContent* aBindingParent,
 4306:                                                     PRBool aCompileEventHandlers)
 4306: {
 4306:   nsresult rv = nsStyledElementBase::BindToTree(aDocument, aParent,
 4306:                                                 aBindingParent,
 4306:                                                 aCompileEventHandlers);
 4306:   NS_ENSURE_SUCCESS(rv, rv);
 4306: 
43079:   if (aDocument && HasFlag(NODE_HAS_ID) && !GetBindingParent()) {
43079:     aDocument->AddToIdTable(this, DoGetID());
43079:   }
43079: 
43079:   if (!IsXUL()) {
 4306:     // XXXbz if we already have a style attr parsed, this won't do
 4306:     // anything... need to fix that.
11871:     ReparseStyleAttribute(PR_FALSE);
43079:   }
 4306: 
43079:   return NS_OK;
 4306: }
 4306: 
43079: void
67659: nsStyledElementNotElementCSSInlineStyle::UnbindFromTree(PRBool aDeep,
67659:                                                         PRBool aNullParent)
43079: {
55416:   RemoveFromIdTable();
43079: 
43079:   nsStyledElementBase::UnbindFromTree(aDeep, aNullParent);
43079: }
43079: 
43079: 
 4306: // ---------------------------------------------------------------
 4306: // Others and helpers
 4306: 
48944: nsIDOMCSSStyleDeclaration*
67659: nsStyledElementNotElementCSSInlineStyle::GetStyle(nsresult* retval)
 4306: {
48944:   nsXULElement* xulElement = nsXULElement::FromContent(this);
48944:   if (xulElement) {
48944:     nsresult rv = xulElement->EnsureLocalStyle();
48944:     if (NS_FAILED(rv)) {
48944:       *retval = rv;
48944:       return nsnull;
48944:     }
48944:   }
48944:     
59659:   nsGenericElement::nsDOMSlots *slots = DOMSlots();
 4306: 
 4306:   if (!slots->mStyle) {
 4306:     // Just in case...
11871:     ReparseStyleAttribute(PR_TRUE);
 4306: 
32193:     slots->mStyle = new nsDOMCSSAttributeDeclaration(this
32193: #ifdef MOZ_SMIL
32193:                                                      , PR_FALSE
32193: #endif // MOZ_SMIL
32193:                                                      );
 6041:     SetFlags(NODE_MAY_HAVE_STYLE);
 4306:   }
 4306: 
48944:   *retval = NS_OK;
48944:   return slots->mStyle;
 4306: }
 4306: 
 4306: nsresult
67659: nsStyledElementNotElementCSSInlineStyle::ReparseStyleAttribute(PRBool aForceInDataDoc)
 4306: {
 6041:   if (!HasFlag(NODE_MAY_HAVE_STYLE)) {
 6041:     return NS_OK;
 6041:   }
 4306:   const nsAttrValue* oldVal = mAttrsAndChildren.GetAttr(nsGkAtoms::style);
 4306:   
 4306:   if (oldVal && oldVal->Type() != nsAttrValue::eCSSStyleRule) {
 4306:     nsAttrValue attrValue;
 4306:     nsAutoString stringValue;
 4306:     oldVal->ToString(stringValue);
38452:     ParseStyleAttribute(stringValue, attrValue, aForceInDataDoc);
 4306:     // Don't bother going through SetInlineStyleRule, we don't want to fire off
 4306:     // mutation events or document notifications anyway
 4306:     nsresult rv = mAttrsAndChildren.SetAndTakeAttr(nsGkAtoms::style, attrValue);
 4306:     NS_ENSURE_SUCCESS(rv, rv);
 4306:   }
 4306:   
 4306:   return NS_OK;
 4306: }
 4306: 
 4306: void
67659: nsStyledElementNotElementCSSInlineStyle::ParseStyleAttribute(const nsAString& aValue,
11871:                                                              nsAttrValue& aResult,
11871:                                                              PRBool aForceInDataDoc)
 4306: {
38452:   nsIDocument* doc = GetOwnerDoc();
 4306: 
35581:   if (doc && (aForceInDataDoc ||
35581:               !doc->IsLoadedAsData() ||
35581:               doc->IsStaticDocument())) {
 4306:     PRBool isCSS = PR_TRUE; // assume CSS until proven otherwise
 4306: 
38452:     if (!IsInNativeAnonymousSubtree()) {  // native anonymous content
 4306:                                           // always assumes CSS
 4306:       nsAutoString styleType;
 4306:       doc->GetHeaderData(nsGkAtoms::headerContentStyleType, styleType);
 4306:       if (!styleType.IsEmpty()) {
 4306:         static const char textCssStr[] = "text/css";
 4306:         isCSS = (styleType.EqualsIgnoreCase(textCssStr, sizeof(textCssStr) - 1));
 4306:       }
 4306:     }
 4306: 
 4306:     if (isCSS) {
63693:       css::Loader* cssLoader = doc->CSSLoader();
38849:       nsCSSParser cssParser(cssLoader);
 4306:       if (cssParser) {
38452:         nsCOMPtr<nsIURI> baseURI = GetBaseURI();
 4306: 
63693:         nsRefPtr<css::StyleRule> rule;
38849:         cssParser.ParseStyleAttribute(aValue, doc->GetDocumentURI(),
 4306:                                       baseURI,
38452:                                       NodePrincipal(),
 4306:                                       getter_AddRefs(rule));
 4306:         if (rule) {
50380:           aResult.SetTo(rule, &aValue);
 4306:           return;
 4306:         }
 4306:       }
 4306:     }
 4306:   }
 4306: 
 4306:   aResult.SetTo(aValue);
 4306: }
