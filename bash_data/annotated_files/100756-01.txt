 98983: # This Source Code Form is subject to the terms of the Mozilla Public
 98983: # License, v. 2.0. If a copy of the MPL was not distributed with this
 98983: # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 35742: 
 35742: import sys
 35742: 
 35742: class Visitor:
 35742:     def defaultVisit(self, node):
 35742:         raise Exception, "INTERNAL ERROR: no visitor for node type `%s'"% (
 35742:             node.__class__.__name__)
 35742: 
 35742:     def visitTranslationUnit(self, tu):
 35742:         for cxxInc in tu.cxxIncludes:
 35742:             cxxInc.accept(self)
 35742:         for protoInc in tu.protocolIncludes:
 35742:             protoInc.accept(self)
 42564:         for su in tu.structsAndUnions:
 42564:             su.accept(self)
 35742:         for using in tu.using:
 35742:             using.accept(self)
 35742:         tu.protocol.accept(self)
 35742: 
 35742:     def visitCxxInclude(self, inc):
 35742:         pass
 35742: 
 35742:     def visitProtocolInclude(self, inc):
 35742:         # Note: we don't visit the child AST here, because that needs delicate
 35742:         # and pass-specific handling
 35742:         pass
 35742: 
 42564:     def visitStructDecl(self, struct):
 42564:         for f in struct.fields:
 42564:             f.accept(self)
 42564: 
 42564:     def visitStructField(self, field):
 42564:         field.type.accept(self)
 42564: 
 35900:     def visitUnionDecl(self, union):
 35900:         for t in union.components:
 35900:             t.accept(self)
 35900: 
 35742:     def visitUsingStmt(self, using):
 35742:         pass
 35742: 
 35742:     def visitProtocol(self, p):
 35742:         for namespace in p.namespaces:
 35742:             namespace.accept(self)
 42560:         for spawns in p.spawnsStmts:
 42560:             spawns.accept(self)
 42560:         for bridges in p.bridgesStmts:
 42560:             bridges.accept(self)
 71249:         for opens in p.opensStmts:
 71249:             opens.accept(self)
 38096:         for mgr in p.managers:
 38096:             mgr.accept(self)
 35742:         for managed in p.managesStmts:
 35742:             managed.accept(self)
 35742:         for msgDecl in p.messageDecls:
 35742:             msgDecl.accept(self)
 35742:         for transitionStmt in p.transitionStmts:
 35742:             transitionStmt.accept(self)
 35742: 
 35742:     def visitNamespace(self, ns):
 35742:         pass
 35742: 
 42560:     def visitSpawnsStmt(self, spawns):
 42560:         pass
 42560: 
 42560:     def visitBridgesStmt(self, bridges):
 42560:         pass
 42560: 
 71249:     def visitOpensStmt(self, opens):
 71249:         pass
 71249: 
 38096:     def visitManager(self, mgr):
 35742:         pass
 35742: 
 35742:     def visitManagesStmt(self, mgs):
 35742:         pass
 35742: 
 35742:     def visitMessageDecl(self, md):
 35742:         for inParam in md.inParams:
 35742:             inParam.accept(self)
 35742:         for outParam in md.outParams:
 35742:             outParam.accept(self)
 35742: 
 35763:     def visitTransitionStmt(self, ts):
 35763:         ts.state.accept(self)
 35763:         for trans in ts.transitions:
 35763:             trans.accept(self)
 35763: 
 35763:     def visitTransition(self, t):
 35998:         for toState in t.toStates:
 35998:             toState.accept(self)
 35763: 
 35763:     def visitState(self, s):
 35763:         pass
 35763: 
 35742:     def visitParam(self, decl):
 35742:         pass
 35742: 
 35742:     def visitTypeSpec(self, ts):
 35742:         pass
 35742: 
 35742:     def visitDecl(self, d):
 35742:         pass
 35742: 
 35742: class Loc:
 35742:     def __init__(self, filename='<??>', lineno=0):
 35742:         assert filename
 35742:         self.filename = filename
 35742:         self.lineno = lineno
 35742:     def __repr__(self):
 35742:         return '%r:%r'% (self.filename, self.lineno)
 35742:     def __str__(self):
 35742:         return '%s:%s'% (self.filename, self.lineno)
 35742: 
 35742: Loc.NONE = Loc(filename='<??>', lineno=0)
 35742: 
 36276: class _struct:
 35742:     pass
 35742: 
 35742: class Node:
 35742:     def __init__(self, loc=Loc.NONE):
 35742:         self.loc = loc
 35742: 
 35742:     def accept(self, visitor):
 35742:         visit = getattr(visitor, 'visit'+ self.__class__.__name__, None)
 35742:         if visit is None:
 35742:             return getattr(visitor, 'defaultVisit')(self)
 35742:         return visit(self)
 35742: 
 35742:     def addAttrs(self, attrsName):
 35742:         if not hasattr(self, attrsName):
 35742:             setattr(self, attrsName, _struct())
 35742: 
 35900: 
 35900: class NamespacedNode(Node):
 35900:     def __init__(self, loc=Loc.NONE, name=None):
 35900:         Node.__init__(self, loc)
 35900:         self.name = name
 35900:         self.namespaces = [ ]  
 35900: 
 35900:     def addOuterNamespace(self, namespace):
 35900:         self.namespaces.insert(0, namespace)
 35900: 
 35900:     def qname(self):
 35900:         return QualifiedId(self.loc, self.name,
 35990:                            [ ns.name for ns in self.namespaces ])
 35900: 
 35742: class TranslationUnit(Node):
 35742:     def __init__(self):
 35742:         Node.__init__(self)
 35742:         self.filename = None
 35742:         self.cxxIncludes = [ ]
 35742:         self.protocolIncludes = [ ]
 35742:         self.using = [ ]
 42564:         self.structsAndUnions = [ ]
 35742:         self.protocol = None
 35742: 
 35742:     def addCxxInclude(self, cxxInclude): self.cxxIncludes.append(cxxInclude)
 35742:     def addProtocolInclude(self, pInc): self.protocolIncludes.append(pInc)
 42564:     def addStructDecl(self, struct): self.structsAndUnions.append(struct)
 42564:     def addUnionDecl(self, union): self.structsAndUnions.append(union)
 35742:     def addUsingStmt(self, using): self.using.append(using)
 35742: 
 35742:     def setProtocol(self, protocol): self.protocol = protocol
 35742: 
 35742: class CxxInclude(Node):
 35742:     def __init__(self, loc, cxxFile):
 35742:         Node.__init__(self, loc)
 35742:         self.file = cxxFile
 35742: 
 35742: class ProtocolInclude(Node):
 41366:     def __init__(self, loc, protocolName):
 35742:         Node.__init__(self, loc)
 41366:         self.file = "%s.ipdl" % protocolName
 35742: 
 35742: class UsingStmt(Node):
 35742:     def __init__(self, loc, cxxTypeSpec):
 35742:         Node.__init__(self, loc)
 35742:         self.type = cxxTypeSpec
 35742: 
 35742: # "singletons"
 35742: class ASYNC:
 35763:     pretty = 'async'
 35763:     @classmethod
 35763:     def __hash__(cls): return hash(cls.pretty)
 35763:     @classmethod
 35763:     def __str__(cls):  return cls.pretty
 35742: class RPC:
 35763:     pretty = 'rpc'
 35763:     @classmethod
 35763:     def __hash__(cls): return hash(cls.pretty)
 35763:     @classmethod
 35763:     def __str__(cls):  return cls.pretty
 35742: class SYNC:
 35763:     pretty = 'sync'
 35763:     @classmethod
 35763:     def __hash__(cls): return hash(cls.pretty)
 35763:     @classmethod
 35763:     def __str__(cls):  return cls.pretty
 35742: 
 35742: class INOUT:
 35763:     pretty = 'inout'
 35763:     @classmethod
 35763:     def __hash__(cls): return hash(cls.pretty)
 35763:     @classmethod
 35763:     def __str__(cls):  return cls.pretty
 35742: class IN:
 35763:     pretty = 'in'
 35763:     @classmethod
 35763:     def __hash__(cls): return hash(cls.pretty)
 35763:     @classmethod
 35763:     def __str__(cls):  return cls.pretty
 35742:     @staticmethod
 35763:     def prettySS(cls, ss): return _prettyTable['in'][ss.pretty]
 35742: class OUT:
 35763:     pretty = 'out'
 35763:     @classmethod
 35763:     def __hash__(cls): return hash(cls.pretty)
 35763:     @classmethod
 35763:     def __str__(cls):  return cls.pretty
 35742:     @staticmethod
 35769:     def prettySS(ss): return _prettyTable['out'][ss.pretty]
 35742: 
 35742: _prettyTable = {
 35763:     IN  : { 'async': 'AsyncRecv',
 35763:             'sync': 'SyncRecv',
 35763:             'rpc': 'RpcAnswer' },
 35763:     OUT : { 'async': 'AsyncSend',
 35763:             'sync': 'SyncSend',
 35763:             'rpc': 'RpcCall' }
 35742:     # inout doesn't make sense here
 35742: }
 35742: 
 35742: 
 35900: class Namespace(Node):
 35900:     def __init__(self, loc, namespace):
 35900:         Node.__init__(self, loc)
 35990:         self.name = namespace
 35900: 
 35900: class Protocol(NamespacedNode):
 35742:     def __init__(self, loc):
 35900:         NamespacedNode.__init__(self, loc)
 35742:         self.sendSemantics = ASYNC
 42560:         self.spawnsStmts = [ ]
 42560:         self.bridgesStmts = [ ]
 71249:         self.opensStmts = [ ]
 38096:         self.managers = [ ]
 35742:         self.managesStmts = [ ]
 35742:         self.messageDecls = [ ]
 35742:         self.transitionStmts = [ ]
 35867:         self.startStates = [ ]
 35742: 
 42564: class StructField(Node):
 42564:     def __init__(self, loc, type, name):
 42564:         Node.__init__(self, loc)
 42564:         self.type = type
 42564:         self.name = name
 42564: 
 42564: class StructDecl(NamespacedNode):
 42564:     def __init__(self, loc, name, fields):
 42564:         NamespacedNode.__init__(self, loc, name)
 42564:         self.fields = fields
 42564: 
 35900: class UnionDecl(NamespacedNode):
 35900:     def __init__(self, loc, name, components):
 35900:         NamespacedNode.__init__(self, loc, name)
 35900:         self.components = components
 35742: 
 42560: class SpawnsStmt(Node):
 42560:     def __init__(self, loc, side, proto, spawnedAs):
 42560:         Node.__init__(self, loc)
 42560:         self.side = side
 42560:         self.proto = proto
 42560:         self.spawnedAs = spawnedAs
 42560: 
 42560: class BridgesStmt(Node):
 42560:     def __init__(self, loc, parentSide, childSide):
 42560:         Node.__init__(self, loc)
 42560:         self.parentSide = parentSide
 42560:         self.childSide = childSide
 42560: 
 71249: class OpensStmt(Node):
 71249:     def __init__(self, loc, side, proto):
 71249:         Node.__init__(self, loc)
 71249:         self.side = side
 71249:         self.proto = proto
 71249: 
 38096: class Manager(Node):
 35742:     def __init__(self, loc, managerName):
 35742:         Node.__init__(self, loc)
 35742:         self.name = managerName
 35742: 
 35742: class ManagesStmt(Node):
 35742:     def __init__(self, loc, managedName):
 35742:         Node.__init__(self, loc)
 35742:         self.name = managedName
 35742: 
 35742: class MessageDecl(Node):
 35742:     def __init__(self, loc):
 35742:         Node.__init__(self, loc)
 35742:         self.name = None
 35742:         self.sendSemantics = ASYNC
 35742:         self.direction = None
 35742:         self.inParams = [ ]
 35742:         self.outParams = [ ]
 35742: 
 35742:     def addInParams(self, inParamsList):
 35742:         self.inParams += inParamsList
 35742: 
 35742:     def addOutParams(self, outParamsList):
 35742:         self.outParams += outParamsList
 35742: 
 35742:     def hasReply(self):
 35742:         return self.sendSemantics is SYNC or self.sendSemantics is RPC
 35742: 
 35763: class Transition(Node):
 35868:     def __init__(self, loc, trigger, msg, toStates):
 35763:         Node.__init__(self, loc)
 35763:         self.trigger = trigger
 35763:         self.msg = msg
 35868:         self.toStates = toStates
 35763: 
 36171:     def __cmp__(self, o):
 36171:         c = cmp(self.msg, o.msg)
 36171:         if c: return c
 36171:         c = cmp(self.trigger, o.trigger)
 36171:         if c: return c
 36171: 
 36171:     def __hash__(self): return hash(str(self))
 36171:     def __str__(self): return '%s %s'% (self.trigger, self.msg)
 36171: 
 35763:     @staticmethod
 35763:     def nameToTrigger(name):
 35763:         return { 'send': SEND, 'recv': RECV, 'call': CALL, 'answer': ANSWER }[name]
 35763: 
 36138: Transition.NULL = Transition(Loc.NONE, None, None, [ ])
 36138: 
 36138: class TransitionStmt(Node):
 36138:     def __init__(self, loc, state, transitions):
 36138:         Node.__init__(self, loc)
 36138:         self.state = state
 36138:         self.transitions = transitions
 36138: 
 36138:     @staticmethod
 36138:     def makeNullStmt(state):
 36138:         return TransitionStmt(Loc.NONE, state, [ Transition.NULL ])
 36138: 
 35763: class SEND:
 35763:     pretty = 'send'
 35763:     @classmethod
 35763:     def __hash__(cls): return hash(cls.pretty)
 35796:     @classmethod
 35796:     def direction(cls): return OUT
 35763: class RECV:
 35763:     pretty = 'recv'
 35763:     @classmethod
 35763:     def __hash__(cls): return hash(cls.pretty)
 35796:     @classmethod
 35796:     def direction(cls): return IN
 35763: class CALL:
 35763:     pretty = 'call'
 35763:     @classmethod
 35763:     def __hash__(cls): return hash(cls.pretty)
 35796:     @classmethod
 35796:     def direction(cls): return OUT
 35763: class ANSWER:
 35763:     pretty = 'answer'
 35763:     @classmethod
 35763:     def __hash__(cls): return hash(cls.pretty)
 35796:     @classmethod
 35796:     def direction(cls): return IN
 35763: 
 35763: class State(Node):
 35867:     def __init__(self, loc, name, start=False):
 35763:         Node.__init__(self, loc)
 35763:         self.name = name
 35867:         self.start = start
 35793:     def __eq__(self, o):
 35867:          return (isinstance(o, State)
 35867:                  and o.name == self.name
 35867:                  and o.start == self.start)
 35793:     def __hash__(self):
 35793:         return hash(repr(self))
 35796:     def __ne__(self, o):
 35796:         return not (self == o)
 35868:     def __repr__(self): return '<State %r start=%r>'% (self.name, self.start)
 35867:     def __str__(self): return '<State %s start=%s>'% (self.name, self.start)
 35763: 
 35894: State.ANY = State(Loc.NONE, '[any]', start=True)
 36138: State.DEAD = State(Loc.NONE, '[dead]', start=False)
100756: State.DYING = State(Loc.NONE, '[dying]', start=False)
 35894: 
 35742: class Param(Node):
 35742:     def __init__(self, loc, typespec, name):
 35742:         Node.__init__(self, loc)
 35742:         self.name = name
 35742:         self.typespec = typespec
 35742: 
 35742: class TypeSpec(Node):
 36135:     def __init__(self, loc, spec, state=None, array=0, nullable=0,
 36135:                  myChmod=None, otherChmod=None):
 35742:         Node.__init__(self, loc)
 36135:         self.spec = spec                # QualifiedId
 36135:         self.state = state              # None or State
 36135:         self.array = array              # bool
 36135:         self.nullable = nullable        # bool
 36135:         self.myChmod = myChmod          # None or string
 36135:         self.otherChmod = otherChmod    # None or string
 35742: 
 35742:     def basename(self):
 35742:         return self.spec.baseid
 35742: 
 35764:     def isActor(self):
 35764:         return self.state is not None
 35764: 
 35742:     def __str__(self):  return str(self.spec)
 35742: 
 35742: class QualifiedId:              # FIXME inherit from node?
 35742:     def __init__(self, loc, baseid, quals=[ ]):
 35813:         assert isinstance(baseid, str)
 35813:         for qual in quals: assert isinstance(qual, str)
 35813: 
 35742:         self.loc = loc
 35742:         self.baseid = baseid
 35742:         self.quals = quals
 35742: 
 35742:     def qualify(self, id):
 35742:         self.quals.append(self.baseid)
 35742:         self.baseid = id
 35742: 
 35742:     def __str__(self):
 35742:         if 0 == len(self.quals):
 35742:             return self.baseid
 35742:         return '::'.join(self.quals) +'::'+ self.baseid
 35742: 
 35742: # added by type checking passes
 35742: class Decl(Node):
 35742:     def __init__(self, loc):
 35742:         Node.__init__(self, loc)
 35742:         self.progname = None    # what the programmer typed, if relevant
 35742:         self.shortname = None   # shortest way to refer to this decl
 35742:         self.fullname = None    # full way to refer to this decl
 35742:         self.loc = loc
 35742:         self.type = None
 35742:         self.scope = None
