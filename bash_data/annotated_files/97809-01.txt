    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Novell code.
    1:  *
    1:  * The Initial Developer of the Original Code is Novell Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2006
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   robert@ocallahan.org
97472:  *   Jonathan Kew <jfkthame@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsTextRunTransformations.h"
    1: 
    1: #include "nsTextFrameUtils.h"
    1: #include "gfxSkipChars.h"
94515: #include "nsGkAtoms.h"
    1: 
    1: #include "nsStyleConsts.h"
    1: #include "nsStyleContext.h"
    1: #include "gfxContext.h"
 3049: #include "nsContentUtils.h"
48377: #include "nsUnicharUtils.h"
95461: #include "nsUnicodeProperties.h"
96805: #include "nsSpecialCasingData.h"
    1: 
94165: // Unicode characters needing special casing treatment in tr/az languages
94165: #define LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE  0x0130
94165: #define LATIN_SMALL_LETTER_DOTLESS_I           0x0131
94165: 
95461: // Greek sigma needs custom handling for the lowercase transform; for details
95461: // see comments under "case NS_STYLE_TEXT_TRANSFORM_LOWERCASE" within
95461: // nsCaseTransformTextRunFactory::RebuildTextRun(), and bug 740120.
95461: #define GREEK_CAPITAL_LETTER_SIGMA             0x03A3
95461: #define GREEK_SMALL_LETTER_FINAL_SIGMA         0x03C2
95461: #define GREEK_SMALL_LETTER_SIGMA               0x03C3
95461: 
97472: // Custom uppercase mapping for Greek; see bug 307039 for details
97472: #define GREEK_LOWER_ALPHA                      0x03B1
97472: #define GREEK_LOWER_ALPHA_TONOS                0x03AC
97472: #define GREEK_LOWER_ALPHA_OXIA                 0x1F71
97472: #define GREEK_LOWER_EPSILON                    0x03B5
97472: #define GREEK_LOWER_EPSILON_TONOS              0x03AD
97472: #define GREEK_LOWER_EPSILON_OXIA               0x1F73
97472: #define GREEK_LOWER_ETA                        0x03B7
97472: #define GREEK_LOWER_ETA_TONOS                  0x03AE
97472: #define GREEK_LOWER_ETA_OXIA                   0x1F75
97472: #define GREEK_LOWER_IOTA                       0x03B9
97472: #define GREEK_LOWER_IOTA_TONOS                 0x03AF
97472: #define GREEK_LOWER_IOTA_OXIA                  0x1F77
97472: #define GREEK_LOWER_IOTA_DIALYTIKA             0x03CA
97472: #define GREEK_LOWER_IOTA_DIALYTIKA_TONOS       0x0390
97472: #define GREEK_LOWER_IOTA_DIALYTIKA_OXIA        0x1FD3
97472: #define GREEK_LOWER_OMICRON                    0x03BF
97472: #define GREEK_LOWER_OMICRON_TONOS              0x03CC
97472: #define GREEK_LOWER_OMICRON_OXIA               0x1F79
97472: #define GREEK_LOWER_UPSILON                    0x03C5
97472: #define GREEK_LOWER_UPSILON_TONOS              0x03CD
97472: #define GREEK_LOWER_UPSILON_OXIA               0x1F7B
97472: #define GREEK_LOWER_UPSILON_DIALYTIKA          0x03CB
97472: #define GREEK_LOWER_UPSILON_DIALYTIKA_TONOS    0x03B0
97472: #define GREEK_LOWER_UPSILON_DIALYTIKA_OXIA     0x1FE3
97472: #define GREEK_LOWER_OMEGA                      0x03C9
97472: #define GREEK_LOWER_OMEGA_TONOS                0x03CE
97472: #define GREEK_LOWER_OMEGA_OXIA                 0x1F7D
97472: #define GREEK_UPPER_ALPHA                      0x0391
97472: #define GREEK_UPPER_EPSILON                    0x0395
97472: #define GREEK_UPPER_ETA                        0x0397
97472: #define GREEK_UPPER_IOTA                       0x0399
97472: #define GREEK_UPPER_IOTA_DIALYTIKA             0x03AA
97472: #define GREEK_UPPER_OMICRON                    0x039F
97472: #define GREEK_UPPER_UPSILON                    0x03A5
97472: #define GREEK_UPPER_UPSILON_DIALYTIKA          0x03AB
97472: #define GREEK_UPPER_OMEGA                      0x03A9
97472: #define GREEK_UPPER_ALPHA_TONOS                0x0386
97472: #define GREEK_UPPER_ALPHA_OXIA                 0x1FBB
97472: #define GREEK_UPPER_EPSILON_TONOS              0x0388
97472: #define GREEK_UPPER_EPSILON_OXIA               0x1FC9
97472: #define GREEK_UPPER_ETA_TONOS                  0x0389
97472: #define GREEK_UPPER_ETA_OXIA                   0x1FCB
97472: #define GREEK_UPPER_IOTA_TONOS                 0x038A
97472: #define GREEK_UPPER_IOTA_OXIA                  0x1FDB
97472: #define GREEK_UPPER_OMICRON_TONOS              0x038C
97472: #define GREEK_UPPER_OMICRON_OXIA               0x1FF9
97472: #define GREEK_UPPER_UPSILON_TONOS              0x038E
97472: #define GREEK_UPPER_UPSILON_OXIA               0x1FEB
97472: #define GREEK_UPPER_OMEGA_TONOS                0x038F
97472: #define GREEK_UPPER_OMEGA_OXIA                 0x1FFB
97472: #define COMBINING_ACUTE_ACCENT                 0x0301
97472: #define COMBINING_DIAERESIS                    0x0308
97472: #define COMBINING_ACUTE_TONE_MARK              0x0341
97472: #define COMBINING_GREEK_DIALYTIKA_TONOS        0x0344
97472: 
97472: // When doing an Uppercase transform in Greek, we need to keep track of the
97472: // current state while iterating through the string, to recognize and process
97472: // diphthongs correctly. For clarity, we define a state for each vowel and
97472: // each vowel with accent, although a few of these do not actually need any
97472: // special treatment and could be folded into kStart.
97472: enum GreekCasingState {
97472:   kStart,
97472:   kAlpha,
97472:   kEpsilon,
97472:   kEta,
97472:   kIota,
97472:   kOmicron,
97472:   kUpsilon,
97472:   kOmega,
97472:   kAlphaAcc,
97472:   kEpsilonAcc,
97472:   kEtaAcc,
97472:   kIotaAcc,
97472:   kOmicronAcc,
97472:   kUpsilonAcc,
97472:   kOmegaAcc,
97472:   kOmicronUpsilon,
97472:   kDiaeresis
97472: };
97472: 
97472: static PRUint32
97472: GreekUpperCase(PRUint32 aCh, GreekCasingState* aState)
97472: {
97472:   switch (aCh) {
97472:   case GREEK_UPPER_ALPHA:
97472:   case GREEK_LOWER_ALPHA:
97472:     *aState = kAlpha;
97472:     return GREEK_UPPER_ALPHA;
97472: 
97472:   case GREEK_UPPER_EPSILON:
97472:   case GREEK_LOWER_EPSILON:
97472:     *aState = kEpsilon;
97472:     return GREEK_UPPER_EPSILON;
97472: 
97472:   case GREEK_UPPER_ETA:
97472:   case GREEK_LOWER_ETA:
97472:     *aState = kEta;
97472:     return GREEK_UPPER_ETA;
97472: 
97472:   case GREEK_UPPER_IOTA:
97472:     *aState = kIota;
97472:     return GREEK_UPPER_IOTA;
97472: 
97472:   case GREEK_UPPER_OMICRON:
97472:   case GREEK_LOWER_OMICRON:
97472:     *aState = kOmicron;
97472:     return GREEK_UPPER_OMICRON;
97472: 
97472:   case GREEK_UPPER_UPSILON:
97472:     switch (*aState) {
97472:     case kOmicron:
97472:       *aState = kOmicronUpsilon;
97472:       break;
97472:     default:
97472:       *aState = kUpsilon;
97472:       break;
97472:     }
97472:     return GREEK_UPPER_UPSILON;
97472: 
97472:   case GREEK_UPPER_OMEGA:
97472:   case GREEK_LOWER_OMEGA:
97472:     *aState = kOmega;
97472:     return GREEK_UPPER_OMEGA;
97472: 
97472:   // iota and upsilon may be the second vowel of a diphthong
97472:   case GREEK_LOWER_IOTA:
97472:     switch (*aState) {
97472:     case kAlphaAcc:
97472:     case kEpsilonAcc:
97472:     case kOmicronAcc:
97472:     case kUpsilonAcc:
97472:       *aState = kStart;
97472:       return GREEK_UPPER_IOTA_DIALYTIKA;
97472:     default:
97472:       break;
97472:     }
97472:     *aState = kIota;
97472:     return GREEK_UPPER_IOTA;
97472: 
97472:   case GREEK_LOWER_UPSILON:
97472:     switch (*aState) {
97472:     case kAlphaAcc:
97472:     case kEpsilonAcc:
97472:     case kEtaAcc:
97472:     case kOmicronAcc:
97472:       *aState = kStart;
97472:       return GREEK_UPPER_UPSILON_DIALYTIKA;
97472:     case kOmicron:
97472:       *aState = kOmicronUpsilon;
97472:       break;
97472:     default:
97472:       *aState = kUpsilon;
97472:       break;
97472:     }
97472:     return GREEK_UPPER_UPSILON;
97472: 
97472:   case GREEK_UPPER_IOTA_DIALYTIKA:
97472:   case GREEK_LOWER_IOTA_DIALYTIKA:
97472:   case GREEK_UPPER_UPSILON_DIALYTIKA:
97472:   case GREEK_LOWER_UPSILON_DIALYTIKA:
97472:   case COMBINING_DIAERESIS:
97472:     *aState = kDiaeresis;
97472:     return ToUpperCase(aCh);
97472: 
97472:   // remove accent if it follows a vowel or diaeresis,
97472:   // and set appropriate state for diphthong detection
97472:   case COMBINING_ACUTE_ACCENT:
97472:   case COMBINING_ACUTE_TONE_MARK:
97472:     switch (*aState) {
97472:     case kAlpha:
97472:       *aState = kAlphaAcc;
97472:       return PRUint32(-1); // omit this char from result string
97472:     case kEpsilon:
97472:       *aState = kEpsilonAcc;
97472:       return PRUint32(-1);
97472:     case kEta:
97472:       *aState = kEtaAcc;
97472:       return PRUint32(-1);
97472:     case kIota:
97472:       *aState = kIotaAcc;
97472:       return PRUint32(-1);
97472:     case kOmicron:
97472:       *aState = kOmicronAcc;
97472:       return PRUint32(-1);
97472:     case kUpsilon:
97472:       *aState = kUpsilonAcc;
97472:       return PRUint32(-1);
97472:     case kOmicronUpsilon:
97472:       *aState = kStart; // this completed a diphthong
97472:       return PRUint32(-1);
97472:     case kOmega:
97472:       *aState = kOmegaAcc;
97472:       return PRUint32(-1);
97472:     case kDiaeresis:
97472:       *aState = kStart;
97472:       return PRUint32(-1);
97472:     default:
97472:       break;
97472:     }
97472:     break;
97472: 
97472:   // combinations with dieresis+accent just strip the accent,
97472:   // and reset to start state (don't form diphthong with following vowel)
97472:   case GREEK_LOWER_IOTA_DIALYTIKA_TONOS:
97472:   case GREEK_LOWER_IOTA_DIALYTIKA_OXIA:
97472:     *aState = kStart;
97472:     return GREEK_UPPER_IOTA_DIALYTIKA;
97472: 
97472:   case GREEK_LOWER_UPSILON_DIALYTIKA_TONOS:
97472:   case GREEK_LOWER_UPSILON_DIALYTIKA_OXIA:
97472:     *aState = kStart;
97472:     return GREEK_UPPER_UPSILON_DIALYTIKA;
97472: 
97472:   case COMBINING_GREEK_DIALYTIKA_TONOS:
97472:     *aState = kStart;
97472:     return COMBINING_DIAERESIS;
97472: 
97472:   // strip accents from vowels, and note the vowel seen so that we can detect
97472:   // diphthongs where diaeresis needs to be added
97472:   case GREEK_LOWER_ALPHA_TONOS:
97472:   case GREEK_LOWER_ALPHA_OXIA:
97472:   case GREEK_UPPER_ALPHA_TONOS:
97472:   case GREEK_UPPER_ALPHA_OXIA:
97472:     *aState = kAlphaAcc;
97472:     return GREEK_UPPER_ALPHA;
97472: 
97472:   case GREEK_LOWER_EPSILON_TONOS:
97472:   case GREEK_LOWER_EPSILON_OXIA:
97472:   case GREEK_UPPER_EPSILON_TONOS:
97472:   case GREEK_UPPER_EPSILON_OXIA:
97472:     *aState = kEpsilonAcc;
97472:     return GREEK_UPPER_EPSILON;
97472: 
97472:   case GREEK_LOWER_ETA_TONOS:
97472:   case GREEK_LOWER_ETA_OXIA:
97472:   case GREEK_UPPER_ETA_TONOS:
97472:   case GREEK_UPPER_ETA_OXIA:
97472:     *aState = kEtaAcc;
97472:     return GREEK_UPPER_ETA;
97472: 
97472:   case GREEK_LOWER_IOTA_TONOS:
97472:   case GREEK_LOWER_IOTA_OXIA:
97472:   case GREEK_UPPER_IOTA_TONOS:
97472:   case GREEK_UPPER_IOTA_OXIA:
97472:     *aState = kIotaAcc;
97472:     return GREEK_UPPER_IOTA;
97472: 
97472:   case GREEK_LOWER_OMICRON_TONOS:
97472:   case GREEK_LOWER_OMICRON_OXIA:
97472:   case GREEK_UPPER_OMICRON_TONOS:
97472:   case GREEK_UPPER_OMICRON_OXIA:
97472:     *aState = kOmicronAcc;
97472:     return GREEK_UPPER_OMICRON;
97472: 
97472:   case GREEK_LOWER_UPSILON_TONOS:
97472:   case GREEK_LOWER_UPSILON_OXIA:
97472:   case GREEK_UPPER_UPSILON_TONOS:
97472:   case GREEK_UPPER_UPSILON_OXIA:
97472:     switch (*aState) {
97472:     case kOmicron:
97472:       *aState = kStart; // this completed a diphthong
97472:       break;
97472:     default:
97472:       *aState = kUpsilonAcc;
97472:       break;
97472:     }
97472:     return GREEK_UPPER_UPSILON;
97472: 
97472:   case GREEK_LOWER_OMEGA_TONOS:
97472:   case GREEK_LOWER_OMEGA_OXIA:
97472:   case GREEK_UPPER_OMEGA_TONOS:
97472:   case GREEK_UPPER_OMEGA_OXIA:
97472:     *aState = kOmegaAcc;
97472:     return GREEK_UPPER_OMEGA;
97472:   }
97472: 
97472:   // all other characters just reset the state, and use standard mappings
97472:   *aState = kStart;
97472:   return ToUpperCase(aCh);
97472: }
97472: 
 8081: nsTransformedTextRun *
 8081: nsTransformedTextRun::Create(const gfxTextRunFactory::Parameters* aParams,
 8081:                              nsTransformingTextRunFactory* aFactory,
 8081:                              gfxFontGroup* aFontGroup,
 8081:                              const PRUnichar* aString, PRUint32 aLength,
 8081:                              const PRUint32 aFlags, nsStyleContext** aStyles,
79445:                              bool aOwnsFactory)
 8081: {
38204:   NS_ASSERTION(!(aFlags & gfxTextRunFactory::TEXT_IS_8BIT),
38204:                "didn't expect text to be marked as 8-bit here");
38204: 
86699:   void *storage = AllocateStorageForTextRun(sizeof(nsTransformedTextRun), aLength);
86699:   if (!storage) {
38204:     return nsnull;
38204:   }
38204: 
86699:   return new (storage) nsTransformedTextRun(aParams, aFactory, aFontGroup,
86697:                                             aString, aLength,
86699:                                             aFlags, aStyles, aOwnsFactory);
 8081: }
 8081: 
 7832: void
 7832: nsTransformedTextRun::SetCapitalization(PRUint32 aStart, PRUint32 aLength,
79445:                                         bool* aCapitalization,
 7832:                                         gfxContext* aRefContext)
    8: {
 7832:   if (mCapitalize.IsEmpty()) {
 7832:     if (!mCapitalize.AppendElements(GetLength()))
 7832:       return;
79445:     memset(mCapitalize.Elements(), 0, GetLength()*sizeof(bool));
    8:   }
79445:   memcpy(mCapitalize.Elements() + aStart, aCapitalization, aLength*sizeof(bool));
80486:   mNeedsRebuild = true;
    8: }
    1: 
79445: bool
 7832: nsTransformedTextRun::SetPotentialLineBreaks(PRUint32 aStart, PRUint32 aLength,
74669:                                              PRUint8* aBreakBefore,
 2834:                                              gfxContext* aRefContext)
    8: {
79445:   bool changed = gfxTextRun::SetPotentialLineBreaks(aStart, aLength,
 2834:       aBreakBefore, aRefContext);
23491:   if (changed) {
80486:     mNeedsRebuild = true;
23491:   }
22895:   return changed;
22886: }
22895: 
82849: size_t
82849: nsTransformedTextRun::SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf)
80375: {
82849:   size_t total = gfxTextRun::SizeOfExcludingThis(aMallocSizeOf);
84923:   total += mStyles.SizeOfExcludingThis(aMallocSizeOf);
84923:   total += mCapitalize.SizeOfExcludingThis(aMallocSizeOf);
80375:   if (mOwnsFactory) {
88300:     total += aMallocSizeOf(mFactory);
80375:   }
80375:   return total;
80375: }
80375: 
82849: size_t
82849: nsTransformedTextRun::SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf)
82849: {
88300:   return aMallocSizeOf(this) + SizeOfExcludingThis(aMallocSizeOf);
82849: }
82849: 
23857: nsTransformedTextRun*
    8: nsTransformingTextRunFactory::MakeTextRun(const PRUnichar* aString, PRUint32 aLength,
 1328:                                           const gfxTextRunFactory::Parameters* aParams,
 1328:                                           gfxFontGroup* aFontGroup, PRUint32 aFlags,
79445:                                           nsStyleContext** aStyles, bool aOwnsFactory)
    1: {
23491:   return nsTransformedTextRun::Create(aParams, this, aFontGroup,
 1435:                                       aString, aLength, aFlags, aStyles, aOwnsFactory);
    1: }
    1: 
23857: nsTransformedTextRun*
    1: nsTransformingTextRunFactory::MakeTextRun(const PRUint8* aString, PRUint32 aLength,
 1328:                                           const gfxTextRunFactory::Parameters* aParams,
 1328:                                           gfxFontGroup* aFontGroup, PRUint32 aFlags,
79445:                                           nsStyleContext** aStyles, bool aOwnsFactory)
    1: {
    1:   // We'll only have a Unicode code path to minimize the amount of code needed
    8:   // for these rarely used features
 3233:   NS_ConvertASCIItoUTF16 unicodeString(reinterpret_cast<const char*>(aString), aLength);
 1328:   return MakeTextRun(unicodeString.get(), aLength, aParams, aFontGroup,
 1328:                      aFlags & ~(gfxFontGroup::TEXT_IS_PERSISTENT | gfxFontGroup::TEXT_IS_8BIT),
 1435:                      aStyles, aOwnsFactory);
    8: }
    8: 
    1: /**
    8:  * Copy a given textrun, but merge certain characters into a single logical
    8:  * character. Glyphs for a character are added to the glyph list for the previous
    8:  * character and then the merged character is eliminated. Visually the results
    8:  * are identical.
    8:  * 
    8:  * This is used for text-transform:uppercase when we encounter a SZLIG,
96805:  * whose uppercase form is "SS", or other ligature or precomposed form
97472:  * that expands to multiple codepoints during case transformation,
97472:  * and for Greek text when combining diacritics have been deleted.
    8:  * 
    8:  * This function is unable to merge characters when they occur in different
96805:  * glyph runs. This only happens in tricky edge cases where a character was
96805:  * decomposed by case-mapping (e.g. there's no precomposed uppercase version
96805:  * of an accented lowercase letter), and then font-matching caused the
96805:  * diacritics to be assigned to a different font than the base character.
96805:  * In this situation, the diacritic(s) get discarded, which is less than
96805:  * ideal, but they probably weren't going to render very well anyway.
96805:  * Bug 543200 will improve this by making font-matching operate on entire
96805:  * clusters instead of individual codepoints.
    8:  * 
 7715:  * For simplicity, this produces a textrun containing all DetailedGlyphs,
 7715:  * no simple glyphs. So don't call it unless you really have merging to do.
 7715:  * 
97472:  * @param aCharsToMerge when aCharsToMerge[i] is true, this character in aSrc
97472:  * is merged into the previous character
97472:  *
97472:  * @param aDeletedChars when aDeletedChars[i] is true, the character at this
97472:  * position in aDest was deleted (has no corresponding char in aSrc)
    8:  */
    8: static void
    8: MergeCharactersInTextRun(gfxTextRun* aDest, gfxTextRun* aSrc,
97472:                          const bool* aCharsToMerge, const bool* aDeletedChars)
    8: {
    8:   aDest->ResetGlyphRuns();
    8: 
 7715:   gfxTextRun::GlyphRunIterator iter(aSrc, 0, aSrc->GetLength());
    8:   PRUint32 offset = 0;
 7715:   nsAutoTArray<gfxTextRun::DetailedGlyph,2> glyphs;
 7715:   while (iter.NextRun()) {
 7715:     gfxTextRun::GlyphRun* run = iter.GetGlyphRun();
71910:     nsresult rv = aDest->AddGlyphRun(run->mFont, run->mMatchType,
80486:                                      offset, false);
    8:     if (NS_FAILED(rv))
    8:       return;
    8: 
79445:     bool anyMissing = false;
 7715:     PRUint32 mergeRunStart = iter.GetStringStart();
96805:     const gfxTextRun::CompressedGlyph *srcGlyphs = aSrc->GetCharacterGlyphs();
96805:     gfxTextRun::CompressedGlyph mergedGlyph = srcGlyphs[mergeRunStart];
96805:     PRUint32 stringEnd = iter.GetStringEnd();
96805:     for (PRUint32 k = iter.GetStringStart(); k < stringEnd; ++k) {
96805:       const gfxTextRun::CompressedGlyph g = srcGlyphs[k];
 7715:       if (g.IsSimpleGlyph()) {
 7715:         if (!anyMissing) {
 7715:           gfxTextRun::DetailedGlyph details;
 7715:           details.mGlyphID = g.GetSimpleGlyph();
 7715:           details.mAdvance = g.GetSimpleAdvance();
 7715:           details.mXOffset = 0;
 7715:           details.mYOffset = 0;
 7715:           glyphs.AppendElement(details);
    8:         }
    8:       } else {
 7715:         if (g.IsMissing()) {
80486:           anyMissing = true;
 7715:           glyphs.Clear();
    8:         }
62426:         if (g.GetGlyphCount() > 0) {
 7715:           glyphs.AppendElements(aSrc->GetDetailedGlyphs(k), g.GetGlyphCount());
 7715:         }
62426:       }
 7715: 
 7715:       if (k + 1 < iter.GetStringEnd() && aCharsToMerge[k + 1]) {
96805:         // next char is supposed to merge with current, so loop without
96805:         // writing current merged glyph to the destination
 7715:         continue;
 7715:       }
 7715: 
10106:       // If the start of the merge run is actually a character that should
10106:       // have been merged with the previous character (this can happen
96805:       // if there's a font change in the middle of a case-mapped character,
96805:       // that decomposed into a sequence of base+diacritics, for example),
10106:       // just discard the entire merge run. See comment at start of this
10106:       // function.
96805:       NS_WARN_IF_FALSE(!aCharsToMerge[mergeRunStart],
96805:                        "unable to merge across a glyph run boundary, "
96805:                        "glyph(s) discarded");
10106:       if (!aCharsToMerge[mergeRunStart]) {
 7715:         if (anyMissing) {
96805:           mergedGlyph.SetMissing(glyphs.Length());
 7715:         } else {
96805:           mergedGlyph.SetComplex(mergedGlyph.IsClusterStart(),
96805:                                  mergedGlyph.IsLigatureGroupStart(),
96805:                                  glyphs.Length());
 7715:         }
96805:         aDest->SetGlyphs(offset, mergedGlyph, glyphs.Elements());
 7685:         ++offset;
97472: 
97472:         while (offset < aDest->GetLength() && aDeletedChars[offset]) {
97472:           aDest->SetGlyphs(offset++, gfxTextRun::CompressedGlyph(), nsnull);
97472:         }
10106:       }
10106: 
 7715:       glyphs.Clear();
80486:       anyMissing = false;
 7715:       mergeRunStart = k + 1;
96805:       if (mergeRunStart < stringEnd) {
96805:         mergedGlyph = srcGlyphs[mergeRunStart];
96805:       }
 7678:     }
 7715:     NS_ASSERTION(glyphs.Length() == 0,
 7715:                  "Leftover glyphs, don't request merging of the last character with its next!");  
    8:   }
    8:   NS_ASSERTION(offset == aDest->GetLength(), "Bad offset calculations");
    8: }
    8: 
    8: static gfxTextRunFactory::Parameters
 2834: GetParametersForInner(nsTransformedTextRun* aTextRun, PRUint32* aFlags,
 2834:     gfxContext* aRefContext)
    8: {
    8:   gfxTextRunFactory::Parameters params =
 2834:     { aRefContext, nsnull, nsnull,
23491:       nsnull, 0, aTextRun->GetAppUnitsPerDevUnit()
 1328:     };
 1328:   *aFlags = aTextRun->GetFlags() & ~gfxFontGroup::TEXT_IS_PERSISTENT;
    8:   return params;
    8: }
    8: 
    8: void
 2834: nsFontVariantTextRunFactory::RebuildTextRun(nsTransformedTextRun* aTextRun,
 2834:     gfxContext* aRefContext)
    1: {
 1328:   gfxFontGroup* fontGroup = aTextRun->GetFontGroup();
 1328:   gfxFontStyle fontStyle = *fontGroup->GetStyle();
    1:   fontStyle.size *= 0.8;
 1328:   nsRefPtr<gfxFontGroup> smallFont = fontGroup->Copy(&fontStyle);
    1:   if (!smallFont)
    8:     return;
    1: 
 1328:   PRUint32 flags;
 2834:   gfxTextRunFactory::Parameters innerParams =
 2834:       GetParametersForInner(aTextRun, &flags, aRefContext);
    8: 
    8:   PRUint32 length = aTextRun->GetLength();
86697:   const PRUnichar* str = aTextRun->mString.BeginReading();
    8:   nsRefPtr<nsStyleContext>* styles = aTextRun->mStyles.Elements();
    8:   // Create a textrun so we can check cluster-start properties
86690:   nsAutoPtr<gfxTextRun> inner(fontGroup->MakeTextRun(str, length, &innerParams, flags));
 3118:   if (!inner.get())
    8:     return;
    1: 
80486:   nsCaseTransformTextRunFactory uppercaseFactory(nsnull, true);
    1: 
    8:   aTextRun->ResetGlyphRuns();
    1: 
    1:   PRUint32 runStart = 0;
    8:   nsAutoTArray<nsStyleContext*,50> styleArray;
74669:   nsAutoTArray<PRUint8,50> canBreakBeforeArray;
    8: 
97472:   enum RunCaseState {
97472:     kUpperOrCaseless, // will be untouched by font-variant:small-caps
97472:     kLowercase,       // will be uppercased and reduced
97472:     kSpecialUpper     // specials: don't shrink, but apply uppercase mapping
97472:   };
97472:   RunCaseState runCase = kUpperOrCaseless;
97472: 
97809:   // Note that this loop runs from 0 to length *inclusive*, so the last
97809:   // iteration is in effect beyond the end of the input text, to give a
97809:   // chance to finish the last casing run we've found.
97809:   // The last iteration, when i==length, must not attempt to look at the
97809:   // character position [i] or the style data for styles[i], as this would
97809:   // be beyond the valid length of the textrun or its style array.
97809:   for (PRUint32 i = 0; i <= length; ++i) {
97472:     RunCaseState chCase = kUpperOrCaseless;
97809:     // Unless we're at the end, figure out what treatment the current
97809:     // character will need.
97809:     if (i < length) {
97472:       nsStyleContext* styleContext = styles[i];
    1:       // Characters that aren't the start of a cluster are ignored here. They
    1:       // get added to whatever lowercase/non-lowercase run we're in.
 2358:       if (!inner->IsClusterStart(i)) {
97472:         chCase = runCase;
 2358:       } else {
97472:         if (styleContext->GetStyleFont()->mFont.variant == NS_STYLE_FONT_VARIANT_SMALL_CAPS) {
93110:           PRUint32 ch = str[i];
93110:           if (NS_IS_HIGH_SURROGATE(ch) && i < length - 1 && NS_IS_LOW_SURROGATE(str[i + 1])) {
93110:             ch = SURROGATE_TO_UCS4(ch, str[i + 1]);
93110:           }
93110:           PRUint32 ch2 = ToUpperCase(ch);
97472:           if (ch != ch2 || mozilla::unicode::SpecialUpper(ch)) {
97472:             chCase = kLowercase;
97472:           } else if (styleContext->GetStyleFont()->mLanguage == nsGkAtoms::el) {
97472:             // In Greek, check for characters that will be modified by the
97472:             // GreekUpperCase mapping - this catches accented capitals where
97472:             // the accent is to be removed (bug 307039). These are handled by
97472:             // a transformed child run using the full-size font.
97472:             GreekCasingState state = kStart; // don't need exact context here
97472:             ch2 = GreekUpperCase(ch, &state);
97472:             if (ch != ch2) {
97472:               chCase = kSpecialUpper;
97472:             }
97472:           }
    1:         } else {
    1:           // Don't transform the character! I.e., pretend that it's not lowercase
    1:         }
    1:       }
 2358:     }
    1: 
97809:     // At the end of the text, or when the current character needs different
97809:     // casing treatment from the current run, finish the run-in-progress
97809:     // and prepare to accumulate a new run.
97809:     // Note that we do not look at any source data for offset [i] here,
97809:     // as that would be invalid in the case where i==length.
97472:     if ((i == length || runCase != chCase) && runStart < i) {
23857:       nsAutoPtr<nsTransformedTextRun> transformedChild;
86690:       nsAutoPtr<gfxTextRun> cachedChild;
 3118:       gfxTextRun* child;
23491: 
97472:       switch (runCase) {
97472:       case kUpperOrCaseless:
97472:         cachedChild =
97472:           fontGroup->MakeTextRun(str + runStart, i - runStart, &innerParams,
97472:                                  flags);
97472:         child = cachedChild.get();
97472:         break;
97472:       case kLowercase:
97472:         transformedChild =
97472:           uppercaseFactory.MakeTextRun(str + runStart, i - runStart,
97472:                                        &innerParams, smallFont, flags,
97472:                                        styleArray.Elements(), false);
 3118:         child = transformedChild;
97472:         break;
97472:       case kSpecialUpper:
97472:         transformedChild =
97472:           uppercaseFactory.MakeTextRun(str + runStart, i - runStart,
97472:                                        &innerParams, fontGroup, flags,
97472:                                        styleArray.Elements(), false);
97472:         child = transformedChild;
97472:         break;
    1:       }
    8:       if (!child)
    8:         return;
    8:       // Copy potential linebreaks into child so they're preserved
    8:       // (and also child will be shaped appropriately)
    8:       NS_ASSERTION(canBreakBeforeArray.Length() == i - runStart,
    8:                    "lost some break-before values?");
 2834:       child->SetPotentialLineBreaks(0, canBreakBeforeArray.Length(),
 2834:           canBreakBeforeArray.Elements(), aRefContext);
23857:       if (transformedChild) {
23857:         transformedChild->FinishSettingProperties(aRefContext);
23857:       }
62288:       aTextRun->CopyGlyphDataFrom(child, 0, child->GetLength(), runStart);
    8: 
    1:       runStart = i;
    8:       styleArray.Clear();
    8:       canBreakBeforeArray.Clear();
    1:     }
    1: 
    8:     if (i < length) {
97472:       runCase = chCase;
97809:       styleArray.AppendElement(styles[i]);
    8:       canBreakBeforeArray.AppendElement(aTextRun->CanBreakLineBefore(i));
    8:     }
    8:   }
    1: }
    1: 
    8: void
 2834: nsCaseTransformTextRunFactory::RebuildTextRun(nsTransformedTextRun* aTextRun,
 2834:     gfxContext* aRefContext)
    1: {
    8:   PRUint32 length = aTextRun->GetLength();
86697:   const PRUnichar* str = aTextRun->mString.BeginReading();
    8:   nsRefPtr<nsStyleContext>* styles = aTextRun->mStyles.Elements();
    1: 
    1:   nsAutoString convertedString;
79445:   nsAutoTArray<bool,50> charsToMergeArray;
97472:   nsAutoTArray<bool,50> deletedCharsArray;
    8:   nsAutoTArray<nsStyleContext*,50> styleArray;
74669:   nsAutoTArray<PRUint8,50> canBreakBeforeArray;
97472:   bool mergeNeeded = false;
    8: 
94500:   // Some languages have special casing conventions that differ from the
94500:   // default Unicode mappings.
94500:   // The enum values here are named for well-known exemplar languages that
94500:   // exhibit the behavior in question; multiple lang tags may map to the
94500:   // same setting here, if the behavior is shared by other languages.
94500:   enum {
94500:     eNone,    // default non-lang-specific behavior
94500:     eTurkish, // preserve dotted/dotless-i distinction in uppercase
97472:     eDutch,   // treat "ij" digraph as a unit for capitalization
97472:     eGreek    // strip accent when uppercasing Greek vowels
94500:   } languageSpecificCasing = eNone;
94500: 
94165:   const nsIAtom* lang = nsnull;
94500:   bool capitalizeDutchIJ = false;
95461:   bool prevIsLetter = false;
95461:   PRUint32 sigmaIndex = PRUint32(-1);
95461:   nsIUGenCategory::nsUGenCategory cat;
97472:   GreekCasingState greekState = kStart;
    1:   PRUint32 i;
    8:   for (i = 0; i < length; ++i) {
93110:     PRUint32 ch = str[i];
94165:     nsStyleContext* styleContext = styles[i];
    1: 
    8:     PRUint8 style = mAllUppercase ? NS_STYLE_TEXT_TRANSFORM_UPPERCASE
94165:       : styleContext->GetStyleText()->mTextTransform;
96805:     int extraChars = 0;
96805:     const mozilla::unicode::MultiCharMapping *mcm;
    1: 
93110:     if (NS_IS_HIGH_SURROGATE(ch) && i < length - 1 && NS_IS_LOW_SURROGATE(str[i + 1])) {
93110:       ch = SURROGATE_TO_UCS4(ch, str[i + 1]);
93110:     }
93110: 
94165:     if (lang != styleContext->GetStyleFont()->mLanguage) {
94165:       lang = styleContext->GetStyleFont()->mLanguage;
94515:       if (lang == nsGkAtoms::tr || lang == nsGkAtoms::az ||
94515:           lang == nsGkAtoms::ba || lang == nsGkAtoms::crh ||
94515:           lang == nsGkAtoms::tt) {
94500:         languageSpecificCasing = eTurkish;
94515:       } else if (lang == nsGkAtoms::nl) {
94500:         languageSpecificCasing = eDutch;
97472:       } else if (lang == nsGkAtoms::el) {
97472:         languageSpecificCasing = eGreek;
97472:         greekState = kStart;
94500:       } else {
94500:         languageSpecificCasing = eNone;
94500:       }
94165:     }
94165: 
    1:     switch (style) {
    1:     case NS_STYLE_TEXT_TRANSFORM_LOWERCASE:
96805:       if (languageSpecificCasing == eTurkish) {
96805:         if (ch == 'I') {
94165:           ch = LATIN_SMALL_LETTER_DOTLESS_I;
95461:           prevIsLetter = true;
95461:           sigmaIndex = PRUint32(-1);
95461:           break;
95461:         }
96805:         if (ch == LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE) {
96805:           ch = 'i';
96805:           prevIsLetter = true;
96805:           sigmaIndex = PRUint32(-1);
96805:           break;
96805:         }
96805:       }
95461: 
95461:       // Special lowercasing behavior for Greek Sigma: note that this is listed
95461:       // as context-sensitive in Unicode's SpecialCasing.txt, but is *not* a
95461:       // language-specific mapping; it applies regardless of the language of
95461:       // the element.
95461:       //
95461:       // The lowercase mapping for CAPITAL SIGMA should be to SMALL SIGMA (i.e.
95461:       // the non-final form) whenever there is a following letter, or when the
95461:       // CAPITAL SIGMA occurs in isolation (neither preceded nor followed by a
95461:       // LETTER); and to FINAL SIGMA when it is preceded by another letter but
95461:       // not followed by one.
95461:       //
95461:       // To implement the context-sensitive nature of this mapping, we keep
95461:       // track of whether the previous character was a letter. If not, CAPITAL
95461:       // SIGMA will map directly to SMALL SIGMA. If the previous character
95461:       // was a letter, CAPITAL SIGMA maps to FINAL SIGMA and we record the
95461:       // position in the converted string; if we then encounter another letter,
95461:       // that FINAL SIGMA is replaced with a standard SMALL SIGMA.
95461: 
95461:       cat = mozilla::unicode::GetGenCategory(ch);
95461: 
95461:       // If sigmaIndex is not -1, it marks where we have provisionally mapped
95461:       // a CAPITAL SIGMA to FINAL SIGMA; if we now find another letter, we
95461:       // need to change it to SMALL SIGMA.
95461:       if (sigmaIndex != PRUint32(-1)) {
95461:         if (cat == nsIUGenCategory::kLetter) {
95461:           convertedString.SetCharAt(GREEK_SMALL_LETTER_SIGMA, sigmaIndex);
95461:         }
95461:       }
95461: 
95461:       if (ch == GREEK_CAPITAL_LETTER_SIGMA) {
95461:         // If preceding char was a letter, map to FINAL instead of SMALL,
95461:         // and note where it occurred by setting sigmaIndex; we'll change it
95461:         // to standard SMALL SIGMA later if another letter follows
95461:         if (prevIsLetter) {
95461:           ch = GREEK_SMALL_LETTER_FINAL_SIGMA;
95461:           sigmaIndex = convertedString.Length();
94165:         } else {
95461:           // CAPITAL SIGMA not preceded by a letter is unconditionally mapped
95461:           // to SMALL SIGMA
95461:           ch = GREEK_SMALL_LETTER_SIGMA;
95461:           sigmaIndex = PRUint32(-1);
95461:         }
95461:         prevIsLetter = true;
95461:         break;
95461:       }
95461: 
95461:       // ignore diacritics for the purpose of contextual sigma mapping;
95461:       // otherwise, reset prevIsLetter appropriately and clear the
95461:       // sigmaIndex marker
95461:       if (cat != nsIUGenCategory::kMark) {
95461:         prevIsLetter = (cat == nsIUGenCategory::kLetter);
95461:         sigmaIndex = PRUint32(-1);
94165:       }
96805: 
96805:       mcm = mozilla::unicode::SpecialLower(ch);
96805:       if (mcm) {
96805:         int j = 0;
96805:         while (j < 2 && mcm->mMappedChars[j + 1]) {
96805:           convertedString.Append(mcm->mMappedChars[j]);
96805:           ++extraChars;
96805:           ++j;
96805:         }
96805:         ch = mcm->mMappedChars[j];
96805:         break;
96805:       }
96805: 
96805:       ch = ToLowerCase(ch);
    1:       break;
95461: 
    1:     case NS_STYLE_TEXT_TRANSFORM_UPPERCASE:
95461:       if (languageSpecificCasing == eTurkish && ch == 'i') {
94165:         ch = LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE;
95461:         break;
95461:       }
96805: 
97472:       if (languageSpecificCasing == eGreek) {
97472:         ch = GreekUpperCase(ch, &greekState);
97472:         break;
97472:       }
97472: 
96805:       mcm = mozilla::unicode::SpecialUpper(ch);
96805:       if (mcm) {
96805:         int j = 0;
96805:         while (j < 2 && mcm->mMappedChars[j + 1]) {
96805:           convertedString.Append(mcm->mMappedChars[j]);
96805:           ++extraChars;
96805:           ++j;
96805:         }
96805:         ch = mcm->mMappedChars[j];
96805:         break;
96805:       }
96805: 
48377:       ch = ToUpperCase(ch);
    1:       break;
95461: 
    1:     case NS_STYLE_TEXT_TRANSFORM_CAPITALIZE:
94500:       if (capitalizeDutchIJ && ch == 'j') {
94500:         ch = 'J';
94500:         capitalizeDutchIJ = false;
94500:         break;
94500:       }
94500:       capitalizeDutchIJ = false;
 7832:       if (i < aTextRun->mCapitalize.Length() && aTextRun->mCapitalize[i]) {
95461:         if (languageSpecificCasing == eTurkish && ch == 'i') {
94165:           ch = LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE;
95461:           break;
95461:         }
95461:         if (languageSpecificCasing == eDutch && ch == 'i') {
94500:           ch = 'I';
94500:           capitalizeDutchIJ = true;
95461:           break;
95461:         }
96805: 
96805:         mcm = mozilla::unicode::SpecialTitle(ch);
96805:         if (mcm) {
96805:           int j = 0;
96805:           while (j < 2 && mcm->mMappedChars[j + 1]) {
96805:             convertedString.Append(mcm->mMappedChars[j]);
96805:             ++extraChars;
96805:             ++j;
96805:           }
96805:           ch = mcm->mMappedChars[j];
96805:           break;
96805:         }
96805: 
48377:         ch = ToTitleCase(ch);
    1:       }
    1:       break;
95461: 
    1:     default:
    1:       break;
    1:     }
    1: 
97472:     if (ch == PRUint32(-1)) {
97472:       deletedCharsArray.AppendElement(true);
97472:       mergeNeeded = true;
97472:     } else {
97472:       deletedCharsArray.AppendElement(false);
97472:       charsToMergeArray.AppendElement(false);
97472:       styleArray.AppendElement(styleContext);
97472:       canBreakBeforeArray.AppendElement(aTextRun->CanBreakLineBefore(i));
97472: 
93110:       if (IS_IN_BMP(ch)) {
    1:         convertedString.Append(ch);
93110:       } else {
93110:         convertedString.Append(H_SURROGATE(ch));
93110:         convertedString.Append(L_SURROGATE(ch));
97472:         ++i;
97472:         deletedCharsArray.AppendElement(true); // not exactly deleted, but the
97472:                                                // trailing surrogate is skipped
97472:         ++extraChars;
97472:       }
97472: 
97472:       while (extraChars-- > 0) {
97472:         mergeNeeded = true;
97472:         charsToMergeArray.AppendElement(true);
94165:         styleArray.AppendElement(styleContext);
93110:         canBreakBeforeArray.AppendElement(false);
93110:       }
    1:     }
    8:   }
    1: 
 1328:   PRUint32 flags;
 2834:   gfxTextRunFactory::Parameters innerParams =
 2834:       GetParametersForInner(aTextRun, &flags, aRefContext);
 1328:   gfxFontGroup* fontGroup = aTextRun->GetFontGroup();
    1: 
23857:   nsAutoPtr<nsTransformedTextRun> transformedChild;
86690:   nsAutoPtr<gfxTextRun> cachedChild;
 3118:   gfxTextRun* child;
23491: 
    8:   if (mInnerTransformingTextRunFactory) {
 3118:     transformedChild = mInnerTransformingTextRunFactory->MakeTextRun(
    8:         convertedString.BeginReading(), convertedString.Length(),
80486:         &innerParams, fontGroup, flags, styleArray.Elements(), false);
 3118:     child = transformedChild.get();
    8:   } else {
86690:     cachedChild = fontGroup->MakeTextRun(
86690:         convertedString.BeginReading(), convertedString.Length(),
 3118:         &innerParams, flags);
 3118:     child = cachedChild.get();
    1:   }
    8:   if (!child)
    8:     return;
    8:   // Copy potential linebreaks into child so they're preserved
    8:   // (and also child will be shaped appropriately)
    8:   NS_ASSERTION(convertedString.Length() == canBreakBeforeArray.Length(),
    8:                "Dropped characters or break-before values somewhere!");
 2834:   child->SetPotentialLineBreaks(0, canBreakBeforeArray.Length(),
 2834:       canBreakBeforeArray.Elements(), aRefContext);
23857:   if (transformedChild) {
23857:     transformedChild->FinishSettingProperties(aRefContext);
23857:   }
 7715: 
97472:   if (mergeNeeded) {
    8:     // Now merge multiple characters into one multi-glyph character as required
97472:     // and deal with skipping deleted accent chars
97472:     NS_ASSERTION(charsToMergeArray.Length() == child->GetLength(),
97472:                  "source length mismatch");
97472:     NS_ASSERTION(deletedCharsArray.Length() == aTextRun->GetLength(),
97472:                  "destination length mismatch");
97472:     MergeCharactersInTextRun(aTextRun, child, charsToMergeArray.Elements(),
97472:                              deletedCharsArray.Elements());
 7715:   } else {
 7715:     // No merging to do, so just copy; this produces a more optimized textrun.
 7715:     // We can't steal the data because the child may be cached and stealing
 7715:     // the data would break the cache.
 7715:     aTextRun->ResetGlyphRuns();
62288:     aTextRun->CopyGlyphDataFrom(child, 0, child->GetLength(), 0);
    1:   }
 7715: }
