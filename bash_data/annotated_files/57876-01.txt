29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   IBM Corp.
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS number type and wrapper class.
    1:  */
26750: #ifdef XP_OS2
26750: #define _PC_53  PC_53
26750: #define _MCW_EM MCW_EM
26750: #define _MCW_PC MCW_PC
26750: #endif
    1: #include <locale.h>
    1: #include <limits.h>
    1: #include <math.h>
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
55477: #include "jsutil.h"
    1: #include "jsapi.h"
    1: #include "jsatom.h"
20408: #include "jsbuiltins.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsdtoa.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
    1: #include "jsprf.h"
12581: #include "jsscope.h"
    1: #include "jsstr.h"
48643: #include "jstracer.h"
40901: #include "jsvector.h"
40901: 
55711: #include "jsinterpinlines.h"
40901: #include "jsobjinlines.h"
40900: #include "jsstrinlines.h"
40899: 
39941: using namespace js;
32758: 
32780: #ifndef JS_HAVE_STDINT_H /* Native support is innocent until proven guilty. */
32780: 
32758: JS_STATIC_ASSERT(uint8_t(-1) == UINT8_MAX);
32758: JS_STATIC_ASSERT(uint16_t(-1) == UINT16_MAX);
32758: JS_STATIC_ASSERT(uint32_t(-1) == UINT32_MAX);
32758: JS_STATIC_ASSERT(uint64_t(-1) == UINT64_MAX);
32758: 
32758: JS_STATIC_ASSERT(INT8_MAX > INT8_MIN);
32782: JS_STATIC_ASSERT(uint8_t(INT8_MAX) + uint8_t(1) == uint8_t(INT8_MIN));
32758: JS_STATIC_ASSERT(INT16_MAX > INT16_MIN);
32782: JS_STATIC_ASSERT(uint16_t(INT16_MAX) + uint16_t(1) == uint16_t(INT16_MIN));
32758: JS_STATIC_ASSERT(INT32_MAX > INT32_MIN);
32782: JS_STATIC_ASSERT(uint32_t(INT32_MAX) + uint32_t(1) == uint32_t(INT32_MIN));
32758: JS_STATIC_ASSERT(INT64_MAX > INT64_MIN);
32782: JS_STATIC_ASSERT(uint64_t(INT64_MAX) + uint64_t(1) == uint64_t(INT64_MIN));
32758: 
32758: JS_STATIC_ASSERT(INTPTR_MAX > INTPTR_MIN);
32782: JS_STATIC_ASSERT(uintptr_t(INTPTR_MAX) + uintptr_t(1) == uintptr_t(INTPTR_MIN));
32758: JS_STATIC_ASSERT(uintptr_t(-1) == UINTPTR_MAX);
32758: JS_STATIC_ASSERT(size_t(-1) == SIZE_MAX);
32758: JS_STATIC_ASSERT(PTRDIFF_MAX > PTRDIFF_MIN);
32758: JS_STATIC_ASSERT(ptrdiff_t(PTRDIFF_MAX) == PTRDIFF_MAX);
32758: JS_STATIC_ASSERT(ptrdiff_t(PTRDIFF_MIN) == PTRDIFF_MIN);
32782: JS_STATIC_ASSERT(uintptr_t(PTRDIFF_MAX) + uintptr_t(1) == uintptr_t(PTRDIFF_MIN));
32758: 
32780: #endif /* JS_HAVE_STDINT_H */
32758: 
48629: /*
48629:  * If we're accumulating a decimal number and the number is >= 2^53, then the
48629:  * fast result from the loop in GetPrefixInteger may be inaccurate. Call
48629:  * js_strtod_harder to get the correct answer.
48629:  */
56593: static bool
48629: ComputeAccurateDecimalInteger(JSContext *cx, const jschar *start, const jschar *end, jsdouble *dp)
48629: {
48629:     size_t length = end - start;
48629:     char *cstr = static_cast<char *>(cx->malloc(length + 1));
48629:     if (!cstr)
48629:         return false;
48629: 
48629:     for (size_t i = 0; i < length; i++) {
48629:         char c = char(start[i]);
48629:         JS_ASSERT(('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'));
48629:         cstr[i] = c;
48629:     }
48629:     cstr[length] = 0;
48629: 
48629:     char *estr;
48629:     int err = 0;
48629:     *dp = js_strtod_harder(JS_THREAD_DATA(cx)->dtoaState, cstr, &estr, &err);
48629:     if (err == JS_DTOA_ENOMEM) {
48629:         JS_ReportOutOfMemory(cx);
48629:         cx->free(cstr);
48629:         return false;
48629:     }
48629:     if (err == JS_DTOA_ERANGE && *dp == HUGE_VAL)
48629:         *dp = js_PositiveInfinity;
48629:     cx->free(cstr);
48629:     return true;
48629: }
48629: 
48629: class BinaryDigitReader
48629: {
48629:     const int base;      /* Base of number; must be a power of 2 */
48629:     int digit;           /* Current digit value in radix given by base */
48629:     int digitMask;       /* Mask to extract the next bit from digit */
48629:     const jschar *start; /* Pointer to the remaining digits */
48629:     const jschar *end;   /* Pointer to first non-digit */
48629: 
48629:   public:
48629:     BinaryDigitReader(int base, const jschar *start, const jschar *end)
48629:       : base(base), digit(0), digitMask(0), start(start), end(end)
48629:     {
48629:     }
48629: 
48629:     /* Return the next binary digit from the number, or -1 if done. */
48629:     int nextDigit() {
48629:         if (digitMask == 0) {
48629:             if (start == end)
48629:                 return -1;
48629: 
48629:             int c = *start++;
48629:             JS_ASSERT(('0' <= c && c <= '9') || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'));
48629:             if ('0' <= c && c <= '9')
48629:                 digit = c - '0';
48629:             else if ('a' <= c && c <= 'z')
48629:                 digit = c - 'a' + 10;
48629:             else
48629:                 digit = c - 'A' + 10;
48629:             digitMask = base >> 1;
48629:         }
48629: 
48629:         int bit = (digit & digitMask) != 0;
48629:         digitMask >>= 1;
48629:         return bit;
48629:     }
48629: };
48629: 
48629: /*
48629:  * The fast result might also have been inaccurate for power-of-two bases. This
48629:  * happens if the addition in value * 2 + digit causes a round-down to an even
48629:  * least significant mantissa bit when the first dropped bit is a one.  If any
48629:  * of the following digits in the number (which haven't been added in yet) are
48629:  * nonzero, then the correct action would have been to round up instead of
48629:  * down.  An example occurs when reading the number 0x1000000000000081, which
48629:  * rounds to 0x1000000000000000 instead of 0x1000000000000100.
48629:  */
56593: static jsdouble
48629: ComputeAccurateBinaryBaseInteger(JSContext *cx, const jschar *start, const jschar *end, int base)
48629: {
48629:     BinaryDigitReader bdr(base, start, end);
48629: 
48629:     /* Skip leading zeroes. */
48629:     int bit;
48629:     do {
48629:         bit = bdr.nextDigit();
48629:     } while (bit == 0);
48629: 
48629:     JS_ASSERT(bit == 1); // guaranteed by GetPrefixInteger
48629: 
48629:     /* Gather the 53 significant bits (including the leading 1). */
48629:     jsdouble value = 1.0;
48629:     for (int j = 52; j > 0; j--) {
48629:         bit = bdr.nextDigit();
48629:         if (bit < 0)
48629:             return value;
48629:         value = value * 2 + bit;
48629:     }
48629: 
48629:     /* bit2 is the 54th bit (the first dropped from the mantissa). */
48629:     int bit2 = bdr.nextDigit();
48629:     if (bit2 >= 0) {
48629:         jsdouble factor = 2.0;
48629:         int sticky = 0;  /* sticky is 1 if any bit beyond the 54th is 1 */
48629:         int bit3;
48629: 
48629:         while ((bit3 = bdr.nextDigit()) >= 0) {
48629:             sticky |= bit3;
48629:             factor *= 2;
48629:         }
48629:         value += bit2 & (bit | sticky);
48629:         value *= factor;
48629:     }
48629: 
48629:     return value;
48629: }
48629: 
48629: namespace js {
48629: 
48629: bool
48629: GetPrefixInteger(JSContext *cx, const jschar *start, const jschar *end, int base,
48629:                  const jschar **endp, jsdouble *dp)
48629: {
48629:     JS_ASSERT(start <= end);
48629:     JS_ASSERT(2 <= base && base <= 36);
48629: 
48629:     const jschar *s = start;
48629:     jsdouble d = 0.0;
48629:     for (; s < end; s++) {
48629:         int digit;
48629:         jschar c = *s;
48629:         if ('0' <= c && c <= '9')
48629:             digit = c - '0';
48629:         else if ('a' <= c && c <= 'z')
48629:             digit = c - 'a' + 10;
48629:         else if ('A' <= c && c <= 'Z')
48629:             digit = c - 'A' + 10;
48629:         else
48629:             break;
48629:         if (digit >= base)
48629:             break;
48629:         d = d * base + digit;
48629:     }
48629: 
48629:     *endp = s;
48629:     *dp = d;
48629: 
48629:     /* If we haven't reached the limit of integer precision, we're done. */
48629:     if (d < DOUBLE_INTEGRAL_PRECISION_LIMIT)
48629:         return true;
48629: 
48629:     /*
48629:      * Otherwise compute the correct integer from the prefix of valid digits
48629:      * if we're computing for base ten or a power of two.  Don't worry about
48629:      * other bases; see 15.1.2.2 step 13.
48629:      */
48629:     if (base == 10)
48629:         return ComputeAccurateDecimalInteger(cx, start, s, dp);
48629:     if ((base & (base - 1)) == 0)
48629:         *dp = ComputeAccurateBinaryBaseInteger(cx, start, s, base);
48629: 
48629:     return true;
48629: }
48629: 
48629: } // namespace js
48629: 
    1: static JSBool
48470: num_isNaN(JSContext *cx, uintN argc, Value *vp)
    1: {
16519:     if (argc == 0) {
48470:         vp->setBoolean(true);
16519:         return JS_TRUE;
16519:     }
40828:     jsdouble x;
40828:     if (!ValueToNumber(cx, vp[2], &x))
40828:         return false;
48470:     vp->setBoolean(JSDOUBLE_IS_NaN(x));
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
48470: num_isFinite(JSContext *cx, uintN argc, Value *vp)
    1: {
16519:     if (argc == 0) {
48470:         vp->setBoolean(false);
16519:         return JS_TRUE;
16519:     }
40828:     jsdouble x;
40828:     if (!ValueToNumber(cx, vp[2], &x))
    1:         return JS_FALSE;
48470:     vp->setBoolean(JSDOUBLE_IS_FINITE(x));
    1:     return JS_TRUE;
    1: }
    1: 
20408: static JSBool
48470: num_parseFloat(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *str;
    1:     jsdouble d;
 4718:     const jschar *bp, *end, *ep;
    1: 
16519:     if (argc == 0) {
48470:         vp->setDouble(js_NaN);
16519:         return JS_TRUE;
16519:     }
 4127:     str = js_ValueToString(cx, vp[2]);
    1:     if (!str)
    1:         return JS_FALSE;
29366:     str->getCharsAndEnd(bp, end);
 4718:     if (!js_strtod(cx, bp, end, &ep, &d))
    1:         return JS_FALSE;
    1:     if (ep == bp) {
48470:         vp->setDouble(js_NaN);
    1:         return JS_TRUE;
    1:     }
48470:     vp->setNumber(d);
48470:     return JS_TRUE;
    1: }
    1: 
20408: #ifdef JS_TRACER
20915: static jsdouble FASTCALL
20915: ParseFloat(JSContext* cx, JSString* str)
20408: {
20408:     const jschar* bp;
20408:     const jschar* end;
20408:     const jschar* ep;
20408:     jsdouble d;
20408: 
29366:     str->getCharsAndEnd(bp, end);
20408:     if (!js_strtod(cx, bp, end, &ep, &d) || ep == bp)
20408:         return js_NaN;
20408:     return d;
20408: }
20408: #endif
20408: 
56593: static bool
53297: ParseIntStringHelper(JSContext *cx, const jschar *ws, const jschar *end, int maybeRadix,
53297:                      bool stripPrefix, jsdouble *dp)
48629: {
48640:     JS_ASSERT(maybeRadix == 0 || (2 <= maybeRadix && maybeRadix <= 36));
48629:     JS_ASSERT(ws <= end);
48629: 
48629:     const jschar *s = js_SkipWhiteSpace(ws, end);
48629:     JS_ASSERT(ws <= s);
48629:     JS_ASSERT(s <= end);
48629: 
48629:     /* 15.1.2.2 steps 3-4. */
48629:     bool negative = (s != end && s[0] == '-');
48629: 
48629:     /* 15.1.2.2 step 5. */
48629:     if (s != end && (s[0] == '-' || s[0] == '+'))
48629:         s++;
48629: 
48640:     /* 15.1.2.2 step 9. */
48640:     int radix = maybeRadix;
48640:     if (radix == 0) {
48640:         if (end - s >= 2 && s[0] == '0' && (s[1] != 'x' && s[1] != 'X')) {
48640:             /*
48640:              * Non-standard: ES5 requires that parseInt interpret leading-zero
48640:              * strings not starting with "0x" or "0X" as decimal (absent an
48640:              * explicitly specified non-zero radix), but we continue to
48809:              * interpret such strings as octal, as per ES3 and web practice.
48640:              */
48809:             radix = 8;
48640:         } else {
48640:             radix = 10;
48640:         }
48640:     }
48640: 
48629:     /* 15.1.2.2 step 10. */
48629:     if (stripPrefix) {
48640:         if (end - s >= 2 && s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) {
48629:             s += 2;
48629:             radix = 16;
48629:         }
48629:     }
48629: 
48629:     /* 15.1.2.2 steps 11-14. */
48629:     const jschar *actualEnd;
48629:     if (!GetPrefixInteger(cx, s, end, radix, &actualEnd, dp))
48629:         return false;
48629:     if (s == actualEnd)
48629:         *dp = js_NaN;
48629:     else if (negative)
48629:         *dp = -*dp;
48629:     return true;
48629: }
48629: 
56593: static jsdouble
53297: ParseIntDoubleHelper(jsdouble d)
53297: {
53297:     if (!JSDOUBLE_IS_FINITE(d))
53297:         return js_NaN;
53297:     if (d > 0)
53297:         return floor(d);
53297:     if (d < 0)
53297:         return -floor(-d);
53297:     return 0;
53297: }
53297: 
    1: /* See ECMA 15.1.2.2. */
20408: static JSBool
48470: num_parseInt(JSContext *cx, uintN argc, Value *vp)
    1: {
48629:     /* Fast paths and exceptional cases. */
16519:     if (argc == 0) {
48470:         vp->setDouble(js_NaN);
48629:         return true;
16519:     }
48629: 
53297:     if (argc == 1 || (vp[3].isInt32() && (vp[3].toInt32() == 0 || vp[3].toInt32() == 10))) {
53297:         if (vp[2].isInt32()) {
48629:             *vp = vp[2];
48629:             return true;
48629:         }
53297:         if (vp[2].isDouble()) {
53297:             vp->setDouble(ParseIntDoubleHelper(vp[2].toDouble()));
48629:             return true;
48629:         }
48629:     }
48629: 
48629:     /* Step 1. */
48629:     JSString *inputString = js_ValueToString(cx, vp[2]);
48629:     if (!inputString)
48629:         return false;
48629:     vp[2].setString(inputString);
48629: 
48640:     /* 15.1.2.2 steps 6-8. */
48629:     bool stripPrefix = true;
48640:     int32_t radix = 0;
    1:     if (argc > 1) {
40828:         if (!ValueToECMAInt32(cx, vp[3], &radix))
48629:             return false;
48629:         if (radix != 0) {
48629:             if (radix < 2 || radix > 36) {
48629:                 vp->setDouble(js_NaN);
48629:                 return true;
48629:             }
48629:             if (radix != 16)
48629:                 stripPrefix = false;
    1:         }
    1:     }
    1: 
48640:     /* Steps 2-5, 9-14. */
48629:     const jschar *ws, *end;
48629:     inputString->getCharsAndEnd(ws, end);
12605: 
48629:     jsdouble number;
48629:     if (!ParseIntStringHelper(cx, ws, end, radix, stripPrefix, &number))
48629:         return false;
48629: 
48629:     /* Step 15. */
48629:     vp->setNumber(number);
48629:     return true;
    1: }
    1: 
20408: #ifdef JS_TRACER
20915: static jsdouble FASTCALL
20915: ParseInt(JSContext* cx, JSString* str)
20408: {
48629:     const jschar *start, *end;
48629:     str->getCharsAndEnd(start, end);
48629: 
20408:     jsdouble d;
48643:     if (!ParseIntStringHelper(cx, start, end, 0, true, &d)) {
48643:         SetBuiltinError(cx);
48643:         return js_NaN;
48643:     }
20408:     return d;
20408: }
20408: 
20915: static jsdouble FASTCALL
20915: ParseIntDouble(jsdouble d)
20408: {
53297:     return ParseIntDoubleHelper(d);
20408: }
20408: #endif
20408: 
    1: const char js_Infinity_str[]   = "Infinity";
    1: const char js_NaN_str[]        = "NaN";
    1: const char js_isNaN_str[]      = "isNaN";
    1: const char js_isFinite_str[]   = "isFinite";
    1: const char js_parseFloat_str[] = "parseFloat";
    1: const char js_parseInt_str[]   = "parseInt";
    1: 
20408: #ifdef JS_TRACER
20408: 
20930: JS_DEFINE_TRCINFO_2(num_parseInt,
48640:     (2, (static, DOUBLE_FAIL, ParseInt, CONTEXT, STRING,1, nanojit::ACCSET_NONE)),
48613:     (1, (static, DOUBLE, ParseIntDouble, DOUBLE,        1, nanojit::ACCSET_NONE)))
20408: 
20930: JS_DEFINE_TRCINFO_1(num_parseFloat,
48613:     (2, (static, DOUBLE, ParseFloat, CONTEXT, STRING,   1, nanojit::ACCSET_NONE)))
20408: 
20408: #endif /* JS_TRACER */
20408: 
    1: static JSFunctionSpec number_functions[] = {
16519:     JS_FN(js_isNaN_str,         num_isNaN,           1,0),
16519:     JS_FN(js_isFinite_str,      num_isFinite,        1,0),
32669:     JS_TN(js_parseFloat_str,    num_parseFloat,      1,0, &num_parseFloat_trcinfo),
32669:     JS_TN(js_parseInt_str,      num_parseInt,        2,0, &num_parseInt_trcinfo),
 4127:     JS_FS_END
    1: };
    1: 
48470: Class js_NumberClass = {
    1:     js_Number_str,
31452:     JSCLASS_HAS_RESERVED_SLOTS(1) | JSCLASS_HAS_CACHED_PROTO(JSProto_Number),
48622:     PropertyStub,   /* addProperty */
48622:     PropertyStub,   /* delProperty */
48622:     PropertyStub,   /* getProperty */
48622:     PropertyStub,   /* setProperty */
48622:     EnumerateStub,
48622:     ResolveStub,
48622:     ConvertStub
    1: };
    1: 
    1: static JSBool
53557: Number(JSContext *cx, uintN argc, Value *vp)
    1: {
53557:     /* Sample JS_CALLEE before clobbering. */
53557:     bool isConstructing = IsConstructing(vp);
53557: 
53557:     if (argc > 0) {
53557:         if (!ValueToNumber(cx, &vp[2]))
53557:             return false;
53557:         vp[0] = vp[2];
12850:     } else {
53557:         vp[0].setInt32(0);
12850:     }
53557: 
53557:     if (!isConstructing)
53557:         return true;
53557:     
53557:     JSObject *obj = NewBuiltinClassInstance(cx, &js_NumberClass);
53557:     if (!obj)
53557:         return false;
53557:     obj->setPrimitiveThis(vp[0]);
53557:     vp->setObject(*obj);
31452:     return true;
    1: }
    1: 
    1: #if JS_HAS_TOSOURCE
    1: static JSBool
48470: num_toSource(JSContext *cx, uintN argc, Value *vp)
    1: {
55711:     double d;
55711:     if (!GetPrimitiveThis(cx, vp, &d))
55711:         return false;
    1: 
53852:     ToCStringBuf cbuf;
53852:     char *numStr = NumberToCString(cx, &cbuf, d);
    1:     if (!numStr) {
    1:         JS_ReportOutOfMemory(cx);
55711:         return false;
    1:     }
55711: 
55711:     char buf[64];
    1:     JS_snprintf(buf, sizeof buf, "(new %s(%s))", js_NumberClass.name, numStr);
55711:     JSString *str = js_NewStringCopyZ(cx, buf);
    1:     if (!str)
55711:         return false;
48470:     vp->setString(str);
55711:     return true;
    1: }
    1: #endif
    1: 
53852: ToCStringBuf::ToCStringBuf() :dbuf(NULL)
53852: {
53852:     JS_STATIC_ASSERT(sbufSize >= DTOSTR_STANDARD_BUFFER_SIZE);
53852: }
53852: 
53852: ToCStringBuf::~ToCStringBuf()
53852: {
53852:     if (dbuf)
53852:         js_free(dbuf);
53852: }
53852: 
57760: JSString * JS_FASTCALL
57760: js_IntToString(JSContext *cx, int32 si)
57735: {
57735:     uint32 ui;
57735:     if (si >= 0) {
57735:         if (si < INT_STRING_LIMIT)
57735:             return JSString::intString(si);
57735:         if (si < 100)
57735:             return JSString::length2String(si);
57735:         ui = si;
57735:     } else {
57735:         ui = uint32(-si);
57735:         JS_ASSERT_IF(si == INT32_MIN, ui == uint32(INT32_MAX) + 1);
57735:     }
57735: 
57735:     JSThreadData *data = JS_THREAD_DATA(cx);
57735:     if (data->dtoaCache.s && data->dtoaCache.base == 10 && data->dtoaCache.d == si)
57735:         return data->dtoaCache.s;
57735: 
57735:     JSShortString *str = js_NewGCShortString(cx);
57735:     if (!str)
57735:         return NULL;
57735: 
57735:     /* +1, since MAX_SHORT_STRING_LENGTH does not count the null char. */
57735:     JS_STATIC_ASSERT(JSShortString::MAX_SHORT_STRING_LENGTH + 1 >= sizeof("-2147483648"));
57735: 
57735:     jschar *end = str->getInlineStorageBeforeInit() + JSShortString::MAX_SHORT_STRING_LENGTH;
57735:     jschar *cp = end;
57735:     *cp = 0;
57735: 
57735:     do {
57735:         jsuint newui = ui / 10, digit = ui % 10;  /* optimizers are our friends */
57735:         *--cp = '0' + digit;
57735:         ui = newui;
57735:     } while (ui != 0);
57735: 
57735:     if (si < 0)
57735:         *--cp = '-';
57735: 
57735:     str->initAtOffsetInBuffer(cp, end - cp);
57735: 
57735:     JSString *ret = str->header();
57735:     data->dtoaCache.base = 10;
57735:     data->dtoaCache.d = si;
57735:     data->dtoaCache.s = ret;
57735:     return ret;
57735: }
57735: 
53852: /* Returns a non-NULL pointer to inside cbuf.  */
23700: static char *
53852: IntToCString(ToCStringBuf *cbuf, jsint i, jsint base = 10)
    1: {
    1:     char *cp;
    1:     jsuint u;
    1: 
    1:     u = (i < 0) ? -i : i;
    1: 
53852:     cp = cbuf->sbuf + cbuf->sbufSize;   /* one past last buffer cell */
    1:     *--cp = '\0';                       /* null terminate the string to be */
    1: 
    1:     /*
    1:      * Build the string from behind. We use multiply and subtraction
    1:      * instead of modulus because that's much faster.
    1:      */
20898:     switch (base) {
20898:     case 10:
    1:       do {
    1:           jsuint newu = u / 10;
    1:           *--cp = (char)(u - newu * 10) + '0';
    1:           u = newu;
    1:       } while (u != 0);
20898:       break;
20898:     case 16:
20898:       do {
20898:           jsuint newu = u / 16;
20898:           *--cp = "0123456789abcdef"[u - newu * 16];
20898:           u = newu;
20898:       } while (u != 0);
20898:       break;
20898:     default:
20898:       JS_ASSERT(base >= 2 && base <= 36);
20898:       do {
20898:           jsuint newu = u / base;
20898:           *--cp = "0123456789abcdefghijklmnopqrstuvwxyz"[u - newu * base];
20898:           u = newu;
20898:       } while (u != 0);
20898:       break;
20898:     }
    1:     if (i < 0)
    1:         *--cp = '-';
    1: 
53852:     JS_ASSERT(cp >= cbuf->sbuf);
    1:     return cp;
    1: }
    1: 
33937: static JSString * JS_FASTCALL
33937: js_NumberToStringWithBase(JSContext *cx, jsdouble d, jsint base);
33937: 
20408: static JSBool
48470: num_toString(JSContext *cx, uintN argc, Value *vp)
    1: {
55711:     double d;
55711:     if (!GetPrimitiveThis(cx, vp, &d))
55711:         return false;
55711: 
40828:     int32_t base = 10;
48470:     if (argc != 0 && !vp[2].isUndefined()) {
40828:         if (!ValueToECMAInt32(cx, vp[2], &base))
    1:             return JS_FALSE;
40828: 
    1:         if (base < 2 || base > 36) {
53852:             ToCStringBuf cbuf;
53852:             char *numStr = IntToCString(&cbuf, base);   /* convert the base itself to a string */
53852:             JS_ASSERT(numStr);
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_RADIX,
    1:                                  numStr);
    1:             return JS_FALSE;
    1:         }
    1:     }
48470:     JSString *str = js_NumberToStringWithBase(cx, d, base);
33937:     if (!str) {
    1:         JS_ReportOutOfMemory(cx);
    1:         return JS_FALSE;
    1:     }
48470:     vp->setString(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
48470: num_toLocaleString(JSContext *cx, uintN argc, Value *vp)
    1: {
39928:     size_t thousandsLength, decimalLength;
    1:     const char *numGrouping, *tmpGroup;
    1:     JSRuntime *rt;
48470:     JSString *str;
    1:     const char *num, *end, *tmpSrc;
 6152:     char *buf, *tmpDest;
16181:     const char *nint;
    1:     int digits, size, remainder, nrepeat;
    1: 
    1:     /*
    1:      * Create the string, move back to bytes to make string twiddling
    1:      * a bit easier and so we can insert platform charset seperators.
    1:      */
20408:     if (!num_toString(cx, 0, vp))
    1:         return JS_FALSE;
48470:     JS_ASSERT(vp->isString());
57812:     JSAutoByteString numBytes(cx, vp->toString());
57812:     if (!numBytes)
57812:         return JS_FALSE;
57812:     num = numBytes.ptr();
    1:     if (!num)
    1:         return JS_FALSE;
    1: 
16181:     /*
16181:      * Find the first non-integer value, whether it be a letter as in
16183:      * 'Infinity', a decimal point, or an 'e' from exponential notation.
16181:      */
16181:     nint = num;
16181:     if (*nint == '-')
16181:         nint++;
16181:     while (*nint >= '0' && *nint <= '9')
16181:         nint++;
16181:     digits = nint - num;
    1:     end = num + digits;
16181:     if (!digits)
16181:         return JS_TRUE;
    1: 
    1:     rt = cx->runtime;
    1:     thousandsLength = strlen(rt->thousandsSeparator);
    1:     decimalLength = strlen(rt->decimalSeparator);
    1: 
    1:     /* Figure out how long resulting string will be. */
16181:     size = digits + (*nint ? strlen(nint + 1) + 1 : 0);
16181:     if (*nint == '.')
16181:         size += decimalLength;
    1: 
    1:     numGrouping = tmpGroup = rt->numGrouping;
    1:     remainder = digits;
    1:     if (*num == '-')
    1:         remainder--;
    1: 
    1:     while (*tmpGroup != CHAR_MAX && *tmpGroup != '\0') {
    1:         if (*tmpGroup >= remainder)
    1:             break;
    1:         size += thousandsLength;
    1:         remainder -= *tmpGroup;
    1:         tmpGroup++;
    1:     }
    1:     if (*tmpGroup == '\0' && *numGrouping != '\0') {
    1:         nrepeat = (remainder - 1) / tmpGroup[-1];
    1:         size += thousandsLength * nrepeat;
    1:         remainder -= nrepeat * tmpGroup[-1];
    1:     } else {
    1:         nrepeat = 0;
    1:     }
    1:     tmpGroup--;
    1: 
30851:     buf = (char *)cx->malloc(size + 1);
    1:     if (!buf)
    1:         return JS_FALSE;
    1: 
    1:     tmpDest = buf;
    1:     tmpSrc = num;
    1: 
    1:     while (*tmpSrc == '-' || remainder--)
    1:         *tmpDest++ = *tmpSrc++;
    1:     while (tmpSrc < end) {
    1:         strcpy(tmpDest, rt->thousandsSeparator);
    1:         tmpDest += thousandsLength;
    1:         memcpy(tmpDest, tmpSrc, *tmpGroup);
    1:         tmpDest += *tmpGroup;
    1:         tmpSrc += *tmpGroup;
    1:         if (--nrepeat < 0)
    1:             tmpGroup--;
    1:     }
    1: 
16181:     if (*nint == '.') {
    1:         strcpy(tmpDest, rt->decimalSeparator);
    1:         tmpDest += decimalLength;
16181:         strcpy(tmpDest, nint + 1);
    1:     } else {
16181:         strcpy(tmpDest, nint);
    1:     }
    1: 
    1:     if (cx->localeCallbacks && cx->localeCallbacks->localeToUnicode)
48470:         return cx->localeCallbacks->localeToUnicode(cx, buf, Jsvalify(vp));
    1: 
    1:     str = JS_NewString(cx, buf, size);
    1:     if (!str) {
30851:         cx->free(buf);
    1:         return JS_FALSE;
    1:     }
    1: 
48470:     vp->setString(str);
    1:     return JS_TRUE;
    1: }
    1: 
56216: JSBool
56216: js_num_valueOf(JSContext *cx, uintN argc, Value *vp)
    1: {
55711:     double d;
55711:     if (!GetPrimitiveThis(cx, vp, &d))
55711:         return false;
55711: 
55711:     vp->setNumber(d);
55711:     return true;
    1: }
    1: 
    1: 
    1: #define MAX_PRECISION 100
    1: 
    1: static JSBool
 4127: num_to(JSContext *cx, JSDToStrMode zeroArgMode, JSDToStrMode oneArgMode,
 4127:        jsint precisionMin, jsint precisionMax, jsint precisionOffset,
48470:        uintN argc, Value *vp)
    1: {
 4127:     /* Use MAX_PRECISION+1 because precisionOffset can be 1. */
 4127:     char buf[DTOSTR_VARIABLE_BUFFER_SIZE(MAX_PRECISION+1)];
 4127:     char *numStr;
 4127: 
55711:     double d;
55711:     if (!GetPrimitiveThis(cx, vp, &d))
55711:         return false;
    1: 
48470:     double precision;
 4127:     if (argc == 0) {
    1:         precision = 0.0;
    1:         oneArgMode = zeroArgMode;
    1:     } else {
40828:         if (!ValueToNumber(cx, vp[2], &precision))
    1:             return JS_FALSE;
    1:         precision = js_DoubleToInteger(precision);
    1:         if (precision < precisionMin || precision > precisionMax) {
53852:             ToCStringBuf cbuf;
53852:             numStr = IntToCString(&cbuf, jsint(precision));
53852:             JS_ASSERT(numStr);
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_PRECISION_RANGE, numStr);
    1:             return JS_FALSE;
    1:         }
    1:     }
    1: 
40339:     numStr = js_dtostr(JS_THREAD_DATA(cx)->dtoaState, buf, sizeof buf,
40339:                        oneArgMode, (jsint)precision + precisionOffset, d);
    1:     if (!numStr) {
    1:         JS_ReportOutOfMemory(cx);
    1:         return JS_FALSE;
    1:     }
48563:     JSString *str = js_NewStringCopyZ(cx, numStr);
    1:     if (!str)
    1:         return JS_FALSE;
48470:     vp->setString(str);
    1:     return JS_TRUE;
    1: }
    1: 
 4127: /*
 4127:  * In the following three implementations, we allow a larger range of precision
 4127:  * than ECMA requires; this is permitted by ECMA-262.
 4127:  */
    1: static JSBool
48470: num_toFixed(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return num_to(cx, DTOSTR_FIXED, DTOSTR_FIXED, -20, MAX_PRECISION, 0,
 4127:                   argc, vp);
    1: }
    1: 
    1: static JSBool
48470: num_toExponential(JSContext *cx, uintN argc, Value *vp)
    1: {
53852:     return num_to(cx, DTOSTR_STANDARD_EXPONENTIAL, DTOSTR_EXPONENTIAL, 0, MAX_PRECISION, 1,
53852:                   argc, vp);
    1: }
    1: 
    1: static JSBool
48470: num_toPrecision(JSContext *cx, uintN argc, Value *vp)
    1: {
48470:     if (argc == 0 || vp[2].isUndefined())
20408:         return num_toString(cx, 0, vp);
 4127:     return num_to(cx, DTOSTR_STANDARD, DTOSTR_PRECISION, 1, MAX_PRECISION, 0,
 4127:                   argc, vp);
    1: }
    1: 
20408: #ifdef JS_TRACER
20408: 
33937: JS_DEFINE_TRCINFO_2(num_toString,
48613:     (2, (extern, STRING_RETRY, js_NumberToString,         CONTEXT, THIS_DOUBLE,
48613:          1, nanojit::ACCSET_NONE)),
48613:     (3, (static, STRING_RETRY, js_NumberToStringWithBase, CONTEXT, THIS_DOUBLE, INT32,
48613:          1, nanojit::ACCSET_NONE)))
20408: 
20408: #endif /* JS_TRACER */
20408: 
    1: static JSFunctionSpec number_methods[] = {
    1: #if JS_HAS_TOSOURCE
55711:     JS_FN(js_toSource_str,       num_toSource,          0, JSFUN_PRIMITIVE_THIS),
    1: #endif
55711:     JS_TN(js_toString_str,       num_toString,          1, JSFUN_PRIMITIVE_THIS, &num_toString_trcinfo),
55711:     JS_FN(js_toLocaleString_str, num_toLocaleString,    0, JSFUN_PRIMITIVE_THIS),
56216:     JS_FN(js_valueOf_str,        js_num_valueOf,        0, JSFUN_PRIMITIVE_THIS),
56216:     JS_FN(js_toJSON_str,         js_num_valueOf,        0, JSFUN_PRIMITIVE_THIS),
55711:     JS_FN("toFixed",             num_toFixed,           1, JSFUN_PRIMITIVE_THIS),
55711:     JS_FN("toExponential",       num_toExponential,     1, JSFUN_PRIMITIVE_THIS),
55711:     JS_FN("toPrecision",         num_toPrecision,       1, JSFUN_PRIMITIVE_THIS),
 4127:     JS_FS_END
    1: };
    1: 
    1: /* NB: Keep this in synch with number_constants[]. */
    1: enum nc_slot {
    1:     NC_NaN,
    1:     NC_POSITIVE_INFINITY,
    1:     NC_NEGATIVE_INFINITY,
    1:     NC_MAX_VALUE,
    1:     NC_MIN_VALUE,
    1:     NC_LIMIT
    1: };
    1: 
    1: /*
    1:  * Some to most C compilers forbid spelling these at compile time, or barf
    1:  * if you try, so all but MAX_VALUE are set up by js_InitRuntimeNumberState
    1:  * using union jsdpun.
    1:  */
    1: static JSConstDoubleSpec number_constants[] = {
    1:     {0,                         js_NaN_str,          0,{0,0,0}},
    1:     {0,                         "POSITIVE_INFINITY", 0,{0,0,0}},
    1:     {0,                         "NEGATIVE_INFINITY", 0,{0,0,0}},
    1:     {1.7976931348623157E+308,   "MAX_VALUE",         0,{0,0,0}},
    1:     {0,                         "MIN_VALUE",         0,{0,0,0}},
    1:     {0,0,0,{0,0,0}}
    1: };
    1: 
18295: jsdouble js_NaN;
34372: jsdouble js_PositiveInfinity;
34372: jsdouble js_NegativeInfinity;
32599: 
39733: #if (defined __GNUC__ && defined __i386__) || \
39733:     (defined __SUNPRO_CC && defined __i386)
    1: 
    1: /*
    1:  * Set the exception mask to mask all exceptions and set the FPU precision
32599:  * to 53 bit mantissa (64 bit doubles).
    1:  */
32599: inline void FIX_FPU() {
32599:     short control;
32599:     asm("fstcw %0" : "=m" (control) : );
32599:     control &= ~0x300; // Lower bits 8 and 9 (precision control).
32599:     control |= 0x2f3;  // Raise bits 0-5 (exception masks) and 9 (64-bit precision).
32599:     asm("fldcw %0" : : "m" (control) );
32599: }
    1: 
    1: #else
    1: 
    1: #define FIX_FPU() ((void)0)
    1: 
    1: #endif
    1: 
    1: JSBool
    1: js_InitRuntimeNumberState(JSContext *cx)
    1: {
34372:     JSRuntime *rt = cx->runtime;
    1: 
    1:     FIX_FPU();
    1: 
34372:     jsdpun u;
48497:     u.s.hi = JSDOUBLE_HI32_NAN;
48497:     u.s.lo = JSDOUBLE_LO32_NAN;
18295:     number_constants[NC_NaN].dval = js_NaN = u.d;
48470:     rt->NaNValue.setDouble(u.d);
    1: 
    1:     u.s.hi = JSDOUBLE_HI32_EXPMASK;
    1:     u.s.lo = 0x00000000;
34372:     number_constants[NC_POSITIVE_INFINITY].dval = js_PositiveInfinity = u.d;
48470:     rt->positiveInfinityValue.setDouble(u.d);
    1: 
    1:     u.s.hi = JSDOUBLE_HI32_SIGNBIT | JSDOUBLE_HI32_EXPMASK;
    1:     u.s.lo = 0x00000000;
34372:     number_constants[NC_NEGATIVE_INFINITY].dval = js_NegativeInfinity = u.d;
48470:     rt->negativeInfinityValue.setDouble(u.d);
    1: 
    1:     u.s.hi = 0;
    1:     u.s.lo = 1;
    1:     number_constants[NC_MIN_VALUE].dval = u.d;
    1: 
40165: #ifndef HAVE_LOCALECONV
40165:     rt->thousandsSeparator = JS_strdup(cx, "'");
40165:     rt->decimalSeparator = JS_strdup(cx, ".");
40165:     rt->numGrouping = JS_strdup(cx, "\3\0");
40165: #else
34372:     struct lconv *locale = localeconv();
    1:     rt->thousandsSeparator =
    1:         JS_strdup(cx, locale->thousands_sep ? locale->thousands_sep : "'");
    1:     rt->decimalSeparator =
    1:         JS_strdup(cx, locale->decimal_point ? locale->decimal_point : ".");
    1:     rt->numGrouping =
    1:         JS_strdup(cx, locale->grouping ? locale->grouping : "\3\0");
40165: #endif
    1: 
    1:     return rt->thousandsSeparator && rt->decimalSeparator && rt->numGrouping;
    1: }
    1: 
    1: void
    1: js_FinishRuntimeNumberState(JSContext *cx)
    1: {
    1:     JSRuntime *rt = cx->runtime;
    1: 
30851:     cx->free((void *) rt->thousandsSeparator);
30851:     cx->free((void *) rt->decimalSeparator);
30851:     cx->free((void *) rt->numGrouping);
    1:     rt->thousandsSeparator = rt->decimalSeparator = rt->numGrouping = NULL;
    1: }
    1: 
    1: JSObject *
    1: js_InitNumberClass(JSContext *cx, JSObject *obj)
    1: {
    1:     JSObject *proto, *ctor;
    1:     JSRuntime *rt;
    1: 
    1:     /* XXX must do at least once per new thread, so do it per JSContext... */
    1:     FIX_FPU();
    1: 
    1:     if (!JS_DefineFunctions(cx, obj, number_functions))
    1:         return NULL;
    1: 
48470:     proto = js_InitClass(cx, obj, NULL, &js_NumberClass, Number, 1,
    1:                          NULL, number_methods, NULL, NULL);
    1:     if (!proto || !(ctor = JS_GetConstructor(cx, proto)))
    1:         return NULL;
48470:     proto->setPrimitiveThis(Int32Value(0));
    1:     if (!JS_DefineConstDoubles(cx, ctor, number_constants))
    1:         return NULL;
    1: 
    1:     /* ECMA 15.1.1.1 */
    1:     rt = cx->runtime;
48470:     if (!JS_DefineProperty(cx, obj, js_NaN_str, Jsvalify(rt->NaNValue),
48470:                            JS_PropertyStub, JS_PropertyStub,
37031:                            JSPROP_PERMANENT | JSPROP_READONLY)) {
    1:         return NULL;
    1:     }
    1: 
    1:     /* ECMA 15.1.1.2 */
48470:     if (!JS_DefineProperty(cx, obj, js_Infinity_str, Jsvalify(rt->positiveInfinityValue),
37031:                            JS_PropertyStub, JS_PropertyStub,
37031:                            JSPROP_PERMANENT | JSPROP_READONLY)) {
    1:         return NULL;
    1:     }
    1:     return proto;
    1: }
    1: 
54164: namespace v8 {
54164: namespace internal {
54164: extern char* DoubleToCString(double v, char* buffer, int buflen);
54164: }
54164: }
54164: 
53852: namespace js {
53852: 
23700: static char *
53852: FracNumberToCString(JSContext *cx, ToCStringBuf *cbuf, jsdouble d, jsint base = 10)
53852: {
53852: #ifdef DEBUG
53852:     {
53855:         int32_t _;
53852:         JS_ASSERT(!JSDOUBLE_IS_INT32(d, &_));
53852:     }
53852: #endif
54164: 
54164:     char* numStr;
54164:     if (base == 10) {
54164:         /*
54164:          * This is V8's implementation of the algorithm described in the
54164:          * following paper:
54164:          *
54164:          *   Printing floating-point numbers quickly and accurately with integers. 
54164:          *   Florian Loitsch, PLDI 2010.
54164:          *
54164:          * It fails on a small number of cases, whereupon we fall back to
54164:          * js_dtostr() (which uses David Gay's dtoa).
54164:          */
54164:         numStr = v8::internal::DoubleToCString(d, cbuf->sbuf, cbuf->sbufSize);
54164:         if (!numStr)
54164:             numStr = js_dtostr(JS_THREAD_DATA(cx)->dtoaState, cbuf->sbuf, cbuf->sbufSize,
54164:                                DTOSTR_STANDARD, 0, d);
54164:     } else {
54164:         numStr = cbuf->dbuf = js_dtobasestr(JS_THREAD_DATA(cx)->dtoaState, base, d);
54164:     }
54164:     return numStr;
53852: }
53852: 
53852: char *
53852: NumberToCString(JSContext *cx, ToCStringBuf *cbuf, jsdouble d, jsint base/* = 10*/)
    1: {
48470:     int32_t i;
53852:     return (JSDOUBLE_IS_INT32(d, &i))
53852:            ? IntToCString(cbuf, i, base)
53852:            : FracNumberToCString(cx, cbuf, d, base);
53852: }
    1: 
    1: }
    1: 
33937: static JSString * JS_FASTCALL
33937: js_NumberToStringWithBase(JSContext *cx, jsdouble d, jsint base)
20409: {
53852:     ToCStringBuf cbuf;
20409:     char *numStr;
23700:     JSString *s;
53852:     JSThreadData *data;
20409: 
33937:     /*
33937:      * Caller is responsible for error reporting. When called from trace,
33937:      * returning NULL here will cause us to fall of trace and then retry
33937:      * from the interpreter (which will report the error).
33937:      */
20898:     if (base < 2 || base > 36)
20898:         return NULL;
33937: 
48470:     int32_t i;
48470:     if (JSDOUBLE_IS_INT32(d, &i)) {
33937:         if (base == 10 && jsuint(i) < INT_STRING_LIMIT)
33937:             return JSString::intString(i);
33937:         if (jsuint(i) < jsuint(base)) {
33937:             if (i < 10)
33937:                 return JSString::intString(i);
39928:             return JSString::unitString(jschar('a' + i - 10));
33937:         }
53852: 
53852:         data = JS_THREAD_DATA(cx);
41847:         if (data->dtoaCache.s && data->dtoaCache.base == base && data->dtoaCache.d == d)
41847:             return data->dtoaCache.s;
53852: 
53852:         numStr = IntToCString(&cbuf, i, base);
53852:         JS_ASSERT(!cbuf.dbuf && numStr >= cbuf.sbuf && numStr < cbuf.sbuf + cbuf.sbufSize);
53852:     } else {
53852:         data = JS_THREAD_DATA(cx);
53852:         if (data->dtoaCache.s && data->dtoaCache.base == base && data->dtoaCache.d == d)
53852:             return data->dtoaCache.s;
53852: 
53852:         numStr = FracNumberToCString(cx, &cbuf, d, base);
53852:         if (!numStr) {
53852:             JS_ReportOutOfMemory(cx);
20409:             return NULL;
53852:         }
53852:         JS_ASSERT_IF(base == 10,
53852:                      !cbuf.dbuf && numStr >= cbuf.sbuf && numStr < cbuf.sbuf + cbuf.sbufSize);
53852:         JS_ASSERT_IF(base != 10,
53852:                      cbuf.dbuf && cbuf.dbuf == numStr);
53852:     }
53852: 
48563:     s = js_NewStringCopyZ(cx, numStr);
53852: 
41847:     data->dtoaCache.base = base;
41847:     data->dtoaCache.d = d;
41847:     data->dtoaCache.s = s;
53852: 
23700:     return s;
20409: }
20409: 
18078: JSString * JS_FASTCALL
    1: js_NumberToString(JSContext *cx, jsdouble d)
    1: {
33937:     return js_NumberToStringWithBase(cx, d, 10);
    1: }
    1: 
30023: JSBool JS_FASTCALL
48470: js_NumberValueToCharBuffer(JSContext *cx, const Value &v, JSCharBuffer &cb)
30023: {
30023:     /* Convert to C-string. */
53852:     ToCStringBuf cbuf;
30023:     const char *cstr;
48470:     if (v.isInt32()) {
53852:         cstr = IntToCString(&cbuf, v.toInt32());
30023:     } else {
53852:         cstr = NumberToCString(cx, &cbuf, v.toDouble());
53852:         if (!cstr) {
53852:             JS_ReportOutOfMemory(cx);
53852:             return JS_FALSE;
30023:         }
53852:     }
30023: 
30023:     /*
30023:      * Inflate to jschar string.  The input C-string characters are < 127, so
30023:      * even if jschars are UTF-8, all chars should map to one jschar.
30023:      */
30023:     size_t cstrlen = strlen(cstr);
53852:     JS_ASSERT(!cbuf.dbuf && cstrlen < cbuf.sbufSize);
31925:     size_t sizeBefore = cb.length();
48470:     if (!cb.growByUninitialized(cstrlen))
30023:         return JS_FALSE;
31890:     jschar *appendBegin = cb.begin() + sizeBefore;
30023: #ifdef DEBUG
30023:     size_t oldcstrlen = cstrlen;
30023:     JSBool ok =
30023: #endif
30023:         js_InflateStringToBuffer(cx, cstr, cstrlen, appendBegin, &cstrlen);
30023:     JS_ASSERT(ok && cstrlen == oldcstrlen);
30023:     return JS_TRUE;
30023: }
30023: 
40828: namespace js {
40828: 
48470: bool
48470: ValueToNumberSlow(JSContext *cx, Value v, double *out)
    1: {
48470:     JS_ASSERT(!v.isNumber());
40828:     goto skip_int_double;
40828:     for (;;) {
48470:         if (v.isNumber()) {
48470:             *out = v.toNumber();
48470:             return true;
40828:         }
40828:       skip_int_double:
48470:         if (v.isString()) {
48470:             jsdouble d = StringToNumberType<jsdouble>(cx, v.toString());
39942:             if (JSDOUBLE_IS_NaN(d))
12694:                 break;
40828:             *out = d;
48470:             return true;
12581:         }
48470:         if (v.isBoolean()) {
48470:             if (v.toBoolean()) {
40828:                 *out = 1.0;
48470:                 return true;
39942:             }
40828:             *out = 0.0;
48470:             return true;
12850:         }
48470:         if (v.isNull()) {
40828:             *out = 0.0;
48470:             return true;
12694:         }
48470:         if (v.isUndefined())
12694:             break;
12694: 
48470:         JS_ASSERT(v.isObject());
57876:         if (!v.isObject()) {
57876:             if (v.isMagic(JS_ARRAY_HOLE))
57876:                 *(int *) 0x88 = 0;
57876:             else
57876:                 *(int *) 0x99 = 0;
57876:         }
48470:         if (!DefaultValue(cx, &v.toObject(), JSTYPE_NUMBER, &v))
48470:             return false;
48470:         if (v.isObject())
12694:             break;
12694:     }
12694: 
40828:     *out = js_NaN;
48470:     return true;
12581: }
12581: 
40828: bool
48470: ValueToECMAInt32Slow(JSContext *cx, const Value &v, int32_t *out)
    1: {
48470:     JS_ASSERT(!v.isInt32());
    1:     jsdouble d;
48470:     if (v.isDouble()) {
48470:         d = v.toDouble();
12681:     } else {
48470:         if (!ValueToNumberSlow(cx, v, &d))
40828:             return false;
12681:     }
40828:     *out = js_DoubleToECMAInt32(d);
40828:     return true;
    1: }
    1: 
40828: bool
48470: ValueToECMAUint32Slow(JSContext *cx, const Value &v, uint32_t *out)
    1: {
48470:     JS_ASSERT(!v.isInt32());
    1:     jsdouble d;
48470:     if (v.isDouble()) {
48470:         d = v.toDouble();
12681:     } else {
48470:         if (!ValueToNumberSlow(cx, v, &d))
40828:             return false;
12681:     }
40828:     *out = js_DoubleToECMAUint32(d);
40828:     return true;
    1: }
    1: 
40828: }  /* namespace js */
40828: 
 9613: uint32
 9613: js_DoubleToECMAUint32(jsdouble d)
    1: {
12681:     int32 i;
    1:     JSBool neg;
12681:     jsdouble two32;
    1: 
12681:     if (!JSDOUBLE_IS_FINITE(d))
 9613:         return 0;
    1: 
12681:     /*
12681:      * We check whether d fits int32, not uint32, as all but the ">>>" bit
12681:      * manipulation bytecode stores the result as int, not uint. When the
48470:      * result does not fit int Value, it will be stored as a negative double.
12681:      */
12681:     i = (int32) d;
12681:     if ((jsdouble) i == d)
12681:         return (int32)i;
    1: 
    1:     neg = (d < 0);
    1:     d = floor(neg ? -d : d);
    1:     d = neg ? -d : d;
    1: 
12681:     two32 = 4294967296.0;
    1:     d = fmod(d, two32);
    1: 
11278:     return (uint32) (d >= 0 ? d : d + two32);
    1: }
    1: 
40828: namespace js {
40828: 
40828: bool
48470: ValueToInt32Slow(JSContext *cx, const Value &v, int32_t *out)
    1: {
48470:     JS_ASSERT(!v.isInt32());
    1:     jsdouble d;
48470:     if (v.isDouble()) {
48470:         d = v.toDouble();
48470:     } else if (!ValueToNumberSlow(cx, v, &d)) {
40828:         return false;
40828:     }
    1: 
    1:     if (JSDOUBLE_IS_NaN(d) || d <= -2147483649.0 || 2147483648.0 <= d) {
    1:         js_ReportValueError(cx, JSMSG_CANT_CONVERT,
    1:                             JSDVG_SEARCH_STACK, v, NULL);
40828:         return false;
    1:     }
40828:     *out = (int32) floor(d + 0.5);  /* Round to nearest */
40828:     return true;
    1: }
    1: 
40828: bool
48470: ValueToUint16Slow(JSContext *cx, const Value &v, uint16_t *out)
    1: {
48470:     JS_ASSERT(!v.isInt32());
    1:     jsdouble d;
48470:     if (v.isDouble()) {
48470:         d = v.toDouble();
48470:     } else if (!ValueToNumberSlow(cx, v, &d)) {
40828:         return false;
40828:     }
    1: 
40828:     if (d == 0 || !JSDOUBLE_IS_FINITE(d)) {
40828:         *out = 0;
40828:         return true;
40828:     }
12850: 
40828:     uint16 u = (uint16) d;
40828:     if ((jsdouble)u == d) {
40828:         *out = u;
40828:         return true;
40828:     }
40828: 
40828:     bool neg = (d < 0);
    1:     d = floor(neg ? -d : d);
    1:     d = neg ? -d : d;
40828:     jsuint m = JS_BIT(16);
    1:     d = fmod(d, (double) m);
    1:     if (d < 0)
    1:         d += m;
40828:     *out = (uint16_t) d;
40828:     return true;
12850: }
40828: 
40828: }  /* namespace js */
    1: 
    1: JSBool
 4281: js_strtod(JSContext *cx, const jschar *s, const jschar *send,
 4281:           const jschar **ep, jsdouble *dp)
    1: {
 4281:     const jschar *s1;
 4281:     size_t length, i;
    1:     char cbuf[32];
    1:     char *cstr, *istr, *estr;
    1:     JSBool negative;
    1:     jsdouble d;
 4281: 
 4281:     s1 = js_SkipWhiteSpace(s, send);
 4281:     length = send - s1;
    1: 
    1:     /* Use cbuf to avoid malloc */
    1:     if (length >= sizeof cbuf) {
30851:         cstr = (char *) cx->malloc(length + 1);
    1:         if (!cstr)
    1:            return JS_FALSE;
    1:     } else {
    1:         cstr = cbuf;
    1:     }
    1: 
 4281:     for (i = 0; i != length; i++) {
 4281:         if (s1[i] >> 8)
    1:             break;
    1:         cstr[i] = (char)s1[i];
    1:     }
 4281:     cstr[i] = 0;
    1: 
    1:     istr = cstr;
    1:     if ((negative = (*istr == '-')) != 0 || *istr == '+')
    1:         istr++;
32609:     if (*istr == 'I' && !strncmp(istr, js_Infinity_str, sizeof js_Infinity_str - 1)) {
34372:         d = negative ? js_NegativeInfinity : js_PositiveInfinity;
    1:         estr = istr + 8;
    1:     } else {
    1:         int err;
40339:         d = js_strtod_harder(JS_THREAD_DATA(cx)->dtoaState, cstr, &estr, &err);
    1:         if (d == HUGE_VAL)
34372:             d = js_PositiveInfinity;
    1:         else if (d == -HUGE_VAL)
34372:             d = js_NegativeInfinity;
    1:     }
    1: 
    1:     i = estr - cstr;
    1:     if (cstr != cbuf)
30851:         cx->free(cstr);
    1:     *ep = i ? s1 + i : s;
    1:     *dp = d;
    1:     return JS_TRUE;
    1: }
