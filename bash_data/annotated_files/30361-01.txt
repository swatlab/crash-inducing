15958: /* ***** BEGIN LICENSE BLOCK *****
15958:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
15958:  *
15958:  * The contents of this file are subject to the Mozilla Public License Version
15958:  * 1.1 (the "License"); you may not use this file except in compliance with
15958:  * the License. You may obtain a copy of the License at
15958:  * http://www.mozilla.org/MPL/
15958:  *
15958:  * Software distributed under the License is distributed on an "AS IS" basis,
15958:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
15958:  * for the specific language governing rights and limitations under the
15958:  * License.
15958:  *
15958:  * The Original Code is Geolocation.
15958:  *
15958:  * The Initial Developer of the Original Code is Mozilla Corporation
15958:  * Portions created by the Initial Developer are Copyright (C) 2008
15958:  * the Initial Developer. All Rights Reserved.
15958:  *
15958:  * Contributor(s):
15958:  *  Doug Turner <dougt@meer.net>  (Original Author)
15958:  *
15958:  * Alternatively, the contents of this file may be used under the terms of
15958:  * either the GNU General Public License Version 2 or later (the "GPL"), or
15958:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
15958:  * in which case the provisions of the GPL or the LGPL are applicable instead
15958:  * of those above. If you wish to allow use of your version of this file only
15958:  * under the terms of either the GPL or the LGPL, and not to allow others to
15958:  * use your version of this file under the terms of the MPL, indicate your
15958:  * decision by deleting the provisions above and replace them with the notice
15958:  * and other provisions required by the GPL or the LGPL. If you do not delete
15958:  * the provisions above, a recipient may use your version of this file under
15958:  * the terms of any one of the MPL, the GPL or the LGPL.
15958:  *
15958:  * ***** END LICENSE BLOCK ***** */
15958: 
15958: #include "nsGeolocation.h"
15958: #include "nsAutoPtr.h"
15958: #include "nsCOMPtr.h"
15958: #include "nsIDOMWindow.h"
15958: #include "nsDOMClassInfo.h"
15958: #include "nsComponentManagerUtils.h"
30193: #include "nsICategoryManager.h"
30193: #include "nsISupportsPrimitives.h"
15958: #include "nsServiceManagerUtils.h"
15958: #include "nsContentUtils.h"
15958: #include "nsIURI.h"
15958: #include "nsIPermissionManager.h"
15958: #include "nsIObserverService.h"
15958: #include "nsIPrefService.h"
15958: #include "nsIPrefBranch2.h"
19106: #include "nsIJSContextStack.h"
16677: 
16677: #include <math.h>
15958: 
19213: #ifdef NS_MAEMO_LOCATION
15958: #include "MaemoLocationProvider.h"
15958: #endif
15958: 
26580: #ifdef WINCE_WINDOWS_MOBILE
26169: #include "WinMobileLocationProvider.h"
26169: #endif
26169: 
15958: #include "nsIDOMDocument.h"
15958: #include "nsIDocument.h"
16677: 
21623: // Some limit to the number of get or watch geolocation requests
21623: // that a window can make.
21623: #define MAX_GEO_REQUESTS_PER_WINDOW  1500
21623: 
16677: ////////////////////////////////////////////////////
16677: // nsDOMGeoPositionError
16677: ////////////////////////////////////////////////////
16677: 
16677: class nsDOMGeoPositionError : public nsIDOMGeoPositionError
16677: {
16677: public:
16677:   NS_DECL_ISUPPORTS
16677:   NS_DECL_NSIDOMGEOPOSITIONERROR
16677: 
20687:   nsDOMGeoPositionError(PRInt16 aCode);
20687:   void NotifyCallback(nsIDOMGeoPositionErrorCallback* callback);
16677: 
16677: private:
16677:   ~nsDOMGeoPositionError();
16677:   PRInt16 mCode;
16677: };
16677: 
16677: NS_INTERFACE_MAP_BEGIN(nsDOMGeoPositionError)
16677:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMGeoPositionError)
16677:   NS_INTERFACE_MAP_ENTRY(nsIDOMGeoPositionError)
16677:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(GeoPositionError)
16677: NS_INTERFACE_MAP_END
16677: 
16677: NS_IMPL_THREADSAFE_ADDREF(nsDOMGeoPositionError)
16677: NS_IMPL_THREADSAFE_RELEASE(nsDOMGeoPositionError)
16677: 
20687: nsDOMGeoPositionError::nsDOMGeoPositionError(PRInt16 aCode)
20687:   : mCode(aCode)
16677: {
16677: }
16677: 
16677: nsDOMGeoPositionError::~nsDOMGeoPositionError(){}
16677: 
16677: 
16677: NS_IMETHODIMP
16677: nsDOMGeoPositionError::GetCode(PRInt16 *aCode)
16677: {
16677:   NS_ENSURE_ARG_POINTER(aCode);
16677:   *aCode = mCode;
16677:   return NS_OK;
16677: }
16677: 
16677: NS_IMETHODIMP
16677: nsDOMGeoPositionError::GetMessage(nsAString & aMessage)
16677: {
20687:   aMessage.Truncate();
16677:   return NS_OK;
16677: }
16677: 
20687: void
20687: nsDOMGeoPositionError::NotifyCallback(nsIDOMGeoPositionErrorCallback* aCallback)
20687: {
20687:   if (!aCallback)
20687:     return;
20687:   
20687:   // Ensure that the proper context is on the stack (bug 452762)
20687:   nsCOMPtr<nsIJSContextStack> stack(do_GetService("@mozilla.org/js/xpc/ContextStack;1"));
20687:   if (!stack || NS_FAILED(stack->Push(nsnull)))
20687:     return;
20687:   
20687:   aCallback->HandleEvent(this);
20687:   
20687:   // remove the stack
20687:   JSContext* cx;
20687:   stack->Pop(&cx);
20687: }
15958: ////////////////////////////////////////////////////
15958: // nsGeolocationRequest
15958: ////////////////////////////////////////////////////
15958: 
20687: nsGeolocationRequest::nsGeolocationRequest(nsGeolocation* aLocator,
20687:                                            nsIDOMGeoPositionCallback* aCallback,
20687:                                            nsIDOMGeoPositionErrorCallback* aErrorCallback,
20687:                                            nsIDOMGeoPositionOptions* aOptions)
20687:   : mAllowed(PR_FALSE),
20687:     mCleared(PR_FALSE),
20687:     mHasSentData(PR_FALSE),
20687:     mCallback(aCallback),
20687:     mErrorCallback(aErrorCallback),
20687:     mOptions(aOptions),
20687:     mLocator(aLocator)
15958: {
15958: }
15958: 
15958: nsGeolocationRequest::~nsGeolocationRequest()
15958: {
15958: }
15958: 
21622: nsresult
21622: nsGeolocationRequest::Init()
21622: {
21622:   // This method is called before the user has given permission for this request.
21622: 
21622:   // check to see if we have a geolocation provider, if not, notify an error and bail.
21622:   nsRefPtr<nsGeolocationService> geoService = nsGeolocationService::GetInstance();
21622:   if (!geoService->HasGeolocationProvider()) {
21628:     NotifyError(nsIDOMGeoPositionError::POSITION_UNAVAILABLE);
21622:     return NS_ERROR_FAILURE;;
21622:   }
21622: 
21622:   return NS_OK;
21622: }
21622: 
23692: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsGeolocationRequest)
15958:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIGeolocationRequest)
15958:   NS_INTERFACE_MAP_ENTRY(nsIGeolocationRequest)
20687:   NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
15958: NS_INTERFACE_MAP_END
15958: 
23692: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsGeolocationRequest)
23692: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsGeolocationRequest)
23692: 
29118: NS_IMPL_CYCLE_COLLECTION_4(nsGeolocationRequest, mCallback, mErrorCallback, mOptions, mLocator)
15958: 
20687: 
20687: void
20687: nsGeolocationRequest::NotifyError(PRInt16 errorCode)
20687: {
20687:   nsRefPtr<nsDOMGeoPositionError> positionError = new nsDOMGeoPositionError(errorCode);
20687:   if (!positionError)
20687:     return;
20687:   
20687:   positionError->NotifyCallback(mErrorCallback);
20687: }
20687: 
20687: 
20687: NS_IMETHODIMP
20687: nsGeolocationRequest::Notify(nsITimer* aTimer)
20687: {
20687:   // If we haven't gotten an answer from the geolocation
20687:   // provider yet, cancel the request.  Same logic as
20687:   // ::Cancel, just a different error
20687:   
20687:   if (!mHasSentData) {
21628:     NotifyError(nsIDOMGeoPositionError::TIMEOUT);
20687:     // remove ourselves from the locator's callback lists.
20687:     mLocator->RemoveRequest(this);
20687:   }
20687: 
20687:   mTimeoutTimer = nsnull;
20687:   return NS_OK;
20687: }
20687:  
15958: NS_IMETHODIMP
15958: nsGeolocationRequest::GetRequestingURI(nsIURI * *aRequestingURI)
15958: {
15958:   NS_ENSURE_ARG_POINTER(aRequestingURI);
30191: 
30191:   nsCOMPtr<nsIURI> uri = mLocator->GetURI();
30191:   uri.forget(aRequestingURI);
30191: 
15958:   return NS_OK;
15958: }
15958: 
15958: NS_IMETHODIMP
15958: nsGeolocationRequest::GetRequestingWindow(nsIDOMWindow * *aRequestingWindow)
15958: {
15958:   NS_ENSURE_ARG_POINTER(aRequestingWindow);
30191: 
30191:   nsCOMPtr<nsIDOMWindow> window = do_QueryReferent(mLocator->GetOwner());
30191:   window.forget(aRequestingWindow);
30191: 
15958:   return NS_OK;
15958: }
15958: 
15958: NS_IMETHODIMP
15958: nsGeolocationRequest::Cancel()
15958: {
21628:   NotifyError(nsIDOMGeoPositionError::PERMISSION_DENIED);
20687: 
15958:   // remove ourselves from the locators callback lists.
15958:   mLocator->RemoveRequest(this);
15958:   return NS_OK;
15958: }
15958: 
15958: NS_IMETHODIMP
15958: nsGeolocationRequest::Allow()
15958: {
22369:   nsRefPtr<nsGeolocationService> geoService = nsGeolocationService::GetInstance();
22369: 
23412:   // Kick off the geo device, if it isn't already running
23412:   nsresult rv = geoService->StartDevice();
23412:   
23412:   if (NS_FAILED(rv)) {
23412:     // Location provider error
23412:     NotifyError(nsIDOMGeoPositionError::POSITION_UNAVAILABLE);
23412:     return NS_OK;
23412:   }
23412:   
22369:   nsCOMPtr<nsIDOMGeoPosition> lastPosition = geoService->GetCachedPosition();
22369:   DOMTimeStamp cachedPositionTime;
23412:   if (lastPosition)
22369:     lastPosition->GetTimestamp(&cachedPositionTime);
22369: 
23412:   // check to see if we can use a cached value
23412:   //
23412:   // either:
23412:   // a) the user has specified a maximumAge which allows us to return a cached value,
23412:   // -or-
23412:   // b) the cached position time is some reasonable value to return to the user (<30s)
23412:   
23412:   PRUint32 maximumAge = 30 * PR_MSEC_PER_SEC;
23412:   if (mOptions) {
23414:     PRInt32 tempAge;
23412:     nsresult rv = mOptions->GetMaximumAge(&tempAge);
23414:     if (NS_SUCCEEDED(rv)) {
23414:       if (tempAge > 0)
23412:         maximumAge = tempAge;
23412:     }
23414:   }
23412: 
23412:   if (lastPosition && maximumAge > 0 && ( (PR_Now() / PR_USEC_PER_MSEC ) - maximumAge <= cachedPositionTime) ) {
22369:     // okay, we can return a cached position
22369:     mAllowed = PR_TRUE;
22369:     
22369:     // send the cached location
22369:     SendLocation(lastPosition);
22369:   }
22369: 
23414:   PRInt32 timeout;
20687:   if (mOptions && NS_SUCCEEDED(mOptions->GetTimeout(&timeout)) && timeout > 0) {
23412:     
23412:     if (timeout < 10)
23412:       timeout = 10;
23412: 
20687:     mTimeoutTimer = do_CreateInstance("@mozilla.org/timer;1");
20687:     mTimeoutTimer->InitWithCallback(this, timeout, nsITimer::TYPE_ONE_SHOT);
16677:   }
15958: 
15958:   mAllowed = PR_TRUE;
15958:   return NS_OK;
15958: }
15958: 
15958: void
15958: nsGeolocationRequest::MarkCleared()
15958: {
15958:   mCleared = PR_TRUE;
15958: }
15958: 
15958: void
20687: nsGeolocationRequest::SendLocation(nsIDOMGeoPosition* aPosition)
15958: {
16329:   if (mCleared || !mAllowed)
15958:     return;
15958: 
21626:   // we should not pass null back to the DOM.
21626:   if (!aPosition) {
21626:     NotifyError(nsIDOMGeoPositionError::POSITION_UNAVAILABLE);
21626:     return;
21626:   }
21626: 
19106:   // Ensure that the proper context is on the stack (bug 452762)
19106:   nsCOMPtr<nsIJSContextStack> stack(do_GetService("@mozilla.org/js/xpc/ContextStack;1"));
19106:   if (!stack || NS_FAILED(stack->Push(nsnull)))
19106:     return; // silently fail
19106:   
20687:   mCallback->HandleEvent(aPosition);
15958: 
19106:   // remove the stack
19106:   JSContext* cx;
19106:   stack->Pop(&cx);
20687: 
20687:   mHasSentData = PR_TRUE;
15958: }
15958: 
15958: void
15958: nsGeolocationRequest::Shutdown()
15958: {
15958:   mCleared = PR_TRUE;
15958:   mCallback = nsnull;
16677:   mErrorCallback = nsnull;
15958: }
15958: 
15958: ////////////////////////////////////////////////////
16677: // nsGeolocationService
15958: ////////////////////////////////////////////////////
16677: NS_INTERFACE_MAP_BEGIN(nsGeolocationService)
15958:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIGeolocationUpdate)
15958:   NS_INTERFACE_MAP_ENTRY(nsIGeolocationUpdate)
15958:   NS_INTERFACE_MAP_ENTRY(nsIObserver)
15958: NS_INTERFACE_MAP_END
15958: 
16677: NS_IMPL_THREADSAFE_ADDREF(nsGeolocationService)
16677: NS_IMPL_THREADSAFE_RELEASE(nsGeolocationService)
15958: 
28057: 
28057: static PRBool sGeoEnabled = PR_TRUE;
28057: static int
28057: GeoEnabledChangedCallback(const char *aPrefName, void *aClosure)
28057: {
28057:   sGeoEnabled = nsContentUtils::GetBoolPref("geo.enabled", PR_TRUE);
28057:   return 0;
28057: }
28057: 
16677: nsGeolocationService::nsGeolocationService()
15958: {
15958:   nsCOMPtr<nsIObserverService> obs = do_GetService("@mozilla.org/observer-service;1");
15958:   if (obs) {
15958:     obs->AddObserver(this, "quit-application", false);
15958:   }
15958: 
15958:   mTimeout = nsContentUtils::GetIntPref("geo.timeout", 6000);
21622: 
28057:   nsContentUtils::RegisterPrefCallback("geo.enabled",
28057:                                        GeoEnabledChangedCallback,
28057:                                        nsnull);
28057: 
28057:   GeoEnabledChangedCallback("geo.enabled", nsnull);
28057: 
28057:   if (sGeoEnabled == PR_FALSE)
27350:     return;
27350: 
30193:   nsCOMPtr<nsIGeolocationProvider> provider = do_GetService(NS_GEOLOCATION_PROVIDER_CONTRACTID);
30193:   if (provider)
30193:     mProviders.AppendObject(provider);
30193: 
30193: 
30193:   // look up any providers that were registered via the category manager
30193:   nsCOMPtr<nsICategoryManager> catMan(do_GetService("@mozilla.org/categorymanager;1"));
30193:   if (!catMan)
30193:     return;
30193: 
30193:   nsCOMPtr<nsISimpleEnumerator> geoproviders;
30193:   catMan->EnumerateCategory("geolocation-provider", getter_AddRefs(geoproviders));
30193:   if (geoproviders) {
30193: 
30193:     PRBool hasMore;
30193:     while (NS_SUCCEEDED(geoproviders->HasMoreElements(&hasMore)) && hasMore) {
30193:       nsCOMPtr<nsISupports> elem;
30193:       geoproviders->GetNext(getter_AddRefs(elem));
30193: 
30193:       nsCOMPtr<nsISupportsCString> elemString = do_QueryInterface(elem);
30193:       
30193:       nsCAutoString name;
30193:       elemString->GetData(name);
30193: 
30193:       nsXPIDLCString spec;
30193:       catMan->GetCategoryEntry("geolocation-provider", name.get(), getter_Copies(spec));
30193: 
30193:       provider = do_GetService(spec);
30193:       if (provider)
30193:         mProviders.AppendObject(provider);
30193:     }
30193:   }
30193: 
30193:   // we should move these providers outside of this file! dft
21622: 
21622:   // if NS_MAEMO_LOCATION, see if we should try the MAEMO location provider
21622: #ifdef NS_MAEMO_LOCATION
30193:   provider = new MaemoLocationProvider();
30193:   if (provider)
30193:     mProviders.AppendObject(provider);
21622: #endif
21622: 
26169:   // if WINCE, see if we should try the WINCE location provider
26580: #ifdef WINCE_WINDOWS_MOBILE
30193:   provider = new WinMobileLocationProvider();
30193:   if (provider)
30193:     mProviders.AppendObject(provider);
26169: #endif
15958: }
15958: 
16677: nsGeolocationService::~nsGeolocationService()
15958: {
15958: }
15958: 
15958: NS_IMETHODIMP
20687: nsGeolocationService::Observe(nsISupports* aSubject,
20687:                               const char* aTopic,
15958:                               const PRUnichar* aData)
15958: {
15958:   if (!strcmp("quit-application", aTopic))
15958:   {
15958:     nsCOMPtr<nsIObserverService> obs = do_GetService("@mozilla.org/observer-service;1");
15958:     if (obs) {
15958:       obs->RemoveObserver(this, "quit-application");
15958:     }
15958: 
15958:     for (PRUint32 i = 0; i< mGeolocators.Length(); i++)
15958:       mGeolocators[i]->Shutdown();
15958: 
15958:     StopDevice();
15958: 
15958:     return NS_OK;
15958:   }
15958:   
15958:   if (!strcmp("timer-callback", aTopic))
15958:   {
15958:     // decide if we can close down the service.
15958:     for (PRUint32 i = 0; i< mGeolocators.Length(); i++)
15958:       if (mGeolocators[i]->HasActiveCallbacks())
15958:       {
15958:         SetDisconnectTimer();
15958:         return NS_OK;
15958:       }
15958:     
15958:     // okay to close up.
15958:     StopDevice();
15958:     Update(nsnull);
15958:     return NS_OK;
15958:   }
15958: 
15958:   return NS_ERROR_FAILURE;
15958: }
15958: 
15958: NS_IMETHODIMP
20687: nsGeolocationService::Update(nsIDOMGeoPosition *aSomewhere)
15958: {
30193:   // here we have to determine this aSomewhere is a "better"
30193:   // position than any previously recv'ed.
30193: 
30193:   if (!IsBetterPosition(aSomewhere))
30193:     return NS_OK;
30193: 
30193:   SetCachedPosition(aSomewhere);
30193: 
15958:   for (PRUint32 i = 0; i< mGeolocators.Length(); i++)
20687:     mGeolocators[i]->Update(aSomewhere);
15958:   return NS_OK;
15958: }
15958: 
30193: PRBool
30193: nsGeolocationService::IsBetterPosition(nsIDOMGeoPosition *aSomewhere)
30193: {
30193:   if (!aSomewhere)
30193:     return PR_FALSE;
30193: 
30193:   nsRefPtr<nsGeolocationService> geoService = nsGeolocationService::GetInstance();
30193:   if (!geoService)
30193:     return PR_FALSE;
30193: 
30193:   nsCOMPtr<nsIDOMGeoPosition> lastPosition = geoService->GetCachedPosition();
30193:   if (!lastPosition)
30193:     return PR_TRUE;
30193:   
30193:   nsresult rv;
30193:   DOMTimeStamp oldTime;
30193:   rv = lastPosition->GetTimestamp(&oldTime);
30193:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
30193: 
30193:   nsCOMPtr<nsIDOMGeoPositionCoords> coords;
30193:   lastPosition->GetCoords(getter_AddRefs(coords));
30193:   if (!coords)
30193:     return PR_FALSE;
30193: 
30193:   double oldAccuracy;
30193:   rv = coords->GetAccuracy(&oldAccuracy);
30193:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
30193: 
30193:   double oldLat, oldLon;
30193:   rv = coords->GetLongitude(&oldLon);
30193:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
30193: 
30193:   rv = coords->GetLatitude(&oldLat);
30193:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
30193: 
30193: 
30193:   DOMTimeStamp newTime;
30193:   rv = aSomewhere->GetTimestamp(&newTime);
30193:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
30193: 
30193:   aSomewhere->GetCoords(getter_AddRefs(coords));
30193:   if (!coords)
30193:     return PR_FALSE;
30193: 
30193:   double newAccuracy;
30193:   rv = coords->GetAccuracy(&newAccuracy);
30193:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
30193: 
30193:   double newLat, newLon;
30193:   rv = coords->GetLongitude(&newLon);
30193:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
30193: 
30193:   rv = coords->GetLatitude(&newLat);
30193:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
30193: 
30193:   // check to see if there has been a large movement
30193:   double delta = fabs(newLat - oldLat) + fabs(newLon + oldLon);
30193: 
30193:   // Convert to meters. 1 second of arc of latitude (or longitude at the
30193:   // equator) is 1 nautical mile or 1852m.
30193:   delta *= 60 * 1852;
30193: 
30193:   // The threshold is when the distance between the two positions exceeds the
30193:   // worse (larger value) of the two accuracies.
30193:   double max_accuracy = PR_MAX(oldAccuracy, newAccuracy);
30193:   if (delta > max_accuracy)
30193:     return PR_TRUE;
30193: 
30193:   // check to see if the aSomewhere position is more accurate
30193:   if (oldAccuracy >= newAccuracy)
30193:     return PR_TRUE;
30193: 
30193:   return PR_FALSE;
30193: }
22369: 
22369: void
22369: nsGeolocationService::SetCachedPosition(nsIDOMGeoPosition* aPosition)
22369: {
22369:   mLastPosition = aPosition;
22369: }
22369: 
22369: nsIDOMGeoPosition*
22369: nsGeolocationService::GetCachedPosition()
22369: {
22369:   return mLastPosition;
22369: }
22369: 
21622: PRBool
21622: nsGeolocationService::HasGeolocationProvider()
21622: {
30193:   return mProviders.Count() > 0;
21622: }
21622: 
15958: nsresult
16677: nsGeolocationService::StartDevice()
15958: {
28057:   if (sGeoEnabled == PR_FALSE)
28057:     return NS_ERROR_NOT_AVAILABLE;
28057: 
30193:   if (!HasGeolocationProvider())
21622:     return NS_ERROR_NOT_AVAILABLE;
15958:   
15958:   // if we have one, start it up.
30193: 
30193:   // Start them up!
30193:   nsresult rv = NS_ERROR_NOT_AVAILABLE;
30193:   for (PRUint32 i = mProviders.Count() - 1; i != PRUint32(-1); --i) {
30193:     // If any provder gets started without error, go ahead
30193:     // and proceed without error
30193:     nsresult temp = mProviders[i]->Startup();
30193:     if (NS_SUCCEEDED(temp)) {
30193:       rv = NS_OK;
30193: 
30193:       mProviders[i]->Watch(this);
30193:     }
30193:   }
30193:   
15958:   if (NS_FAILED(rv)) 
16677:     return NS_ERROR_NOT_AVAILABLE;
15958:   
15958:   // we do not want to keep the geolocation devices online
15958:   // indefinitely.  Close them down after a reasonable period of
15958:   // inactivivity
15958:   SetDisconnectTimer();
21622: 
15958:   return NS_OK;
15958: }
15958: 
15958: void
16677: nsGeolocationService::SetDisconnectTimer()
15958: {
15958:   if (!mDisconnectTimer)
15958:     mDisconnectTimer = do_CreateInstance("@mozilla.org/timer;1");
15958:   else
15958:     mDisconnectTimer->Cancel();
15958: 
15958:   mDisconnectTimer->Init(this,
15958:                          mTimeout,
15958:                          nsITimer::TYPE_ONE_SHOT);
15958: }
15958: 
15958: void 
16677: nsGeolocationService::StopDevice()
15958: {
30193:   for (PRUint32 i = mProviders.Count() - 1; i != PRUint32(-1); --i) {
30193:     mProviders[i]->Shutdown();
15958:   }
15958: 
15958:   if(mDisconnectTimer) {
15958:     mDisconnectTimer->Cancel();
15958:     mDisconnectTimer = nsnull;
15958:   }
15958: }
15958: 
16677: nsGeolocationService* nsGeolocationService::gService = nsnull;
15958: 
16677: nsGeolocationService*
16677: nsGeolocationService::GetInstance()
15958: {
16677:   if (!nsGeolocationService::gService) {
16677:     nsGeolocationService::gService = new nsGeolocationService();
20687:     NS_ASSERTION(nsGeolocationService::gService, "null nsGeolocationService.");
15958:   }
16677:   return nsGeolocationService::gService;
15958: }
15958: 
16677: nsGeolocationService*
16677: nsGeolocationService::GetGeolocationService()
15958: {
16677:   nsGeolocationService* inst = nsGeolocationService::GetInstance();
15958:   NS_ADDREF(inst);
15958:   return inst;
15958: }
15958: 
15958: void
20687: nsGeolocationService::AddLocator(nsGeolocation* aLocator)
15958: {
20687:   mGeolocators.AppendElement(aLocator);
15958: }
15958: 
15958: void
20687: nsGeolocationService::RemoveLocator(nsGeolocation* aLocator)
15958: {
20687:   mGeolocators.RemoveElement(aLocator);
15958: }
15958: 
15958: ////////////////////////////////////////////////////
16677: // nsGeolocation
15958: ////////////////////////////////////////////////////
15958: 
23692: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsGeolocation)
16677:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMGeoGeolocation)
16677:   NS_INTERFACE_MAP_ENTRY(nsIDOMGeoGeolocation)
16677:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(GeoGeolocation)
15958: NS_INTERFACE_MAP_END
15958: 
23692: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsGeolocation)
23692: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsGeolocation)
23692: NS_IMPL_CYCLE_COLLECTION_CLASS(nsGeolocation)
23692: 
23692: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsGeolocation)
23692:   tmp->mPendingCallbacks.Clear();
23692:   tmp->mWatchingCallbacks.Clear();
23692: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
23692: 
23692: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsGeolocation)
23692:   PRUint32 i; 
23692:   for (i = 0; i < tmp->mPendingCallbacks.Length(); ++i)
23692:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mPendingCallbacks[i], nsIGeolocationRequest)
23692: 
23692:   for (i = 0; i < tmp->mWatchingCallbacks.Length(); ++i)
23692:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mWatchingCallbacks[i], nsIGeolocationRequest)
23692: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
15958: 
20687: nsGeolocation::nsGeolocation(nsIDOMWindow* aContentDom) 
15958: : mUpdateInProgress(PR_FALSE)
15958: {
15958:   // Remember the window
20687:   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(aContentDom);
15958:   if (window)
30191:     mOwner = do_GetWeakReference(window->GetCurrentInnerWindow());
15958: 
15958:   // Grab the uri of the document
15958:   nsCOMPtr<nsIDOMDocument> domdoc;
20687:   aContentDom->GetDocument(getter_AddRefs(domdoc));
15958:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(domdoc);
15958:   if (doc)
15958:     doc->NodePrincipal()->GetURI(getter_AddRefs(mURI));
15958: 
16677:   mService = nsGeolocationService::GetInstance();
15958:   if (mService)
15958:     mService->AddLocator(this);
15958: }
15958: 
16677: nsGeolocation::~nsGeolocation()
15958: {
27439:   if (mService)
27439:     Shutdown();
15958: }
15958: 
15958: void
16677: nsGeolocation::Shutdown()
15958: {
15958:   // Shutdown and release all callbacks
20687:   for (PRUint32 i = 0; i< mPendingCallbacks.Length(); i++)
15958:     mPendingCallbacks[i]->Shutdown();
15958:   mPendingCallbacks.Clear();
15958: 
20687:   for (PRUint32 i = 0; i< mWatchingCallbacks.Length(); i++)
15958:     mWatchingCallbacks[i]->Shutdown();
15958:   mWatchingCallbacks.Clear();
15958: 
15958:   if (mService)
15958:     mService->RemoveLocator(this);
15958: 
15958:   mService = nsnull;
15958:   mURI = nsnull;
15958: }
15958: 
15958: PRBool
16677: nsGeolocation::HasActiveCallbacks()
15958: {
20687:   return mWatchingCallbacks.Length() != 0;
15958: }
15958: 
15958: void
20687: nsGeolocation::RemoveRequest(nsGeolocationRequest* aRequest)
15958: {
20687:   mPendingCallbacks.RemoveElement(aRequest);
15958: 
15958:   // if it is in the mWatchingCallbacks, we can't do much
15958:   // since we passed back the position in the array to who
15958:   // ever called WatchPosition() and we do not want to mess
15958:   // around with the ordering of the array.  Instead, just
15958:   // mark the request as "cleared".
15958: 
20687:   aRequest->MarkCleared();
15958: }
15958: 
15958: void
20687: nsGeolocation::Update(nsIDOMGeoPosition *aSomewhere)
15958: {
15958:   // This method calls out to objects which may spin and
15958:   // event loop which may add new location objects into
15958:   // mPendingCallbacks, and mWatchingCallbacks.  Since this
15958:   // function can only be called on the primary thread, we
15958:   // can lock this method with a member var.
15958: 
15958:   if (mUpdateInProgress)
15958:     return;
15958: 
15958:   mUpdateInProgress = PR_TRUE;
22369: 
15958:   if (!OwnerStillExists())
15958:   {
15958:     Shutdown();
15958:     return;
15958:   }
15958: 
15958:   // notify anyone that has been waiting
20687:   for (PRUint32 i = 0; i< mPendingCallbacks.Length(); i++)
20687:     mPendingCallbacks[i]->SendLocation(aSomewhere);
15958:   mPendingCallbacks.Clear();
15958: 
15958:   // notify everyone that is watching
20687:   for (PRUint32 i = 0; i< mWatchingCallbacks.Length(); i++)
20687:     mWatchingCallbacks[i]->SendLocation(aSomewhere);
15958: 
15958:   mUpdateInProgress = PR_FALSE;
15958: }
15958: 
15958: NS_IMETHODIMP
16677: nsGeolocation::GetCurrentPosition(nsIDOMGeoPositionCallback *callback,
16677:                                   nsIDOMGeoPositionErrorCallback *errorCallback,
16677:                                   nsIDOMGeoPositionOptions *options)
15958: {
30361:   NS_ENSURE_ARG_POINTER(callback);
30361: 
28057:   if (sGeoEnabled == PR_FALSE)
28057:     return NS_ERROR_NOT_AVAILABLE;
28057: 
20809:   nsCOMPtr<nsIGeolocationPrompt> prompt = do_GetService(NS_GEOLOCATION_PROMPT_CONTRACTID);
15958:   if (prompt == nsnull)
15958:     return NS_ERROR_NOT_AVAILABLE;
15958: 
21623:   if (mPendingCallbacks.Length() > MAX_GEO_REQUESTS_PER_WINDOW)
21623:     return NS_ERROR_NOT_AVAILABLE;
21623: 
20687:   nsRefPtr<nsGeolocationRequest> request = new nsGeolocationRequest(this, callback, errorCallback, options);
20687:   if (!request)
20687:     return NS_ERROR_OUT_OF_MEMORY;
20687: 
21622:   if (NS_FAILED(request->Init()))
21622:     return NS_OK;
21622: 
15958:   prompt->Prompt(request);
15958: 
15958:   // What if you have a location provider that only sends a location once, then stops.?  fix.
20687:   mPendingCallbacks.AppendElement(request);
15958:   return NS_OK;
15958: }
15958: 
15958: NS_IMETHODIMP
20687: nsGeolocation::WatchPosition(nsIDOMGeoPositionCallback *aCallback,
20687:                              nsIDOMGeoPositionErrorCallback *aErrorCallback,
20687:                              nsIDOMGeoPositionOptions *aOptions, 
21624:                              PRInt32 *_retval NS_OUTPARAM)
15958: {
30361:   NS_ENSURE_ARG_POINTER(aCallback);
30361: 
28057:   if (sGeoEnabled == PR_FALSE)
28057:     return NS_ERROR_NOT_AVAILABLE;
28057: 
20809:   nsCOMPtr<nsIGeolocationPrompt> prompt = do_GetService(NS_GEOLOCATION_PROMPT_CONTRACTID);
15958:   if (prompt == nsnull)
15958:     return NS_ERROR_NOT_AVAILABLE;
15958: 
21623:   if (mWatchingCallbacks.Length() > MAX_GEO_REQUESTS_PER_WINDOW)
21623:     return NS_ERROR_NOT_AVAILABLE;
21623: 
20687:   nsRefPtr<nsGeolocationRequest> request = new nsGeolocationRequest(this, aCallback, aErrorCallback, aOptions);
20687:   if (!request)
20687:     return NS_ERROR_OUT_OF_MEMORY;
20687: 
21622:   if (NS_FAILED(request->Init()))
21622:     return NS_OK;
21622: 
15958:   prompt->Prompt(request);
15958: 
15958:   // need to hand back an index/reference.
20687:   mWatchingCallbacks.AppendElement(request);
20687:   *_retval = mWatchingCallbacks.Length() - 1;
15958:   return NS_OK;
15958: }
15958: 
15958: NS_IMETHODIMP
21624: nsGeolocation::ClearWatch(PRInt32 aWatchId)
15958: {
21624:   PRUint32 count = mWatchingCallbacks.Length();
21630:   if (aWatchId < 0 || count == 0 || aWatchId > count)
21624:     return NS_ERROR_FAILURE;
21624: 
20687:   mWatchingCallbacks[aWatchId]->MarkCleared();
15958:   return NS_OK;
15958: }
15958: 
15958: PRBool
16677: nsGeolocation::OwnerStillExists()
15958: {
30191:   nsCOMPtr<nsPIDOMWindow> window = do_QueryReferent(mOwner);
30191: 
30191:   if (!window)
15958:     return PR_FALSE;
15958: 
30191:   if (window)
15958:   {
15958:     PRBool closed = PR_FALSE;
30191:     window->GetClosed(&closed);
15958:     if (closed)
15958:       return PR_FALSE;
15958:   }
15958: 
30191:   nsPIDOMWindow* outer = window->GetOuterWindow();
30191:   if (!outer || outer->GetCurrentInnerWindow() != window)
15958:     return PR_FALSE;
15958: 
15958:   return PR_TRUE;
15958: }
