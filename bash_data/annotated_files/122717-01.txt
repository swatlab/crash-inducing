 72423: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 72423: 
 72423: #include "ScaledFontDWrite.h"
 72423: #include "PathD2D.h"
114779: #include "DrawTargetD2D.h"
101966: #include "Logging.h"
 72423: 
 72423: #include <vector>
 72423: 
 72423: namespace mozilla {
 72423: namespace gfx {
 72423: 
114779: struct ffReferenceKey
114779: {
114779:     uint8_t *mData;
114779:     uint32_t mSize;
114779: };
114779: 
114779: class DWriteFontFileLoader : public IDWriteFontFileLoader
114779: {
114779: public:
114779:   DWriteFontFileLoader()
114779:   {
114779:   }
114779: 
114779:   // IUnknown interface
114779:   IFACEMETHOD(QueryInterface)(IID const& iid, OUT void** ppObject)
114779:   {
114779:     if (iid == __uuidof(IDWriteFontFileLoader)) {
114779:       *ppObject = static_cast<IDWriteFontFileLoader*>(this);
114779:       return S_OK;
114779:     } else if (iid == __uuidof(IUnknown)) {
114779:       *ppObject = static_cast<IUnknown*>(this);
114779:       return S_OK;
114779:     } else {
114779:       return E_NOINTERFACE;
114779:     }
114779:   }
114779: 
114779:   IFACEMETHOD_(ULONG, AddRef)()
114779:   {
114779:     return 1;
114779:   }
114779: 
114779:   IFACEMETHOD_(ULONG, Release)()
114779:   {
114779:     return 1;
114779:   }
114779: 
114779:   // IDWriteFontFileLoader methods
114779:   /**
114779:     * Important! Note the key here -has- to be a pointer to an
114779:     * ffReferenceKey object.
114779:     */
114779:   virtual HRESULT STDMETHODCALLTYPE 
114779:     CreateStreamFromKey(void const* fontFileReferenceKey,
114779:                         UINT32 fontFileReferenceKeySize,
114779:                         OUT IDWriteFontFileStream** fontFileStream);
114779: 
114779:   /**
114779:     * Gets the singleton loader instance. Note that when using this font
114779:     * loader, the key must be a pointer to an FallibleTArray<uint8_t>. This
114779:     * array will be empty when the function returns.
114779:     */
114779:   static IDWriteFontFileLoader* Instance()
114779:   {
114779:     if (!mInstance) {
114779:       mInstance = new DWriteFontFileLoader();
114779:       DrawTargetD2D::GetDWriteFactory()->
114779:           RegisterFontFileLoader(mInstance);
114779:     }
114779:     return mInstance;
114779:   }
114779: 
114779: private:
114779:   static IDWriteFontFileLoader* mInstance;
114779: }; 
114779: 
114779: class DWriteFontFileStream : public IDWriteFontFileStream
114779: {
114779: public:
114779:   /**
114779:     * Used by the FontFileLoader to create a new font stream,
114779:     * this font stream is created from data in memory. The memory
114779:     * passed may be released after object creation, it will be
114779:     * copied internally.
114779:     *
114779:     * @param aData Font data
114779:     */
114779:   DWriteFontFileStream(uint8_t *aData, uint32_t aSize);
114779:   ~DWriteFontFileStream();
114779: 
114779:   // IUnknown interface
114779:   IFACEMETHOD(QueryInterface)(IID const& iid, OUT void** ppObject)
114779:   {
114779:     if (iid == __uuidof(IDWriteFontFileStream)) {
114779:       *ppObject = static_cast<IDWriteFontFileStream*>(this);
114779:       return S_OK;
114779:     } else if (iid == __uuidof(IUnknown)) {
114779:       *ppObject = static_cast<IUnknown*>(this);
114779:       return S_OK;
114779:     } else {
114779:       return E_NOINTERFACE;
114779:     }
114779:   }
114779: 
114779:   IFACEMETHOD_(ULONG, AddRef)()
114779:   {
114779:     ++mRefCnt;
114779:     return mRefCnt;
114779:   }
114779: 
114779:   IFACEMETHOD_(ULONG, Release)()
114779:   {
114779:     --mRefCnt;
114779:     if (mRefCnt == 0) {
114779:       delete this;
114779:       return 0;
114779:     }
114779:     return mRefCnt;
114779:   }
114779: 
114779:   // IDWriteFontFileStream methods
114779:   virtual HRESULT STDMETHODCALLTYPE ReadFileFragment(void const** fragmentStart,
114779:                                                      UINT64 fileOffset,
114779:                                                      UINT64 fragmentSize,
114779:                                                      OUT void** fragmentContext);
114779: 
114779:   virtual void STDMETHODCALLTYPE ReleaseFileFragment(void* fragmentContext);
114779: 
114779:   virtual HRESULT STDMETHODCALLTYPE GetFileSize(OUT UINT64* fileSize);
114779: 
114779:   virtual HRESULT STDMETHODCALLTYPE GetLastWriteTime(OUT UINT64* lastWriteTime);
114779: 
114779: private:
114779:   std::vector<uint8_t> mData;
114779:   uint32_t mRefCnt;
114779: };
114779: 
122408: static BYTE
122408: GetSystemTextQuality()
122408: {
122408:   BOOL font_smoothing;
122408:   UINT smoothing_type;
122408: 
122408:   if (!SystemParametersInfo(SPI_GETFONTSMOOTHING, 0, &font_smoothing, 0)) {
122408:     return DEFAULT_QUALITY;
122408:   }
122408: 
122408:   if (font_smoothing) {
122408:       if (!SystemParametersInfo(SPI_GETFONTSMOOTHINGTYPE,
122408:                                 0, &smoothing_type, 0)) {
122408:         return DEFAULT_QUALITY;
122408:       }
122408: 
122408:       if (smoothing_type == FE_FONTSMOOTHINGCLEARTYPE) {
122408:         return CLEARTYPE_QUALITY;
122408:       }
122408: 
122408:       return ANTIALIASED_QUALITY;
122408:   }
122408: 
122408:   return DEFAULT_QUALITY;
122408: }
122408: 
122408: #define GASP_TAG 0x70736167
122408: #define GASP_DOGRAY 0x2
122408: 
122408: static inline unsigned short
122408: readShort(const char *aBuf)
122408: {
122408:   return (*aBuf << 8) | *(aBuf + 1);
122408: }
122408: 
122408: static bool
122408: DoGrayscale(IDWriteFontFace *aDWFace, unsigned int ppem)
122408: {
122408:   void *tableContext;
122408:   char *tableData;
122408:   UINT32 tableSize;
122408:   BOOL exists;
122408:   aDWFace->TryGetFontTable(GASP_TAG, (const void**)&tableData, &tableSize, &tableContext, &exists);
122408: 
122408:   if (exists) {
122408:     if (tableSize < 4) {
122408:       aDWFace->ReleaseFontTable(tableContext);
122408:       return true;
122408:     }
122408:     struct gaspRange {
122408:       unsigned short maxPPEM; // Stored big-endian
122408:       unsigned short behavior; // Stored big-endian
122408:     };
122408:     unsigned short numRanges = readShort(tableData + 2);
122408:     if (tableSize < (UINT)4 + numRanges * 4) {
122408:       aDWFace->ReleaseFontTable(tableContext);
122408:       return true;
122408:     }
122408:     gaspRange *ranges = (gaspRange *)(tableData + 4);
122408:     for (int i = 0; i < numRanges; i++) {
122408:       if (readShort((char*)&ranges[i].maxPPEM) > ppem) {
122408:         if (!(readShort((char*)&ranges[i].behavior) & GASP_DOGRAY)) {
122408:           aDWFace->ReleaseFontTable(tableContext);
122408:           return false;
122408:         }
122408:         break;
122408:       }
122408:     }
122408:     aDWFace->ReleaseFontTable(tableContext);
122408:   }
122408:   return true;
122408: }
122408: 
114779: IDWriteFontFileLoader* DWriteFontFileLoader::mInstance = NULL;
114779: 
114779: HRESULT STDMETHODCALLTYPE
114779: DWriteFontFileLoader::CreateStreamFromKey(const void *fontFileReferenceKey, 
114779:                                           UINT32 fontFileReferenceKeySize, 
114779:                                           IDWriteFontFileStream **fontFileStream)
114779: {
114779:   if (!fontFileReferenceKey || !fontFileStream) {
114779:     return E_POINTER;
114779:   }
114779: 
114779:   const ffReferenceKey *key = static_cast<const ffReferenceKey*>(fontFileReferenceKey);
114779:   *fontFileStream = 
114779:     new DWriteFontFileStream(key->mData, key->mSize);
114779: 
114779:   if (!*fontFileStream) {
114779:     return E_OUTOFMEMORY;
114779:   }
114779:   (*fontFileStream)->AddRef();
114779:   return S_OK;
114779: }
114779: 
114779: DWriteFontFileStream::DWriteFontFileStream(uint8_t *aData, uint32_t aSize)
114779:   : mRefCnt(0)
114779: {
114779:   mData.resize(aSize);
114779:   memcpy(&mData.front(), aData, aSize);
114779: }
114779: 
114779: DWriteFontFileStream::~DWriteFontFileStream()
114779: {
114779: }
114779: 
114779: HRESULT STDMETHODCALLTYPE
114779: DWriteFontFileStream::GetFileSize(UINT64 *fileSize)
114779: {
114779:   *fileSize = mData.size();
114779:   return S_OK;
114779: }
114779: 
114779: HRESULT STDMETHODCALLTYPE
114779: DWriteFontFileStream::GetLastWriteTime(UINT64 *lastWriteTime)
114779: {
114779:   return E_NOTIMPL;
114779: }
114779: 
114779: HRESULT STDMETHODCALLTYPE
114779: DWriteFontFileStream::ReadFileFragment(const void **fragmentStart,
114779:                                        UINT64 fileOffset,
114779:                                        UINT64 fragmentSize,
114779:                                        void **fragmentContext)
114779: {
114779:   // We are required to do bounds checking.
114779:   if (fileOffset + fragmentSize > (UINT64)mData.size()) {
114779:     return E_FAIL;
114779:   }
114779:   // We should be alive for the duration of this.
114779:   *fragmentStart = &mData[fileOffset];
114779:   *fragmentContext = NULL;
114779:   return S_OK;
114779: }
114779: 
114779: void STDMETHODCALLTYPE
114779: DWriteFontFileStream::ReleaseFileFragment(void *fragmentContext)
114779: {
114779: }
114779: 
114779: ScaledFontDWrite::ScaledFontDWrite(uint8_t *aData, uint32_t aSize,
114779:                                    uint32_t aIndex, Float aGlyphSize)
114779:   : ScaledFontBase(aGlyphSize)
114779: {
114779:   IDWriteFactory *factory = DrawTargetD2D::GetDWriteFactory();
114779: 
114779:   ffReferenceKey key;
114779:   key.mData = aData;
114779:   key.mSize = aSize;
114779: 
114779:   RefPtr<IDWriteFontFile> fontFile;
114779:   if (FAILED(factory->CreateCustomFontFileReference(&key, sizeof(ffReferenceKey), DWriteFontFileLoader::Instance(), byRef(fontFile)))) {
114779:     gfxWarning() << "Failed to load font file from data!";
114779:     return;
114779:   }
114779: 
114779:   IDWriteFontFile *ff = fontFile;
114779:   if (FAILED(factory->CreateFontFace(DWRITE_FONT_FACE_TYPE_TRUETYPE, 1, &ff, aIndex, DWRITE_FONT_SIMULATIONS_NONE, byRef(mFontFace)))) {
114779:     gfxWarning() << "Failed to create font face from font file data!";
114779:   }
114779: }
114779: 
 72423: TemporaryRef<Path>
 72423: ScaledFontDWrite::GetPathForGlyphs(const GlyphBuffer &aBuffer, const DrawTarget *aTarget)
 72423: {
 72423:   if (aTarget->GetType() != BACKEND_DIRECT2D) {
122717:     return ScaledFontBase::GetPathForGlyphs(aBuffer, aTarget);
 72423:   }
 72423: 
 72423:   RefPtr<PathBuilder> pathBuilder = aTarget->CreatePathBuilder();
 72423: 
 72423:   PathBuilderD2D *pathBuilderD2D =
 72423:     static_cast<PathBuilderD2D*>(pathBuilder.get());
 72423: 
 94392:   CopyGlyphsToSink(aBuffer, pathBuilderD2D->GetSink());
 94392: 
 94392:   return pathBuilder->Finish();
 94392: }
 94392: 
 94392: void
 94392: ScaledFontDWrite::CopyGlyphsToBuilder(const GlyphBuffer &aBuffer, PathBuilder *aBuilder)
 94392: {
 94392:   // XXX - Check path builder type!
 94392:   PathBuilderD2D *pathBuilderD2D =
 94392:     static_cast<PathBuilderD2D*>(aBuilder);
 94392: 
 94392:   CopyGlyphsToSink(aBuffer, pathBuilderD2D->GetSink());
 94392: }
 94392: 
 94392: void
 94392: ScaledFontDWrite::CopyGlyphsToSink(const GlyphBuffer &aBuffer, ID2D1GeometrySink *aSink)
 94392: {
 72423:   std::vector<UINT16> indices;
 72423:   std::vector<FLOAT> advances;
 72423:   std::vector<DWRITE_GLYPH_OFFSET> offsets;
 72423:   indices.resize(aBuffer.mNumGlyphs);
 72423:   advances.resize(aBuffer.mNumGlyphs);
 72423:   offsets.resize(aBuffer.mNumGlyphs);
 72423: 
 72423:   memset(&advances.front(), 0, sizeof(FLOAT) * aBuffer.mNumGlyphs);
 72423:   for (unsigned int i = 0; i < aBuffer.mNumGlyphs; i++) {
 72423:     indices[i] = aBuffer.mGlyphs[i].mIndex;
 72423:     offsets[i].advanceOffset = aBuffer.mGlyphs[i].mPosition.x;
 72423:     offsets[i].ascenderOffset = -aBuffer.mGlyphs[i].mPosition.y;
 72423:   }
 72423: 
 72423:   mFontFace->GetGlyphRunOutline(mSize, &indices.front(), &advances.front(),
 72423:                                 &offsets.front(), aBuffer.mNumGlyphs,
 94392:                                 FALSE, FALSE, aSink);
 72423: }
 72423: 
114779: bool
114779: ScaledFontDWrite::GetFontFileData(FontFileDataOutput aDataCallback, void *aBaton)
114779: {
114779:   UINT32 fileCount = 0;
114779:   mFontFace->GetFiles(&fileCount, nullptr);
114779: 
114779:   if (fileCount > 1) {
114779:     MOZ_ASSERT(false);
114779:     return false;
 72423:   }
114779: 
114779:   RefPtr<IDWriteFontFile> file;
114779:   mFontFace->GetFiles(&fileCount, byRef(file));
114779: 
114779:   const void *referenceKey;
114779:   UINT32 refKeySize;
114779:   // XXX - This can currently crash for webfonts, as when we get the reference
114779:   // key out of the file, that can be an invalid reference key for the loader
114779:   // we use it with. The fix to this is not obvious but it will probably 
114779:   // have to happen inside thebes.
114779:   file->GetReferenceKey(&referenceKey, &refKeySize);
114779: 
114779:   RefPtr<IDWriteFontFileLoader> loader;
114779:   file->GetLoader(byRef(loader));
114779:   
114779:   RefPtr<IDWriteFontFileStream> stream;
114779:   loader->CreateStreamFromKey(referenceKey, refKeySize, byRef(stream));
114779: 
114779:   UINT64 fileSize;
114779:   stream->GetFileSize(&fileSize);
114779: 
114779:   const void *fragmentStart;
114779:   void *context;
114779:   stream->ReadFileFragment(&fragmentStart, 0, fileSize, &context);
114779: 
114779:   aDataCallback((uint8_t*)fragmentStart, fileSize, mFontFace->GetIndex(), mSize, aBaton);
114779: 
114779:   stream->ReleaseFileFragment(context);
114779: 
114779:   return true;
 72423: }
114779: 
122408: AntialiasMode
122408: ScaledFontDWrite::GetDefaultAAMode()
122408: {
122408:   AntialiasMode defaultMode = AA_SUBPIXEL;
122408: 
122408:   switch (GetSystemTextQuality()) {
122408:   case CLEARTYPE_QUALITY:
122408:     defaultMode = AA_SUBPIXEL;
122408:     break;
122408:   case ANTIALIASED_QUALITY:
122408:     defaultMode = AA_GRAY;
122408:     break;
122408:   case DEFAULT_QUALITY:
122408:     defaultMode = AA_NONE;
122408:     break;
114779:   }
122408: 
122408:   if (defaultMode == AA_GRAY) {
122408:     if (!DoGrayscale(mFontFace, mSize)) {
122408:       defaultMode = AA_NONE;
114779:     }
122408:   }
122408:   return defaultMode;
122408: }
122408: 
122408: }
122408: }
