 97553: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #ifdef _MSC_VER
     1: #define _USE_MATH_DEFINES
     1: #endif
     1: #include <math.h>
     1: 
     1: #ifndef M_PI
     1: #define M_PI 3.14159265358979323846
     1: #endif
     1: 
     1: #include "cairo.h"
     1: 
     1: #include "gfxContext.h"
     1: 
     1: #include "gfxColor.h"
     1: #include "gfxMatrix.h"
     1: #include "gfxASurface.h"
     1: #include "gfxPattern.h"
  3787: #include "gfxPlatform.h"
 59771: #include "gfxTeeSurface.h"
 95736: #include "sampler.h"
     1: 
 86662: using namespace mozilla;
 86662: using namespace mozilla::gfx;
 86662: 
 86662: /* This class lives on the stack and allows gfxContext users to easily, and
 86662:  * performantly get a gfx::Pattern to use for drawing in their current context.
 86662:  */
 86662: class GeneralPattern
 86662: {
 86662: public:    
 86662:   GeneralPattern(gfxContext *aContext) : mContext(aContext), mPattern(NULL) {}
 86662:   ~GeneralPattern() { if (mPattern) { mPattern->~Pattern(); } }
 86662: 
 86662:   operator mozilla::gfx::Pattern&()
 86662:   {
 86662:     gfxContext::AzureState &state = mContext->CurrentState();
 86662: 
 86662:     if (state.pattern) {
 94391:       return *state.pattern->GetPattern(mContext->mDT, state.patternTransformChanged ? &state.patternTransform : nsnull);
 86662:     } else if (state.sourceSurface) {
 94391:       Matrix transform = state.surfTransform;
 94391: 
 94391:       if (state.patternTransformChanged) {
101753:         Matrix mat = state.patternTransform;
 94391:         mat.Invert();
 94391: 
101753:         transform = mat * mContext->mDT->GetTransform() * transform;
 94391:       }
 94391: 
 86662:       mPattern = new (mSurfacePattern.addr())
 94391:         SurfacePattern(state.sourceSurface, EXTEND_CLAMP, transform);
 86662:       return *mPattern;
 86662:     } else {
 86662:       mPattern = new (mColorPattern.addr())
 86662:         ColorPattern(state.color);
 86662:       return *mPattern;
 86662:     }
 86662:   }
 86662: 
 86662: private:
 86662:   union {
 86662:     mozilla::AlignedStorage2<mozilla::gfx::ColorPattern> mColorPattern;
 86662:     mozilla::AlignedStorage2<mozilla::gfx::SurfacePattern> mSurfacePattern;
 86662:   };
 86662: 
 86662:   gfxContext *mContext;
 86662:   Pattern *mPattern;
 86662: };
 86662: 
 86662: gfxContext::gfxContext(gfxASurface *surface)
 91673:   : mRefCairo(NULL)
 91673:   , mSurface(surface)
     1: {
 43774:   MOZ_COUNT_CTOR(gfxContext);
 43774: 
     1:   mCairo = cairo_create(surface->CairoSurface());
  8452:   mFlags = surface->GetDefaultContextFlags();
 73875:   if (mSurface->GetRotateForLandscape()) {
 73875:     // Rotate page 90 degrees to draw landscape page on portrait paper
 73875:     gfxIntSize size = mSurface->GetSize();
 73875:     Translate(gfxPoint(0, size.width));
 73875:     gfxMatrix matrix(0, -1,
 73875:                       1,  0,
 73875:                       0,  0);
 73875:     Multiply(matrix);
 73875:   }
     1: }
 86662: 
 86662: gfxContext::gfxContext(DrawTarget *aTarget)
 86662:   : mPathIsRect(false)
 86662:   , mTransformChanged(false)
 86662:   , mCairo(NULL)
 86662:   , mRefCairo(NULL)
 86662:   , mSurface(NULL)
 86662:   , mFlags(0)
 86662:   , mDT(aTarget)
 86662:   , mOriginalDT(aTarget)
 86662: {
 86662:   MOZ_COUNT_CTOR(gfxContext);
 86662: 
 86662:   mStateStack.SetLength(1);
 86662:   CurrentState().drawTarget = mDT;
 86662:   mDT->SetTransform(Matrix());
 86662: }
 86662: 
     1: gfxContext::~gfxContext()
     1: {
 86662:   if (mCairo) {
     1:     cairo_destroy(mCairo);
 86662:   }
 86662:   if (mRefCairo) {
 86662:     cairo_destroy(mRefCairo);
 86662:   }
 86662:   if (mDT) {
 86662:     for (int i = mStateStack.Length() - 1; i >= 0; i--) {
 86662:       for (unsigned int c = 0; c < mStateStack[i].pushedClips.Length(); c++) {
 86662:         mDT->PopClip();
 86662:       }
 43774: 
 86662:       if (mStateStack[i].clipWasReset) {
 86662:         break;
 86662:       }
 86662:     }
 86662:     mDT->Flush();
 86662:   }
 43774:   MOZ_COUNT_DTOR(gfxContext);
     1: }
     1: 
     1: gfxASurface *
     1: gfxContext::OriginalSurface()
     1: {
     1:     return mSurface;
     1: }
     1: 
     1: already_AddRefed<gfxASurface>
     1: gfxContext::CurrentSurface(gfxFloat *dx, gfxFloat *dy)
     1: {
 86662:   if (mCairo) {
     1:     cairo_surface_t *s = cairo_get_group_target(mCairo);
     1:     if (s == mSurface->CairoSurface()) {
     1:         if (dx && dy)
     1:             cairo_surface_get_device_offset(s, dx, dy);
     1:         gfxASurface *ret = mSurface;
     1:         NS_ADDREF(ret);
     1:         return ret;
     1:     }
     1: 
     1:     if (dx && dy)
     1:         cairo_surface_get_device_offset(s, dx, dy);
     1:     return gfxASurface::Wrap(s);
 86662:   } else {
 86662:     if (dx && dy) {
 86662:       *dx = *dy = 0;
 86662:     }
 86662:     // An Azure context doesn't have a surface backing it.
 86662:     return NULL;
 86662:   }
 86662: }
 86662: 
 86662: cairo_t *
 86662: gfxContext::GetCairo()
 86662: {
 86662:   if (mCairo) {
 86662:     return mCairo;
 86662:   }
 86662: 
 86662:   if (mRefCairo) {
 86662:     // Set transform!
 86662:     return mRefCairo;
 86662:   }
 86662: 
 86662:   mRefCairo = cairo_create(gfxPlatform::GetPlatform()->ScreenReferenceSurface()->CairoSurface()); 
 86662: 
 86662:   return mRefCairo;
     1: }
     1: 
     1: void
     1: gfxContext::Save()
     1: {
 86662:   if (mCairo) {
     1:     cairo_save(mCairo);
 86662:   } else {
 86662:     CurrentState().transform = mDT->GetTransform();
 86662:     mStateStack.AppendElement(AzureState(CurrentState()));
 86662:     CurrentState().clipWasReset = false;
 86662:     CurrentState().pushedClips.Clear();
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::Restore()
     1: {
 86662:   if (mCairo) {
     1:     cairo_restore(mCairo);
 86662:   } else {
 86662:     for (unsigned int c = 0; c < CurrentState().pushedClips.Length(); c++) {
 86662:       mDT->PopClip();
 86662:     }
 86662: 
 86662:     if (CurrentState().clipWasReset &&
 86662:         CurrentState().drawTarget == mStateStack[mStateStack.Length() - 2].drawTarget) {
 86662:       PushClipsToDT(mDT);
 86662:     }
 86662: 
 86662:     mStateStack.RemoveElementAt(mStateStack.Length() - 1);
 86662: 
 86662:     if (mPathBuilder || mPath || mPathIsRect) {
 99078:       // Support here isn't fully correct if the path is continued -after-
 99078:       // the restore. We don't currently have users that do this and we should
 99078:       // make sure there will not be any. Sadly we can't assert this easily.
 86662:       mTransformChanged = true;
 86662:       mPathTransform = mDT->GetTransform();
 86662:     }
 86662: 
 86662:     mDT = CurrentState().drawTarget;
 86662:     mDT->SetTransform(CurrentState().transform);
 86662:   }
     1: }
     1: 
     1: // drawing
     1: void
     1: gfxContext::NewPath()
     1: {
 86662:   if (mCairo) {
     1:     cairo_new_path(mCairo);
 86662:   } else {
 86662:     mPath = NULL;
 86662:     mPathBuilder = NULL;
 86662:     mPathIsRect = false;
 86662:     mTransformChanged = false;
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::ClosePath()
     1: {
 86662:   if (mCairo) {
     1:     cairo_close_path(mCairo);
 86662:   } else {
 86662:     EnsurePathBuilder();
 86662:     mPathBuilder->Close();
 86662:   }
     1: }
     1: 
 19733: already_AddRefed<gfxPath> gfxContext::CopyPath() const
 16042: {
 86662:   if (mCairo) {
 16042:     nsRefPtr<gfxPath> path = new gfxPath(cairo_copy_path(mCairo));
 16042:     return path.forget();
 86662:   } else {
 86662:     // XXX - This is not yet supported for Azure.
 86662:     return NULL;
 86662:   }
 16042: }
 16042: 
 16042: void gfxContext::AppendPath(gfxPath* path)
 16042: {
 86662:   if (mCairo) {
 16042:     if (path->mPath->status == CAIRO_STATUS_SUCCESS && path->mPath->num_data != 0)
 16042:         cairo_append_path(mCairo, path->mPath);
 86662:   } else {
 86662:     // XXX - This is not yet supported for Azure.
 86662:     return;
 86662:   }
 16042: }
 16042: 
     1: gfxPoint
 86662: gfxContext::CurrentPoint()
     1: {
 86662:   if (mCairo) {
     1:     double x, y;
     1:     cairo_get_current_point(mCairo, &x, &y);
     1:     return gfxPoint(x, y);
 86662:   } else {
 86662:     EnsurePathBuilder();
 86662:     return ThebesPoint(mPathBuilder->CurrentPoint());
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::Stroke()
     1: {
 86662:   if (mCairo) {
     1:     cairo_stroke_preserve(mCairo);
 86662:   } else {
 86662:     AzureState &state = CurrentState();
 86662:     if (mPathIsRect) {
 86662:       mDT->StrokeRect(mRect, GeneralPattern(this),
 86662:                       state.strokeOptions,
 86662:                       DrawOptions(1.0f, GetOp(), state.aaMode));
 86662:     } else {
 86662:       EnsurePath();
 86662: 
 86662:       mDT->Stroke(mPath, GeneralPattern(this), state.strokeOptions,
 86662:                   DrawOptions(1.0f, GetOp(), state.aaMode));
 86662:     }
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::Fill()
     1: {
 95736:   SAMPLE_LABEL("gfxContext", "Fill");
 86662:   if (mCairo) {
     1:     cairo_fill_preserve(mCairo);
 86662:   } else {
 86662:     FillAzure(1.0f);
 86662:   }
     1: }
     1: 
     1: void
 61311: gfxContext::FillWithOpacity(gfxFloat aOpacity)
 61311: {
 86662:   if (mCairo) {
 61311:     // This method exists in the hope that one day cairo gets a direct
 61311:     // API for this, and then we would change this method to use that
 61311:     // API instead.
 61311:     if (aOpacity != 1.0) {
 61311:       gfxContextAutoSaveRestore saveRestore(this);
 61311:       Clip();
 61311:       Paint(aOpacity);
 61311:     } else {
 61311:       Fill();
 61311:     }
 86662:   } else {
 86662:     FillAzure(Float(aOpacity));
 86662:   }
 61311: }
 61311: 
 61311: void
     1: gfxContext::MoveTo(const gfxPoint& pt)
     1: {
 86662:   if (mCairo) {
     1:     cairo_move_to(mCairo, pt.x, pt.y);
 86662:   } else {
 86662:     EnsurePathBuilder();
 86662:     mPathBuilder->MoveTo(ToPoint(pt));
 86662:   }
     1: }
     1: 
     1: void
   947: gfxContext::NewSubPath()
   947: {
 86662:   if (mCairo) {
   947:     cairo_new_sub_path(mCairo);
 86662:   } else {
 86662:     // XXX - This has no users, we should kill it, it should be equivelant to a
 86662:     // MoveTo to the path's current point.
 86662:   }
   947: }
   947: 
   947: void
     1: gfxContext::LineTo(const gfxPoint& pt)
     1: {
 86662:   if (mCairo) {
     1:     cairo_line_to(mCairo, pt.x, pt.y);
 86662:   } else {
 86662:     EnsurePathBuilder();
 86662:     mPathBuilder->LineTo(ToPoint(pt));
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::CurveTo(const gfxPoint& pt1, const gfxPoint& pt2, const gfxPoint& pt3)
     1: {
 86662:   if (mCairo) {
     1:     cairo_curve_to(mCairo, pt1.x, pt1.y, pt2.x, pt2.y, pt3.x, pt3.y);
 86662:   } else {
 86662:     EnsurePathBuilder();
 86662:     mPathBuilder->BezierTo(ToPoint(pt1), ToPoint(pt2), ToPoint(pt3));
 86662:   }
     1: }
     1: 
     1: void
 16149: gfxContext::QuadraticCurveTo(const gfxPoint& pt1, const gfxPoint& pt2)
 16149: {
 86662:   if (mCairo) {
 16149:     double cx, cy;
 16149:     cairo_get_current_point(mCairo, &cx, &cy);
 16149:     cairo_curve_to(mCairo,
 16149:                    (cx + pt1.x * 2.0) / 3.0,
 16149:                    (cy + pt1.y * 2.0) / 3.0,
 16149:                    (pt1.x * 2.0 + pt2.x) / 3.0,
 16149:                    (pt1.y * 2.0 + pt2.y) / 3.0,
 16149:                    pt2.x,
 16149:                    pt2.y);
 86662:   } else {
 86662:     EnsurePathBuilder();
 86662:     mPathBuilder->QuadraticBezierTo(ToPoint(pt1), ToPoint(pt2));
 86662:   }
 16149: }
 16149: 
 16149: void
     1: gfxContext::Arc(const gfxPoint& center, gfxFloat radius,
     1:                 gfxFloat angle1, gfxFloat angle2)
     1: {
 86662:   if (mCairo) {
     1:     cairo_arc(mCairo, center.x, center.y, radius, angle1, angle2);
 86662:   } else {
 86662:     EnsurePathBuilder();
 86662:     mPathBuilder->Arc(ToPoint(center), Float(radius), Float(angle1), Float(angle2));
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::NegativeArc(const gfxPoint& center, gfxFloat radius,
     1:                         gfxFloat angle1, gfxFloat angle2)
     1: {
 86662:   if (mCairo) {
     1:     cairo_arc_negative(mCairo, center.x, center.y, radius, angle1, angle2);
 86662:   } else {
 86662:     EnsurePathBuilder();
 86662:     mPathBuilder->Arc(ToPoint(center), Float(radius), Float(angle2), Float(angle1));
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::Line(const gfxPoint& start, const gfxPoint& end)
     1: {
 86662:   if (mCairo) {
     1:     MoveTo(start);
     1:     LineTo(end);
 86662:   } else {
 86662:     EnsurePathBuilder();
 86662:     mPathBuilder->MoveTo(ToPoint(start));
 86662:     mPathBuilder->LineTo(ToPoint(end));
 86662:   }
     1: }
     1: 
     1: // XXX snapToPixels is only valid when snapping for filled
     1: // rectangles and for even-width stroked rectangles.
     1: // For odd-width stroked rectangles, we need to offset x/y by
     1: // 0.5...
     1: void
 79445: gfxContext::Rectangle(const gfxRect& rect, bool snapToPixels)
     1: {
 86662:   if (mCairo) {
     1:     if (snapToPixels) {
     1:         gfxRect snappedRect(rect);
     1: 
 80486:         if (UserToDevicePixelSnapped(snappedRect, true))
 20226:         {
     1:             cairo_matrix_t mat;
     1:             cairo_get_matrix(mCairo, &mat);
     1:             cairo_identity_matrix(mCairo);
     1:             Rectangle(snappedRect);
     1:             cairo_set_matrix(mCairo, &mat);
     1: 
     1:             return;
     1:         }
     1:     }
     1: 
 68632:     cairo_rectangle(mCairo, rect.X(), rect.Y(), rect.Width(), rect.Height());
 86662:   } else {
 86662:     Rect rec = ToRect(rect);
 86662: 
 86662:     if (snapToPixels) {
 86662:       gfxRect newRect(rect);
 90091:       if (UserToDevicePixelSnapped(newRect, true)) {
 86662:         gfxMatrix mat = ThebesMatrix(mDT->GetTransform());
 86662:         mat.Invert();
 86662: 
 86662:         // We need the user space rect.
 86662:         rec = ToRect(mat.TransformBounds(newRect));
 86662:       }
 86662:     }
 86662: 
 86662:     if (!mPathBuilder && !mPathIsRect) {
 86662:       mPathIsRect = true;
 86662:       mRect = rec;
 86662:       return;
 86662:     } else if (!mPathBuilder) {
 86662:       EnsurePathBuilder();
 86662:     }
 86662:     
 86662:     mPathBuilder->MoveTo(rec.TopLeft());
 86662:     mPathBuilder->LineTo(rec.TopRight());
 86662:     mPathBuilder->LineTo(rec.BottomRight());
 86662:     mPathBuilder->LineTo(rec.BottomLeft());
 86662:     mPathBuilder->Close();
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::Ellipse(const gfxPoint& center, const gfxSize& dimensions)
     1: {
 16149:   gfxSize halfDim = dimensions / 2.0;
 68631:   gfxRect r(center - gfxPoint(halfDim.width, halfDim.height), dimensions);
 16149:   gfxCornerSizes c(halfDim, halfDim, halfDim, halfDim);
     1: 
 16149:   RoundedRectangle (r, c);
     1: }
     1: 
     1: void
     1: gfxContext::Polygon(const gfxPoint *points, PRUint32 numPoints)
     1: {
 86662:   if (mCairo) {
     1:     if (numPoints == 0)
     1:         return;
     1: 
     1:     cairo_move_to(mCairo, points[0].x, points[0].y);
     1:     for (PRUint32 i = 1; i < numPoints; ++i) {
     1:         cairo_line_to(mCairo, points[i].x, points[i].y);
     1:     }
 86662:   } else {
 86662:     if (numPoints == 0) {
 86662:       return;
 86662:     }
 86662: 
 86662:     EnsurePathBuilder();
 86662: 
 86662:     mPathBuilder->MoveTo(ToPoint(points[0]));
 86662:     for (PRUint32 i = 1; i < numPoints; i++) {
 86662:       mPathBuilder->LineTo(ToPoint(points[i]));
 86662:     }
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::DrawSurface(gfxASurface *surface, const gfxSize& size)
     1: {
 86662:   if (mCairo) {
     1:     cairo_save(mCairo);
     1:     cairo_set_source_surface(mCairo, surface->CairoSurface(), 0, 0);
     1:     cairo_new_path(mCairo);
     1: 
     1:     // pixel-snap this
 80486:     Rectangle(gfxRect(gfxPoint(0.0, 0.0), size), true);
     1: 
     1:     cairo_fill(mCairo);
     1:     cairo_restore(mCairo);
 86662:   } else {
 99077:     // Lifetime needs to be limited here since we may wrap surface's data.
 86662:     RefPtr<SourceSurface> surf =
 86662:       gfxPlatform::GetPlatform()->GetSourceSurfaceForSurface(mDT, surface);
 86662: 
 86662:     Rect rect(0, 0, Float(size.width), Float(size.height));
 86662:     rect.Intersect(Rect(0, 0, Float(surf->GetSize().width), Float(surf->GetSize().height)));
 86662: 
 86662:     // XXX - Should fix pixel snapping.
 86662:     mDT->DrawSurface(surf, rect, rect);
 86662:   }
     1: }
     1: 
     1: // transform stuff
     1: void
     1: gfxContext::Translate(const gfxPoint& pt)
     1: {
 86662:   if (mCairo) {
     1:     cairo_translate(mCairo, pt.x, pt.y);
 86662:   } else {
 99078:     Matrix newMatrix = mDT->GetTransform();
 86662: 
 99078:     ChangeTransform(newMatrix.Translate(Float(pt.x), Float(pt.y)));
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::Scale(gfxFloat x, gfxFloat y)
     1: {
 86662:   if (mCairo) {
     1:     cairo_scale(mCairo, x, y);
 86662:   } else {
 99078:     Matrix newMatrix = mDT->GetTransform();
 86662: 
 99078:     ChangeTransform(newMatrix.Scale(Float(x), Float(y)));
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::Rotate(gfxFloat angle)
     1: {
 86662:   if (mCairo) {
     1:     cairo_rotate(mCairo, angle);
 86662:   } else {
 86662:     Matrix rotation = Matrix::Rotation(Float(angle));
 99078:     ChangeTransform(rotation * mDT->GetTransform());
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::Multiply(const gfxMatrix& matrix)
     1: {
 86662:   if (mCairo) {
     1:     const cairo_matrix_t& mat = reinterpret_cast<const cairo_matrix_t&>(matrix);
     1:     cairo_transform(mCairo, &mat);
 86662:   } else {
 99078:     ChangeTransform(ToMatrix(matrix) * mDT->GetTransform());
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::SetMatrix(const gfxMatrix& matrix)
     1: {
 86662:   if (mCairo) {
     1:     const cairo_matrix_t& mat = reinterpret_cast<const cairo_matrix_t&>(matrix);
     1:     cairo_set_matrix(mCairo, &mat);
 86662:   } else {
 99078:     ChangeTransform(ToMatrix(matrix));
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::IdentityMatrix()
     1: {
 86662:   if (mCairo) {
     1:     cairo_identity_matrix(mCairo);
 86662:   } else {
 99078:     ChangeTransform(Matrix());
 86662:   }
     1: }
     1: 
     1: gfxMatrix
     1: gfxContext::CurrentMatrix() const
     1: {
 86662:   if (mCairo) {
     1:     cairo_matrix_t mat;
     1:     cairo_get_matrix(mCairo, &mat);
     1:     return gfxMatrix(*reinterpret_cast<gfxMatrix*>(&mat));
 86662:   } else {
 86662:     return ThebesMatrix(mDT->GetTransform());
 86662:   }
     1: }
     1: 
 47758: void
 47758: gfxContext::NudgeCurrentMatrixToIntegers()
 47758: {
 86662:   if (mCairo) {
 47758:     cairo_matrix_t mat;
 47758:     cairo_get_matrix(mCairo, &mat);
 54550:     gfxMatrix(*reinterpret_cast<gfxMatrix*>(&mat)).NudgeToIntegers();
 47758:     cairo_set_matrix(mCairo, &mat);
 86662:   } else {
 86662:     gfxMatrix matrix = ThebesMatrix(mTransform);
 86662:     matrix.NudgeToIntegers();
 86662:     mTransform = ToMatrix(matrix);
 86662:   }
 47758: }
 47758: 
     1: gfxPoint
     1: gfxContext::DeviceToUser(const gfxPoint& point) const
     1: {
 86662:   if (mCairo) {
     1:     gfxPoint ret = point;
     1:     cairo_device_to_user(mCairo, &ret.x, &ret.y);
     1:     return ret;
 86662:   } else {
 86662:     Matrix matrix = mDT->GetTransform();
 86662: 
 86662:     matrix.Invert();
 86662: 
 86662:     return ThebesPoint(matrix * ToPoint(point));
 86662:   }
     1: }
     1: 
     1: gfxSize
     1: gfxContext::DeviceToUser(const gfxSize& size) const
     1: {
 86662:   if (mCairo) {
     1:     gfxSize ret = size;
     1:     cairo_device_to_user_distance(mCairo, &ret.width, &ret.height);
     1:     return ret;
 86662:   } else {
 86662:     Matrix matrix = mDT->GetTransform();
 86662: 
 86662:     matrix.Invert();
 86662: 
 86662:     return ThebesSize(matrix * ToSize(size));
 86662:   }
     1: }
     1: 
     1: gfxRect
     1: gfxContext::DeviceToUser(const gfxRect& rect) const
     1: {
 86662:   if (mCairo) {
     1:     gfxRect ret = rect;
 68634:     cairo_device_to_user(mCairo, &ret.x, &ret.y);
 68634:     cairo_device_to_user_distance(mCairo, &ret.width, &ret.height);
     1:     return ret;
 86662:   } else {
 86662:     Matrix matrix = mDT->GetTransform();
 86662: 
 86662:     matrix.Invert();
 86662: 
 86662:     return ThebesRect(matrix.TransformBounds(ToRect(rect)));
 86662:   }
     1: }
     1: 
     1: gfxPoint
     1: gfxContext::UserToDevice(const gfxPoint& point) const
     1: {
 86662:   if (mCairo) {
     1:     gfxPoint ret = point;
     1:     cairo_user_to_device(mCairo, &ret.x, &ret.y);
     1:     return ret;
 86662:   } else {
 86662:     return ThebesPoint(mDT->GetTransform() * ToPoint(point));
 86662:   }
     1: }
     1: 
     1: gfxSize
     1: gfxContext::UserToDevice(const gfxSize& size) const
     1: {
 86662:   if (mCairo) {
     1:     gfxSize ret = size;
     1:     cairo_user_to_device_distance(mCairo, &ret.width, &ret.height);
     1:     return ret;
 86662:   } else {
 86662:     const Matrix &matrix = mDT->GetTransform();
 86662: 
 86662:     gfxSize newSize = size;
 86662:     newSize.width = newSize.width * matrix._11 + newSize.height * matrix._12;
 86662:     newSize.height = newSize.width * matrix._21 + newSize.height * matrix._22;
 86662:     return newSize;
 86662:   }
     1: }
     1: 
     1: gfxRect
     1: gfxContext::UserToDevice(const gfxRect& rect) const
     1: {
 86662:   if (mCairo) {
 68632:     double xmin = rect.X(), ymin = rect.Y(), xmax = rect.XMost(), ymax = rect.YMost();
     1: 
     1:     double x[3], y[3];
     1:     x[0] = xmin;  y[0] = ymax;
     1:     x[1] = xmax;  y[1] = ymax;
     1:     x[2] = xmax;  y[2] = ymin;
     1: 
     1:     cairo_user_to_device(mCairo, &xmin, &ymin);
     1:     xmax = xmin;
     1:     ymax = ymin;
     1:     for (int i = 0; i < 3; i++) {
     1:         cairo_user_to_device(mCairo, &x[i], &y[i]);
 71173:         xmin = NS_MIN(xmin, x[i]);
 71173:         xmax = NS_MAX(xmax, x[i]);
 71173:         ymin = NS_MIN(ymin, y[i]);
 71173:         ymax = NS_MAX(ymax, y[i]);
     1:     }
     1: 
     1:     return gfxRect(xmin, ymin, xmax - xmin, ymax - ymin);
 86662:   } else {
 86662:     const Matrix &matrix = mDT->GetTransform();
 86662:     return ThebesRect(matrix.TransformBounds(ToRect(rect)));
 86662:   }
     1: }
     1: 
 79445: bool
 79445: gfxContext::UserToDevicePixelSnapped(gfxRect& rect, bool ignoreScale) const
     1: {
  9965:   if (GetFlags() & FLAG_DISABLE_SNAPPING)
 80486:       return false;
  9965: 
  8349:   // if we're not at 1.0 scale, don't snap, unless we're
  8349:   // ignoring the scale.  If we're not -just- a scale,
  8349:   // never snap.
 56135:   const gfxFloat epsilon = 0.0000001;
 56135: #define WITHIN_E(a,b) (fabs((a)-(b)) < epsilon)
 86662:   if (mCairo) {
     1:     cairo_matrix_t mat;
     1:     cairo_get_matrix(mCairo, &mat);
 46325:     if (!ignoreScale &&
 56135:         (!WITHIN_E(mat.xx,1.0) || !WITHIN_E(mat.yy,1.0) ||
 56135:           !WITHIN_E(mat.xy,0.0) || !WITHIN_E(mat.yx,0.0)))
 80486:         return false;
 86662:   } else {
 86662:     Matrix mat = mDT->GetTransform();
 86662:     if (!ignoreScale &&
 86662:         (!WITHIN_E(mat._11,1.0) || !WITHIN_E(mat._22,1.0) ||
 86662:           !WITHIN_E(mat._12,0.0) || !WITHIN_E(mat._21,0.0)))
 86662:         return false;
 86662:   }
 56135: #undef WITHIN_E
     1: 
 68631:   gfxPoint p1 = UserToDevice(rect.TopLeft());
 68631:   gfxPoint p2 = UserToDevice(rect.TopRight());
 68631:   gfxPoint p3 = UserToDevice(rect.BottomRight());
     1: 
 46325:   // Check that the rectangle is axis-aligned. For an axis-aligned rectangle,
 46325:   // two opposite corners define the entire rectangle. So check if
 46325:   // the axis-aligned rectangle with opposite corners p1 and p3
 46325:   // define an axis-aligned rectangle whose other corners are p2 and p4.
 46325:   // We actually only need to check one of p2 and p4, since an affine
 46325:   // transform maps parallelograms to parallelograms.
 46325:   if (p2 == gfxPoint(p1.x, p3.y) || p2 == gfxPoint(p3.x, p1.y)) {
 46325:       p1.Round();
 46325:       p3.Round();
     1: 
 68632:       rect.MoveTo(gfxPoint(NS_MIN(p1.x, p3.x), NS_MIN(p1.y, p3.y)));
 68632:       rect.SizeTo(gfxSize(NS_MAX(p1.x, p3.x) - rect.X(),
 68632:                           NS_MAX(p1.y, p3.y) - rect.Y()));
 80486:       return true;
 46325:   }
 46325: 
 80486:   return false;
     1: }
     1: 
 79445: bool
 79445: gfxContext::UserToDevicePixelSnapped(gfxPoint& pt, bool ignoreScale) const
 21323: {
 21323:   if (GetFlags() & FLAG_DISABLE_SNAPPING)
 80486:       return false;
 21323: 
 21323:   // if we're not at 1.0 scale, don't snap, unless we're
 21323:   // ignoring the scale.  If we're not -just- a scale,
 21323:   // never snap.
 86662:   const gfxFloat epsilon = 0.0000001;
 86662: #define WITHIN_E(a,b) (fabs((a)-(b)) < epsilon)
 86662:   if (mCairo) {
 21323:     cairo_matrix_t mat;
 21323:     cairo_get_matrix(mCairo, &mat);
 86662:     if (!ignoreScale &&
 86662:         (!WITHIN_E(mat.xx,1.0) || !WITHIN_E(mat.yy,1.0) ||
 86662:           !WITHIN_E(mat.xy,0.0) || !WITHIN_E(mat.yx,0.0)))
 80486:         return false;
 86662:   } else {
 86662:     Matrix mat = mDT->GetTransform();
 86662:     if (!ignoreScale &&
 86662:         (!WITHIN_E(mat._11,1.0) || !WITHIN_E(mat._22,1.0) ||
 86662:           !WITHIN_E(mat._12,0.0) || !WITHIN_E(mat._21,0.0)))
 86662:         return false;
 86662:   }
 86662: #undef WITHIN_E
 21323: 
 21323:   pt = UserToDevice(pt);
 21323:   pt.Round();
 80486:   return true;
 21323: }
 21323: 
     1: void
     1: gfxContext::PixelSnappedRectangleAndSetPattern(const gfxRect& rect,
     1:                                                gfxPattern *pattern)
     1: {
     1:   gfxRect r(rect);
     1: 
     1:   // Bob attempts to pixel-snap the rectangle, and returns true if
     1:   // the snapping succeeds.  If it does, we need to set up an
     1:   // identity matrix, because the rectangle given back is in device
     1:   // coordinates.
     1:   //
     1:   // We then have to call a translate to dr.pos afterwards, to make
     1:   // sure the image lines up in the right place with our pixel
     1:   // snapped rectangle.
     1:   //
     1:   // If snapping wasn't successful, we just translate to where the
     1:   // pattern would normally start (in app coordinates) and do the
     1:   // same thing.
 86662:   Rectangle(r, true);
     1:   SetPattern(pattern);
     1: }
     1: 
     1: void
     1: gfxContext::SetAntialiasMode(AntialiasMode mode)
     1: {
 86662:   if (mCairo) {
     1:     if (mode == MODE_ALIASED) {
     1:         cairo_set_antialias(mCairo, CAIRO_ANTIALIAS_NONE);
     1:     } else if (mode == MODE_COVERAGE) {
     1:         cairo_set_antialias(mCairo, CAIRO_ANTIALIAS_DEFAULT);
     1:     }
 86662:   } else {
 86662:     if (mode == MODE_ALIASED) {
 86662:       CurrentState().aaMode = AA_NONE;
 86662:     } else if (mode == MODE_COVERAGE) {
 86662:       CurrentState().aaMode = AA_SUBPIXEL;
 86662:     }
 86662:   }
     1: }
     1: 
     1: gfxContext::AntialiasMode
     1: gfxContext::CurrentAntialiasMode() const
     1: {
 86662:   if (mCairo) {
     1:     cairo_antialias_t aa = cairo_get_antialias(mCairo);
     1:     if (aa == CAIRO_ANTIALIAS_NONE)
     1:         return MODE_ALIASED;
     1:     return MODE_COVERAGE;
 86662:   } else {
 86662:     if (CurrentState().aaMode == AA_NONE) {
 86662:       return MODE_ALIASED;
 86662:     }
 86662:     return MODE_COVERAGE;
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::SetDash(gfxLineType ltype)
     1: {
     1:   static double dash[] = {5.0, 5.0};
     1:   static double dot[] = {1.0, 1.0};
     1: 
     1:   switch (ltype) {
     1:       case gfxLineDashed:
     1:           SetDash(dash, 2, 0.0);
     1:           break;
     1:       case gfxLineDotted:
     1:           SetDash(dot, 2, 0.0);
     1:           break;
     1:       case gfxLineSolid:
     1:       default:
     1:           SetDash(nsnull, 0, 0.0);
     1:           break;
     1:   }
     1: }
     1: 
     1: void
     1: gfxContext::SetDash(gfxFloat *dashes, int ndash, gfxFloat offset)
     1: {
 86662:   if (mCairo) {
     1:     cairo_set_dash(mCairo, dashes, ndash, offset);
 86662:   } else {
 86662:     AzureState &state = CurrentState();
 86662: 
 86662:     state.dashPattern.SetLength(ndash);
 86662:     for (int i = 0; i < ndash; i++) {
 86662:       state.dashPattern[i] = Float(dashes[i]);
 86662:     }
 86662:     state.strokeOptions.mDashLength = ndash;
 86662:     state.strokeOptions.mDashOffset = Float(offset);
 86662:     state.strokeOptions.mDashPattern = ndash ? state.dashPattern.Elements() : NULL;
 86662:   }
     1: }
 72741: 
 72741: bool
 72741: gfxContext::CurrentDash(FallibleTArray<gfxFloat>& dashes, gfxFloat* offset) const
 72741: {
 86662:   if (mCairo) {
 72741:     int count = cairo_get_dash_count(mCairo);
 72741:     if (count <= 0 || !dashes.SetLength(count)) {
 72741:         return false;
 72741:     }
 72741:     cairo_get_dash(mCairo, dashes.Elements(), offset);
 72741:     return true;
 86662:   } else {
 86662:     const AzureState &state = CurrentState();
 86662:     int count = state.strokeOptions.mDashLength;
 86662: 
 86662:     if (count <= 0 || !dashes.SetLength(count)) {
 86662:       return false;
 86662:     }
 86662: 
 86662:     for (int i = 0; i < count; i++) {
 86662:       dashes[i] = state.dashPattern[i];
 86662:     }
 86662: 
 86662:     *offset = state.strokeOptions.mDashOffset;
 86662: 
 86662:     return true;
 86662:   }
 72741: }
 72741: 
 72741: gfxFloat
 72741: gfxContext::CurrentDashOffset() const
 72741: {
 86662:   if (mCairo) {
 72741:     if (cairo_get_dash_count(mCairo) <= 0) {
 72741:         return 0.0;
 72741:     }
 72741:     gfxFloat offset;
 72741:     cairo_get_dash(mCairo, NULL, &offset);
 72741:     return offset;
 86662:   } else {
 86662:     return CurrentState().strokeOptions.mDashOffset;
 86662:   }
 72741: }
     1: 
     1: void
     1: gfxContext::SetLineWidth(gfxFloat width)
     1: {
 86662:   if (mCairo) {
     1:     cairo_set_line_width(mCairo, width);
 86662:   } else {
 86662:     CurrentState().strokeOptions.mLineWidth = Float(width);
 86662:   }
     1: }
     1: 
     1: gfxFloat
     1: gfxContext::CurrentLineWidth() const
     1: {
 86662:   if (mCairo) {
     1:     return cairo_get_line_width(mCairo);
 86662:   } else {
 86662:     return CurrentState().strokeOptions.mLineWidth;
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::SetOperator(GraphicsOperator op)
     1: {
 86662:   if (mCairo) {
  8456:     if (mFlags & FLAG_SIMPLIFY_OPERATORS) {
  8452:         if (op != OPERATOR_SOURCE &&
  8452:             op != OPERATOR_CLEAR &&
  8452:             op != OPERATOR_OVER)
  8452:             op = OPERATOR_OVER;
  8452:     }
  8452: 
     1:     cairo_set_operator(mCairo, (cairo_operator_t)op);
 86662:   } else {
 86662:     if (op == OPERATOR_CLEAR) {
 86662:       CurrentState().opIsClear = true;
 86662:       return;
 86662:     }
 86662:     CurrentState().opIsClear = false;
 86662:     CurrentState().op = CompositionOpForOp(op);
 86662:   }
     1: }
     1: 
     1: gfxContext::GraphicsOperator
     1: gfxContext::CurrentOperator() const
     1: {
 86662:   if (mCairo) {
     1:     return (GraphicsOperator)cairo_get_operator(mCairo);
 86662:   } else {
 86662:     return ThebesOp(CurrentState().op);
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::SetLineCap(GraphicsLineCap cap)
     1: {
 86662:   if (mCairo) {
     1:     cairo_set_line_cap(mCairo, (cairo_line_cap_t)cap);
 86662:   } else {
 86662:     CurrentState().strokeOptions.mLineCap = ToCapStyle(cap);
 86662:   }
     1: }
     1: 
     1: gfxContext::GraphicsLineCap
     1: gfxContext::CurrentLineCap() const
     1: {
 86662:   if (mCairo) {
     1:     return (GraphicsLineCap)cairo_get_line_cap(mCairo);
 86662:   } else {
 86662:     return ThebesLineCap(CurrentState().strokeOptions.mLineCap);
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::SetLineJoin(GraphicsLineJoin join)
     1: {
 86662:   if (mCairo) {
     1:     cairo_set_line_join(mCairo, (cairo_line_join_t)join);
 86662:   } else {
 86662:     CurrentState().strokeOptions.mLineJoin = ToJoinStyle(join);
 86662:   }
     1: }
     1: 
     1: gfxContext::GraphicsLineJoin
     1: gfxContext::CurrentLineJoin() const
     1: {
 86662:   if (mCairo) {
     1:     return (GraphicsLineJoin)cairo_get_line_join(mCairo);
 86662:   } else {
 86662:     return ThebesLineJoin(CurrentState().strokeOptions.mLineJoin);
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::SetMiterLimit(gfxFloat limit)
     1: {
 86662:   if (mCairo) {
     1:     cairo_set_miter_limit(mCairo, limit);
 86662:   } else {
 86662:     CurrentState().strokeOptions.mMiterLimit = Float(limit);
 86662:   }
     1: }
     1: 
     1: gfxFloat
     1: gfxContext::CurrentMiterLimit() const
     1: {
 86662:   if (mCairo) {
     1:     return cairo_get_miter_limit(mCairo);
 86662:   } else {
 86662:     return CurrentState().strokeOptions.mMiterLimit;
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::SetFillRule(FillRule rule)
     1: {
 86662:   if (mCairo) {
     1:     cairo_set_fill_rule(mCairo, (cairo_fill_rule_t)rule);
 86662:   } else {
 86662:     CurrentState().fillRule = rule == FILL_RULE_WINDING ? FILL_WINDING : FILL_EVEN_ODD;
 86662:   }
     1: }
     1: 
     1: gfxContext::FillRule
     1: gfxContext::CurrentFillRule() const
     1: {
 86662:   if (mCairo) {
     1:     return (FillRule)cairo_get_fill_rule(mCairo);
 86662:   } else {
 86662:     return FILL_RULE_WINDING;
 86662:   }
     1: }
     1: 
     1: // clipping
     1: void
     1: gfxContext::Clip(const gfxRect& rect)
     1: {
 86662:   if (mCairo) {
     1:     cairo_new_path(mCairo);
 68632:     cairo_rectangle(mCairo, rect.X(), rect.Y(), rect.Width(), rect.Height());
     1:     cairo_clip(mCairo);
 86662:   } else {
 86662:     AzureState::PushedClip clip = { NULL, ToRect(rect), mDT->GetTransform() };
 86662:     CurrentState().pushedClips.AppendElement(clip);
 86662:     mDT->PushClipRect(ToRect(rect));
 86662:     NewPath();
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::Clip()
     1: {
 86662:   if (mCairo) {
     1:     cairo_clip_preserve(mCairo);
 86662:   } else {
 86662:     if (mPathIsRect && !mTransformChanged) {
 86662:       AzureState::PushedClip clip = { NULL, mRect, mDT->GetTransform() };
 86662:       CurrentState().pushedClips.AppendElement(clip);
 86662:       mDT->PushClipRect(mRect);
 86662:     } else {
 86662:       EnsurePath();
 86662:       mDT->PushClip(mPath);
 86662:       AzureState::PushedClip clip = { mPath, Rect(), mDT->GetTransform() };
 86662:       CurrentState().pushedClips.AppendElement(clip);
 86662:     }
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::ResetClip()
     1: {
 86662:   if (mCairo) {
     1:     cairo_reset_clip(mCairo);
 86662:   } else {
 86662:     for (int i = mStateStack.Length() - 1; i >= 0; i--) {
 86662:       for (unsigned int c = 0; c < mStateStack[i].pushedClips.Length(); c++) {
 86662:         mDT->PopClip();
 86662:       }
 86662: 
 86662:       if (mStateStack[i].clipWasReset) {
 86662:         break;
 86662:       }
 86662:     }
 86662:     CurrentState().pushedClips.Clear();
 86662:     CurrentState().clipWasReset = true;
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::UpdateSurfaceClip()
     1: {
 86662:   if (mCairo) {
     1:     NewPath();
 41340:     // we paint an empty rectangle to ensure the clip is propagated to
 41340:     // the destination surface
 41340:     SetDeviceColor(gfxRGBA(0,0,0,0));
 41340:     Rectangle(gfxRect(0,1,1,0));
     1:     Fill();
     1:   }
 86662: }
     1: 
  1706: gfxRect
  1706: gfxContext::GetClipExtents()
  1706: {
 86662:   if (mCairo) {
  1706:     double xmin, ymin, xmax, ymax;
  1706:     cairo_clip_extents(mCairo, &xmin, &ymin, &xmax, &ymax);
  1706:     return gfxRect(xmin, ymin, xmax - xmin, ymax - ymin);
 86662:   } else {
 86662:     unsigned int lastReset = 0;
 86662:     for (int i = mStateStack.Length() - 1; i > 0; i--) {
 86662:       if (mStateStack[i].clipWasReset) {
 86662:         lastReset = i;
 86662:       }
 86662:     }
 86662: 
 86662:     Rect rect(0, 0, Float(mDT->GetSize().width), Float(mDT->GetSize().height));
 86662:     for (unsigned int i = lastReset; i < mStateStack.Length(); i++) {
 86662:       for (unsigned int c = 0; c < mStateStack[i].pushedClips.Length(); c++) {
 86662:         AzureState::PushedClip &clip = mStateStack[i].pushedClips[c];
 86662:         if (clip.path) {
 86662:           Rect bounds = clip.path->GetBounds(clip.transform);
 86662:           rect.IntersectRect(rect, bounds);
 86662:         } else {
 86662:           rect.IntersectRect(rect, clip.transform.TransformBounds(clip.rect));
 86662:         }
 86662:       }
 86662:     }
 86662: 
 86662:     if (rect.width == 0 || rect.height == 0) {
 86662:       return gfxRect(0, 0, 0, 0);
 86662:     }
 86662: 
 86662:     Matrix mat = mDT->GetTransform();
 86662:     mat.Invert();
 86662:     rect = mat.TransformBounds(rect);
 86662: 
 86662:     return ThebesRect(rect);
 86662:   }
  1706: }
  1706: 
 79445: bool
 77288: gfxContext::ClipContainsRect(const gfxRect& aRect)
 77288: {
 86662:   if (mCairo) {
 77288:     cairo_rectangle_list_t *clip =
 77288:         cairo_copy_clip_rectangle_list(mCairo);
 77288: 
 79445:     bool result = false;
 77288: 
 77288:     if (clip->status == CAIRO_STATUS_SUCCESS) {
 77288:         for (int i = 0; i < clip->num_rectangles; i++) {
 77288:             gfxRect rect(clip->rectangles[i].x, clip->rectangles[i].y,
 77288:                          clip->rectangles[i].width, clip->rectangles[i].height);
 77288:             if (rect.Contains(aRect)) {
 80486:                 result = true;
 77288:                 break;
 77288:             }
 77288:         }
 77288:     }
 77288: 
 77288:     cairo_rectangle_list_destroy(clip);
 77288:     return result;
 86662:   } else {
 86662:     unsigned int lastReset = 0;
 86662:     for (int i = mStateStack.Length() - 2; i > 0; i--) {
 86662:       if (mStateStack[i].clipWasReset) {
 86662:         lastReset = i;
 86662:       }
 86662:     }
 86662: 
 86662:     // Since we always return false when the clip list contains a
 86662:     // non-rectangular clip or a non-rectilinear transform, our 'total' clip
 86662:     // is always a rectangle if we hit the end of this function.
 86662:     Rect clipBounds(0, 0, Float(mDT->GetSize().width), Float(mDT->GetSize().height));
 86662: 
 86662:     for (unsigned int i = lastReset; i < mStateStack.Length(); i++) {
 86662:       for (unsigned int c = 0; c < mStateStack[i].pushedClips.Length(); c++) {
 86662:         AzureState::PushedClip &clip = mStateStack[i].pushedClips[c];
 86662:         if (clip.path || !clip.transform.IsRectilinear()) {
 86662:           // Cairo behavior is we return false if the clip contains a non-
 86662:           // rectangle.
 86662:           return false;
 86662:         } else {
 86662:           Rect clipRect = mTransform.TransformBounds(clip.rect);
 86662: 
 86662:           clipBounds.IntersectRect(clipBounds, clipRect);
 86662:         }
 86662:       }
 86662:     }
 86662: 
 86662:     return clipBounds.Contains(ToRect(aRect));
 86662:   }
 77288: }
 77288: 
     1: // rendering sources
     1: 
     1: void
     1: gfxContext::SetColor(const gfxRGBA& c)
     1: {
 86662:   if (mCairo) {
 16571:     if (gfxPlatform::GetCMSMode() == eCMSMode_All) {
 19127: 
 19127:         gfxRGBA cms;
 19127:         gfxPlatform::TransformPixel(c, cms, gfxPlatform::GetCMSRGBTransform());
 19127: 
 19002:         // Use the original alpha to avoid unnecessary float->byte->float
 19002:         // conversion errors
 19002:         cairo_set_source_rgba(mCairo, cms.r, cms.g, cms.b, c.a);
  3787:     }
 19127:     else
     1:         cairo_set_source_rgba(mCairo, c.r, c.g, c.b, c.a);
 86662:   } else {
 86662:     CurrentState().pattern = NULL;
 99077:     CurrentState().sourceSurfCairo = NULL;
 86662:     CurrentState().sourceSurface = NULL;
 86662: 
 86662:     if (gfxPlatform::GetCMSMode() == eCMSMode_All) {
 86662: 
 86662:         gfxRGBA cms;
 86662:         gfxPlatform::TransformPixel(c, cms, gfxPlatform::GetCMSRGBTransform());
 86662: 
 86662:         // Use the original alpha to avoid unnecessary float->byte->float
 86662:         // conversion errors
 86662:         CurrentState().color = ToColor(cms);
 86662:     }
 86662:     else
 86662:         CurrentState().color = ToColor(c);
 86662:   }
     1: }
     1: 
 14741: void
 14741: gfxContext::SetDeviceColor(const gfxRGBA& c)
 14741: {
 86662:   if (mCairo) {
 14741:     cairo_set_source_rgba(mCairo, c.r, c.g, c.b, c.a);
 86662:   } else {
 86662:     CurrentState().pattern = NULL;
 99077:     CurrentState().sourceSurfCairo = NULL;
 86662:     CurrentState().sourceSurface = NULL;
 86662:     CurrentState().color = ToColor(c);
 86662:   }
 14741: }
 14741: 
 79445: bool
 14741: gfxContext::GetDeviceColor(gfxRGBA& c)
     1: {
 86662:   if (mCairo) {
     1:     return cairo_pattern_get_rgba(cairo_get_source(mCairo),
     1:                                   &c.r,
     1:                                   &c.g,
     1:                                   &c.b,
     1:                                   &c.a) == CAIRO_STATUS_SUCCESS;
 86662:   } else {
 86662:     if (CurrentState().sourceSurface) {
 86662:       return false;
 86662:     }
 86662:     if (CurrentState().pattern) {
 86662:       gfxRGBA color;
 86662:       return CurrentState().pattern->GetSolidColor(c);
 86662:     }
 86662: 
 86662:     c = ThebesRGBA(CurrentState().color);
 86662:     return true;
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::SetSource(gfxASurface *surface, const gfxPoint& offset)
     1: {
 86662:   if (mCairo) {
 59772:     NS_ASSERTION(surface->GetAllowUseAsSource(), "Surface not allowed to be used as source!");
     1:     cairo_set_source_surface(mCairo, surface->CairoSurface(), offset.x, offset.y);
 86662:   } else {
 86662:     CurrentState().surfTransform = Matrix(1.0f, 0, 0, 1.0f, Float(offset.x), Float(offset.y));
 86662:     CurrentState().pattern = NULL;
 94391:     CurrentState().patternTransformChanged = false;
 99077:     // Keep the underlying cairo surface around while we keep the
 99077:     // sourceSurface.
 99077:     CurrentState().sourceSurfCairo = surface;
 86662:     CurrentState().sourceSurface =
 86662:       gfxPlatform::GetPlatform()->GetSourceSurfaceForSurface(mDT, surface);
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::SetPattern(gfxPattern *pattern)
     1: {
 86662:   if (mCairo) {
     1:     cairo_set_source(mCairo, pattern->CairoPattern());
 86662:   } else {
 99077:     CurrentState().sourceSurfCairo = NULL;
 86662:     CurrentState().sourceSurface = NULL;
 94391:     CurrentState().patternTransformChanged = false;
 86662:     CurrentState().pattern = pattern;
 86662:   }
     1: }
     1: 
     1: already_AddRefed<gfxPattern>
     1: gfxContext::GetPattern()
     1: {
 86662:   if (mCairo) {
     1:     cairo_pattern_t *pat = cairo_get_source(mCairo);
     1:     NS_ASSERTION(pat, "I was told this couldn't be null");
     1: 
     1:     gfxPattern *wrapper = nsnull;
     1:     if (pat)
     1:         wrapper = new gfxPattern(pat);
     1:     else
     1:         wrapper = new gfxPattern(gfxRGBA(0,0,0,0));
     1: 
  3769:     NS_IF_ADDREF(wrapper);
     1:     return wrapper;
 86662:   } else {
 86662:     nsRefPtr<gfxPattern> pat;
 86662:     
 86662:     AzureState &state = CurrentState();
 86662:     if (state.pattern) {
 86662:       pat = state.pattern;
 86662:     } else if (state.sourceSurface) {
 86662:       NS_ASSERTION(false, "Ugh, this isn't good.");
 86662:     } else {
 86662:       pat = new gfxPattern(ThebesRGBA(state.color));
 86662:     }
 86662:     return pat.forget();
 86662:   }
     1: }
     1: 
     1: 
     1: // masking
     1: 
     1: void
     1: gfxContext::Mask(gfxPattern *pattern)
     1: {
 86662:   if (mCairo) {
     1:     cairo_mask(mCairo, pattern->CairoPattern());
 86662:   } else {
 86662:     mDT->Mask(GeneralPattern(this), *pattern->GetPattern(mDT), DrawOptions(1.0f, CurrentState().op, CurrentState().aaMode));
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::Mask(gfxASurface *surface, const gfxPoint& offset)
     1: {
 95736:   SAMPLE_LABEL("gfxContext", "Mask");
 86662:   if (mCairo) {
     1:     cairo_mask_surface(mCairo, surface->CairoSurface(), offset.x, offset.y);
 86662:   } else {
 99077:     // Lifetime needs to be limited here as we may simply wrap surface's data.
 86662:     RefPtr<SourceSurface> sourceSurf =
 86662:       gfxPlatform::GetPlatform()->GetSourceSurfaceForSurface(mDT, surface);
 86662: 
 86662:     gfxPoint pt = surface->GetDeviceOffset();
 86662:     mDT->Mask(GeneralPattern(this), 
 86662:               SurfacePattern(sourceSurf, EXTEND_CLAMP,
 86662:                              Matrix(1.0f, 0, 0, 1.0f, Float(offset.x - pt.x), Float(offset.y - pt.y))),
 86662:                              DrawOptions(1.0f, CurrentState().op, CurrentState().aaMode));
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::Paint(gfxFloat alpha)
     1: {
 95736:   SAMPLE_LABEL("gfxContext", "Paint");
 86662:   if (mCairo) {
     1:     cairo_paint_with_alpha(mCairo, alpha);
 86662:   } else {
 86662:     AzureState &state = CurrentState();
 86662: 
 86662:     Matrix mat = mDT->GetTransform();
 86662:     mat.Invert();
 86662:     Rect paintRect = mat.TransformBounds(Rect(Point(0, 0), Size(mDT->GetSize())));
 86662: 
 86662:     if (state.opIsClear) {
 86662:       mDT->ClearRect(paintRect);
 86662:     } else {
 86662:       mDT->FillRect(paintRect, GeneralPattern(this),
 86662:                     DrawOptions(Float(alpha), GetOp()));
 86662:     }
 86662:   }
     1: }
     1: 
     1: // groups
     1: 
     1: void
     1: gfxContext::PushGroup(gfxASurface::gfxContentType content)
     1: {
 86662:   if (mCairo) {
     1:     cairo_push_group_with_content(mCairo, (cairo_content_t) content);
 86662:   } else {
 86662:     RefPtr<DrawTarget> newDT =
 99511:       mDT->CreateSimilarDrawTarget(mDT->GetSize(), gfxPlatform::GetPlatform()->Optimal2DFormatForContent(content));
 86662: 
 86662:     Save();
 86662: 
 86662:     CurrentState().drawTarget = newDT;
 86662: 
 86662:     PushClipsToDT(newDT);
 86662:     newDT->SetTransform(mDT->GetTransform());
 86662:     mDT = newDT;
 86662:   }
     1: }
     1: 
 59765: static gfxRect
 59765: GetRoundOutDeviceClipExtents(gfxContext* aCtx)
 59765: {
 59765:   gfxContextMatrixAutoSaveRestore save(aCtx);
 59765:   aCtx->IdentityMatrix();
 59765:   gfxRect r = aCtx->GetClipExtents();
 59765:   r.RoundOut();
 59765:   return r;
 59765: }
 59765: 
 60676: /**
 60676:  * Copy the contents of aSrc to aDest, translated by aTranslation.
 60676:  */
 59771: static void
 60676: CopySurface(gfxASurface* aSrc, gfxASurface* aDest, const gfxPoint& aTranslation)
 59771: {
 59771:   cairo_t *cr = cairo_create(aDest->CairoSurface());
 60676:   cairo_set_source_surface(cr, aSrc->CairoSurface(), aTranslation.x, aTranslation.y);
 59771:   cairo_set_operator(cr, CAIRO_OPERATOR_SOURCE);
 59771:   cairo_paint(cr);
 59771:   cairo_destroy(cr);
 59771: }
 59771: 
 59760: void
 59760: gfxContext::PushGroupAndCopyBackground(gfxASurface::gfxContentType content)
 59760: {
 86662:   if (mCairo) {
 60646:     if (content == gfxASurface::CONTENT_COLOR_ALPHA &&
 60646:       !(GetFlags() & FLAG_DISABLE_COPY_BACKGROUND)) {
 59765:       nsRefPtr<gfxASurface> s = CurrentSurface();
 60644:       if ((s->GetAllowUseAsSource() || s->GetType() == gfxASurface::SurfaceTypeTee) &&
 60644:           (s->GetContentType() == gfxASurface::CONTENT_COLOR ||
 60644:               s->GetOpaqueRect().Contains(GetRoundOutDeviceClipExtents(this)))) {
 59760:         cairo_push_group_with_content(mCairo, CAIRO_CONTENT_COLOR);
 59765:         nsRefPtr<gfxASurface> d = CurrentSurface();
 59760: 
 59771:         if (d->GetType() == gfxASurface::SurfaceTypeTee) {
 59771:           NS_ASSERTION(s->GetType() == gfxASurface::SurfaceTypeTee, "Mismatched types");
 59771:           nsAutoTArray<nsRefPtr<gfxASurface>,2> ss;
 59771:           nsAutoTArray<nsRefPtr<gfxASurface>,2> ds;
 59771:           static_cast<gfxTeeSurface*>(s.get())->GetSurfaces(&ss);
 59771:           static_cast<gfxTeeSurface*>(d.get())->GetSurfaces(&ds);
 59771:           NS_ASSERTION(ss.Length() == ds.Length(), "Mismatched lengths");
 60676:           gfxPoint translation = d->GetDeviceOffset() - s->GetDeviceOffset();
 59771:           for (PRUint32 i = 0; i < ss.Length(); ++i) {
 60676:               CopySurface(ss[i], ds[i], translation);
 59771:           }
 59771:         } else {
 60676:           CopySurface(s, d, gfxPoint(0, 0));
 59771:         }
 59765:         d->SetOpaqueRect(s->GetOpaqueRect());
 59760:         return;
 59760:       }
 59760:     }
 86662:   } else {
 97553:     IntRect clipExtents;
 97553:     if (mDT->GetFormat() != FORMAT_B8G8R8X8) {
 97553:       gfxRect clipRect = GetRoundOutDeviceClipExtents(this);
 97553:       clipExtents = IntRect(clipRect.x, clipRect.y, clipRect.width, clipRect.height);
 97553:     }
 97553:     if (mDT->GetFormat() == FORMAT_B8G8R8X8 ||
 97553:         mDT->GetOpaqueRect().Contains(clipExtents)) {
 97553:       DrawTarget *oldDT = mDT;
 86662:       RefPtr<SourceSurface> source = mDT->Snapshot();
 86662:       PushGroup(content);
 86662:       Rect surfRect(0, 0, Float(mDT->GetSize().width), Float(mDT->GetSize().height));
 97553:       Matrix oldTransform = mDT->GetTransform();
 97553:       mDT->SetTransform(Matrix());
 86662:       mDT->DrawSurface(source, surfRect, surfRect); 
 97553:       mDT->SetTransform(oldTransform);
 97553:       mDT->SetOpaqueRect(oldDT->GetOpaqueRect());
 97553:       return;
 86662:     }
 59760:   }
 97553:   PushGroup(content);
 97553: }
 59760: 
     1: already_AddRefed<gfxPattern>
     1: gfxContext::PopGroup()
     1: {
 86662:   if (mCairo) {
     1:     cairo_pattern_t *pat = cairo_pop_group(mCairo);
     1:     gfxPattern *wrapper = new gfxPattern(pat);
  3769:     cairo_pattern_destroy(pat);
  3769:     NS_IF_ADDREF(wrapper);
     1:     return wrapper;
 86662:   } else {
 86662:     RefPtr<SourceSurface> src = mDT->Snapshot();
 86662: 
 86662:     Restore();
 86662: 
 86662:     Matrix mat = mDT->GetTransform();
 86662:     mat.Invert();
 86662:     nsRefPtr<gfxPattern> pat = new gfxPattern(src, mat);
 86662: 
 86662:     return pat.forget();
 86662:   }
     1: }
     1: 
     1: void
     1: gfxContext::PopGroupToSource()
     1: {
 86662:   if (mCairo) {
     1:     cairo_pop_group_to_source(mCairo);
 86662:   } else {
 86662:     RefPtr<SourceSurface> src = mDT->Snapshot();
 86662:     Restore();
 99077:     CurrentState().sourceSurfCairo = NULL;
 86662:     CurrentState().sourceSurface = src;
 86662:     CurrentState().pattern = NULL;
 94391:     CurrentState().patternTransformChanged = false;
 86662: 
 86662:     Matrix mat = mDT->GetTransform();
 86662:     mat.Invert();
 86662:     CurrentState().surfTransform = mat;
 86662:   }
     1: }
     1: 
 79445: bool
     1: gfxContext::PointInFill(const gfxPoint& pt)
     1: {
 86662:   if (mCairo) {
     1:     return cairo_in_fill(mCairo, pt.x, pt.y);
 86662:   } else {
 86662:     return mPath->ContainsPoint(ToPoint(pt), mTransform);
 86662:   }
     1: }
     1: 
 79445: bool
     1: gfxContext::PointInStroke(const gfxPoint& pt)
     1: {
 86662:   if (mCairo) {
     1:     return cairo_in_stroke(mCairo, pt.x, pt.y);
 86662:   } else {
 86662:     // XXX - Used by SVG, needs fixing.
 90091:     return false;
 86662:   }
     1: }
     1: 
     1: gfxRect
 10786: gfxContext::GetUserPathExtent()
 10786: {
 86662:   if (mCairo) {
 10786:     double xmin, ymin, xmax, ymax;
 10786:     cairo_path_extents(mCairo, &xmin, &ymin, &xmax, &ymax);
 10786:     return gfxRect(xmin, ymin, xmax - xmin, ymax - ymin);
 86662:   } else {
 86662:     return ThebesRect(mPath->GetBounds());
 86662:   }
 10786: }
 10786: 
 10786: gfxRect
     1: gfxContext::GetUserFillExtent()
     1: {
 86662:   if (mCairo) {
     1:     double xmin, ymin, xmax, ymax;
     1:     cairo_fill_extents(mCairo, &xmin, &ymin, &xmax, &ymax);
     1:     return gfxRect(xmin, ymin, xmax - xmin, ymax - ymin);
 86662:   } else {
 86662:     return ThebesRect(mPath->GetBounds());
 86662:   }
     1: }
     1: 
     1: gfxRect
     1: gfxContext::GetUserStrokeExtent()
     1: {
 86662:   if (mCairo) {
     1:     double xmin, ymin, xmax, ymax;
     1:     cairo_stroke_extents(mCairo, &xmin, &ymin, &xmax, &ymax);
     1:     return gfxRect(xmin, ymin, xmax - xmin, ymax - ymin);
 86662:   } else {
 86662:     return ThebesRect(mPath->GetStrokedBounds(CurrentState().strokeOptions, mTransform));
 86662:   }
     1: }
   562: 
   562: already_AddRefed<gfxFlattenedPath>
   562: gfxContext::GetFlattenedPath()
   562: {
 86662:   if (mCairo) {
   562:     gfxFlattenedPath *path =
   562:         new gfxFlattenedPath(cairo_copy_path_flat(mCairo));
   562:     NS_IF_ADDREF(path);
   562:     return path;
 86662:   } else {
 86662:     // XXX - Used by SVG, needs fixing.
 86662:     return NULL;
 86662:   }
   562: }
 10103: 
 79445: bool
 10103: gfxContext::HasError()
 10103: {
 86662:   if (mCairo) {
 10103:     return cairo_status(mCairo) != CAIRO_STATUS_SUCCESS;
 86662:   } else {
 86662:     // As far as this is concerned, an Azure context is never in error.
 90091:     return false;
 86662:   }
 10103: }
 16149: 
 16149: void
 16149: gfxContext::RoundedRectangle(const gfxRect& rect,
 16149:                              const gfxCornerSizes& corners,
 79445:                              bool draw_clockwise)
 16149: {
 16149:     //
 16149:     // For CW drawing, this looks like:
 16149:     //
 16149:     //  ...******0**      1    C
 16149:     //              ****
 16149:     //                  ***    2
 16149:     //                     **
 16149:     //                       *
 16149:     //                        *
 16149:     //                         3
 16149:     //                         *
 16149:     //                         *
 16149:     //
 22354:     // Where 0, 1, 2, 3 are the control points of the Bezier curve for
 22354:     // the corner, and C is the actual corner point.
 16149:     //
 16149:     // At the start of the loop, the current point is assumed to be
 16149:     // the point adjacent to the top left corner on the top
 16149:     // horizontal.  Note that corner indices start at the top left and
 16149:     // continue clockwise, whereas in our loop i = 0 refers to the top
 16149:     // right corner.
 16149:     //
 22354:     // When going CCW, the control points are swapped, and the first
 22354:     // corner that's drawn is the top left (along with the top segment).
 22354:     //
 22354:     // There is considerable latitude in how one chooses the four
 22354:     // control points for a Bezier curve approximation to an ellipse.
 22354:     // For the overall path to be continuous and show no corner at the
 22354:     // endpoints of the arc, points 0 and 3 must be at the ends of the
 22354:     // straight segments of the rectangle; points 0, 1, and C must be
 22354:     // collinear; and points 3, 2, and C must also be collinear.  This
 22354:     // leaves only two free parameters: the ratio of the line segments
 22354:     // 01 and 0C, and the ratio of the line segments 32 and 3C.  See
 22354:     // the following papers for extensive discussion of how to choose
 22354:     // these ratios:
 22354:     //
 22354:     //   Dokken, Tor, et al. "Good approximation of circles by
 22354:     //      curvature-continuous Bezier curves."  Computer-Aided
 22354:     //      Geometric Design 7(1990) 33--41.
 22354:     //   Goldapp, Michael. "Approximation of circular arcs by cubic
 22354:     //      polynomials." Computer-Aided Geometric Design 8(1991) 227--238.
 22354:     //   Maisonobe, Luc. "Drawing an elliptical arc using polylines,
 22354:     //      quadratic, or cubic Bezier curves."
 22354:     //      http://www.spaceroots.org/documents/ellipse/elliptical-arc.pdf
 22354:     //
 22354:     // We follow the approach in section 2 of Goldapp (least-error,
 22354:     // Hermite-type approximation) and make both ratios equal to
 22354:     //
 22354:     //          2   2 + n - sqrt(2n + 28)
 22354:     //  alpha = - * ---------------------
 22354:     //          3           n - 4
 22354:     //
 22354:     // where n = 3( cbrt(sqrt(2)+1) - cbrt(sqrt(2)-1) ).
 22354:     //
 22354:     // This is the result of Goldapp's equation (10b) when the angle
 22354:     // swept out by the arc is pi/2, and the parameter "a-bar" is the
 22354:     // expression given immediately below equation (21).
 22354:     //
 22354:     // Using this value, the maximum radial error for a circle, as a
 22354:     // fraction of the radius, is on the order of 0.2 x 10^-3.
 22354:     // Neither Dokken nor Goldapp discusses error for a general
 22354:     // ellipse; Maisonobe does, but his choice of control points
 22354:     // follows different constraints, and Goldapp's expression for
 22354:     // 'alpha' gives much smaller radial error, even for very flat
 22354:     // ellipses, than Maisonobe's equivalent.
 22354:     //
 22354:     // For the various corners and for each axis, the sign of this
 22354:     // constant changes, or it might be 0 -- it's multiplied by the
 22354:     // appropriate multiplier from the list before using.
 86662: 
 86662:   if (mCairo) {
 22354:     const gfxFloat alpha = 0.55191497064665766025;
 16149: 
 16149:     typedef struct { gfxFloat a, b; } twoFloats;
 16149: 
 16149:     twoFloats cwCornerMults[4] = { { -1,  0 },
 16149:                                    {  0, -1 },
 16149:                                    { +1,  0 },
 16149:                                    {  0, +1 } };
 16149:     twoFloats ccwCornerMults[4] = { { +1,  0 },
 16149:                                     {  0, -1 },
 16149:                                     { -1,  0 },
 16149:                                     {  0, +1 } };
 16149: 
 16149:     twoFloats *cornerMults = draw_clockwise ? cwCornerMults : ccwCornerMults;
 16149: 
 16149:     gfxPoint pc, p0, p1, p2, p3;
 16149: 
 16149:     if (draw_clockwise)
 68632:         cairo_move_to(mCairo, rect.X() + corners[NS_CORNER_TOP_LEFT].width, rect.Y());
 16149:     else
 68632:         cairo_move_to(mCairo, rect.X() + rect.Width() - corners[NS_CORNER_TOP_RIGHT].width, rect.Y());
 16149: 
 41419:     NS_FOR_CSS_CORNERS(i) {
 16149:         // the corner index -- either 1 2 3 0 (cw) or 0 3 2 1 (ccw)
 41419:         mozilla::css::Corner c = mozilla::css::Corner(draw_clockwise ? ((i+1) % 4) : ((4-i) % 4));
 16149: 
 16149:         // i+2 and i+3 respectively.  These are used to index into the corner
 16149:         // multiplier table, and were deduced by calculating out the long form
 16149:         // of each corner and finding a pattern in the signs and values.
 16149:         int i2 = (i+2) % 4;
 16149:         int i3 = (i+3) % 4;
 16149: 
 41419:         pc = rect.AtCorner(c);
 16149: 
 16149:         if (corners[c].width > 0.0 && corners[c].height > 0.0) {
 16149:             p0.x = pc.x + cornerMults[i].a * corners[c].width;
 16149:             p0.y = pc.y + cornerMults[i].b * corners[c].height;
 16149: 
 16149:             p3.x = pc.x + cornerMults[i3].a * corners[c].width;
 16149:             p3.y = pc.y + cornerMults[i3].b * corners[c].height;
 16149: 
 16149:             p1.x = p0.x + alpha * cornerMults[i2].a * corners[c].width;
 16149:             p1.y = p0.y + alpha * cornerMults[i2].b * corners[c].height;
 16149: 
 16149:             p2.x = p3.x - alpha * cornerMults[i3].a * corners[c].width;
 16149:             p2.y = p3.y - alpha * cornerMults[i3].b * corners[c].height;
 16149: 
 16149:             cairo_line_to (mCairo, p0.x, p0.y);
 16149:             cairo_curve_to (mCairo,
 16149:                             p1.x, p1.y,
 16149:                             p2.x, p2.y,
 16149:                             p3.x, p3.y);
 16149:         } else {
 16149:             cairo_line_to (mCairo, pc.x, pc.y);
 16149:         }
 16149:     }
 16149: 
 16149:     cairo_close_path (mCairo);
 86662:   } else {
 86662:     EnsurePathBuilder();
 86662: 
 86662:     const gfxFloat alpha = 0.55191497064665766025;
 86662: 
 86662:     typedef struct { gfxFloat a, b; } twoFloats;
 86662: 
 86662:     twoFloats cwCornerMults[4] = { { -1,  0 },
 86662:                                    {  0, -1 },
 86662:                                    { +1,  0 },
 86662:                                    {  0, +1 } };
 86662:     twoFloats ccwCornerMults[4] = { { +1,  0 },
 86662:                                     {  0, -1 },
 86662:                                     { -1,  0 },
 86662:                                     {  0, +1 } };
 86662: 
 86662:     twoFloats *cornerMults = draw_clockwise ? cwCornerMults : ccwCornerMults;
 86662: 
 86662:     gfxPoint pc, p0, p1, p2, p3;
 86662: 
 86662:     if (draw_clockwise)
 86662:         mPathBuilder->MoveTo(Point(Float(rect.X() + corners[NS_CORNER_TOP_LEFT].width), Float(rect.Y())));
 86662:     else
 86662:         mPathBuilder->MoveTo(Point(Float(rect.X() + rect.Width() - corners[NS_CORNER_TOP_RIGHT].width), Float(rect.Y())));
 86662: 
 86662:     NS_FOR_CSS_CORNERS(i) {
 86662:         // the corner index -- either 1 2 3 0 (cw) or 0 3 2 1 (ccw)
 86662:         mozilla::css::Corner c = mozilla::css::Corner(draw_clockwise ? ((i+1) % 4) : ((4-i) % 4));
 86662: 
 86662:         // i+2 and i+3 respectively.  These are used to index into the corner
 86662:         // multiplier table, and were deduced by calculating out the long form
 86662:         // of each corner and finding a pattern in the signs and values.
 86662:         int i2 = (i+2) % 4;
 86662:         int i3 = (i+3) % 4;
 86662: 
 86662:         pc = rect.AtCorner(c);
 86662: 
 86662:         if (corners[c].width > 0.0 && corners[c].height > 0.0) {
 86662:             p0.x = pc.x + cornerMults[i].a * corners[c].width;
 86662:             p0.y = pc.y + cornerMults[i].b * corners[c].height;
 86662: 
 86662:             p3.x = pc.x + cornerMults[i3].a * corners[c].width;
 86662:             p3.y = pc.y + cornerMults[i3].b * corners[c].height;
 86662: 
 86662:             p1.x = p0.x + alpha * cornerMults[i2].a * corners[c].width;
 86662:             p1.y = p0.y + alpha * cornerMults[i2].b * corners[c].height;
 86662: 
 86662:             p2.x = p3.x - alpha * cornerMults[i3].a * corners[c].width;
 86662:             p2.y = p3.y - alpha * cornerMults[i3].b * corners[c].height;
 86662: 
 86662:             mPathBuilder->LineTo(ToPoint(p0));
 86662:             mPathBuilder->BezierTo(ToPoint(p1), ToPoint(p2), ToPoint(p3));
 86662:         } else {
 86662:             mPathBuilder->LineTo(ToPoint(pc));
 86662:         }
 86662:     }
 86662: 
 86662:     mPathBuilder->Close();
 86662:   }
 16149: }
 80872: 
 82351: #ifdef MOZ_DUMP_PAINTING
 80872: void
 80872: gfxContext::WriteAsPNG(const char* aFile)
 80872: { 
 80872:   nsRefPtr<gfxASurface> surf = CurrentSurface();
 80872:   if (surf) {
 80872:     surf->WriteAsPNG(aFile);
 80872:   } else {
 80872:     NS_WARNING("No surface found!");
 80872:   }
 80872: }
 80872: 
 80872: void 
 80872: gfxContext::DumpAsDataURL()
 80872: { 
 80872:   nsRefPtr<gfxASurface> surf = CurrentSurface();
 80872:   if (surf) {
 80872:     surf->DumpAsDataURL();
 80872:   } else {
 80872:     NS_WARNING("No surface found!");
 80872:   }
 80872: }
 80872: 
 80872: void 
 80872: gfxContext::CopyAsDataURL()
 80872: { 
 80872:   nsRefPtr<gfxASurface> surf = CurrentSurface();
 80872:   if (surf) {
 80872:     surf->CopyAsDataURL();
 80872:   } else {
 80872:     NS_WARNING("No surface found!");
 80872:   }
 80872: }
 80872: #endif
 86662: 
 86662: void
 86662: gfxContext::EnsurePath()
 86662: {
 86662:   if (mPathBuilder) {
 86662:     mPath = mPathBuilder->Finish();
 86662:     mPathBuilder = NULL;
 86662:   }
 86662: 
 86662:   if (mPath) {
 86662:     if (mTransformChanged) {
 86662:       Matrix mat = mDT->GetTransform();
 86662:       mat.Invert();
 86662:       mat = mPathTransform * mat;
 86662:       mPathBuilder = mPath->TransformedCopyToBuilder(mat, CurrentState().fillRule);
 86662:       mPath = mPathBuilder->Finish();
 86662:       mPathBuilder = NULL;
 86662: 
 86662:       mTransformChanged = false;
 86662:     }
 86662: 
 86662:     if (CurrentState().fillRule == mPath->GetFillRule()) {
 86662:       return;
 86662:     }
 86662: 
 86662:     mPathBuilder = mPath->CopyToBuilder(CurrentState().fillRule);
 86662: 
 86662:     mPath = mPathBuilder->Finish();
 86662:     mPathBuilder = NULL;
 86662:     return;
 86662:   }
 86662: 
 86662:   EnsurePathBuilder();
 86662:   mPath = mPathBuilder->Finish();
 86662:   mPathBuilder = NULL;
 86662: }
 86662: 
 86662: void
 86662: gfxContext::EnsurePathBuilder()
 86662: {
 86662:   if (mPathBuilder) {
 86662:     return;
 86662:   }
 86662: 
 86662:   if (mPath) {
 86662:     mPathBuilder = mPath->CopyToBuilder(CurrentState().fillRule);
 86662:     mPath = NULL;
 86662:   }
 86662: 
 86662:   mPathBuilder = mDT->CreatePathBuilder(CurrentState().fillRule);
 86662: 
 86662:   if (mPathIsRect && !mTransformChanged) {
 86662:     mPathBuilder->MoveTo(mRect.TopLeft());
 86662:     mPathBuilder->LineTo(mRect.TopRight());
 86662:     mPathBuilder->LineTo(mRect.BottomRight());
 86662:     mPathBuilder->LineTo(mRect.BottomLeft());
 86662:     mPathBuilder->Close();
 86662:   } else if (mPathIsRect) {
 86662:     mTransformChanged = false;
 86662:     Matrix mat = mDT->GetTransform();
 86662:     mat.Invert();
 86662:     mat = mPathTransform * mat;
 86662:     mPathBuilder->MoveTo(mat * mRect.TopLeft());
 86662:     mPathBuilder->LineTo(mat * mRect.TopRight());
 86662:     mPathBuilder->LineTo(mat * mRect.BottomRight());
 86662:     mPathBuilder->LineTo(mat * mRect.BottomLeft());
 86662:     mPathBuilder->Close();
 86662:   }
 86662: 
 86662:   mPathIsRect = false;
 86662: }
 86662: 
 86662: void
 86662: gfxContext::FillAzure(Float aOpacity)
 86662: {
 86662:   AzureState &state = CurrentState();
 86662: 
 86662:   CompositionOp op = GetOp();
 86662: 
 86662:   if (mPathIsRect && !mTransformChanged) {
 86662:     if (state.opIsClear) {
 86662:       mDT->ClearRect(mRect);
 86662:     } else if (op == OP_SOURCE) {
 86662:       // Emulate cairo operator source which is bound by mask!
 86662:       mDT->ClearRect(mRect);
 86662:       mDT->FillRect(mRect, GeneralPattern(this), DrawOptions(aOpacity));
 86662:     } else {
 86662:       mDT->FillRect(mRect, GeneralPattern(this), DrawOptions(aOpacity, op, state.aaMode));
 86662:     }
 86662:   } else {
 86662:     EnsurePath();
 86662: 
 86662:     NS_ASSERTION(!state.opIsClear, "We shouldn't be clearing complex paths!");
 86662: 
 86662:     mDT->Fill(mPath, GeneralPattern(this), DrawOptions(aOpacity, op, state.aaMode));
 86662:   }
 86662: }
 86662: 
 86662: void
 86662: gfxContext::PushClipsToDT(DrawTarget *aDT)
 86662: {
 86662:   // Tricky, we have to restore all clips -since the last time- the clip
 86662:   // was reset. If we didn't reset the clip, just popping the clips we
 86662:   // added was fine.
 86662:   unsigned int lastReset = 0;
 86662:   for (int i = mStateStack.Length() - 2; i > 0; i--) {
 86662:     if (mStateStack[i].clipWasReset) {
 86662:       lastReset = i;
 86662:     }
 86662:   }
 86662: 
 86662:   // Don't need to save the old transform, we'll be setting a new one soon!
 86662: 
 86662:   // Push all clips from the last state on the stack where the clip was
 86662:   // reset to the clip before ours.
 86662:   for (unsigned int i = lastReset; i < mStateStack.Length() - 1; i++) {
 86662:     for (unsigned int c = 0; c < mStateStack[i].pushedClips.Length(); c++) {
 86662:       aDT->SetTransform(mStateStack[i].pushedClips[c].transform);
 86662:       if (mStateStack[i].pushedClips[c].path) {
 86662:         aDT->PushClip(mStateStack[i].pushedClips[c].path);
 86662:       } else {
 86662:         aDT->PushClipRect(mStateStack[i].pushedClips[c].rect);
 86662:       }
 86662:     }
 86662:   }
 86662: }
 86662: 
 86662: CompositionOp
 86662: gfxContext::GetOp()
 86662: {
 86662:   if (CurrentState().op != OP_SOURCE) {
 86662:     return CurrentState().op;
 86662:   }
 86662: 
 86662:   AzureState &state = CurrentState();
 86662:   if (state.pattern) {
 86662:     if (state.pattern->IsOpaque()) {
 86662:       return OP_OVER;
 86662:     } else {
 86662:       return OP_SOURCE;
 86662:     }
 86662:   } else if (state.sourceSurface) {
 86662:     if (state.sourceSurface->GetFormat() == FORMAT_B8G8R8X8) {
 86662:       return OP_OVER;
 86662:     } else {
 86662:       return OP_SOURCE;
 86662:     }
 86662:   } else {
 86662:     if (state.color.a > 0.999) {
 86662:       return OP_OVER;
 86662:     } else {
 86662:       return OP_SOURCE;
 86662:     }
 86662:   }
 86662: }
 94391: 
 94391: /* SVG font code can change the transform after having set the pattern on the
 94391:  * context. When the pattern is set it is in user space, if the transform is
 94391:  * changed after doing so the pattern needs to be converted back into userspace.
 94391:  * We just store the old pattern here so that we only do the work needed here
 94391:  * if the pattern is actually used.
 94391:  */
 94391: void
 99080: gfxContext::ChangeTransform(const Matrix &aNewMatrix)
 94391: {
 94391:   AzureState &state = CurrentState();
 94391: 
 94391:   if ((state.pattern || state.sourceSurface)
 94391:       && !state.patternTransformChanged) {
 94391:     state.patternTransform = mDT->GetTransform();
 94391:     state.patternTransformChanged = true;
 94391:   }
 99078: 
 99078:   if (mPathBuilder || mPathIsRect) {
 99078:     Matrix invMatrix = aNewMatrix;
 99078:     
 99078:     invMatrix.Invert();
 99078: 
 99078:     Matrix toNewUS = mDT->GetTransform() * invMatrix;
 99078: 
 99078:     if (toNewUS.IsRectilinear() && mPathIsRect) {
 99078:       mRect = toNewUS.TransformBounds(mRect);
 99078:     } else if (mPathIsRect) {
 99078:       mPathBuilder = mDT->CreatePathBuilder(CurrentState().fillRule);
 99078:       
 99078:       mPathBuilder->MoveTo(toNewUS * mRect.TopLeft());
 99078:       mPathBuilder->LineTo(toNewUS * mRect.TopRight());
 99078:       mPathBuilder->LineTo(toNewUS * mRect.BottomRight());
 99078:       mPathBuilder->LineTo(toNewUS * mRect.BottomLeft());
 99078:       mPathBuilder->Close();
 99078:     } else {
 99078:       RefPtr<Path> path = mPathBuilder->Finish();
 99078:       // Create path in device space.
 99078:       mPathBuilder = path->TransformedCopyToBuilder(toNewUS);
 99078:     }
 99078:     // No need to consider the transform changed now!
 99078:     mTransformChanged = false;
 99078:   }
 99078: 
 99078:   mDT->SetTransform(aNewMatrix);
 94391: }
