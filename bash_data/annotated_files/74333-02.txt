58172: /* -*- Mode: c++; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
43066:  * ***** BEGIN LICENSE BLOCK *****
43066:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43066:  *
43066:  * The contents of this file are subject to the Mozilla Public License Version
43066:  * 1.1 (the "License"); you may not use this file except in compliance with
43066:  * the License. You may obtain a copy of the License at
43066:  * http://www.mozilla.org/MPL/
43066:  *
43066:  * Software distributed under the License is distributed on an "AS IS" basis,
43066:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43066:  * for the specific language governing rights and limitations under the
43066:  * License.
43066:  *
43066:  * The Original Code is Mozilla Android code.
43066:  *
43066:  * The Initial Developer of the Original Code is Mozilla Foundation.
43066:  * Portions created by the Initial Developer are Copyright (C) 2010
43066:  * the Initial Developer. All Rights Reserved.
43066:  *
43066:  * Contributor(s):
43066:  *   Vladimir Vukicevic <vladimir@pobox.com>
57436:  *   Matt Brubeck <mbrubeck@mozilla.com>
57436:  *   Vivien Nicolas <vnicolas@mozilla.com>
43066:  *
43066:  * Alternatively, the contents of this file may be used under the terms of
43066:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43066:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43066:  * in which case the provisions of the GPL or the LGPL are applicable instead
43066:  * of those above. If you wish to allow use of your version of this file only
43066:  * under the terms of either the GPL or the LGPL, and not to allow others to
43066:  * use your version of this file under the terms of the MPL, indicate your
43066:  * decision by deleting the provisions above and replace them with the notice
43066:  * and other provisions required by the GPL or the LGPL. If you do not delete
43066:  * the provisions above, a recipient may use your version of this file under
43066:  * the terms of any one of the MPL, the GPL or the LGPL.
43066:  *
43066:  * ***** END LICENSE BLOCK ***** */
43066: 
43066: #include <android/log.h>
51501: #include <math.h>
43066: 
58172: #include "mozilla/dom/ContentParent.h"
58172: #include "mozilla/dom/ContentChild.h"
58172: #include "mozilla/unused.h"
71384: #include "mozilla/Preferences.h"
58172: 
58172: using mozilla::dom::ContentParent;
58172: using mozilla::dom::ContentChild;
58172: using mozilla::unused;
58172: 
43066: #include "nsAppShell.h"
43066: #include "nsIdleService.h"
43066: #include "nsWindow.h"
58172: #include "nsIObserverService.h"
43066: 
68481: #include "nsRenderingContext.h"
51501: #include "nsIDOMSimpleGestureEvent.h"
43066: 
43066: #include "nsWidgetAtoms.h"
43066: #include "nsWidgetsCID.h"
43066: #include "nsGfxCIID.h"
43066: 
43066: #include "gfxImageSurface.h"
43066: #include "gfxContext.h"
43066: 
46261: #include "Layers.h"
46261: #include "BasicLayers.h"
46261: #include "LayerManagerOGL.h"
46261: #include "GLContext.h"
46261: #include "GLContextProvider.h"
46261: 
43066: #include "nsTArray.h"
43066: 
43066: #include "AndroidBridge.h"
43066: 
43066: using namespace mozilla;
43066: 
43066: NS_IMPL_ISUPPORTS_INHERITED0(nsWindow, nsBaseWidget)
43066: 
43066: // The dimensions of the current android view
43066: static gfxIntSize gAndroidBounds;
60620: static gfxIntSize gAndroidScreenBounds;
43066: 
58172: class ContentCreationNotifier;
58172: static nsCOMPtr<ContentCreationNotifier> gContentCreationNotifier;
58172: // A helper class to send updates when content processes
58172: // are created. Currently an update for the screen size is sent.
58172: class ContentCreationNotifier : public nsIObserver
58172: {
58172:     NS_DECL_ISUPPORTS
58172: 
58172:     NS_IMETHOD Observe(nsISupports* aSubject,
58172:                        const char* aTopic,
58172:                        const PRUnichar* aData)
58172:     {
58172:         if (!strcmp(aTopic, "ipc:content-created")) {
58172:             ContentParent *cp = ContentParent::GetSingleton(PR_FALSE);
58172:             NS_ABORT_IF_FALSE(cp, "Must have content process if notified of its creation");
60620:             unused << cp->SendScreenSizeChanged(gAndroidScreenBounds);
58172:         } else if (!strcmp(aTopic, "xpcom-shutdown")) {
58172:             nsCOMPtr<nsIObserverService>
58172:                 obs(do_GetService("@mozilla.org/observer-service;1"));
58172:             if (obs) {
58172:                 obs->RemoveObserver(static_cast<nsIObserver*>(this),
58172:                                     "xpcom-shutdown");
58172:                 obs->RemoveObserver(static_cast<nsIObserver*>(this),
58172:                                     "ipc:content-created");
58172:             }
58172:             gContentCreationNotifier = nsnull;
58172:         }
58172: 
58172:         return NS_OK;
58172:     }
58172: };
58172: 
58172: NS_IMPL_ISUPPORTS1(ContentCreationNotifier,
58172:                    nsIObserver)
58172: 
55938: static PRBool gMenu;
55938: static PRBool gMenuConsumed;
43066: 
43066: // All the toplevel windows that have been created; these are in
43066: // stacking order, so the window at gAndroidBounds[0] is the topmost
43066: // one.
43066: static nsTArray<nsWindow*> gTopLevelWindows;
43066: 
46261: static nsRefPtr<gl::GLContext> sGLContext;
53686: static bool sFailedToCreateGLContext = false;
59166: static bool sValidSurface;
51501: 
57857: // Multitouch swipe thresholds in inches
57857: static const double SWIPE_MAX_PINCH_DELTA_INCHES = 0.4;
57857: static const double SWIPE_MIN_DISTANCE_INCHES = 0.6;
46261: 
43066: static nsWindow*
43066: TopWindow()
43066: {
43066:     if (!gTopLevelWindows.IsEmpty())
43066:         return gTopLevelWindows[0];
43066:     return nsnull;
43066: }
43066: 
43066: void
43066: nsWindow::LogWindow(nsWindow *win, int index, int indent)
43066: {
43066:     char spaces[] = "                    ";
43066:     spaces[indent < 20 ? indent : 20] = 0;
43066:     ALOG("%s [% 2d] 0x%08x [parent 0x%08x] [% 3d,% 3d % 3dx% 3d] vis %d type %d",
43066:          spaces, index, (intptr_t)win, (intptr_t)win->mParent,
43066:          win->mBounds.x, win->mBounds.y,
43066:          win->mBounds.width, win->mBounds.height,
43066:          win->mIsVisible, win->mWindowType);
43066: }
43066: 
43066: void
43066: nsWindow::DumpWindows()
43066: {
43066:     DumpWindows(gTopLevelWindows);
43066: }
43066: 
43066: void
43066: nsWindow::DumpWindows(const nsTArray<nsWindow*>& wins, int indent)
43066: {
46261:     for (PRUint32 i = 0; i < wins.Length(); ++i) {
43066:         nsWindow *w = wins[i];
43066:         LogWindow(w, i, indent);
43066:         DumpWindows(w->mChildren, indent+1);
43066:     }
43066: }
43066: 
43066: nsWindow::nsWindow() :
43066:     mIsVisible(PR_FALSE),
62542:     mParent(nsnull),
62542:     mFocus(nsnull)
43066: {
43066: }
43066: 
43066: nsWindow::~nsWindow()
43066: {
43066:     gTopLevelWindows.RemoveElement(this);
62542:     nsWindow *top = FindTopLevel();
62542:     if (top->mFocus == this)
62542:         top->mFocus = nsnull;
43066:     ALOG("nsWindow %p destructor", (void*)this);
43066: }
43066: 
43066: PRBool
43066: nsWindow::IsTopLevel()
43066: {
43066:     return mWindowType == eWindowType_toplevel ||
43066:         mWindowType == eWindowType_dialog ||
43066:         mWindowType == eWindowType_invisible;
43066: }
43066: 
43066: NS_IMETHODIMP
43066: nsWindow::Create(nsIWidget *aParent,
43066:                  nsNativeWidget aNativeParent,
43066:                  const nsIntRect &aRect,
43066:                  EVENT_CALLBACK aHandleEventFunction,
68668:                  nsDeviceContext *aContext,
43066:                  nsIAppShell *aAppShell,
43066:                  nsIToolkit *aToolkit,
43066:                  nsWidgetInitData *aInitData)
43066: {
43066:     ALOG("nsWindow[%p]::Create %p [%d %d %d %d]", (void*)this, (void*)aParent, aRect.x, aRect.y, aRect.width, aRect.height);
43066:     nsWindow *parent = (nsWindow*) aParent;
43066: 
46923:     if (!AndroidBridge::Bridge()) {
46923:         aNativeParent = nsnull;
46923:     }
46923: 
43066:     if (aNativeParent) {
43066:         if (parent) {
43066:             ALOG("Ignoring native parent on Android window [%p], since parent was specified (%p %p)", (void*)this, (void*)aNativeParent, (void*)aParent);
43066:         } else {
43066:             parent = (nsWindow*) aNativeParent;
43066:         }
43066:     }
43066: 
43066:     mBounds = aRect;
43066: 
43066:     // for toplevel windows, bounds are fixed to full screen size
43066:     if (!parent) {
43066:         mBounds.x = 0;
43066:         mBounds.y = 0;
43066:         mBounds.width = gAndroidBounds.width;
43066:         mBounds.height = gAndroidBounds.height;
43066:     }
43066: 
43066:     BaseCreate(nsnull, mBounds, aHandleEventFunction, aContext,
43066:                aAppShell, aToolkit, aInitData);
43066: 
43066:     NS_ASSERTION(IsTopLevel() || parent, "non top level windowdoesn't have a parent!");
43066: 
43066:     if (IsTopLevel()) {
43066:         gTopLevelWindows.AppendElement(this);
43066:     }
43066: 
43066:     if (parent) {
43066:         parent->mChildren.AppendElement(this);
43066:         mParent = parent;
43066:     }
43066: 
57857:     float dpi = GetDPI();
57857:     mSwipeMaxPinchDelta = SWIPE_MAX_PINCH_DELTA_INCHES * dpi;
57857:     mSwipeMinDistance = SWIPE_MIN_DISTANCE_INCHES * dpi;
57857: 
43066:     return NS_OK;
43066: }
43066: 
43066: NS_IMETHODIMP
43066: nsWindow::Destroy(void)
43066: {
43066:     for (PRUint32 i = 0; i < mChildren.Length(); ++i) {
43066:         // why do we still have children?
43066:         ALOG("### Warning: Destroying window %p and reparenting child %p to null!", (void*)this, (void*)mChildren[i]);
43066:         mChildren[i]->SetParent(nsnull);
43066:     }
43066: 
43066:     if (IsTopLevel())
43066:         gTopLevelWindows.RemoveElement(this);
43066: 
43066:     if (mParent)
43066:         mParent->mChildren.RemoveElement(this);
43066: 
43066:     return NS_OK;
43066: }
43066: 
43066: NS_IMETHODIMP
43066: nsWindow::ConfigureChildren(const nsTArray<nsIWidget::Configuration>& config)
43066: {
43066:     for (PRUint32 i = 0; i < config.Length(); ++i) {
43066:         nsWindow *childWin = (nsWindow*) config[i].mChild;
43066:         childWin->Resize(config[i].mBounds.x,
43066:                          config[i].mBounds.y,
43066:                          config[i].mBounds.width,
43066:                          config[i].mBounds.height,
43066:                          PR_FALSE);
43066:     }
43066: 
43066:     return NS_OK;
43066: }
43066: 
43066: NS_IMETHODIMP
43066: nsWindow::SetParent(nsIWidget *aNewParent)
43066: {
43066:     if ((nsIWidget*)mParent == aNewParent)
43066:         return NS_OK;
43066: 
43066:     // If we had a parent before, remove ourselves from its list of
43066:     // children.  If we didn't have a parent, then remove ourselves
43066:     // from the list of toplevel windows if we're about to get a
43066:     // parent.
43066:     if (mParent)
43066:         mParent->mChildren.RemoveElement(this);
43066: 
43066:     mParent = (nsWindow*)aNewParent;
43066: 
43066:     if (mParent)
43066:         mParent->mChildren.AppendElement(this);
43066: 
43066:     // if we are now in the toplevel window's hierarchy, schedule a redraw
43066:     if (FindTopLevel() == TopWindow())
60835:         nsAppShell::gAppShell->PostEvent(new AndroidGeckoEvent(-1, -1, -1, -1));
43066: 
43066:     return NS_OK;
43066: }
43066: 
54312: NS_IMETHODIMP
54312: nsWindow::ReparentNativeWidget(nsIWidget *aNewParent)
54312: {
54312:     NS_PRECONDITION(aNewParent, "");
54312:     return NS_OK;
54312: }
54312: 
43066: nsIWidget*
43066: nsWindow::GetParent()
43066: {
43066:     return mParent;
43066: }
43066: 
55134: float
55134: nsWindow::GetDPI()
55134: {
55134:     if (AndroidBridge::Bridge())
55134:         return AndroidBridge::Bridge()->GetDPI();
55134:     return 160.0f;
55134: }
55134: 
43066: NS_IMETHODIMP
43066: nsWindow::Show(PRBool aState)
43066: {
43066:     ALOG("nsWindow[%p]::Show %d", (void*)this, aState);
43066: 
43066:     if (mWindowType == eWindowType_invisible) {
43066:         ALOG("trying to show invisible window! ignoring..");
43066:         return NS_ERROR_FAILURE;
43066:     }
43066: 
62542:     if (aState == mIsVisible)
62542:         return NS_OK;
62542: 
43066:     mIsVisible = aState;
43066: 
43066:     if (IsTopLevel()) {
43066:         // XXX should we bring this to the front when it's shown,
43066:         // if it's a toplevel widget?
43066: 
43066:         // XXX we should synthesize a NS_MOUSE_EXIT (for old top
43066:         // window)/NS_MOUSE_ENTER (for new top window) since we need
43066:         // to pretend that the top window always has focus.  Not sure
43066:         // if Show() is the right place to do this, though.
43066: 
62542:         if (aState) {
43066:             // It just became visible, so send a resize update if necessary
43066:             // and bring it to the front.
43066:             Resize(0, 0, gAndroidBounds.width, gAndroidBounds.height, PR_FALSE);
43066:             BringToFront();
62542:         } else if (TopWindow() == this) {
62542:             // find the next visible window to show
63330:             unsigned int i;
62542:             for (i = 1; i < gTopLevelWindows.Length(); i++) {
62542:                 nsWindow *win = gTopLevelWindows[i];
62542:                 if (!win->mIsVisible)
62542:                     continue;
62542: 
62542:                 win->BringToFront();
62542:                 break;
62542:             }
43066:         }
43066:     } else if (FindTopLevel() == TopWindow()) {
60835:         nsAppShell::gAppShell->PostEvent(new AndroidGeckoEvent(-1, -1, -1, -1));
43066:     }
43066: 
43066: #ifdef ANDROID_DEBUG_WIDGET
43066:     DumpWindows();
43066: #endif
43066: 
43066:     return NS_OK;
43066: }
43066: 
43066: NS_IMETHODIMP
43066: nsWindow::SetModal(PRBool aState)
43066: {
43066:     ALOG("nsWindow[%p]::SetModal %d ignored", (void*)this, aState);
43066: 
43066:     return NS_OK;
43066: }
43066: 
43066: NS_IMETHODIMP
43066: nsWindow::IsVisible(PRBool& aState)
43066: {
43066:     aState = mIsVisible;
43066:     return NS_OK;
43066: }
43066: 
43066: NS_IMETHODIMP
43066: nsWindow::ConstrainPosition(PRBool aAllowSlop,
43066:                             PRInt32 *aX,
43066:                             PRInt32 *aY)
43066: {
43066:     ALOG("nsWindow[%p]::ConstrainPosition %d [%d %d]", (void*)this, aAllowSlop, *aX, *aY);
43066: 
43066:     // constrain toplevel windows; children we don't care about
43066:     if (IsTopLevel()) {
43066:         *aX = 0;
43066:         *aY = 0;
43066:     }
43066: 
43066:     return NS_OK;
43066: }
43066: 
43066: NS_IMETHODIMP
43066: nsWindow::Move(PRInt32 aX,
43066:                PRInt32 aY)
43066: {
43066:     if (IsTopLevel())
43066:         return NS_OK;
43066: 
43066:     return Resize(aX,
43066:                   aY,
43066:                   mBounds.width,
43066:                   mBounds.height,
43066:                   PR_TRUE);
43066: }
43066: 
43066: NS_IMETHODIMP
43066: nsWindow::Resize(PRInt32 aWidth,
43066:                  PRInt32 aHeight,
43066:                  PRBool aRepaint)
43066: {
43066:     return Resize(mBounds.x,
43066:                   mBounds.y,
43066:                   aWidth,
43066:                   aHeight,
43066:                   aRepaint);
43066: }
43066: 
43066: NS_IMETHODIMP
43066: nsWindow::Resize(PRInt32 aX,
43066:                  PRInt32 aY,
43066:                  PRInt32 aWidth,
43066:                  PRInt32 aHeight,
43066:                  PRBool aRepaint)
43066: {
43066:     ALOG("nsWindow[%p]::Resize [%d %d %d %d] (repaint %d)", (void*)this, aX, aY, aWidth, aHeight, aRepaint);
43066: 
43066:     PRBool needSizeDispatch = aWidth != mBounds.width || aHeight != mBounds.height;
43066: 
43066:     if (IsTopLevel()) {
43066:         ALOG("... ignoring Resize sizes on toplevel window");
43066:         aX = 0;
43066:         aY = 0;
43066:         aWidth = gAndroidBounds.width;
43066:         aHeight = gAndroidBounds.height;
43066:     }
43066: 
43066:     mBounds.x = aX;
43066:     mBounds.y = aY;
43066:     mBounds.width = aWidth;
43066:     mBounds.height = aHeight;
43066: 
43066:     if (needSizeDispatch)
43066:         OnSizeChanged(gfxIntSize(aWidth, aHeight));
43066: 
43066:     // Should we skip honoring aRepaint here?
43066:     if (aRepaint && FindTopLevel() == TopWindow())
60835:         nsAppShell::gAppShell->PostEvent(new AndroidGeckoEvent(-1, -1, -1, -1));
43066: 
43066:     return NS_OK;
43066: }
43066: 
43066: NS_IMETHODIMP
43066: nsWindow::SetZIndex(PRInt32 aZIndex)
43066: {
43066:     ALOG("nsWindow[%p]::SetZIndex %d ignored", (void*)this, aZIndex);
43066: 
43066:     return NS_OK;
43066: }
43066: 
43066: NS_IMETHODIMP
43066: nsWindow::PlaceBehind(nsTopLevelWidgetZPlacement aPlacement,
43066:                       nsIWidget *aWidget,
43066:                       PRBool aActivate)
43066: {
43066:     return NS_OK;
43066: }
43066: 
43066: NS_IMETHODIMP
43066: nsWindow::SetSizeMode(PRInt32 aMode)
43066: {
43694:     switch (aMode) {
43694:         case nsSizeMode_Minimized:
43694:             AndroidBridge::Bridge()->MoveTaskToBack();
43694:             break;
57134:         case nsSizeMode_Fullscreen:
57134:             MakeFullScreen(PR_TRUE);
57134:             break;
43694:     }
43066:     return NS_OK;
43066: }
43066: 
43066: NS_IMETHODIMP
43066: nsWindow::Enable(PRBool aState)
43066: {
43066:     ALOG("nsWindow[%p]::Enable %d ignored", (void*)this, aState);
43066:     return NS_OK;
43066: }
43066: 
43066: NS_IMETHODIMP
43066: nsWindow::IsEnabled(PRBool *aState)
43066: {
43066:     *aState = PR_TRUE;
43066:     return NS_OK;
43066: }
43066: 
43066: NS_IMETHODIMP
43066: nsWindow::Invalidate(const nsIntRect &aRect,
43066:                      PRBool aIsSynchronous)
43066: {
60835:     nsAppShell::gAppShell->PostEvent(new AndroidGeckoEvent(-1, -1, -1, -1));
43066:     return NS_OK;
43066: }
43066: 
43066: NS_IMETHODIMP
43066: nsWindow::Update()
43066: {
43066:     return NS_OK;
43066: }
43066: 
43066: nsWindow*
43066: nsWindow::FindTopLevel()
43066: {
43066:     nsWindow *toplevel = this;
43066:     while (toplevel) {
43066:         if (toplevel->IsTopLevel())
43066:             return toplevel;
43066: 
43066:         toplevel = toplevel->mParent;
43066:     }
43066: 
43066:     ALOG("nsWindow::FindTopLevel(): couldn't find a toplevel or dialog window in this [%p] widget's hierarchy!", (void*)this);
43066:     return this;
43066: }
43066: 
43066: NS_IMETHODIMP
43066: nsWindow::SetFocus(PRBool aRaise)
43066: {
43066:     if (!aRaise)
43066:         ALOG("nsWindow::SetFocus: can't set focus without raising, ignoring aRaise = false!");
43066: 
47827:     if (!AndroidBridge::Bridge())
47827:         return NS_OK;
47827: 
62542:     nsWindow *top = FindTopLevel();
62542:     top->mFocus = this;
62542:     top->BringToFront();
43066: 
43066:     return NS_OK;
43066: }
43066: 
43066: void
43066: nsWindow::BringToFront()
43066: {
43066:     if (FindTopLevel() == TopWindow())
43066:         return;
43066: 
43066:     if (!IsTopLevel()) {
43066:         FindTopLevel()->BringToFront();
43066:         return;
43066:     }
43066: 
43066:     nsWindow *oldTop = nsnull;
43066:     if (!gTopLevelWindows.IsEmpty())
43066:         oldTop = gTopLevelWindows[0];
43066: 
43066:     gTopLevelWindows.RemoveElement(this);
43066:     gTopLevelWindows.InsertElementAt(0, this);
43066: 
43066:     if (oldTop) {
57607:         nsGUIEvent event(PR_TRUE, NS_DEACTIVATE, oldTop);
43066:         DispatchEvent(&event);
43066:     }
43066: 
43066:     nsGUIEvent event(PR_TRUE, NS_ACTIVATE, this);
43066:     DispatchEvent(&event);
43066: 
60835:     nsAppShell::gAppShell->PostEvent(new AndroidGeckoEvent(-1, -1, -1, -1));
43066: }
43066: 
43066: NS_IMETHODIMP
43066: nsWindow::GetScreenBounds(nsIntRect &aRect)
43066: {
43066:     nsIntPoint p = WidgetToScreenOffset();
43066: 
43066:     aRect.x = p.x;
43066:     aRect.y = p.y;
43066:     aRect.width = mBounds.width;
43066:     aRect.height = mBounds.height;
43066:     
43066:     return NS_OK;
43066: }
43066: 
43066: nsIntPoint
43066: nsWindow::WidgetToScreenOffset()
43066: {
43066:     nsIntPoint p(0, 0);
43066:     nsWindow *w = this;
43066: 
43066:     while (w && !w->IsTopLevel()) {
43066:         p.x += w->mBounds.x;
43066:         p.y += w->mBounds.y;
43066: 
43066:         w = w->mParent;
43066:     }
43066: 
43066:     return p;
43066: }
43066: 
43066: NS_IMETHODIMP
43066: nsWindow::DispatchEvent(nsGUIEvent *aEvent,
43066:                         nsEventStatus &aStatus)
43066: {
43066:     aStatus = DispatchEvent(aEvent);
43066:     return NS_OK;
43066: }
43066: 
43066: nsEventStatus
43066: nsWindow::DispatchEvent(nsGUIEvent *aEvent)
43066: {
51142:     if (mEventCallback) {
51142:         nsEventStatus status = (*mEventCallback)(aEvent);
51142: 
51142:         switch (aEvent->message) {
51142:         case NS_COMPOSITION_START:
51142:             mIMEComposing = PR_TRUE;
51142:             break;
51142:         case NS_COMPOSITION_END:
51142:             mIMEComposing = PR_FALSE;
51142:             break;
51142:         case NS_TEXT_TEXT:
51142:             mIMEComposingText = static_cast<nsTextEvent*>(aEvent)->theText;
51142:             break;
51142:         }
51142:         return status;
51142:     }
43066:     return nsEventStatus_eIgnore;
43066: }
43066: 
43066: NS_IMETHODIMP
57134: nsWindow::MakeFullScreen(PRBool aFullScreen)
57134: {
57134:     AndroidBridge::Bridge()->SetFullScreen(aFullScreen);
57134:     return NS_OK;
57134: }
57134: 
57134: NS_IMETHODIMP
43066: nsWindow::SetWindowClass(const nsAString& xulWinType)
43066: {
43066:     return NS_OK;
43066: }
43066: 
53686: mozilla::layers::LayerManager*
58812: nsWindow::GetLayerManager(LayerManagerPersistence, bool* aAllowRetaining)
53686: {
55858:     if (aAllowRetaining) {
55858:         *aAllowRetaining = true;
55858:     }
53686:     if (mLayerManager) {
53686:         return mLayerManager;
53686:     }
53686: 
53686:     printf_stderr("nsWindow::GetLayerManager\n");
53686: 
53686:     nsWindow *topWindow = TopWindow();
53686: 
53686:     if (!topWindow) {
53686:         printf_stderr(" -- no topwindow\n");
54111:         mLayerManager = CreateBasicLayerManager();
53686:         return mLayerManager;
53686:     }
53686: 
53686:     mUseAcceleratedRendering = GetShouldAccelerate();
53686: 
53686:     if (!mUseAcceleratedRendering ||
53686:         sFailedToCreateGLContext)
53686:     {
53686:         printf_stderr(" -- creating basic, not accelerated\n");
54111:         mLayerManager = CreateBasicLayerManager();
53686:         return mLayerManager;
53686:     }
53686: 
53686:     if (!sGLContext) {
53686:         // the window we give doesn't matter here
53686:         sGLContext = mozilla::gl::GLContextProvider::CreateForWindow(this);
53686:     }
53686: 
53686:     if (sGLContext) {
53686:         nsRefPtr<mozilla::layers::LayerManagerOGL> layerManager =
53686:             new mozilla::layers::LayerManagerOGL(this);
53686: 
53686:         if (layerManager && layerManager->Initialize(sGLContext))
53686:             mLayerManager = layerManager;
59166:         sValidSurface = true;
53686:     }
53686: 
53686:     if (!sGLContext || !mLayerManager) {
53686:         sGLContext = nsnull;
53686:         sFailedToCreateGLContext = PR_TRUE;
53686: 
54111:         mLayerManager = CreateBasicLayerManager();
53686:     }
53686: 
53686:     return mLayerManager;
53686: }
53686: 
43066: gfxASurface*
43066: nsWindow::GetThebesSurface()
43066: {
43066:     /* This is really a dummy surface; this is only used when doing reflow, because
43066:      * we need a RenderingContext to measure text against.
43066:      */
43066: 
43066:     // XXX this really wants to return already_AddRefed, but this only really gets used
43066:     // on direct assignment to a gfxASurface
43066:     return new gfxImageSurface(gfxIntSize(5,5), gfxImageSurface::ImageFormatRGB24);
43066: }
43066: 
43066: void
43066: nsWindow::OnGlobalAndroidEvent(AndroidGeckoEvent *ae)
43066: {
47827:     if (!AndroidBridge::Bridge())
47827:         return;
47827: 
56629:     nsWindow *win = TopWindow();
56629:     if (!win)
56629:         return;
56629: 
43066:     switch (ae->Type()) {
43066:         case AndroidGeckoEvent::SIZE_CHANGED: {
43066:             int nw = ae->P0().x;
43066:             int nh = ae->P0().y;
43066: 
60620:             if (nw != gAndroidBounds.width ||
60620:                 nh != gAndroidBounds.height) {
43066: 
43066:                 gAndroidBounds.width = nw;
43066:                 gAndroidBounds.height = nh;
43066: 
43066:                 // tell all the windows about the new size
43066:                 for (size_t i = 0; i < gTopLevelWindows.Length(); ++i) {
43066:                     if (gTopLevelWindows[i]->mIsVisible)
60620:                         gTopLevelWindows[i]->Resize(gAndroidBounds.width,
60620:                                                     gAndroidBounds.height,
60620:                                                     PR_TRUE);
60620:                 }
43066:             }
43066: 
60620:             int newScreenWidth = ae->P1().x;
60620:             int newScreenHeight = ae->P1().y;
60620: 
60620:             if (newScreenWidth == gAndroidScreenBounds.width &&
60620:                 newScreenHeight == gAndroidScreenBounds.height)
60620:                 break;
60620: 
60620:             gAndroidScreenBounds.width = newScreenWidth;
60620:             gAndroidScreenBounds.height = newScreenHeight;
60620: 
60620:             if (XRE_GetProcessType() != GeckoProcessType_Default)
60620:                 break;
60620: 
60620:             // Tell the content process the new screen size.
60620:             ContentParent *cp = ContentParent::GetSingleton(PR_FALSE);
60620:             if (cp)
60620:                 unused << cp->SendScreenSizeChanged(gAndroidScreenBounds);
60620: 
60620:             if (gContentCreationNotifier)
60620:                 break;
60620: 
60620:             // If the content process is not created yet, wait until it's
60620:             // created and then tell it the screen size.
60620:             nsCOMPtr<nsIObserverService> obs = do_GetService("@mozilla.org/observer-service;1");
60620:             if (!obs)
60620:                 break;
60620: 
58172:             nsCOMPtr<ContentCreationNotifier> notifier = new ContentCreationNotifier;
58172:             if (NS_SUCCEEDED(obs->AddObserver(notifier, "ipc:content-created", PR_FALSE))) {
58172:                 if (NS_SUCCEEDED(obs->AddObserver(notifier, "xpcom-shutdown", PR_FALSE)))
58172:                     gContentCreationNotifier = notifier;
60620:                 else
58172:                     obs->RemoveObserver(notifier, "ipc:content-created");
58172:             }
43066:         }
43066: 
43066:         case AndroidGeckoEvent::MOTION_EVENT: {
56629:             win->UserActivity();
43066:             if (!gTopLevelWindows.IsEmpty()) {
43066:                 nsIntPoint pt(ae->P0());
43066:                 pt.x = NS_MIN(NS_MAX(pt.x, 0), gAndroidBounds.width - 1);
43066:                 pt.y = NS_MIN(NS_MAX(pt.y, 0), gAndroidBounds.height - 1);
56629:                 nsWindow *target = win->FindWindowForPoint(pt);
43066: 
43066: #if 0
43066:                 ALOG("MOTION_EVENT %f,%f -> %p (visible: %d children: %d)", ae->P0().x, ae->P0().y, (void*)target,
43066:                      target ? target->mIsVisible : 0,
43066:                      target ? target->mChildren.Length() : 0);
43066: 
43066:                 DumpWindows();
43066: #endif
43066: 
47266:                 if (target) {
47266:                     if (ae->Count() > 1)
47266:                         target->OnMultitouchEvent(ae);
47266:                     else
43066:                         target->OnMotionEvent(ae);
43066:                 }
47266:             }
43066:             break;
43066:         }
43066: 
43066:         case AndroidGeckoEvent::KEY_EVENT:
56629:             win->UserActivity();
62542:             if (win->mFocus)
62542:                 win->mFocus->OnKeyEvent(ae);
43066:             break;
43066: 
43066:         case AndroidGeckoEvent::DRAW:
56629:             win->OnDraw(ae);
43066:             break;
43066: 
43066:         case AndroidGeckoEvent::IME_EVENT:
56629:             win->UserActivity();
62542:             if (win->mFocus) {
62542:                 win->mFocus->OnIMEEvent(ae);
44159:             } else {
44159:                 NS_WARNING("Sending unexpected IME event to top window");
56629:                 win->OnIMEEvent(ae);
44159:             }
43066:             break;
43066: 
59166:         case AndroidGeckoEvent::SURFACE_CREATED:
59166:             break;
59166: 
59166:         case AndroidGeckoEvent::SURFACE_DESTROYED:
59166:             sValidSurface = false;
59166:             break;
59166: 
63330:         case AndroidGeckoEvent::GECKO_EVENT_SYNC:
63330:             AndroidBridge::Bridge()->AcknowledgeEventSync();
63330:             break;
63330: 
43066:         default:
43066:             break;
43066:     }
43066: }
43066: 
43066: void
43066: nsWindow::OnAndroidEvent(AndroidGeckoEvent *ae)
43066: {
47827:     if (!AndroidBridge::Bridge())
47827:         return;
47827: 
43066:     switch (ae->Type()) {
43066:         case AndroidGeckoEvent::DRAW:
43066:             OnDraw(ae);
43066:             break;
43066: 
43066:         default:
43066:             ALOG("Window got targetted android event type %d, but didn't handle!", ae->Type());
43066:             break;
43066:     }
43066: }
43066: 
43066: PRBool
43066: nsWindow::DrawTo(gfxASurface *targetSurface)
43066: {
43066:     if (!mIsVisible)
43066:         return PR_FALSE;
43066: 
46261:     nsEventStatus status;
46261:     nsIntRect boundsRect(0, 0, mBounds.width, mBounds.height);
46261: 
46261:     // Figure out if any of our children cover this widget completely
46261:     PRInt32 coveringChildIndex = -1;
46261:     for (PRUint32 i = 0; i < mChildren.Length(); ++i) {
46261:         if (mChildren[i]->mBounds.IsEmpty())
46261:             continue;
46261: 
46261:         if (mChildren[i]->mBounds.Contains(boundsRect)) {
46261:             coveringChildIndex = PRInt32(i);
46261:         }
46261:     }
46261: 
46261:     // If we have no covering child, then we need to render this.
46261:     if (coveringChildIndex == -1) {
46392:         nsPaintEvent event(PR_TRUE, NS_PAINT, this);
46392:         event.region = boundsRect;
58812:         switch (GetLayerManager(nsnull)->GetBackendType()) {
46261:             case LayerManager::LAYERS_BASIC: {
43066:                 nsRefPtr<gfxContext> ctx = new gfxContext(targetSurface);
43066: 
43066:                 {
47746:                     AutoLayerManagerSetup
61092:                       setupLayerManager(this, ctx, BasicLayerManager::BUFFER_NONE);
46261:                     status = DispatchEvent(&event);
43066:                 }
43066: 
43066:                 // XXX uhh.. we can't just ignore this because we no longer have
43066:                 // what we needed before, but let's keep drawing the children anyway?
43066: #if 0
43066:                 if (status == nsEventStatus_eIgnore)
43066:                     return PR_FALSE;
43066: #endif
43066: 
43066:                 // XXX if we got an ignore for the parent, do we still want to draw the children?
43066:                 // We don't really have a good way not to...
46392:                 break;
46261:             }
43066: 
46261:             case LayerManager::LAYERS_OPENGL: {
58812:                 static_cast<mozilla::layers::LayerManagerOGL*>(GetLayerManager(nsnull))->
46261:                     SetClippingRegion(nsIntRegion(boundsRect));
46261: 
46261:                 status = DispatchEvent(&event);
46392:                 break;
46261:             }
46261: 
46261:             default:
46261:                 NS_ERROR("Invalid layer manager");
46261:         }
46261: 
46261:         // We had no covering child, so make sure we draw all the children,
46261:         // starting from index 0.
46261:         coveringChildIndex = 0;
46261:     }
46261: 
46261:     gfxPoint offset;
46261: 
46261:     if (targetSurface)
46261:         offset = targetSurface->GetDeviceOffset();
46261: 
46261:     for (PRUint32 i = coveringChildIndex; i < mChildren.Length(); ++i) {
46261:         if (mChildren[i]->mBounds.IsEmpty() ||
46392:             !mChildren[i]->mBounds.Intersects(boundsRect)) {
46261:             continue;
46261:         }
46261: 
46261:         if (targetSurface)
43066:             targetSurface->SetDeviceOffset(offset + gfxPoint(mChildren[i]->mBounds.x,
43066:                                                              mChildren[i]->mBounds.y));
46261: 
46261:         PRBool ok = mChildren[i]->DrawTo(targetSurface);
46261: 
46261:         if (!ok) {
43066:             ALOG("nsWindow[%p]::DrawTo child %d[%p] returned FALSE!", (void*) this, i, (void*)mChildren[i]);
43066:         }
43066:     }
43066: 
46261:     if (targetSurface)
43066:         targetSurface->SetDeviceOffset(offset);
43066: 
43066:     return PR_TRUE;
43066: }
43066: 
43066: void
43066: nsWindow::OnDraw(AndroidGeckoEvent *ae)
43066: {
43066:     if (!IsTopLevel()) {
43066:         ALOG("##### redraw for window %p, which is not a toplevel window -- sending to toplevel!", (void*) this);
43066:         DumpWindows();
43066:         return;
43066:     }
43066: 
43066:     if (!mIsVisible) {
43066:         ALOG("##### redraw for window %p, which is not visible -- ignoring!", (void*) this);
43066:         DumpWindows();
43066:         return;
43066:     }
43066: 
57134:     AndroidBridge::AutoLocalJNIFrame jniFrame;
57134: 
57134:     AndroidGeckoSurfaceView& sview(AndroidBridge::Bridge()->SurfaceView());
57134: 
57134:     NS_ASSERTION(!sview.isNull(), "SurfaceView is null!");
57134: 
57419:     AndroidBridge::Bridge()->HideProgressDialogOnce();
57419: 
58812:     if (GetLayerManager(nsnull)->GetBackendType() == LayerManager::LAYERS_BASIC) {
71892:         if (AndroidBridge::Bridge()->HasNativeBitmapAccess()) {
71892:             jobject bitmap = sview.GetSoftwareDrawBitmap();
71892:             if (!bitmap) {
71892:                 ALOG("no bitmap to draw into - skipping draw");
71892:                 return;
71892:             }
71892: 
71892:             if (!AndroidBridge::Bridge()->ValidateBitmap(bitmap, mBounds.width, mBounds.height))
71892:                 return;
71892: 
71892:             void *buf = AndroidBridge::Bridge()->LockBitmap(bitmap);
71892:             if (buf == nsnull) {
71892:                 ALOG("### Software drawing, but failed to lock bitmap.");
71892:                 return;
71892:             }
71892: 
71892:             nsRefPtr<gfxImageSurface> targetSurface =
71892:                 new gfxImageSurface((unsigned char *)buf,
71892:                                     gfxIntSize(mBounds.width, mBounds.height),
71892:                                     mBounds.width * 2,
71892:                                     gfxASurface::ImageFormatRGB16_565);
74333:             if (targetSurface->CairoStatus()) {
74333:                 ALOG("### Failed to create a valid surface from the bitmap");
74333:             } else {
71892:                 DrawTo(targetSurface);
74333:             }
71892: 
71892:             AndroidBridge::Bridge()->UnlockBitmap(bitmap);
71892:             sview.Draw2D(bitmap, mBounds.width, mBounds.height);
71892:         } else {
46392:             jobject bytebuf = sview.GetSoftwareDrawBuffer();
46392:             if (!bytebuf) {
46392:                 ALOG("no buffer to draw into - skipping draw");
46392:                 return;
46392:             }
46392: 
46392:             void *buf = AndroidBridge::JNI()->GetDirectBufferAddress(bytebuf);
46392:             int cap = AndroidBridge::JNI()->GetDirectBufferCapacity(bytebuf);
57134:             if (!buf || cap != (mBounds.width * mBounds.height * 2)) {
57134:                 ALOG("### Software drawing, but unexpected buffer size %d expected %d (or no buffer %p)!", cap, mBounds.width * mBounds.height * 2, buf);
46392:                 return;
46392:             }
46392: 
46392:             nsRefPtr<gfxImageSurface> targetSurface =
46392:                 new gfxImageSurface((unsigned char *)buf,
46392:                                     gfxIntSize(mBounds.width, mBounds.height),
46392:                                     mBounds.width * 2,
46392:                                     gfxASurface::ImageFormatRGB16_565);
74333:             if (targetSurface->CairoStatus()) {
74333:                 ALOG("### Failed to create a valid surface");
74333:             } else {
71892:                 DrawTo(targetSurface);
74333:             }
46392: 
57134:             sview.Draw2D(bytebuf, mBounds.width * 2);
71892:         }
46392:     } else {
43066:         int drawType = sview.BeginDrawing();
43066: 
43066:         if (drawType == AndroidGeckoSurfaceView::DRAW_ERROR) {
43066:             ALOG("##### BeginDrawing failed!");
43066:             return;
43066:         }
43066: 
59166:         if (!sValidSurface) {
59166:             sGLContext->RenewSurface();
59166:             sValidSurface = true;
59166:         }
59166: 
59166: 
46261:         NS_ASSERTION(sGLContext, "Drawing with GLES without a GL context?");
43066: 
46261:         DrawTo(nsnull);
46261: 
46392:         sview.EndDrawing();
43066:     }
43066: }
43066: 
43066: void
43066: nsWindow::OnSizeChanged(const gfxIntSize& aSize)
43066: {
43066:     int w = aSize.width;
43066:     int h = aSize.height;
43066: 
43066:     ALOG("nsWindow: %p OnSizeChanged [%d %d]", (void*)this, w, h);
43066: 
43066:     nsSizeEvent event(PR_TRUE, NS_SIZE, this);
43066:     InitEvent(event);
43066: 
43066:     nsIntRect wsz(0, 0, w, h);
43066:     event.windowSize = &wsz;
43066:     event.mWinWidth = w;
43066:     event.mWinHeight = h;
43066: 
43066:     mBounds.width = w;
43066:     mBounds.height = h;
43066: 
43066:     DispatchEvent(&event);
43066: }
43066: 
43066: void
43066: nsWindow::InitEvent(nsGUIEvent& event, nsIntPoint* aPoint)
43066: {
43066:     if (aPoint) {
43066:         event.refPoint.x = aPoint->x;
43066:         event.refPoint.y = aPoint->y;
43066:     } else {
43066:         event.refPoint.x = 0;
43066:         event.refPoint.y = 0;
43066:     }
43066: 
43066:     event.time = PR_Now() / 1000;
43066: }
43066: 
43066: gfxIntSize
60620: nsWindow::GetAndroidScreenBounds()
43066: {
58172:     if (XRE_GetProcessType() == GeckoProcessType_Content) {
58172:         return ContentChild::GetSingleton()->GetScreenSize();
58172:     }
60620:     return gAndroidScreenBounds;
43066: }
43066: 
43066: void *
43066: nsWindow::GetNativeData(PRUint32 aDataType)
43066: {
43066:     switch (aDataType) {
46261:         // used by GLContextProviderEGL, NULL is EGL_DEFAULT_DISPLAY
46261:         case NS_NATIVE_DISPLAY:
46261:             return NULL;
46261: 
43066:         case NS_NATIVE_WIDGET:
43066:             return (void *) this;
43066:     }
43066: 
43066:     return nsnull;
43066: }
43066: 
43066: void
43066: nsWindow::OnMotionEvent(AndroidGeckoEvent *ae)
43066: {
43066:     PRUint32 msg;
43066:     switch (ae->Action() & AndroidMotionEvent::ACTION_MASK) {
43066:         case AndroidMotionEvent::ACTION_DOWN:
43066:             msg = NS_MOUSE_BUTTON_DOWN;
43066:             break;
43066: 
43066:         case AndroidMotionEvent::ACTION_MOVE:
43066:             msg = NS_MOUSE_MOVE;
43066:             break;
43066: 
43066:         case AndroidMotionEvent::ACTION_UP:
43066:         case AndroidMotionEvent::ACTION_CANCEL:
43066:             msg = NS_MOUSE_BUTTON_UP;
43066:             break;
43066: 
43066:         default:
43066:             return;
43066:     }
43066: 
43066:     nsIntPoint pt(ae->P0());
43066:     nsIntPoint offset = WidgetToScreenOffset();
43066: 
43066:     //ALOG("#### motion pt: %d %d offset: %d %d", pt.x, pt.y, offset.x, offset.y);
43066: 
43066:     pt.x -= offset.x;
43066:     pt.y -= offset.y;
43066: 
43066:     // XXX possibly bound the range of pt here. some code may get confused.
43066: 
43066: send_again:
43066: 
43066:     nsMouseEvent event(PR_TRUE,
43066:                        msg, this,
43066:                        nsMouseEvent::eReal, nsMouseEvent::eNormal);
43066:     InitEvent(event, &pt);
43066: 
43066:     event.time = ae->Time();
59574:     event.isShift = !!(ae->MetaState() & AndroidKeyEvent::META_SHIFT_ON);
55938:     event.isControl = PR_FALSE;
43066:     event.isMeta = PR_FALSE;
59574:     event.isAlt = !!(ae->MetaState() & AndroidKeyEvent::META_ALT_ON);
43066: 
43066:     // XXX can we synthesize different buttons?
43066:     event.button = nsMouseEvent::eLeftButton;
43066: 
43066:     if (msg != NS_MOUSE_MOVE)
43066:         event.clickCount = 1;
43066: 
43066:     // XXX add the double-click handling logic here
43066: 
43066:     DispatchEvent(&event);
43066: 
43066:     if (msg == NS_MOUSE_BUTTON_DOWN) {
43066:         msg = NS_MOUSE_MOVE;
43066:         goto send_again;
43066:     }
43066: }
43066: 
47266: static double
51501: getDistance(const nsIntPoint &p1, const nsIntPoint &p2)
47266: {
51501:     double deltaX = p2.x - p1.x;
51501:     double deltaY = p2.y - p1.y;
47266:     return sqrt(deltaX*deltaX + deltaY*deltaY);
47266: }
47266: 
47266: void nsWindow::OnMultitouchEvent(AndroidGeckoEvent *ae)
47266: {
51501:     PRUint32 msg = 0;
47266: 
51501:     nsIntPoint midPoint;
51501:     midPoint.x = ((ae->P0().x + ae->P1().x) / 2);
51501:     midPoint.y = ((ae->P0().y + ae->P1().y) / 2);
51501:     nsIntPoint refPoint = midPoint - WidgetToScreenOffset();
51501: 
51501:     double pinchDist = getDistance(ae->P0(), ae->P1());
51501:     double pinchDelta = 0;
51501: 
47266:     switch (ae->Action() & AndroidMotionEvent::ACTION_MASK) {
51501:         case AndroidMotionEvent::ACTION_POINTER_DOWN:
51501:             msg = NS_SIMPLE_GESTURE_MAGNIFY_START;
51501:             mStartPoint = new nsIntPoint(midPoint);
51501:             mStartDist = mLastDist = pinchDist;
51501:             mGestureFinished = false;
51501:             break;
47266:         case AndroidMotionEvent::ACTION_MOVE:
47266:             msg = NS_SIMPLE_GESTURE_MAGNIFY_UPDATE;
51501:             pinchDelta = pinchDist - mLastDist;
51501:             mLastDist = pinchDist;
47266:             break;
47266:         case AndroidMotionEvent::ACTION_POINTER_UP:
47266:             msg = NS_SIMPLE_GESTURE_MAGNIFY;
51501:             pinchDelta = pinchDist - mStartDist;
51501:             mStartPoint = nsnull;
47266:             break;
47266:         default:
47266:             return;
47266:     }
47266: 
51501:     if (!mGestureFinished) {
51501:         DispatchGestureEvent(msg, 0, pinchDelta, refPoint, ae->Time());
51501: 
51501:         // If the cumulative pinch delta goes past the threshold, treat this
51501:         // as a pinch only, and not a swipe.
57857:         if (fabs(pinchDist - mStartDist) > mSwipeMaxPinchDelta)
51501:             mStartPoint = nsnull;
51501: 
51501:         // If we have traveled more than SWIPE_MIN_DISTANCE from the start
51501:         // point, stop the pinch gesture and fire a swipe event.
51501:         if (mStartPoint) {
51501:             double swipeDistance = getDistance(midPoint, *mStartPoint);
57857:             if (swipeDistance > mSwipeMinDistance) {
51501:                 PRUint32 direction = 0;
51501:                 nsIntPoint motion = midPoint - *mStartPoint;
51501: 
51501:                 if (motion.x < -swipeDistance/2)
51501:                     direction |= nsIDOMSimpleGestureEvent::DIRECTION_LEFT;
51501:                 if (motion.x > swipeDistance/2)
51501:                     direction |= nsIDOMSimpleGestureEvent::DIRECTION_RIGHT;
51501:                 if (motion.y < -swipeDistance/2)
51501:                     direction |= nsIDOMSimpleGestureEvent::DIRECTION_UP;
51501:                 if (motion.y > swipeDistance/2)
51501:                     direction |= nsIDOMSimpleGestureEvent::DIRECTION_DOWN;
51501: 
51501:                 // Finish the pinch gesture, then fire the swipe event:
51501:                 msg = NS_SIMPLE_GESTURE_MAGNIFY;
51501:                 DispatchGestureEvent(msg, 0, pinchDist - mStartDist, refPoint, ae->Time());
51501:                 msg = NS_SIMPLE_GESTURE_SWIPE;
51501:                 DispatchGestureEvent(msg, direction, 0, refPoint, ae->Time());
51501: 
51501:                 // Don't generate any more gesture events for this touch.
51501:                 mGestureFinished = true;
51501:             }
51501:         }
51501:     }
51501: }
51501: 
51501: void
51501: nsWindow::DispatchGestureEvent(PRUint32 msg, PRUint32 direction, double delta,
51501:                                const nsIntPoint &refPoint, PRUint64 time)
51501: {
51501:     nsSimpleGestureEvent event(PR_TRUE, msg, this, direction, delta);
47266: 
59574:     event.isShift = PR_FALSE;
55938:     event.isControl = PR_FALSE;
47266:     event.isMeta = PR_FALSE;
59574:     event.isAlt = PR_FALSE;
51501:     event.time = time;
51501:     event.refPoint = refPoint;
47266: 
47266:     DispatchEvent(&event);
47266: }
47266: 
43066: void
43066: nsWindow::InitKeyEvent(nsKeyEvent& event, AndroidGeckoEvent& key)
43066: {
43066:     switch (key.KeyCode()) {
43066:     case AndroidKeyEvent::KEYCODE_UNKNOWN:
43066:     case AndroidKeyEvent::KEYCODE_HOME:
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_BACK:
43066:         event.keyCode = NS_VK_ESCAPE;
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_CALL:
43066:     case AndroidKeyEvent::KEYCODE_ENDCALL:
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_0:
43066:     case AndroidKeyEvent::KEYCODE_1:
43066:     case AndroidKeyEvent::KEYCODE_2:
43066:     case AndroidKeyEvent::KEYCODE_3:
43066:     case AndroidKeyEvent::KEYCODE_4:
43066:     case AndroidKeyEvent::KEYCODE_5:
43066:     case AndroidKeyEvent::KEYCODE_6:
43066:     case AndroidKeyEvent::KEYCODE_7:
43066:     case AndroidKeyEvent::KEYCODE_8:
43066:     case AndroidKeyEvent::KEYCODE_9:
43066:         event.keyCode = key.KeyCode() - AndroidKeyEvent::KEYCODE_0 + NS_VK_0;
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_STAR:
43066:         event.keyCode = NS_VK_MULTIPLY;
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_POUND:
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_DPAD_UP:
43066:         event.keyCode = NS_VK_UP;
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_DPAD_DOWN:
43066:         event.keyCode = NS_VK_DOWN;
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_SOFT_LEFT:
43066:     case AndroidKeyEvent::KEYCODE_DPAD_LEFT:
43066:         event.keyCode = NS_VK_LEFT;
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_SOFT_RIGHT:
43066:     case AndroidKeyEvent::KEYCODE_DPAD_RIGHT:
43066:         event.keyCode = NS_VK_RIGHT;
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_VOLUME_UP:
43066:     case AndroidKeyEvent::KEYCODE_VOLUME_DOWN:
43066:     case AndroidKeyEvent::KEYCODE_POWER:
43066:     case AndroidKeyEvent::KEYCODE_CAMERA:
43066:     case AndroidKeyEvent::KEYCODE_CLEAR:
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_A:
43066:     case AndroidKeyEvent::KEYCODE_B:
43066:     case AndroidKeyEvent::KEYCODE_C:
43066:     case AndroidKeyEvent::KEYCODE_D:
43066:     case AndroidKeyEvent::KEYCODE_E:
43066:     case AndroidKeyEvent::KEYCODE_F:
43066:     case AndroidKeyEvent::KEYCODE_G:
43066:     case AndroidKeyEvent::KEYCODE_H:
43066:     case AndroidKeyEvent::KEYCODE_I:
43066:     case AndroidKeyEvent::KEYCODE_J:
43066:     case AndroidKeyEvent::KEYCODE_K:
43066:     case AndroidKeyEvent::KEYCODE_L:
43066:     case AndroidKeyEvent::KEYCODE_M:
43066:     case AndroidKeyEvent::KEYCODE_N:
43066:     case AndroidKeyEvent::KEYCODE_O:
43066:     case AndroidKeyEvent::KEYCODE_P:
43066:     case AndroidKeyEvent::KEYCODE_Q:
43066:     case AndroidKeyEvent::KEYCODE_R:
43066:     case AndroidKeyEvent::KEYCODE_S:
43066:     case AndroidKeyEvent::KEYCODE_T:
43066:     case AndroidKeyEvent::KEYCODE_U:
43066:     case AndroidKeyEvent::KEYCODE_V:
43066:     case AndroidKeyEvent::KEYCODE_W:
43066:     case AndroidKeyEvent::KEYCODE_X:
43066:     case AndroidKeyEvent::KEYCODE_Y:
43066:     case AndroidKeyEvent::KEYCODE_Z:
43066:         event.keyCode = key.KeyCode() - AndroidKeyEvent::KEYCODE_A + NS_VK_A;
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_COMMA:
43066:         event.keyCode = NS_VK_COMMA;
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_PERIOD:
43066:         event.keyCode = NS_VK_PERIOD;
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_ALT_LEFT:
43066:     case AndroidKeyEvent::KEYCODE_ALT_RIGHT:
43066:     case AndroidKeyEvent::KEYCODE_SHIFT_LEFT:
43066:     case AndroidKeyEvent::KEYCODE_SHIFT_RIGHT:
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_TAB:
43066:         event.keyCode = NS_VK_TAB;
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_SPACE:
43066:         event.keyCode = NS_VK_SPACE;
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_SYM:
43066:     case AndroidKeyEvent::KEYCODE_EXPLORER:
43066:     case AndroidKeyEvent::KEYCODE_ENVELOPE:
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_DPAD_CENTER:
43066:     case AndroidKeyEvent::KEYCODE_ENTER:
43066:         event.keyCode = NS_VK_RETURN;
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_DEL:
43066:         event.keyCode = NS_VK_BACK;
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_GRAVE:
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_MINUS:
43066:         event.keyCode = NS_VK_SUBTRACT;
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_EQUALS:
43066:         event.keyCode = NS_VK_EQUALS;
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_LEFT_BRACKET:
43066:         event.keyCode = NS_VK_OPEN_BRACKET;
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_RIGHT_BRACKET:
43066:         event.keyCode = NS_VK_CLOSE_BRACKET;
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_BACKSLASH:
43066:         event.keyCode = NS_VK_BACK_SLASH;
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_SEMICOLON:
43066:         event.keyCode = NS_VK_SEMICOLON;
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_APOSTROPHE:
43066:         event.keyCode = NS_VK_QUOTE;
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_SLASH:
43066:         event.keyCode = NS_VK_SLASH;
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_AT:
43066:     case AndroidKeyEvent::KEYCODE_NUM:
43066:     case AndroidKeyEvent::KEYCODE_HEADSETHOOK:
43066:     case AndroidKeyEvent::KEYCODE_FOCUS:
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_PLUS:
43066:         event.keyCode = NS_VK_ADD;
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_MENU:
43066:     case AndroidKeyEvent::KEYCODE_NOTIFICATION:
43066:     case AndroidKeyEvent::KEYCODE_SEARCH:
43066:     case AndroidKeyEvent::KEYCODE_MEDIA_PLAY_PAUSE:
43066:     case AndroidKeyEvent::KEYCODE_MEDIA_STOP:
43066:     case AndroidKeyEvent::KEYCODE_MEDIA_NEXT:
43066:     case AndroidKeyEvent::KEYCODE_MEDIA_PREVIOUS:
43066:     case AndroidKeyEvent::KEYCODE_MEDIA_REWIND:
43066:     case AndroidKeyEvent::KEYCODE_MEDIA_FAST_FORWARD:
43066:     case AndroidKeyEvent::KEYCODE_MUTE:
43066:         break;
43066:     default:
43066:         ALOG("Unknown key code!");
43066:         break;
43066:     }
43066: 
59574:     // Android gives us \n, so filter out some control characters.
59574:     if (event.message == NS_KEY_PRESS &&
59574:         key.UnicodeChar() >= ' ') {
43066:         event.charCode = key.UnicodeChar();
59574:         if (key.UnicodeChar())
59574:             event.keyCode = 0;
59574:     }
59574:     event.isShift = !!(key.MetaState() & AndroidKeyEvent::META_SHIFT_ON);
55938:     event.isControl = gMenu;
59574:     event.isAlt = !!(key.MetaState() & AndroidKeyEvent::META_ALT_ON);
43066:     event.isMeta = PR_FALSE;
43066:     event.time = key.Time();
55938: 
55938:     if (gMenu)
55938:         gMenuConsumed = PR_TRUE;
43066: }
43066: 
43066: void
43066: nsWindow::HandleSpecialKey(AndroidGeckoEvent *ae)
43066: {
43066:     nsCOMPtr<nsIAtom> command;
43066:     PRBool isDown = ae->Action() == AndroidKeyEvent::ACTION_DOWN;
57436:     PRBool isLongPress = !!(ae->Flags() & AndroidKeyEvent::FLAG_LONG_PRESS);
43066:     PRBool doCommand = PR_FALSE;
43066:     PRUint32 keyCode = ae->KeyCode();
43066: 
43066:     if (isDown) {
43066:         switch (keyCode) {
57436:             case AndroidKeyEvent::KEYCODE_BACK:
57436:                 if (isLongPress) {
57436:                     command = nsWidgetAtoms::Clear;
57436:                     doCommand = PR_TRUE;
57436:                 }
57436:                 break;
43066:             case AndroidKeyEvent::KEYCODE_VOLUME_UP:
43066:                 command = nsWidgetAtoms::VolumeUp;
43066:                 doCommand = PR_TRUE;
43066:                 break;
43066:             case AndroidKeyEvent::KEYCODE_VOLUME_DOWN:
43066:                 command = nsWidgetAtoms::VolumeDown;
43066:                 doCommand = PR_TRUE;
43066:                 break;
55938:             case AndroidKeyEvent::KEYCODE_MENU:
55938:                 gMenu = PR_TRUE;
57436:                 gMenuConsumed = isLongPress;
55938:                 break;
43066:         }
43066:     } else {
43066:         switch (keyCode) {
43066:             case AndroidKeyEvent::KEYCODE_BACK: {
43066:                 nsKeyEvent pressEvent(PR_TRUE, NS_KEY_PRESS, this);
43066:                 InitKeyEvent(pressEvent, *ae);
43066:                 DispatchEvent(&pressEvent);
43066:                 return;
43066:             }
43066:             case AndroidKeyEvent::KEYCODE_MENU:
55938:                 gMenu = PR_FALSE;
55938:                 if (!gMenuConsumed) {
43066:                     command = nsWidgetAtoms::Menu;
43066:                     doCommand = PR_TRUE;
55938:                 }
43066:                 break;
43066:             case AndroidKeyEvent::KEYCODE_SEARCH:
43066:                 command = nsWidgetAtoms::Search;
43066:                 doCommand = PR_TRUE;
43066:                 break;
43066:             default:
43066:                 ALOG("Unknown special key code!");
43066:                 return;
43066:         }
43066:     }
43066:     if (doCommand) {
43066:         nsCommandEvent event(PR_TRUE, nsWidgetAtoms::onAppCommand, command, this);
43066:         InitEvent(event);
43066:         DispatchEvent(&event);
43066:     }
43066: }
43066: 
43066: void
43066: nsWindow::OnKeyEvent(AndroidGeckoEvent *ae)
43066: {
43066:     PRUint32 msg;
43066:     switch (ae->Action()) {
43066:     case AndroidKeyEvent::ACTION_DOWN:
43066:         msg = NS_KEY_DOWN;
43066:         break;
43066:     case AndroidKeyEvent::ACTION_UP:
43066:         msg = NS_KEY_UP;
43066:         break;
43066:     case AndroidKeyEvent::ACTION_MULTIPLE:
43066:         {
43066:             nsTextEvent event(PR_TRUE, NS_TEXT_TEXT, this);
43066:             event.theText.Assign(ae->Characters());
43066:             DispatchEvent(&event);
43066:         }
43066:         return;
43066:     default:
43066:         ALOG("Unknown key action event!");
43066:         return;
43066:     }
43066: 
59574:     bool firePress = ae->Action() == AndroidKeyEvent::ACTION_DOWN;
43066:     switch (ae->KeyCode()) {
43066:     case AndroidKeyEvent::KEYCODE_SHIFT_LEFT:
43066:     case AndroidKeyEvent::KEYCODE_SHIFT_RIGHT:
43066:     case AndroidKeyEvent::KEYCODE_ALT_LEFT:
43066:     case AndroidKeyEvent::KEYCODE_ALT_RIGHT:
59574:         firePress = false;
43066:         break;
43066:     case AndroidKeyEvent::KEYCODE_BACK:
43066:     case AndroidKeyEvent::KEYCODE_MENU:
43066:     case AndroidKeyEvent::KEYCODE_SEARCH:
43066:     case AndroidKeyEvent::KEYCODE_VOLUME_UP:
43066:     case AndroidKeyEvent::KEYCODE_VOLUME_DOWN:
43066:         HandleSpecialKey(ae);
43066:         return;
43066:     }
43066: 
59574:     nsEventStatus status;
43066:     nsKeyEvent event(PR_TRUE, msg, this);
43066:     InitKeyEvent(event, *ae);
59574:     DispatchEvent(&event, status);
43066: 
59574:     if (!firePress)
59574:         return;
59574: 
43066:     nsKeyEvent pressEvent(PR_TRUE, NS_KEY_PRESS, this);
43066:     InitKeyEvent(pressEvent, *ae);
59574:     if (status == nsEventStatus_eConsumeNoDefault) {
59574:         pressEvent.flags |= NS_EVENT_FLAG_NO_DEFAULT;
59574:     }
43066: #ifdef ANDROID_DEBUG_WIDGET
59574:     __android_log_print(ANDROID_LOG_INFO, "Gecko", "Dispatching key pressEvent with keyCode %d charCode %d shift %d alt %d sym/ctrl %d metamask %d", pressEvent.keyCode, pressEvent.charCode, pressEvent.isShift, pressEvent.isAlt, pressEvent.isControl, ae->MetaState());
43066: #endif
43066:     DispatchEvent(&pressEvent);
43066: }
43066: 
48868: #ifdef ANDROID_DEBUG_IME
48868: #define ALOGIME(args...) ALOG(args)
48868: #else
48868: #define ALOGIME(args...)
48868: #endif
48868: 
48868: void
48868: nsWindow::OnIMEAddRange(AndroidGeckoEvent *ae)
43066: {
48868:     //ALOGIME("IME: IME_ADD_RANGE");
48868:     nsTextRange range;
48868:     range.mStartOffset = ae->Offset();
48868:     range.mEndOffset = range.mStartOffset + ae->Count();
48868:     range.mRangeType = ae->RangeType();
48868:     range.mRangeStyle.mDefinedStyles = ae->RangeStyles();
48868:     range.mRangeStyle.mLineStyle = nsTextRangeStyle::LINESTYLE_SOLID;
48868:     range.mRangeStyle.mForegroundColor = NS_RGBA(
48868:         ((ae->RangeForeColor() >> 16) & 0xff),
48868:         ((ae->RangeForeColor() >> 8) & 0xff),
48868:         (ae->RangeForeColor() & 0xff),
48868:         ((ae->RangeForeColor() >> 24) & 0xff));
48868:     range.mRangeStyle.mBackgroundColor = NS_RGBA(
48868:         ((ae->RangeBackColor() >> 16) & 0xff),
48868:         ((ae->RangeBackColor() >> 8) & 0xff),
48868:         (ae->RangeBackColor() & 0xff),
48868:         ((ae->RangeBackColor() >> 24) & 0xff));
48868:     mIMERanges.AppendElement(range);
48868:     return;
43066: }
43066: 
43066: void
43066: nsWindow::OnIMEEvent(AndroidGeckoEvent *ae)
43066: {
43066:     switch (ae->Action()) {
48868:     case AndroidGeckoEvent::IME_COMPOSITION_END:
43066:         {
48868:             ALOGIME("IME: IME_COMPOSITION_END");
43066:             nsCompositionEvent event(PR_TRUE, NS_COMPOSITION_END, this);
48868:             InitEvent(event, nsnull);
43066:             DispatchEvent(&event);
43066:         }
43066:         return;
48868:     case AndroidGeckoEvent::IME_COMPOSITION_BEGIN:
43066:         {
48868:             ALOGIME("IME: IME_COMPOSITION_BEGIN");
43066:             nsCompositionEvent event(PR_TRUE, NS_COMPOSITION_START, this);
48868:             InitEvent(event, nsnull);
43066:             DispatchEvent(&event);
48868:         }
48868:         return;
48868:     case AndroidGeckoEvent::IME_ADD_RANGE:
48868:         {
48868:             OnIMEAddRange(ae);
43066:         }
43066:         return;
43066:     case AndroidGeckoEvent::IME_SET_TEXT:
43066:         {
48868:             OnIMEAddRange(ae);
48868: 
43066:             nsTextEvent event(PR_TRUE, NS_TEXT_TEXT, this);
48868:             InitEvent(event, nsnull);
48868: 
43066:             event.theText.Assign(ae->Characters());
48868:             event.rangeArray = mIMERanges.Elements();
48868:             event.rangeCount = mIMERanges.Length();
48868: 
48868:             ALOGIME("IME: IME_SET_TEXT: l=%u, r=%u",
48868:                 event.theText.Length(), mIMERanges.Length());
48868: 
43066:             DispatchEvent(&event);
48868:             mIMERanges.Clear();
43066:         }
43066:         return;
43066:     case AndroidGeckoEvent::IME_GET_TEXT:
43066:         {
48868:             ALOGIME("IME: IME_GET_TEXT: o=%u, l=%u", ae->Offset(), ae->Count());
48868: 
48868:             nsQueryContentEvent event(PR_TRUE, NS_QUERY_TEXT_CONTENT, this);
48868:             InitEvent(event, nsnull);
48868: 
48868:             event.InitForQueryTextContent(ae->Offset(), ae->Count());
48868:             
48868:             DispatchEvent(&event);
48868: 
48868:             if (!event.mSucceeded) {
48868:                 ALOGIME("IME:     -> failed");
48868:                 AndroidBridge::Bridge()->ReturnIMEQueryResult(
48868:                     nsnull, 0, 0, 0);
43066:                 return;
50732:             } else if (!event.mWasAsync) {
48868:                 AndroidBridge::Bridge()->ReturnIMEQueryResult(
48868:                     event.mReply.mString.get(), 
48868:                     event.mReply.mString.Length(), 0, 0);
50732:             }
48868:             //ALOGIME("IME:     -> l=%u", event.mReply.mString.Length());
43066:         }
43066:         return;
43066:     case AndroidGeckoEvent::IME_DELETE_TEXT:
43066:         {   
48868:             ALOGIME("IME: IME_DELETE_TEXT");
50760:             nsKeyEvent event(PR_TRUE, NS_KEY_PRESS, this);
48868:             InitEvent(event, nsnull);
50760:             event.keyCode = NS_VK_BACK;
48868:             DispatchEvent(&event);
48868:         }
43066:         return;
48868:     case AndroidGeckoEvent::IME_SET_SELECTION:
48868:         {
48868:             ALOGIME("IME: IME_SET_SELECTION: o=%u, l=%d", ae->Offset(), ae->Count());
43066: 
48868:             nsSelectionEvent selEvent(PR_TRUE, NS_SELECTION_SET, this);
48868:             InitEvent(selEvent, nsnull);
48868: 
48868:             selEvent.mOffset = PRUint32(ae->Count() >= 0 ?
48868:                                         ae->Offset() :
48868:                                         ae->Offset() + ae->Count());
71173:             selEvent.mLength = PRUint32(NS_ABS(ae->Count()));
48868:             selEvent.mReversed = ae->Count() >= 0 ? PR_FALSE : PR_TRUE;
48868: 
48868:             DispatchEvent(&selEvent);
43066:         }
48868:         return;
48868:     case AndroidGeckoEvent::IME_GET_SELECTION:
48868:         {
48868:             ALOGIME("IME: IME_GET_SELECTION");
48868: 
48868:             nsQueryContentEvent event(PR_TRUE, NS_QUERY_SELECTED_TEXT, this);
48868:             InitEvent(event, nsnull);
48868:             DispatchEvent(&event);
48868: 
48868:             if (!event.mSucceeded) {
48868:                 ALOGIME("IME:     -> failed");
48868:                 AndroidBridge::Bridge()->ReturnIMEQueryResult(
48868:                     nsnull, 0, 0, 0);
48868:                 return;
50732:             } else if (!event.mWasAsync) {
48868:                 AndroidBridge::Bridge()->ReturnIMEQueryResult(
48868:                     event.mReply.mString.get(),
48868:                     event.mReply.mString.Length(), 
50732:                     event.GetSelectionStart(),
50732:                     event.GetSelectionEnd() - event.GetSelectionStart());
50732:             }
48868:             //ALOGIME("IME:     -> o=%u, l=%u", event.mReply.mOffset, event.mReply.mString.Length());
43066:         }
43066:         return;
43066:     }
43066: }
43066: 
43066: nsWindow *
43066: nsWindow::FindWindowForPoint(const nsIntPoint& pt)
43066: {
43066:     if (!mBounds.Contains(pt))
43066:         return nsnull;
43066: 
43066:     // children mBounds are relative to their parent
43066:     nsIntPoint childPoint(pt.x - mBounds.x, pt.y - mBounds.y);
43066: 
43066:     for (PRUint32 i = 0; i < mChildren.Length(); ++i) {
43066:         if (mChildren[i]->mBounds.Contains(childPoint))
43066:             return mChildren[i]->FindWindowForPoint(childPoint);
43066:     }
43066: 
43066:     return this;
43066: }
43066: 
43066: void
43066: nsWindow::UserActivity()
43066: {
43066:   if (!mIdleService) {
43066:     mIdleService = do_GetService("@mozilla.org/widget/idleservice;1");
43066:   }
43066: 
43066:   if (mIdleService) {
43066:     mIdleService->ResetIdleTimeOut();
43066:   }
43066: }
43066: 
43066: NS_IMETHODIMP
48868: nsWindow::ResetInputState()
48868: {
48868:     //ALOGIME("IME: ResetInputState: s=%d", aState);
48868: 
48868:     // Cancel composition on Gecko side
48868:     if (mIMEComposing) {
51142:         nsTextEvent textEvent(PR_TRUE, NS_TEXT_TEXT, this);
51142:         InitEvent(textEvent, nsnull);
51142:         textEvent.theText = mIMEComposingText;
51142:         DispatchEvent(&textEvent);
54609:         mIMEComposingText.Truncate(0);
51142: 
48868:         nsCompositionEvent event(PR_TRUE, NS_COMPOSITION_END, this);
48868:         InitEvent(event, nsnull);
48868:         DispatchEvent(&event);
48868:     }
48868: 
48959:     AndroidBridge::NotifyIME(AndroidBridge::NOTIFY_IME_RESETINPUTSTATE, 0);
48868:     return NS_OK;
48868: }
48868: 
48868: NS_IMETHODIMP
58017: nsWindow::SetInputMode(const IMEContext& aContext)
43066: {
68713:     ALOGIME("IME: SetInputMode: s=%d trusted=%d", aContext.mStatus, aContext.mReason);
48868: 
58019:     mIMEContext = aContext;
68713: 
68713:     // Ensure that opening the virtual keyboard is allowed for this specific
68713:     // IMEContext depending on the content.ime.strict.policy pref
68713:     if (aContext.mStatus != nsIWidget::IME_STATUS_DISABLED && 
68713:         aContext.mStatus != nsIWidget::IME_STATUS_PLUGIN) {
71384:       if (Preferences::GetBool("content.ime.strict_policy", PR_FALSE) &&
71384:           !aContext.FocusMovedByUser() &&
68713:           aContext.FocusMovedInContentProcess()) {
68713:         return NS_OK;
68713:       }
68713:     }
68713: 
58121:     AndroidBridge::NotifyIMEEnabled(int(aContext.mStatus), aContext.mHTMLInputType, aContext.mActionHint);
43066:     return NS_OK;
43066: }
43066: 
43066: NS_IMETHODIMP
58019: nsWindow::GetInputMode(IMEContext& aContext)
43066: {
58019:     aContext = mIMEContext;
43066:     return NS_OK;
43066: }
48868: 
48868: NS_IMETHODIMP
48868: nsWindow::CancelIMEComposition()
48868: {
48868:     ALOGIME("IME: CancelIMEComposition");
48868: 
48868:     // Cancel composition on Gecko side
48868:     if (mIMEComposing) {
48868:         nsTextEvent textEvent(PR_TRUE, NS_TEXT_TEXT, this);
48868:         InitEvent(textEvent, nsnull);
48868:         DispatchEvent(&textEvent);
54609:         mIMEComposingText.Truncate(0);
48868: 
48868:         nsCompositionEvent compEvent(PR_TRUE, NS_COMPOSITION_END, this);
48868:         InitEvent(compEvent, nsnull);
48868:         DispatchEvent(&compEvent);
48868:     }
48868: 
48959:     AndroidBridge::NotifyIME(AndroidBridge::NOTIFY_IME_CANCELCOMPOSITION, 0);
48868:     return NS_OK;
48868: }
48868: 
48868: NS_IMETHODIMP
48868: nsWindow::OnIMEFocusChange(PRBool aFocus)
48868: {
48868:     ALOGIME("IME: OnIMEFocusChange: f=%d", aFocus);
48868: 
48959:     AndroidBridge::NotifyIME(AndroidBridge::NOTIFY_IME_FOCUSCHANGE, 
48959:                              int(aFocus));
58197: 
58197:     if (aFocus) {
58197:         OnIMETextChange(0, 0, 0);
58197:         OnIMESelectionChange();
58197:     }
58197: 
48868:     return NS_OK;
48868: }
48868: 
48868: NS_IMETHODIMP
48868: nsWindow::OnIMETextChange(PRUint32 aStart, PRUint32 aOldEnd, PRUint32 aNewEnd)
48868: {
48868:     ALOGIME("IME: OnIMETextChange: s=%d, oe=%d, ne=%d",
48868:             aStart, aOldEnd, aNewEnd);
48868: 
58197:     // A quirk in Android makes it necessary to pass the whole text.
58197:     // The more efficient way would have been passing the substring from index
58197:     // aStart to index aNewEnd
48868: 
48868:     nsQueryContentEvent event(PR_TRUE, NS_QUERY_TEXT_CONTENT, this);
48868:     InitEvent(event, nsnull);
58197:     event.InitForQueryTextContent(0, PR_UINT32_MAX);
48868: 
48868:     DispatchEvent(&event);
48868:     if (!event.mSucceeded)
48868:         return NS_OK;
48868: 
48959:     AndroidBridge::NotifyIMEChange(event.mReply.mString.get(),
48868:                                    event.mReply.mString.Length(),
48868:                                    aStart, aOldEnd, aNewEnd);
58197: 
48868:     return NS_OK;
48868: }
48868: 
48868: NS_IMETHODIMP
48868: nsWindow::OnIMESelectionChange(void)
48868: {
48868:     ALOGIME("IME: OnIMESelectionChange");
48868: 
48868:     nsQueryContentEvent event(PR_TRUE, NS_QUERY_SELECTED_TEXT, this);
48868:     InitEvent(event, nsnull);
48868: 
48868:     DispatchEvent(&event);
48868:     if (!event.mSucceeded)
48868:         return NS_OK;
48868: 
48959:     AndroidBridge::NotifyIMEChange(nsnull, 0, int(event.mReply.mOffset),
48959:                                    int(event.mReply.mOffset + 
48959:                                        event.mReply.mString.Length()), -1);
48868:     return NS_OK;
48868: }
48868: 
54600: nsIMEUpdatePreference
54600: nsWindow::GetIMEUpdatePreference()
54600: {
54600:     return nsIMEUpdatePreference(PR_TRUE, PR_TRUE);
54600: }
54600: 
