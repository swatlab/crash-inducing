 82129: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 32723:  * vim: set ts=8 sw=4 et tw=79 ft=cpp:
 32723:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 32723: 
 32723: #ifndef jsscriptinlines_h___
 32723: #define jsscriptinlines_h___
 32723: 
 68894: #include "jsautooplen.h"
 59968: #include "jscntxt.h"
 32736: #include "jsfun.h"
 34290: #include "jsopcode.h"
 32738: #include "jsscript.h"
 59968: #include "jsscope.h"
 79981: 
 86483: #include "vm/ScopeObject.h"
 77343: #include "vm/GlobalObject.h"
 79981: #include "vm/RegExpObject.h"
 77343: 
 77343: #include "jsscopeinlines.h"
 76205: 
 59968: namespace js {
 59968: 
 83302: inline
 83302: Bindings::Bindings(JSContext *cx)
 93245:     : lastBinding(NULL), nargs(0), nvars(0), hasDup_(false)
 83302: {}
 83302: 
 59968: inline void
 59968: Bindings::transfer(JSContext *cx, Bindings *bindings)
 59968: {
 77343:     JS_ASSERT(!lastBinding);
 83221:     JS_ASSERT(!bindings->lastBinding || !bindings->lastBinding->inDictionary());
 59968: 
 59968:     *this = *bindings;
 59968: #ifdef DEBUG
 59968:     bindings->lastBinding = NULL;
 59968: #endif
 59968: }
 59968: 
 59968: inline void
 59968: Bindings::clone(JSContext *cx, Bindings *bindings)
 59968: {
 77343:     JS_ASSERT(!lastBinding);
 83221:     JS_ASSERT(!bindings->lastBinding || !bindings->lastBinding->inDictionary());
 59968: 
 59968:     *this = *bindings;
 59968: }
 59968: 
 64295: Shape *
 59968: Bindings::lastShape() const
 59968: {
 59968:     JS_ASSERT(lastBinding);
 83221:     JS_ASSERT(!lastBinding->inDictionary());
 59968:     return lastBinding;
 59968: }
 59968: 
 89745: Shape *
 89745: Bindings::initialShape(JSContext *cx) const
 89745: {
 89745:     /* Get an allocation kind to match an empty call object. */
100006:     gc::AllocKind kind = gc::FINALIZE_OBJECT4;
100006:     JS_ASSERT(gc::GetGCKindSlots(kind) == CallObject::RESERVED_SLOTS + 1);
 89745: 
 89745:     return EmptyShape::getInitialShape(cx, &CallClass, NULL, NULL, kind,
 89745:                                        BaseShape::VAROBJ);
 89745: }
 89745: 
 77343: bool
 77343: Bindings::ensureShape(JSContext *cx)
 77343: {
 77343:     if (!lastBinding) {
 89745:         lastBinding = initialShape(cx);
 77343:         if (!lastBinding)
 77343:             return false;
 77343:     }
 77343:     return true;
 77343: }
 77343: 
 83221: bool
 83221: Bindings::extensibleParents()
 83221: {
 83221:     return lastBinding && lastBinding->extensibleParents();
 83221: }
 83221: 
 84691: extern void
 91237: CurrentScriptFileLineOriginSlow(JSContext *cx, const char **file, unsigned *linenop, JSPrincipals **origin);
 68894: 
 84691: inline void
 91237: CurrentScriptFileLineOrigin(JSContext *cx, const char **file, unsigned *linenop, JSPrincipals **origin,
 84691:                             LineOption opt = NOT_CALLED_FROM_JSOP_EVAL)
 68894: {
 68894:     if (opt == CALLED_FROM_JSOP_EVAL) {
 84195:         JS_ASSERT(JSOp(*cx->regs().pc) == JSOP_EVAL);
 69223:         JS_ASSERT(*(cx->regs().pc + JSOP_EVAL_LENGTH) == JSOP_LINENO);
 84691:         JSScript *script = cx->fp()->script();
 84691:         *file = script->filename;
 69223:         *linenop = GET_UINT16(cx->regs().pc + JSOP_EVAL_LENGTH);
 84691:         *origin = script->originPrincipals;
 84691:         return;
 68894:     }
 68894: 
 84691:     CurrentScriptFileLineOriginSlow(cx, file, linenop, origin);
 68894: }
 68894: 
 84803: inline void
 94959: ScriptCounts::destroy(FreeOp *fop)
 84803: {
 94959:     fop->free_(pcCountsVector);
 84803: }
 84803: 
 97463: inline void
 97463: MarkScriptFilename(JSRuntime *rt, const char *filename)
 97463: {
 97463:     /*
 97463:      * As an invariant, a ScriptFilenameEntry should not be 'marked' outside of
 97463:      * a GC. Since SweepScriptFilenames is only called during a full gc,
 97463:      * to preserve this invariant, only mark during a full gc.
 97463:      */
 97463:     if (rt->gcIsFull)
 97463:         ScriptFilenameEntry::fromFilename(filename)->marked = true;
 97463: }
 97463: 
 59968: } // namespace js
 32736: 
 84726: inline void
 84726: JSScript::setFunction(JSFunction *fun)
 84726: {
 84726:     function_ = fun;
 84726: }
 84726: 
 32736: inline JSFunction *
 32736: JSScript::getFunction(size_t index)
 32736: {
 32736:     JSObject *funobj = getObject(index);
 83234:     JS_ASSERT(funobj->isFunction() && funobj->toFunction()->isInterpreted());
 83234:     return funobj->toFunction();
 32736: }
 32736: 
 75519: inline JSFunction *
 75519: JSScript::getCallerFunction()
 75519: {
 75519:     JS_ASSERT(savedCallerFun);
 75519:     return getFunction(0);
 75519: }
 75519: 
 32736: inline JSObject *
 32736: JSScript::getRegExp(size_t index)
 32736: {
 97362:     js::ObjectArray *arr = regexps();
 84755:     JS_ASSERT(uint32_t(index) < arr->length);
 32723:     JSObject *obj = arr->vector[index];
 77817:     JS_ASSERT(obj->isRegExp());
 32723:     return obj;
 32723: }
 32723: 
 34290: inline bool
 34290: JSScript::isEmpty() const
 34290: {
 59220:     if (length > 3)
 59220:         return false;
 56201: 
 34290:     jsbytecode *pc = code;
 34290:     if (noScriptRval && JSOp(*pc) == JSOP_FALSE)
 34290:         ++pc;
 59220:     return JSOp(*pc) == JSOP_STOP;
 34290: }
 34290: 
 77343: inline bool
 77343: JSScript::hasGlobal() const
 77343: {
 77343:     /*
 77343:      * Make sure that we don't try to query information about global objects
 77343:      * which have had their scopes cleared. compileAndGo code should not run
 77343:      * anymore against such globals.
 77343:      */
 77884:     JS_ASSERT(types && types->hasScope());
 77884:     js::GlobalObject *obj = types->global;
 77391:     return obj && !obj->isCleared();
 77343: }
 77343: 
 77343: inline js::GlobalObject *
 77343: JSScript::global() const
 77343: {
 77343:     JS_ASSERT(hasGlobal());
 77884:     return types->global;
 77343: }
 77343: 
 77343: inline bool
 77343: JSScript::hasClearedGlobal() const
 77343: {
 77884:     JS_ASSERT(types && types->hasScope());
 77884:     js::GlobalObject *obj = types->global;
 77391:     return obj && obj->isCleared();
 77343: }
 77343: 
 77884: inline js::types::TypeScriptNesting *
 77884: JSScript::nesting() const
 77884: {
 83256:     JS_ASSERT(function() && types && types->hasScope());
 77884:     return types->nesting;
 77884: }
 77884: 
 77884: inline void
 77884: JSScript::clearNesting()
 77884: {
 77884:     js::types::TypeScriptNesting *nesting = this->nesting();
 77884:     if (nesting) {
 77884:         js::Foreground::delete_(nesting);
 77884:         types->nesting = NULL;
 77884:     }
 77884: }
 77884: 
 99476: #ifdef JS_METHODJIT
 99476: inline bool
 99476: JSScript::ensureHasJITInfo(JSContext *cx)
 99476: {
 99476:     if (jitInfo)
 99476:         return true;
 99476:     jitInfo = cx->new_<JITScriptSet>();
 99476:     return jitInfo != NULL;
 99476: }
 99476: 
 99476: inline void
 99476: JSScript::destroyJITInfo(js::FreeOp *fop)
 99476: {
 99476:     fop->delete_(jitInfo);
 99476:     jitInfo = NULL;
 99476: }
 99476: #endif /* JS_METHODJIT */
 99476: 
 82129: inline void
 82129: JSScript::writeBarrierPre(JSScript *script)
 82129: {
 82129: #ifdef JSGC_INCREMENTAL
 82129:     if (!script)
 82129:         return;
 82129: 
 82129:     JSCompartment *comp = script->compartment();
 82129:     if (comp->needsBarrier()) {
 82129:         JS_ASSERT(!comp->rt->gcRunning);
 91557:         JSScript *tmp = script;
 91557:         MarkScriptUnbarriered(comp->barrierTracer(), &tmp, "write barrier");
 91557:         JS_ASSERT(tmp == script);
 82129:     }
 82129: #endif
 82129: }
 82129: 
 82129: inline void
 82129: JSScript::writeBarrierPost(JSScript *script, void *addr)
 82129: {
 82129: }
 82129: 
 32723: #endif /* jsscriptinlines_h___ */
