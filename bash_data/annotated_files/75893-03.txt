75615: /* -*- Mode: c++; c-basic-offset: 4; tab-width: 40; indent-tabs-mode: nil -*- */
75615: /* vim: set ts=40 sw=4 et tw=99: */
75615: /* ***** BEGIN LICENSE BLOCK *****
75615:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
75615:  *
75615:  * The contents of this file are subject to the Mozilla Public License Version
75615:  * 1.1 (the "License"); you may not use this file except in compliance with
75615:  * the License. You may obtain a copy of the License at
75615:  * http://www.mozilla.org/MPL/
75615:  *
75615:  * Software distributed under the License is distributed on an "AS IS" basis,
75615:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
75615:  * for the specific language governing rights and limitations under the
75615:  * License.
75615:  *
75615:  * The Original Code is the Mozilla SpiderMonkey bytecode type inference
75615:  *
75615:  * The Initial Developer of the Original Code is
75615:  *   Mozilla Foundation
75615:  * Portions created by the Initial Developer are Copyright (C) 2010
75615:  * the Initial Developer. All Rights Reserved.
75615:  *
75615:  * Contributor(s):
75615:  *   Brian Hackett <bhackett@mozilla.com>
75615:  *
75615:  * Alternatively, the contents of this file may be used under the terms of
75615:  * either of the GNU General Public License Version 2 or later (the "GPL"),
75615:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
75615:  * in which case the provisions of the GPL or the LGPL are applicable instead
75615:  * of those above. If you wish to allow use of your version of this file only
75615:  * under the terms of either the GPL or the LGPL, and not to allow others to
75615:  * use your version of this file under the terms of the MPL, indicate your
75615:  * decision by deleting the provisions above and replace them with the notice
75615:  * and other provisions required by the GPL or the LGPL. If you do not delete
75615:  * the provisions above, a recipient may use your version of this file under
75615:  * the terms of any one of the MPL, the GPL or the LGPL.
75615:  *
75615:  * ***** END LICENSE BLOCK ***** */
75615: 
75622: /* Inline members for javascript type inference. */
75615: 
75615: #include "jsanalyze.h"
75615: #include "jscompartment.h"
75615: #include "jsinfer.h"
75617: #include "jsprf.h"
75615: 
75615: #ifndef jsinferinlines_h___
75615: #define jsinferinlines_h___
75615: 
75615: /////////////////////////////////////////////////////////////////////
75615: // Types
75615: /////////////////////////////////////////////////////////////////////
75615: 
75615: namespace js {
75615: namespace types {
75615: 
75615: inline jstype
75615: GetValueType(JSContext *cx, const Value &val)
75615: {
75720:     JS_ASSERT(cx->typeInferenceEnabled());
75615:     if (val.isDouble())
75615:         return TYPE_DOUBLE;
75615:     switch (val.extractNonDoubleType()) {
75615:       case JSVAL_TYPE_INT32:
75615:         return TYPE_INT32;
75615:       case JSVAL_TYPE_UNDEFINED:
75615:         return TYPE_UNDEFINED;
75615:       case JSVAL_TYPE_BOOLEAN:
75615:         return TYPE_BOOLEAN;
75615:       case JSVAL_TYPE_STRING:
75615:         return TYPE_STRING;
75615:       case JSVAL_TYPE_NULL:
75615:         return TYPE_NULL;
75615:       case JSVAL_TYPE_OBJECT: {
75615:         JSObject *obj = &val.toObject();
75679:         JS_ASSERT(obj->type);
75679:         return (jstype) obj->type;
75615:       }
75615:       default:
75615:         JS_NOT_REACHED("Unknown value");
75615:         return (jstype) 0;
75615:     }
75615: }
75615: 
75615: /*
75615:  * Get the canonical representation of an id to use when doing inference.  This
75615:  * maintains the constraint that if two different jsids map to the same property
75615:  * in JS (e.g. 3 and "3"), they have the same type representation.
75615:  */
75615: inline jsid
75679: MakeTypeId(JSContext *cx, jsid id)
75615: {
75615:     /*
75615:      * All integers must map to the aggregate property for index types, including
75615:      * negative integers.
75615:      */
75615:     if (JSID_IS_INT(id))
75615:         return JSID_VOID;
75615: 
75615:     /*
75615:      * Check for numeric strings, as in js_StringIsIndex, but allow negative
75679:      * and overflowing integers.
75615:      */
75615:     if (JSID_IS_STRING(id)) {
75688:         JSFlatString *str = JSID_TO_FLAT_STRING(id);
75688:         const jschar *cp = str->getCharsZ(cx);
75615:         if (JS7_ISDEC(*cp) || *cp == '-') {
75615:             cp++;
75615:             while (JS7_ISDEC(*cp))
75615:                 cp++;
75615:             if (unsigned(cp - str->chars()) == str->length())
75615:                 return JSID_VOID;
75615:         }
75720:         return id;
75615:     }
75615: 
75615:     return JSID_VOID;
75615: }
75615: 
75682: const char * TypeIdStringImpl(jsid id);
75682: 
75638: /* Convert an id for printing during debug. */
75638: static inline const char *
75640: TypeIdString(jsid id)
75638: {
75638: #ifdef DEBUG
75657:     return TypeIdStringImpl(id);
75638: #else
75641:     return "(missing)";
75638: #endif
75638: }
75638: 
75720: /*
75720:  * Structure for type inference entry point functions. All functions which can
75720:  * change type information must use this, and functions which depend on
75720:  * intermediate types (i.e. JITs) can use this to ensure that intermediate
75720:  * information is not collected and does not change.
75720:  *
75720:  * Pins inference results so that intermediate type information, TypeObjects
75720:  * and JSScripts won't be collected during GC. Does additional sanity checking
75720:  * that inference is not reentrant and that recompilations occur properly.
75720:  */
75720: struct AutoEnterTypeInference
75720: {
75720:     JSContext *cx;
75720: #ifdef DEBUG
75720:     unsigned depth;
75720: #endif
75720: 
75720:     AutoEnterTypeInference(JSContext *cx, bool compiling = false)
75720:         : cx(cx)
75720:     {
75720: #ifdef DEBUG
75720:         depth = cx->compartment->types.inferenceDepth;
75720: #endif
75720:         JS_ASSERT_IF(!compiling, cx->compartment->types.inferenceEnabled);
75720:         if (cx->compartment->types.inferenceDepth++ == 0)
75720:             cx->compartment->types.inferenceStartTime = cx->compartment->types.currentTime();
75720:     }
75720: 
75720:     ~AutoEnterTypeInference()
75720:     {
75893:         /*
75893:          * This should have been reset by checkPendingRecompiles.
75893:          * :FIXME: be more tolerant and clean up anyways, the caller may be
75893:          * propagating an OOM or other error.
75893:          */
75720:         JS_ASSERT(cx->compartment->types.inferenceDepth == depth);
75720:     }
75720: };
75720: 
75720: bool
75720: TypeCompartment::checkPendingRecompiles(JSContext *cx)
75720: {
75720:     JS_ASSERT(inferenceDepth);
75720:     if (--inferenceDepth != 0) {
75720:         /*
75720:          * There is still a type inference activation on the stack, wait for it to
75720:          * finish before handling any recompilations. Note that we should not be
75720:          * invoking any scripted code while the inference is running :TODO: assert this.
75720:          */
75720:         return true;
75720:     }
75720:     if (inferenceStartTime)
75720:         analysisTime += currentTime() - inferenceStartTime;
75720:     inferenceStartTime = 0;
75720:     if (pendingNukeTypes)
75720:         return nukeTypes(cx);
75720:     else if (pendingRecompiles && !processPendingRecompiles(cx))
75720:         return false;
75720:     return true;
75720: }
75720: 
75893: /*
75893:  * Structure marking the currently compiled script, for constraints which can
75893:  * trigger recompilation.
75893:  */
75893: struct AutoEnterCompilation
75893: {
75893:     JSContext *cx;
75893:     JSScript *script;
75893: 
75893:     AutoEnterCompilation(JSContext *cx, JSScript *script)
75893:         : cx(cx), script(script)
75893:     {
75893:         JS_ASSERT(!cx->compartment->types.compiledScript);
75893:         cx->compartment->types.compiledScript = script;
75893:     }
75893: 
75893:     ~AutoEnterCompilation()
75893:     {
75893:         JS_ASSERT(cx->compartment->types.compiledScript == script);
75893:         cx->compartment->types.compiledScript = NULL;
75893:     }
75893: };
75893: 
75788: bool
75788: UseNewType(JSContext *cx, JSScript *script, jsbytecode *pc);
75788: 
75615: } } /* namespace js::types */
75615: 
75615: /////////////////////////////////////////////////////////////////////
75615: // JSContext
75615: /////////////////////////////////////////////////////////////////////
75615: 
75720: inline bool
75720: JSContext::typeInferenceEnabled()
75720: {
75720:     return compartment->types.inferenceEnabled;
75720: }
75720: 
75615: inline js::types::TypeObject *
75679: JSContext::getTypeNewObject(JSProtoKey key)
75615: {
75679:     JSObject *proto;
75679:     if (!js_GetClassPrototype(this, NULL, key, &proto, NULL))
75641:         return NULL;
75679:     return proto->getNewType(this);
75641: }
75641: 
75615: inline js::types::TypeObject *
75615: JSContext::getTypeCallerInitObject(bool isArray)
75615: {
75720:     if (typeInferenceEnabled()) {
75615:         JSStackFrame *caller = js_GetScriptedCaller(this, NULL);
75864:         if (caller && caller->script()->compartment == compartment) {
75864:             JSScript *script;
75864:             jsbytecode *pc = caller->inlinepc(this, &script);
75864:             return script->getTypeInitObject(this, pc, isArray);
75864:         }
75720:     }
75681:     return getTypeNewObject(isArray ? JSProto_Array : JSProto_Object);
75615: }
75615: 
75615: inline bool
75615: JSContext::markTypeCallerUnexpected(js::types::jstype type)
75615: {
75720:     if (!typeInferenceEnabled())
75720:         return true;
75783: 
75783:     /*
75783:      * Check that we are actually at a scripted callsite. This function is
75783:      * called from JS natives which can be called anywhere a script can be
75783:      * called, such as on property getters or setters. This filtering is not
75783:      * perfect, but we only need to make sure the type result is added wherever
75783:      * the native's type handler was used, i.e. at scripted callsites directly
75783:      * calling the native.
75783:      */
75783: 
75615:     JSStackFrame *caller = js_GetScriptedCaller(this, NULL);
75681:     if (!caller)
75720:         return true;
75783: 
75854:     /*
75854:      * Watch out if the caller is in a different compartment from this one.
75854:      * This must have gone through a cross-compartment wrapper.
75854:      */
75854:     if (caller->script()->compartment != compartment)
75854:         return true;
75854: 
75864:     JSScript *script;
75864:     jsbytecode *pc = caller->inlinepc(this, &script);
75864: 
75864:     switch ((JSOp)*pc) {
75783:       case JSOP_CALL:
75783:       case JSOP_EVAL:
75783:       case JSOP_FUNCALL:
75783:       case JSOP_FUNAPPLY:
75783:       case JSOP_NEW:
75783:         break;
75864:       case JSOP_ITER:
75864:         /* This is also used for handling custom iterators. */
75864:         break;
75783:       default:
75783:         return true;
75783:     }
75783: 
75864:     return script->typeMonitorResult(this, pc, type);
75615: }
75615: 
75720: inline bool
75615: JSContext::markTypeCallerUnexpected(const js::Value &value)
75615: {
75720:     return markTypeCallerUnexpected(js::types::GetValueType(this, value));
75615: }
75615: 
75720: inline bool
75615: JSContext::markTypeCallerOverflow()
75615: {
75720:     return markTypeCallerUnexpected(js::types::TYPE_DOUBLE);
75615: }
75615: 
75720: inline bool
75615: JSContext::addTypeProperty(js::types::TypeObject *obj, const char *name, js::types::jstype type)
75615: {
75732:     if (typeInferenceEnabled() && !obj->unknownProperties) {
75615:         jsid id = JSID_VOID;
75720:         if (name) {
75720:             JSAtom *atom = js_Atomize(this, name, strlen(name), 0);
75720:             if (!atom)
75720:                 return false;
75720:             id = ATOM_TO_JSID(atom);
75720:         }
75720:         return addTypePropertyId(obj, id, type);
75720:     }
75720:     return true;
75615: }
75615: 
75720: inline bool
75615: JSContext::addTypeProperty(js::types::TypeObject *obj, const char *name, const js::Value &value)
75615: {
75732:     if (typeInferenceEnabled() && !obj->unknownProperties)
75720:         return addTypeProperty(obj, name, js::types::GetValueType(this, value));
75720:     return true;
75615: }
75615: 
75720: inline bool
75615: JSContext::addTypePropertyId(js::types::TypeObject *obj, jsid id, js::types::jstype type)
75615: {
75732:     if (!typeInferenceEnabled() || obj->unknownProperties)
75720:         return true;
75720: 
75615:     /* Convert string index properties into the common index property. */
75679:     id = js::types::MakeTypeId(this, id);
75615: 
75720:     js::types::AutoEnterTypeInference enter(this);
75720: 
75641:     js::types::TypeSet *types = obj->getProperty(this, id, true);
75720:     if (!types || types->hasType(type))
75720:         return compartment->types.checkPendingRecompiles(this);
75615: 
75789:     js::types::InferSpew(js::types::ISpewOps, "externalType: property %s %s: %s",
75679:                          obj->name(), js::types::TypeIdString(id),
75640:                          js::types::TypeString(type));
75615:     types->addType(this, type);
75720: 
75720:     return compartment->types.checkPendingRecompiles(this);
75615: }
75615: 
75720: inline bool
75615: JSContext::addTypePropertyId(js::types::TypeObject *obj, jsid id, const js::Value &value)
75615: {
75732:     if (typeInferenceEnabled() && !obj->unknownProperties)
75720:         return addTypePropertyId(obj, id, js::types::GetValueType(this, value));
75720:     return true;
75699: }
75699: 
75794: inline bool
75794: JSContext::addTypePropertyId(js::types::TypeObject *obj, jsid id, js::types::ClonedTypeSet *set)
75794: {
75794:     if (obj->unknownProperties)
75794:         return true;
75794:     id = js::types::MakeTypeId(this, id);
75794: 
75794:     js::types::AutoEnterTypeInference enter(this);
75794: 
75794:     js::types::TypeSet *types = obj->getProperty(this, id, true);
75794:     if (!types)
75794:         return compartment->types.checkPendingRecompiles(this);
75794: 
75794:     js::types::InferSpew(js::types::ISpewOps, "externalType: property %s %s",
75794:                          obj->name(), js::types::TypeIdString(id));
75794:     types->addTypeSet(this, set);
75794: 
75794:     return compartment->types.checkPendingRecompiles(this);
75794: }
75794: 
75679: inline js::types::TypeObject *
75722: JSContext::getTypeEmpty()
75722: {
75760:     return &compartment->types.typeEmpty;
75679: }
75679: 
75720: inline bool
75615: JSContext::aliasTypeProperties(js::types::TypeObject *obj, jsid first, jsid second)
75615: {
75760:     if (!typeInferenceEnabled() || obj->unknownProperties)
75720:         return true;
75720: 
75720:     js::types::AutoEnterTypeInference enter(this);
75720: 
75679:     first = js::types::MakeTypeId(this, first);
75679:     second = js::types::MakeTypeId(this, second);
75615: 
75641:     js::types::TypeSet *firstTypes = obj->getProperty(this, first, true);
75641:     js::types::TypeSet *secondTypes = obj->getProperty(this, second, true);
75720:     if (!firstTypes || !secondTypes)
75720:         return false;
75615: 
75718:     firstTypes->addBaseSubset(this, obj, secondTypes);
75718:     secondTypes->addBaseSubset(this, obj, firstTypes);
75720: 
75720:     return compartment->types.checkPendingRecompiles(this);
75615: }
75615: 
75720: inline bool
75720: JSContext::markTypeArrayNotPacked(js::types::TypeObject *obj, bool notDense)
75625: {
75720:     if (!typeInferenceEnabled() || (notDense ? !obj->isDenseArray : !obj->isPackedArray))
75720:         return true;
75720:     js::types::AutoEnterTypeInference enter(this);
75625: 
75720:     obj->markNotPacked(this, notDense);
75720: 
75720:     return compartment->types.checkPendingRecompiles(this);
75640: }
75640: 
75864: inline bool
75864: JSContext::markTypeFunctionUninlineable(js::types::TypeObject *obj)
75864: {
75864:     if (!typeInferenceEnabled() || obj->isUninlineable)
75864:         return true;
75864:     js::types::AutoEnterTypeInference enter(this);
75864: 
75864:     obj->markUninlineable(this);
75864: 
75864:     return compartment->types.checkPendingRecompiles(this);
75864: }
75864: 
75864: inline bool
75720: JSContext::markTypeObjectUnknownProperties(js::types::TypeObject *obj)
75720: {
75720:     if (!typeInferenceEnabled() || obj->unknownProperties)
75720:         return true;
75720: 
75720:     js::types::AutoEnterTypeInference enter(this);
75720:     obj->markUnknown(this);
75720:     return compartment->types.checkPendingRecompiles(this);
75625: }
75636: 
75720: inline bool
75720: JSContext::typeMonitorAssign(JSObject *obj, jsid id, const js::Value &rval)
75720: {
75720:     if (typeInferenceEnabled())
75720:         return compartment->types.dynamicAssign(this, obj, id, rval);
75720:     return true;
75625: }
75625: 
75720: inline bool
75720: JSContext::typeMonitorCall(const js::CallArgs &args, bool constructing)
75627: {
75720:     if (!typeInferenceEnabled() || !args.callee().isObject())
75720:         return true;
75627: 
75720:     JSObject *callee = &args.callee().toObject();
75720:     if (!callee->isFunction() || !callee->getFunctionPrivate()->isInterpreted())
75720:         return true;
75615: 
75720:     return compartment->types.dynamicCall(this, callee, args, constructing);
75641: }
75641: 
75770: inline bool
75770: JSContext::fixArrayType(JSObject *obj)
75770: {
75770:     return !typeInferenceEnabled() || compartment->types.fixArrayType(this, obj);
75770: }
75770: 
75770: inline bool
75770: JSContext::fixObjectType(JSObject *obj)
75770: {
75770:     return !typeInferenceEnabled() || compartment->types.fixObjectType(this, obj);
75770: }
75770: 
75615: /////////////////////////////////////////////////////////////////////
75615: // JSScript
75615: /////////////////////////////////////////////////////////////////////
75615: 
75718: inline bool
75718: JSScript::ensureVarTypes(JSContext *cx)
75718: {
75718:     if (varTypes)
75718:         return true;
75718:     return makeVarTypes(cx);
75718: }
75718: 
75718: inline js::types::TypeSet *
75718: JSScript::returnTypes()
75718: {
75718:     JS_ASSERT(varTypes);
75718:     return &varTypes[0];
75718: }
75718: 
75718: inline js::types::TypeSet *
75718: JSScript::thisTypes()
75718: {
75718:     JS_ASSERT(varTypes);
75718:     return &varTypes[1];
75718: }
75718: 
75718: inline js::types::TypeSet *
75718: JSScript::argTypes(unsigned i)
75718: {
75718:     JS_ASSERT(varTypes && fun && i < fun->nargs);
75718:     return &varTypes[2 + i];
75718: }
75718: 
75718: inline js::types::TypeSet *
75718: JSScript::localTypes(unsigned i)
75718: {
75718:     JS_ASSERT(varTypes && i < nfixed);
75718:     if (fun)
75718:         i += fun->nargs;
75718:     return &varTypes[2 + i];
75718: }
75718: 
75718: inline js::types::TypeSet *
75718: JSScript::upvarTypes(unsigned i)
75718: {
75718:     JS_ASSERT(varTypes && i < bindings.countUpvars());
75718:     if (fun)
75718:         i += fun->nargs;
75718:     return &varTypes[2 + nfixed + i];
75718: }
75718: 
75708: inline JSObject *
75708: JSScript::getGlobal()
75708: {
75718:     JS_ASSERT(compileAndGo && global);
75708:     return global;
75708: }
75708: 
75708: inline js::types::TypeObject *
75708: JSScript::getGlobalType()
75708: {
75708:     return getGlobal()->getType();
75708: }
75708: 
75708: inline js::types::TypeObject *
75708: JSScript::getTypeNewObject(JSContext *cx, JSProtoKey key)
75708: {
75708:     JSObject *proto;
75708:     if (!js_GetClassPrototype(cx, getGlobal(), key, &proto, NULL))
75708:         return NULL;
75708:     return proto->getNewType(cx);
75708: }
75708: 
75615: inline js::types::TypeObject *
75615: JSScript::getTypeInitObject(JSContext *cx, const jsbytecode *pc, bool isArray)
75615: {
75720:     if (!cx->typeInferenceEnabled() || !compileAndGo)
75686:         return cx->getTypeNewObject(isArray ? JSProto_Array : JSProto_Object);
75708: 
75708:     uint32 offset = pc - code;
75718:     js::types::TypeObject *prev = NULL, *obj = typeObjects;
75708:     while (obj) {
75708:         if (isArray ? obj->initializerArray : obj->initializerObject) {
75708:             if (obj->initializerOffset == offset) {
75708:                 /* Move this to the head of the objects list, maintain LRU order. */
75708:                 if (prev) {
75708:                     prev->next = obj->next;
75718:                     obj->next = typeObjects;
75718:                     typeObjects = obj;
75708:                 }
75708:                 return obj;
75708:             }
75708:         }
75708:         prev = obj;
75708:         obj = obj->next;
75708:     }
75708: 
75708:     return cx->compartment->types.newInitializerTypeObject(cx, this, offset, isArray);
75615: }
75615: 
75720: inline bool
75718: JSScript::typeMonitorResult(JSContext *cx, const jsbytecode *pc,
75633:                             js::types::jstype type)
75615: {
75720:     if (cx->typeInferenceEnabled())
75720:         return cx->compartment->types.dynamicPush(cx, this, pc - code, type);
75720:     return true;
75615: }
75615: 
75720: inline bool
75718: JSScript::typeMonitorResult(JSContext *cx, const jsbytecode *pc, const js::Value &rval)
75615: {
75720:     if (cx->typeInferenceEnabled())
75720:         return typeMonitorResult(cx, pc, js::types::GetValueType(cx, rval));
75720:     return true;
75615: }
75615: 
75720: inline bool
75718: JSScript::typeMonitorOverflow(JSContext *cx, const jsbytecode *pc)
75633: {
75720:     return typeMonitorResult(cx, pc, js::types::TYPE_DOUBLE);
75633: }
75633: 
75720: inline bool
75718: JSScript::typeMonitorUndefined(JSContext *cx, const jsbytecode *pc)
75633: {
75720:     return typeMonitorResult(cx, pc, js::types::TYPE_UNDEFINED);
75718: }
75718: 
75720: inline bool
75820: JSScript::typeMonitorString(JSContext *cx, const jsbytecode *pc)
75820: {
75820:     return typeMonitorResult(cx, pc, js::types::TYPE_STRING);
75820: }
75820: 
75820: inline bool
75718: JSScript::typeMonitorUnknown(JSContext *cx, const jsbytecode *pc)
75718: {
75720:     return typeMonitorResult(cx, pc, js::types::TYPE_UNKNOWN);
75633: }
75633: 
75720: inline bool
75720: JSScript::typeSetThis(JSContext *cx, js::types::jstype type)
75615: {
75720:     JS_ASSERT(cx->typeInferenceEnabled());
75720:     if (!ensureVarTypes(cx))
75720:         return false;
75723: 
75723:     /* Analyze the script regardless if -a was used. */
75723:     bool analyze = !types && cx->hasRunOption(JSOPTION_METHODJIT_ALWAYS) && !isUncachedEval;
75723: 
75723:     if (!thisTypes()->hasType(type) || analyze) {
75720:         js::types::AutoEnterTypeInference enter(cx);
75615: 
75789:         js::types::InferSpew(js::types::ISpewOps, "externalType: setThis #%u: %s",
75720:                              id(), js::types::TypeString(type));
75720:         thisTypes()->addType(cx, type);
75720: 
75733:         if (analyze && !types)
75723:             js::types::AnalyzeScriptTypes(cx, this);
75723: 
75720:         return cx->compartment->types.checkPendingRecompiles(cx);
75720:     }
75723: 
75720:     return true;
75615: }
75615: 
75720: inline bool
75791: JSScript::typeSetThis(JSContext *cx, const js::Value &value)
75791: {
75791:     if (cx->typeInferenceEnabled())
75791:         return typeSetThis(cx, js::types::GetValueType(cx, value));
75791:     return true;
75791: }
75791: 
75791: inline bool
75794: JSScript::typeSetThis(JSContext *cx, js::types::ClonedTypeSet *set)
75794: {
75794:     if (!ensureVarTypes(cx))
75794:         return false;
75794:     js::types::AutoEnterTypeInference enter(cx);
75794: 
75812:     js::types::InferSpew(js::types::ISpewOps, "externalType: setThis #%u", id());
75794:     thisTypes()->addTypeSet(cx, set);
75794: 
75794:     return cx->compartment->types.checkPendingRecompiles(cx);
75794: }
75794: 
75794: inline bool
75768: JSScript::typeSetNewCalled(JSContext *cx)
75768: {
75768:     if (!cx->typeInferenceEnabled() || calledWithNew)
75768:         return true;
75768:     calledWithNew = true;
75768: 
75768:     /*
75768:      * Determining the 'this' type used when the script is invoked with 'new'
75768:      * happens during the script's prologue, so we don't try to pick it up from
75768:      * dynamic calls. Instead, generate constraints modeling the construction
75768:      * of 'this' when the script is analyzed or reanalyzed after an invoke with 'new',
75768:      * and if 'new' is first invoked after the script has already been analyzed.
75768:      */
75768:     if (analyzed) {
75768:         /* Regenerate types for the function. */
75768:         js::types::AutoEnterTypeInference enter(cx);
75768:         js::types::AnalyzeScriptNew(cx, this);
75768:         if (!cx->compartment->types.checkPendingRecompiles(cx))
75768:             return false;
75768:     }
75768:     return true;
75768: }
75768: 
75768: inline bool
75775: JSScript::typeSetLocal(JSContext *cx, unsigned local, js::types::jstype type)
75720: {
75720:     if (!cx->typeInferenceEnabled())
75720:         return true;
75720:     if (!ensureVarTypes(cx))
75720:         return false;
75720:     if (!localTypes(local)->hasType(type)) {
75720:         js::types::AutoEnterTypeInference enter(cx);
75720: 
75789:         js::types::InferSpew(js::types::ISpewOps, "externalType: setLocal #%u %u: %s",
75720:                              id(), local, js::types::TypeString(type));
75720:         localTypes(local)->addType(cx, type);
75720: 
75720:         return compartment->types.checkPendingRecompiles(cx);
75720:     }
75720:     return true;
75720: }
75720: 
75720: inline bool
75775: JSScript::typeSetLocal(JSContext *cx, unsigned local, const js::Value &value)
75775: {
75775:     if (cx->typeInferenceEnabled()) {
75775:         js::types::jstype type = js::types::GetValueType(cx, value);
75775:         return typeSetLocal(cx, local, type);
75775:     }
75775:     return true;
75775: }
75775: 
75775: inline bool
75794: JSScript::typeSetLocal(JSContext *cx, unsigned local, js::types::ClonedTypeSet *set)
75794: {
75794:     if (!ensureVarTypes(cx))
75794:         return false;
75794:     js::types::AutoEnterTypeInference enter(cx);
75794: 
75794:     js::types::InferSpew(js::types::ISpewOps, "externalType: setLocal #%u %u", id(), local);
75794:     localTypes(local)->addTypeSet(cx, set);
75794: 
75794:     return compartment->types.checkPendingRecompiles(cx);
75794: }
75794: 
75794: inline bool
75720: JSScript::typeSetArgument(JSContext *cx, unsigned arg, js::types::jstype type)
75720: {
75720:     if (!cx->typeInferenceEnabled())
75720:         return true;
75720:     if (!ensureVarTypes(cx))
75720:         return false;
75720:     if (!argTypes(arg)->hasType(type)) {
75720:         js::types::AutoEnterTypeInference enter(cx);
75720: 
75789:         js::types::InferSpew(js::types::ISpewOps, "externalType: setArg #%u %u: %s",
75720:                              id(), arg, js::types::TypeString(type));
75720:         argTypes(arg)->addType(cx, type);
75720: 
75720:         return cx->compartment->types.checkPendingRecompiles(cx);
75720:     }
75720:     return true;
75720: }
75720: 
75720: inline bool
75615: JSScript::typeSetArgument(JSContext *cx, unsigned arg, const js::Value &value)
75615: {
75720:     if (cx->typeInferenceEnabled()) {
75615:         js::types::jstype type = js::types::GetValueType(cx, value);
75720:         return typeSetArgument(cx, arg, type);
75718:     }
75720:     return true;
75718: }
75718: 
75720: inline bool
75794: JSScript::typeSetArgument(JSContext *cx, unsigned arg, js::types::ClonedTypeSet *set)
75794: {
75794:     if (!ensureVarTypes(cx))
75794:         return false;
75794:     js::types::AutoEnterTypeInference enter(cx);
75794: 
75794:     js::types::InferSpew(js::types::ISpewOps, "externalType: setArg #%u %u", id(), arg);
75794:     argTypes(arg)->addTypeSet(cx, set);
75794: 
75794:     return cx->compartment->types.checkPendingRecompiles(cx);
75794: }
75794: 
75794: inline bool
75718: JSScript::typeSetUpvar(JSContext *cx, unsigned upvar, const js::Value &value)
75718: {
75720:     if (!cx->typeInferenceEnabled())
75720:         return true;
75718:     if (!ensureVarTypes(cx))
75720:         return false;
75718:     js::types::jstype type = js::types::GetValueType(cx, value);
75718:     if (!upvarTypes(upvar)->hasType(type)) {
75720:         js::types::AutoEnterTypeInference enter(cx);
75720: 
75789:         js::types::InferSpew(js::types::ISpewOps, "externalType: setUpvar #%u %u: %s",
75718:                              id(), upvar, js::types::TypeString(type));
75720:         upvarTypes(upvar)->addType(cx, type);
75720: 
75720:         return cx->compartment->types.checkPendingRecompiles(cx);
75615:     }
75720:     return true;
75615: }
75615: 
75615: namespace js {
75708: namespace types {
75615: 
75615: /////////////////////////////////////////////////////////////////////
75615: // TypeCompartment
75615: /////////////////////////////////////////////////////////////////////
75615: 
75615: inline void
75615: TypeCompartment::addPending(JSContext *cx, TypeConstraint *constraint, TypeSet *source, jstype type)
75615: {
75615:     JS_ASSERT(this == &cx->compartment->types);
75615:     JS_ASSERT(type);
75750:     JS_ASSERT(!cx->runtime->gcRunning);
75615: 
75718:     InferSpew(ISpewOps, "pending: C%p %s", constraint, TypeString(type));
75615: 
75615:     if (pendingCount == pendingCapacity)
75718:         growPendingArray(cx);
75615: 
75615:     PendingWork &pending = pendingArray[pendingCount++];
75615:     pending.constraint = constraint;
75615:     pending.source = source;
75615:     pending.type = type;
75615: }
75615: 
75615: inline void
75615: TypeCompartment::resolvePending(JSContext *cx)
75615: {
75615:     JS_ASSERT(this == &cx->compartment->types);
75615: 
75615:     if (resolving) {
75615:         /* There is an active call further up resolving the worklist. */
75615:         return;
75615:     }
75615: 
75615:     resolving = true;
75615: 
75615:     /* Handle all pending type registrations. */
75615:     while (pendingCount) {
75615:         const PendingWork &pending = pendingArray[--pendingCount];
75718:         InferSpew(ISpewOps, "resolve: C%p %s",
75718:                   pending.constraint, TypeString(pending.type));
75615:         pending.constraint->newType(cx, pending.source, pending.type);
75615:     }
75615: 
75615:     resolving = false;
75615: }
75615: 
75615: /////////////////////////////////////////////////////////////////////
75615: // TypeSet
75615: /////////////////////////////////////////////////////////////////////
75615: 
75615: /*
75615:  * The sets of objects and scripts in a type set grow monotonically, are usually
75615:  * empty, almost always small, and sometimes big.  For empty or singleton sets,
75615:  * the pointer refers directly to the value.  For sets fitting into SET_ARRAY_SIZE,
75615:  * an array of this length is used to store the elements.  For larger sets, a hash
75615:  * table filled to 25%-50% of capacity is used, with collisions resolved by linear
75615:  * probing.  TODO: replace these with jshashtables.
75615:  */
75615: const unsigned SET_ARRAY_SIZE = 8;
75615: 
75615: /* Get the capacity of a set with the given element count. */
75615: static inline unsigned
75615: HashSetCapacity(unsigned count)
75615: {
75615:     JS_ASSERT(count >= 2);
75615: 
75615:     if (count <= SET_ARRAY_SIZE)
75615:         return SET_ARRAY_SIZE;
75615: 
75615:     unsigned log2;
75615:     JS_FLOOR_LOG2(log2, count);
75615:     return 1 << (log2 + 2);
75615: }
75615: 
75615: /* Compute the FNV hash for the low 32 bits of v. */
75641: template <class T, class KEY>
75615: static inline uint32
75641: HashKey(T v)
75615: {
75641:     uint32 nv = KEY::keyBits(v);
75615: 
75615:     uint32 hash = 84696351 ^ (nv & 0xff);
75615:     hash = (hash * 16777619) ^ ((nv >> 8) & 0xff);
75615:     hash = (hash * 16777619) ^ ((nv >> 16) & 0xff);
75615:     return (hash * 16777619) ^ ((nv >> 24) & 0xff);
75615: }
75615: 
75615: /*
75641:  * Insert space for an element into the specified set and grow its capacity if needed.
75641:  * returned value is an existing or new entry (NULL if new).
75615:  */
75641: template <class T, class U, class KEY>
75720: static U **
75720: HashSetInsertTry(JSContext *cx, U **&values, unsigned &count, T key, bool pool)
75615: {
75615:     unsigned capacity = HashSetCapacity(count);
75641:     unsigned insertpos = HashKey<T,KEY>(key) & (capacity - 1);
75615: 
75641:     /* Whether we are converting from a fixed array to hashtable. */
75641:     bool converting = (count == SET_ARRAY_SIZE);
75615: 
75641:     if (!converting) {
75641:         while (values[insertpos] != NULL) {
75641:             if (KEY::getKey(values[insertpos]) == key)
75720:                 return &values[insertpos];
75641:             insertpos = (insertpos + 1) & (capacity - 1);
75615:         }
75615:     }
75615: 
75615:     count++;
75615:     unsigned newCapacity = HashSetCapacity(count);
75615: 
75641:     if (newCapacity == capacity) {
75641:         JS_ASSERT(!converting);
75720:         return &values[insertpos];
75641:     }
75641: 
75720:     U **newValues = pool
75720:         ? ArenaArray<U*>(cx->compartment->types.pool, newCapacity)
75750:         : (U **) ::js_malloc(newCapacity * sizeof(U*));
75720:     if (!newValues) {
75720:         cx->compartment->types.setPendingNukeTypes(cx);
75720:         return NULL;
75720:     }
75720:     PodZero(newValues, newCapacity);
75615: 
75615:     for (unsigned i = 0; i < capacity; i++) {
75615:         if (values[i]) {
75641:             unsigned pos = HashKey<T,KEY>(KEY::getKey(values[i])) & (newCapacity - 1);
75615:             while (newValues[pos] != NULL)
75615:                 pos = (pos + 1) & (newCapacity - 1);
75615:             newValues[pos] = values[i];
75615:         }
75615:     }
75615: 
75720:     if (values && !pool)
75750:         ::js_free(values);
75615:     values = newValues;
75615: 
75641:     insertpos = HashKey<T,KEY>(key) & (newCapacity - 1);
75641:     while (values[insertpos] != NULL)
75641:         insertpos = (insertpos + 1) & (newCapacity - 1);
75720:     return &values[insertpos];
75615: }
75615: 
75615: /*
75641:  * Insert an element into the specified set if it is not already there, returning
75641:  * an entry which is NULL if the element was not there.
75615:  */
75641: template <class T, class U, class KEY>
75720: static inline U **
75720: HashSetInsert(JSContext *cx, U **&values, unsigned &count, T key, bool pool)
75615: {
75615:     if (count == 0) {
75641:         JS_ASSERT(values == NULL);
75615:         count++;
75720:         return (U **) &values;
75615:     }
75615: 
75615:     if (count == 1) {
75641:         U *oldData = (U*) values;
75720:         if (KEY::getKey(oldData) == key)
75720:             return (U **) &values;
75720: 
75720:         values = pool
75720:             ? ArenaArray<U*>(cx->compartment->types.pool, SET_ARRAY_SIZE)
75750:             : (U **) ::js_malloc(SET_ARRAY_SIZE * sizeof(U*));
75720:         if (!values) {
75720:             values = (U **) oldData;
75720:             cx->compartment->types.setPendingNukeTypes(cx);
75720:             return NULL;
75641:         }
75720:         PodZero(values, SET_ARRAY_SIZE);
75641:         count++;
75615: 
75615:         values[0] = oldData;
75720:         return &values[1];
75615:     }
75615: 
75615:     if (count <= SET_ARRAY_SIZE) {
75615:         for (unsigned i = 0; i < count; i++) {
75641:             if (KEY::getKey(values[i]) == key)
75720:                 return &values[i];
75615:         }
75615: 
75615:         if (count < SET_ARRAY_SIZE) {
75641:             count++;
75720:             return &values[count - 1];
75641:         }
75615:     }
75615: 
75720:     return HashSetInsertTry<T,U,KEY>(cx, values, count, key, pool);
75615: }
75615: 
75641: /* Lookup an entry in a hash set, return NULL if it does not exist. */
75641: template <class T, class U, class KEY>
75641: static inline U *
75641: HashSetLookup(U **values, unsigned count, T key)
75615: {
75615:     if (count == 0)
75641:         return NULL;
75615: 
75615:     if (count == 1)
75641:         return (KEY::getKey((U *) values) == key) ? (U *) values : NULL;
75615: 
75615:     if (count <= SET_ARRAY_SIZE) {
75615:         for (unsigned i = 0; i < count; i++) {
75641:             if (KEY::getKey(values[i]) == key)
75641:                 return values[i];
75615:         }
75641:         return NULL;
75615:     }
75615: 
75615:     unsigned capacity = HashSetCapacity(count);
75641:     unsigned pos = HashKey<T,KEY>(key) & (capacity - 1);
75615: 
75615:     while (values[pos] != NULL) {
75641:         if (KEY::getKey(values[pos]) == key)
75641:             return values[pos];
75615:         pos = (pos + 1) & (capacity - 1);
75615:     }
75615: 
75641:     return NULL;
75615: }
75615: 
75641: struct TypeObjectKey {
75713:     static intptr_t keyBits(TypeObject *obj) { return (intptr_t) obj; }
75641:     static TypeObject *getKey(TypeObject *obj) { return obj; }
75641: };
75641: 
75720: inline void
75720: TypeSet::destroy(JSContext *cx)
75720: {
75720:     JS_ASSERT(!(typeFlags & TYPE_FLAG_INTERMEDIATE_SET));
75720:     if (objectCount >= 2)
75750:         ::js_free(objectSet);
75736:     while (constraintList) {
75736:         TypeConstraint *next = constraintList->next;
75736:         if (constraintList->condensed() || constraintList->baseSubset())
75750:             ::js_free(constraintList);
75736:         constraintList = next;
75736:     }
75720: }
75720: 
75615: inline bool
75615: TypeSet::hasType(jstype type)
75615: {
75697:     if (unknown())
75615:         return true;
75615: 
75718:     if (type == TYPE_UNKNOWN) {
75718:         return false;
75718:     } else if (TypeIsPrimitive(type)) {
75615:         return ((1 << type) & typeFlags) != 0;
75641:     } else {
75641:         return HashSetLookup<TypeObject*,TypeObject,TypeObjectKey>
75641:             (objectSet, objectCount, (TypeObject *) type) != NULL;
75615:     }
75615: }
75615: 
75615: inline void
75761: TypeSet::markUnknown(JSContext *cx)
75761: {
75761:     typeFlags = TYPE_FLAG_UNKNOWN | (typeFlags & TYPE_FLAG_INTERMEDIATE_SET);
75761:     if (objectCount >= 2 && !(typeFlags & TYPE_FLAG_INTERMEDIATE_SET))
75761:         cx->free(objectSet);
75761:     objectCount = 0;
75761:     objectSet = NULL;
75761: }
75761: 
75761: inline void
75615: TypeSet::addType(JSContext *cx, jstype type)
75615: {
75615:     JS_ASSERT(type);
75720:     JS_ASSERT(cx->compartment->types.inferenceDepth);
75615: 
75697:     if (unknown())
75615:         return;
75615: 
75615:     if (type == TYPE_UNKNOWN) {
75761:         markUnknown(cx);
75615:     } else if (TypeIsPrimitive(type)) {
75615:         TypeFlags flag = 1 << type;
75615:         if (typeFlags & flag)
75615:             return;
75615: 
75615:         /* If we add float to a type set it is also considered to contain int. */
75615:         if (flag == TYPE_FLAG_DOUBLE)
75615:             flag |= TYPE_FLAG_INT32;
75615: 
75615:         typeFlags |= flag;
75615:     } else {
75615:         TypeObject *object = (TypeObject*) type;
75720:         TypeObject **pentry = HashSetInsert<TypeObject *,TypeObject,TypeObjectKey>
75720:                                   (cx, objectSet, objectCount, object,
75720:                                    typeFlags & TYPE_FLAG_INTERMEDIATE_SET);
75720:         if (!pentry || *pentry)
75615:             return;
75720:         *pentry = object;
75761: 
75761:         object->contribution += objectCount;
75761:         if (object->contribution >= TypeObject::CONTRIBUTION_LIMIT) {
75761:             InferSpew(ISpewOps, "limitUnknown: T%p", this);
75761:             type = TYPE_UNKNOWN;
75761:             markUnknown(cx);
75761:         }
75615:     }
75615: 
75812:     InferSpew(ISpewOps, "addType: T%p %s", this, TypeString(type));
75812: 
75615:     /* Propagate the type to all constraints. */
75615:     TypeConstraint *constraint = constraintList;
75615:     while (constraint) {
75854:         JS_ASSERT_IF(!constraint->baseSubset(),
75854:                      constraint->script->compartment == cx->compartment);
75615:         cx->compartment->types.addPending(cx, constraint, this, type);
75615:         constraint = constraint->next;
75615:     }
75615: 
75615:     cx->compartment->types.resolvePending(cx);
75615: }
75615: 
75615: inline TypeSet *
75720: TypeSet::make(JSContext *cx, const char *name)
75615: {
75720:     JS_ASSERT(cx->compartment->types.inferenceDepth);
75720: 
75720:     TypeSet *res = ArenaNew<TypeSet>(cx->compartment->types.pool);
75720:     if (!res) {
75720:         cx->compartment->types.setPendingNukeTypes(cx);
75720:         return NULL;
75720:     }
75720: 
75789:     InferSpew(ISpewOps, "typeSet: T%p intermediate %s", res, name);
75720:     res->setIntermediate();
75615: 
75615:     return res;
75615: }
75615: 
75615: /////////////////////////////////////////////////////////////////////
75615: // TypeCallsite
75615: /////////////////////////////////////////////////////////////////////
75615: 
75615: inline
75720: TypeCallsite::TypeCallsite(JSContext *cx, JSScript *script, const jsbytecode *pc,
75708:                            bool isNew, unsigned argumentCount)
75708:     : script(script), pc(pc), isNew(isNew), argumentCount(argumentCount),
75615:       thisTypes(NULL), thisType(0), returnTypes(NULL)
75615: {
75720:     /* Caller must check for failure. */
75720:     argumentTypes = ArenaArray<TypeSet*>(cx->compartment->types.pool, argumentCount);
75615: }
75615: 
75720: inline bool
75615: TypeCallsite::forceThisTypes(JSContext *cx)
75615: {
75615:     if (thisTypes)
75720:         return true;
75720:     thisTypes = TypeSet::make(cx, "site_this");
75720:     if (thisTypes)
75615:         thisTypes->addType(cx, thisType);
75720:     return thisTypes != NULL;
75615: }
75615: 
75615: inline TypeObject *
75615: TypeCallsite::getInitObject(JSContext *cx, bool isArray)
75615: {
75720:     TypeObject *type = script->getTypeInitObject(cx, pc, isArray);
75720:     if (!type)
75720:         cx->compartment->types.setPendingNukeTypes(cx);
75720:     return type;
75615: }
75615: 
75688: inline bool
75688: TypeCallsite::compileAndGo()
75688: {
75708:     return script->compileAndGo;
75688: }
75688: 
75615: /////////////////////////////////////////////////////////////////////
75641: // TypeObject
75615: /////////////////////////////////////////////////////////////////////
75615: 
75615: inline TypeSet *
75641: TypeObject::getProperty(JSContext *cx, jsid id, bool assign)
75615: {
75720:     JS_ASSERT(cx->compartment->types.inferenceDepth);
75679:     JS_ASSERT(JSID_IS_VOID(id) || JSID_IS_EMPTY(id) || JSID_IS_STRING(id));
75615:     JS_ASSERT_IF(JSID_IS_STRING(id), JSID_TO_STRING(id) != NULL);
75760:     JS_ASSERT(!unknownProperties);
75615: 
75720:     Property **pprop = HashSetInsert<jsid,Property,Property>
75720:                            (cx, propertySet, propertyCount, id, false);
75720:     if (!pprop || (!*pprop && !addProperty(cx, id, pprop)))
75720:         return NULL;
75641: 
75720:     return assign ? &(*pprop)->ownTypes : &(*pprop)->types;
75615: }
75615: 
75708: /////////////////////////////////////////////////////////////////////
75708: // TypeScript
75708: /////////////////////////////////////////////////////////////////////
75641: 
75708: inline bool
75708: TypeScript::monitored(uint32 offset)
75641: {
75708:     JS_ASSERT(offset < script->length);
75708:     return 0x1 & (size_t) pushedArray[offset];
75641: }
75641: 
75708: inline void
75708: TypeScript::setMonitored(uint32 offset)
75708: {
75720:     JS_ASSERT(script->compartment->types.inferenceDepth);
75708:     JS_ASSERT(offset < script->length);
75708:     pushedArray[offset] = (TypeSet *) (0x1 | (size_t) pushedArray[offset]);
75708: }
75708: 
75708: inline TypeSet *
75708: TypeScript::pushed(uint32 offset)
75708: {
75708:     JS_ASSERT(offset < script->length);
75708:     return (TypeSet *) (~0x1 & (size_t) pushedArray[offset]);
75708: }
75708: 
75708: inline TypeSet *
75708: TypeScript::pushed(uint32 offset, uint32 index)
75708: {
75708:     JS_ASSERT(offset < script->length);
75708:     JS_ASSERT(index < js::analyze::GetDefCount(script, offset));
75708:     return pushed(offset) + index;
75708: }
75708: 
75708: inline void
75708: TypeScript::addType(JSContext *cx, uint32 offset, uint32 index, jstype type)
75708: {
75708:     TypeSet *types = pushed(offset, index);
75708:     types->addType(cx, type);
75708: }
75708: 
75679: inline const char *
75679: TypeObject::name()
75679: {
75679: #ifdef DEBUG
75679:     return TypeIdString(name_);
75679: #else
75679:     return NULL;
75679: #endif
75679: }
75679: 
75718: inline TypeObject::TypeObject(jsid name, JSObject *proto)
75679:     : proto(proto), emptyShapes(NULL), isFunction(false), marked(false),
75708:       initializerObject(false), initializerArray(false), initializerOffset(0),
75761:       contribution(0), propertySet(NULL), propertyCount(0),
75718:       instanceList(NULL), instanceNext(NULL), next(NULL), unknownProperties(false),
75864:       isDenseArray(false), isPackedArray(false),
75864:       isUninlineable(false), hasSpecialEquality(false),
75845:       singleton(NULL)
75679: {
75679: #ifdef DEBUG
75679:     this->name_ = name;
75679: #endif
75679: 
75679:     InferSpew(ISpewOps, "newObject: %s", this->name());
75679: 
75679:     if (proto) {
75679:         TypeObject *prototype = proto->getType();
75844:         if (prototype->unknownProperties) {
75864:             isUninlineable = true;
75844:             hasSpecialEquality = true;
75679:             unknownProperties = true;
75844:         }
75679:         instanceNext = prototype->instanceList;
75679:         prototype->instanceList = this;
75679:     }
75679: }
75679: 
75718: inline TypeFunction::TypeFunction(jsid name, JSObject *proto)
75718:     : TypeObject(name, proto), handler(NULL), script(NULL), isGeneric(false)
75679: {
75679:     isFunction = true;
75679: }
75679: 
75776: inline void
75794: SweepClonedTypes(ClonedTypeSet *types)
75776: {
75794:     if (types->objectCount >= 2) {
75794:         for (unsigned i = 0; i < types->objectCount; i++) {
75794:             if (!types->objectSet[i]->marked)
75794:                 types->objectSet[i--] = types->objectSet[--types->objectCount];
75794:         }
75794:         if (types->objectCount == 1) {
75819:             TypeObject *obj = types->objectSet[0];
75794:             ::js_free(types->objectSet);
75794:             types->objectSet = (TypeObject **) obj;
75794:         } else if (types->objectCount == 0) {
75794:             ::js_free(types->objectSet);
75794:             types->objectSet = NULL;
75794:         }
75794:     } else if (types->objectCount == 1) {
75794:         TypeObject *obj = (TypeObject *) types->objectSet;
75794:         if (!obj->marked) {
75794:             types->objectSet = NULL;
75794:             types->objectCount = 0;
75794:         }
75794:     }
75776: }
75776: 
75679: } } /* namespace js::types */
75679: 
75615: #endif // jsinferinlines_h___
