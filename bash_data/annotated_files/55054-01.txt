    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* struct containing the input to nsIFrame::Reflow */
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsCSSAnonBoxes.h"
    1: #include "nsFrame.h"
    1: #include "nsIContent.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsPresContext.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsIRenderingContext.h"
    1: #include "nsIFontMetrics.h"
    1: #include "nsBlockFrame.h"
    1: #include "nsLineBox.h"
    1: #include "nsImageFrame.h"
    1: #include "nsTableFrame.h"
 2543: #include "nsTableCellFrame.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIPercentHeightObserver.h"
    1: #include "nsContentUtils.h"
    1: #include "nsLayoutUtils.h"
    1: #ifdef IBMBIDI
    1: #include "nsBidiUtils.h"
    1: #endif
    1: 
    1: #ifdef NS_DEBUG
    1: #undef NOISY_VERTICAL_ALIGN
    1: #else
    1: #undef NOISY_VERTICAL_ALIGN
    1: #endif
    1: 
39965: using namespace mozilla;
39965: 
    1: // Prefs-driven control for |text-decoration: blink|
    1: static PRPackedBool sPrefIsLoaded = PR_FALSE;
    1: static PRPackedBool sBlinkIsAllowed = PR_TRUE;
    1: 
    1: enum eNormalLineHeightControl {
    1:   eUninitialized = -1,
    1:   eNoExternalLeading = 0,   // does not include external leading 
    1:   eIncludeExternalLeading,  // use whatever value font vendor provides
    1:   eCompensateLeading        // compensate leading if leading provided by font vendor is not enough
    1: };
    1: 
    1: static eNormalLineHeightControl sNormalLineHeightControl = eUninitialized;
    1: 
    1: // Initialize a <b>root</b> reflow state with a rendering context to
    1: // use for measuring things.
    1: nsHTMLReflowState::nsHTMLReflowState(nsPresContext*       aPresContext,
    1:                                      nsIFrame*            aFrame,
    1:                                      nsIRenderingContext* aRenderingContext,
    1:                                      const nsSize&        aAvailableSpace)
    1:   : nsCSSOffsetState(aFrame, aRenderingContext)
11744:   , mBlockDelta(0)
    1:   , mReflowDepth(0)
    1: {
    1:   NS_PRECONDITION(aPresContext, "no pres context");
    1:   NS_PRECONDITION(aRenderingContext, "no rendering context");
    1:   NS_PRECONDITION(aFrame, "no frame");
    1:   parentReflowState = nsnull;
    1:   availableWidth = aAvailableSpace.width;
    1:   availableHeight = aAvailableSpace.height;
23305:   mFloatManager = nsnull;
    1:   mLineLayout = nsnull;
    1:   mFlags.mSpecialHeightReflow = PR_FALSE;
    1:   mFlags.mIsTopOfPage = PR_FALSE;
    1:   mFlags.mTableIsSplittable = PR_FALSE;
    1:   mFlags.mNextInFlowUntouched = PR_FALSE;
    1:   mFlags.mAssumingHScrollbar = mFlags.mAssumingVScrollbar = PR_FALSE;
    1:   mFlags.mHasClearance = PR_FALSE;
12040:   mFlags.mHeightDependsOnAncestorCell = PR_FALSE;
    1:   mDiscoveredClearance = nsnull;
    1:   mPercentHeightObserver = nsnull;
    1:   Init(aPresContext);
    1: }
    1: 
    1: static PRBool CheckNextInFlowParenthood(nsIFrame* aFrame, nsIFrame* aParent)
    1: {
    1:   nsIFrame* frameNext = aFrame->GetNextInFlow();
    1:   nsIFrame* parentNext = aParent->GetNextInFlow();
    1:   return frameNext && parentNext && frameNext->GetParent() == parentNext;
    1: }
    1: 
    1: // Initialize a reflow state for a child frames reflow. Some state
    1: // is copied from the parent reflow state; the remaining state is
    1: // computed.
    1: nsHTMLReflowState::nsHTMLReflowState(nsPresContext*           aPresContext,
    1:                                      const nsHTMLReflowState& aParentReflowState,
    1:                                      nsIFrame*                aFrame,
    1:                                      const nsSize&            aAvailableSpace,
    1:                                      nscoord                  aContainingBlockWidth,
    1:                                      nscoord                  aContainingBlockHeight,
    1:                                      PRBool                   aInit)
    1:   : nsCSSOffsetState(aFrame, aParentReflowState.rendContext)
11744:   , mBlockDelta(0)
    1:   , mReflowDepth(aParentReflowState.mReflowDepth + 1)
    1:   , mFlags(aParentReflowState.mFlags)
    1: {
    1:   NS_PRECONDITION(aPresContext, "no pres context");
    1:   NS_PRECONDITION(aFrame, "no frame");
    1:   NS_PRECONDITION((aContainingBlockWidth == -1) ==
    1:                     (aContainingBlockHeight == -1),
    1:                   "cb width and height should only be non-default together");
    1:   NS_PRECONDITION(aInit == PR_TRUE || aInit == PR_FALSE,
    1:                   "aInit out of range for PRBool");
    1:   NS_PRECONDITION(!mFlags.mSpecialHeightReflow ||
 1158:                   !NS_SUBTREE_DIRTY(aFrame),
    1:                   "frame should be clean when getting special height reflow");
    1: 
    1:   parentReflowState = &aParentReflowState;
    1: 
    1:   // If the parent is dirty, then the child is as well.
    1:   // XXX Are the other cases where the parent reflows a child a second
    1:   // time, as a resize?
    1:   if (!mFlags.mSpecialHeightReflow)
    1:     frame->AddStateBits(parentReflowState->frame->GetStateBits() &
    1:                         NS_FRAME_IS_DIRTY);
    1: 
    1:   availableWidth = aAvailableSpace.width;
    1:   availableHeight = aAvailableSpace.height;
    1: 
23305:   mFloatManager = aParentReflowState.mFloatManager;
 1588:   if (frame->IsFrameOfType(nsIFrame::eLineParticipant))
    1:     mLineLayout = aParentReflowState.mLineLayout;
 1588:   else
 1588:     mLineLayout = nsnull;
    1:   mFlags.mIsTopOfPage = aParentReflowState.mFlags.mIsTopOfPage;
    1:   mFlags.mNextInFlowUntouched = aParentReflowState.mFlags.mNextInFlowUntouched &&
    1:     CheckNextInFlowParenthood(aFrame, aParentReflowState.frame);
    1:   mFlags.mAssumingHScrollbar = mFlags.mAssumingVScrollbar = PR_FALSE;
    1:   mFlags.mHasClearance = PR_FALSE;
    1:   mDiscoveredClearance = nsnull;
    1:   mPercentHeightObserver = (aParentReflowState.mPercentHeightObserver && 
    1:                             aParentReflowState.mPercentHeightObserver->NeedsToObserve(*this)) 
    1:                            ? aParentReflowState.mPercentHeightObserver : nsnull;
    1: 
    1:   if (aInit) {
    1:     Init(aPresContext, aContainingBlockWidth, aContainingBlockHeight);
    1:   }
    1: }
    1: 
 1068: inline nscoord
 1068: nsCSSOffsetState::ComputeWidthValue(nscoord aContainingBlockWidth,
 1068:                                     nscoord aContentEdgeToBoxSizing,
 1068:                                     nscoord aBoxSizingToMarginEdge,
 1068:                                     const nsStyleCoord& aCoord)
 1068: {
 1068:   return nsLayoutUtils::ComputeWidthValue(rendContext, frame,
 1068:                                           aContainingBlockWidth,
 1068:                                           aContentEdgeToBoxSizing,
 1068:                                           aBoxSizingToMarginEdge,
 1068:                                           aCoord);
 1068: }
 1068: 
 1068: nscoord
 1068: nsCSSOffsetState::ComputeWidthValue(nscoord aContainingBlockWidth,
 1068:                                     PRUint8 aBoxSizing,
 1068:                                     const nsStyleCoord& aCoord)
 1068: {
 1068:   nscoord inside = 0, outside = mComputedBorderPadding.LeftRight() +
 1068:                                 mComputedMargin.LeftRight();
 1068:   switch (aBoxSizing) {
 1068:     case NS_STYLE_BOX_SIZING_BORDER:
 1068:       inside = mComputedBorderPadding.LeftRight();
 1068:       break;
 1068:     case NS_STYLE_BOX_SIZING_PADDING:
 1068:       inside = mComputedPadding.LeftRight();
 1068:       break;
 1068:   }
 1068:   outside -= inside;
 1068: 
 1068:   return ComputeWidthValue(aContainingBlockWidth, inside,
 1068:                            outside, aCoord);
 1068: }
 1068: 
    1: void
    1: nsHTMLReflowState::SetComputedWidth(nscoord aComputedWidth)
    1: {
    1:   NS_ASSERTION(frame, "Must have a frame!");
    1:   // It'd be nice to assert that |frame| is not in reflow, but this fails for
    1:   // two reasons:
    1:   //
    1:   // 1) Viewport frames reset the computed width on a copy of their reflow
    1:   //    state when reflowing fixed-pos kids.  In that case we actually don't
    1:   //    want to mess with the resize flags, because comparing the frame's rect
    1:   //    to the munged computed width is pointless.
    1:   // 2) nsFrame::BoxReflow creates a reflow state for its parent.  This reflow
    1:   //    state is not used to reflow the parent, but just as a parent for the
    1:   //    frame's own reflow state.  So given a nsBoxFrame inside some non-XUL
    1:   //    (like a text control, for example), we'll end up creating a reflow
    1:   //    state for the parent while the parent is reflowing.
    1: 
 1107:   NS_PRECONDITION(aComputedWidth >= 0, "Invalid computed width");
 1107:   if (mComputedWidth != aComputedWidth) {
    1:     mComputedWidth = aComputedWidth;
 1107:     if (frame->GetType() != nsGkAtoms::viewportFrame) { // Or check GetParent()?
  238:       InitResizeFlags(frame->PresContext());
    1:     }
    1:   }
 1107: }
    1: 
    1: void
 4166: nsHTMLReflowState::SetComputedHeight(nscoord aComputedHeight)
 4166: {
 4166:   NS_ASSERTION(frame, "Must have a frame!");
24416:   // It'd be nice to assert that |frame| is not in reflow, but this fails
24416:   // because:
 4166:   //
24416:   //    nsFrame::BoxReflow creates a reflow state for its parent.  This reflow
 4166:   //    state is not used to reflow the parent, but just as a parent for the
 4166:   //    frame's own reflow state.  So given a nsBoxFrame inside some non-XUL
 4166:   //    (like a text control, for example), we'll end up creating a reflow
 4166:   //    state for the parent while the parent is reflowing.
 4166: 
 4166:   NS_PRECONDITION(aComputedHeight >= 0, "Invalid computed height");
 4166:   if (mComputedHeight != aComputedHeight) {
 4166:     mComputedHeight = aComputedHeight;
 4166:     InitResizeFlags(frame->PresContext());
 4166:   }
 4166: }
 4166: 
 4166: void
    1: nsHTMLReflowState::Init(nsPresContext* aPresContext,
    1:                         nscoord         aContainingBlockWidth,
    1:                         nscoord         aContainingBlockHeight,
    1:                         const nsMargin* aBorder,
    1:                         const nsMargin* aPadding)
    1: {
34267:   NS_WARN_IF_FALSE(availableWidth != NS_UNCONSTRAINEDSIZE,
34267:                    "have unconstrained width; this should only result from "
34267:                    "very large sizes, not attempts at intrinsic width "
34267:                    "calculation");
    1: 
    1:   mStylePosition = frame->GetStylePosition();
    1:   mStyleDisplay = frame->GetStyleDisplay();
    1:   mStyleVisibility = frame->GetStyleVisibility();
    1:   mStyleBorder = frame->GetStyleBorder();
    1:   mStyleMargin = frame->GetStyleMargin();
    1:   mStylePadding = frame->GetStylePadding();
    1:   mStyleText = frame->GetStyleText();
    1: 
    1:   InitFrameType();
    1:   InitCBReflowState();
    1: 
    1:   InitConstraints(aPresContext, aContainingBlockWidth, aContainingBlockHeight, aBorder, aPadding);
    1: 
    1:   InitResizeFlags(aPresContext);
    1: 
34267:   NS_WARN_IF_FALSE((mFrameType == NS_CSS_FRAME_TYPE_INLINE &&
    1:                     !frame->IsFrameOfType(nsIFrame::eReplaced)) ||
    1:                    frame->GetType() == nsGkAtoms::textFrame ||
    1:                    mComputedWidth != NS_UNCONSTRAINEDSIZE,
34267:                    "have unconstrained width; this should only result from "
34267:                    "very large sizes, not attempts at intrinsic width "
34267:                    "calculation");
    1: }
    1: 
    1: void nsHTMLReflowState::InitCBReflowState()
    1: {
    1:   if (!parentReflowState) {
    1:     mCBReflowState = nsnull;
    1:     return;
    1:   }
    1: 
25438:   // If outer tables ever become containing blocks, we need to make sure to use
25438:   // their mCBReflowState in the non-absolutely-positioned case for inner
25438:   // tables.
25438:   NS_ASSERTION(frame->GetType() != nsGkAtoms::tableFrame ||
25438:                !frame->GetParent()->IsContainingBlock(),
25438:                "Outer table should not be containing block");
25438: 
    1:   if (parentReflowState->frame->IsContainingBlock() ||
    1:       // Absolutely positioned frames should always be kids of the frames that
38904:       // determine their containing block....
    1:       (NS_FRAME_GET_TYPE(mFrameType) == NS_CSS_FRAME_TYPE_ABSOLUTE)) {
38904:     // an absolutely positioned inner table needs to use the parent of
38904:     // the outer table.  So the above comment about absolutely
38904:     // positioned frames is sort of a lie.
    1:     if (parentReflowState->parentReflowState &&
38904:         frame->GetType() == nsGkAtoms::tableFrame) {
    1:       mCBReflowState = parentReflowState->parentReflowState;
    1:     } else {
    1:       mCBReflowState = parentReflowState;
    1:     }
    1:       
    1:     return;
    1:   }
    1:   
    1:   mCBReflowState = parentReflowState->mCBReflowState;
    1: }
    1: 
 1488: /* Check whether CalcQuirkContainingBlockHeight would stop on the
 1488:  * given reflow state, using its block as a height.  (essentially 
 1488:  * returns false for any case in which CalcQuirkContainingBlockHeight 
 1488:  * has a "continue" in its main loop.)
 1488:  *
 1488:  * XXX Maybe refactor CalcQuirkContainingBlockHeight so it uses 
 1488:  * this function as well
 1488:  */
 1488: static PRBool
 1488: IsQuirkContainingBlockHeight(const nsHTMLReflowState* rs) 
 1488: {
 1488:   nsIAtom* frameType = rs->frame->GetType();
 1488:   if (nsGkAtoms::blockFrame == frameType ||
23176: #ifdef MOZ_XUL
23176:       nsGkAtoms::XULLabelFrame == frameType ||
23176: #endif
 1488:       nsGkAtoms::scrollFrame == frameType) {
 1488:     // Note: This next condition could change due to a style change,
 1488:     // but that would cause a style reflow anyway, which means we're ok.
 4166:     if (NS_AUTOHEIGHT == rs->ComputedHeight()) {
 1488:       if (!rs->frame->GetStyleDisplay()->IsAbsolutelyPositioned()) {
 1488:         return PR_FALSE;
 1488:       }
 1488:     }
 1488:   }
 1488:   return PR_TRUE;
 1488: }
 1488: 
 1488: 
    1: void
    1: nsHTMLReflowState::InitResizeFlags(nsPresContext* aPresContext)
    1: {
    1:   mFlags.mHResize = !(frame->GetStateBits() & NS_FRAME_IS_DIRTY) &&
    1:                     frame->GetSize().width !=
    1:                       mComputedWidth + mComputedBorderPadding.LeftRight();
    1: 
    1:   // XXX Should we really need to null check mCBReflowState?  (We do for
    1:   // at least nsBoxFrame).
 2543:   if (IS_TABLE_CELL(frame->GetType()) &&
 2543:       (mFlags.mSpecialHeightReflow ||
 2543:        (frame->GetFirstInFlow()->GetStateBits() &
 2543:          NS_TABLE_CELL_HAD_SPECIAL_REFLOW)) &&
    1:       (frame->GetStateBits() & NS_FRAME_CONTAINS_RELATIVE_HEIGHT)) {
 2543:     // Need to set the bit on the cell so that
 2543:     // mCBReflowState->mFlags.mVResize is set correctly below when
 2543:     // reflowing descendant.
    1:     mFlags.mVResize = PR_TRUE;
    1:   } else if (mCBReflowState && !frame->IsContainingBlock()) {
    1:     // XXX Is this problematic for relatively positioned inlines acting
    1:     // as containing block for absolutely positioned elements?
38904:     // Possibly; in that case we should at least be checking
38904:     // NS_SUBTREE_DIRTY, I'd think.
    1:     mFlags.mVResize = mCBReflowState->mFlags.mVResize;
    1:   } else if (mComputedHeight == NS_AUTOHEIGHT) {
    1:     if (eCompatibility_NavQuirks == aPresContext->CompatibilityMode() &&
    1:         mCBReflowState) {
    1:       mFlags.mVResize = mCBReflowState->mFlags.mVResize;
    1:     } else {
33779:       mFlags.mVResize = mFlags.mHResize;
    1:     }
33779:     mFlags.mVResize = mFlags.mVResize || NS_SUBTREE_DIRTY(frame);
    1:   } else {
    1:     // not 'auto' height
    1:     mFlags.mVResize = frame->GetSize().height !=
    1:                         mComputedHeight + mComputedBorderPadding.TopBottom();
    1:   }
    1: 
29410:   PRBool dependsOnCBHeight =
51406:     (mStylePosition->HeightDependsOnContainer() &&
51406:      // FIXME: condition this on not-abspos?
51406:      mStylePosition->mHeight.GetUnit() != eStyleUnit_Auto) ||
51406:     (mStylePosition->MinHeightDependsOnContainer() &&
51406:      // FIXME: condition this on not-abspos?
51406:      mStylePosition->mMinHeight.GetUnit() != eStyleUnit_Auto) ||
51406:     (mStylePosition->MaxHeightDependsOnContainer() &&
51406:      // FIXME: condition this on not-abspos?
51406:      mStylePosition->mMaxHeight.GetUnit() != eStyleUnit_Auto) ||
51410:     mStylePosition->OffsetHasPercent(NS_SIDE_TOP) ||
 8731:     mStylePosition->mOffset.GetBottomUnit() != eStyleUnit_Auto ||
 8142:     frame->IsBoxFrame() ||
13281:     (mStylePosition->mHeight.GetUnit() == eStyleUnit_Auto &&
13281:      frame->GetIntrinsicSize().height.GetUnit() == eStyleUnit_Percent);
 2543: 
29410:   if (mStyleText->mLineHeight.GetUnit() == eStyleUnit_Enumerated) {
29410:     NS_ASSERTION(mStyleText->mLineHeight.GetIntValue() ==
29410:                  NS_STYLE_LINE_HEIGHT_BLOCK_HEIGHT,
29410:                  "bad line-height value");
29410: 
29410:     // line-height depends on block height
29410:     frame->AddStateBits(NS_FRAME_CONTAINS_RELATIVE_HEIGHT);
29410:     // but only on containing blocks if this frame is not a suitable block
29410:     dependsOnCBHeight |= !frame->IsContainingBlock();
29410:   }
29410: 
12040:   // If we're the descendant of a table cell that performs special height
 2543:   // reflows and we could be the child that requires them, always set
 2543:   // the vertical resize in case this is the first pass before the
21892:   // special height reflow.  However, don't do this if it actually is
21892:   // the special height reflow, since in that case it will already be
21892:   // set correctly above if we need it set.
 2543:   if (!mFlags.mVResize && mCBReflowState &&
12040:       (IS_TABLE_CELL(mCBReflowState->frame->GetType()) || 
12040:        mCBReflowState->mFlags.mHeightDependsOnAncestorCell) &&
21892:       !mCBReflowState->mFlags.mSpecialHeightReflow && 
12040:       dependsOnCBHeight) {
 2543:     mFlags.mVResize = PR_TRUE;
12040:     mFlags.mHeightDependsOnAncestorCell = PR_TRUE;
12040:   }
 2543: 
 2543:   // Set NS_FRAME_CONTAINS_RELATIVE_HEIGHT if it's needed.
 2543: 
    1:   // It would be nice to check that |mComputedHeight != NS_AUTOHEIGHT|
    1:   // &&ed with the percentage height check.  However, this doesn't get
    1:   // along with table special height reflows, since a special height
    1:   // reflow (a quirk that makes such percentage heights work on children
    1:   // of table cells) can cause not just a single percentage height to
    1:   // become fixed, but an entire descendant chain of percentage heights
    1:   // to become fixed.
 2543:   if (dependsOnCBHeight && mCBReflowState) {
    1:     const nsHTMLReflowState *rs = this;
 1488:     PRBool hitCBReflowState = PR_FALSE;
    1:     do {
    1:       rs = rs->parentReflowState;
 1488:       if (!rs) {
 1488:         break;
 1488:       }
 1488:         
    1:       if (rs->frame->GetStateBits() & NS_FRAME_CONTAINS_RELATIVE_HEIGHT)
    1:         break; // no need to go further
    1:       rs->frame->AddStateBits(NS_FRAME_CONTAINS_RELATIVE_HEIGHT);
 1488:       
 1488:       // Keep track of whether we've hit the containing block, because
 1488:       // we need to go at least that far.
 1488:       if (rs == mCBReflowState) {
 1488:         hitCBReflowState = PR_TRUE;
    1:       }
    1: 
 1488:     } while (!hitCBReflowState ||
 1488:              (eCompatibility_NavQuirks == aPresContext->CompatibilityMode() &&
 1488:               !IsQuirkContainingBlockHeight(rs)));
 1488:     // Note: We actually don't need to set the
 1488:     // NS_FRAME_CONTAINS_RELATIVE_HEIGHT bit for the cases
 1488:     // where we hit the early break statements in
 1488:     // CalcQuirkContainingBlockHeight. But it doesn't hurt
 1488:     // us to set the bit in these cases.
 1488:     
 1488:   }
    1:   if (frame->GetStateBits() & NS_FRAME_IS_DIRTY) {
    1:     // If we're reflowing everything, then we'll find out if we need
    1:     // to re-set this.
    1:     frame->RemoveStateBits(NS_FRAME_CONTAINS_RELATIVE_HEIGHT);
    1:   }
    1: }
    1: 
    1: /* static */
    1: nscoord
    1: nsHTMLReflowState::GetContainingBlockContentWidth(const nsHTMLReflowState* aReflowState)
    1: {
    1:   const nsHTMLReflowState* rs = aReflowState->mCBReflowState;
    1:   if (!rs)
    1:     return 0;
    1:   return rs->mComputedWidth;
    1: }
    1: 
    1: /* static */
    1: nsIFrame*
    1: nsHTMLReflowState::GetContainingBlockFor(const nsIFrame* aFrame)
    1: {
    1:   NS_PRECONDITION(aFrame, "Must have frame to work with");
    1:   nsIFrame* container = aFrame->GetParent();
    1:   if (aFrame->GetStyleDisplay()->IsAbsolutelyPositioned()) {
    1:     // Absolutely positioned frames are just kids of their containing
    1:     // blocks (which may happen to be inlines).
    1:     return container;
    1:   }
    1:   while (container && !container->IsContainingBlock()) {
    1:     container = container->GetParent();
    1:   }
    1:   return container;
    1: }
    1: 
    1: void
    1: nsHTMLReflowState::InitFrameType()
    1: {
    1:   const nsStyleDisplay *disp = mStyleDisplay;
    1:   nsCSSFrameType frameType;
    1: 
    1:   // Section 9.7 of the CSS2 spec indicates that absolute position
    1:   // takes precedence over float which takes precedence over display.
25438:   // XXXldb nsRuleNode::ComputeDisplayData should take care of this, right?
    1:   // Make sure the frame was actually moved out of the flow, and don't
25438: 
25438:   // just assume what the style says, because we might not have had a
25438:   // useful float/absolute containing block
25438:   nsIFrame* frameToTest =
25438:     frame->GetType() == nsGkAtoms::tableFrame ? frame->GetParent() : frame;
41687: 
41687:   DISPLAY_INIT_TYPE(frameToTest, this);
41687: 
25438:   NS_ASSERTION(frameToTest->GetStyleDisplay()->IsAbsolutelyPositioned() ==
25438:                  disp->IsAbsolutelyPositioned(),
25438:                "Unexpected position style");
25438:   NS_ASSERTION(frameToTest->GetStyleDisplay()->IsFloating() ==
25438:                  disp->IsFloating(), "Unexpected float style");
25438:   if (frameToTest->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
    1:     if (disp->IsAbsolutelyPositioned()) {
    1:       frameType = NS_CSS_FRAME_TYPE_ABSOLUTE;
 6521:       //XXXfr hack for making frames behave properly when in overflow container lists
 6521:       //      see bug 154892; need to revisit later
25438:       if (frameToTest->GetPrevInFlow())
 6521:         frameType = NS_CSS_FRAME_TYPE_BLOCK;
    1:     }
25438:     else if (disp->IsFloating()) {
    1:       frameType = NS_CSS_FRAME_TYPE_FLOATING;
    1:     } else {
    1:       NS_ASSERTION(disp->mDisplay == NS_STYLE_DISPLAY_POPUP,
    1:                    "unknown out of flow frame type");
    1:       frameType = NS_CSS_FRAME_TYPE_UNKNOWN;
    1:     }
    1:   }
    1:   else {
    1:     switch (disp->mDisplay) {
    1:     case NS_STYLE_DISPLAY_BLOCK:
    1:     case NS_STYLE_DISPLAY_LIST_ITEM:
    1:     case NS_STYLE_DISPLAY_TABLE:
    1:     case NS_STYLE_DISPLAY_TABLE_CAPTION:
    1:       frameType = NS_CSS_FRAME_TYPE_BLOCK;
    1:       break;
    1: 
    1:     case NS_STYLE_DISPLAY_INLINE:
    1:     case NS_STYLE_DISPLAY_INLINE_BLOCK:
    1:     case NS_STYLE_DISPLAY_MARKER:
    1:     case NS_STYLE_DISPLAY_INLINE_TABLE:
    1:     case NS_STYLE_DISPLAY_INLINE_BOX:
    1:     case NS_STYLE_DISPLAY_INLINE_GRID:
    1:     case NS_STYLE_DISPLAY_INLINE_STACK:
    1:       frameType = NS_CSS_FRAME_TYPE_INLINE;
    1:       break;
    1: 
    1:     case NS_STYLE_DISPLAY_RUN_IN:
    1:     case NS_STYLE_DISPLAY_COMPACT:
    1:       // XXX need to look ahead at the frame's sibling
    1:       frameType = NS_CSS_FRAME_TYPE_BLOCK;
    1:       break;
    1: 
    1:     case NS_STYLE_DISPLAY_TABLE_CELL:
    1:     case NS_STYLE_DISPLAY_TABLE_ROW_GROUP:
    1:     case NS_STYLE_DISPLAY_TABLE_COLUMN:
    1:     case NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP:
    1:     case NS_STYLE_DISPLAY_TABLE_HEADER_GROUP:
    1:     case NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP:
    1:     case NS_STYLE_DISPLAY_TABLE_ROW:
    1:       frameType = NS_CSS_FRAME_TYPE_INTERNAL_TABLE;
    1:       break;
    1: 
    1:     case NS_STYLE_DISPLAY_NONE:
    1:     default:
    1:       frameType = NS_CSS_FRAME_TYPE_UNKNOWN;
    1:       break;
    1:     }
    1:   }
    1: 
    1:   // See if the frame is replaced
    1:   if (frame->IsFrameOfType(nsIFrame::eReplacedContainsBlock)) {
    1:     frameType = NS_FRAME_REPLACED_CONTAINS_BLOCK(frameType);
    1:   } else if (frame->IsFrameOfType(nsIFrame::eReplaced)) {
    1:     frameType = NS_FRAME_REPLACED(frameType);
    1:   }
    1: 
    1:   mFrameType = frameType;
    1: }
    1: 
    1: void
    1: nsHTMLReflowState::ComputeRelativeOffsets(const nsHTMLReflowState* cbrs,
    1:                                           nscoord aContainingBlockWidth,
14460:                                           nscoord aContainingBlockHeight,
14460:                                           nsPresContext* aPresContext)
    1: {
    1:   // Compute the 'left' and 'right' values. 'Left' moves the boxes to the right,
    1:   // and 'right' moves the boxes to the left. The computed values are always:
    1:   // left=-right
    1:   PRBool  leftIsAuto = eStyleUnit_Auto == mStylePosition->mOffset.GetLeftUnit();
    1:   PRBool  rightIsAuto = eStyleUnit_Auto == mStylePosition->mOffset.GetRightUnit();
    1: 
    1:   // If neither 'left' not 'right' are auto, then we're over-constrained and
    1:   // we ignore one of them
    1:   if (!leftIsAuto && !rightIsAuto) {
    1:     if (mCBReflowState &&
    1:         NS_STYLE_DIRECTION_RTL == mCBReflowState->mStyleVisibility->mDirection) {
    1:       leftIsAuto = PR_TRUE;
    1:     } else {
    1:       rightIsAuto = PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   if (leftIsAuto) {
    1:     if (rightIsAuto) {
    1:       // If both are 'auto' (their initial values), the computed values are 0
    1:       mComputedOffsets.left = mComputedOffsets.right = 0;
    1:     } else {
    1:       // 'Right' isn't 'auto' so compute its value
16031:       mComputedOffsets.right = nsLayoutUtils::
    1:         ComputeWidthDependentValue(aContainingBlockWidth,
16031:                                    mStylePosition->mOffset.GetRight());
    1: 
    1:       // Computed value for 'left' is minus the value of 'right'
    1:       mComputedOffsets.left = -mComputedOffsets.right;
    1:     }
    1: 
    1:   } else {
    1:     NS_ASSERTION(rightIsAuto, "unexpected specified constraint");
    1:     
    1:     // 'Left' isn't 'auto' so compute its value
16031:     mComputedOffsets.left = nsLayoutUtils::
    1:       ComputeWidthDependentValue(aContainingBlockWidth,
16031:                                  mStylePosition->mOffset.GetLeft());
    1: 
    1:     // Computed value for 'right' is minus the value of 'left'
    1:     mComputedOffsets.right = -mComputedOffsets.left;
    1:   }
    1: 
    1:   // Compute the 'top' and 'bottom' values. The 'top' and 'bottom' properties
    1:   // move relatively positioned elements up and down. They also must be each 
    1:   // other's negative
    1:   PRBool  topIsAuto = eStyleUnit_Auto == mStylePosition->mOffset.GetTopUnit();
    1:   PRBool  bottomIsAuto = eStyleUnit_Auto == mStylePosition->mOffset.GetBottomUnit();
    1: 
    1:   // Check for percentage based values and a containing block height that
    1:   // depends on the content height. Treat them like 'auto'
    1:   if (NS_AUTOHEIGHT == aContainingBlockHeight) {
51410:     if (mStylePosition->OffsetHasPercent(NS_SIDE_TOP)) {
    1:       topIsAuto = PR_TRUE;
    1:     }
51410:     if (mStylePosition->OffsetHasPercent(NS_SIDE_BOTTOM)) {
    1:       bottomIsAuto = PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   // If neither is 'auto', 'bottom' is ignored
    1:   if (!topIsAuto && !bottomIsAuto) {
    1:     bottomIsAuto = PR_TRUE;
    1:   }
    1: 
    1:   if (topIsAuto) {
    1:     if (bottomIsAuto) {
    1:       // If both are 'auto' (their initial values), the computed values are 0
    1:       mComputedOffsets.top = mComputedOffsets.bottom = 0;
    1:     } else {
    1:       // 'Bottom' isn't 'auto' so compute its value
16031:       mComputedOffsets.bottom = nsLayoutUtils::
    1:         ComputeHeightDependentValue(aContainingBlockHeight,
16031:                                     mStylePosition->mOffset.GetBottom());
    1:       
    1:       // Computed value for 'top' is minus the value of 'bottom'
    1:       mComputedOffsets.top = -mComputedOffsets.bottom;
    1:     }
    1: 
    1:   } else {
    1:     NS_ASSERTION(bottomIsAuto, "unexpected specified constraint");
    1:     
    1:     // 'Top' isn't 'auto' so compute its value
16031:     mComputedOffsets.top = nsLayoutUtils::
    1:       ComputeHeightDependentValue(aContainingBlockHeight,
16031:                                   mStylePosition->mOffset.GetTop());
    1: 
    1:     // Computed value for 'bottom' is minus the value of 'top'
    1:     mComputedOffsets.bottom = -mComputedOffsets.top;
    1:   }
14460: 
14460:   // Store the offset
39965:   FrameProperties props(aPresContext->PropertyTable(), frame);
14460:   nsPoint* offsets = static_cast<nsPoint*>
39965:     (props.Get(nsIFrame::ComputedOffsetProperty()));
39965:   if (offsets) {
14460:     offsets->MoveTo(mComputedOffsets.left, mComputedOffsets.top);
39965:   } else {
39965:     props.Set(nsIFrame::ComputedOffsetProperty(),
39965:               new nsPoint(mComputedOffsets.left, mComputedOffsets.top));
14460:   }
    1: }
    1: 
40126: static nsIFrame*
40126: GetNearestContainingBlock(nsIFrame *aFrame)
40126: {
40126:   nsIFrame *cb = aFrame;
40126:   do {
40126:     cb = cb->GetParent();
40126:   } while (!cb->IsContainingBlock());
40126:   return cb;
40126: }
40126: 
    1: nsIFrame*
21929: nsHTMLReflowState::GetHypotheticalBoxContainer(nsIFrame* aFrame,
21929:                                                nscoord& aCBLeftEdge,
    1:                                                nscoord& aCBWidth)
    1: {
40126:   aFrame = GetNearestContainingBlock(aFrame);
    1:   NS_ASSERTION(aFrame != frame, "How did that happen?");
    1: 
    1:   /* Now aFrame is the containing block we want */
    1: 
30710:   /* Check whether the containing block is currently being reflowed.
    1:      If so, use the info from the reflow state. */
    1:   const nsHTMLReflowState* state;
    1:   if (aFrame->GetStateBits() & NS_FRAME_IN_REFLOW) {
    1:     for (state = parentReflowState; state && state->frame != aFrame;
    1:          state = state->parentReflowState) {
    1:       /* do nothing */
    1:     }
    1:   } else {
    1:     state = nsnull;
    1:   }
    1:   
    1:   if (state) {
    1:     aCBLeftEdge = state->mComputedBorderPadding.left;
    1:     aCBWidth = state->mComputedWidth;
    1:   } else {
    1:     /* Didn't find a reflow state for aFrame.  Just compute the information we
    1:        want, on the assumption that aFrame already knows its size.  This really
    1:        ought to be true by now. */
    1:     NS_ASSERTION(!(aFrame->GetStateBits() & NS_FRAME_IN_REFLOW),
    1:                  "aFrame shouldn't be in reflow; we'll lie if it is");
    1:     nsMargin borderPadding = aFrame->GetUsedBorderAndPadding();
    1:     aCBLeftEdge = borderPadding.left;
    1:     aCBWidth = aFrame->GetSize().width - borderPadding.LeftRight();
    1:   }
    1: 
    1:   return aFrame;
    1: }
    1: 
    1: // When determining the hypothetical box that would have been if the element
    1: // had been in the flow we may not be able to exactly determine both the left
    1: // and right edges. For example, if the element is a non-replaced inline-level
    1: // element we would have to reflow it in order to determine it desired width.
    1: // In that case depending on the progression direction either the left or
    1: // right edge would be marked as not being exact
    1: struct nsHypotheticalBox {
12210:   // offsets from left edge of containing block (which is a padding edge)
    1:   nscoord       mLeft, mRight;
12210:   // offset from top edge of containing block (which is a padding edge)
    1:   nscoord       mTop;
15227: #ifdef DEBUG
    1:   PRPackedBool  mLeftIsExact, mRightIsExact;
15227: #endif
    1: 
    1:   nsHypotheticalBox() {
15227: #ifdef DEBUG
    1:     mLeftIsExact = mRightIsExact = PR_FALSE;
15227: #endif
    1:   }
    1: };
    1:       
    1: static PRBool
    1: GetIntrinsicSizeFor(nsIFrame* aFrame, nsSize& aIntrinsicSize)
    1: {
    1:   // See if it is an image frame
52205:   PRBool success = PR_FALSE;
    1: 
    1:   // Currently the only type of replaced frame that we can get the intrinsic
    1:   // size for is an image frame
    1:   // XXX We should add back the GetReflowMetrics() function and one of the
    1:   // things should be the intrinsic size...
    1:   if (aFrame->GetType() == nsGkAtoms::imageFrame) {
    1:     nsImageFrame* imageFrame = (nsImageFrame*)aFrame;
    1: 
52205:     if (NS_SUCCEEDED(imageFrame->GetIntrinsicImageSize(aIntrinsicSize))) {
52205:       success = (aIntrinsicSize != nsSize(0, 0));
    1:     }
52205:   }
52205:   return success;
    1: }
    1: 
 1068: /**
 1068:  * aInsideBoxSizing returns the part of the horizontal padding, border,
 1068:  * and margin that goes inside the edge given by -moz-box-sizing;
 1068:  * aOutsideBoxSizing returns the rest.
 1068:  */
 1068: void
 1068: nsHTMLReflowState::CalculateHorizBorderPaddingMargin(
 1068:                        nscoord aContainingBlockWidth,
 1068:                        nscoord* aInsideBoxSizing,
 1068:                        nscoord* aOutsideBoxSizing)
    1: {
15992:   const nsMargin& border = mStyleBorder->GetActualBorder();
    1:   nsMargin padding, margin;
    1: 
    1:   // See if the style system can provide us the padding directly
    1:   if (!mStylePadding->GetPadding(padding)) {
    1:     // We have to compute the left and right values
16031:     padding.left = nsLayoutUtils::
    1:       ComputeWidthDependentValue(aContainingBlockWidth,
16031:                                  mStylePadding->mPadding.GetLeft());
16031:     padding.right = nsLayoutUtils::
    1:       ComputeWidthDependentValue(aContainingBlockWidth,
16031:                                  mStylePadding->mPadding.GetRight());
    1:   }
    1: 
    1:   // See if the style system can provide us the margin directly
    1:   if (!mStyleMargin->GetMargin(margin)) {
    1:     // We have to compute the left and right values
    1:     if (eStyleUnit_Auto == mStyleMargin->mMargin.GetLeftUnit()) {
    1:       // XXX FIXME (or does CalculateBlockSideMargins do this?)
    1:       margin.left = 0;  // just ignore
    1:     } else {
16031:       margin.left = nsLayoutUtils::
    1:         ComputeWidthDependentValue(aContainingBlockWidth,
16031:                                    mStyleMargin->mMargin.GetLeft());
    1:     }
    1:     if (eStyleUnit_Auto == mStyleMargin->mMargin.GetRightUnit()) {
    1:       // XXX FIXME (or does CalculateBlockSideMargins do this?)
    1:       margin.right = 0;  // just ignore
    1:     } else {
16031:       margin.right = nsLayoutUtils::
    1:         ComputeWidthDependentValue(aContainingBlockWidth,
16031:                                    mStyleMargin->mMargin.GetRight());
    1:     }
    1:   }
    1: 
 1068:   nscoord outside =
 1068:     padding.LeftRight() + border.LeftRight() + margin.LeftRight();
 1068:   nscoord inside = 0;
 1068:   switch (mStylePosition->mBoxSizing) {
 1068:     case NS_STYLE_BOX_SIZING_BORDER:
 1068:       inside += border.LeftRight();
 1068:       // fall through
 1068:     case NS_STYLE_BOX_SIZING_PADDING:
 1068:       inside += padding.LeftRight();
 1068:   }
 1068:   outside -= inside;
 1068:   *aInsideBoxSizing = inside;
 1068:   *aOutsideBoxSizing = outside;
 1068:   return;
    1: }
    1: 
    1: /**
    1:  * Returns PR_TRUE iff a pre-order traversal of the normal child
    1:  * frames rooted at aFrame finds no non-empty frame before aDescendant.
    1:  */
    1: static PRBool AreAllEarlierInFlowFramesEmpty(nsIFrame* aFrame,
    1:   nsIFrame* aDescendant, PRBool* aFound) {
    1:   if (aFrame == aDescendant) {
    1:     *aFound = PR_TRUE;
    1:     return PR_TRUE;
    1:   }
    1:   if (!aFrame->IsSelfEmpty()) {
    1:     *aFound = PR_FALSE;
    1:     return PR_FALSE;
    1:   }
    1:   for (nsIFrame* f = aFrame->GetFirstChild(nsnull); f; f = f->GetNextSibling()) {
    1:     PRBool allEmpty = AreAllEarlierInFlowFramesEmpty(f, aDescendant, aFound);
    1:     if (*aFound || !allEmpty) {
    1:       return allEmpty;
    1:     }
    1:   }
    1:   *aFound = PR_FALSE;
    1:   return PR_TRUE;
    1: }
    1: 
    1: // Calculate the hypothetical box that the element would have if it were in
    1: // the flow. The values returned are relative to the padding edge of the
    1: // absolute containing block
21930: // aContainingBlock is the placeholder's containing block (XXX rename it?)
21930: // cbrs->frame is the actual containing block
    1: void
    1: nsHTMLReflowState::CalculateHypotheticalBox(nsPresContext*    aPresContext,
    1:                                             nsIFrame*         aPlaceholderFrame,
    1:                                             nsIFrame*         aContainingBlock,
    1:                                             nscoord           aBlockLeftContentEdge,
    1:                                             nscoord           aBlockContentWidth,
    1:                                             const nsHTMLReflowState* cbrs,
    1:                                             nsHypotheticalBox& aHypotheticalBox)
    1: {
    1:   NS_ASSERTION(mStyleDisplay->mOriginalDisplay != NS_STYLE_DISPLAY_NONE,
    1:                "mOriginalDisplay has not been properly initialized");
    1:   
    1:   // If it's a replaced element and it has a 'auto' value for 'width', see if we
    1:   // can get the intrinsic size. This will allow us to exactly determine both the
    1:   // left and right edges
 1068:   PRBool isAutoWidth = mStylePosition->mWidth.GetUnit() == eStyleUnit_Auto;
    1:   nsSize      intrinsicSize;
    1:   PRBool      knowIntrinsicSize = PR_FALSE;
 1068:   if (NS_FRAME_IS_REPLACED(mFrameType) && isAutoWidth) {
    1:     // See if we can get the intrinsic size of the element
    1:     knowIntrinsicSize = GetIntrinsicSizeFor(frame, intrinsicSize);
    1:   }
    1: 
    1:   // See if we can calculate what the box width would have been if the
    1:   // element had been in the flow
    1:   nscoord boxWidth;
    1:   PRBool  knowBoxWidth = PR_FALSE;
    1:   if ((NS_STYLE_DISPLAY_INLINE == mStyleDisplay->mOriginalDisplay) &&
    1:       !NS_FRAME_IS_REPLACED(mFrameType)) {
    1:     // For non-replaced inline-level elements the 'width' property doesn't apply,
    1:     // so we don't know what the width would have been without reflowing it
    1: 
    1:   } else {
    1:     // It's either a replaced inline-level element or a block-level element
    1: 
    1:     // Determine the total amount of horizontal border/padding/margin that
    1:     // the element would have had if it had been in the flow. Note that we
    1:     // ignore any 'auto' and 'inherit' values
 1068:     nscoord insideBoxSizing, outsideBoxSizing;
 1068:     CalculateHorizBorderPaddingMargin(aBlockContentWidth,
 1068:                                       &insideBoxSizing, &outsideBoxSizing);
    1: 
 1068:     if (NS_FRAME_IS_REPLACED(mFrameType) && isAutoWidth) {
    1:       // It's a replaced element with an 'auto' width so the box width is
    1:       // its intrinsic size plus any border/padding/margin
    1:       if (knowIntrinsicSize) {
 1068:         boxWidth = intrinsicSize.width + outsideBoxSizing + insideBoxSizing;
    1:         knowBoxWidth = PR_TRUE;
    1:       }
    1: 
 1068:     } else if (isAutoWidth) {
    1:       // The box width is the containing block width
    1:       boxWidth = aBlockContentWidth;
    1:       knowBoxWidth = PR_TRUE;
    1:     
    1:     } else {
    1:       // We need to compute it. It's important we do this, because if it's
12210:       // percentage based this computed value may be different from the computed
    1:       // value calculated using the absolute containing block width
 1068:       boxWidth = ComputeWidthValue(aBlockContentWidth,
 1068:                                    insideBoxSizing, outsideBoxSizing,
 1068:                                    mStylePosition->mWidth) + 
 1068:                  insideBoxSizing + outsideBoxSizing;
    1:       knowBoxWidth = PR_TRUE;
    1:     }
    1:   }
    1:   
    1:   // Get the 'direction' of the block
    1:   const nsStyleVisibility* blockVis = aContainingBlock->GetStyleVisibility();
    1: 
    1:   // Get the placeholder x-offset and y-offset in the coordinate
40126:   // space of its containing block
30710:   // XXXbz the placeholder is not fully reflowed yet if our containing block is
    1:   // relatively positioned...
    1:   nsPoint placeholderOffset = aPlaceholderFrame->GetOffsetTo(aContainingBlock);
    1: 
40126:   // First, determine the hypothetical box's mTop.  We want to check the
40126:   // content insertion frame of aContainingBlock for block-ness, but make
40126:   // sure to compute all coordinates in the coordinate system of
40126:   // aContainingBlock.
40126:   nsBlockFrame* blockFrame =
40126:     nsLayoutUtils::GetAsBlock(aContainingBlock->GetContentInsertionFrame());
15909:   if (blockFrame) {
40126:     nscoord blockYOffset = blockFrame->GetOffsetTo(aContainingBlock).y;
12355:     PRBool isValid;
12355:     nsBlockInFlowLineIterator iter(blockFrame, aPlaceholderFrame, &isValid);
55054:     if (!isValid) {
55054:       // Give up.  We're probably dealing with somebody using
55054:       // position:absolute inside native-anonymous content anyway.
55054:       aHypotheticalBox.mTop = placeholderOffset.y;
55054:     } else {
55054:       NS_ASSERTION(iter.GetContainer() == blockFrame,
55054:                    "Found placeholder in wrong block!");
12355:       nsBlockFrame::line_iterator lineBox = iter.GetLine();
    1: 
    1:       // How we determine the hypothetical box depends on whether the element
    1:       // would have been inline-level or block-level
    1:       if (NS_STYLE_DISPLAY_INLINE == mStyleDisplay->mOriginalDisplay) {
55054:         // Use the top of the inline box which the placeholder lives in
55054:         // as the hypothetical box's top.
40126:         aHypotheticalBox.mTop = lineBox->mBounds.y + blockYOffset;
    1:       } else {
55054:         // The element would have been block-level which means it would
55054:         // be below the line containing the placeholder frame, unless
55054:         // all the frames before it are empty.  In that case, it would
55054:         // have been just before this line.
55054:         // XXXbz the line box is not fully reflowed yet if our
55054:         // containing block is relatively positioned...
14246:         if (lineBox != iter.End()) {
    1:           nsIFrame * firstFrame = lineBox->mFirstChild;
    1:           PRBool found = PR_FALSE;
    1:           PRBool allEmpty = PR_TRUE;
    1:           while (firstFrame) { // See bug 223064
    1:             allEmpty = AreAllEarlierInFlowFramesEmpty(firstFrame,
    1:               aPlaceholderFrame, &found);
    1:             if (found || !allEmpty)
    1:               break;
    1:             firstFrame = firstFrame->GetNextSibling();
    1:           }
    1:           NS_ASSERTION(firstFrame, "Couldn't find placeholder!");
    1: 
    1:           if (allEmpty) {
55054:             // The top of the hypothetical box is the top of the line
55054:             // containing the placeholder, since there is nothing in the
55054:             // line before our placeholder except empty frames.
40126:             aHypotheticalBox.mTop = lineBox->mBounds.y + blockYOffset;
    1:           } else {
55054:             // The top of the hypothetical box is just below the line
55054:             // containing the placeholder.
40126:             aHypotheticalBox.mTop = lineBox->mBounds.YMost() + blockYOffset;
    1:           }
    1:         } else {
40126:           // Just use the placeholder's y-offset wrt the containing block
    1:           aHypotheticalBox.mTop = placeholderOffset.y;
    1:         }
    1:       }
55054:     }
    1:   } else {
    1:     // The containing block is not a block, so it's probably something
    1:     // like a XUL box, etc.
    1:     // Just use the placeholder's y-offset
    1:     aHypotheticalBox.mTop = placeholderOffset.y;
    1:   }
    1: 
    1:   // Second, determine the hypothetical box's mLeft & mRight
    1:   // To determine the left and right offsets we need to look at the block's 'direction'
    1:   if (NS_STYLE_DIRECTION_LTR == blockVis->mDirection) {
    1:     // How we determine the hypothetical box depends on whether the element
    1:     // would have been inline-level or block-level
    1:     if (NS_STYLE_DISPLAY_INLINE == mStyleDisplay->mOriginalDisplay) {
    1:       // The placeholder represents the left edge of the hypothetical box
    1:       aHypotheticalBox.mLeft = placeholderOffset.x;
    1:     } else {
    1:       aHypotheticalBox.mLeft = aBlockLeftContentEdge;
    1:     }
15227: #ifdef DEBUG
    1:     aHypotheticalBox.mLeftIsExact = PR_TRUE;
15227: #endif
    1: 
    1:     if (knowBoxWidth) {
    1:       aHypotheticalBox.mRight = aHypotheticalBox.mLeft + boxWidth;
15227: #ifdef DEBUG
    1:       aHypotheticalBox.mRightIsExact = PR_TRUE;
15227: #endif
    1:     } else {
    1:       // We can't compute the right edge because we don't know the desired
    1:       // width. So instead use the right content edge of the block parent,
    1:       // but remember it's not exact
    1:       aHypotheticalBox.mRight = aBlockLeftContentEdge + aBlockContentWidth;
15227: #ifdef DEBUG
    1:       aHypotheticalBox.mRightIsExact = PR_FALSE;
15227: #endif
    1:     }
    1: 
    1:   } else {
    1:     // The placeholder represents the right edge of the hypothetical box
    1:     if (NS_STYLE_DISPLAY_INLINE == mStyleDisplay->mOriginalDisplay) {
    1:       aHypotheticalBox.mRight = placeholderOffset.x;
    1:     } else {
    1:       aHypotheticalBox.mRight = aBlockLeftContentEdge + aBlockContentWidth;
    1:     }
15227: #ifdef DEBUG
    1:     aHypotheticalBox.mRightIsExact = PR_TRUE;
15227: #endif
    1:     
    1:     if (knowBoxWidth) {
    1:       aHypotheticalBox.mLeft = aHypotheticalBox.mRight - boxWidth;
15227: #ifdef DEBUG
    1:       aHypotheticalBox.mLeftIsExact = PR_TRUE;
15227: #endif
    1:     } else {
    1:       // We can't compute the left edge because we don't know the desired
    1:       // width. So instead use the left content edge of the block parent,
    1:       // but remember it's not exact
    1:       aHypotheticalBox.mLeft = aBlockLeftContentEdge;
15227: #ifdef DEBUG
    1:       aHypotheticalBox.mLeftIsExact = PR_FALSE;
15227: #endif
    1:     }
    1: 
    1:   }
    1: 
    1:   // The current coordinate space is that of the nearest block to the placeholder.
    1:   // Convert to the coordinate space of the absolute containing block
    1:   // One weird thing here is that for fixed-positioned elements we want to do
    1:   // the conversion incorrectly; specifically we want to ignore any scrolling
    1:   // that may have happened;
    1:   nsPoint cbOffset;
21930:   if (mStyleDisplay->mPosition == NS_STYLE_POSITION_FIXED &&
21930:       // Exclude cases inside -moz-transform where fixed is like absolute.
21930:       nsLayoutUtils::IsReallyFixedPos(frame)) {
    1:     // In this case, cbrs->frame will always be an ancestor of
    1:     // aContainingBlock, so can just walk our way up the frame tree.
    1:     // Make sure to not add positions of frames whose parent is a
    1:     // scrollFrame, since we're doing fixed positioning, which assumes
    1:     // everything is scrolled to (0,0).
    1:     cbOffset.MoveTo(0, 0);
    1:     do {
    1:       NS_ASSERTION(aContainingBlock,
    1:                    "Should hit cbrs->frame before we run off the frame tree!");
    1:       cbOffset += aContainingBlock->GetPositionIgnoringScrolling();
    1:       aContainingBlock = aContainingBlock->GetParent();
    1:     } while (aContainingBlock != cbrs->frame);
    1:   } else {
21930:     // XXXldb We need to either ignore scrolling for the absolute
21930:     // positioning case too (and take the incompatibility) or figure out
21930:     // how to make these positioned elements actually *move* when we
21930:     // scroll, and thus avoid the resulting incremental reflow bugs.
    1:     cbOffset = aContainingBlock->GetOffsetTo(cbrs->frame);
    1:   }
    1:   aHypotheticalBox.mLeft += cbOffset.x;
    1:   aHypotheticalBox.mTop += cbOffset.y;
    1:   aHypotheticalBox.mRight += cbOffset.x;
    1:   
    1:   // The specified offsets are relative to the absolute containing block's
    1:   // padding edge and our current values are relative to the border edge, so
    1:   // translate.
    1:   nsMargin border = cbrs->mComputedBorderPadding - cbrs->mComputedPadding;
    1:   aHypotheticalBox.mLeft -= border.left;
12210:   aHypotheticalBox.mRight -= border.left;
    1:   aHypotheticalBox.mTop -= border.top;
    1: }
    1: 
    1: void
    1: nsHTMLReflowState::InitAbsoluteConstraints(nsPresContext* aPresContext,
    1:                                            const nsHTMLReflowState* cbrs,
    1:                                            nscoord containingBlockWidth,
    1:                                            nscoord containingBlockHeight)
    1: {
    1:   NS_PRECONDITION(containingBlockHeight != NS_AUTOHEIGHT,
    1:                   "containing block height must be constrained");
    1: 
25438:   nsIFrame* outOfFlow = 
25438:     frame->GetType() == nsGkAtoms::tableFrame ? frame->GetParent() : frame;
25438:   NS_ASSERTION(outOfFlow->GetStateBits() & NS_FRAME_OUT_OF_FLOW,
25438:                "Why are we here?");
25438: 
    1:   // Get the placeholder frame
    1:   nsIFrame*     placeholderFrame;
    1: 
39668:   placeholderFrame = aPresContext->PresShell()->GetPlaceholderFrameFor(outOfFlow);
    1:   NS_ASSERTION(nsnull != placeholderFrame, "no placeholder frame");
    1: 
    1:   // If both 'left' and 'right' are 'auto' or both 'top' and 'bottom' are
    1:   // 'auto', then compute the hypothetical box of where the element would
    1:   // have been if it had been in the flow
    1:   nsHypotheticalBox hypotheticalBox;
    1:   if (((eStyleUnit_Auto == mStylePosition->mOffset.GetLeftUnit()) &&
    1:        (eStyleUnit_Auto == mStylePosition->mOffset.GetRightUnit())) ||
    1:       ((eStyleUnit_Auto == mStylePosition->mOffset.GetTopUnit()) &&
    1:        (eStyleUnit_Auto == mStylePosition->mOffset.GetBottomUnit()))) {
21929:     // Find the nearest containing block frame to the placeholder frame,
21929:     // and return its left edge and width.
21929:     nscoord cbLeftEdge, cbWidth;
21929:     nsIFrame* cbFrame = GetHypotheticalBoxContainer(placeholderFrame,
21929:                                                     cbLeftEdge,
21929:                                                     cbWidth);
    1: 
    1:     CalculateHypotheticalBox(aPresContext, placeholderFrame, cbFrame,
    1:                              cbLeftEdge, cbWidth, cbrs, hypotheticalBox);
    1:   }
    1: 
    1:   // Initialize the 'left' and 'right' computed offsets
    1:   // XXX Handle new 'static-position' value...
    1:   PRBool        leftIsAuto = PR_FALSE, rightIsAuto = PR_FALSE;
    1:   if (eStyleUnit_Auto == mStylePosition->mOffset.GetLeftUnit()) {
    1:     mComputedOffsets.left = 0;
    1:     leftIsAuto = PR_TRUE;
    1:   } else {
16031:     mComputedOffsets.left = nsLayoutUtils::
    1:       ComputeWidthDependentValue(containingBlockWidth,
16031:                                  mStylePosition->mOffset.GetLeft());
    1:   }
    1:   if (eStyleUnit_Auto == mStylePosition->mOffset.GetRightUnit()) {
    1:     mComputedOffsets.right = 0;
    1:     rightIsAuto = PR_TRUE;
    1:   } else {
16031:     mComputedOffsets.right = nsLayoutUtils::
    1:       ComputeWidthDependentValue(containingBlockWidth,
16031:                                  mStylePosition->mOffset.GetRight());
    1:   }
    1: 
    1:   // Use the horizontal component of the hypothetical box in the cases
    1:   // where it's needed.
    1:   if (leftIsAuto && rightIsAuto) {
12106:     // Use the direction of the original ("static-position") containing block
12106:     // to dictate whether 'left' or 'right' is treated like 'static-position'.
21929:     if (NS_STYLE_DIRECTION_LTR == GetNearestContainingBlock(placeholderFrame)
21929:                                     ->GetStyleVisibility()->mDirection) {
15227:       NS_ASSERTION(hypotheticalBox.mLeftIsExact, "should always have "
15227:                    "exact value on containing block's start side");
    1:       mComputedOffsets.left = hypotheticalBox.mLeft;
    1:       leftIsAuto = PR_FALSE;
    1:     } else {
15227:       NS_ASSERTION(hypotheticalBox.mRightIsExact, "should always have "
15227:                    "exact value on containing block's start side");
    1:       mComputedOffsets.right = containingBlockWidth - hypotheticalBox.mRight;
    1:       rightIsAuto = PR_FALSE;
    1:     }
    1:   }
    1: 
    1:   // Initialize the 'top' and 'bottom' computed offsets
    1:   PRBool      topIsAuto = PR_FALSE, bottomIsAuto = PR_FALSE;
    1:   if (eStyleUnit_Auto == mStylePosition->mOffset.GetTopUnit()) {
    1:     mComputedOffsets.top = 0;
    1:     topIsAuto = PR_TRUE;
    1:   } else {
16031:     mComputedOffsets.top = nsLayoutUtils::
    1:       ComputeHeightDependentValue(containingBlockHeight,
16031:                                   mStylePosition->mOffset.GetTop());
    1:   }
    1:   if (eStyleUnit_Auto == mStylePosition->mOffset.GetBottomUnit()) {
    1:     mComputedOffsets.bottom = 0;        
    1:     bottomIsAuto = PR_TRUE;
    1:   } else {
16031:     mComputedOffsets.bottom = nsLayoutUtils::
    1:       ComputeHeightDependentValue(containingBlockHeight,
16031:                                   mStylePosition->mOffset.GetBottom());
    1:   }
    1: 
    1:   if (topIsAuto && bottomIsAuto) {
    1:     // Treat 'top' like 'static-position'
    1:     mComputedOffsets.top = hypotheticalBox.mTop;
    1:     topIsAuto = PR_FALSE;
    1:   }
    1: 
    1:   PRBool widthIsAuto = eStyleUnit_Auto == mStylePosition->mWidth.GetUnit();
    1:   PRBool heightIsAuto = eStyleUnit_Auto == mStylePosition->mHeight.GetUnit();
    1: 
    1:   PRBool shrinkWrap = leftIsAuto || rightIsAuto;
    1:   nsSize size =
    1:     frame->ComputeSize(rendContext,
    1:                        nsSize(containingBlockWidth,
    1:                               containingBlockHeight),
    1:                        containingBlockWidth, // XXX or availableWidth?
    1:                        nsSize(mComputedMargin.LeftRight() +
    1:                                 mComputedOffsets.LeftRight(),
    1:                               mComputedMargin.TopBottom() +
    1:                                 mComputedOffsets.TopBottom()),
    1:                        nsSize(mComputedBorderPadding.LeftRight() -
    1:                                 mComputedPadding.LeftRight(),
    1:                               mComputedBorderPadding.TopBottom() -
    1:                                 mComputedPadding.TopBottom()),
    1:                        nsSize(mComputedPadding.LeftRight(),
    1:                               mComputedPadding.TopBottom()),
    1:                        shrinkWrap);
    1:   mComputedWidth = size.width;
    1:   mComputedHeight = size.height;
11744:   NS_ASSERTION(mComputedWidth >= 0, "Bogus width");
11744:   NS_ASSERTION(mComputedHeight == NS_UNCONSTRAINEDSIZE ||
11744:                mComputedHeight >= 0, "Bogus height");
    1: 
    1:   // XXX Now that we have ComputeSize, can we condense many of the
    1:   // branches off of widthIsAuto?
    1: 
    1:   if (leftIsAuto) {
    1:     // We know 'right' is not 'auto' anymore thanks to the hypothetical
    1:     // box code above.
    1:     // Solve for 'left'.
    1:     if (widthIsAuto) {
    1:       // XXXldb This, and the corresponding code in
    1:       // nsAbsoluteContainingBlock.cpp, could probably go away now that
    1:       // we always compute widths.
    1:       mComputedOffsets.left = NS_AUTOOFFSET;
    1:     } else {
    1:       mComputedOffsets.left = containingBlockWidth - mComputedMargin.left -
    1:         mComputedBorderPadding.left - mComputedWidth - mComputedBorderPadding.right - 
    1:         mComputedMargin.right - mComputedOffsets.right;
    1: 
    1:     }
    1:   } else if (rightIsAuto) {
    1:     // We know 'left' is not 'auto' anymore thanks to the hypothetical
    1:     // box code above.
    1:     // Solve for 'right'.
    1:     if (widthIsAuto) {
    1:       // XXXldb This, and the corresponding code in
    1:       // nsAbsoluteContainingBlock.cpp, could probably go away now that
    1:       // we always compute widths.
    1:       mComputedOffsets.right = NS_AUTOOFFSET;
    1:     } else {
    1:       mComputedOffsets.right = containingBlockWidth - mComputedOffsets.left -
    1:         mComputedMargin.left - mComputedBorderPadding.left - mComputedWidth -
    1:         mComputedBorderPadding.right - mComputedMargin.right;
    1:     }
    1:   } else {
    1:     // Neither 'left' nor 'right' is 'auto'.  However, the width might
    1:     // still not fill all the available space (even though we didn't
    1:     // shrink-wrap) in case:
    1:     //  * width was specified
    1:     //  * we're dealing with a replaced element
    1:     //  * width was constrained by min-width or max-width.
    1: 
    1:     nscoord availMarginSpace = containingBlockWidth -
    1:                                mComputedOffsets.LeftRight() -
    1:                                mComputedMargin.LeftRight() -
    1:                                mComputedBorderPadding.LeftRight() -
    1:                                mComputedWidth;
    1:     PRBool marginLeftIsAuto =
    1:       eStyleUnit_Auto == mStyleMargin->mMargin.GetLeftUnit();
    1:     PRBool marginRightIsAuto =
    1:       eStyleUnit_Auto == mStyleMargin->mMargin.GetRightUnit();
    1: 
    1:     if (availMarginSpace < 0 ||
    1:         (!marginLeftIsAuto && !marginRightIsAuto)) {
12106:       // We're over-constrained so use the direction of the containing block
12106:       // to dictate which value to ignore.  (And note that the spec says to ignore
12106:       // 'left' or 'right' rather than 'margin-left' or 'margin-right'.)
12106:       if (cbrs &&
12106:           NS_STYLE_DIRECTION_RTL == cbrs->mStyleVisibility->mDirection) {
12106:         // Ignore the specified value for 'left'.
12106:         mComputedOffsets.left += availMarginSpace;
12106:       } else {
    1:         // Ignore the specified value for 'right'.
    1:         mComputedOffsets.right += availMarginSpace;
    1:       }
    1:     } else if (marginLeftIsAuto) {
    1:       if (marginRightIsAuto) {
    1:         // Both 'margin-left' and 'margin-right' are 'auto', so they get
    1:         // equal values
    1:         mComputedMargin.left = availMarginSpace / 2;
    1:         mComputedMargin.right = availMarginSpace - mComputedMargin.left;
    1:       } else {
    1:         // Just 'margin-left' is 'auto'
12182:         mComputedMargin.left = availMarginSpace;
    1:       }
    1:     } else {
    1:       // Just 'margin-right' is 'auto'
12182:       mComputedMargin.right = availMarginSpace;
    1:     }
    1:   }
    1: 
    1:   if (topIsAuto) {
    1:     // solve for 'top'
    1:     if (heightIsAuto) {
    1:       mComputedOffsets.top = NS_AUTOOFFSET;
    1:     } else {
    1:       mComputedOffsets.top = containingBlockHeight - mComputedMargin.top -
    1:         mComputedBorderPadding.top - mComputedHeight - mComputedBorderPadding.bottom - 
    1:         mComputedMargin.bottom - mComputedOffsets.bottom;
    1:     }
    1:   } else if (bottomIsAuto) {
    1:     // solve for 'bottom'
    1:     if (heightIsAuto) {
    1:       mComputedOffsets.bottom = NS_AUTOOFFSET;
    1:     } else {
    1:       mComputedOffsets.bottom = containingBlockHeight - mComputedOffsets.top -
    1:         mComputedMargin.top - mComputedBorderPadding.top - mComputedHeight -
    1:         mComputedBorderPadding.bottom - mComputedMargin.bottom;
    1:     }
    1:   } else {
    1:     // Neither 'top' nor 'bottom' is 'auto'.
    1:     nscoord autoHeight = containingBlockHeight -
    1:                          mComputedOffsets.TopBottom() -
    1:                          mComputedMargin.TopBottom() -
    1:                          mComputedBorderPadding.TopBottom();
    1:     if (autoHeight < 0) {
    1:       autoHeight = 0;
    1:     }
    1: 
    1:     if (mComputedHeight == NS_UNCONSTRAINEDSIZE) {
    1:       // For non-replaced elements with 'height' auto, the 'height'
    1:       // fills the remaining space.
    1:       mComputedHeight = autoHeight;
    1: 
    1:       // XXX Do these need box-sizing adjustments?
    1:       if (mComputedHeight > mComputedMaxHeight)
    1:         mComputedHeight = mComputedMaxHeight;
    1:       if (mComputedHeight < mComputedMinHeight)
    1:         mComputedHeight = mComputedMinHeight;
    1:     }
    1: 
    1:     // The height might still not fill all the available space in case:
    1:     //  * height was specified
    1:     //  * we're dealing with a replaced element
    1:     //  * height was constrained by min-height or max-height.
    1:     nscoord availMarginSpace = autoHeight - mComputedHeight;
    1:     PRBool marginTopIsAuto =
    1:       eStyleUnit_Auto == mStyleMargin->mMargin.GetTopUnit();
    1:     PRBool marginBottomIsAuto =
    1:       eStyleUnit_Auto == mStyleMargin->mMargin.GetBottomUnit();
    1: 
    1:     if (availMarginSpace < 0 || (!marginTopIsAuto && !marginBottomIsAuto)) {
    1:       // We're over-constrained so ignore the specified value for
    1:       // 'bottom'.  (And note that the spec says to ignore 'bottom'
    1:       // rather than 'margin-bottom'.)
    1:       mComputedOffsets.bottom += availMarginSpace;
    1:     } else if (marginTopIsAuto) {
    1:       if (marginBottomIsAuto) {
    1:         // Both 'margin-top' and 'margin-bottom' are 'auto', so they get
    1:         // equal values
    1:         mComputedMargin.top = availMarginSpace / 2;
    1:         mComputedMargin.bottom = availMarginSpace - mComputedMargin.top;
    1:       } else {
    1:         // Just 'margin-top' is 'auto'
    1:         mComputedMargin.top = availMarginSpace - mComputedMargin.bottom;
    1:       }
    1:     } else {
    1:       // Just 'margin-bottom' is 'auto'
    1:       mComputedMargin.bottom = availMarginSpace - mComputedMargin.top;
    1:     }
    1:   }
    1: }
    1: 
    1: nscoord 
    1: GetVerticalMarginBorderPadding(const nsHTMLReflowState* aReflowState)
    1: {
    1:   nscoord result = 0;
    1:   if (!aReflowState) return result;
    1: 
    1:   // zero auto margins
    1:   nsMargin margin = aReflowState->mComputedMargin;
    1:   if (NS_AUTOMARGIN == margin.top) 
    1:     margin.top = 0;
    1:   if (NS_AUTOMARGIN == margin.bottom) 
    1:     margin.bottom = 0;
    1: 
    1:   result += margin.top + margin.bottom;
    1:   result += aReflowState->mComputedBorderPadding.top + 
    1:             aReflowState->mComputedBorderPadding.bottom;
    1: 
    1:   return result;
    1: }
    1: 
    1: /* Get the height based on the viewport of the containing block specified 
    1:  * in aReflowState when the containing block has mComputedHeight == NS_AUTOHEIGHT
    1:  * This will walk up the chain of containing blocks looking for a computed height
    1:  * until it finds the canvas frame, or it encounters a frame that is not a block,
    1:  * area, or scroll frame. This handles compatibility with IE (see bug 85016 and bug 219693)
    1:  *
23296:  *  When we encounter scrolledContent block frames, we skip over them, since they are guaranteed to not be useful for computing the containing block.
 1488:  *
 1488:  * See also IsQuirkContainingBlockHeight.
    1:  */
 1488: static nscoord
    1: CalcQuirkContainingBlockHeight(const nsHTMLReflowState* aCBReflowState)
    1: {
    1:   nsHTMLReflowState* firstAncestorRS = nsnull; // a candidate for html frame
    1:   nsHTMLReflowState* secondAncestorRS = nsnull; // a candidate for body frame
    1:   
    1:   // initialize the default to NS_AUTOHEIGHT as this is the containings block
    1:   // computed height when this function is called. It is possible that we 
    1:   // don't alter this height especially if we are restricted to one level
    1:   nscoord result = NS_AUTOHEIGHT; 
    1:                              
    1:   const nsHTMLReflowState* rs = aCBReflowState;
 1488:   for (; rs; rs = (nsHTMLReflowState *)(rs->parentReflowState)) { 
    1:     nsIAtom* frameType = rs->frame->GetType();
    1:     // if the ancestor is auto height then skip it and continue up if it 
23296:     // is the first block frame and possibly the body/html
    1:     if (nsGkAtoms::blockFrame == frameType ||
23176: #ifdef MOZ_XUL
23176:         nsGkAtoms::XULLabelFrame == frameType ||
23176: #endif
    1:         nsGkAtoms::scrollFrame == frameType) {
    1: 
    1:       secondAncestorRS = firstAncestorRS;
    1:       firstAncestorRS = (nsHTMLReflowState*)rs;
    1: 
    1:       // If the current frame we're looking at is positioned, we don't want to
    1:       // go any further (see bug 221784).  The behavior we want here is: 1) If
    1:       // not auto-height, use this as the percentage base.  2) If auto-height,
    1:       // keep looking, unless the frame is positioned.
 4166:       if (NS_AUTOHEIGHT == rs->ComputedHeight()) {
    1:         if (rs->frame->GetStyleDisplay()->IsAbsolutelyPositioned()) {
    1:           break;
    1:         } else {
    1:           continue;
    1:         }
    1:       }
    1:     }
    1:     else if (nsGkAtoms::canvasFrame == frameType) {
 8731:       // Always continue on to the height calculation
    1:     }
    1:     else if (nsGkAtoms::pageContentFrame == frameType) {
    1:       nsIFrame* prevInFlow = rs->frame->GetPrevInFlow();
    1:       // only use the page content frame for a height basis if it is the first in flow
    1:       if (prevInFlow) 
    1:         break;
    1:     }
    1:     else {
    1:       break;
    1:     }
    1: 
    1:     // if the ancestor is the page content frame then the percent base is 
    1:     // the avail height, otherwise it is the computed height
    1:     result = (nsGkAtoms::pageContentFrame == frameType)
 4166:              ? rs->availableHeight : rs->ComputedHeight();
    1:     // if unconstrained - don't sutract borders - would result in huge height
    1:     if (NS_AUTOHEIGHT == result) return result;
    1: 
    1:     // if we got to the canvas or page content frame, then subtract out 
    1:     // margin/border/padding for the BODY and HTML elements
    1:     if ((nsGkAtoms::canvasFrame == frameType) || 
    1:         (nsGkAtoms::pageContentFrame == frameType)) {
    1: 
    1:       result -= GetVerticalMarginBorderPadding(firstAncestorRS); 
    1:       result -= GetVerticalMarginBorderPadding(secondAncestorRS); 
    1: 
    1: #ifdef DEBUG
    1:       // make sure the first ancestor is the HTML and the second is the BODY
    1:       if (firstAncestorRS) {
    1:         nsIContent* frameContent = firstAncestorRS->frame->GetContent();
    1:         if (frameContent) {
    1:           nsIAtom *contentTag = frameContent->Tag();
    1:           NS_ASSERTION(contentTag == nsGkAtoms::html, "First ancestor is not HTML");
    1:         }
    1:       }
    1:       if (secondAncestorRS) {
    1:         nsIContent* frameContent = secondAncestorRS->frame->GetContent();
    1:         if (frameContent) {
    1:           nsIAtom *contentTag = frameContent->Tag();
    1:           NS_ASSERTION(contentTag == nsGkAtoms::body, "Second ancestor is not BODY");
    1:         }
    1:       }
    1: #endif
    1:       
    1:     }
23175:     // if we got to the html frame (a block child of the canvas) ...
23175:     else if (nsGkAtoms::blockFrame == frameType &&
23175:              nsGkAtoms::canvasFrame ==
23175:                rs->parentReflowState->frame->GetType()) {
23175:       // ... then subtract out margin/border/padding for the BODY element
    1:       result -= GetVerticalMarginBorderPadding(secondAncestorRS);
    1:     }
    1:     break;
    1:   }
    1: 
    1:   // Make sure not to return a negative height here!
32531:   return NS_MAX(result, 0);
    1: }
    1: // Called by InitConstraints() to compute the containing block rectangle for
    1: // the element. Handles the special logic for absolutely positioned elements
    1: void
    1: nsHTMLReflowState::ComputeContainingBlockRectangle(nsPresContext*          aPresContext,
    1:                                                    const nsHTMLReflowState* aContainingBlockRS,
    1:                                                    nscoord&                 aContainingBlockWidth,
    1:                                                    nscoord&                 aContainingBlockHeight)
    1: {
    1:   // Unless the element is absolutely positioned, the containing block is
    1:   // formed by the content edge of the nearest block-level ancestor
    1:   aContainingBlockWidth = aContainingBlockRS->mComputedWidth;
    1:   aContainingBlockHeight = aContainingBlockRS->mComputedHeight;
    1:   
    1:   if (NS_FRAME_GET_TYPE(mFrameType) == NS_CSS_FRAME_TYPE_ABSOLUTE) {
    1:     // See if the ancestor is block-level or inline-level
    1:     if (NS_FRAME_GET_TYPE(aContainingBlockRS->mFrameType) == NS_CSS_FRAME_TYPE_INLINE) {
    1:       // Base our size on the actual size of the frame.  In cases when this is
    1:       // completely bogus (eg initial reflow), this code shouldn't even be
    1:       // called, since the code in nsPositionedInlineFrame::Reflow will pass in
    1:       // the containing block dimensions to our constructor.
    1:       // XXXbz we should be taking the in-flows into account too, but
    1:       // that's very hard.
    1:       nsMargin computedBorder = aContainingBlockRS->mComputedBorderPadding -
    1:         aContainingBlockRS->mComputedPadding;
    1:       aContainingBlockWidth = aContainingBlockRS->frame->GetRect().width -
    1:         computedBorder.LeftRight();;
    1:       NS_ASSERTION(aContainingBlockWidth >= 0,
    1:                    "Negative containing block width!");
    1:       aContainingBlockHeight = aContainingBlockRS->frame->GetRect().height -
    1:         computedBorder.TopBottom();
    1:       NS_ASSERTION(aContainingBlockHeight >= 0,
    1:                    "Negative containing block height!");
    1:     } else {
    1:       // If the ancestor is block-level, the containing block is formed by the
    1:       // padding edge of the ancestor
    1:       aContainingBlockWidth += aContainingBlockRS->mComputedPadding.LeftRight();
18953:       aContainingBlockHeight += aContainingBlockRS->mComputedPadding.TopBottom();
    1:     }
    1:   } else {
    1:     // an element in quirks mode gets a containing block based on looking for a
    1:     // parent with a non-auto height if the element has a percent height
51406:     // Note: We don't emulate this quirk for percents in calc().
    1:     if (NS_AUTOHEIGHT == aContainingBlockHeight) {
    1:       if (eCompatibility_NavQuirks == aPresContext->CompatibilityMode() &&
    1:           mStylePosition->mHeight.GetUnit() == eStyleUnit_Percent) {
    1:         aContainingBlockHeight = CalcQuirkContainingBlockHeight(aContainingBlockRS);
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: // Prefs callback to pick up changes
20261: static int
    1: PrefsChanged(const char *aPrefName, void *instance)
    1: {
    1:   sBlinkIsAllowed =
    1:     nsContentUtils::GetBoolPref("browser.blink_allowed", sBlinkIsAllowed);
    1: 
    1:   return 0; /* PREF_OK */
    1: }
    1: 
    1: // Check to see if |text-decoration: blink| is allowed.  The first time
    1: // called, register the callback and then force-load the pref.  After that,
    1: // just use the cached value.
    1: static PRBool BlinkIsAllowed(void)
    1: {
    1:   if (!sPrefIsLoaded) {
    1:     // Set up a listener and check the initial value
    1:     nsContentUtils::RegisterPrefCallback("browser.blink_allowed", PrefsChanged,
    1:                                          nsnull);
    1:     PrefsChanged(nsnull, nsnull);
    1:     sPrefIsLoaded = PR_TRUE;
    1:   }
    1:   return sBlinkIsAllowed;
    1: }
    1: 
    1: static eNormalLineHeightControl GetNormalLineHeightCalcControl(void)
    1: {
    1:   if (sNormalLineHeightControl == eUninitialized) {
    1:     // browser.display.normal_lineheight_calc_control is not user
    1:     // changeable, so no need to register callback for it.
    1:     sNormalLineHeightControl =
 3233:       static_cast<eNormalLineHeightControl>
 3233:                  (nsContentUtils::GetIntPref("browser.display.normal_lineheight_calc_control", eNoExternalLeading));
    1:   }
    1:   return sNormalLineHeightControl;
    1: }
    1: 
12310: static inline PRBool
12310: IsSideCaption(nsIFrame* aFrame, const nsStyleDisplay* aStyleDisplay)
12310: {
12310:   if (aStyleDisplay->mDisplay != NS_STYLE_DISPLAY_TABLE_CAPTION)
12310:     return PR_FALSE;
12310:   PRUint8 captionSide = aFrame->GetStyleTableBorder()->mCaptionSide;
12310:   return captionSide == NS_STYLE_CAPTION_SIDE_LEFT ||
12310:          captionSide == NS_STYLE_CAPTION_SIDE_RIGHT;
12310: }
12310: 
    1: // XXX refactor this code to have methods for each set of properties
    1: // we are computing: width,height,line-height; margin; offsets
    1: 
    1: void
    1: nsHTMLReflowState::InitConstraints(nsPresContext* aPresContext,
    1:                                    nscoord         aContainingBlockWidth,
    1:                                    nscoord         aContainingBlockHeight,
    1:                                    const nsMargin* aBorder,
    1:                                    const nsMargin* aPadding)
    1: {
41687:   DISPLAY_INIT_CONSTRAINTS(frame, this,
41687:                            aContainingBlockWidth, aContainingBlockHeight,
41687:                            aBorder, aPadding);
41687: 
38828:   // Since we are in reflow, we don't need to store these properties anymore
39965:   FrameProperties props(aPresContext->PropertyTable(), frame);
39965:   props.Delete(nsIFrame::UsedBorderProperty());
39965:   props.Delete(nsIFrame::UsedPaddingProperty());
39965:   props.Delete(nsIFrame::UsedMarginProperty());
38828: 
    1:   // If this is the root frame, then set the computed width and
    1:   // height equal to the available space
    1:   if (nsnull == parentReflowState) {
    1:     // XXXldb This doesn't mean what it used to!
    1:     InitOffsets(aContainingBlockWidth, aBorder, aPadding);
    1:     // Override mComputedMargin since reflow roots start from the
    1:     // frame's boundary, which is inside the margin.
    1:     mComputedMargin.SizeTo(0, 0, 0, 0);
    1:     mComputedOffsets.SizeTo(0, 0, 0, 0);
    1: 
    1:     mComputedWidth = availableWidth - mComputedBorderPadding.LeftRight();
    1:     if (mComputedWidth < 0)
    1:       mComputedWidth = 0;
    1:     if (availableHeight != NS_UNCONSTRAINEDSIZE) {
    1:       mComputedHeight = availableHeight - mComputedBorderPadding.TopBottom();
    1:       if (mComputedHeight < 0)
    1:         mComputedHeight = 0;
    1:     } else {
    1:       mComputedHeight = NS_UNCONSTRAINEDSIZE;
    1:     }
    1: 
    1:     mComputedMinWidth = mComputedMinHeight = 0;
    1:     mComputedMaxWidth = mComputedMaxHeight = NS_UNCONSTRAINEDSIZE;
    1:   } else {
    1:     // Get the containing block reflow state
    1:     const nsHTMLReflowState* cbrs = mCBReflowState;
    1:     NS_ASSERTION(nsnull != cbrs, "no containing block");
    1: 
    1:     // If we weren't given a containing block width and height, then
    1:     // compute one
    1:     if (aContainingBlockWidth == -1) {
    1:       ComputeContainingBlockRectangle(aPresContext, cbrs, aContainingBlockWidth, 
    1:                                       aContainingBlockHeight);
    1:     }
    1: 
    1:     // See if the containing block height is based on the size of its
    1:     // content
    1:     nsIAtom* fType;
    1:     if (NS_AUTOHEIGHT == aContainingBlockHeight) {
 8731:       // See if the containing block is a cell frame which needs
    1:       // to use the mComputedHeight of the cell instead of what the cell block passed in.
 8731:       // XXX It seems like this could lead to bugs with min-height and friends
    1:       if (cbrs->parentReflowState) {
    1:         fType = cbrs->frame->GetType();
    1:         if (IS_TABLE_CELL(fType)) {
    1:           // use the cell's computed height 
    1:           aContainingBlockHeight = cbrs->mComputedHeight;
    1:         }
    1:       }
    1:     }
    1: 
    1:     InitOffsets(aContainingBlockWidth, aBorder, aPadding);
    1: 
51406:     const nsStyleCoord &height = mStylePosition->mHeight;
51406:     nsStyleUnit heightUnit = height.GetUnit();
    1: 
    1:     // Check for a percentage based height and a containing block height
    1:     // that depends on the content height
    1:     // XXX twiddling heightUnit doesn't help anymore
51406:     // FIXME Shouldn't we fix that?
51406:     if (height.HasPercent()) {
    1:       if (NS_AUTOHEIGHT == aContainingBlockHeight) {
    1:         // this if clause enables %-height on replaced inline frames,
    1:         // such as images.  See bug 54119.  The else clause "heightUnit = eStyleUnit_Auto;"
    1:         // used to be called exclusively.
    1:         if (NS_FRAME_REPLACED(NS_CSS_FRAME_TYPE_INLINE) == mFrameType ||
    1:             NS_FRAME_REPLACED_CONTAINS_BLOCK(
    1:                 NS_CSS_FRAME_TYPE_INLINE) == mFrameType) {
    1:           // Get the containing block reflow state
    1:           NS_ASSERTION(nsnull != cbrs, "no containing block");
    1:           // in quirks mode, get the cb height using the special quirk method
    1:           if (eCompatibility_NavQuirks == aPresContext->CompatibilityMode()) {
    1:             if (!IS_TABLE_CELL(fType)) {
    1:               aContainingBlockHeight = CalcQuirkContainingBlockHeight(cbrs);
    1:               if (aContainingBlockHeight == NS_AUTOHEIGHT) {
    1:                 heightUnit = eStyleUnit_Auto;
    1:               }
    1:             }
    1:             else {
    1:               heightUnit = eStyleUnit_Auto;
    1:             }
    1:           }
    1:           // in standard mode, use the cb height.  if it's "auto", as will be the case
    1:           // by default in BODY, use auto height as per CSS2 spec.
    1:           else 
    1:           {
    1:             if (NS_AUTOHEIGHT != cbrs->mComputedHeight)
    1:               aContainingBlockHeight = cbrs->mComputedHeight;
    1:             else
    1:               heightUnit = eStyleUnit_Auto;
    1:           }
    1:         }
    1:         else {
    1:           // default to interpreting the height like 'auto'
    1:           heightUnit = eStyleUnit_Auto;
    1:         }
    1:       }
    1:     }
    1: 
    1:     // Compute our offsets if the element is relatively positioned.  We need
    1:     // the correct containing block width and height here, which is why we need
    1:     // to do it after all the quirks-n-such above.
    1:     if (NS_STYLE_POSITION_RELATIVE == mStyleDisplay->mPosition) {
14460:       ComputeRelativeOffsets(cbrs, aContainingBlockWidth, aContainingBlockHeight, aPresContext);
    1:     } else {
    1:       // Initialize offsets to 0
    1:       mComputedOffsets.SizeTo(0, 0, 0, 0);
    1:     }
    1: 
    1:     // Calculate the computed values for min and max properties.  Note that
    1:     // this MUST come after we've computed our border and padding.
    1:     ComputeMinMaxValues(aContainingBlockWidth, aContainingBlockHeight, cbrs);
    1: 
    1:     // Calculate the computed width and height. This varies by frame type
    1: 
    1:     if (NS_CSS_FRAME_TYPE_INTERNAL_TABLE == mFrameType) {
    1:       // Internal table elements. The rules vary depending on the type.
    1:       // Calculate the computed width
    1:       PRBool rowOrRowGroup = PR_FALSE;
51406:       const nsStyleCoord &width = mStylePosition->mWidth;
51406:       nsStyleUnit widthUnit = width.GetUnit();
    1:       if ((NS_STYLE_DISPLAY_TABLE_ROW == mStyleDisplay->mDisplay) ||
    1:           (NS_STYLE_DISPLAY_TABLE_ROW_GROUP == mStyleDisplay->mDisplay)) {
    1:         // 'width' property doesn't apply to table rows and row groups
    1:         widthUnit = eStyleUnit_Auto;
    1:         rowOrRowGroup = PR_TRUE;
    1:       }
    1: 
51406:       // calc() acts like auto on internal table elements
51406:       if (eStyleUnit_Auto == widthUnit || width.IsCalcUnit()) {
    1:         mComputedWidth = availableWidth;
    1: 
    1:         if ((mComputedWidth != NS_UNCONSTRAINEDSIZE) && !rowOrRowGroup){
    1:           // Internal table elements don't have margins. Only tables and
    1:           // cells have border and padding
    1:           mComputedWidth -= mComputedBorderPadding.left +
    1:             mComputedBorderPadding.right;
11744:           if (mComputedWidth < 0)
11744:             mComputedWidth = 0;
    1:         }
11744:         NS_ASSERTION(mComputedWidth >= 0, "Bogus computed width");
    1:       
    1:       } else {
    1:         NS_ASSERTION(widthUnit == mStylePosition->mWidth.GetUnit(),
    1:                      "unexpected width unit change");
 1068:         mComputedWidth = ComputeWidthValue(aContainingBlockWidth,
 1068:                                            mStylePosition->mBoxSizing,
 1068:                                            mStylePosition->mWidth);
    1:       }
    1: 
    1:       // Calculate the computed height
    1:       if ((NS_STYLE_DISPLAY_TABLE_COLUMN == mStyleDisplay->mDisplay) ||
    1:           (NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP == mStyleDisplay->mDisplay)) {
    1:         // 'height' property doesn't apply to table columns and column groups
    1:         heightUnit = eStyleUnit_Auto;
    1:       }
51406:       // calc() acts like 'auto' on internal table elements
51406:       if (eStyleUnit_Auto == heightUnit || height.IsCalcUnit()) {
    1:         mComputedHeight = NS_AUTOHEIGHT;
    1:       } else {
    1:         NS_ASSERTION(heightUnit == mStylePosition->mHeight.GetUnit(),
    1:                      "unexpected height unit change");
16031:         mComputedHeight = nsLayoutUtils::
51406:           ComputeHeightValue(aContainingBlockHeight, mStylePosition->mHeight);
    1:       }
    1: 
    1:       // Doesn't apply to table elements
    1:       mComputedMinWidth = mComputedMinHeight = 0;
    1:       mComputedMaxWidth = mComputedMaxHeight = NS_UNCONSTRAINEDSIZE;
    1: 
    1:     } else if (NS_FRAME_GET_TYPE(mFrameType) == NS_CSS_FRAME_TYPE_ABSOLUTE) {
    1:       // XXX not sure if this belongs here or somewhere else - cwk
    1:       InitAbsoluteConstraints(aPresContext, cbrs, aContainingBlockWidth,
    1:                               aContainingBlockHeight);
    1:     } else {
    1:       PRBool isBlock =
    1:         NS_CSS_FRAME_TYPE_BLOCK == NS_FRAME_GET_TYPE(mFrameType);
30867:       // make sure legend frames with display:block and width:auto still
30867:       // shrink-wrap
30867:       PRBool shrinkWrap = !isBlock || frame->GetType() == nsGkAtoms::legendFrame;
    1:       nsSize size =
    1:         frame->ComputeSize(rendContext,
    1:                            nsSize(aContainingBlockWidth,
    1:                                   aContainingBlockHeight),
    1:                            availableWidth,
    1:                            nsSize(mComputedMargin.LeftRight(),
    1:                                   mComputedMargin.TopBottom()),
    1:                            nsSize(mComputedBorderPadding.LeftRight() -
    1:                                     mComputedPadding.LeftRight(),
    1:                                   mComputedBorderPadding.TopBottom() -
    1:                                     mComputedPadding.TopBottom()),
    1:                            nsSize(mComputedPadding.LeftRight(),
    1:                                   mComputedPadding.TopBottom()),
30867:                            shrinkWrap);
    1: 
    1:       mComputedWidth = size.width;
    1:       mComputedHeight = size.height;
11744:       NS_ASSERTION(mComputedWidth >= 0, "Bogus width");
11744:       NS_ASSERTION(mComputedHeight == NS_UNCONSTRAINEDSIZE ||
11744:                    mComputedHeight >= 0, "Bogus height");
    1: 
12310:       if (isBlock && !IsSideCaption(frame, mStyleDisplay))
    1:         CalculateBlockSideMargins(availableWidth, mComputedWidth);
    1:     }
    1:   }
    1:   // Check for blinking text and permission to display it
    1:   mFlags.mBlinks = (parentReflowState && parentReflowState->mFlags.mBlinks);
    1:   if (!mFlags.mBlinks && BlinkIsAllowed()) {
    1:     const nsStyleTextReset* st = frame->GetStyleTextReset();
    1:     mFlags.mBlinks = 
    1:       ((st->mTextDecoration & NS_STYLE_TEXT_DECORATION_BLINK) != 0);
    1:   }
    1: }
    1: 
    1: void
    1: nsCSSOffsetState::InitOffsets(nscoord aContainingBlockWidth,
    1:                               const nsMargin *aBorder,
    1:                               const nsMargin *aPadding)
    1: {
41687:   DISPLAY_INIT_OFFSETS(frame, this, aContainingBlockWidth, aBorder, aPadding);
41687: 
    1:   // Compute margins from the specified margin style information. These
    1:   // become the default computed values, and may be adjusted below
    1:   // XXX fix to provide 0,0 for the top&bottom margins for
    1:   // inline-non-replaced elements
    1:   ComputeMargin(aContainingBlockWidth);
    1: 
    1:   const nsStyleDisplay *disp = frame->GetStyleDisplay();
    1:   PRBool isThemed = frame->IsThemed(disp);
  238:   nsPresContext *presContext = frame->PresContext();
    1: 
23738:   nsIntMargin widget;
    1:   if (isThemed &&
    1:       presContext->GetTheme()->GetWidgetPadding(presContext->DeviceContext(),
    1:                                                 frame, disp->mAppearance,
23738:                                                 &widget)) {
23738:     mComputedPadding.top = presContext->DevPixelsToAppUnits(widget.top);
23738:     mComputedPadding.right = presContext->DevPixelsToAppUnits(widget.right);
23738:     mComputedPadding.bottom = presContext->DevPixelsToAppUnits(widget.bottom);
23738:     mComputedPadding.left = presContext->DevPixelsToAppUnits(widget.left);
    1:   }
    1:   else if (aPadding) { // padding is an input arg
    1:     mComputedPadding.top    = aPadding->top;
    1:     mComputedPadding.right  = aPadding->right;
    1:     mComputedPadding.bottom = aPadding->bottom;
    1:     mComputedPadding.left   = aPadding->left;
    1:   }
    1:   else {
    1:     ComputePadding(aContainingBlockWidth);
    1:   }
    1: 
    1:   if (isThemed) {
23738:     nsIntMargin widget;
    1:     presContext->GetTheme()->GetWidgetBorder(presContext->DeviceContext(),
    1:                                              frame, disp->mAppearance,
23738:                                              &widget);
    1:     mComputedBorderPadding.top =
23738:       presContext->DevPixelsToAppUnits(widget.top);
    1:     mComputedBorderPadding.right =
23738:       presContext->DevPixelsToAppUnits(widget.right);
    1:     mComputedBorderPadding.bottom =
23738:       presContext->DevPixelsToAppUnits(widget.bottom);
    1:     mComputedBorderPadding.left =
23738:       presContext->DevPixelsToAppUnits(widget.left);
    1:   }
    1:   else if (aBorder) {  // border is an input arg
    1:     mComputedBorderPadding = *aBorder;
    1:   }
    1:   else {
15992:     mComputedBorderPadding = frame->GetStyleBorder()->GetActualBorder();
    1:   }
    1:   mComputedBorderPadding += mComputedPadding;
    1: 
30886:   nsIAtom* frameType = frame->GetType();
30886:   if (frameType == nsGkAtoms::tableFrame) {
 3233:     nsTableFrame *tableFrame = static_cast<nsTableFrame*>(frame);
    1: 
    1:     if (tableFrame->IsBorderCollapse()) {
    1:       // border-collapsed tables don't use any of their padding, and
    1:       // only part of their border.  We need to do this here before we
    1:       // try to do anything like handling 'auto' widths,
    1:       // '-moz-box-sizing', or 'auto' margins.
    1:       mComputedPadding.SizeTo(0,0,0,0);
    1:       mComputedBorderPadding = tableFrame->GetIncludedOuterBCBorder();
    1:     }
30886:   } else if (frameType == nsGkAtoms::scrollbarFrame) {
30886:     // scrollbars may have had their width or height smashed to zero
30886:     // by the associated scrollframe, in which case we must not report
31617:     // any padding or border.
30886:     nsSize size(frame->GetSize());
31617:     if (size.width == 0 || size.height == 0) {
30886:       mComputedPadding.left = 0;
30886:       mComputedPadding.right = 0;
30886:       mComputedBorderPadding.left = 0;
30886:       mComputedBorderPadding.right = 0;
30886:       mComputedPadding.top = 0;
30886:       mComputedPadding.bottom = 0;
30886:       mComputedBorderPadding.top = 0;
30886:       mComputedBorderPadding.bottom = 0;
30886:     }
    1:   }
    1: }
    1: 
    1: // This code enforces section 10.3.3 of the CSS2 spec for this formula:
    1: //
    1: // 'margin-left' + 'border-left-width' + 'padding-left' + 'width' +
    1: //   'padding-right' + 'border-right-width' + 'margin-right'
    1: //   = width of containing block 
    1: //
    1: // Note: the width unit is not auto when this is called
    1: void
    1: nsHTMLReflowState::CalculateBlockSideMargins(nscoord aAvailWidth,
    1:                                              nscoord aComputedWidth)
    1: {
34267:   NS_WARN_IF_FALSE(NS_UNCONSTRAINEDSIZE != aComputedWidth &&
    1:                    NS_UNCONSTRAINEDSIZE != aAvailWidth,
34267:                    "have unconstrained width; this should only result from "
34267:                    "very large sizes, not attempts at intrinsic width "
34267:                    "calculation");
    1: 
    1:   nscoord sum = mComputedMargin.left + mComputedBorderPadding.left +
    1:     aComputedWidth + mComputedBorderPadding.right + mComputedMargin.right;
    1:   if (sum == aAvailWidth)
    1:     // The sum is already correct
    1:     return;
    1: 
    1:   // Determine the left and right margin values. The width value
    1:   // remains constant while we do this.
    1: 
    1:   // Calculate how much space is available for margins
    1:   nscoord availMarginSpace = aAvailWidth - sum;
    1: 
    1:   // If the available margin space is negative, then don't follow the
    1:   // usual overconstraint rules.
    1:   if (availMarginSpace < 0) {
    1:     if (mCBReflowState &&
    1:         mCBReflowState->mStyleVisibility->mDirection == NS_STYLE_DIRECTION_RTL) {
    1:       mComputedMargin.left += availMarginSpace;
    1:     } else {
    1:       mComputedMargin.right += availMarginSpace;
    1:     }
    1:     return;
    1:   }
    1: 
    1:   // The css2 spec clearly defines how block elements should behave
    1:   // in section 10.3.3.
    1:   PRBool isAutoLeftMargin =
    1:     eStyleUnit_Auto == mStyleMargin->mMargin.GetLeftUnit();
    1:   PRBool isAutoRightMargin =
    1:     eStyleUnit_Auto == mStyleMargin->mMargin.GetRightUnit();
    1:   if (!isAutoLeftMargin && !isAutoRightMargin) {
    1:     // Neither margin is 'auto' so we're over constrained. Use the
    1:     // 'direction' property of the parent to tell which margin to
    1:     // ignore
    1:     // First check if there is an HTML alignment that we should honor
    1:     const nsHTMLReflowState* prs = parentReflowState;
    1:     if (frame->GetType() == nsGkAtoms::tableFrame) {
    1:       NS_ASSERTION(prs->frame->GetType() == nsGkAtoms::tableOuterFrame,
    1:                    "table not inside outer table");
    1:       // Center the table within the outer table based on the alignment
    1:       // of the outer table's parent.
    1:       prs = prs->parentReflowState;
    1:     }
    1:     if (prs &&
    1:         (prs->mStyleText->mTextAlign == NS_STYLE_TEXT_ALIGN_MOZ_LEFT ||
    1:          prs->mStyleText->mTextAlign == NS_STYLE_TEXT_ALIGN_MOZ_CENTER ||
    1:          prs->mStyleText->mTextAlign == NS_STYLE_TEXT_ALIGN_MOZ_RIGHT)) {
    1:       isAutoLeftMargin =
    1:         prs->mStyleText->mTextAlign != NS_STYLE_TEXT_ALIGN_MOZ_LEFT;
    1:       isAutoRightMargin =
    1:         prs->mStyleText->mTextAlign != NS_STYLE_TEXT_ALIGN_MOZ_RIGHT;
    1:     }
    1:     // Otherwise apply the CSS rules, and ignore one margin by forcing
    1:     // it to 'auto', depending on 'direction'.
    1:     else if (mCBReflowState &&
    1:              NS_STYLE_DIRECTION_RTL == mCBReflowState->mStyleVisibility->mDirection) {
    1:       isAutoLeftMargin = PR_TRUE;
    1:     }
    1:     else {
    1:       isAutoRightMargin = PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   // Logic which is common to blocks and tables
18538:   // The computed margins need not be zero because the 'auto' could come from
18538:   // overconstraint or from HTML alignment so values need to be accumulated
18538: 
    1:   if (isAutoLeftMargin) {
    1:     if (isAutoRightMargin) {
18538:       // Both margins are 'auto' so the computed addition should be equal
18538:       nscoord forLeft = availMarginSpace / 2;
18538:       mComputedMargin.left  += forLeft;
18538:       mComputedMargin.right += availMarginSpace - forLeft;
    1:     } else {
    1:       mComputedMargin.left += availMarginSpace;
    1:     }
    1:   } else if (isAutoRightMargin) {
    1:     mComputedMargin.right += availMarginSpace;
    1:   }
    1: }
    1: 
    1: #define NORMAL_LINE_HEIGHT_FACTOR 1.2f    // in term of emHeight 
    1: // For "normal" we use the font's normal line height (em height + leading).
    1: // If both internal leading and  external leading specified by font itself
    1: // are zeros, we should compensate this by creating extra (external) leading 
    1: // in eCompensateLeading mode. This is necessary because without this 
    1: // compensation, normal line height might looks too tight. 
    1: 
    1: // For risk management, we use preference to control the behavior, and 
    1: // eNoExternalLeading is the old behavior.
    1: static nscoord
    1: GetNormalLineHeight(nsIFontMetrics* aFontMetrics)
    1: {
    1:   NS_PRECONDITION(nsnull != aFontMetrics, "no font metrics");
    1: 
    1:   nscoord normalLineHeight;
    1: 
    1:   nscoord externalLeading, internalLeading, emHeight;
    1:   aFontMetrics->GetExternalLeading(externalLeading);
    1:   aFontMetrics->GetInternalLeading(internalLeading);
    1:   aFontMetrics->GetEmHeight(emHeight);
    1:   switch (GetNormalLineHeightCalcControl()) {
    1:   case eIncludeExternalLeading:
    1:     normalLineHeight = emHeight+ internalLeading + externalLeading;
    1:     break;
    1:   case eCompensateLeading:
    1:     if (!internalLeading && !externalLeading)
    1:       normalLineHeight = NSToCoordRound(emHeight * NORMAL_LINE_HEIGHT_FACTOR);
    1:     else
    1:       normalLineHeight = emHeight+ internalLeading + externalLeading;
    1:     break;
    1:   default:
    1:     //case eNoExternalLeading:
    1:     normalLineHeight = emHeight + internalLeading;
    1:   }
    1:   return normalLineHeight;
    1: }
    1: 
    1: static nscoord
28519: ComputeLineHeight(nsStyleContext* aStyleContext,
28519:                   nscoord aBlockHeight)
    1: {
    1:   const nsStyleCoord& lhCoord = aStyleContext->GetStyleText()->mLineHeight;
    1: 
16031:   if (lhCoord.GetUnit() == eStyleUnit_Coord)
16031:     return lhCoord.GetCoordValue();
16031: 
16031:   if (lhCoord.GetUnit() == eStyleUnit_Factor)
    1:     // For factor units the computed value of the line-height property 
    1:     // is found by multiplying the factor by the font's computed size
    1:     // (adjusted for min-size prefs and text zoom).
16031:     return NSToCoordRound(lhCoord.GetFactorValue() *
16031:                           aStyleContext->GetStyleFont()->mFont.size);
16031: 
28519:   NS_ASSERTION(lhCoord.GetUnit() == eStyleUnit_Normal ||
28519:                lhCoord.GetUnit() == eStyleUnit_Enumerated,
28519:                "bad line-height unit");
16031:   
28519:   if (lhCoord.GetUnit() == eStyleUnit_Enumerated) {
28519:     NS_ASSERTION(lhCoord.GetIntValue() == NS_STYLE_LINE_HEIGHT_BLOCK_HEIGHT,
28519:                  "bad line-height value");
28519:     if (aBlockHeight != NS_AUTOHEIGHT)
28519:       return aBlockHeight;
28519:   }
28519: 
    1:   nsCOMPtr<nsIFontMetrics> fm;
 4353:   nsLayoutUtils::GetFontMetricsForStyleContext(aStyleContext,
 4353:                                                getter_AddRefs(fm));
16031:   return GetNormalLineHeight(fm);
    1: }
    1: 
    1: nscoord
28519: nsHTMLReflowState::CalcLineHeight() const
28519: {
28519:   nscoord blockHeight =
28519:     frame->IsContainingBlock() ? mComputedHeight :
28519:     (mCBReflowState ? mCBReflowState->mComputedHeight : NS_AUTOHEIGHT);
28519: 
28519:   return CalcLineHeight(frame->GetStyleContext(), blockHeight);
28519: }
28519: 
28519: /* static */ nscoord
28519: nsHTMLReflowState::CalcLineHeight(nsStyleContext* aStyleContext,
28519:                                   nscoord aBlockHeight)
    1: {
 5256:   NS_PRECONDITION(aStyleContext, "Must have a style context");
    1:   
28519:   nscoord lineHeight = ComputeLineHeight(aStyleContext, aBlockHeight);
 1102: 
 1102:   NS_ASSERTION(lineHeight >= 0, "ComputeLineHeight screwed up");
 1102: 
 1102:   return lineHeight;
 1102: }
 1102: 
    1: void
    1: nsCSSOffsetState::ComputeMargin(nscoord aContainingBlockWidth)
    1: {
    1:   // If style style can provide us the margin directly, then use it.
    1:   const nsStyleMargin *styleMargin = frame->GetStyleMargin();
    1:   if (!styleMargin->GetMargin(mComputedMargin)) {
    1:     // We have to compute the value
16031:     mComputedMargin.left = nsLayoutUtils::
    1:       ComputeWidthDependentValue(aContainingBlockWidth,
16031:                                  styleMargin->mMargin.GetLeft());
16031:     mComputedMargin.right = nsLayoutUtils::
    1:       ComputeWidthDependentValue(aContainingBlockWidth,
16031:                                  styleMargin->mMargin.GetRight());
    1: 
    1:     // According to the CSS2 spec, margin percentages are
    1:     // calculated with respect to the *width* of the containing
    1:     // block, even for margin-top and margin-bottom.
    1:     // XXX This isn't true for page boxes, if we implement them.
16031:     mComputedMargin.top = nsLayoutUtils::
    1:       ComputeWidthDependentValue(aContainingBlockWidth,
16031:                                  styleMargin->mMargin.GetTop());
16031:     mComputedMargin.bottom = nsLayoutUtils::
    1:       ComputeWidthDependentValue(aContainingBlockWidth,
16031:                                  styleMargin->mMargin.GetBottom());
    1: 
    1:     // XXX We need to include 'auto' horizontal margins in this too!
12310:     // ... but if we did that, we'd need to fix nsFrame::GetUsedMargin
12310:     // to use it even when the margins are all zero (since sometimes
12310:     // they get treated as auto)
39965:     frame->Properties().Set(nsIFrame::UsedMarginProperty(),
39965:                             new nsMargin(mComputedMargin));
    1:   }
    1: }
    1: 
    1: void
    1: nsCSSOffsetState::ComputePadding(nscoord aContainingBlockWidth)
    1: {
    1:   // If style can provide us the padding directly, then use it.
    1:   const nsStylePadding *stylePadding = frame->GetStylePadding();
    1:   if (!stylePadding->GetPadding(mComputedPadding)) {
    1:     // We have to compute the value
52283:     // clamp negative calc() results to 0
52283:     mComputedPadding.left = NS_MAX(0, nsLayoutUtils::
    1:       ComputeWidthDependentValue(aContainingBlockWidth,
52283:                                  stylePadding->mPadding.GetLeft()));
52283:     mComputedPadding.right = NS_MAX(0, nsLayoutUtils::
    1:       ComputeWidthDependentValue(aContainingBlockWidth,
52283:                                  stylePadding->mPadding.GetRight()));
    1: 
    1:     // According to the CSS2 spec, percentages are calculated with respect to
    1:     // containing block width for padding-top and padding-bottom
52283:     mComputedPadding.top = NS_MAX(0, nsLayoutUtils::
    1:       ComputeWidthDependentValue(aContainingBlockWidth,
52283:                                  stylePadding->mPadding.GetTop()));
52283:     mComputedPadding.bottom = NS_MAX(0, nsLayoutUtils::
    1:       ComputeWidthDependentValue(aContainingBlockWidth,
52283:                                  stylePadding->mPadding.GetBottom()));
    1: 
39965:     frame->Properties().Set(nsIFrame::UsedPaddingProperty(),
39965:                             new nsMargin(mComputedPadding));
    1:   }
    1:   // a table row/col group, row/col doesn't have padding
    1:   // XXXldb Neither do border-collapse tables.
    1:   nsIAtom* frameType = frame->GetType();
    1:   if (nsGkAtoms::tableRowGroupFrame == frameType ||
    1:       nsGkAtoms::tableColGroupFrame == frameType ||
    1:       nsGkAtoms::tableRowFrame      == frameType ||
    1:       nsGkAtoms::tableColFrame      == frameType) {
    1:     mComputedPadding.top    = 0;
    1:     mComputedPadding.right  = 0;
    1:     mComputedPadding.bottom = 0;
    1:     mComputedPadding.left   = 0;
    1:   }
    1: }
    1: 
    1: void
    1: nsHTMLReflowState::ApplyMinMaxConstraints(nscoord* aFrameWidth,
    1:                                           nscoord* aFrameHeight) const
    1: {
    1:   if (aFrameWidth) {
    1:     if (NS_UNCONSTRAINEDSIZE != mComputedMaxWidth) {
32531:       *aFrameWidth = NS_MIN(*aFrameWidth, mComputedMaxWidth);
    1:     }
32531:     *aFrameWidth = NS_MAX(*aFrameWidth, mComputedMinWidth);
    1:   }
    1: 
    1:   if (aFrameHeight) {
    1:     if (NS_UNCONSTRAINEDSIZE != mComputedMaxHeight) {
32531:       *aFrameHeight = NS_MIN(*aFrameHeight, mComputedMaxHeight);
    1:     }
32531:     *aFrameHeight = NS_MAX(*aFrameHeight, mComputedMinHeight);
    1:   }
    1: }
    1: 
    1: void
    1: nsHTMLReflowState::ComputeMinMaxValues(nscoord aContainingBlockWidth,
    1:                                        nscoord aContainingBlockHeight,
    1:                                        const nsHTMLReflowState* aContainingBlockRS)
    1: {
 1068:   mComputedMinWidth = ComputeWidthValue(aContainingBlockWidth,
 1068:                                         mStylePosition->mBoxSizing,
 1068:                                         mStylePosition->mMinWidth);
    1: 
 1363:   if (eStyleUnit_None == mStylePosition->mMaxWidth.GetUnit()) {
    1:     // Specified value of 'none'
    1:     mComputedMaxWidth = NS_UNCONSTRAINEDSIZE;  // no limit
    1:   } else {
 1068:     mComputedMaxWidth = ComputeWidthValue(aContainingBlockWidth,
 1068:                                           mStylePosition->mBoxSizing,
 1068:                                           mStylePosition->mMaxWidth);
    1:   }
    1: 
    1:   // If the computed value of 'min-width' is greater than the value of
    1:   // 'max-width', 'max-width' is set to the value of 'min-width'
    1:   if (mComputedMinWidth > mComputedMaxWidth) {
    1:     mComputedMaxWidth = mComputedMinWidth;
    1:   }
    1: 
    1:   // Check for percentage based values and a containing block height that
    1:   // depends on the content height. Treat them like 'auto'
51406:   // Likewise, check for calc() on internal table elements; calc() on
51406:   // such elements is unsupported.
51406:   const nsStyleCoord &minHeight = mStylePosition->mMinHeight;
51406:   if ((NS_AUTOHEIGHT == aContainingBlockHeight &&
51406:        minHeight.HasPercent()) ||
51406:       (mFrameType == NS_CSS_FRAME_TYPE_INTERNAL_TABLE &&
51406:        minHeight.IsCalcUnit())) {
    1:     mComputedMinHeight = 0;
    1:   } else {
16031:     mComputedMinHeight = nsLayoutUtils::
51406:       ComputeHeightValue(aContainingBlockHeight, minHeight);
    1:   }
51406:   const nsStyleCoord &maxHeight = mStylePosition->mMaxHeight;
51406:   nsStyleUnit maxHeightUnit = maxHeight.GetUnit();
 1363:   if (eStyleUnit_None == maxHeightUnit) {
    1:     // Specified value of 'none'
    1:     mComputedMaxHeight = NS_UNCONSTRAINEDSIZE;  // no limit
    1:   } else {
    1:     // Check for percentage based values and a containing block height that
    1:     // depends on the content height. Treat them like 'auto'
51406:     // Likewise, check for calc() on internal table elements; calc() on
51406:     // such elements is unsupported.
51406:     if ((NS_AUTOHEIGHT == aContainingBlockHeight && 
51406:          maxHeight.HasPercent()) ||
51406:         (mFrameType == NS_CSS_FRAME_TYPE_INTERNAL_TABLE &&
51406:          maxHeight.IsCalcUnit())) {
    1:       mComputedMaxHeight = NS_UNCONSTRAINEDSIZE;
    1:     } else {
16031:       mComputedMaxHeight = nsLayoutUtils::
51406:         ComputeHeightValue(aContainingBlockHeight, maxHeight);
    1:     }
    1:   }
    1: 
    1:   // If the computed value of 'min-height' is greater than the value of
    1:   // 'max-height', 'max-height' is set to the value of 'min-height'
    1:   if (mComputedMinHeight > mComputedMaxHeight) {
    1:     mComputedMaxHeight = mComputedMinHeight;
    1:   }
    1: }
    1: 
    1: void
    1: nsHTMLReflowState::SetTruncated(const nsHTMLReflowMetrics& aMetrics,
    1:                                 nsReflowStatus* aStatus) const
    1: {
    1:   if (availableHeight != NS_UNCONSTRAINEDSIZE &&
    1:       availableHeight < aMetrics.height &&
    1:       !mFlags.mIsTopOfPage) {
    1:     *aStatus |= NS_FRAME_TRUNCATED;
    1:   } else {
    1:     *aStatus &= ~NS_FRAME_TRUNCATED;
    1:   }
    1: }
