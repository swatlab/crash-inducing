 59931: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 59931:  * vim: set ts=4 sw=4 et tw=99:
 59931:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 59931: 
 89265: #include "mozilla/GuardObjects.h"
 91311: #include "mozilla/StandardInteger.h"
 89265: 
 59931: #include "jscntxt.h"
 67915: #include "jscompartment.h"
 59931: #include "jsfriendapi.h"
 79734: #include "jswrapper.h"
 82724: #include "jsweakmap.h"
 88447: #include "jswatchpoint.h"
 59931: 
 91659: #include "builtin/TestingFunctions.h"
 91659: 
 77343: #include "jsobjinlines.h"
 77343: 
 67915: using namespace js;
 78158: using namespace JS;
 67915: 
121158: // Required by PerThreadDataFriendFields::getMainThread()
121158: JS_STATIC_ASSERT(offsetof(JSRuntime, mainThread) == sizeof(RuntimeFriendFields));
121158: 
121158: PerThreadDataFriendFields::PerThreadDataFriendFields()
121158: {
121158: #if defined(JSGC_ROOT_ANALYSIS) || defined(JSGC_USE_EXACT_ROOTING)
121158:     PodArrayZero(thingGCRooters);
121158: #endif
121158: }
121158: 
 80159: JS_FRIEND_API(void)
105947: JS_SetSourceHook(JSRuntime *rt, JS_SourceHook hook)
105947: {
105947:     rt->sourceHook = hook;
105947: }
105947: 
105947: JS_FRIEND_API(void)
 80159: JS_SetGrayGCRootsTracer(JSRuntime *rt, JSTraceDataOp traceOp, void *data)
 80159: {
 80159:     rt->gcGrayRootsTraceOp = traceOp;
 80159:     rt->gcGrayRootsData = data;
 80159: }
 80159: 
 59931: JS_FRIEND_API(JSString *)
 59931: JS_GetAnonymousString(JSRuntime *rt)
 59931: {
 87611:     JS_ASSERT(rt->hasContexts());
114207:     return rt->atomState.anonymous;
 59931: }
 67915: 
 67915: JS_FRIEND_API(JSObject *)
107154: JS_FindCompilationScope(JSContext *cx, RawObject objArg)
 67915: {
107154:     RootedObject obj(cx, objArg);
 98960: 
 67915:     /*
 67915:      * We unwrap wrappers here. This is a little weird, but it's what's being
 67915:      * asked of us.
 67915:      */
 67915:     if (obj->isWrapper())
 79734:         obj = UnwrapObject(obj);
 67915: 
 67915:     /*
 67915:      * Innerize the target_obj so that we compile in the correct (inner)
 67915:      * scope.
 67915:      */
 67915:     if (JSObjectOp op = obj->getClass()->ext.innerObject)
 67915:         obj = op(cx, obj);
 67915:     return obj;
 67915: }
 67915: 
 79734: JS_FRIEND_API(JSFunction *)
107154: JS_GetObjectFunction(RawObject obj)
 67915: {
 79734:     if (obj->isFunction())
 83234:         return obj->toFunction();
 79734:     return NULL;
 67915: }
 69223: 
 69223: JS_FRIEND_API(JSObject *)
 80154: JS_GetGlobalForFrame(JSStackFrame *fp)
 69223: {
 96793:     return &Valueify(fp)->global();
 69223: }
 74914: 
 77353: JS_FRIEND_API(JSBool)
107154: JS_SplicePrototype(JSContext *cx, JSObject *objArg, JSObject *protoArg)
 77343: {
107154:     RootedObject obj(cx, objArg);
107154:     RootedObject proto(cx, protoArg);
 77343:     /*
 77343:      * Change the prototype of an object which hasn't been used anywhere
 77343:      * and does not share its type with another object. Unlike JS_SetPrototype,
 77343:      * does not nuke type information for the object.
 77343:      */
 77343:     CHECK_REQUEST(cx);
 78454: 
 78454:     if (!obj->hasSingletonType()) {
 78454:         /*
 78454:          * We can see non-singleton objects when trying to splice prototypes
 78454:          * due to mutable __proto__ (ugh).
 78454:          */
 78454:         return JS_SetPrototype(cx, obj, proto);
 78454:     }
 78454: 
115021:     Rooted<TaggedProto> tagged(cx, TaggedProto(proto));
115021:     return obj->splicePrototype(cx, tagged);
 77343: }
 77343: 
 77343: JS_FRIEND_API(JSObject *)
107154: JS_NewObjectWithUniqueType(JSContext *cx, JSClass *clasp, JSObject *protoArg, JSObject *parentArg)
 77343: {
107154:     RootedObject proto(cx, protoArg);
107154:     RootedObject parent(cx, parentArg);
123846:     /*
123846:      * Create our object with a null proto and then splice in the correct proto
123846:      * after we setSingletonType, so that we don't pollute the default
123846:      * TypeObject attached to our proto with information about our object, since
123846:      * we're not going to be using that TypeObject anyway.
123846:      */
123846:     RootedObject obj(cx, JS_NewObjectWithGivenProto(cx, clasp, NULL, parent));
108951:     if (!obj || !JSObject::setSingletonType(cx, obj))
 77343:         return NULL;
123846:     if (!JS_SplicePrototype(cx, obj, proto))
123846:         return NULL;
 77343:     return obj;
 77343: }
 77343: 
 86375: JS_FRIEND_API(void)
 94871: js::PrepareCompartmentForGC(JSCompartment *comp)
 82884: {
 94871:     comp->scheduleGC();
 88182: }
 88182: 
 88182: JS_FRIEND_API(void)
 94871: js::PrepareForFullGC(JSRuntime *rt)
 89284: {
 94871:     for (CompartmentsIter c(rt); !c.done(); c.next())
 94871:         c->scheduleGC();
 94871: }
 89284: 
103364: JS_FRIEND_API(void)
103364: js::PrepareForIncrementalGC(JSRuntime *rt)
103364: {
114957:     if (!IsIncrementalGCInProgress(rt))
103364:         return;
103364: 
103364:     for (CompartmentsIter c(rt); !c.done(); c.next()) {
106556:         if (c->wasGCStarted())
103364:             PrepareCompartmentForGC(c);
103364:     }
103364: }
103364: 
 97770: JS_FRIEND_API(bool)
 97770: js::IsGCScheduled(JSRuntime *rt)
 97770: {
 97770:     for (CompartmentsIter c(rt); !c.done(); c.next()) {
 97770:         if (c->isGCScheduled())
 97770:             return true;
 97770:     }
 97770: 
 97770:     return false;
 97770: }
 97770: 
 94871: JS_FRIEND_API(void)
 98111: js::SkipCompartmentForGC(JSCompartment *comp)
 98111: {
 98111:     comp->unscheduleGC();
 98111: }
 98111: 
 98111: JS_FRIEND_API(void)
 94960: js::GCForReason(JSRuntime *rt, gcreason::Reason reason)
 94871: {
 94960:     GC(rt, GC_NORMAL, reason);
 89284: }
 89284: 
 89284: JS_FRIEND_API(void)
 94960: js::ShrinkingGC(JSRuntime *rt, gcreason::Reason reason)
 88182: {
 94960:     GC(rt, GC_SHRINK, reason);
 90410: }
 90410: 
 90410: JS_FRIEND_API(void)
107052: js::IncrementalGC(JSRuntime *rt, gcreason::Reason reason, int64_t millis)
 90410: {
107052:     GCSlice(rt, GC_NORMAL, reason, millis);
 82884: }
 82884: 
 86375: JS_FRIEND_API(void)
103364: js::FinishIncrementalGC(JSRuntime *rt, gcreason::Reason reason)
103364: {
103364:     GCFinalSlice(rt, GC_NORMAL, reason);
103364: }
103364: 
103364: JS_FRIEND_API(void)
 86375: JS_ShrinkGCBuffers(JSRuntime *rt)
 86375: {
 86375:     ShrinkGCBuffers(rt);
 86375: }
 86375: 
 78158: JS_FRIEND_API(JSPrincipals *)
 78158: JS_GetCompartmentPrincipals(JSCompartment *compartment)
 78158: {
 78158:     return compartment->principals;
 78158: }
 78158: 
102066: JS_FRIEND_API(void)
102066: JS_SetCompartmentPrincipals(JSCompartment *compartment, JSPrincipals *principals)
102066: {
102066:     // Short circuit if there's no change.
102066:     if (principals == compartment->principals)
102066:         return;
102066: 
111189:     // Any compartment with the trusted principals -- and there can be
111189:     // multiple -- is a system compartment.
111189:     JSPrincipals *trusted = compartment->rt->trustedPrincipals();
111189:     bool isSystem = principals && principals == trusted;
111189: 
102066:     // Clear out the old principals, if any.
102066:     if (compartment->principals) {
102066:         JS_DropPrincipals(compartment->rt, compartment->principals);
102066:         compartment->principals = NULL;
111189:         // We'd like to assert that our new principals is always same-origin
111189:         // with the old one, but JSPrincipals doesn't give us a way to do that.
111189:         // But we can at least assert that we're not switching between system
111189:         // and non-system.
111189:         JS_ASSERT(compartment->isSystemCompartment == isSystem);
102066:     }
102066: 
102066:     // Set up the new principals.
102066:     if (principals) {
102066:         JS_HoldPrincipals(principals);
102066:         compartment->principals = principals;
102066:     }
102066: 
111189:     // Update the system flag.
111189:     compartment->isSystemCompartment = isSystem;
102066: }
102066: 
 78158: JS_FRIEND_API(JSBool)
 78158: JS_WrapPropertyDescriptor(JSContext *cx, js::PropertyDescriptor *desc)
 78158: {
 78158:     return cx->compartment->wrap(cx, desc);
 78158: }
 78158: 
101167: JS_FRIEND_API(JSBool)
101167: JS_WrapAutoIdVector(JSContext *cx, js::AutoIdVector &props)
101167: {
101167:     return cx->compartment->wrap(cx, props);
101167: }
101167: 
 85055: JS_FRIEND_API(void)
 85055: JS_TraceShapeCycleCollectorChildren(JSTracer *trc, void *shape)
 84173: {
 90419:     MarkCycleCollectorChildren(trc, (Shape *)shape);
 84173: }
 84173: 
 91659: static bool
 97353: DefineHelpProperty(JSContext *cx, HandleObject obj, const char *prop, const char *value)
 91659: {
107982:     JSAtom *atom = Atomize(cx, value, strlen(value));
 91659:     if (!atom)
 91659:         return false;
 91659:     jsval v = STRING_TO_JSVAL(atom);
 91659:     return JS_DefineProperty(cx, obj, prop, v,
 91659:                              JS_PropertyStub, JS_StrictPropertyStub,
 91659:                              JSPROP_READONLY | JSPROP_PERMANENT);
 91659: }
 91659: 
 91659: JS_FRIEND_API(bool)
107154: JS_DefineFunctionsWithHelp(JSContext *cx, JSObject *objArg, const JSFunctionSpecWithHelp *fs)
 91659: {
107154:     RootedObject obj(cx, objArg);
 91659:     JS_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
 91659: 
 91659:     CHECK_REQUEST(cx);
 91659:     assertSameCompartment(cx, obj);
 91659:     for (; fs->name; fs++) {
107982:         JSAtom *atom = Atomize(cx, fs->name, strlen(fs->name));
 91659:         if (!atom)
 91659:             return false;
 91659: 
102586:         Rooted<jsid> id(cx, AtomToId(atom));
103990:         RootedFunction fun(cx, js_DefineFunction(cx, obj, id, fs->call, fs->nargs, fs->flags));
 91659:         if (!fun)
 91659:             return false;
 91659: 
 91659:         if (fs->usage) {
 91659:             if (!DefineHelpProperty(cx, fun, "usage", fs->usage))
 91659:                 return false;
 91659:         }
 91659: 
 91659:         if (fs->help) {
 91659:             if (!DefineHelpProperty(cx, fun, "help", fs->help))
 91659:                 return false;
 91659:         }
 91659:     }
 91659: 
 91659:     return true;
 91659: }
 91659: 
 78158: AutoSwitchCompartment::AutoSwitchCompartment(JSContext *cx, JSCompartment *newCompartment
 78158:                                              JS_GUARD_OBJECT_NOTIFIER_PARAM_NO_INIT)
 78158:   : cx(cx), oldCompartment(cx->compartment)
 78158: {
 78158:     JS_GUARD_OBJECT_NOTIFIER_INIT;
 78158:     cx->setCompartment(newCompartment);
 78158: }
 78158: 
107154: AutoSwitchCompartment::AutoSwitchCompartment(JSContext *cx, JSHandleObject target
 78158:                                              JS_GUARD_OBJECT_NOTIFIER_PARAM_NO_INIT)
 78158:   : cx(cx), oldCompartment(cx->compartment)
 78158: {
 78158:     JS_GUARD_OBJECT_NOTIFIER_INIT;
 78158:     cx->setCompartment(target->compartment());
 78158: }
 78158: 
 78158: AutoSwitchCompartment::~AutoSwitchCompartment()
 78158: {
 78158:     /* The old compartment may have been destroyed, so we can't use cx->setCompartment. */
 78158:     cx->compartment = oldCompartment;
 78158: }
 78158: 
 83278: JS_FRIEND_API(bool)
 86105: js::IsSystemCompartment(const JSCompartment *c)
 86105: {
 86105:     return c->isSystemCompartment;
 86105: }
 86105: 
 86105: JS_FRIEND_API(bool)
 91250: js::IsAtomsCompartment(const JSCompartment *c)
 86986: {
 91250:     return c == c->rt->atomsCompartment;
 86986: }
 86986: 
 86986: JS_FRIEND_API(bool)
107154: js::IsScopeObject(RawObject obj)
 82095: {
 86483:     return obj->isScope();
 80213: }
 80213: 
 83239: JS_FRIEND_API(JSObject *)
107154: js::GetObjectParentMaybeScope(RawObject obj)
 80213: {
 86483:     return obj->enclosingScope();
 83239: }
 83239: 
 83293: JS_FRIEND_API(JSObject *)
107154: js::GetGlobalForObjectCrossCompartment(RawObject obj)
 83293: {
 86483:     return &obj->global();
 83293: }
 83293: 
 98147: JS_FRIEND_API(void)
107154: js::NotifyAnimationActivity(RawObject obj)
 98147: {
 98147:     obj->compartment()->lastAnimationTime = PRMJ_Now();
 98147: }
 98147: 
 84755: JS_FRIEND_API(uint32_t)
107154: js::GetObjectSlotSpan(RawObject obj)
 83252: {
 83252:     return obj->slotSpan();
 83252: }
 80213: 
 83256: JS_FRIEND_API(bool)
107154: js::IsObjectInContextCompartment(RawObject obj, const JSContext *cx)
 86111: {
 86111:     return obj->compartment() == cx->compartment;
 86111: }
 86111: 
 86111: JS_FRIEND_API(bool)
 83256: js::IsOriginalScriptFunction(JSFunction *fun)
 83256: {
123827:     return fun->nonLazyScript()->function() == fun;
 83256: }
 83256: 
121515: JS_FRIEND_API(JSScript *)
121515: js::GetOutermostEnclosingFunctionOfScriptedCaller(JSContext *cx)
121515: {
121515:     if (!cx->hasfp())
121515:         return NULL;
121515: 
121515:     StackFrame *fp = cx->fp();
121515:     if (!fp->isFunctionFrame())
121515:         return NULL;
121515: 
121515:     JSFunction *scriptedCaller = fp->fun();
123827:     RootedScript outermost(cx, scriptedCaller->nonLazyScript());
121515:     for (StaticScopeIter i(scriptedCaller); !i.done(); i++) {
121515:         if (i.type() == StaticScopeIter::FUNCTION)
121515:             outermost = i.funScript();
121515:     }
121515:     return outermost;
121515: }
121515: 
 83262: JS_FRIEND_API(JSFunction *)
107154: js::DefineFunctionWithReserved(JSContext *cx, JSObject *objArg, const char *name, JSNative call,
 91237:                                unsigned nargs, unsigned attrs)
 83262: {
107154:     RootedObject obj(cx, objArg);
 83262:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
 83262:     CHECK_REQUEST(cx);
 83262:     assertSameCompartment(cx, obj);
107982:     JSAtom *atom = Atomize(cx, name, strlen(name));
 83262:     if (!atom)
 83262:         return NULL;
102586:     Rooted<jsid> id(cx, AtomToId(atom));
123738:     return js_DefineFunction(cx, obj, id, call, nargs, attrs, JSFunction::ExtendedFinalizeKind);
 83262: }
 83262: 
 83262: JS_FRIEND_API(JSFunction *)
 91237: js::NewFunctionWithReserved(JSContext *cx, JSNative native, unsigned nargs, unsigned flags,
107154:                             JSObject *parentArg, const char *name)
 83268: {
107154:     RootedObject parent(cx, parentArg);
 83268:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
 83268: 
 83268:     CHECK_REQUEST(cx);
 83268:     assertSameCompartment(cx, parent);
 83268: 
116203:     RootedAtom atom(cx);
116203:     if (name) {
107982:         atom = Atomize(cx, name, strlen(name));
 83268:         if (!atom)
 83268:             return NULL;
 83268:     }
 83268: 
121256:     JSFunction::Flags funFlags = JSAPIToJSFunctionFlags(flags);
121256:     return js_NewFunction(cx, NullPtr(), native, nargs, funFlags, parent, atom,
 83268:                           JSFunction::ExtendedFinalizeKind);
 83268: }
 83268: 
 83268: JS_FRIEND_API(JSFunction *)
107154: js::NewFunctionByIdWithReserved(JSContext *cx, JSNative native, unsigned nargs, unsigned flags, JSObject *parentArg,
 83262:                                 jsid id)
 83262: {
107154:     RootedObject parent(cx, parentArg);
 83262:     JS_ASSERT(JSID_IS_STRING(id));
 83262:     JS_THREADSAFE_ASSERT(cx->compartment != cx->runtime->atomsCompartment);
 83262:     CHECK_REQUEST(cx);
 83262:     assertSameCompartment(cx, parent);
 83262: 
116203:     RootedAtom atom(cx, JSID_TO_ATOM(id));
121256:     JSFunction::Flags funFlags = JSAPIToJSFunctionFlags(flags);
121256:     return js_NewFunction(cx, NullPtr(), native, nargs, funFlags, parent, atom,
 83262:                           JSFunction::ExtendedFinalizeKind);
 83262: }
 83262: 
 83262: JS_FRIEND_API(JSObject *)
107154: js::InitClassWithReserved(JSContext *cx, JSObject *objArg, JSObject *parent_protoArg,
 91237:                           JSClass *clasp, JSNative constructor, unsigned nargs,
 83262:                           JSPropertySpec *ps, JSFunctionSpec *fs,
 83262:                           JSPropertySpec *static_ps, JSFunctionSpec *static_fs)
 83262: {
107154:     RootedObject obj(cx, objArg);
107154:     RootedObject parent_proto(cx, parent_protoArg);
 83262:     CHECK_REQUEST(cx);
 83262:     assertSameCompartment(cx, obj, parent_proto);
 99364:     return js_InitClass(cx, obj, parent_proto, Valueify(clasp), constructor,
 83262:                         nargs, ps, fs, static_ps, static_fs, NULL,
 83262:                         JSFunction::ExtendedFinalizeKind);
 83262: }
 83262: 
 83258: JS_FRIEND_API(const Value &)
107154: js::GetFunctionNativeReserved(RawObject fun, size_t which)
 83258: {
 83301:     JS_ASSERT(fun->toFunction()->isNative());
 83301:     return fun->toFunction()->getExtendedSlot(which);
 80062: }
 80062: 
 80062: JS_FRIEND_API(void)
107154: js::SetFunctionNativeReserved(RawObject fun, size_t which, const Value &val)
 80062: {
 83301:     JS_ASSERT(fun->toFunction()->isNative());
 83301:     fun->toFunction()->setExtendedSlot(which, val);
 79734: }
 79734: 
 87982: JS_FRIEND_API(void)
107154: js::SetReservedSlotWithBarrier(RawObject obj, size_t slot, const js::Value &value)
 87982: {
 87982:     obj->setSlot(slot, value);
 87982: }
 87982: 
106724: JS_FRIEND_API(bool)
108951: js::GetGeneric(JSContext *cx, JSObject *objArg, JSObject *receiverArg, jsid idArg,
106724:                Value *vp)
106724: {
108951:     RootedObject obj(cx, objArg), receiver(cx, receiverArg);
108951:     RootedId id(cx, idArg);
106862:     RootedValue value(cx);
108951:     if (!JSObject::getGeneric(cx, obj, receiver, id, &value))
106862:         return false;
106862:     *vp = value;
106862:     return true;
106724: }
106724: 
 84729: void
 84729: js::SetPreserveWrapperCallback(JSRuntime *rt, PreserveWrapperCallback callback)
 84729: {
 84729:     rt->preserveWrapperCallback = callback;
 84729: }
 84729: 
 74914: /*
 74914:  * The below code is for temporary telemetry use. It can be removed when
 74914:  * sufficient data has been harvested.
 74914:  */
 74914: 
123695: // Defined in jsxml.cpp.
 74914: extern size_t sE4XObjectsCreated;
 74914: 
 74914: JS_FRIEND_API(size_t)
 74914: JS_GetE4XObjectsCreated(JSContext *)
 74914: {
 74914:     return sE4XObjectsCreated;
 74914: }
 74914: 
105547: namespace js {
123695: // Defined in vm/GlobalObject.cpp.
 74914: extern size_t sSetProtoCalled;
105547: }
 74914: 
 74914: JS_FRIEND_API(size_t)
 74914: JS_SetProtoCalled(JSContext *)
 74914: {
 74914:     return sSetProtoCalled;
 74914: }
 74914: 
123695: // Defined in jsiter.cpp.
 74914: extern size_t sCustomIteratorCount;
 74914: 
 74914: JS_FRIEND_API(size_t)
 74914: JS_GetCustomIteratorCount(JSContext *cx)
 74914: {
 74914:     return sCustomIteratorCount;
 74914: }
 80213: 
105788: JS_FRIEND_API(JSBool)
105788: JS_IsDeadWrapper(JSObject *obj)
105788: {
105788:     if (!IsProxy(obj)) {
105788:         return false;
105788:     }
105788: 
105788:     BaseProxyHandler *handler = GetProxyHandler(obj);
105788:     return handler->family() == &DeadObjectProxy::sDeadObjectFamily;
105788: }
105788: 
 82724: void
 82724: js::TraceWeakMaps(WeakMapTracer *trc)
 82724: {
 82724:     WeakMapBase::traceAllMappings(trc);
 88447:     WatchpointMap::traceAll(trc);
 82724: }
 82724: 
124506: JS_FRIEND_API(bool)
124506: js::GCThingIsMarkedGray(void *thing)
124506: {
124506:     JS_ASSERT(thing);
124506:     return reinterpret_cast<gc::Cell *>(thing)->isMarked(gc::GRAY);
124506: }
124506: 
124669: extern JS_FRIEND_API(bool)
124669: js::AreGCGrayBitsValid(JSRuntime *rt)
124669: {
124669:     return rt->gcGrayBitsValid;
124669: }
124669: 
120195: JS_FRIEND_API(JSGCTraceKind)
120195: js::GCThingTraceKind(void *thing)
120195: {
120195:     JS_ASSERT(thing);
120195:     return gc::GetGCThingTraceKind(thing);
120195: }
120195: 
120195: JS_FRIEND_API(void)
124669: js::VisitGrayWrapperTargets(JSCompartment *comp, GCThingCallback callback, void *closure)
103072: {
124656:     for (JSCompartment::WrapperEnum e(comp); !e.empty(); e.popFront()) {
103072:         gc::Cell *thing = e.front().key.wrapped;
103072:         if (thing->isMarked(gc::GRAY))
103072:             callback(closure, thing);
103072:     }
103072: }
103072: 
119274: JS_FRIEND_API(JSObject *)
119274: js::GetWeakmapKeyDelegate(JSObject *key)
119274: {
119274:     if (JSWeakmapKeyDelegateOp op = key->getClass()->ext.weakmapKeyDelegateOp)
119274:         return op(key);
119274:     return NULL;
119274: }
119274: 
 80213: JS_FRIEND_API(void)
 80213: JS_SetAccumulateTelemetryCallback(JSRuntime *rt, JSAccumulateTelemetryDataCallback callback)
 80213: {
 80213:     rt->telemetryCallback = callback;
 80213: }
 80670: 
115021: JS_FRIEND_API(JSObject *)
115021: JS_CloneObject(JSContext *cx, JSObject *obj_, JSObject *proto_, JSObject *parent_)
115021: {
115021:     RootedObject obj(cx, obj_);
115021:     Rooted<js::TaggedProto> proto(cx, proto_);
115021:     RootedObject parent(cx, parent_);
115021:     return CloneObject(cx, obj, proto, parent);
115021: }
115021: 
 80670: #ifdef DEBUG
 89265: JS_FRIEND_API(void)
 89265: js_DumpString(JSString *str)
 89265: {
 89265:     str->dump();
 89265: }
 89265: 
 89265: JS_FRIEND_API(void)
 89265: js_DumpAtom(JSAtom *atom)
 89265: {
 89265:     atom->dump();
 89265: }
 89265: 
 89265: JS_FRIEND_API(void)
 89265: js_DumpChars(const jschar *s, size_t n)
 89265: {
 89265:     fprintf(stderr, "jschar * (%p) = ", (void *) s);
111369:     JSString::dumpChars(s, n);
 89265:     fputc('\n', stderr);
 89265: }
 89265: 
 89265: JS_FRIEND_API(void)
 89265: js_DumpObject(JSObject *obj)
 89265: {
 89265:     obj->dump();
 89265: }
 80670: 
101990: #endif
101990: 
120827: struct JSDumpHeapTracer : public JSTracer
120827: {
 80670:     FILE   *output;
 80670: 
 91339:     JSDumpHeapTracer(FILE *fp)
 91339:       : output(fp)
 80670:     {}
 80670: };
 80670: 
 91317: static char
 91317: MarkDescriptor(void *thing)
 91317: {
 91317:     gc::Cell *cell = static_cast<gc::Cell*>(thing);
 91317:     if (cell->isMarked(gc::BLACK))
 91317:         return cell->isMarked(gc::GRAY) ? 'G' : 'B';
 91317:     else
 91317:         return cell->isMarked(gc::GRAY) ? 'X' : 'W';
 91317: }
 91317: 
 80670: static void
120827: DumpHeapVisitCompartment(JSRuntime *rt, void *data, JSCompartment *comp)
 80670: {
120827:     char name[1024];
120827:     if (rt->compartmentNameCallback)
120827:         (*rt->compartmentNameCallback)(rt, comp, name, sizeof(name));
120827:     else
120827:         strcpy(name, "<unknown>");
 80670: 
120827:     JSDumpHeapTracer *dtrc = static_cast<JSDumpHeapTracer *>(data);
120827:     fprintf(dtrc->output, "# compartment %s\n", name);
 80670: }
 80670: 
120827: static void
120827: DumpHeapVisitArena(JSRuntime *rt, void *data, gc::Arena *arena,
120827:                    JSGCTraceKind traceKind, size_t thingSize)
120827: {
120827:     JSDumpHeapTracer *dtrc = static_cast<JSDumpHeapTracer *>(data);
120827:     fprintf(dtrc->output, "# arena allockind=%u size=%u\n",
120827:             unsigned(arena->aheader.getAllocKind()), unsigned(thingSize));
120827: }
 80670: 
120827: static void
120827: DumpHeapVisitCell(JSRuntime *rt, void *data, void *thing,
120827:                   JSGCTraceKind traceKind, size_t thingSize)
120827: {
120827:     JSDumpHeapTracer *dtrc = static_cast<JSDumpHeapTracer *>(data);
120827:     char cellDesc[1024];
120827:     JS_GetTraceThingInfo(cellDesc, sizeof(cellDesc), dtrc, thing, traceKind, true);
120827:     fprintf(dtrc->output, "%p %c %s\n", thing, MarkDescriptor(thing), cellDesc);
120827:     JS_TraceChildren(dtrc, thing, traceKind);
 80670: }
 80670: 
 80670: static void
 90232: DumpHeapVisitChild(JSTracer *trc, void **thingp, JSGCTraceKind kind)
 80670: {
 80670:     JSDumpHeapTracer *dtrc = static_cast<JSDumpHeapTracer *>(trc);
120827:     char buffer[1024];
120827:     fprintf(dtrc->output, "> %p %c %s\n", *thingp, MarkDescriptor(*thingp),
120827:             JS_GetTraceEdgeName(dtrc, buffer, sizeof(buffer)));
120827: }
120827: 
120827: static void
120827: DumpHeapVisitRoot(JSTracer *trc, void **thingp, JSGCTraceKind kind)
120827: {
120827:     JSDumpHeapTracer *dtrc = static_cast<JSDumpHeapTracer *>(trc);
120827:     char buffer[1024];
120827:     fprintf(dtrc->output, "%p %c %s\n", *thingp, MarkDescriptor(*thingp),
120827:             JS_GetTraceEdgeName(dtrc, buffer, sizeof(buffer)));
 80670: }
 80670: 
 80670: void
 91339: js::DumpHeapComplete(JSRuntime *rt, FILE *fp)
 80670: {
 91339:     JSDumpHeapTracer dtrc(fp);
 80670: 
120827:     JS_TracerInit(&dtrc, rt, DumpHeapVisitRoot);
 80670:     TraceRuntime(&dtrc);
120827: 
 80670:     fprintf(dtrc.output, "==========\n");
 80670: 
120827:     JS_TracerInit(&dtrc, rt, DumpHeapVisitChild);
120827:     IterateCompartmentsArenasCells(rt, &dtrc,
120827:                                    DumpHeapVisitCompartment,
120827:                                    DumpHeapVisitArena,
120827:                                    DumpHeapVisitCell);
 80670: 
 90876:     fflush(dtrc.output);
 80670: }
 80670: 
 87277: JS_FRIEND_API(const JSStructuredCloneCallbacks *)
123695: js::GetContextStructuredCloneCallbacks(JSContext *cx)
 87277: {
 87277:     return cx->runtime->structuredCloneCallbacks;
 87277: }
 87277: 
 87278: JS_FRIEND_API(JSVersion)
123695: js::VersionSetMoarXML(JSVersion version, bool enable)
 87278: {
 99820:     return enable ? JSVersion(uint32_t(version) | VersionFlags::MOAR_XML)
 99820:                   : JSVersion(uint32_t(version) & ~VersionFlags::MOAR_XML);
 87278: }
 87278: 
 87279: JS_FRIEND_API(bool)
123695: js::CanCallContextDebugHandler(JSContext *cx)
 87279: {
 91178:     return !!cx->runtime->debugHooks.debuggerHandler;
 87279: }
 87279: 
 87279: JS_FRIEND_API(JSTrapStatus)
123695: js::CallContextDebugHandler(JSContext *cx, JSScript *script, jsbytecode *bc, Value *rval)
 87279: {
 91178:     if (!cx->runtime->debugHooks.debuggerHandler)
 87279:         return JSTRAP_RETURN;
 87279: 
 91178:     return cx->runtime->debugHooks.debuggerHandler(cx, script, bc, rval,
 91178:                                                    cx->runtime->debugHooks.debuggerHandlerData);
 87279: }
 87279: 
 86984: #ifdef JS_THREADSAFE
 88135: void *
123695: js::GetOwnerThread(const JSContext *cx)
 86984: {
 88135:     return cx->runtime->ownerThread();
 86984: }
 87282: 
114305: JS_FRIEND_API(bool)
123695: js::ContextHasOutstandingRequests(const JSContext *cx)
 87282: {
114305:     return cx->outstandingRequests > 0;
 87282: }
 86984: #endif
 86984: 
 87284: JS_FRIEND_API(JSCompartment *)
123695: js::GetContextCompartment(const JSContext *cx)
 87284: {
 87284:     return cx->compartment;
 87284: }
 87284: 
 87285: JS_FRIEND_API(bool)
123695: js::HasUnrootedGlobal(const JSContext *cx)
 87285: {
 87285:     return cx->hasRunOption(JSOPTION_UNROOTED_GLOBAL);
 87285: }
 87285: 
 87286: JS_FRIEND_API(void)
123695: js::SetActivityCallback(JSRuntime *rt, ActivityCallback cb, void *arg)
 87286: {
 87286:     rt->activityCallback = cb;
 87286:     rt->activityCallbackArg = arg;
 87286: }
 87291: 
 87291: JS_FRIEND_API(bool)
123695: js::IsContextRunningJS(JSContext *cx)
 87291: {
 87291:     return !cx->stack.empty();
 87291: }
 87291: 
 87293: JS_FRIEND_API(const CompartmentVector&)
123695: js::GetRuntimeCompartments(JSRuntime *rt)
 87293: {
 87293:     return rt->compartments;
 87293: }
 87293: 
 90410: JS_FRIEND_API(GCSliceCallback)
123695: js::SetGCSliceCallback(JSRuntime *rt, GCSliceCallback callback)
 90410: {
 90410:     GCSliceCallback old = rt->gcSliceCallback;
 90410:     rt->gcSliceCallback = callback;
 90410:     return old;
 90410: }
 90410: 
107267: JS_FRIEND_API(bool)
123695: js::WasIncrementalGC(JSRuntime *rt)
107267: {
107267:     return rt->gcIsIncremental;
107267: }
107267: 
 92707: jschar *
 92707: GCDescription::formatMessage(JSRuntime *rt) const
 92707: {
 92707:     return rt->gcStats.formatMessage();
 92707: }
 92707: 
 92707: jschar *
 93384: GCDescription::formatJSON(JSRuntime *rt, uint64_t timestamp) const
 92707: {
 93384:     return rt->gcStats.formatJSON(timestamp);
 92707: }
 92707: 
109045: JS_FRIEND_API(AnalysisPurgeCallback)
123695: js::SetAnalysisPurgeCallback(JSRuntime *rt, AnalysisPurgeCallback callback)
109045: {
109045:     AnalysisPurgeCallback old = rt->analysisPurgeCallback;
109045:     rt->analysisPurgeCallback = callback;
109045:     return old;
109045: }
109045: 
 94960: JS_FRIEND_API(void)
123695: js::NotifyDidPaint(JSRuntime *rt)
 90410: {
105981:     if (rt->gcZeal() == gc::ZealFrameVerifierPreValue) {
105981:         gc::VerifyBarriers(rt, gc::PreBarrierVerifier);
105981:         return;
105981:     }
105981: 
105981:     if (rt->gcZeal() == gc::ZealFrameVerifierPostValue) {
105981:         gc::VerifyBarriers(rt, gc::PostBarrierVerifier);
 90410:         return;
 90410:     }
 90410: 
 90410:     if (rt->gcZeal() == gc::ZealFrameGCValue) {
 94869:         PrepareForFullGC(rt);
 94960:         GCSlice(rt, GC_NORMAL, gcreason::REFRESH_FRAME);
 90410:         return;
 90410:     }
 90410: 
114957:     if (IsIncrementalGCInProgress(rt) && !rt->gcInterFrameGC) {
103364:         PrepareForIncrementalGC(rt);
 94960:         GCSlice(rt, GC_NORMAL, gcreason::REFRESH_FRAME);
 94620:     }
 90410: 
 90410:     rt->gcInterFrameGC = false;
 90410: }
 90410: 
123695: JS_FRIEND_API(bool)
123695: js::IsIncrementalGCEnabled(JSRuntime *rt)
 90410: {
 98153:     return rt->gcIncrementalEnabled && rt->gcMode == JSGC_MODE_INCREMENTAL;
 90410: }
 90410: 
114957: JS_FRIEND_API(bool)
123695: js::IsIncrementalGCInProgress(JSRuntime *rt)
114957: {
114957:     return (rt->gcIncrementalState != gc::NO_INCREMENTAL && !rt->gcVerifyPreData);
114957: }
114957: 
123695: JS_FRIEND_API(void)
123695: js::DisableIncrementalGC(JSRuntime *rt)
 91205: {
 91205:     rt->gcIncrementalEnabled = false;
 91205: }
 91205: 
 90410: JS_FRIEND_API(bool)
123695: js::IsIncrementalBarrierNeeded(JSRuntime *rt)
 90410: {
103783:     return (rt->gcIncrementalState == gc::MARK && !rt->isHeapBusy());
 90410: }
 90410: 
 90410: JS_FRIEND_API(bool)
123695: js::IsIncrementalBarrierNeeded(JSContext *cx)
 90410: {
 90410:     return IsIncrementalBarrierNeeded(cx->runtime);
 90410: }
 90410: 
124506: JS_FRIEND_API(bool)
124728: js::IsIncrementalBarrierNeededOnGCThing(void *thing, JSGCTraceKind kind)
124506: {
124728:     return static_cast<gc::Cell *>(thing)->compartment()->needsBarrier();
124506: }
124506: 
123695: JS_FRIEND_API(void)
123695: js::IncrementalReferenceBarrier(void *ptr)
 90410: {
 90410:     if (!ptr)
 90410:         return;
121539: 
121539:     gc::Cell *cell = static_cast<gc::Cell *>(ptr);
121539:     JS_ASSERT(!cell->compartment()->rt->isHeapBusy());
121539: 
121539:     AutoMarkInDeadCompartment amn(cell->compartment());
121539: 
 90410:     uint32_t kind = gc::GetGCThingTraceKind(ptr);
 90410:     if (kind == JSTRACE_OBJECT)
124515:         JSObject::writeBarrierPre(reinterpret_cast<RawObject>(ptr));
 90410:     else if (kind == JSTRACE_STRING)
124515:         JSString::writeBarrierPre(reinterpret_cast<RawString>(ptr));
 97830:     else if (kind == JSTRACE_SCRIPT)
124515:         JSScript::writeBarrierPre(reinterpret_cast<RawScript>(ptr));
 97830:     else if (kind == JSTRACE_SHAPE)
 97830:         Shape::writeBarrierPre((Shape *) ptr);
 97830:     else if (kind == JSTRACE_BASE_SHAPE)
124515:         BaseShape::writeBarrierPre(reinterpret_cast<RawBaseShape>(ptr));
 97830:     else if (kind == JSTRACE_TYPE_OBJECT)
 97830:         types::TypeObject::writeBarrierPre((types::TypeObject *) ptr);
 90410:     else
 90410:         JS_NOT_REACHED("invalid trace kind");
 90410: }
 90410: 
123695: JS_FRIEND_API(void)
123695: js::IncrementalValueBarrier(const Value &v)
 90410: {
 90410:     HeapValue::writeBarrierPre(v);
 90410: }
 90410: 
123695: JS_FRIEND_API(void)
123695: js::PokeGC(JSRuntime *rt)
 99131: {
 99131:     rt->gcPoke = true;
 99131: }
 99131: 
 91659: JS_FRIEND_API(JSObject *)
123695: js::GetTestingFunctions(JSContext *cx)
 91659: {
107154:     RootedObject obj(cx, JS_NewObject(cx, NULL, NULL, NULL));
 91659:     if (!obj)
 91659:         return NULL;
 91659: 
 91659:     if (!DefineTestingFunctions(cx, obj))
 91659:         return NULL;
 91659: 
 91659:     return obj;
 91659: }
 91659: 
103915: JS_FRIEND_API(void)
123695: js::SetRuntimeProfilingStack(JSRuntime *rt, ProfileEntry *stack, uint32_t *size, uint32_t max)
103915: {
103915:     rt->spsProfiler.setProfilingStack(stack, size, max);
104307: }
104307: 
104307: JS_FRIEND_API(void)
123695: js::EnableRuntimeProfilingStack(JSRuntime *rt, bool enabled)
104307: {
104307:     rt->spsProfiler.enable(enabled);
103915: }
103915: 
108150: JS_FRIEND_API(jsbytecode*)
123695: js::ProfilingGetPC(JSRuntime *rt, JSScript *script, void *ip)
108150: {
108150:     return rt->spsProfiler.ipToPC(script, size_t(ip));
108150: }
108150: 
107786: JS_FRIEND_API(void)
123695: js::SetDOMCallbacks(JSRuntime *rt, const DOMCallbacks *callbacks)
107786: {
107786:     rt->DOMcallbacks = callbacks;
107786: }
107786: 
107786: JS_FRIEND_API(const DOMCallbacks *)
123695: js::GetDOMCallbacks(JSRuntime *rt)
107786: {
107786:     return rt->DOMcallbacks;
107786: }
107786: 
107606: static void *gListBaseHandlerFamily = NULL;
107606: static uint32_t gListBaseExpandoSlot = 0;
107606: 
107606: JS_FRIEND_API(void)
123695: js::SetListBaseInformation(void *listBaseHandlerFamily, uint32_t listBaseExpandoSlot)
107606: {
107606:     gListBaseHandlerFamily = listBaseHandlerFamily;
107606:     gListBaseExpandoSlot = listBaseExpandoSlot;
107606: }
107606: 
107606: void *
123695: js::GetListBaseHandlerFamily()
107606: {
107606:     return gListBaseHandlerFamily;
107606: }
107606: 
107606: uint32_t
123695: js::GetListBaseExpandoSlot()
107606: {
107606:     return gListBaseExpandoSlot;
107606: }
