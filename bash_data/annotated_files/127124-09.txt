     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
     1: /* vim:set ts=2 sts=2 sw=2 et cin: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 29835: /*
 29841:  * nsWindow - Native window management and event handling.
 29841:  * 
 29835:  * nsWindow is organized into a set of major blocks and
 29835:  * block subsections. The layout is as follows:
 29835:  *
 29835:  *  Includes
 29835:  *  Variables
 29835:  *  nsIWidget impl.
 29835:  *     nsIWidget methods and utilities
 29835:  *  nsSwitchToUIThread impl.
 29835:  *     nsSwitchToUIThread methods and utilities
 29835:  *  Moz events
 29835:  *     Event initialization
 29835:  *     Event dispatching
 29835:  *  Native events
 29835:  *     Wndproc(s)
 29835:  *     Event processing
 29835:  *     OnEvent event handlers
 29835:  *  IME management and accessibility
 29835:  *  Transparency
 29835:  *  Popup hook handling
 29835:  *  Misc. utilities
 29835:  *  Child window impl.
 29835:  *
 29835:  * Search for "BLOCK:" to find major blocks.
 29835:  * Search for "SECTION:" to find specific sections.
 29835:  *
 29835:  * Blocks should be split out into separate files if they
 29835:  * become unmanageable.
 29835:  *
 29835:  * Related source:
 29835:  *
 29835:  *  nsWindowDefs.h     - Definitions, macros, structs, enums
 29835:  *                       and general setup.
 29835:  *  nsWindowDbg.h/.cpp - Debug related code and directives.
 29835:  *  nsWindowGfx.h/.cpp - Graphics and painting.
 29835:  *
 29835:  */
 29835: 
 29835: /**************************************************************
 29835:  **************************************************************
 29835:  **
 29835:  ** BLOCK: Includes
 29835:  **
 29835:  ** Include headers.
 29835:  **
 29835:  **************************************************************
 29835:  **************************************************************/
 29835: 
 38103: #include "mozilla/ipc/RPCChannel.h"
 36056: 
 80467: /* This must occur *after* ipc/RPCChannel.h to avoid typedefs conflicts. */
 80467: #include "mozilla/Util.h"
 80467: 
     1: #include "nsWindow.h"
 29835: 
108835: #include <shellapi.h>
 29835: #include <windows.h>
 29835: #include <process.h>
 29835: #include <commctrl.h>
 29835: #include <unknwn.h>
 90802: #include <psapi.h>
 29835: 
 29835: #include "prlog.h"
 29835: #include "prtime.h"
 29835: #include "prprf.h"
 29835: #include "prmem.h"
 29835: 
 68748: #include "mozilla/WidgetTraceEvent.h"
     1: #include "nsIAppShell.h"
 29835: #include "nsISupportsPrimitives.h"
 77227: #include "nsIDOMMouseEvent.h"
 29835: #include "nsITheme.h"
 29835: #include "nsIObserverService.h"
 29835: #include "nsIScreenManager.h"
 29835: #include "imgIContainer.h"
 29835: #include "nsIFile.h"
 29835: #include "nsIRollupListener.h"
 29835: #include "nsIServiceManager.h"
 29835: #include "nsIClipboard.h"
 29835: #include "nsIMM32Handler.h"
 91613: #include "WinMouseScrollHandler.h"
 68493: #include "nsFontMetrics.h"
     1: #include "nsIFontEnumerator.h"
 29835: #include "nsGUIEvent.h"
     1: #include "nsFont.h"
     1: #include "nsRect.h"
     1: #include "nsThreadUtils.h"
     1: #include "nsNativeCharsetUtils.h"
 80435: #include "nsGkAtoms.h"
 29835: #include "nsCRT.h"
 29835: #include "nsAppDirectoryServiceDefs.h"
 29835: #include "nsXPIDLString.h"
 29835: #include "nsWidgetsCID.h"
 30540: #include "nsTHashtable.h"
 30540: #include "nsHashKeys.h"
 32183: #include "nsString.h"
 41540: #include "mozilla/Services.h"
 49249: #include "nsNativeThemeWin.h"
 57388: #include "nsWindowsDllInterceptor.h"
 58814: #include "nsIWindowMediator.h"
 58814: #include "nsIServiceManager.h"
 29835: #include "nsWindowGfx.h"
 38727: #include "gfxWindowsPlatform.h"
 40028: #include "Layers.h"
 77158: #include "nsPrintfCString.h"
 70956: #include "mozilla/Preferences.h"
 78043: #include "nsISound.h"
 81361: #include "WinTaskbar.h"
 86569: #include "WinUtils.h"
 98715: #include "WidgetUtils.h"
108457: #include "nsIWidgetListener.h"
114690: #include "nsDOMTouchEvent.h"
124775: #include <cstdlib> // for std::abs(int/long)
124775: #include <cmath> // for std::abs(float/double)
 68855: 
 43174: #ifdef MOZ_ENABLE_D3D9_LAYER
 42612: #include "LayerManagerD3D9.h"
 43174: #endif
 68855: 
 54816: #ifdef MOZ_ENABLE_D3D10_LAYER
 54816: #include "LayerManagerD3D10.h"
 54816: #endif
 68855: 
 42612: #include "LayerManagerOGL.h"
 60833: #include "nsIGfxInfo.h"
 50583: #include "BasicLayers.h"
 26576: #include "nsUXThemeConstants.h"
 48247: #include "KeyboardLayout.h"
 23335: #include "nsNativeDragTarget.h"
 29835: #include <mmsystem.h> // needed for WIN32_LEAN_AND_MEAN
 29835: #include <zmouse.h>
 31281: #include <richedit.h>
 29835: 
 29835: #if defined(ACCESSIBILITY)
 31281: #include "oleidl.h"
  7756: #include <winuser.h>
102366: #include "nsAccessibilityService.h"
124964: #include "mozilla/a11y/Platform.h"
 29835: #if !defined(WINABLEAPI)
  7756: #include <winable.h>
 29835: #endif // !defined(WINABLEAPI)
 29835: #endif // defined(ACCESSIBILITY)
 29835: 
 33486: #include "nsIWinTaskbar.h"
 77693: #define NS_TASKBAR_CONTRACTID "@mozilla.org/windows-taskbar;1"
 33486: 
 29835: #if defined(NS_ENABLE_TSF)
 29835: #include "nsTextStore.h"
 29835: #endif // defined(NS_ENABLE_TSF)
 29835: 
 29835: // Windowless plugin support
 32799: #include "npapi.h"
     1: 
 29835: #include "nsWindowDefs.h"
 29835: 
 62476: #include "nsCrashOnException.h"
 51658: #include "nsIXULRuntime.h"
 51658: 
 82052: #include "nsIContent.h"
 82052: 
119111: #include "mozilla/HangMonitor.h"
119111: #include "nsIMM32Handler.h"
119111: 
 48247: using namespace mozilla::widget;
 58633: using namespace mozilla::layers;
 70956: using namespace mozilla;
 48247: 
 31122: /**************************************************************
 29835:  **************************************************************
 29835:  **
 29835:  ** BLOCK: Variables
 29835:  **
 29835:  ** nsWindow Class static initializations and global variables. 
 29835:  **
 29835:  **************************************************************
 29835:  **************************************************************/
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsWindow statics
 29835:  *
 29835:  **************************************************************/
 29835: 
 79445: bool            nsWindow::sDropShadowEnabled      = true;
108991: uint32_t        nsWindow::sInstanceCount          = 0;
 79445: bool            nsWindow::sSwitchKeyboardLayout   = false;
  7271: BOOL            nsWindow::sIsOleInitialized       = FALSE;
 29835: HCURSOR         nsWindow::sHCursor                = NULL;
106838: imgIContainer*  nsWindow::sCursorImgContainer     = nullptr;
106838: nsWindow*       nsWindow::sCurrentWindow          = nullptr;
 79445: bool            nsWindow::sJustGotDeactivate      = false;
 79445: bool            nsWindow::sJustGotActivate        = false;
 79445: bool            nsWindow::sIsInMouseCapture       = false;
 29835: 
 29835: // imported in nsWidgetFactory.cpp
 29835: TriStateBool    nsWindow::sCanQuit                = TRI_UNKNOWN;
 29835: 
 29835: // Hook Data Memebers for Dropdowns. sProcessHook Tells the
 29835: // hook methods whether they should be processing the hook
 29835: // messages.
 29835: HHOOK           nsWindow::sMsgFilterHook          = NULL;
 29835: HHOOK           nsWindow::sCallProcHook           = NULL;
 29835: HHOOK           nsWindow::sCallMouseHook          = NULL;
 79445: bool            nsWindow::sProcessHook            = false;
 29835: UINT            nsWindow::sRollupMsgId            = 0;
 29835: HWND            nsWindow::sRollupMsgWnd           = NULL;
 29835: UINT            nsWindow::sHookTimerId            = 0;
 29835: 
 29835: // Mouse Clicks - static variable definitions for figuring
 29835: // out 1 - 3 Clicks.
 29835: POINT           nsWindow::sLastMousePoint         = {0};
 29835: POINT           nsWindow::sLastMouseMovePoint     = {0};
 29835: LONG            nsWindow::sLastMouseDownTime      = 0L;
 29835: LONG            nsWindow::sLastClickCount         = 0L;
 29835: BYTE            nsWindow::sLastMouseButton        = 0;
 29835: 
 29835: // Trim heap on minimize. (initialized, but still true.)
 29835: int             nsWindow::sTrimOnMinimize         = 2;
     1: 
 57092: // Default value for general window class (used when the pref is the empty string).
 57092: const char*     nsWindow::sDefaultMainWindowClass = kClassNameGeneral;
 57092: 
 58814: // If we're using D3D9, this will not be allowed during initial 5 seconds.
 58814: bool            nsWindow::sAllowD3D9              = false;
 33529: 
 63258: TriStateBool nsWindow::sHasBogusPopupsDropShadowOnMultiMonitor = TRI_UNKNOWN;
 63258: 
 37550: // Used in OOPP plugin focus processing.
 37550: const PRUnichar* kOOPPPluginFocusEventId   = L"OOPP Plugin Focus Widget Event";
108991: uint32_t        nsWindow::sOOPPPluginFocusEvent   =
 37550:                   RegisterWindowMessageW(kOOPPPluginFocusEventId);
 37550: 
 60495: MSG             nsWindow::sRedirectedKeyDown;
 60495: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: globals variables
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: static const char *sScreenManagerContractID       = "@mozilla.org/gfx/screenmanager;1";
 29835: 
 29835: #ifdef PR_LOGGING
106838: PRLogModuleInfo* gWindowsLog                      = nullptr;
     1: #endif
 29835: 
 29835: // Kbd layout. Used throughout character processing.
 48050: static KeyboardLayout gKbdLayout;
 31985: 
 29835: // Global used in Show window enumerations.
 79445: static bool     gWindowsVisible                   = false;
 29835: 
 82031: // True if we have sent a notification that we are suspending/sleeping.
 82031: static bool     gIsSleepMode                      = false;
 82031: 
 29835: static NS_DEFINE_CID(kCClipboardCID, NS_CLIPBOARD_CID);
 29835: 
 57388: // General purpose user32.dll hook object
 57388: static WindowsDllInterceptor sUser32Intercept;
 57388: 
 87238: // 2 pixel offset for eTransparencyBorderlessGlass which equals the size of
 87238: // the default window border Windows paints. Glass will be extended inward
 87238: // this distance to remove the border.
108991: static const int32_t kGlassMarginAdjustment = 2;
 61413: 
 87238: // When the client area is extended out into the default window frame area,
 87238: // this is the minimum amount of space along the edge of resizable windows
 87238: // we will always display a resize cursor in, regardless of the underlying
 87238: // content.
108991: static const int32_t kResizableBorderMinSize = 3;
 79695: 
 79695: // We should never really try to accelerate windows bigger than this. In some
 79695: // cases this might lead to no D3D9 acceleration where we could have had it
 79695: // but D3D9 does not reliably report when it supports bigger windows. 8192
 79695: // is as safe as we can get, we know at least D3D10 hardware always supports
 79695: // this, other hardware we expect to report correctly in D3D9.
 79695: #define MAX_ACCELERATED_DIMENSION 8192
 79695: 
 79695: 
 29835: /**************************************************************
 29835:  **************************************************************
 29835:  **
 29835:  ** BLOCK: nsIWidget impl.
 29835:  **
 29835:  ** nsIWidget interface implementation, broken down into
 29835:  ** sections.
 29835:  **
 29835:  **************************************************************
 29835:  **************************************************************/
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsWindow construction and destruction
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: nsWindow::nsWindow() : nsBaseWidget()
 29835: {
 29835: #ifdef PR_LOGGING
 76714:   if (!gWindowsLog) {
 76714:     gWindowsLog = PR_NewLogModule("nsWindow");
 76714:   }
     1: #endif
     1: 
106838:   mIconSmall            = nullptr;
106838:   mIconBig              = nullptr;
106838:   mWnd                  = nullptr;
106838:   mPaintDC              = nullptr;
106838:   mPrevWndProc          = nullptr;
106838:   mNativeDragTarget     = nullptr;
 79626:   mInDtor               = false;
 79626:   mIsVisible            = false;
 79626:   mIsTopWidgetWindow    = false;
 79626:   mUnicodeWidget        = true;
 79626:   mDisplayPanFeedback   = false;
 79626:   mTouchWindow          = false;
 79626:   mCustomNonClient      = false;
 79626:   mHideChrome           = false;
 79626:   mFullscreenMode       = false;
 79626:   mMousePresent         = false;
 84178:   mDestroyCalled        = false;
 84178:   mPickerDisplayCount   = 0;
 29835:   mWindowType           = eWindowType_child;
 29835:   mBorderStyle          = eBorderStyle_default;
 46335:   mOldSizeMode          = nsSizeMode_Normal;
 97778:   mLastSizeMode         = nsSizeMode_Normal;
     1:   mLastPoint.x          = 0;
     1:   mLastPoint.y          = 0;
     1:   mLastSize.width       = 0;
     1:   mLastSize.height      = 0;
     1:   mOldStyle             = 0;
     1:   mOldExStyle           = 0;
     1:   mPainting             = 0;
 29835:   mLastKeyboardLayout   = 0;
120269:   mBlurSuppressLevel    = 0;
 89510:   mLastPaintEndTime     = TimeStamp::Now();
 29835: #ifdef MOZ_XUL
106838:   mTransparentSurface   = nullptr;
106838:   mMemoryDC             = nullptr;
 29835:   mTransparencyMode     = eTransparencyOpaque;
 39718:   memset(&mGlassMargins, 0, sizeof mGlassMargins);
 29835: #endif
 29835:   mBackground           = ::GetSysColor(COLOR_BTNFACE);
 29835:   mBrush                = ::CreateSolidBrush(NSRGB_2_COLOREF(mBackground));
 29835:   mForeground           = ::GetSysColor(COLOR_WINDOWTEXT);
 29835: 
106838:   mTaskbarPreview = nullptr;
 79626:   mHasTaskbarIconBeenCreated = false;
 33486: 
 29835:   // Global initialization
 29835:   if (!sInstanceCount) {
 81361:     // Global app registration id for Win7 and up. See
 81361:     // WinTaskbar.cpp for details.
 81361:     mozilla::widget::WinTaskbar::RegisterAppUserModelID();
 22411:     gKbdLayout.LoadLayout(::GetKeyboardLayout(0));
 29835:     // Init IME handler
 27961:     nsIMM32Handler::Initialize();
 24836: #ifdef NS_ENABLE_TSF
 24836:     nsTextStore::Initialize();
 29835: #endif
 91613:     if (SUCCEEDED(::OleInitialize(NULL))) {
  7271:       sIsOleInitialized = TRUE;
 91613:     }
  7271:     NS_ASSERTION(sIsOleInitialized, "***** OLE is not initialized!\n");
 91613:     MouseScrollHandler::Initialize();
 49249:     // Init titlebar button info for custom frames.
 49249:     nsUXThemeData::InitTitlebarInfo();
 55268:     // Init theme data
 55268:     nsUXThemeData::UpdateNativeThemeInfo();
 60495:     ForgetRedirectedKeyDownMessage();
 29835:   } // !sInstanceCount
 29835: 
106838:   mIdleService = nullptr;
 27326: 
     1:   sInstanceCount++;
 23335: }
 23335: 
     1: nsWindow::~nsWindow()
     1: {
 79626:   mInDtor = true;
 30223: 
 30223:   // If the widget was released without calling Destroy() then the native window still
 30223:   // exists, and we need to destroy it. This will also result in a call to OnDestroy.
 30223:   //
 30223:   // XXX How could this happen???
 30223:   if (NULL != mWnd)
     1:     Destroy();
     1: 
103754:   // Free app icon resources.  This must happen after `OnDestroy` (see bug 708033).
103754:   if (mIconSmall)
103754:     ::DestroyIcon(mIconSmall);
103754: 
103754:   if (mIconBig)
103754:     ::DestroyIcon(mIconBig);
103754: 
 24836:   sInstanceCount--;
 24836: 
 29835:   // Global shutdown
 29841:   if (sInstanceCount == 0) {
 24836: #ifdef NS_ENABLE_TSF
 24836:     nsTextStore::Terminate();
 29835: #endif
 29835:     NS_IF_RELEASE(sCursorImgContainer);
  7271:     if (sIsOleInitialized) {
  7968:       ::OleFlushClipboard();
  7271:       ::OleUninitialize();
  7271:       sIsOleInitialized = FALSE;
  7271:     }
 29835:     // delete any of the IME structures that we allocated
 27961:     nsIMM32Handler::Terminate();
 68855:   }
 68855: 
     1:   NS_IF_RELEASE(mNativeDragTarget);
 29835: }
 29835: 
 29835: NS_IMPL_ISUPPORTS_INHERITED0(nsWindow, nsBaseWidget)
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::Create, nsIWidget::Destroy
 29835:  *
 29835:  * Creating and destroying windows for this widget.
 29835:  *
 29835:  **************************************************************/
 29835: 
 33013: // Allow Derived classes to modify the height that is passed
 68855: // when the window is created or resized.
108991: int32_t nsWindow::GetHeight(int32_t aProposedHeight)
 33013: {
 68855:   return aProposedHeight;
 33013: }
 33013: 
 29835: // Create the proper widget
 33013: nsresult
 33013: nsWindow::Create(nsIWidget *aParent,
 33013:                  nsNativeWidget aNativeParent,
 29835:                  const nsIntRect &aRect,
 68668:                  nsDeviceContext *aContext,
 29835:                  nsWidgetInitData *aInitData)
 29835: {
 51041:   nsWidgetInitData defaultInitData;
 51041:   if (!aInitData)
 51041:     aInitData = &defaultInitData;
 51041: 
 29835:   mUnicodeWidget = aInitData->mUnicode;
 33013: 
 51041:   nsIWidget *baseParent = aInitData->mWindowType == eWindowType_dialog ||
     1:                           aInitData->mWindowType == eWindowType_toplevel ||
 51041:                           aInitData->mWindowType == eWindowType_invisible ?
106838:                           nullptr : aParent;
106838: 
106838:   mIsTopWidgetWindow = (nullptr == baseParent);
 55224:   mBounds = aRect;
     1: 
 80842:   // Ensure that the toolkit is created.
 80842:   nsToolkit::GetToolkit();
 80842: 
108460:   BaseCreate(baseParent, aRect, aContext, aInitData);
     1: 
     1:   HWND parent;
 43018:   if (aParent) { // has a nsIWidget parent
 43018:     parent = aParent ? (HWND)aParent->GetNativeData(NS_NATIVE_WINDOW) : NULL;
 43018:     mParent = aParent;
     1:   } else { // has a nsNative parent
     1:     parent = (HWND)aNativeParent;
 86569:     mParent = aNativeParent ?
106838:       WinUtils::GetNSWindowPtr((HWND)aNativeParent) : nullptr;
     1:   }
     1: 
 51919:   mIsRTL = aInitData->mRTL;
     1: 
     1:   DWORD style = WindowStyle();
     1:   DWORD extendedStyle = WindowExStyle();
     1: 
     1:   if (mWindowType == eWindowType_popup) {
116459:     if (!aParent) {
  8587:       parent = NULL;
116459:     }
116459: 
124316:     if (WinUtils::GetWindowsVersion() >= WinUtils::VISTA_VERSION &&
124316:         WinUtils::GetWindowsVersion() <= WinUtils::WIN7_VERSION) {
116459:       extendedStyle |= WS_EX_COMPOSITED;
116459:     }
 77050: 
 77050:     if (aInitData->mIsDragPopup) {
 77050:       // This flag makes the window transparent to mouse events
 77050:       extendedStyle |= WS_EX_TRANSPARENT;
 77050:     }
 31952:   } else if (mWindowType == eWindowType_invisible) {
 31952:     // Make sure CreateWindowEx succeeds at creating a toplevel window
 31960:     style &= ~0x40000000; // WS_CHILDWINDOW
 51041:   } else {
     1:     // See if the caller wants to explictly set clip children and clip siblings
     1:     if (aInitData->clipChildren) {
     1:       style |= WS_CLIPCHILDREN;
     1:     } else {
     1:       style &= ~WS_CLIPCHILDREN;
     1:     }
     1:     if (aInitData->clipSiblings) {
     1:       style |= WS_CLIPSIBLINGS;
     1:     }
     1:   }
     1: 
 57092:   nsAutoString className;
 57092:   if (aInitData->mDropShadow) {
 57092:     GetWindowPopupClass(className);
 57092:   } else {
 57092:     GetWindowClass(className);
 57092:   }
 77660:   // Plugins are created in the disabled state so that they can't
 77660:   // steal focus away from our main window.  This is especially
 77660:   // important if the plugin has loaded in a background tab.
 77660:   if(aInitData->mWindowType == eWindowType_plugin) {
 77660:     style |= WS_DISABLED;
 77660:   }
     1:   mWnd = ::CreateWindowExW(extendedStyle,
 57092:                            className.get(),
     1:                            L"",
     1:                            style,
     1:                            aRect.x,
     1:                            aRect.y,
     1:                            aRect.width,
     1:                            GetHeight(aRect.height),
     1:                            parent,
     1:                            NULL,
     1:                            nsToolkit::mDllInstance,
     1:                            NULL);
     1: 
 46192:   if (!mWnd) {
 46192:     NS_WARNING("nsWindow CreateWindowEx failed.");
     1:     return NS_ERROR_FAILURE;
 46192:   }
     1: 
 52118:   if (mIsRTL && nsUXThemeData::dwmSetWindowAttributePtr) {
 52118:     DWORD dwAttribute = TRUE;    
 52118:     nsUXThemeData::dwmSetWindowAttributePtr(mWnd, DWMWA_NONCLIENT_RTL_LAYOUT, &dwAttribute, sizeof dwAttribute);
 52118:   }
 52118: 
 91763:   if (mWindowType != eWindowType_plugin &&
 91763:       mWindowType != eWindowType_invisible &&
 91617:       MouseScrollHandler::Device::IsFakeScrollableWindowNeeded()) {
 91763:     // Ugly Thinkpad Driver Hack (Bugs 507222 and 594977)
 59750:     //
 91763:     // We create two zero-sized windows as descendants of the top-level window,
 91763:     // like so:
 59750:     //
 59750:     //   Top-level window (MozillaWindowClass)
 59750:     //     FAKETRACKPOINTSCROLLCONTAINER (MozillaWindowClass)
 59750:     //       FAKETRACKPOINTSCROLLABLE (MozillaWindowClass)
 59750:     //
 91763:     // We need to have the middle window, otherwise the Trackpoint driver
 59750:     // will fail to deliver scroll messages.  WM_MOUSEWHEEL messages are
 59750:     // sent to the FAKETRACKPOINTSCROLLABLE, which then propagate up the
 59750:     // window hierarchy until they are handled by nsWindow::WindowProc.
 59750:     // WM_HSCROLL messages are also sent to the FAKETRACKPOINTSCROLLABLE,
 59750:     // but these do not propagate automatically, so we have the window
 59750:     // procedure pretend that they were dispatched to the top-level window
 59750:     // instead.
 59750:     //
 59750:     // The FAKETRACKPOINTSCROLLABLE needs to have the specific window styles it
 59750:     // is given below so that it catches the Trackpoint driver's heuristics.
 59750:     HWND scrollContainerWnd = ::CreateWindowW
 59750:       (className.get(), L"FAKETRACKPOINTSCROLLCONTAINER",
 59750:        WS_CHILD | WS_VISIBLE,
 59750:        0, 0, 0, 0, mWnd, NULL, nsToolkit::mDllInstance, NULL);
 59750:     HWND scrollableWnd = ::CreateWindowW
 59750:       (className.get(), L"FAKETRACKPOINTSCROLLABLE",
 59750:        WS_CHILD | WS_VISIBLE | WS_VSCROLL | WS_TABSTOP | 0x30,
 59750:        0, 0, 0, 0, scrollContainerWnd, NULL, nsToolkit::mDllInstance, NULL);
 59750: 
 59750:     // Give the FAKETRACKPOINTSCROLLABLE window a specific ID so that
 59750:     // WindowProcInternal can distinguish it from the top-level window
 59750:     // easily.
 59750:     ::SetWindowLongPtrW(scrollableWnd, GWLP_ID, eFakeTrackPointScrollableID);
 59750: 
 59750:     // Make FAKETRACKPOINTSCROLLABLE use nsWindow::WindowProc, and store the
 59750:     // old window procedure in its "user data".
 59750:     WNDPROC oldWndProc;
 59750:     if (mUnicodeWidget)
 59750:       oldWndProc = (WNDPROC)::SetWindowLongPtrW(scrollableWnd, GWLP_WNDPROC,
 59750:                                                 (LONG_PTR)nsWindow::WindowProc);
 59750:     else
 59750:       oldWndProc = (WNDPROC)::SetWindowLongPtrA(scrollableWnd, GWLP_WNDPROC,
 59750:                                                 (LONG_PTR)nsWindow::WindowProc);
 59750:     ::SetWindowLongPtrW(scrollableWnd, GWLP_USERDATA, (LONG_PTR)oldWndProc);
 33357:   }
 32183: 
     1:   SubclassWindow(TRUE);
     1: 
120230:   // NOTE: mNativeIMEContext may be null if IMM module isn't installed.
120230:   nsIMEContext IMEContext(mWnd);
120230:   mInputContext.mNativeIMEContext = static_cast<void*>(IMEContext.get());
120230:   MOZ_ASSERT(mInputContext.mNativeIMEContext ||
120230:              !nsIMM32Handler::IsIMEAvailable());
120230:   // If no IME context is available, we should set this widget's pointer since
120230:   // nullptr indicates there is only one context per process on the platform.
120230:   if (!mInputContext.mNativeIMEContext) {
120230:     mInputContext.mNativeIMEContext = this;
120230:   }
120230: 
 70972:   // If the internal variable set by the config.trim_on_minimize pref has not
 70972:   // been initialized, and if this is the hidden window (conveniently created
 70972:   // before any visible windows, and after the profile has been initialized),
 70972:   // do some initialization work.
 29835:   if (sTrimOnMinimize == 2 && mWindowType == eWindowType_invisible) {
 70972:     // Our internal trim prevention logic is effective on 2K/XP at maintaining
 70972:     // the working set when windows are minimized, but on Vista and up it has
 70972:     // little to no effect. Since this feature has been the source of numerous
 70972:     // bugs over the years, disable it (sTrimOnMinimize=1) on Vista and up.
 70956:     sTrimOnMinimize =
 70972:       Preferences::GetBool("config.trim_on_minimize",
 86569:         (WinUtils::GetWindowsVersion() >= WinUtils::VISTA_VERSION)) ? 1 : 0;
 70956:     sSwitchKeyboardLayout =
 79445:       Preferences::GetBool("intl.keyboard.per_window_layout", false);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 30223: // Close this nsWindow
 30223: NS_METHOD nsWindow::Destroy()
 30223: {
 77212:   // WM_DESTROY has already fired, avoid calling it twice
 77212:   if (mOnDestroyCalled)
 30223:     return NS_OK;
 30223: 
 84178:   // Don't destroy windows that have file pickers open, we'll tear these down
 84178:   // later once the picker is closed.
 84178:   mDestroyCalled = true;
 84178:   if (mPickerDisplayCount)
 84178:     return NS_OK;
 84178: 
 30223:   // During the destruction of all of our children, make sure we don't get deleted.
 30223:   nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
 30223: 
 40028:   /**
 40028:    * On windows the LayerManagerOGL destructor wants the widget to be around for
 40028:    * cleanup. It also would like to have the HWND intact, so we NULL it here.
 40028:    */
 49074:   if (mLayerManager) {
 49074:     mLayerManager->Destroy();
 49074:   }
106838:   mLayerManager = nullptr;
 40028: 
 51000:   /* We should clear our cached resources now and not wait for the GC to
 50777:    * delete the nsWindow. */
 51000:   ClearCachedResources();
 50777: 
 30223:   // The DestroyWindow function destroys the specified window. The function sends WM_DESTROY
 30223:   // and WM_NCDESTROY messages to the window to deactivate it and remove the keyboard focus
 30223:   // from it. The function also destroys the window's menu, flushes the thread message queue,
 30223:   // destroys timers, removes clipboard ownership, and breaks the clipboard viewer chain (if
 30223:   // the window is at the top of the viewer chain).
 30223:   //
 30223:   // If the specified window is a parent or owner window, DestroyWindow automatically destroys
 30223:   // the associated child or owned windows when it destroys the parent or owner window. The
 30223:   // function first destroys child or owned windows, and then it destroys the parent or owner
 30223:   // window.
 30223:   VERIFY(::DestroyWindow(mWnd));
 30223:   
 30223:   // Our windows can be subclassed which may prevent us receiving WM_DESTROY. If OnDestroy()
 30223:   // didn't get called, call it now.
 79626:   if (false == mOnDestroyCalled) {
 58032:     LRESULT result;
 58032:     mWindowHook.Notify(mWnd, WM_DESTROY, 0, 0, &result);
 30223:     OnDestroy();
 58032:   }
 30223: 
 30223:   return NS_OK;
 30223: }
 30223: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: Window class utilities
 29835:  *
 29835:  * Utilities for calculating the proper window class name for
 29835:  * Create window.
 29835:  *
 29835:  **************************************************************/
 29835: 
 57092: void nsWindow::RegisterWindowClass(const nsString& aClassName, UINT aExtraStyle,
 57092:                                    LPWSTR aIconID)
 57092: {
 29835:   WNDCLASSW wc;
 57092:   if (::GetClassInfoW(nsToolkit::mDllInstance, aClassName.get(), &wc)) {
 57092:     // already registered
 57092:     return;
 57092:   }
 57092: 
 57092:   wc.style         = CS_DBLCLKS | aExtraStyle;
 29835:   wc.lpfnWndProc   = ::DefWindowProcW;
 29835:   wc.cbClsExtra    = 0;
 29835:   wc.cbWndExtra    = 0;
 29835:   wc.hInstance     = nsToolkit::mDllInstance;
 57092:   wc.hIcon         = aIconID ? ::LoadIconW(::GetModuleHandleW(NULL), aIconID) : NULL;
 29835:   wc.hCursor       = NULL;
 29835:   wc.hbrBackground = mBrush;
 29835:   wc.lpszMenuName  = NULL;
 57092:   wc.lpszClassName = aClassName.get();
 57092: 
 57092:   if (!::RegisterClassW(&wc)) {
 57092:     // For older versions of Win32 (i.e., not XP), the registration may
 57092:     // fail with aExtraStyle, so we have to re-register without it.
 57092:     wc.style = CS_DBLCLKS;
 57092:     ::RegisterClassW(&wc);
 57092:   }
 57092: }
 57092: 
 57103: static LPWSTR const gStockApplicationIcon = MAKEINTRESOURCEW(32512);
 57103: 
 57092: // Return the proper window class for everything except popups.
 57092: void nsWindow::GetWindowClass(nsString& aWindowClass)
 57092: {
 57092:   switch (mWindowType) {
 57092:   case eWindowType_invisible:
 57092:     aWindowClass.AssignLiteral(kClassNameHidden);
 57103:     RegisterWindowClass(aWindowClass, 0, gStockApplicationIcon);
 57092:     break;
 57092:   case eWindowType_dialog:
 57092:     aWindowClass.AssignLiteral(kClassNameDialog);
 57092:     RegisterWindowClass(aWindowClass, 0, 0);
 57092:     break;
 57092:   default:
 57092:     GetMainWindowClass(aWindowClass);
 57103:     RegisterWindowClass(aWindowClass, 0, gStockApplicationIcon);
 57092:     break;
 57092:   }
 29835: }
 29835: 
 29835: // Return the proper popup window class
 57092: void nsWindow::GetWindowPopupClass(nsString& aWindowClass)
 57092: {
 57092:   aWindowClass.AssignLiteral(kClassNameDropShadow);
 57103:   RegisterWindowClass(aWindowClass, CS_XP_DROPSHADOW, gStockApplicationIcon);
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: Window styles utilities
 29835:  *
 29835:  * Return the proper windows styles and extended styles.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: // Return nsWindow styles
 29835: DWORD nsWindow::WindowStyle()
 29835: {
 29835:   DWORD style;
 29835: 
 29835:   switch (mWindowType) {
 33357:     case eWindowType_plugin:
 29835:     case eWindowType_child:
 29835:       style = WS_OVERLAPPED;
 29835:       break;
 29835: 
 29835:     case eWindowType_dialog:
 46264:       style = WS_OVERLAPPED | WS_BORDER | WS_DLGFRAME | WS_SYSMENU | DS_3DLOOK |
 46264:               DS_MODALFRAME | WS_CLIPCHILDREN;
 29835:       if (mBorderStyle != eBorderStyle_default)
 29835:         style |= WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX;
 29835:       break;
 29835: 
 29835:     case eWindowType_popup:
 29835:       style = WS_POPUP;
 50770:       if (!HasGlass()) {
 29835:         style |= WS_OVERLAPPED;
 29835:       }
 29835:       break;
 29835: 
 29835:     default:
 31561:       NS_ERROR("unknown border style");
 29835:       // fall through
 29835: 
 29835:     case eWindowType_toplevel:
 29835:     case eWindowType_invisible:
 29835:       style = WS_OVERLAPPED | WS_BORDER | WS_DLGFRAME | WS_SYSMENU |
 46264:               WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_CLIPCHILDREN;
 29835:       break;
 29835:   }
 29835: 
 31589:   if (mBorderStyle != eBorderStyle_default && mBorderStyle != eBorderStyle_all) {
 31589:     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_border))
 31589:       style &= ~WS_BORDER;
 31589: 
 31589:     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_title)) {
 31589:       style &= ~WS_DLGFRAME;
 31589:       style |= WS_POPUP;
 31589:       style &= ~WS_CHILD;
 31589:     }
 31589: 
 31589:     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_close))
 31589:       style &= ~0;
 31589:     // XXX The close box can only be removed by changing the window class,
 31589:     // as far as I know   --- roc+moz@cs.cmu.edu
 31589: 
 31589:     if (mBorderStyle == eBorderStyle_none ||
 31589:       !(mBorderStyle & (eBorderStyle_menu | eBorderStyle_close)))
 31589:       style &= ~WS_SYSMENU;
 31589:     // Looks like getting rid of the system menu also does away with the
 31589:     // close box. So, we only get rid of the system menu if you want neither it
 31589:     // nor the close box. How does the Windows "Dialog" window class get just
 31589:     // closebox and no sysmenu? Who knows.
 31589: 
 31589:     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_resizeh))
 31589:       style &= ~WS_THICKFRAME;
 31589: 
 31589:     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_minimize))
 31589:       style &= ~WS_MINIMIZEBOX;
 31589: 
 31589:     if (mBorderStyle == eBorderStyle_none || !(mBorderStyle & eBorderStyle_maximize))
 31589:       style &= ~WS_MAXIMIZEBOX;
 48256: 
 48256:     if (IsPopupWithTitleBar()) {
 48256:       style |= WS_CAPTION;
 48261:       if (mBorderStyle & eBorderStyle_close) {
 48261:         style |= WS_SYSMENU;
 48261:       }
 48256:     }
 48256:   }
 48256: 
 29835:   VERIFY_WINDOW_STYLE(style);
 29835:   return style;
 29835: }
 29835: 
 29835: // Return nsWindow extended styles
 29835: DWORD nsWindow::WindowExStyle()
 29835: {
 29835:   switch (mWindowType)
 29835:   {
 33357:     case eWindowType_plugin:
 29835:     case eWindowType_child:
 29835:       return 0;
 29835: 
 29835:     case eWindowType_dialog:
 29835:       return WS_EX_WINDOWEDGE | WS_EX_DLGMODALFRAME;
 29835: 
 29835:     case eWindowType_popup:
 48254:     {
 68855:       DWORD extendedStyle = WS_EX_TOOLWINDOW;
 48254:       if (mPopupLevel == ePopupLevelTop)
 48254:         extendedStyle |= WS_EX_TOPMOST;
 48254:       return extendedStyle;
 48254:     }
 29835:     default:
 31561:       NS_ERROR("unknown border style");
 29835:       // fall through
 29835: 
 29835:     case eWindowType_toplevel:
 29835:     case eWindowType_invisible:
 29835:       return WS_EX_WINDOWEDGE;
 29835:   }
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: Window subclassing utilities
 29835:  *
 29835:  * Set or clear window subclasses on native windows. Used in
 29835:  * Create and Destroy.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: // Subclass (or remove the subclass from) this component's nsWindow
 29835: void nsWindow::SubclassWindow(BOOL bState)
 29835: {
100251:   if (bState) {
100251:     if (!mWnd || !IsWindow(mWnd)) {
 33486:       NS_ERROR("Invalid window handle");
 33486:     }
 29835: 
100251:     if (mUnicodeWidget) {
100251:       mPrevWndProc =
100251:         reinterpret_cast<WNDPROC>(
100251:           SetWindowLongPtrW(mWnd,
100251:                             GWLP_WNDPROC,
100251:                             reinterpret_cast<LONG_PTR>(nsWindow::WindowProc)));
100251:     } else {
100251:       mPrevWndProc =
100251:         reinterpret_cast<WNDPROC>(
100251:           SetWindowLongPtrA(mWnd,
100251:                             GWLP_WNDPROC,
100251:                             reinterpret_cast<LONG_PTR>(nsWindow::WindowProc)));
100251:     }
 29835:     NS_ASSERTION(mPrevWndProc, "Null standard window procedure");
 29835:     // connect the this pointer to the nsWindow handle
 86569:     WinUtils::SetNSWindowPtr(mWnd, this);
100251:   } else {
100251:     if (IsWindow(mWnd)) {
100251:       if (mUnicodeWidget) {
100251:         SetWindowLongPtrW(mWnd,
100251:                           GWLP_WNDPROC,
100251:                           reinterpret_cast<LONG_PTR>(mPrevWndProc));
100251:       } else {
100251:         SetWindowLongPtrA(mWnd,
100251:                           GWLP_WNDPROC,
100251:                           reinterpret_cast<LONG_PTR>(mPrevWndProc));
100251:       }
100251:     }
 86569:     WinUtils::SetNSWindowPtr(mWnd, NULL);
 29835:     mPrevWndProc = NULL;
 29835:   }
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::SetParent, nsIWidget::GetParent
 29835:  *
 29835:  * Set or clear the parent widgets using window properties, and
 29835:  * handles calculating native parent handles.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: // Get and set parent widgets
     1: NS_IMETHODIMP nsWindow::SetParent(nsIWidget *aNewParent)
     1: {
 43018:   mParent = aNewParent;
 43018: 
  3419:   nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
  3419:   nsIWidget* parent = GetParent();
  3419:   if (parent) {
  3419:     parent->RemoveChild(this);
  3419:   }
 54312:   if (aNewParent) {
 54312:     ReparentNativeWidget(aNewParent);
 54312:     aNewParent->AddChild(this);
 54312:     return NS_OK;
 54312:   }
 54312:   if (mWnd) {
 54312:     // If we have no parent, SetParent should return the desktop.
106838:     VERIFY(::SetParent(mWnd, nullptr));
 54312:   }
 54312:   return NS_OK;
 54312: }
 54312: 
 54312: NS_IMETHODIMP
 54312: nsWindow::ReparentNativeWidget(nsIWidget* aNewParent)
 54312: {
 54312:   NS_PRECONDITION(aNewParent, "");
 54312: 
 54312:   mParent = aNewParent;
 54312:   if (mWindowType == eWindowType_popup) {
 54312:     return NS_OK;
 54312:   }
     1:   HWND newParent = (HWND)aNewParent->GetNativeData(NS_NATIVE_WINDOW);
     1:   NS_ASSERTION(newParent, "Parent widget has a null native window handle");
  3419:   if (newParent && mWnd) {
     1:     ::SetParent(mWnd, newParent);
  3419:   }
  4577:   return NS_OK;
     1: }
     1: 
     1: nsIWidget* nsWindow::GetParent(void)
     1: {
 79626:   return GetParentWindow(false);
 27505: }
 27505: 
 50783: float nsWindow::GetDPI()
 50783: {
 50783:   HDC dc = ::GetDC(mWnd);
 50783:   if (!dc)
 50783:     return 96.0f;
 50783: 
 50784:   double heightInches = ::GetDeviceCaps(dc, VERTSIZE)/MM_PER_INCH_FLOAT;
 50783:   int heightPx = ::GetDeviceCaps(dc, VERTRES);
 50783:   ::ReleaseDC(mWnd, dc);
 50783:   if (heightInches < 0.25) {
 50783:     // Something's broken
 50783:     return 96.0f;
 50783:   }
 50783:   return float(heightPx/heightInches);
 50783: }
 50783: 
120488: double nsWindow::GetDefaultScaleInternal()
116171: {
116171:   HDC dc = ::GetDC(mWnd);
116171:   if (!dc)
116171:     return 1.0;
116171: 
116171:   // LOGPIXELSY returns the number of logical pixels per inch. This is based
116171:   // on font DPI settings rather than the actual screen DPI.
116171:   double pixelsPerInch = ::GetDeviceCaps(dc, LOGPIXELSY);
116171:   ::ReleaseDC(mWnd, dc);
116171:   return pixelsPerInch/96.0;
116171: }
116171: 
 79445: nsWindow* nsWindow::GetParentWindow(bool aIncludeOwner)
 19016: {
 19016:   if (mIsTopWidgetWindow) {
     1:     // Must use a flag instead of mWindowType to tell if the window is the
     1:     // owned by the topmost widget, because a child window can be embedded inside
     1:     // a HWND which is not associated with a nsIWidget.
106838:     return nullptr;
     1:   }
 19016: 
     1:   // If this widget has already been destroyed, pretend we have no parent.
     1:   // This corresponds to code in Destroy which removes the destroyed
     1:   // widget from its parent's child list.
 30223:   if (mInDtor || mOnDestroyCalled)
106838:     return nullptr;
     1: 
 27505: 
 27505:   // aIncludeOwner set to true implies walking the parent chain to retrieve the
 27505:   // root owner. aIncludeOwner set to false implies the search will stop at the
 27505:   // true parent (default).
106838:   nsWindow* widget = nullptr;
     1:   if (mWnd) {
106838:     HWND parent = nullptr;
 27505:     if (aIncludeOwner)
 27505:       parent = ::GetParent(mWnd);
 27505:     else
 27505:       parent = ::GetAncestor(mWnd, GA_PARENT);
 68855: 
     1:     if (parent) {
 86569:       widget = WinUtils::GetNSWindowPtr(parent);
     1:       if (widget) {
     1:         // If the widget is in the process of being destroyed then
     1:         // do NOT return it
 30223:         if (widget->mInDtor) {
106838:           widget = nullptr;
     1:         }
     1:       }
     1:     }
     1:   }
     1: 
     1:   return widget;
     1: }
     1:  
 58811: BOOL CALLBACK
 58811: nsWindow::EnumAllChildWindProc(HWND aWnd, LPARAM aParam)
 58811: {
 86569:   nsWindow *wnd = WinUtils::GetNSWindowPtr(aWnd);
 58811:   if (wnd) {
 58811:     ((nsWindow::WindowEnumCallback*)aParam)(wnd);
 58811:   }
 58811:   return TRUE;
 58811: }
 58811: 
 58811: BOOL CALLBACK
 58811: nsWindow::EnumAllThreadWindowProc(HWND aWnd, LPARAM aParam)
 58811: {
 86569:   nsWindow *wnd = WinUtils::GetNSWindowPtr(aWnd);
 58811:   if (wnd) {
 58811:     ((nsWindow::WindowEnumCallback*)aParam)(wnd);
 58811:   }
 58811:   EnumChildWindows(aWnd, EnumAllChildWindProc, aParam);
 58811:   return TRUE;
 58811: }
 58811: 
 58811: void
 58811: nsWindow::EnumAllWindows(WindowEnumCallback aCallback)
 58811: {
 58811:   EnumThreadWindows(GetCurrentThreadId(),
 58811:                     EnumAllThreadWindowProc,
 61524:                     (LPARAM)aCallback);
 58811: }
 58811: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::Show
 29835:  *
 29835:  * Hide or show this component.
 29835:  *
 29835:  **************************************************************/
     1: 
 79445: NS_METHOD nsWindow::Show(bool bState)
     1: {
 62852:   if (mWindowType == eWindowType_popup) {
 63258:     // See bug 603793. When we try to draw D3D9/10 windows with a drop shadow
 62852:     // without the DWM on a secondary monitor, windows fails to composite
 62852:     // our windows correctly. We therefor switch off the drop shadow for
 62852:     // pop-up windows when the DWM is disabled and two monitors are
 62852:     // connected.
 63258:     if (HasBogusPopupsDropShadowOnMultiMonitor() &&
 86569:         WinUtils::GetMonitorCount() > 1 &&
 62852:         !nsUXThemeData::CheckForCompositor())
 62852:     {
 62852:       if (sDropShadowEnabled) {
 62852:         ::SetClassLongA(mWnd, GCL_STYLE, 0);
 79626:         sDropShadowEnabled = false;
 62852:       }
 62852:     } else {
 62852:       if (!sDropShadowEnabled) {
 62852:         ::SetClassLongA(mWnd, GCL_STYLE, CS_DROPSHADOW);
 79626:         sDropShadowEnabled = true;
 62852:       }
 62852:     }
119388: 
119388:     // WS_EX_COMPOSITED conflicts with the WS_EX_LAYERED style and causes
119388:     // some popup menus to become invisible.
119388:     LONG_PTR exStyle = ::GetWindowLongPtrW(mWnd, GWL_EXSTYLE);
119388:     if (exStyle & WS_EX_LAYERED) {
119388:       ::SetWindowLongPtrW(mWnd, GWL_EXSTYLE, exStyle & ~WS_EX_COMPOSITED);
119388:     }
 62852:   }
 62852: 
 79445:   bool syncInvalidate = false;
 79445: 
 79445:   bool wasVisible = mIsVisible;
 16326:   // Set the status now so that anyone asking during ShowWindow or
 16326:   // SetWindowPos would get the correct answer.
 16326:   mIsVisible = bState;
 16326: 
 62612:   // We may have cached an out of date visible state. This can happen
 62612:   // when session restore sets the full screen mode.
 62612:   if (mIsVisible)
 62612:     mOldStyle |= WS_VISIBLE;
 62612:   else
 62612:     mOldStyle &= ~WS_VISIBLE;
 62612: 
 50583:   if (!mIsVisible && wasVisible) {
 51000:       ClearCachedResources();
 51000:   }
 50583: 
     1:   if (mWnd) {
     1:     if (bState) {
 16326:       if (!wasVisible && mWindowType == eWindowType_toplevel) {
 62274:         // speed up the initial paint after show for
 62274:         // top level windows:
 79626:         syncInvalidate = true;
     1:         switch (mSizeMode) {
 64173:           case nsSizeMode_Fullscreen:
 64173:             ::ShowWindow(mWnd, SW_SHOW);
 64173:             break;
 24970:           case nsSizeMode_Maximized :
 24970:             ::ShowWindow(mWnd, SW_SHOWMAXIMIZED);
 24970:             break;
     1:           case nsSizeMode_Minimized :
     1:             ::ShowWindow(mWnd, SW_SHOWMINIMIZED);
 24795:             break;
     1:           default:
     1:             if (CanTakeFocus()) {
 24795:               ::ShowWindow(mWnd, SW_SHOWNORMAL);
     1:             } else {
     1:               // Place the window behind the foreground window
     1:               // (as long as it is not topmost)
     1:               HWND wndAfter = ::GetForegroundWindow();
     1:               if (!wndAfter)
     1:                 wndAfter = HWND_BOTTOM;
 25349:               else if (GetWindowLongPtrW(wndAfter, GWL_EXSTYLE) & WS_EX_TOPMOST)
     1:                 wndAfter = HWND_TOP;
     1:               ::SetWindowPos(mWnd, wndAfter, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOSIZE | 
     1:                              SWP_NOMOVE | SWP_NOACTIVATE);
     1:               GetAttention(2);
     1:             }
 23335:             break;
     1:         }
     1:       } else {
     1:         DWORD flags = SWP_NOSIZE | SWP_NOMOVE | SWP_SHOWWINDOW;
 16326:         if (wasVisible)
     1:           flags |= SWP_NOZORDER;
     1: 
     1:         if (mWindowType == eWindowType_popup) {
     1:           // ensure popups are the topmost of the TOPMOST
     1:           // layer. Remember not to set the SWP_NOZORDER
     1:           // flag as that might allow the taskbar to overlap
 68855:           // the popup.
     1:           flags |= SWP_NOACTIVATE;
  8408:           HWND owner = ::GetWindow(mWnd, GW_OWNER);
  8408:           ::SetWindowPos(mWnd, owner ? 0 : HWND_TOPMOST, 0, 0, 0, 0, flags);
     1:         } else {
 26616:           if (mWindowType == eWindowType_dialog && !CanTakeFocus())
 26616:             flags |= SWP_NOACTIVATE;
 68855: 
     1:           ::SetWindowPos(mWnd, HWND_TOP, 0, 0, 0, 0, flags);
     1:         }
     1:       }
 41071: 
 41071:       if (!wasVisible && (mWindowType == eWindowType_toplevel || mWindowType == eWindowType_dialog)) {
 41071:         // when a toplevel window or dialog is shown, initialize the UI state
 41071:         ::SendMessageW(mWnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_INITIALIZE, UISF_HIDEFOCUS | UISF_HIDEACCEL), 0);
 41071:       }
     1:     } else {
104347:       // Clear contents to avoid ghosting of old content if we display
104347:       // this window again.
104347:       if (wasVisible && mTransparencyMode == eTransparencyTransparent) {
104347:         ClearTranslucentWindow();
104347:       }
     1:       if (mWindowType != eWindowType_dialog) {
     1:         ::ShowWindow(mWnd, SW_HIDE);
     1:       } else {
     1:         ::SetWindowPos(mWnd, 0, 0, 0, 0, 0, SWP_HIDEWINDOW | SWP_NOSIZE | SWP_NOMOVE |
     1:                        SWP_NOZORDER | SWP_NOACTIVATE);
     1:       }
     1:     }
     1:   }
     1:   
     1: #ifdef MOZ_XUL
 87336:   if (!wasVisible && bState) {
 87336:     Invalidate();
126129:     if (syncInvalidate && !mInDtor && !mOnDestroyCalled) {
 87336:       ::UpdateWindow(mWnd);
 87336:     }
 87336:   }
     1: #endif
     1: 
     1:   return NS_OK;
     1: }
     1: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::IsVisible
 29835:  *
 29835:  * Returns the visibility state.
 29835:  *
 29835:  **************************************************************/
 29835: 
 79626: // Return true if the whether the component is visible, false otherwise
105772: bool nsWindow::IsVisible() const
105772: {
105772:   return mIsVisible;
     1: }
     1: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: Window clipping utilities
 29835:  *
 29835:  * Used in Size and Move operations for setting the proper
 29835:  * window clipping regions for window transparency.
 29835:  *
 29835:  **************************************************************/
     1: 
 26576: // XP and Vista visual styles sometimes require window clipping regions to be applied for proper
 26576: // transparency. These routines are called on size and move operations.
 26576: void nsWindow::ClearThemeRegion()
 26576: {
 90191:   if (WinUtils::GetWindowsVersion() >= WinUtils::VISTA_VERSION &&
 90191:       !HasGlass() &&
 52101:       (mWindowType == eWindowType_popup && !IsPopupWithTitleBar() &&
 52101:        (mPopupType == ePopupTypeTooltip || mPopupType == ePopupTypePanel))) {
 26576:     SetWindowRgn(mWnd, NULL, false);
 26650:   }
 26576: }
 26576: 
 26576: void nsWindow::SetThemeRegion()
 26576: {
 26576:   // Popup types that have a visual styles region applied (bug 376408). This can be expanded
 26576:   // for other window types as needed. The regions are applied generically to the base window
 26576:   // so default constants are used for part and state. At some point we might need part and
 26576:   // state values from nsNativeThemeWin's GetThemePartAndState, but currently windows that
 26576:   // change shape based on state haven't come up.
 90191:   if (WinUtils::GetWindowsVersion() >= WinUtils::VISTA_VERSION &&
 90191:       !HasGlass() &&
 52101:       (mWindowType == eWindowType_popup && !IsPopupWithTitleBar() &&
 52101:        (mPopupType == ePopupTypeTooltip || mPopupType == ePopupTypePanel))) {
106838:     HRGN hRgn = nullptr;
 26576:     RECT rect = {0,0,mBounds.width,mBounds.height};
 26576:     
 36844:     HDC dc = ::GetDC(mWnd);
 90802:     GetThemeBackgroundRegion(nsUXThemeData::GetTheme(eUXTooltip), dc, TTP_STANDARD, TS_NORMAL, &rect, &hRgn);
 26576:     if (hRgn) {
 26576:       if (!SetWindowRgn(mWnd, hRgn, false)) // do not delete or alter hRgn if accepted.
 26576:         DeleteObject(hRgn);
 26576:     }
 36844:     ::ReleaseDC(mWnd, dc);
 26576:   }
 26576: }
 26576: 
 29835: /**************************************************************
 29835:  *
 48711:  * SECTION: nsIWidget::RegisterTouchWindow,
 48711:  * nsIWidget::UnregisterTouchWindow, and helper functions
 48711:  *
 48711:  * Used to register the native window to receive touch events
 48711:  *
 48711:  **************************************************************/
 48711: 
 48711: NS_METHOD nsWindow::RegisterTouchWindow() {
 79626:   mTouchWindow = true;
 48711:   mGesture.RegisterTouchWindow(mWnd);
 51212:   ::EnumChildWindows(mWnd, nsWindow::RegisterTouchForDescendants, 0);
 48711:   return NS_OK;
 48711: }
 48711: 
 48711: NS_METHOD nsWindow::UnregisterTouchWindow() {
 79626:   mTouchWindow = false;
 48711:   mGesture.UnregisterTouchWindow(mWnd);
 51212:   ::EnumChildWindows(mWnd, nsWindow::UnregisterTouchForDescendants, 0);
 48711:   return NS_OK;
 48711: }
 48711: 
 48711: BOOL CALLBACK nsWindow::RegisterTouchForDescendants(HWND aWnd, LPARAM aMsg) {
 86569:   nsWindow* win = WinUtils::GetNSWindowPtr(aWnd);
 48711:   if (win)
 48711:     win->mGesture.RegisterTouchWindow(aWnd);
 48711:   return TRUE;
 48711: }
 48711: 
 48711: BOOL CALLBACK nsWindow::UnregisterTouchForDescendants(HWND aWnd, LPARAM aMsg) {
 86569:   nsWindow* win = WinUtils::GetNSWindowPtr(aWnd);
 48711:   if (win)
 48711:     win->mGesture.UnregisterTouchWindow(aWnd);
 48711:   return TRUE;
 48711: }
 48711: 
 48711: /**************************************************************
 48711:  *
 33506:  * SECTION: nsIWidget::Move, nsIWidget::Resize,
 33506:  * nsIWidget::Size, nsIWidget::BeginResizeDrag
 29835:  *
 29835:  * Repositioning and sizing a window.
 29835:  *
 29835:  **************************************************************/
 29835: 
106923: void
106923: nsWindow::SetSizeConstraints(const SizeConstraints& aConstraints)
106923: {
106923:   SizeConstraints c = aConstraints;
106923:   if (mWindowType != eWindowType_popup) {
108991:     c.mMinSize.width = NS_MAX(int32_t(::GetSystemMetrics(SM_CXMINTRACK)), c.mMinSize.width);
108991:     c.mMinSize.height = NS_MAX(int32_t(::GetSystemMetrics(SM_CYMINTRACK)), c.mMinSize.height);
106923:   }
106923: 
106923:   nsBaseWidget::SetSizeConstraints(c);
106923: }
106923: 
     1: // Move this component
125634: NS_METHOD nsWindow::Move(double aX, double aY)
     1: {
 34488:   if (mWindowType == eWindowType_toplevel ||
 34488:       mWindowType == eWindowType_dialog) {
 34488:     SetSizeMode(nsSizeMode_Normal);
 34488:   }
     1:   // Check to see if window needs to be moved first
     1:   // to avoid a costly call to SetWindowPos. This check
     1:   // can not be moved to the calling code in nsView, because
     1:   // some platforms do not position child windows correctly
     1: 
     1:   // Only perform this check for non-popup windows, since the positioning can
     1:   // in fact change even when the x/y do not.  We always need to perform the
     1:   // check. See bug #97805 for details.
     1:   if (mWindowType != eWindowType_popup && (mBounds.x == aX) && (mBounds.y == aY))
     1:   {
     1:     // Nothing to do, since it is already positioned correctly.
     1:     return NS_OK;
     1:   }
     1: 
125978:   // for top-level windows only, convert coordinates from global display pixels
125978:   // (the "parent" coordinate space) to the window's device pixel space
125978:   double scale =
125978:     (mWindowType <= eWindowType_popup) ? GetDefaultScale() : 1.0;
125978:   int32_t x = NSToIntRound(aX * scale);
125978:   int32_t y = NSToIntRound(aY * scale);
125636: 
125636:   mBounds.x = x;
125636:   mBounds.y = y;
     1: 
     1:   if (mWnd) {
     1: #ifdef DEBUG
     1:     // complain if a window is moved offscreen (legal, but potentially worrisome)
     1:     if (mIsTopWidgetWindow) { // only a problem for top-level windows
     1:       // Make sure this window is actually on the screen before we move it
     1:       // XXX: Needs multiple monitor support
     1:       HDC dc = ::GetDC(mWnd);
     1:       if (dc) {
     1:         if (::GetDeviceCaps(dc, TECHNOLOGY) == DT_RASDISPLAY) {
     1:           RECT workArea;
     1:           ::SystemParametersInfo(SPI_GETWORKAREA, 0, &workArea, 0);
     1:           // no annoying assertions. just mention the issue.
125636:           if (x < 0 || x >= workArea.right || y < 0 || y >= workArea.bottom) {
 76714:             PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
 76714:                    ("window moved to offscreen position\n"));
 76714:           }
     1:         }
     1:       ::ReleaseDC(mWnd, dc);
     1:       }
     1:     }
     1: #endif
 26576:     ClearThemeRegion();
 58633: 
 58633:     UINT flags = SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOSIZE;
 58633:     // Workaround SetWindowPos bug with D3D9. If our window has a clip
 58633:     // region, some drivers or OSes may incorrectly copy into the clipped-out
 58633:     // area.
 58633:     if (mWindowType == eWindowType_plugin &&
105710:         (!mLayerManager || mLayerManager->GetBackendType() == LAYERS_D3D9) &&
 58633:         mClipRects &&
 68638:         (mClipRectCount != 1 || !mClipRects[0].IsEqualInterior(nsIntRect(0, 0, mBounds.width, mBounds.height)))) {
 58633:       flags |= SWP_NOCOPYBITS;
 58633:     }
125636:     VERIFY(::SetWindowPos(mWnd, NULL, x, y, 0, 0, flags));
 58633: 
 26576:     SetThemeRegion();
     1:   }
120177:   NotifyRollupGeometryChange();
     1:   return NS_OK;
     1: }
     1: 
     1: // Resize this component
125634: NS_METHOD nsWindow::Resize(double aWidth, double aHeight, bool aRepaint)
     1: {
125978:   // for top-level windows only, convert coordinates from global display pixels
125978:   // (the "parent" coordinate space) to the window's device pixel space
125978:   double scale =
125978:     (mWindowType <= eWindowType_popup) ? GetDefaultScale() : 1.0;
125978:   int32_t width = NSToIntRound(aWidth * scale);
125978:   int32_t height = NSToIntRound(aHeight * scale);
125636: 
125636:   NS_ASSERTION((width >= 0) , "Negative width passed to nsWindow::Resize");
125636:   NS_ASSERTION((height >= 0), "Negative height passed to nsWindow::Resize");
125636: 
125634:   ConstrainSize(&width, &height);
     1: 
 46192:   // Avoid unnecessary resizing calls
125634:   if (mBounds.width == width && mBounds.height == height) {
110896:     if (aRepaint) {
110896:       Invalidate();
110896:     }
 46192:     return NS_OK;
110896:   }
 46192: 
     1: #ifdef MOZ_XUL
 16601:   if (eTransparencyTransparent == mTransparencyMode)
125634:     ResizeTranslucentWindow(width, height);
     1: #endif
     1: 
     1:   // Set cached value for lightweight and printing
125634:   mBounds.width  = width;
125634:   mBounds.height = height;
     1: 
     1:   if (mWnd) {
     1:     UINT  flags = SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOMOVE;
 30750: 
     1:     if (!aRepaint) {
     1:       flags |= SWP_NOREDRAW;
     1:     }
     1: 
 26576:     ClearThemeRegion();
125634:     VERIFY(::SetWindowPos(mWnd, NULL, 0, 0, width, GetHeight(height), flags));
 26576:     SetThemeRegion();
     1:   }
     1: 
     1:   if (aRepaint)
 87336:     Invalidate();
     1: 
120177:   NotifyRollupGeometryChange();
     1:   return NS_OK;
     1: }
     1: 
     1: // Resize this component
125634: NS_METHOD nsWindow::Resize(double aX, double aY, double aWidth, double aHeight, bool aRepaint)
     1: {
125978:   // for top-level windows only, convert coordinates from global display pixels
125978:   // (the "parent" coordinate space) to the window's device pixel space
125978:   double scale =
125978:     (mWindowType <= eWindowType_popup) ? GetDefaultScale() : 1.0;
125636:   int32_t x = NSToIntRound(aX * scale);
125636:   int32_t y = NSToIntRound(aY * scale);
125636:   int32_t width = NSToIntRound(aWidth * scale);
125636:   int32_t height = NSToIntRound(aHeight * scale);
125636: 
125636:   NS_ASSERTION((width >= 0),  "Negative width passed to nsWindow::Resize");
125636:   NS_ASSERTION((height >= 0), "Negative height passed to nsWindow::Resize");
125636: 
125634:   ConstrainSize(&width, &height);
     1: 
 46192:   // Avoid unnecessary resizing calls
125634:   if (mBounds.x == x && mBounds.y == y &&
125634:       mBounds.width == width && mBounds.height == height) {
110896:     if (aRepaint) {
110896:       Invalidate();
110896:     }
 46192:     return NS_OK;
110896:   }
 46192: 
     1: #ifdef MOZ_XUL
 16601:   if (eTransparencyTransparent == mTransparencyMode)
125634:     ResizeTranslucentWindow(width, height);
     1: #endif
     1: 
     1:   // Set cached value for lightweight and printing
125634:   mBounds.x      = x;
125634:   mBounds.y      = y;
125634:   mBounds.width  = width;
125634:   mBounds.height = height;
     1: 
     1:   if (mWnd) {
     1:     UINT  flags = SWP_NOZORDER | SWP_NOACTIVATE;
     1:     if (!aRepaint) {
     1:       flags |= SWP_NOREDRAW;
     1:     }
 26576: 
 26576:     ClearThemeRegion();
125634:     VERIFY(::SetWindowPos(mWnd, NULL, x, y, width, GetHeight(height), flags));
 26576:     SetThemeRegion();
     1:   }
     1: 
     1:   if (aRepaint)
 87336:     Invalidate();
     1: 
120177:   NotifyRollupGeometryChange();
     1:   return NS_OK;
     1: }
     1: 
 33506: NS_IMETHODIMP
108991: nsWindow::BeginResizeDrag(nsGUIEvent* aEvent, int32_t aHorizontal, int32_t aVertical)
 33506: {
 33506:   NS_ENSURE_ARG_POINTER(aEvent);
 33506: 
 33506:   if (aEvent->eventStructType != NS_MOUSE_EVENT) {
 33506:     // you can only begin a resize drag with a mouse event
 33506:     return NS_ERROR_INVALID_ARG;
 33506:   }
 33506: 
 33506:   nsMouseEvent* mouseEvent = static_cast<nsMouseEvent*>(aEvent);
 33506:   if (mouseEvent->button != nsMouseEvent::eLeftButton) {
 33506:     // you can only begin a resize drag with the left mouse button
 33506:     return NS_ERROR_INVALID_ARG;
 33506:   }
 33506: 
 33506:   // work out what sizemode we're talking about
 33506:   WPARAM syscommand;
 33506:   if (aVertical < 0) {
 33506:     if (aHorizontal < 0) {
 33506:       syscommand = SC_SIZE | WMSZ_TOPLEFT;
 33506:     } else if (aHorizontal == 0) {
 33506:       syscommand = SC_SIZE | WMSZ_TOP;
 33506:     } else {
 33506:       syscommand = SC_SIZE | WMSZ_TOPRIGHT;
 33506:     }
 33506:   } else if (aVertical == 0) {
 33506:     if (aHorizontal < 0) {
 33506:       syscommand = SC_SIZE | WMSZ_LEFT;
 33506:     } else if (aHorizontal == 0) {
 33506:       return NS_ERROR_INVALID_ARG;
 33506:     } else {
 33506:       syscommand = SC_SIZE | WMSZ_RIGHT;
 33506:     }
 33506:   } else {
 33506:     if (aHorizontal < 0) {
 33506:       syscommand = SC_SIZE | WMSZ_BOTTOMLEFT;
 33506:     } else if (aHorizontal == 0) {
 33506:       syscommand = SC_SIZE | WMSZ_BOTTOM;
 33506:     } else {
 33506:       syscommand = SC_SIZE | WMSZ_BOTTOMRIGHT;
 33506:     }
 33506:   }
 33506: 
 33506:   // resizing doesn't work if the mouse is already captured
 79626:   CaptureMouse(false);
 33506: 
 33506:   // find the top-level window
 86569:   HWND toplevelWnd = WinUtils::GetTopLevelHWND(mWnd, true);
 33506: 
 33506:   // tell Windows to start the resize
 33506:   ::PostMessage(toplevelWnd, WM_SYSCOMMAND, syscommand,
 33506:                 POINTTOPOINTS(aEvent->refPoint));
 33506: 
 33506:   return NS_OK;
 33506: }
 68855: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: Window Z-order and state.
 29835:  *
 29835:  * nsIWidget::PlaceBehind, nsIWidget::SetSizeMode,
 29835:  * nsIWidget::ConstrainPosition
 29835:  *
 29835:  * Z-order, positioning, restore, minimize, and maximize.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: // Position the window behind the given window
 29835: NS_METHOD nsWindow::PlaceBehind(nsTopLevelWidgetZPlacement aPlacement,
 79445:                                 nsIWidget *aWidget, bool aActivate)
 29835: {
 29835:   HWND behind = HWND_TOP;
 29835:   if (aPlacement == eZPlacementBottom)
 29835:     behind = HWND_BOTTOM;
 29835:   else if (aPlacement == eZPlacementBelow && aWidget)
 29835:     behind = (HWND)aWidget->GetNativeData(NS_NATIVE_WINDOW);
 29835:   UINT flags = SWP_NOMOVE | SWP_NOREPOSITION | SWP_NOSIZE;
 29835:   if (!aActivate)
 29835:     flags |= SWP_NOACTIVATE;
 29835: 
 29835:   if (!CanTakeFocus() && behind == HWND_TOP)
 29835:   {
 29835:     // Can't place the window to top so place it behind the foreground window
 29835:     // (as long as it is not topmost)
 29835:     HWND wndAfter = ::GetForegroundWindow();
 29835:     if (!wndAfter)
 29835:       behind = HWND_BOTTOM;
 29835:     else if (!(GetWindowLongPtrW(wndAfter, GWL_EXSTYLE) & WS_EX_TOPMOST))
 29835:       behind = wndAfter;
 29835:     flags |= SWP_NOACTIVATE;
 29835:   }
 29835: 
 29835:   ::SetWindowPos(mWnd, behind, 0, 0, 0, 0, flags);
 29835:   return NS_OK;
 29835: }
 29835: 
 29835: // Maximize, minimize or restore the window.
108991: NS_IMETHODIMP nsWindow::SetSizeMode(int32_t aMode) {
 29835: 
 29835:   nsresult rv;
 29835: 
 29835:   // Let's not try and do anything if we're already in that state.
 29835:   // (This is needed to prevent problems when calling window.minimize(), which
 29835:   // calls us directly, and then the OS triggers another call to us.)
 29835:   if (aMode == mSizeMode)
 29835:     return NS_OK;
 29835: 
 29835:   // save the requested state
 97778:   mLastSizeMode = mSizeMode;
 29835:   rv = nsBaseWidget::SetSizeMode(aMode);
 29835:   if (NS_SUCCEEDED(rv) && mIsVisible) {
 29835:     int mode;
 29835: 
 29835:     switch (aMode) {
 30075:       case nsSizeMode_Fullscreen :
 47780:         mode = SW_SHOW;
 30075:         break;
 30075: 
 29835:       case nsSizeMode_Maximized :
 29835:         mode = SW_MAXIMIZE;
 29835:         break;
 34786: 
 29835:       case nsSizeMode_Minimized :
 34786:         // Using SW_SHOWMINIMIZED prevents the working set from being trimmed but
 34786:         // keeps the window active in the tray. So after the window is minimized,
 34786:         // windows will fire WM_WINDOWPOSCHANGED (OnWindowPosChanged) at which point
 34786:         // we will do some additional processing to get the active window set right.
 34786:         // If sTrimOnMinimize is set, we let windows handle minimization normally
 34786:         // using SW_MINIMIZE.
 29835:         mode = sTrimOnMinimize ? SW_MINIMIZE : SW_SHOWMINIMIZED;
 34786:         break;
 34786: 
 29835:       default :
 29835:         mode = SW_RESTORE;
 29835:     }
 74541: 
 74541:     WINDOWPLACEMENT pl;
 74541:     pl.length = sizeof(pl);
 74541:     ::GetWindowPlacement(mWnd, &pl);
 74541:     // Don't call ::ShowWindow if we're trying to "restore" a window that is
 74541:     // already in a normal state.  Prevents a bug where snapping to one side
 74541:     // of the screen and then minimizing would cause Windows to forget our
 74541:     // window's correct restored position/size.
 74541:     if( !(pl.showCmd == SW_SHOWNORMAL && mode == SW_RESTORE) ) {
 29835:       ::ShowWindow(mWnd, mode);
 74541:     }
108457:     // we activate here to ensure that the right child window is focused
 97778:     if (mode == SW_MAXIMIZE || mode == SW_SHOW)
108457:       DispatchFocusToTopLevelWindow(true);
 29835:   }
 29835:   return rv;
 29835: }
 29835: 
 29835: // Constrain a potential move to fit onscreen
 79445: NS_METHOD nsWindow::ConstrainPosition(bool aAllowSlop,
108991:                                       int32_t *aX, int32_t *aY)
 29835: {
 29835:   if (!mIsTopWidgetWindow) // only a problem for top-level windows
 29835:     return NS_OK;
 29835: 
 79445:   bool doConstrain = false; // whether we have enough info to do anything
 29835: 
 29835:   /* get our playing field. use the current screen, or failing that
 29835:     for any reason, use device caps for the default screen. */
 29835:   RECT screenRect;
 29835: 
 29835:   nsCOMPtr<nsIScreenManager> screenmgr = do_GetService(sScreenManagerContractID);
 29835:   if (screenmgr) {
 29835:     nsCOMPtr<nsIScreen> screen;
108991:     int32_t left, top, width, height;
 29835: 
 29835:     // zero size rects confuse the screen manager
 29835:     width = mBounds.width > 0 ? mBounds.width : 1;
 29835:     height = mBounds.height > 0 ? mBounds.height : 1;
 29835:     screenmgr->ScreenForRect(*aX, *aY, width, height,
 29835:                              getter_AddRefs(screen));
 29835:     if (screen) {
 47969:       if (mSizeMode != nsSizeMode_Fullscreen) {
 47969:         // For normalized windows, use the desktop work area.
 29835:         screen->GetAvailRect(&left, &top, &width, &height);
 47969:       } else {
 47969:         // For full screen windows, use the desktop.
 47969:         screen->GetRect(&left, &top, &width, &height);
 47969:       }
 29835:       screenRect.left = left;
 29835:       screenRect.right = left+width;
 29835:       screenRect.top = top;
 29835:       screenRect.bottom = top+height;
 79626:       doConstrain = true;
 29835:     }
 29835:   } else {
 29835:     if (mWnd) {
 29835:       HDC dc = ::GetDC(mWnd);
 29835:       if (dc) {
 29835:         if (::GetDeviceCaps(dc, TECHNOLOGY) == DT_RASDISPLAY) {
 47969:           if (mSizeMode != nsSizeMode_Fullscreen) {
 29835:             ::SystemParametersInfo(SPI_GETWORKAREA, 0, &screenRect, 0);
 47969:           } else {
 47969:             screenRect.left = screenRect.top = 0;
 47969:             screenRect.right = GetSystemMetrics(SM_CXFULLSCREEN);
 47969:             screenRect.bottom = GetSystemMetrics(SM_CYFULLSCREEN);
 47969:           }
 79626:           doConstrain = true;
 29835:         }
 29835:         ::ReleaseDC(mWnd, dc);
 29835:       }
 29835:     }
 29835:   }
 29835: 
 29835:   if (aAllowSlop) {
 29835:     if (*aX < screenRect.left - mBounds.width + kWindowPositionSlop)
 29835:       *aX = screenRect.left - mBounds.width + kWindowPositionSlop;
 29835:     else if (*aX >= screenRect.right - kWindowPositionSlop)
 29835:       *aX = screenRect.right - kWindowPositionSlop;
 29835: 
 29835:     if (*aY < screenRect.top - mBounds.height + kWindowPositionSlop)
 29835:       *aY = screenRect.top - mBounds.height + kWindowPositionSlop;
 29835:     else if (*aY >= screenRect.bottom - kWindowPositionSlop)
 29835:       *aY = screenRect.bottom - kWindowPositionSlop;
 29835: 
 29835:   } else {
 29835: 
 29835:     if (*aX < screenRect.left)
 29835:       *aX = screenRect.left;
 29835:     else if (*aX >= screenRect.right - mBounds.width)
 29835:       *aX = screenRect.right - mBounds.width;
 29835: 
 29835:     if (*aY < screenRect.top)
 29835:       *aY = screenRect.top;
 29835:     else if (*aY >= screenRect.bottom - mBounds.height)
 29835:       *aY = screenRect.bottom - mBounds.height;
 29835:   }
 29835: 
 29835:   return NS_OK;
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::Enable, nsIWidget::IsEnabled
 29835:  *
 29835:  * Enabling and disabling the widget.
 29835:  *
 29835:  **************************************************************/
 29835: 
     1: // Enable/disable this component
 79445: NS_METHOD nsWindow::Enable(bool bState)
     1: {
     1:   if (mWnd) {
     1:     ::EnableWindow(mWnd, bState);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
 29835: // Return the current enable state
106103: bool nsWindow::IsEnabled() const
106103: {
106103:   return !mWnd ||
106103:          (::IsWindowEnabled(mWnd) &&
106103:           ::IsWindowEnabled(::GetAncestor(mWnd, GA_ROOT)));
     1: }
     1: 
     1: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::SetFocus
 29835:  *
 29835:  * Give the focus to this widget.
 29835:  *
 29835:  **************************************************************/
 29835: 
 79445: NS_METHOD nsWindow::SetFocus(bool aRaise)
     1: {
     1:   if (mWnd) {
 34735: #ifdef WINSTATE_DEBUG_OUTPUT
 86569:     if (mWnd == WinUtils::GetTopLevelHWND(mWnd)) {
 76714:       PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
 76714:              ("*** SetFocus: [  top] raise=%d\n", aRaise));
 76714:     } else {
 76714:       PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
 76714:              ("*** SetFocus: [child] raise=%d\n", aRaise));
 76714:     }
 34735: #endif
     1:     // Uniconify, if necessary
 86569:     HWND toplevelWnd = WinUtils::GetTopLevelHWND(mWnd);
 33214:     if (aRaise && ::IsIconic(toplevelWnd)) {
     1:       ::ShowWindow(toplevelWnd, SW_RESTORE);
 33214:     }
     1:     ::SetFocus(mWnd);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: Bounds
 29835:  *
 46200:  * GetBounds, GetClientBounds, GetScreenBounds, GetClientOffset
 46200:  * SetDrawsInTitlebar, GetNonClientMargins, SetNonClientMargins
 29835:  *
 29835:  * Bound calculations.
 29835:  *
 29835:  **************************************************************/
 29835: 
 46192: // Return the window's full dimensions in screen coordinates.
 46192: // If the window has a parent, converts the origin to an offset
 46192: // of the parent's screen origin.
 23738: NS_METHOD nsWindow::GetBounds(nsIntRect &aRect)
     1: {
     1:   if (mWnd) {
     1:     RECT r;
     1:     VERIFY(::GetWindowRect(mWnd, &r));
     1: 
     1:     // assign size
     1:     aRect.width  = r.right - r.left;
     1:     aRect.height = r.bottom - r.top;
     1: 
 64624:     // popup window bounds' are in screen coordinates, not relative to parent
 64624:     // window
 64624:     if (mWindowType == eWindowType_popup) {
 64624:       aRect.x = r.left;
 64624:       aRect.y = r.top;
 64624:       return NS_OK;
 64624:     }
 64624: 
 46192:     // chrome on parent:
 46192:     //  ___      5,5   (chrome start)
 46192:     // |  ____   10,10 (client start)
 46192:     // | |  ____ 20,20 (child start)
 46192:     // | | |
 46192:     // 20,20 - 5,5 = 15,15 (??)
 46192:     // minus GetClientOffset:
 46192:     // 15,15 - 5,5 = 10,10
 46192:     //
 46192:     // no chrome on parent:
 46192:     //  ______   10,10 (win start)
 46192:     // |  ____   20,20 (child start)
 46192:     // | |
 46192:     // 20,20 - 10,10 = 10,10
 46192:     //
 46192:     // walking the chain:
 46192:     //  ___      5,5   (chrome start)
 46192:     // |  ___    10,10 (client start)
 46192:     // | |  ___  20,20 (child start)
 46192:     // | | |  __ 30,30 (child start)
 46192:     // | | | |
 46192:     // 30,30 - 20,20 = 10,10 (offset from second child to first)
 46192:     // 20,20 - 5,5 = 15,15 + 10,10 = 25,25 (??)
 46192:     // minus GetClientOffset:
 46192:     // 25,25 - 5,5 = 20,20 (offset from second child to parent client)
 46192: 
     1:     // convert coordinates if parent exists
     1:     HWND parent = ::GetParent(mWnd);
     1:     if (parent) {
     1:       RECT pr;
     1:       VERIFY(::GetWindowRect(parent, &pr));
     1:       r.left -= pr.left;
     1:       r.top  -= pr.top;
 46192:       // adjust for chrome
 46192:       nsWindow* pWidget = static_cast<nsWindow*>(GetParent());
 46192:       if (pWidget && pWidget->IsTopLevelWidget()) {
 48256:         nsIntPoint clientOffset = pWidget->GetClientOffset();
 46192:         r.left -= clientOffset.x;
 46192:         r.top  -= clientOffset.y;
 46192:       }
     1:     }
     1:     aRect.x = r.left;
     1:     aRect.y = r.top;
     1:   } else {
     1:     aRect = mBounds;
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: // Get this component dimension
 23738: NS_METHOD nsWindow::GetClientBounds(nsIntRect &aRect)
     1: {
     1:   if (mWnd) {
     1:     RECT r;
     1:     VERIFY(::GetClientRect(mWnd, &r));
     1: 
 83107:     nsIntRect bounds;
 83107:     GetBounds(bounds);
 83107:     aRect.MoveTo(bounds.TopLeft() + GetClientOffset());
     1:     aRect.width  = r.right - r.left;
     1:     aRect.height = r.bottom - r.top;
     1: 
     1:   } else {
     1:     aRect.SetRect(0,0,0,0);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
 29835: // Like GetBounds, but don't offset by the parent
 23738: NS_METHOD nsWindow::GetScreenBounds(nsIntRect &aRect)
     1: {
     1:   if (mWnd) {
     1:     RECT r;
     1:     VERIFY(::GetWindowRect(mWnd, &r));
     1: 
     1:     aRect.width  = r.right - r.left;
     1:     aRect.height = r.bottom - r.top;
     1:     aRect.x = r.left;
     1:     aRect.y = r.top;
     1:   } else
     1:     aRect = mBounds;
     1: 
     1:   return NS_OK;
     1: }
     1: 
 46192: // return the x,y offset of the client area from the origin
 46192: // of the window. If the window is borderless returns (0,0).
 48256: nsIntPoint nsWindow::GetClientOffset()
 46192: {
 46192:   if (!mWnd) {
 48256:     return nsIntPoint(0, 0);
 46192:   }
 46192: 
 46192:   RECT r1;
 46192:   GetWindowRect(mWnd, &r1);
 46192:   nsIntPoint pt = WidgetToScreenOffset();
 48256:   return nsIntPoint(pt.x - r1.left, pt.y - r1.top);
 46192: }
 46192: 
 46200: void
 79445: nsWindow::SetDrawsInTitlebar(bool aState)
 46200: {
 79626:   nsWindow * window = GetTopLevelWindow(true);
 46200:   if (window && window != this) {
 46200:     return window->SetDrawsInTitlebar(aState);
 46200:   }
 46200: 
 46200:   if (aState) {
 46200:      // left, top, right, bottom for nsIntMargin
 46200:     nsIntMargin margins(-1, 0, -1, -1);
 46200:     SetNonClientMargins(margins);
 46200:   }
 46200:   else {
 46200:     nsIntMargin margins(-1, -1, -1, -1);
 46200:     SetNonClientMargins(margins);
 46200:   }
 46200: }
 46200: 
 46200: NS_IMETHODIMP
 46200: nsWindow::GetNonClientMargins(nsIntMargin &margins)
 46200: {
 79626:   nsWindow * window = GetTopLevelWindow(true);
 46200:   if (window && window != this) {
 46200:     return window->GetNonClientMargins(margins);
 46200:   }
 46200: 
 46200:   if (mCustomNonClient) {
 46200:     margins = mNonClientMargins;
 46200:     return NS_OK;
 46200:   }
 46200: 
 46332:   margins.top = GetSystemMetrics(SM_CYCAPTION);
 46332:   margins.bottom = GetSystemMetrics(SM_CYFRAME);
 46332:   margins.top += margins.bottom;
101616:   margins.left = margins.right = GetSystemMetrics(SM_CXFRAME);
 46200: 
 46200:   return NS_OK;
 46200: }
 46200: 
 47788: void
 47788: nsWindow::ResetLayout()
 47788: {
 47788:   // This will trigger a frame changed event, triggering
 47788:   // nc calc size and a sizemode gecko event.
 47788:   SetWindowPos(mWnd, 0, 0, 0, 0, 0,
 47788:                SWP_FRAMECHANGED|SWP_NOACTIVATE|SWP_NOMOVE|
 47788:                SWP_NOOWNERZORDER|SWP_NOSIZE|SWP_NOZORDER);
 47788: 
 47788:   // If hidden, just send the frame changed event for now.
 47788:   if (!mIsVisible)
 47788:     return;
 47788: 
 47788:   // Send a gecko size event to trigger reflow.
 47788:   RECT clientRc = {0};
 47788:   GetClientRect(mWnd, &clientRc);
120800:   nsIntRect evRect(WinUtils::ToIntRect(clientRc));
 47788:   OnResize(evRect);
 47788: 
 47788:   // Invalidate and update
 87336:   Invalidate();
 47788: }
 47788: 
 57388: // Internally track the caption status via a window property. Required
 57388: // due to our internal handling of WM_NCACTIVATE when custom client
 57388: // margins are set.
 57388: static const PRUnichar kManageWindowInfoProperty[] = L"ManageWindowInfoProperty";
 57388: typedef BOOL (WINAPI *GetWindowInfoPtr)(HWND hwnd, PWINDOWINFO pwi);
 57388: static GetWindowInfoPtr sGetWindowInfoPtrStub = NULL;
 57388: 
 57388: BOOL WINAPI
 57388: GetWindowInfoHook(HWND hWnd, PWINDOWINFO pwi)
 57388: {
 57388:   if (!sGetWindowInfoPtrStub) {
 57388:     NS_ASSERTION(FALSE, "Something is horribly wrong in GetWindowInfoHook!");
 57388:     return FALSE;
 57388:   }
 57388:   int windowStatus = 
 61525:     reinterpret_cast<LONG_PTR>(GetPropW(hWnd, kManageWindowInfoProperty));
 57388:   // No property set, return the default data.
 57388:   if (!windowStatus)
 57388:     return sGetWindowInfoPtrStub(hWnd, pwi);
 57388:   // Call GetWindowInfo and update dwWindowStatus with our
 57388:   // internally tracked value. 
 57388:   BOOL result = sGetWindowInfoPtrStub(hWnd, pwi);
 57388:   if (result && pwi)
 57388:     pwi->dwWindowStatus = (windowStatus == 1 ? 0 : WS_ACTIVECAPTION);
 57388:   return result;
 57388: }
 57388: 
 57388: void
 79445: nsWindow::UpdateGetWindowInfoCaptionStatus(bool aActiveCaption)
 57388: {
 57388:   if (!mWnd)
 57388:     return;
 57388: 
 57388:   if (!sGetWindowInfoPtrStub) {
 57388:     sUser32Intercept.Init("user32.dll");
 69198:     if (!sUser32Intercept.AddHook("GetWindowInfo", reinterpret_cast<intptr_t>(GetWindowInfoHook),
 57388:                                   (void**) &sGetWindowInfoPtrStub))
 57388:       return;
 57388:   }
 57388:   // Update our internally tracked caption status
 57388:   SetPropW(mWnd, kManageWindowInfoProperty, 
 57388:     reinterpret_cast<HANDLE>(static_cast<int>(aActiveCaption) + 1));
 57388: }
 57388: 
108835: /**
108835:  * Called when the window layout changes: full screen mode transitions,
108835:  * theme changes, and composition changes. Calculates the new non-client
108835:  * margins and fires off a frame changed event, which triggers an nc calc
108835:  * size windows event, kicking the changes in.
108835:  *
108835:  * The offsets calculated here are based on the value of `mNonClientMargins`
108835:  * which is specified in the "chromemargins" attribute of the window.  For
108835:  * each margin, the value specified has the following meaning:
108835:  *    -1 - leave the default frame in place
108835:  *     0 - remove the frame
108835:  *    >0 - frame size equals min(0, (default frame size - margin value))
108835:  *
108835:  * This function calculates and populates `mNonClientOffset`.
108835:  * In our processing of `WM_NCCALCSIZE`, the frame size will be calculated
108835:  * as (default frame size - offset).  For example, if the left frame should
108835:  * be 1 pixel narrower than the default frame size, `mNonClientOffset.left`
108835:  * will equal 1.
108835:  *
108835:  * For maximized, fullscreen, and minimized windows, the values stored in
108835:  * `mNonClientMargins` are ignored, and special processing takes place.
108835:  *
108835:  * For non-glass windows, we only allow frames to be their default size
108835:  * or removed entirely.
108835:  */
 79445: bool
108991: nsWindow::UpdateNonClientMargins(int32_t aSizeMode, bool aReflowWindow)
 46200: {
 46200:   if (!mCustomNonClient)
 79626:     return false;
 46200: 
108835:   if (aSizeMode == -1) {
 46332:     aSizeMode = mSizeMode;
108835:   }
108835: 
108835:   bool hasCaption = (mBorderStyle
108835:                     & (eBorderStyle_all
108835:                      | eBorderStyle_title
108835:                      | eBorderStyle_menu
108835:                      | eBorderStyle_default));
108835: 
108835:   // mCaptionHeight is the default size of the NC area at
108835:   // the top of the window. If the window has a caption,
108835:   // the size is calculated as the sum of:
108835:   //      SM_CYFRAME        - The thickness of the sizing border
108835:   //                          around a resizable window
108835:   //      SM_CXPADDEDBORDER - The amount of border padding
108835:   //                          for captioned windows
108835:   //      SM_CYCAPTION      - The height of the caption area
108835:   //
108835:   // If the window does not have a caption, mCaptionHeight will be equal to
108835:   // `GetSystemMetrics(SM_CYFRAME)`
108835:   mCaptionHeight = GetSystemMetrics(SM_CYFRAME)
108835:                  + (hasCaption ? GetSystemMetrics(SM_CYCAPTION)
108835:                                  + GetSystemMetrics(SM_CXPADDEDBORDER)
108835:                                : 0);
108835: 
108835:   // mHorResizeMargin is the size of the default NC areas on the
108835:   // left and right sides of our window.  It is calculated as
108835:   // the sum of:
108835:   //      SM_CXFRAME        - The thickness of the sizing border
108835:   //      SM_CXPADDEDBORDER - The amount of border padding
108835:   //                          for captioned windows
108835:   //
108835:   // If the window does not have a caption, mHorResizeMargin will be equal to
108835:   // `GetSystemMetrics(SM_CXFRAME)`
108835:   mHorResizeMargin = GetSystemMetrics(SM_CXFRAME)
108835:                    + (hasCaption ? GetSystemMetrics(SM_CXPADDEDBORDER) : 0);
108835: 
108835:   // mVertResizeMargin is the size of the default NC area at the
108835:   // bottom of the window. It is calculated as the sum of:
108835:   //      SM_CYFRAME        - The thickness of the sizing border
108835:   //      SM_CXPADDEDBORDER - The amount of border padding
108835:   //                          for captioned windows.
108835:   //
108835:   // If the window does not have a caption, mVertResizeMargin will be equal to
108835:   // `GetSystemMetrics(SM_CYFRAME)`
108835:   mVertResizeMargin = GetSystemMetrics(SM_CYFRAME)
108835:                     + (hasCaption ? GetSystemMetrics(SM_CXPADDEDBORDER) : 0);
108835: 
108835:   if (aSizeMode == nsSizeMode_Minimized) {
108835:     // Use default frame size for minimized windows
108835:     mNonClientOffset.top = 0;
108835:     mNonClientOffset.left = 0;
108835:     mNonClientOffset.right = 0;
108835:     mNonClientOffset.bottom = 0;
108835:   } else if (aSizeMode == nsSizeMode_Fullscreen) {
108835:     // Remove the default frame from the top of our fullscreen window.  This
108835:     // makes the whole caption part of our client area, allowing us to draw
108835:     // in the whole caption area.  Additionally remove the default frame from
108835:     // the left, right, and bottom.
 46200:     mNonClientOffset.top = mCaptionHeight;
108835:     mNonClientOffset.bottom = mVertResizeMargin;
108835:     mNonClientOffset.left = mHorResizeMargin;
108835:     mNonClientOffset.right = mHorResizeMargin;
108835:   } else if (aSizeMode == nsSizeMode_Maximized) {
108835:     // Remove the default frame from the top of our maximized window.  This
108835:     // makes the whole caption part of our client area, allowing us to draw
108835:     // in the whole caption area.  Use default frame size on left, right, and
108835:     // bottom. The reason this works is that, for maximized windows,
108835:     // Windows positions them so that their frames fall off the screen.
108835:     // This gives the illusion of windows having no frames when they are
108835:     // maximized.  If we try to mess with the frame sizes by setting these
108835:     // offsets to positive values, our client area will fall off the screen.
108835:     mNonClientOffset.top = mCaptionHeight;
108835:     mNonClientOffset.bottom = 0;
108835:     mNonClientOffset.left = 0;
108835:     mNonClientOffset.right = 0;
108835: 
108835:     APPBARDATA appBarData;
108835:     appBarData.cbSize = sizeof(appBarData);
108835:     UINT taskbarState = SHAppBarMessage(ABM_GETSTATE, &appBarData);
108835:     if (ABS_AUTOHIDE & taskbarState) {
108835:       UINT edge = -1;
108835:       appBarData.hWnd = FindWindow(L"Shell_TrayWnd", NULL);
108835:       if (appBarData.hWnd) {
108835:         HMONITOR taskbarMonitor = ::MonitorFromWindow(appBarData.hWnd,
108835:                                                       MONITOR_DEFAULTTOPRIMARY);
108835:         HMONITOR windowMonitor = ::MonitorFromWindow(mWnd,
108835:                                                      MONITOR_DEFAULTTONEAREST);
108835:         if (taskbarMonitor == windowMonitor) {
108835:           SHAppBarMessage(ABM_GETTASKBARPOS, &appBarData);
108835:           edge = appBarData.uEdge;
108835:         }
108835:       }
108835: 
108835:       if (ABE_LEFT == edge) {
108835:         mNonClientOffset.left -= 1;
108835:       } else if (ABE_RIGHT == edge) {
108835:         mNonClientOffset.right -= 1;
108835:       } else if (ABE_BOTTOM == edge || ABE_TOP == edge) {
108835:         mNonClientOffset.bottom -= 1;
108835:       }
108835:     }
108835:   } else {
108835:     bool glass = nsUXThemeData::CheckForCompositor();
108835: 
108835:     // We're dealing with a "normal" window (not maximized, minimized, or
108835:     // fullscreen), so process `mNonClientMargins` and set `mNonClientOffset`
108835:     // accordingly.
108835:     //
108835:     // Setting `mNonClientOffset` to 0 has the effect of leaving the default
108835:     // frame intact.  Setting it to a value greater than 0 reduces the frame
108835:     // size by that amount.
108835: 
108835:     if (mNonClientMargins.top > 0 && glass) {
 87238:       mNonClientOffset.top = NS_MIN(mCaptionHeight, mNonClientMargins.top);
108835:     } else if (mNonClientMargins.top == 0) {
108835:       mNonClientOffset.top = mCaptionHeight;
108835:     } else {
108835:       mNonClientOffset.top = 0;
108835:     }
108835: 
108835:     if (mNonClientMargins.bottom > 0 && glass) {
108835:       mNonClientOffset.bottom = NS_MIN(mVertResizeMargin, mNonClientMargins.bottom);
108835:     } else if (mNonClientMargins.bottom == 0) {
108835:       mNonClientOffset.bottom = mVertResizeMargin;
108835:     } else {
108835:       mNonClientOffset.bottom = 0;
108835:     }
108835: 
108835:     if (mNonClientMargins.left > 0 && glass) {
108835:       mNonClientOffset.left = NS_MIN(mHorResizeMargin, mNonClientMargins.left);
108835:     } else if (mNonClientMargins.left == 0) {
 46332:       mNonClientOffset.left = mHorResizeMargin;
108835:     } else {
108835:       mNonClientOffset.left = 0;
108835:     }
108835: 
108835:     if (mNonClientMargins.right > 0 && glass) {
108835:       mNonClientOffset.right = NS_MIN(mHorResizeMargin, mNonClientMargins.right);
108835:     } else if (mNonClientMargins.right == 0) {
 46332:       mNonClientOffset.right = mHorResizeMargin;
108835:     } else {
 87238:       mNonClientOffset.right = 0;
 87238:     }
 48424:   }
 46200: 
 47788:   if (aReflowWindow) {
 47788:     // Force a reflow of content based on the new client
 47788:     // dimensions.
 47788:     ResetLayout();
 46332:   }
 46200: 
 79626:   return true;
 46200: }
 46200: 
 46200: NS_IMETHODIMP
 46200: nsWindow::SetNonClientMargins(nsIntMargin &margins)
 46200: {
 46200:   if (!mIsTopWidgetWindow ||
 46200:       mBorderStyle & eBorderStyle_none ||
 46200:       mHideChrome)
 46200:     return NS_ERROR_INVALID_ARG;
 46200: 
 46200:   // Request for a reset
 46200:   if (margins.top == -1 && margins.left == -1 &&
 46200:       margins.right == -1 && margins.bottom == -1) {
 79626:     mCustomNonClient = false;
 46200:     mNonClientMargins = margins;
 57394:     RemovePropW(mWnd, kManageWindowInfoProperty);
 47788:     // Force a reflow of content based on the new client
 47788:     // dimensions.
 47788:     ResetLayout();
 46200:     return NS_OK;
 46200:   }
 46200: 
 46200:   if (margins.top < -1 || margins.bottom < -1 ||
 46200:       margins.left < -1 || margins.right < -1)
 46200:     return NS_ERROR_INVALID_ARG;
 46200: 
 46200:   mNonClientMargins = margins;
 79626:   mCustomNonClient = true;
 46200:   if (!UpdateNonClientMargins()) {
 46200:     NS_WARNING("UpdateNonClientMargins failed!");
111328:     return NS_OK;
 46200:   }
 46200: 
 46200:   return NS_OK;
 46200: }
 46200: 
 49251: void
 49251: nsWindow::InvalidateNonClientRegion()
 49251: {
 49251:   // +-+-----------------------+-+
 49251:   // | | app non-client chrome | |
 49251:   // | +-----------------------+ |
 49251:   // | |   app client chrome   | | }
 49251:   // | +-----------------------+ | }
 49251:   // | |      app content      | | } area we don't want to invalidate
 49251:   // | +-----------------------+ | }
 49251:   // | |   app client chrome   | | }
 49251:   // | +-----------------------+ | 
 49251:   // +---------------------------+ <
 49251:   //  ^                         ^    windows non-client chrome
 49251:   // client area = app *
 49251:   RECT rect;
 49251:   GetWindowRect(mWnd, &rect);
 49251:   MapWindowPoints(NULL, mWnd, (LPPOINT)&rect, 2);
 49251:   HRGN winRgn = CreateRectRgnIndirect(&rect);
 49251: 
 49251:   // Subtract app client chrome and app content leaving
 49251:   // windows non-client chrome and app non-client chrome
 49251:   // in winRgn.
 49251:   GetWindowRect(mWnd, &rect);
 49251:   rect.top += mCaptionHeight;
 49251:   rect.right -= mHorResizeMargin;
 49251:   rect.bottom -= mHorResizeMargin;
 49251:   rect.left += mVertResizeMargin;
 49251:   MapWindowPoints(NULL, mWnd, (LPPOINT)&rect, 2);
 49251:   HRGN clientRgn = CreateRectRgnIndirect(&rect);
 49251:   CombineRgn(winRgn, winRgn, clientRgn, RGN_DIFF);
 49251:   DeleteObject(clientRgn);
 49251: 
 49251:   // triggers ncpaint and paint events for the two areas
 49251:   RedrawWindow(mWnd, NULL, winRgn, RDW_FRAME|RDW_INVALIDATE);
 49251:   DeleteObject(winRgn);
 49251: }
 49251: 
 49251: HRGN
 49251: nsWindow::ExcludeNonClientFromPaintRegion(HRGN aRegion)
 49251: {
 49251:   RECT rect;
 49251:   HRGN rgn = NULL;
 49251:   if (aRegion == (HRGN)1) { // undocumented value indicating a full refresh
 49251:     GetWindowRect(mWnd, &rect);
 49251:     rgn = CreateRectRgnIndirect(&rect);
 49251:   } else {
 49251:     rgn = aRegion;
 49251:   }
 49251:   GetClientRect(mWnd, &rect);
 49251:   MapWindowPoints(mWnd, NULL, (LPPOINT)&rect, 2);
 49251:   HRGN nonClientRgn = CreateRectRgnIndirect(&rect);
 49251:   CombineRgn(rgn, rgn, nonClientRgn, RGN_DIFF);
 49251:   DeleteObject(nonClientRgn);
 49251:   return rgn;
 49251: }
 49251: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::SetBackgroundColor
 29835:  *
 29835:  * Sets the window background paint color.
 29835:  *
 29835:  **************************************************************/
 29835: 
     1: NS_METHOD nsWindow::SetBackgroundColor(const nscolor &aColor)
     1: {
     1:   nsBaseWidget::SetBackgroundColor(aColor);
     1: 
     1:   if (mBrush)
     1:     ::DeleteObject(mBrush);
     1: 
     1:   mBrush = ::CreateSolidBrush(NSRGB_2_COLOREF(mBackground));
     1:   if (mWnd != NULL) {
 25349:     ::SetClassLongPtrW(mWnd, GCLP_HBRBACKGROUND, (LONG_PTR)mBrush);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::SetCursor
 29835:  *
 29835:  * SetCursor and related utilities for manging cursor state.
 29835:  *
 29835:  **************************************************************/
 29835: 
     1: // Set this component cursor
     1: NS_METHOD nsWindow::SetCursor(nsCursor aCursor)
     1: {
     1:   // Only change cursor if it's changing
     1: 
     1:   //XXX mCursor isn't always right.  Scrollbars and others change it, too.
     1:   //XXX If we want this optimization we need a better way to do it.
     1:   //if (aCursor != mCursor) {
     1:   HCURSOR newCursor = NULL;
     1: 
     1:   switch (aCursor) {
     1:     case eCursor_select:
     1:       newCursor = ::LoadCursor(NULL, IDC_IBEAM);
     1:       break;
     1: 
     1:     case eCursor_wait:
     1:       newCursor = ::LoadCursor(NULL, IDC_WAIT);
     1:       break;
     1: 
     1:     case eCursor_hyperlink:
     1:     {
     1:       newCursor = ::LoadCursor(NULL, IDC_HAND);
     1:       break;
     1:     }
     1: 
     1:     case eCursor_standard:
     1:       newCursor = ::LoadCursor(NULL, IDC_ARROW);
     1:       break;
     1: 
     1:     case eCursor_n_resize:
     1:     case eCursor_s_resize:
     1:       newCursor = ::LoadCursor(NULL, IDC_SIZENS);
     1:       break;
     1: 
     1:     case eCursor_w_resize:
     1:     case eCursor_e_resize:
     1:       newCursor = ::LoadCursor(NULL, IDC_SIZEWE);
     1:       break;
     1: 
     1:     case eCursor_nw_resize:
     1:     case eCursor_se_resize:
     1:       newCursor = ::LoadCursor(NULL, IDC_SIZENWSE);
     1:       break;
     1: 
     1:     case eCursor_ne_resize:
     1:     case eCursor_sw_resize:
     1:       newCursor = ::LoadCursor(NULL, IDC_SIZENESW);
     1:       break;
     1: 
     1:     case eCursor_crosshair:
     1:       newCursor = ::LoadCursor(NULL, IDC_CROSS);
     1:       break;
     1: 
     1:     case eCursor_move:
     1:       newCursor = ::LoadCursor(NULL, IDC_SIZEALL);
     1:       break;
     1: 
     1:     case eCursor_help:
     1:       newCursor = ::LoadCursor(NULL, IDC_HELP);
     1:       break;
     1: 
     1:     case eCursor_copy: // CSS3
     1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_COPY));
     1:       break;
     1: 
     1:     case eCursor_alias:
     1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_ALIAS));
     1:       break;
     1: 
     1:     case eCursor_cell:
     1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_CELL));
     1:       break;
     1: 
     1:     case eCursor_grab:
     1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_GRAB));
     1:       break;
     1: 
     1:     case eCursor_grabbing:
     1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_GRABBING));
     1:       break;
     1: 
     1:     case eCursor_spinning:
     1:       newCursor = ::LoadCursor(NULL, IDC_APPSTARTING);
     1:       break;
     1: 
     1:     case eCursor_context_menu:
     1:       // XXX this CSS3 cursor needs to be implemented
     1:       break;
     1: 
     1:     case eCursor_zoom_in:
     1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_ZOOMIN));
     1:       break;
     1: 
     1:     case eCursor_zoom_out:
     1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_ZOOMOUT));
     1:       break;
     1: 
     1:     case eCursor_not_allowed:
     1:     case eCursor_no_drop:
     1:       newCursor = ::LoadCursor(NULL, IDC_NO);
     1:       break;
     1: 
     1:     case eCursor_col_resize:
     1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_COLRESIZE));
     1:       break;
     1: 
     1:     case eCursor_row_resize:
     1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_ROWRESIZE));
     1:       break;
     1: 
     1:     case eCursor_vertical_text:
     1:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_VERTICALTEXT));
     1:       break;
     1: 
     1:     case eCursor_all_scroll:
     1:       // XXX not 100% appropriate perhaps
     1:       newCursor = ::LoadCursor(NULL, IDC_SIZEALL);
     1:       break;
     1: 
     1:     case eCursor_nesw_resize:
     1:       newCursor = ::LoadCursor(NULL, IDC_SIZENESW);
     1:       break;
     1: 
     1:     case eCursor_nwse_resize:
     1:       newCursor = ::LoadCursor(NULL, IDC_SIZENWSE);
     1:       break;
     1: 
     1:     case eCursor_ns_resize:
     1:       newCursor = ::LoadCursor(NULL, IDC_SIZENS);
     1:       break;
     1: 
     1:     case eCursor_ew_resize:
     1:       newCursor = ::LoadCursor(NULL, IDC_SIZEWE);
     1:       break;
     1: 
 10405:     case eCursor_none:
 10405:       newCursor = ::LoadCursor(nsToolkit::mDllInstance, MAKEINTRESOURCE(IDC_NONE));
 10405:       break;
 10405: 
     1:     default:
     1:       NS_ERROR("Invalid cursor type");
     1:       break;
     1:   }
     1: 
     1:   if (NULL != newCursor) {
     1:     mCursor = aCursor;
     1:     HCURSOR oldCursor = ::SetCursor(newCursor);
     1:     
 29835:     if (sHCursor == oldCursor) {
 29835:       NS_IF_RELEASE(sCursorImgContainer);
 29835:       if (sHCursor != NULL)
 29835:         ::DestroyIcon(sHCursor);
 29835:       sHCursor = NULL;
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 29835: // Setting the actual cursor
     1: NS_IMETHODIMP nsWindow::SetCursor(imgIContainer* aCursor,
108991:                                   uint32_t aHotspotX, uint32_t aHotspotY)
     1: {
 29835:   if (sCursorImgContainer == aCursor && sHCursor) {
 29835:     ::SetCursor(sHCursor);
     1:     return NS_OK;
     1:   }
     1: 
108991:   int32_t width;
108991:   int32_t height;
 30804: 
 30804:   nsresult rv;
 30804:   rv = aCursor->GetWidth(&width);
 30804:   NS_ENSURE_SUCCESS(rv, rv);
 30804:   rv = aCursor->GetHeight(&height);
 30804:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
  6354:   // Reject cursors greater than 128 pixels in either direction, to prevent
     1:   // spoofing.
     1:   // XXX ideally we should rescale. Also, we could modify the API to
     1:   // allow trusted content to set larger cursors.
     1:   if (width > 128 || height > 128)
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
 30804:   HCURSOR cursor;
 79420:   // No scaling
 79420:   gfxIntSize size(0, 0);
 79626:   rv = nsWindowGfx::CreateIcon(aCursor, true, aHotspotX, aHotspotY, size, &cursor);
 30804:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   mCursor = nsCursor(-1);
     1:   ::SetCursor(cursor);
     1: 
 29835:   NS_IF_RELEASE(sCursorImgContainer);
 29835:   sCursorImgContainer = aCursor;
 29835:   NS_ADDREF(sCursorImgContainer);
 29835: 
 29835:   if (sHCursor != NULL)
 29835:     ::DestroyIcon(sHCursor);
 29835:   sHCursor = cursor;
     1: 
     1:   return NS_OK;
     1: }
     1: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::Get/SetTransparencyMode
 29835:  *
 29835:  * Manage the transparency mode of the top-level window
 29835:  * containing this widget.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: #ifdef MOZ_XUL
 29835: nsTransparencyMode nsWindow::GetTransparencyMode()
 29835: {
 79626:   return GetTopLevelWindow(true)->GetWindowTranslucencyInner();
 29835: }
 29835: 
 29835: void nsWindow::SetTransparencyMode(nsTransparencyMode aMode)
 29835: {
 79626:   GetTopLevelWindow(true)->SetWindowTranslucencyInner(aMode);
 29835: }
 39718: 
 61413: static const nsIntRegion
 61413: RegionFromArray(const nsTArray<nsIntRect>& aRects)
 61413: {
 61413:   nsIntRegion region;
108991:   for (uint32_t i = 0; i < aRects.Length(); ++i) {
 61413:     region.Or(region, aRects[i]);
 61413:   }
 61413:   return region;
 61413: }
 61413: 
 69806: void nsWindow::UpdateOpaqueRegion(const nsIntRegion &aOpaqueRegion)
 61413: {
 61413:   if (!HasGlass() || GetParent())
 39718:     return;
 39718: 
 46200:   // If there is no opaque region or hidechrome=true, set margins
 61413:   // to support a full sheet of glass. Comments in MSDN indicate
 61413:   // all values must be set to -1 to get a full sheet of glass.
 61413:   MARGINS margins = { -1, -1, -1, -1 };
 69806:   if (!aOpaqueRegion.IsEmpty()) {
 59822:     nsIntRect pluginBounds;
 59822:     for (nsIWidget* child = GetFirstChild(); child; child = child->GetNextSibling()) {
 59822:       nsWindowType type;
 59822:       child->GetWindowType(type);
 59822:       if (type == eWindowType_plugin) {
 61413:         // Collect the bounds of all plugins for GetLargestRectangle.
 59822:         nsIntRect childBounds;
 59822:         child->GetBounds(childBounds);
 59822:         pluginBounds.UnionRect(pluginBounds, childBounds);
 59822:       }
 59822:     }
 59822: 
 69806:     nsIntRect clientBounds;
 69806:     GetClientBounds(clientBounds);
 69806: 
 59822:     // Find the largest rectangle and use that to calculate the inset. Our top
 59822:     // priority is to include the bounds of all plugins.
 69806:     nsIntRect largest = aOpaqueRegion.GetLargestRectangle(pluginBounds);
 39718:     margins.cxLeftWidth = largest.x;
 39718:     margins.cxRightWidth = clientBounds.width - largest.XMost();
 39718:     margins.cyBottomHeight = clientBounds.height - largest.YMost();
 57439:     if (mCustomNonClient) {
 51610:       // The minimum glass height must be the caption buttons height,
 51610:       // otherwise the buttons are drawn incorrectly.
108991:       largest.y = NS_MAX<uint32_t>(largest.y,
 56099:                          nsUXThemeData::sCommandButtons[CMDBUTTONIDX_BUTTONBOX].cy);
 39718:     }
 57439:     margins.cyTopHeight = largest.y;
 57439:   }
 46200: 
 46200:   // Only update glass area if there are changes
 39718:   if (memcmp(&mGlassMargins, &margins, sizeof mGlassMargins)) {
 39718:     mGlassMargins = margins;
 39718:     UpdateGlass();
 39718:   }
 39718: }
 39718: 
 46200: void nsWindow::UpdateGlass()
 46200: {
 50770:   MARGINS margins = mGlassMargins;
 46200: 
 46200:   // DWMNCRP_USEWINDOWSTYLE - The non-client rendering area is
 46200:   //                          rendered based on the window style.
 46200:   // DWMNCRP_ENABLED        - The non-client area rendering is
 46200:   //                          enabled; the window style is ignored.
 39718:   DWMNCRENDERINGPOLICY policy = DWMNCRP_USEWINDOWSTYLE;
 50770:   switch (mTransparencyMode) {
 50770:   case eTransparencyBorderlessGlass:
 61976:     // Only adjust if there is some opaque rectangle
 51144:     if (margins.cxLeftWidth >= 0) {
 61976:       margins.cxLeftWidth += kGlassMarginAdjustment;
 61976:       margins.cyTopHeight += kGlassMarginAdjustment;
 61976:       margins.cxRightWidth += kGlassMarginAdjustment;
 61976:       margins.cyBottomHeight += kGlassMarginAdjustment;
 50770:     }
 50770:     // Fall through
 50770:   case eTransparencyGlass:
 39718:     policy = DWMNCRP_ENABLED;
 50770:     break;
 39718:   }
 46200: 
 61412:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
 61412:          ("glass margins: left:%d top:%d right:%d bottom:%d\n",
 61412:           margins.cxLeftWidth, margins.cyTopHeight,
 61412:           margins.cxRightWidth, margins.cyBottomHeight));
 61412: 
 46200:   // Extends the window frame behind the client area
 39718:   if(nsUXThemeData::CheckForCompositor()) {
 61413:     nsUXThemeData::dwmExtendFrameIntoClientAreaPtr(mWnd, &margins);
 61413:     nsUXThemeData::dwmSetWindowAttributePtr(mWnd, DWMWA_NCRENDERING_POLICY, &policy, sizeof policy);
 39718:   }
 39718: }
 29835: #endif
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::HideWindowChrome
 29835:  *
 29835:  * Show or hide window chrome.
 29835:  *
 29835:  **************************************************************/
 29835: 
 79445: NS_IMETHODIMP nsWindow::HideWindowChrome(bool aShouldHide)
     1: {
 86569:   HWND hwnd = WinUtils::GetTopLevelHWND(mWnd, true);
 86569:   if (!WinUtils::GetNSWindowPtr(hwnd))
     1:   {
     1:     NS_WARNING("Trying to hide window decorations in an embedded context");
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
 46335:   if (mHideChrome == aShouldHide)
 46335:     return NS_OK;
 46335: 
 25349:   DWORD_PTR style, exStyle;
 46200:   mHideChrome = aShouldHide;
     1:   if (aShouldHide) {
 25349:     DWORD_PTR tempStyle = ::GetWindowLongPtrW(hwnd, GWL_STYLE);
 25349:     DWORD_PTR tempExStyle = ::GetWindowLongPtrW(hwnd, GWL_EXSTYLE);
     1: 
 46234:     style = tempStyle & ~(WS_CAPTION | WS_THICKFRAME);
     1:     exStyle = tempExStyle & ~(WS_EX_DLGMODALFRAME | WS_EX_WINDOWEDGE |
     1:                               WS_EX_CLIENTEDGE | WS_EX_STATICEDGE);
     1: 
     1:     mOldStyle = tempStyle;
     1:     mOldExStyle = tempExStyle;
     1:   }
     1:   else {
 46234:     if (!mOldStyle || !mOldExStyle) {
 25349:       mOldStyle = ::GetWindowLongPtrW(hwnd, GWL_STYLE);
 25349:       mOldExStyle = ::GetWindowLongPtrW(hwnd, GWL_EXSTYLE);
 46234:     }
     1: 
     1:     style = mOldStyle;
     1:     exStyle = mOldExStyle;
     1:   }
     1: 
 19016:   VERIFY_WINDOW_STYLE(style);
 25349:   ::SetWindowLongPtrW(hwnd, GWL_STYLE, style);
 25349:   ::SetWindowLongPtrW(hwnd, GWL_EXSTYLE, exStyle);
     1: 
     1:   return NS_OK;
     1: }
     1: 
 29835: /**************************************************************
 29835:  *
 80035:  * SECTION: nsWindow::Invalidate
 29835:  *
 32293:  * Invalidate an area of the client for painting.
 29835:  *
 29835:  **************************************************************/
 29835: 
     1: // Invalidate this component visible area
 87336: NS_METHOD nsWindow::Invalidate(bool aEraseBackground, 
 80035:                                bool aUpdateNCArea,
 80035:                                bool aIncludeChildren)
 80035: {
 80035:   if (!mWnd) {
 80035:     return NS_OK;
 80035:   }
 80035: 
 29835: #ifdef WIDGET_DEBUG_OUTPUT
     1:   debug_DumpInvalidate(stdout,
     1:                        this,
106838:                        nullptr,
110974:                        nsAutoCString("noname"),
108991:                        (int32_t) mWnd);
 29835: #endif // WIDGET_DEBUG_OUTPUT
 37619: 
 80035:   DWORD flags = RDW_INVALIDATE;
 80035:   if (aEraseBackground) {
 80035:     flags |= RDW_ERASE;
 80035:   }
 80035:   if (aUpdateNCArea) {
 80035:     flags |= RDW_FRAME;
 80035:   }
 80035:   if (aIncludeChildren) {
 80035:     flags |= RDW_ALLCHILDREN;
 80035:   }
 80035: 
 80035:   VERIFY(::RedrawWindow(mWnd, NULL, NULL, flags));
     1:   return NS_OK;
     1: }
     1: 
     1: // Invalidate this component visible area
 87336: NS_METHOD nsWindow::Invalidate(const nsIntRect & aRect)
     1: {
     1:   if (mWnd)
     1:   {
 29835: #ifdef WIDGET_DEBUG_OUTPUT
     1:     debug_DumpInvalidate(stdout,
     1:                          this,
     1:                          &aRect,
110974:                          nsAutoCString("noname"),
108991:                          (int32_t) mWnd);
 29835: #endif // WIDGET_DEBUG_OUTPUT
     1: 
     1:     RECT rect;
     1: 
     1:     rect.left   = aRect.x;
     1:     rect.top    = aRect.y;
     1:     rect.right  = aRect.x + aRect.width;
     1:     rect.bottom = aRect.y + aRect.height;
     1: 
     1:     VERIFY(::InvalidateRect(mWnd, &rect, FALSE));
     1:   }
     1:   return NS_OK;
     1: }
     1: 
 30075: NS_IMETHODIMP
 79445: nsWindow::MakeFullScreen(bool aFullScreen)
 30075: {
 77693:   // taskbarInfo will be NULL pre Windows 7 until Bug 680227 is resolved.
 77693:   nsCOMPtr<nsIWinTaskbar> taskbarInfo =
 77693:     do_GetService(NS_TASKBAR_CONTRACTID);
 77693: 
 52096:   mFullscreenMode = aFullScreen;
 46335:   if (aFullScreen) {
 51547:     if (mSizeMode == nsSizeMode_Fullscreen)
 51547:       return NS_OK;
 46335:     mOldSizeMode = mSizeMode;
 46335:     SetSizeMode(nsSizeMode_Fullscreen);
 77693: 
 77693:     // Notify the taskbar that we will be entering full screen mode.
 77693:     if (taskbarInfo) {
 77693:       taskbarInfo->PrepareFullScreenHWND(mWnd, TRUE);
 77693:     }
 46335:   } else {
 46335:     SetSizeMode(mOldSizeMode);
 46335:   }
 46335: 
 46335:   UpdateNonClientMargins();
 46335: 
 79445:   bool visible = mIsVisible;
 67849:   if (mOldSizeMode == nsSizeMode_Normal)
 79626:     Show(false);
 53999:   
 46335:   // Will call hide chrome, reposition window. Note this will
 46335:   // also cache dimensions for restoration, so it should only
 46335:   // be called once per fullscreen request.
 51547:   nsresult rv = nsBaseWidget::MakeFullScreen(aFullScreen);
 51547: 
 64073:   if (visible) {
 79626:     Show(true);
 87336:     Invalidate();
 53999:   }
 53999: 
 77693:   // Notify the taskbar that we have exited full screen mode.
 77693:   if (!aFullScreen && taskbarInfo) {
 77693:     taskbarInfo->PrepareFullScreenHWND(mWnd, FALSE);
 77693:   }
 77693: 
108457:   if (mWidgetListener)
108457:     mWidgetListener->SizeModeChanged(mSizeMode);
 51547: 
 51547:   return rv;
 30075: }
 30075: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: Native data storage
 29835:  *
 29835:  * nsIWidget::GetNativeData
 29835:  * nsIWidget::FreeNativeData
 29835:  *
 29835:  * Set or clear native data based on a constant.
 29835:  *
 29835:  **************************************************************/
 29835: 
     1: // Return some native data according to aDataType
108991: void* nsWindow::GetNativeData(uint32_t aDataType)
     1: {
 57092:   nsAutoString className;
     1:   switch (aDataType) {
 52079:     case NS_NATIVE_TMP_WINDOW:
 57092:       GetWindowClass(className);
 54349:       return (void*)::CreateWindowExW(mIsRTL ? WS_EX_LAYOUTRTL : 0,
 57092:                                       className.get(),
 52079:                                       L"",
 52079:                                       WS_CHILD,
 52079:                                       CW_USEDEFAULT,
 52079:                                       CW_USEDEFAULT,
 52079:                                       CW_USEDEFAULT,
 52079:                                       CW_USEDEFAULT,
 52079:                                       mWnd,
 52079:                                       NULL,
 52079:                                       nsToolkit::mDllInstance,
 52079:                                       NULL);
 21999:     case NS_NATIVE_PLUGIN_PORT:
     1:     case NS_NATIVE_WIDGET:
     1:     case NS_NATIVE_WINDOW:
 77658:     case NS_NATIVE_SHAREABLE_WINDOW:
     1:       return (void*)mWnd;
     1:     case NS_NATIVE_GRAPHIC:
     1:       // XXX:  This is sleezy!!  Remember to Release the DC after using it!
     1: #ifdef MOZ_XUL
 16601:       return (void*)(eTransparencyTransparent == mTransparencyMode) ?
     1:         mMemoryDC : ::GetDC(mWnd);
     1: #else
     1:       return (void*)::GetDC(mWnd);
     1: #endif
 24836: 
 24836: #ifdef NS_ENABLE_TSF
 25395:     case NS_NATIVE_TSF_THREAD_MGR:
 25395:       return nsTextStore::GetThreadMgr();
 25395:     case NS_NATIVE_TSF_CATEGORY_MGR:
 25395:       return nsTextStore::GetCategoryMgr();
 25395:     case NS_NATIVE_TSF_DISPLAY_ATTR_MGR:
 25395:       return nsTextStore::GetDisplayAttrMgr();
 24836: #endif //NS_ENABLE_TSF
 24836: 
     1:     default:
     1:       break;
     1:   }
     1: 
     1:   return NULL;
     1: }
     1: 
 29835: // Free some native data according to aDataType
108991: void nsWindow::FreeNativeData(void * data, uint32_t aDataType)
     1: {
     1:   switch (aDataType)
     1:   {
     1:     case NS_NATIVE_GRAPHIC:
     1: #ifdef MOZ_XUL
 16601:       if (eTransparencyTransparent != mTransparencyMode)
     1:         ::ReleaseDC(mWnd, (HDC)data);
     1: #else
     1:       ::ReleaseDC(mWnd, (HDC)data);
     1: #endif
     1:       break;
     1:     case NS_NATIVE_WIDGET:
     1:     case NS_NATIVE_WINDOW:
     1:     case NS_NATIVE_PLUGIN_PORT:
     1:       break;
     1:     default:
     1:       break;
     1:   }
     1: }
     1: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::SetTitle
 29835:  *
 29835:  * Set the main windows title text.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: NS_METHOD nsWindow::SetTitle(const nsAString& aTitle)
 29835: {
 29835:   const nsString& strTitle = PromiseFlatString(aTitle);
 29835:   ::SendMessageW(mWnd, WM_SETTEXT, (WPARAM)0, (LPARAM)(LPCWSTR)strTitle.get());
     1:   return NS_OK;
     1: }
     1: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::SetIcon
 29835:  *
 29835:  * Set the main windows icon.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: NS_METHOD nsWindow::SetIcon(const nsAString& aIconSpec) 
 29835: {
 29835:   // Assume the given string is a local identifier for an icon file.
 29835: 
101111:   nsCOMPtr<nsIFile> iconFile;
 29835:   ResolveIconName(aIconSpec, NS_LITERAL_STRING(".ico"),
 29835:                   getter_AddRefs(iconFile));
 29835:   if (!iconFile)
 29835:     return NS_OK; // not an error if icon is not found
 29835: 
 29835:   nsAutoString iconPath;
 29835:   iconFile->GetPath(iconPath);
 29835: 
 29835:   // XXX this should use MZLU (see bug 239279)
 29835: 
 29835:   ::SetLastError(0);
 29835: 
 29835:   HICON bigIcon = (HICON)::LoadImageW(NULL,
 29835:                                       (LPCWSTR)iconPath.get(),
 29835:                                       IMAGE_ICON,
 29835:                                       ::GetSystemMetrics(SM_CXICON),
 29835:                                       ::GetSystemMetrics(SM_CYICON),
 29835:                                       LR_LOADFROMFILE );
 29835:   HICON smallIcon = (HICON)::LoadImageW(NULL,
 29835:                                         (LPCWSTR)iconPath.get(),
 29835:                                         IMAGE_ICON,
 29835:                                         ::GetSystemMetrics(SM_CXSMICON),
 29835:                                         ::GetSystemMetrics(SM_CYSMICON),
 29835:                                         LR_LOADFROMFILE );
 29835: 
 29835:   if (bigIcon) {
 29835:     HICON icon = (HICON) ::SendMessageW(mWnd, WM_SETICON, (WPARAM)ICON_BIG, (LPARAM)bigIcon);
 29835:     if (icon)
 29835:       ::DestroyIcon(icon);
103754:     mIconBig = bigIcon;
 29835:   }
 29835: #ifdef DEBUG_SetIcon
 29835:   else {
 29835:     NS_LossyConvertUTF16toASCII cPath(iconPath);
 76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
 76714:            ("\nIcon load error; icon=%s, rc=0x%08X\n\n", 
 76714:             cPath.get(), ::GetLastError()));
 29835:   }
 29835: #endif
 29835:   if (smallIcon) {
 29835:     HICON icon = (HICON) ::SendMessageW(mWnd, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM)smallIcon);
 29835:     if (icon)
 29835:       ::DestroyIcon(icon);
103754:     mIconSmall = smallIcon;
 29835:   }
 29835: #ifdef DEBUG_SetIcon
 29835:   else {
 29835:     NS_LossyConvertUTF16toASCII cPath(iconPath);
 76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
 76714:            ("\nSmall icon load error; icon=%s, rc=0x%08X\n\n", 
 76714:             cPath.get(), ::GetLastError()));
 29835:   }
 29835: #endif
 29835:   return NS_OK;
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::WidgetToScreenOffset
 29835:  *
 29835:  * Return this widget's origin in screen coordinates.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: nsIntPoint nsWindow::WidgetToScreenOffset()
 29835: {
 29835:   POINT point;
 29835:   point.x = 0;
 29835:   point.y = 0;
 29835:   ::ClientToScreen(mWnd, &point);
 29835:   return nsIntPoint(point.x, point.y);
 29835: }
 29835: 
 48256: nsIntSize nsWindow::ClientToWindowSize(const nsIntSize& aClientSize)
 48256: {
106923:   if (mWindowType == eWindowType_popup && !IsPopupWithTitleBar())
 48256:     return aClientSize;
 48256: 
 48256:   // just use (200, 200) as the position
 48256:   RECT r;
 48256:   r.left = 200;
 48256:   r.top = 200;
 48256:   r.right = 200 + aClientSize.width;
 48256:   r.bottom = 200 + aClientSize.height;
 79626:   ::AdjustWindowRectEx(&r, WindowStyle(), false, WindowExStyle());
 48256: 
 48256:   return nsIntSize(r.right - r.left, r.bottom - r.top);
 48256: }
 48256: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::EnableDragDrop
 29835:  *
 29835:  * Enables/Disables drag and drop of files on this widget.
 29835:  *
 29835:  **************************************************************/
 29835: 
 79445: NS_METHOD nsWindow::EnableDragDrop(bool aEnable)
 29835: {
 43018:   NS_ASSERTION(mWnd, "nsWindow::EnableDragDrop() called after Destroy()");
 43018: 
 29835:   nsresult rv = NS_ERROR_FAILURE;
 29835:   if (aEnable) {
106838:     if (nullptr == mNativeDragTarget) {
 29835:        mNativeDragTarget = new nsNativeDragTarget(this);
 29835:        if (NULL != mNativeDragTarget) {
 29835:          mNativeDragTarget->AddRef();
 29835:          if (S_OK == ::CoLockObjectExternal((LPUNKNOWN)mNativeDragTarget,TRUE,FALSE)) {
 29835:            if (S_OK == ::RegisterDragDrop(mWnd, (LPDROPTARGET)mNativeDragTarget)) {
 29835:              rv = NS_OK;
 29835:            }
 29835:          }
 29835:        }
 29835:     }
 29835:   } else {
106838:     if (nullptr != mWnd && NULL != mNativeDragTarget) {
 29835:       ::RevokeDragDrop(mWnd);
 29835:       if (S_OK == ::CoLockObjectExternal((LPUNKNOWN)mNativeDragTarget, FALSE, TRUE)) {
 29835:         rv = NS_OK;
 29835:       }
 43018:       mNativeDragTarget->DragCancel();
 29835:       NS_RELEASE(mNativeDragTarget);
 29835:     }
 29835:   }
 29835:   return rv;
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::CaptureMouse
 29835:  *
 29835:  * Enables/Disables system mouse capture.
 29835:  *
 29835:  **************************************************************/
 29835: 
 79445: NS_METHOD nsWindow::CaptureMouse(bool aCapture)
 29835: {
 29835:   if (!nsToolkit::gMouseTrailer) {
 29835:     NS_ERROR("nsWindow::CaptureMouse called after nsToolkit destroyed");
 29835:     return NS_OK;
 29835:   }
 29835: 
 29835:   if (aCapture) {
 29835:     nsToolkit::gMouseTrailer->SetCaptureWindow(mWnd);
 29835:     ::SetCapture(mWnd);
 29835:   } else {
 29835:     nsToolkit::gMouseTrailer->SetCaptureWindow(NULL);
 29835:     ::ReleaseCapture();
 29835:   }
 60909:   sIsInMouseCapture = aCapture;
 29835:   return NS_OK;
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::CaptureRollupEvents
 29835:  *
 29835:  * Dealing with event rollup on destroy for popups. Enables &
 29835:  * Disables system capture of any and all events that would
 29835:  * cause a dropdown to be rolled up.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: NS_IMETHODIMP nsWindow::CaptureRollupEvents(nsIRollupListener * aListener,
120177:                                             bool aDoCapture)
 29835: {
 29835:   if (aDoCapture) {
120177:     gRollupListener = aListener;
 29835:     if (!sMsgFilterHook && !sCallProcHook && !sCallMouseHook) {
 29835:       RegisterSpecialDropdownHooks();
 29835:     }
 79626:     sProcessHook = true;
 29835:   } else {
120177:     gRollupListener = nullptr;
 79626:     sProcessHook = false;
 29835:     UnregisterSpecialDropdownHooks();
 29835:   }
 29835: 
 29835:   return NS_OK;
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::GetAttention
 29835:  *
 29835:  * Bring this window to the user's attention.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: // Draw user's attention to this window until it comes to foreground.
 29835: NS_IMETHODIMP
108991: nsWindow::GetAttention(int32_t aCycleCount)
 29835: {
 29835:   // Got window?
 29835:   if (!mWnd)
 29835:     return NS_ERROR_NOT_INITIALIZED;
 29835: 
 86569:   HWND flashWnd = WinUtils::GetTopLevelHWND(mWnd, false, false);
 29835:   HWND fgWnd = ::GetForegroundWindow();
 80121:   // Don't flash if the flash count is 0 or if the foreground window is our
 80121:   // window handle or that of our owned-most window.
 80121:   if (aCycleCount == 0 || 
 80121:       flashWnd == fgWnd ||
 86569:       flashWnd == WinUtils::GetTopLevelHWND(fgWnd, false, false)) {
 29835:     return NS_OK;
 80121:   }
 29835: 
 29835:   DWORD defaultCycleCount = 0;
 29835:   ::SystemParametersInfo(SPI_GETFOREGROUNDFLASHCOUNT, 0, &defaultCycleCount, 0);
 29835: 
 29835:   FLASHWINFO flashInfo = { sizeof(FLASHWINFO), flashWnd,
 29835:     FLASHW_ALL, aCycleCount > 0 ? aCycleCount : defaultCycleCount, 0 };
 29835:   ::FlashWindowEx(&flashInfo);
 68855: 
 29835:   return NS_OK;
 29835: }
 29835: 
 29835: void nsWindow::StopFlashing()
 29835: {
 29835:   HWND flashWnd = mWnd;
 29835:   while (HWND ownerWnd = ::GetWindow(flashWnd, GW_OWNER)) {
 29835:     flashWnd = ownerWnd;
 29835:   }
 29835: 
 29835:   FLASHWINFO flashInfo = { sizeof(FLASHWINFO), flashWnd,
 29835:     FLASHW_STOP, 0, 0 };
 29835:   ::FlashWindowEx(&flashInfo);
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: nsIWidget::HasPendingInputEvent
 29835:  *
 29835:  * Ask whether there user input events pending.  All input events are
 29835:  * included, including those not targeted at this nsIwidget instance.
 29835:  *
 29835:  **************************************************************/
 29835: 
 79445: bool
 29835: nsWindow::HasPendingInputEvent()
 29835: {
 29835:   // If there is pending input or the user is currently
 29835:   // moving the window then return true.
 29835:   // Note: When the user is moving the window WIN32 spins
 29835:   // a separate event loop and input events are not
 29835:   // reported to the application.
 30504:   if (HIWORD(GetQueueStatus(QS_INPUT)))
 79626:     return true;
 30504:   GUITHREADINFO guiInfo;
 30504:   guiInfo.cbSize = sizeof(GUITHREADINFO);
 30504:   if (!GetGUIThreadInfo(GetCurrentThreadId(), &guiInfo))
 79626:     return false;
 30504:   return GUI_INMOVESIZE == (guiInfo.flags & GUI_INMOVESIZE);
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  *
 40028:  * SECTION: nsIWidget::GetLayerManager
 40028:  *
 40028:  * Get the layer manager associated with this widget.
 40028:  *
 40028:  **************************************************************/
 40028: 
 60398: struct LayerManagerPrefs {
 60398:   LayerManagerPrefs()
 79626:     : mAccelerateByDefault(true)
 79626:     , mDisableAcceleration(false)
 79626:     , mPreferOpenGL(false)
 79626:     , mPreferD3D9(false)
 60398:   {}
 79445:   bool mAccelerateByDefault;
 79445:   bool mDisableAcceleration;
 79445:   bool mForceAcceleration;
 79445:   bool mPreferOpenGL;
 79445:   bool mPreferD3D9;
 60398: };
 60398: 
 60398: static void
 60398: GetLayerManagerPrefs(LayerManagerPrefs* aManagerPrefs)
 60398: {
 70956:   Preferences::GetBool("layers.acceleration.disabled",
 60398:                        &aManagerPrefs->mDisableAcceleration);
 70956:   Preferences::GetBool("layers.acceleration.force-enabled",
 60833:                        &aManagerPrefs->mForceAcceleration);
 70956:   Preferences::GetBool("layers.prefer-opengl",
 60398:                        &aManagerPrefs->mPreferOpenGL);
 70956:   Preferences::GetBool("layers.prefer-d3d9",
 60398:                        &aManagerPrefs->mPreferD3D9);
 60398: 
 60398:   const char *acceleratedEnv = PR_GetEnv("MOZ_ACCELERATED");
 60398:   aManagerPrefs->mAccelerateByDefault =
 60398:     aManagerPrefs->mAccelerateByDefault ||
 60398:     (acceleratedEnv && (*acceleratedEnv != '0'));
 60398: 
 79445:   bool safeMode = false;
 60398:   nsCOMPtr<nsIXULRuntime> xr = do_GetService("@mozilla.org/xre/runtime;1");
 60398:   if (xr)
 60398:     xr->GetInSafeMode(&safeMode);
 60398:   aManagerPrefs->mDisableAcceleration =
 60398:     aManagerPrefs->mDisableAcceleration || safeMode;
 60398: }
 60398: 
101914: bool
101914: nsWindow::UseOffMainThreadCompositing()
101914: {
101914:   // OMTC doesn't work on Windows right now.
101914:   return false;
101914: }
101914: 
 75149: LayerManager*
 75149: nsWindow::GetLayerManager(PLayersChild* aShadowManager,
 75149:                           LayersBackend aBackendHint,
 75149:                           LayerManagerPersistence aPersistence,
 75149:                           bool* aAllowRetaining)
 55858: {
 55858:   if (aAllowRetaining) {
 55858:     *aAllowRetaining = true;
 55858:   }
 55858: 
 57918: #ifdef MOZ_ENABLE_D3D10_LAYER
 57918:   if (mLayerManager) {
105710:     if (mLayerManager->GetBackendType() == LAYERS_D3D10)
105710:     {
105710:       LayerManagerD3D10 *layerManagerD3D10 =
105710:         static_cast<LayerManagerD3D10*>(mLayerManager.get());
 57918:       if (layerManagerD3D10->device() !=
 57918:           gfxWindowsPlatform::GetPlatform()->GetD3D10Device())
 57918:       {
108476:         MOZ_ASSERT(!mLayerManager->IsInTransaction());
108476: 
 58810:         mLayerManager->Destroy();
106838:         mLayerManager = nullptr;
 57918:       }
 57918:     }
 57918:   }
 57918: #endif
 57918: 
 79695:   RECT windowRect;
 79695:   ::GetClientRect(mWnd, &windowRect);
 79695: 
 58814:   if (!mLayerManager ||
 58814:       (!sAllowD3D9 && aPersistence == LAYER_MANAGER_PERSISTENT &&
105710:         mLayerManager->GetBackendType() == LAYERS_BASIC)) {
 58814:     // If D3D9 is not currently allowed but the permanent manager is required,
 58814:     // -and- we're currently using basic layers, run through this check.
 60398:     LayerManagerPrefs prefs;
 60398:     GetLayerManagerPrefs(&prefs);
 51978: 
 51995:     /* We don't currently support using an accelerated layer manager with
 51995:      * transparent windows so don't even try. I'm also not sure if we even
 51995:      * want to support this case. See bug #593471 */
 60398:     if (eTransparencyTransparent == mTransparencyMode ||
 79695:         prefs.mDisableAcceleration ||
 79695:         windowRect.right - windowRect.left > MAX_ACCELERATED_DIMENSION ||
102784:         windowRect.bottom - windowRect.top > MAX_ACCELERATED_DIMENSION)
122281:       mUseLayersAcceleration = false;
 60398:     else if (prefs.mAccelerateByDefault)
122281:       mUseLayersAcceleration = true;
122281: 
122281:     if (mUseLayersAcceleration) {
 58814:       if (aPersistence == LAYER_MANAGER_PERSISTENT && !sAllowD3D9) {
108476:         MOZ_ASSERT(!mLayerManager || !mLayerManager->IsInTransaction());
108476: 
 58814:         // This will clear out our existing layer manager if we have one since
 58814:         // if we hit this with a LayerManager we're always using BasicLayers.
 58814:         nsToolkit::StartAllowingD3D9();
 58814:       }
 58814: 
 54816: #ifdef MOZ_ENABLE_D3D10_LAYER
 81596:       if (!prefs.mPreferD3D9 && !prefs.mPreferOpenGL) {
105710:         nsRefPtr<LayerManagerD3D10> layerManager =
105710:           new LayerManagerD3D10(this);
 91135:         if (layerManager->Initialize(prefs.mForceAcceleration)) {
 54816:           mLayerManager = layerManager;
 54816:         }
 54816:       }
 54816: #endif
 43174: #ifdef MOZ_ENABLE_D3D9_LAYER
 60398:       if (!prefs.mPreferOpenGL && !mLayerManager && sAllowD3D9) {
105710:         nsRefPtr<LayerManagerD3D9> layerManager =
105710:           new LayerManagerD3D9(this);
 91135:         if (layerManager->Initialize(prefs.mForceAcceleration)) {
 43174:           mLayerManager = layerManager;
 43174:         }
 43174:       }
 43174: #endif
 60398:       if (!mLayerManager && prefs.mPreferOpenGL) {
 60833:         nsCOMPtr<nsIGfxInfo> gfxInfo = do_GetService("@mozilla.org/gfx/info;1");
108991:         int32_t status = nsIGfxInfo::FEATURE_NO_INFO;
 60833: 
 60833:         if (gfxInfo && !prefs.mForceAcceleration) {
 60833:           gfxInfo->GetFeatureStatus(nsIGfxInfo::FEATURE_OPENGL_LAYERS, &status);
 60833:         }
 60833: 
 60833:         if (status == nsIGfxInfo::FEATURE_NO_INFO) {
105710:           nsRefPtr<LayerManagerOGL> layerManager =
105710:             new LayerManagerOGL(this);
 42612:           if (layerManager->Initialize()) {
 42612:             mLayerManager = layerManager;
 42612:           }
 60833: 
 60833:         } else {
 60833:           NS_WARNING("OpenGL accelerated layers are not supported on this system.");
 60833:         }
 42612:       }
 42612:     }
 51995: 
 51995:     // Fall back to software if we couldn't use any hardware backends.
 99815:     if (!mLayerManager) {
 99815:       // Try to use an async compositor first, if possible
101914:       if (UseOffMainThreadCompositing()) {
 99815:         // e10s uses the parameter to pass in the shadow manager from the TabChild
 99815:         // so we don't expect to see it there since this doesn't support e10s.
106838:         NS_ASSERTION(aShadowManager == nullptr, "Async Compositor not supported with e10s");
 99815:         CreateCompositor();
 99815:       }
 99815: 
 51995:       if (!mLayerManager)
 54111:         mLayerManager = CreateBasicLayerManager();
 51995:     }
 99815:   }
 51995: 
 79629:   NS_ASSERTION(mLayerManager, "Couldn't provide a valid layer manager.");
 79629: 
 51995:   return mLayerManager;
 40028: }
 40028: 
 40028: /**************************************************************
 40028:  *
 29835:  * SECTION: nsIWidget::GetThebesSurface
 29835:  *
 29835:  * Get the Thebes surface associated with this widget.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: gfxASurface *nsWindow::GetThebesSurface()
 29835: {
 38727: #ifdef CAIRO_HAS_D2D_SURFACE
 38727:   if (mD2DWindowSurface) {
 38727:     return mD2DWindowSurface;
 38727:   }
 38727: #endif
 29835:   if (mPaintDC)
 29835:     return (new gfxWindowsSurface(mPaintDC));
 29835: 
 38727: #ifdef CAIRO_HAS_D2D_SURFACE
 38727:   if (gfxWindowsPlatform::GetPlatform()->GetRenderMode() ==
 38727:       gfxWindowsPlatform::RENDER_DIRECT2D) {
 43397:     gfxASurface::gfxContentType content = gfxASurface::CONTENT_COLOR;
 43397: #if defined(MOZ_XUL)
 43397:     if (mTransparencyMode != eTransparencyOpaque) {
 43397:       content = gfxASurface::CONTENT_COLOR_ALPHA;
 43397:     }
 43397: #endif
 43397:     return (new gfxD2DSurface(mWnd, content));
 38727:   } else {
 38727: #endif
108991:     uint32_t flags = gfxWindowsSurface::FLAG_TAKE_DC;
 47767:     if (mTransparencyMode != eTransparencyOpaque) {
 47767:         flags |= gfxWindowsSurface::FLAG_IS_TRANSPARENT;
 47767:     }
 47767:     return (new gfxWindowsSurface(mWnd, flags));
 38727: #ifdef CAIRO_HAS_D2D_SURFACE
 38727:   }
 38727: #endif
 29835: }
 29835: 
 29835: /**************************************************************
 30327:  *
 30327:  * SECTION: nsIWidget::OnDefaultButtonLoaded
 30327:  *
 30327:  * Called after the dialog is loaded and it has a default button.
 30327:  *
 30327:  **************************************************************/
 30327:  
 30327: NS_IMETHODIMP
 30327: nsWindow::OnDefaultButtonLoaded(const nsIntRect &aButtonRect)
 30327: {
 30327:   if (aButtonRect.IsEmpty())
 30327:     return NS_OK;
 30327: 
 30327:   // Don't snap when we are not active.
 30327:   HWND activeWnd = ::GetActiveWindow();
 30327:   if (activeWnd != ::GetForegroundWindow() ||
 86569:       WinUtils::GetTopLevelHWND(mWnd, true) !=
 86569:         WinUtils::GetTopLevelHWND(activeWnd, true)) {
 30327:     return NS_OK;
 30327:   }
 30327: 
 79445:   bool isAlwaysSnapCursor =
 79445:     Preferences::GetBool("ui.cursor_snapping.always_enabled", false);
 30327: 
 30327:   if (!isAlwaysSnapCursor) {
 30327:     BOOL snapDefaultButton;
 30327:     if (!::SystemParametersInfo(SPI_GETSNAPTODEFBUTTON, 0,
 30327:                                 &snapDefaultButton, 0) || !snapDefaultButton)
 30327:       return NS_OK;
 30327:   }
 30327: 
 30327:   nsIntRect widgetRect;
 30327:   nsresult rv = GetScreenBounds(widgetRect);
 30327:   NS_ENSURE_SUCCESS(rv, rv);
 30327:   nsIntRect buttonRect(aButtonRect + widgetRect.TopLeft());
 30327: 
 30327:   nsIntPoint centerOfButton(buttonRect.x + buttonRect.width / 2,
 30327:                             buttonRect.y + buttonRect.height / 2);
 30327:   // The center of the button can be outside of the widget.
 30327:   // E.g., it could be hidden by scrolling.
 30327:   if (!widgetRect.Contains(centerOfButton)) {
 30327:     return NS_OK;
 30327:   }
 30327: 
 30327:   if (!::SetCursorPos(centerOfButton.x, centerOfButton.y)) {
 30327:     NS_ERROR("SetCursorPos failed");
 30327:     return NS_ERROR_FAILURE;
 30327:   }
 30327:   return NS_OK;
 30327: }
 30327: 
 33016: NS_IMETHODIMP
108991: nsWindow::OverrideSystemMouseScrollSpeed(int32_t aOriginalDelta,
 79445:                                          bool aIsHorizontal,
108991:                                          int32_t &aOverriddenDelta)
 33016: {
 33016:   // The default vertical and horizontal scrolling speed is 3, this is defined
 33016:   // on the document of SystemParametersInfo in MSDN.
108991:   const uint32_t kSystemDefaultScrollingSpeed = 3;
108991: 
124775:   int32_t absOriginDelta = std::abs(aOriginalDelta);
 37978: 
 33016:   // Compute the simple overridden speed.
108991:   int32_t absComputedOverriddenDelta;
 33016:   nsresult rv =
 37978:     nsBaseWidget::OverrideSystemMouseScrollSpeed(absOriginDelta, aIsHorizontal,
 37978:                                                  absComputedOverriddenDelta);
 33016:   NS_ENSURE_SUCCESS(rv, rv);
 33016: 
 33016:   aOverriddenDelta = aOriginalDelta;
 33016: 
 37978:   if (absComputedOverriddenDelta == absOriginDelta) {
 33016:     // We don't override now.
 33016:     return NS_OK;
 33016:   }
 33016: 
 33016:   // Otherwise, we should check whether the user customized the system settings
 33016:   // or not.  If the user did it, we should respect the will.
 33016:   UINT systemSpeed;
 33016:   if (!::SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &systemSpeed, 0)) {
 33016:     return NS_ERROR_FAILURE;
 33016:   }
 33016:   // The default vertical scrolling speed is 3, this is defined on the document
 33016:   // of SystemParametersInfo in MSDN.
 33016:   if (systemSpeed != kSystemDefaultScrollingSpeed) {
 33016:     return NS_OK;
 33016:   }
 33016: 
 33016:   // Only Vista and later, Windows has the system setting of horizontal
 33016:   // scrolling by the mouse wheel.
 86569:   if (WinUtils::GetWindowsVersion() >= WinUtils::VISTA_VERSION) {
 33016:     if (!::SystemParametersInfo(SPI_GETWHEELSCROLLCHARS, 0, &systemSpeed, 0)) {
 33016:       return NS_ERROR_FAILURE;
 33016:     }
 33016:     // The default horizontal scrolling speed is 3, this is defined on the
 33016:     // document of SystemParametersInfo in MSDN.
 33016:     if (systemSpeed != kSystemDefaultScrollingSpeed) {
 33016:       return NS_OK;
 33016:     }
 33016:   }
 33016: 
 33016:   // Limit the overridden delta value from the system settings.  The mouse
 33016:   // driver might accelerate the scrolling speed already.  If so, we shouldn't
 33016:   // override the scrolling speed for preventing the unexpected high speed
 33016:   // scrolling.
108991:   int32_t absDeltaLimit;
 33016:   rv =
 33016:     nsBaseWidget::OverrideSystemMouseScrollSpeed(kSystemDefaultScrollingSpeed,
 37978:                                                  aIsHorizontal, absDeltaLimit);
 33016:   NS_ENSURE_SUCCESS(rv, rv);
 33016: 
 37978:   // If the given delta is larger than our computed limitation value, the delta
 37978:   // was accelerated by the mouse driver.  So, we should do nothing here.
 37978:   if (absDeltaLimit <= absOriginDelta) {
 37978:     return NS_OK;
 37978:   }
 37978: 
 37978:   absComputedOverriddenDelta =
 72496:     NS_MIN(absComputedOverriddenDelta, absDeltaLimit);
 37978: 
 37978:   aOverriddenDelta = (aOriginalDelta > 0) ? absComputedOverriddenDelta :
 37978:                                             -absComputedOverriddenDelta;
 33016:   return NS_OK;
 33016: }
 33016: 
 30327: /**************************************************************
 29835:  **************************************************************
 29835:  **
 29835:  ** BLOCK: Moz Events
 29835:  **
 29835:  ** Moz GUI event management. 
 29835:  **
 29835:  **************************************************************
 29835:  **************************************************************/
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: Mozilla event initialization
 29835:  *
 29835:  * Helpers for initializing moz events.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: // Event intialization
 29835: void nsWindow::InitEvent(nsGUIEvent& event, nsIntPoint* aPoint)
 29835: {
106838:   if (nullptr == aPoint) {     // use the point from the event
 29835:     // get the message position in client coordinates
 29835:     if (mWnd != NULL) {
 29835: 
 29835:       DWORD pos = ::GetMessagePos();
 29835:       POINT cpos;
 29835:       
 29835:       cpos.x = GET_X_LPARAM(pos);
 29835:       cpos.y = GET_Y_LPARAM(pos);
 29835: 
 29835:       ::ScreenToClient(mWnd, &cpos);
 29835:       event.refPoint.x = cpos.x;
 29835:       event.refPoint.y = cpos.y;
     1:     } else {
 29835:       event.refPoint.x = 0;
 29835:       event.refPoint.y = 0;
 29835:     }
 29835:   }
 29835:   else {  
 29835:     // use the point override if provided
 29835:     event.refPoint.x = aPoint->x;
 29835:     event.refPoint.y = aPoint->y;
 29835:   }
 29835: 
 29835:   event.time = ::GetMessageTime();
 29835:   mLastPoint = event.refPoint;
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: Moz event dispatch helpers
 29835:  *
 29835:  * Helpers for dispatching different types of moz events.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: // Main event dispatch. Invokes callback and ProcessEvent method on
 29835: // Event Listener object. Part of nsIWidget.
 29835: NS_IMETHODIMP nsWindow::DispatchEvent(nsGUIEvent* event, nsEventStatus & aStatus)
 29835: {
 29835: #ifdef WIDGET_DEBUG_OUTPUT
 29835:   debug_DumpEvent(stdout,
 29835:                   event->widget,
 29835:                   event,
110974:                   nsAutoCString("something"),
108991:                   (int32_t) mWnd);
 29835: #endif // WIDGET_DEBUG_OUTPUT
 29835: 
 29835:   aStatus = nsEventStatus_eIgnore;
 29835: 
 46195:   // Top level windows can have a view attached which requires events be sent
 46195:   // to the underlying base window and the view. Added when we combined the
 46195:   // base chrome window with the main content child for nc client area (title
 46195:   // bar) rendering.
108461:   if (mAttachedWidgetListener) {
108461:     aStatus = mAttachedWidgetListener->HandleEvent(event, mUseAttachedEvents);
108460:   }
108460:   else if (mWidgetListener) {
108460:     aStatus = mWidgetListener->HandleEvent(event, mUseAttachedEvents);
 29835:   }
 29835: 
 29835:   // the window can be destroyed during processing of seemingly innocuous events like, say,
 29835:   // mousedowns due to the magic of scripting. mousedowns will return nsEventStatus_eIgnore,
 29835:   // which causes problems with the deleted window. therefore:
 29835:   if (mOnDestroyCalled)
 29835:     aStatus = nsEventStatus_eConsumeNoDefault;
 29835:   return NS_OK;
 29835: }
 29835: 
108991: bool nsWindow::DispatchStandardEvent(uint32_t aMsg)
 29835: {
 79626:   nsGUIEvent event(true, aMsg, this);
 29835:   InitEvent(event);
 29835: 
 79445:   bool result = DispatchWindowEvent(&event);
 29835:   return result;
 29835: }
 29835: 
 79445: bool nsWindow::DispatchWindowEvent(nsGUIEvent* event)
 29835: {
 29835:   nsEventStatus status;
 29835:   DispatchEvent(event, status);
 29835:   return ConvertStatus(status);
 29835: }
 29835: 
 79445: bool nsWindow::DispatchWindowEvent(nsGUIEvent* event, nsEventStatus &aStatus) {
 29835:   DispatchEvent(event, aStatus);
 29835:   return ConvertStatus(aStatus);
 29835: }
 29835: 
 97476: void nsWindow::InitKeyEvent(nsKeyEvent& aKeyEvent,
 97476:                             const NativeKey& aNativeKey,
102101:                             const ModifierKeyState &aModKeyState)
 97476: {
 97476:   nsIntPoint point(0, 0);
 97476:   InitEvent(aKeyEvent, &point);
 97476:   aKeyEvent.location = aNativeKey.GetKeyLocation();
 97476:   aModKeyState.InitInputEvent(aKeyEvent);
 97476: }
 97476: 
 97476: bool nsWindow::DispatchKeyEvent(nsKeyEvent& aKeyEvent,
 97476:                                 const MSG *aMsgSentToPlugin)
     1: {
 40944:   UserActivity();
 40944: 
 32799:   NPEvent pluginEvent;
 97476:   if (aMsgSentToPlugin && PluginHasFocus()) {
 97476:     pluginEvent.event = aMsgSentToPlugin->message;
 97476:     pluginEvent.wParam = aMsgSentToPlugin->wParam;
 97476:     pluginEvent.lParam = aMsgSentToPlugin->lParam;
 97476:     aKeyEvent.pluginEvent = (void *)&pluginEvent;
 97476:   }
 97476: 
 97476:   return DispatchWindowEvent(&aKeyEvent);
     1: }
     1: 
108991: bool nsWindow::DispatchCommandEvent(uint32_t aEventCommand)
 29835: {
 29835:   nsCOMPtr<nsIAtom> command;
 29835:   switch (aEventCommand) {
 29835:     case APPCOMMAND_BROWSER_BACKWARD:
 80435:       command = nsGkAtoms::Back;
 29835:       break;
 29835:     case APPCOMMAND_BROWSER_FORWARD:
 80435:       command = nsGkAtoms::Forward;
 29835:       break;
 29835:     case APPCOMMAND_BROWSER_REFRESH:
 80435:       command = nsGkAtoms::Reload;
 29835:       break;
 29835:     case APPCOMMAND_BROWSER_STOP:
 80435:       command = nsGkAtoms::Stop;
 29835:       break;
 29835:     case APPCOMMAND_BROWSER_SEARCH:
 80435:       command = nsGkAtoms::Search;
 29835:       break;
 29835:     case APPCOMMAND_BROWSER_FAVORITES:
 80435:       command = nsGkAtoms::Bookmarks;
 29835:       break;
 29835:     case APPCOMMAND_BROWSER_HOME:
 80435:       command = nsGkAtoms::Home;
 29835:       break;
127108:     case APPCOMMAND_CLOSE:
127108:       command = nsGkAtoms::Close;
127108:       break;
127108:     case APPCOMMAND_FIND:
127108:       command = nsGkAtoms::Find;
127108:       break;
127108:     case APPCOMMAND_HELP:
127108:       command = nsGkAtoms::Help;
127108:       break;
127108:     case APPCOMMAND_NEW:
127108:       command = nsGkAtoms::New;
127108:       break;
127108:     case APPCOMMAND_OPEN:
127108:       command = nsGkAtoms::Open;
127108:       break;
127108:     case APPCOMMAND_PRINT:
127108:       command = nsGkAtoms::Print;
127108:       break;
127108:     case APPCOMMAND_SAVE:
127108:       command = nsGkAtoms::Save;
127108:       break;
127108:     case APPCOMMAND_FORWARD_MAIL:
127108:       command = nsGkAtoms::ForwardMail;
127108:       break;
127108:     case APPCOMMAND_REPLY_TO_MAIL:
127108:       command = nsGkAtoms::ReplyToMail;
127108:       break;
127108:     case APPCOMMAND_SEND_MAIL:
127108:       command = nsGkAtoms::SendMail;
127108:       break;
 29835:     default:
 79626:       return false;
 79626:   }
 80435:   nsCommandEvent event(true, nsGkAtoms::onAppCommand, command, this);
 29835: 
 29835:   InitEvent(event);
127108:   return DispatchWindowEvent(&event);
 29835: }
 29835: 
 29835: // Recursively dispatch synchronous paints for nsIWidget
 29835: // descendants with invalidated rectangles.
 29835: BOOL CALLBACK nsWindow::DispatchStarvedPaints(HWND aWnd, LPARAM aMsg)
 29835: {
 29835:   LONG_PTR proc = ::GetWindowLongPtrW(aWnd, GWLP_WNDPROC);
 29835:   if (proc == (LONG_PTR)&nsWindow::WindowProc) {
 29835:     // its one of our windows so check to see if it has a
 29835:     // invalidated rect. If it does. Dispatch a synchronous
 29835:     // paint.
 37613:     if (GetUpdateRect(aWnd, NULL, FALSE))
 29835:       VERIFY(::UpdateWindow(aWnd));
 29835:   }
 29835:   return TRUE;
 29835: }
 29835: 
 29835: // Check for pending paints and dispatch any pending paint
 29835: // messages for any nsIWidget which is a descendant of the
 29835: // top-level window that *this* window is embedded within.
 29835: //
 29835: // Note: We do not dispatch pending paint messages for non
 29835: // nsIWidget managed windows.
 29835: void nsWindow::DispatchPendingEvents()
 29835: {
 35287:   if (mPainting) {
 35287:     NS_WARNING("We were asked to dispatch pending events during painting, "
 35287:                "denying since that's unsafe.");
 35287:     return;
 35287:   }
 35287: 
 29835:   // We need to ensure that reflow events do not get starved.
 29835:   // At the same time, we don't want to recurse through here
 29835:   // as that would prevent us from dispatching starved paints.
 29835:   static int recursionBlocker = 0;
 29835:   if (recursionBlocker++ == 0) {
106838:     NS_ProcessPendingEvents(nullptr, PR_MillisecondsToInterval(100));
 29835:     --recursionBlocker;
 29835:   }
 29835: 
 87254:   // Quickly check to see if there are any paint events pending,
 87254:   // but only dispatch them if it has been long enough since the
 87254:   // last paint completed.
 87254:   if (::GetQueueStatus(QS_PAINT) &&
 87254:       ((TimeStamp::Now() - mLastPaintEndTime).ToMilliseconds() >= 50)) {
 29835:     // Find the top level window.
 86569:     HWND topWnd = WinUtils::GetTopLevelHWND(mWnd);
 29835: 
 55226:     // Dispatch pending paints for topWnd and all its descendant windows.
 29835:     // Note: EnumChildWindows enumerates all descendant windows not just
 55226:     // the children (but not the window itself).
 55226:     nsWindow::DispatchStarvedPaints(topWnd, 0);
 51212:     ::EnumChildWindows(topWnd, nsWindow::DispatchStarvedPaints, 0);
 29835:   }
 29835: }
 29835: 
 29835: // Deal with plugin events
 79445: bool nsWindow::DispatchPluginEvent(const MSG &aMsg)
 29835: {
 29835:   if (!PluginHasFocus())
 79626:     return false;
 79626: 
 79626:   nsPluginEvent event(true, NS_PLUGIN_INPUT_EVENT, this);
 29835:   nsIntPoint point(0, 0);
 29835:   InitEvent(event, &point);
 32799:   NPEvent pluginEvent;
 29835:   pluginEvent.event = aMsg.message;
 29835:   pluginEvent.wParam = aMsg.wParam;
 29835:   pluginEvent.lParam = aMsg.lParam;
 34743:   event.pluginEvent = (void *)&pluginEvent;
 79626:   event.retargetToFocusedDocument = true;
 29835:   return DispatchWindowEvent(&event);
 29835: }
 29835: 
 79445: bool nsWindow::DispatchPluginEvent(UINT aMessage,
 49149:                                      WPARAM aWParam,
 49149:                                      LPARAM aLParam,
 79445:                                      bool aDispatchPendingEvents)
 79445: {
 86569:   bool ret = DispatchPluginEvent(WinUtils::InitMSG(aMessage, aWParam, aLParam));
 49149:   if (aDispatchPendingEvents) {
 49149:     DispatchPendingEvents();
 49149:   }
 49149:   return ret;
 49149: }
 49149: 
 22788: void nsWindow::RemoveMessageAndDispatchPluginEvent(UINT aFirstMsg,
 68737:                  UINT aLastMsg, nsFakeCharMessage* aFakeCharMessage)
 22788: {
 22788:   MSG msg;
 68737:   if (aFakeCharMessage) {
 68737:     if (aFirstMsg > WM_CHAR || aLastMsg < WM_CHAR) {
 68737:       return;
 68737:     }
 68737:     msg = aFakeCharMessage->GetCharMessage(mWnd);
 68737:   } else {
 22788:     ::GetMessageW(&msg, mWnd, aFirstMsg, aLastMsg);
 68737:   }
 22788:   DispatchPluginEvent(msg);
 22788: }
 22788: 
 29835: // Deal with all sort of mouse event
108991: bool nsWindow::DispatchMouseEvent(uint32_t aEventType, WPARAM wParam,
 79445:                                     LPARAM lParam, bool aIsContextMenuKey,
108991:                                     int16_t aButton, uint16_t aInputSource)
 29835: {
 79445:   bool result = false;
 29835: 
 40944:   UserActivity();
 40944: 
108460:   if (!mWidgetListener) {
 29835:     return result;
 29835:   }
 29835: 
 46202:   switch (aEventType) {
 46202:     case NS_MOUSE_BUTTON_DOWN:
 79626:       CaptureMouse(true);
 46202:       break;
 46202: 
 46202:     // NS_MOUSE_MOVE and NS_MOUSE_EXIT are here because we need to make sure capture flag
 46202:     // isn't left on after a drag where we wouldn't see a button up message (see bug 324131).
 46202:     case NS_MOUSE_BUTTON_UP:
 46202:     case NS_MOUSE_MOVE:
 46202:     case NS_MOUSE_EXIT:
 60909:       if (!(wParam & (MK_LBUTTON | MK_MBUTTON | MK_RBUTTON)) && sIsInMouseCapture)
 79626:         CaptureMouse(false);
 46202:       break;
 46202: 
 46202:     default:
 46202:       break;
 46202: 
 46202:   } // switch
 46202: 
 29835:   nsIntPoint eventPoint;
 29835:   eventPoint.x = GET_X_LPARAM(lParam);
 29835:   eventPoint.y = GET_Y_LPARAM(lParam);
 29835: 
 79626:   nsMouseEvent event(true, aEventType, this, nsMouseEvent::eReal,
 29835:                      aIsContextMenuKey
 29835:                      ? nsMouseEvent::eContextMenuKey
 29835:                      : nsMouseEvent::eNormal);
 29835:   if (aEventType == NS_CONTEXTMENU && aIsContextMenuKey) {
 29835:     nsIntPoint zero(0, 0);
 29835:     InitEvent(event, &zero);
 29835:   } else {
 29835:     InitEvent(event, &eventPoint);
 29835:   }
 29835: 
102101:   ModifierKeyState modifierKeyState;
 96889:   modifierKeyState.InitInputEvent(event);
 29835:   event.button    = aButton;
 40485:   event.inputSource = aInputSource;
 29835: 
 29835:   nsIntPoint mpScreen = eventPoint + WidgetToScreenOffset();
 29835: 
 29835:   // Suppress mouse moves caused by widget creation
 29835:   if (aEventType == NS_MOUSE_MOVE) 
 29835:   {
 29835:     if ((sLastMouseMovePoint.x == mpScreen.x) && (sLastMouseMovePoint.y == mpScreen.y))
 29835:       return result;
 29835:     sLastMouseMovePoint.x = mpScreen.x;
 29835:     sLastMouseMovePoint.y = mpScreen.y;
 29835:   }
 29835: 
 79445:   bool insideMovementThreshold = (abs(sLastMousePoint.x - eventPoint.x) < (short)::GetSystemMetrics(SM_CXDOUBLECLK)) &&
 29835:                                    (abs(sLastMousePoint.y - eventPoint.y) < (short)::GetSystemMetrics(SM_CYDOUBLECLK));
 29835: 
 29835:   BYTE eventButton;
 29835:   switch (aButton) {
 29835:     case nsMouseEvent::eLeftButton:
 29835:       eventButton = VK_LBUTTON;
 29835:       break;
 29835:     case nsMouseEvent::eMiddleButton:
 29835:       eventButton = VK_MBUTTON;
 29835:       break;
 29835:     case nsMouseEvent::eRightButton:
 29835:       eventButton = VK_RBUTTON;
 29835:       break;
 29835:     default:
 29835:       eventButton = 0;
 29835:       break;
 29835:   }
 29835: 
 29835:   // Doubleclicks are used to set the click count, then changed to mousedowns
 29835:   // We're going to time double-clicks from mouse *up* to next mouse *down*
 29835:   LONG curMsgTime = ::GetMessageTime();
 29835: 
 29835:   if (aEventType == NS_MOUSE_DOUBLECLICK) {
 29835:     event.message = NS_MOUSE_BUTTON_DOWN;
 29835:     event.button = aButton;
 29835:     sLastClickCount = 2;
 29835:   }
 29835:   else if (aEventType == NS_MOUSE_BUTTON_UP) {
 29835:     // remember when this happened for the next mouse down
 29835:     sLastMousePoint.x = eventPoint.x;
 29835:     sLastMousePoint.y = eventPoint.y;
 29835:     sLastMouseButton = eventButton;
 29835:   }
 29835:   else if (aEventType == NS_MOUSE_BUTTON_DOWN) {
 29835:     // now look to see if we want to convert this to a double- or triple-click
 29835:     if (((curMsgTime - sLastMouseDownTime) < (LONG)::GetDoubleClickTime()) && insideMovementThreshold &&
 29835:         eventButton == sLastMouseButton) {
 29835:       sLastClickCount ++;
 29835:     } else {
 29835:       // reset the click count, to count *this* click
 29835:       sLastClickCount = 1;
 29835:     }
 29835:     // Set last Click time on MouseDown only
 29835:     sLastMouseDownTime = curMsgTime;
 29835:   }
 29835:   else if (aEventType == NS_MOUSE_MOVE && !insideMovementThreshold) {
 29835:     sLastClickCount = 0;
 29835:   }
 29835:   else if (aEventType == NS_MOUSE_EXIT) {
 29835:     event.exit = IsTopLevelMouseExit(mWnd) ? nsMouseEvent::eTopLevel : nsMouseEvent::eChild;
 29835:   }
 46334:   else if (aEventType == NS_MOUSE_MOZHITTEST)
 46334:   {
126039:     event.mFlags.mOnlyChromeDispatch = true;
 46334:   }
 29835:   event.clickCount = sLastClickCount;
 29835: 
 29835: #ifdef NS_DEBUG_XX
 76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
 76714:          ("Msg Time: %d Click Count: %d\n", curMsgTime, event.clickCount));
 29835: #endif
 29835: 
 32799:   NPEvent pluginEvent;
 29835: 
 29835:   switch (aEventType)
 29835:   {
 29835:     case NS_MOUSE_BUTTON_DOWN:
 29835:       switch (aButton) {
 29835:         case nsMouseEvent::eLeftButton:
 29835:           pluginEvent.event = WM_LBUTTONDOWN;
 29835:           break;
 29835:         case nsMouseEvent::eMiddleButton:
 29835:           pluginEvent.event = WM_MBUTTONDOWN;
 29835:           break;
 29835:         case nsMouseEvent::eRightButton:
 29835:           pluginEvent.event = WM_RBUTTONDOWN;
 29835:           break;
 29835:         default:
 29835:           break;
 29835:       }
 29835:       break;
 29835:     case NS_MOUSE_BUTTON_UP:
 29835:       switch (aButton) {
 29835:         case nsMouseEvent::eLeftButton:
 29835:           pluginEvent.event = WM_LBUTTONUP;
 29835:           break;
 29835:         case nsMouseEvent::eMiddleButton:
 29835:           pluginEvent.event = WM_MBUTTONUP;
 29835:           break;
 29835:         case nsMouseEvent::eRightButton:
 29835:           pluginEvent.event = WM_RBUTTONUP;
 29835:           break;
 29835:         default:
 29835:           break;
 29835:       }
 29835:       break;
 29835:     case NS_MOUSE_DOUBLECLICK:
 29835:       switch (aButton) {
 29835:         case nsMouseEvent::eLeftButton:
 29835:           pluginEvent.event = WM_LBUTTONDBLCLK;
 29835:           break;
 29835:         case nsMouseEvent::eMiddleButton:
 29835:           pluginEvent.event = WM_MBUTTONDBLCLK;
 29835:           break;
 29835:         case nsMouseEvent::eRightButton:
 29835:           pluginEvent.event = WM_RBUTTONDBLCLK;
 29835:           break;
 29835:         default:
 29835:           break;
 29835:       }
 29835:       break;
 29835:     case NS_MOUSE_MOVE:
 29835:       pluginEvent.event = WM_MOUSEMOVE;
 29835:       break;
 37167:     case NS_MOUSE_EXIT:
 37167:       pluginEvent.event = WM_MOUSELEAVE;
 37167:       break;
 29835:     default:
 29835:       pluginEvent.event = WM_NULL;
 29835:       break;
 29835:   }
 29835: 
 29835:   pluginEvent.wParam = wParam;     // plugins NEED raw OS event flags!
 29835:   pluginEvent.lParam = lParam;
 29835: 
 34743:   event.pluginEvent = (void *)&pluginEvent;
 29835: 
 29835:   // call the event callback
108460:   if (mWidgetListener) {
 29835:     if (nsToolkit::gMouseTrailer)
 29835:       nsToolkit::gMouseTrailer->Disable();
 29835:     if (aEventType == NS_MOUSE_MOVE) {
 60909:       if (nsToolkit::gMouseTrailer && !sIsInMouseCapture) {
 29835:         nsToolkit::gMouseTrailer->SetMouseTrailerWindow(mWnd);
 29835:       }
 29835:       nsIntRect rect;
 29835:       GetBounds(rect);
 29835:       rect.x = 0;
 29835:       rect.y = 0;
 29835: 
 29835:       if (rect.Contains(event.refPoint)) {
 29835:         if (sCurrentWindow == NULL || sCurrentWindow != this) {
106838:           if ((nullptr != sCurrentWindow) && (!sCurrentWindow->mInDtor)) {
 29835:             LPARAM pos = sCurrentWindow->lParamToClient(lParamToScreen(lParam));
 79626:             sCurrentWindow->DispatchMouseEvent(NS_MOUSE_EXIT, wParam, pos, false, 
 40485:                                                nsMouseEvent::eLeftButton, aInputSource);
 29835:           }
 29835:           sCurrentWindow = this;
 30223:           if (!mInDtor) {
 29835:             LPARAM pos = sCurrentWindow->lParamToClient(lParamToScreen(lParam));
 79626:             sCurrentWindow->DispatchMouseEvent(NS_MOUSE_ENTER, wParam, pos, false,
 40485:                                                nsMouseEvent::eLeftButton, aInputSource);
 29835:           }
 29835:         }
 29835:       }
 29835:     } else if (aEventType == NS_MOUSE_EXIT) {
 29835:       if (sCurrentWindow == this) {
106838:         sCurrentWindow = nullptr;
 29835:       }
 29835:     }
 29835: 
 29835:     result = DispatchWindowEvent(&event);
 29835: 
 29835:     if (nsToolkit::gMouseTrailer)
 29835:       nsToolkit::gMouseTrailer->Enable();
 29835: 
 29835:     // Release the widget with NS_IF_RELEASE() just in case
 29835:     // the context menu key code in nsEventListenerManager::HandleEvent()
 29835:     // released it already.
 29835:     return result;
 29835:   }
 29835: 
 29835:   return result;
 29835: }
 29835: 
120269: void nsWindow::DispatchFocusToTopLevelWindow(bool aIsActivate)
120269: {
120269:   if (aIsActivate)
120269:     sJustGotActivate = false;
120269:   sJustGotDeactivate = false;
120269: 
120269:   // retrive the toplevel window or dialog
120269:   HWND curWnd = mWnd;
 35499:   HWND toplevelWnd = NULL;
120269:   while (curWnd) {
120269:     toplevelWnd = curWnd;
120269: 
120269:     nsWindow *win = WinUtils::GetNSWindowPtr(curWnd);
 35499:     if (win) {
 35499:       nsWindowType wintype;
 35499:       win->GetWindowType(wintype);
 35499:       if (wintype == eWindowType_toplevel || wintype == eWindowType_dialog)
 35499:         break;
 35499:     }
 35499: 
120269:     curWnd = ::GetParent(curWnd); // Parent or owner (if has no parent)
120269:   }
120269: 
 29835:   if (toplevelWnd) {
 86569:     nsWindow *win = WinUtils::GetNSWindowPtr(toplevelWnd);
122223:     if (win && win->mWidgetListener) {
122223:       if (aIsActivate) {
122223:         win->mWidgetListener->WindowActivated();
122223:       } else {
122223:         if (!win->BlurEventsSuppressed()) {
122223:           win->mWidgetListener->WindowDeactivated();
122223:         }
122223:       }
108457:     }
108457:   }
 29835: }
 29835: 
 79445: bool nsWindow::IsTopLevelMouseExit(HWND aWnd)
 29835: {
 29835:   DWORD pos = ::GetMessagePos();
 29835:   POINT mp;
 29835:   mp.x = GET_X_LPARAM(pos);
 29835:   mp.y = GET_Y_LPARAM(pos);
 29835:   HWND mouseWnd = ::WindowFromPoint(mp);
 29835: 
 86569:   // WinUtils::GetTopLevelHWND() will return a HWND for the window frame
 86569:   // (which includes the non-client area).  If the mouse has moved into
 86569:   // the non-client area, we should treat it as a top-level exit.
 86569:   HWND mouseTopLevel = WinUtils::GetTopLevelHWND(mouseWnd);
 29835:   if (mouseWnd == mouseTopLevel)
 79626:     return true;
 29835: 
 86569:   return WinUtils::GetTopLevelHWND(aWnd) != mouseTopLevel;
 29835: }
 29835: 
120269: bool nsWindow::BlurEventsSuppressed()
120269: {
120269:   // are they suppressed in this window?
120269:   if (mBlurSuppressLevel > 0)
120269:     return true;
120269: 
120269:   // are they suppressed by any container widget?
120269:   HWND parentWnd = ::GetParent(mWnd);
120269:   if (parentWnd) {
120269:     nsWindow *parent = WinUtils::GetNSWindowPtr(parentWnd);
120269:     if (parent)
120269:       return parent->BlurEventsSuppressed();
120269:   }
120269:   return false;
120269: }
120269: 
120269: // In some circumstances (opening dependent windows) it makes more sense
120269: // (and fixes a crash bug) to not blur the parent window. Called from
120269: // nsFilePicker.
120269: void nsWindow::SuppressBlurEvents(bool aSuppress)
120269: {
120269:   if (aSuppress)
120269:     ++mBlurSuppressLevel; // for this widget
120269:   else {
120269:     NS_ASSERTION(mBlurSuppressLevel > 0, "unbalanced blur event suppression");
120269:     if (mBlurSuppressLevel > 0)
120269:       --mBlurSuppressLevel;
120269:   }
120269: }
120269: 
 79445: bool nsWindow::ConvertStatus(nsEventStatus aStatus)
 29835: {
 29835:   return aStatus == nsEventStatus_eConsumeNoDefault;
 29835: }
 29835: 
 29835: /**************************************************************
 38103:  *
 38103:  * SECTION: IPC
 38103:  *
 38103:  * IPC related helpers.
 38103:  *
 38103:  **************************************************************/
 38103: 
 38103: // static
 38103: bool
 38103: nsWindow::IsAsyncResponseEvent(UINT aMsg, LRESULT& aResult)
 38103: {
 38103:   switch(aMsg) {
 38103:     case WM_SETFOCUS:
 38103:     case WM_KILLFOCUS:
 38103:     case WM_ENABLE:
 38103:     case WM_WINDOWPOSCHANGING:
 38103:     case WM_WINDOWPOSCHANGED:
 38103:     case WM_PARENTNOTIFY:
 38103:     case WM_ACTIVATEAPP:
 38103:     case WM_NCACTIVATE:
 38103:     case WM_ACTIVATE:
 38103:     case WM_CHILDACTIVATE:
 38103:     case WM_IME_SETCONTEXT:
 38103:     case WM_IME_NOTIFY:
 38103:     case WM_SHOWWINDOW:
 38103:     case WM_CANCELMODE:
 38103:     case WM_MOUSEACTIVATE:
 39729:     case WM_CONTEXTMENU:
 38103:       aResult = 0;
 38103:     return true;
 38103: 
 38103:     case WM_SETTINGCHANGE:
 38103:     case WM_SETCURSOR:
 38103:     return false;
 38103:   }
 38103: 
 38103: #ifdef DEBUG
 38103:   char szBuf[200];
 38103:   sprintf(szBuf,
 38103:     "An unhandled ISMEX_SEND message was received during spin loop! (%X)", aMsg);
 38103:   NS_WARNING(szBuf);
 38103: #endif
 38103: 
 38103:   return false;
 38103: }
 38103: 
 38103: void
 38400: nsWindow::IPCWindowProcHandler(UINT& msg, WPARAM& wParam, LPARAM& lParam)
 38103: {
 38103:   NS_ASSERTION(!mozilla::ipc::SyncChannel::IsPumpingMessages(),
 38103:                "Failed to prevent a nonqueued message from running!");
 38400: 
 39241:   // Modal UI being displayed in windowless plugins.
 39241:   if (mozilla::ipc::RPCChannel::IsSpinLoopActive() &&
 39241:       (InSendMessageEx(NULL)&(ISMEX_REPLIED|ISMEX_SEND)) == ISMEX_SEND) {
 39241:     LRESULT res;
 39241:     if (IsAsyncResponseEvent(msg, res)) {
 39241:       ReplyMessage(res);
 39241:     }
 39241:     return;
 39241:   }
 39241: 
 39241:   // Handle certain sync plugin events sent to the parent which
 39241:   // trigger ipc calls that result in deadlocks.
 39241: 
 40964:   DWORD dwResult = 0;
 79445:   bool handled = false;
 40964: 
 40964:   switch(msg) {
 39241:     // Windowless flash sending WM_ACTIVATE events to the main window
 39241:     // via calls to ShowWindow.
 40964:     case WM_ACTIVATE:
 40964:       if (lParam != 0 && LOWORD(wParam) == WA_ACTIVE &&
 63933:           IsWindow((HWND)lParam)) {
 63933:         // Check for Adobe Reader X sync activate message from their
 63933:         // helper window and ignore. Fixes an annoying focus problem.
 63933:         if ((InSendMessageEx(NULL)&(ISMEX_REPLIED|ISMEX_SEND)) == ISMEX_SEND) {
 63933:           PRUnichar szClass[10];
 63933:           HWND focusWnd = (HWND)lParam;
 63933:           if (IsWindowVisible(focusWnd) &&
 63933:               GetClassNameW(focusWnd, szClass,
 63933:                             sizeof(szClass)/sizeof(PRUnichar)) &&
 63933:               !wcscmp(szClass, L"Edit") &&
 86569:               !WinUtils::IsOurProcessWindow(focusWnd)) {
 63933:             break;
 63933:           }
 63933:         }
 79626:         handled = true;
 63933:       }
 40964:     break;
 40964:     // Plugins taking or losing focus triggering focus app messages.
 40964:     case WM_SETFOCUS:
 40964:     case WM_KILLFOCUS:
 39241:     // Windowed plugins that pass sys key events to defwndproc generate
 39241:     // WM_SYSCOMMAND events to the main window.
 40964:     case WM_SYSCOMMAND:
 40964:     // Windowed plugins that fire context menu selection events to parent
 40964:     // windows.
 40964:     case WM_CONTEXTMENU:
 42381:     // IME events fired as a result of synchronous focus changes
 42381:     case WM_IME_SETCONTEXT:
 79626:       handled = true;
 40964:     break;
 40964:   }
 40964: 
 40964:   if (handled &&
 39241:       (InSendMessageEx(NULL)&(ISMEX_REPLIED|ISMEX_SEND)) == ISMEX_SEND) {
 40964:     ReplyMessage(dwResult);
 39037:   }
 38103: }
 38103: 
 38103: /**************************************************************
 29835:  **************************************************************
 29835:  **
 29835:  ** BLOCK: Native events
 29835:  **
 29835:  ** Main Windows message handlers and OnXXX handlers for
 29835:  ** Windows event handling.
 29835:  **
 29835:  **************************************************************
 29835:  **************************************************************/
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: Wind proc.
 29835:  *
 29835:  * The main Windows event procedures and associated
 29835:  * message processing methods.
 29835:  *
 29835:  **************************************************************/
 29835: 
 79445: static bool
108991: DisplaySystemMenu(HWND hWnd, nsSizeMode sizeMode, bool isRtl, int32_t x, int32_t y)
 56383: {
 56383:   HMENU hMenu = GetSystemMenu(hWnd, FALSE);
 56383:   if (hMenu) {
 69677:     MENUITEMINFO mii;
 69677:     mii.cbSize = sizeof(MENUITEMINFO);
 69677:     mii.fMask = MIIM_STATE;
 69677:     mii.fType = 0;
 69677: 
 56383:     // update the options
 69677:     mii.fState = MF_ENABLED;
 69677:     SetMenuItemInfo(hMenu, SC_RESTORE, FALSE, &mii);
 69677:     SetMenuItemInfo(hMenu, SC_SIZE, FALSE, &mii);
 69677:     SetMenuItemInfo(hMenu, SC_MOVE, FALSE, &mii);
 69677:     SetMenuItemInfo(hMenu, SC_MAXIMIZE, FALSE, &mii);
 69677:     SetMenuItemInfo(hMenu, SC_MINIMIZE, FALSE, &mii);
 69677: 
 69677:     mii.fState = MF_GRAYED;
 56383:     switch(sizeMode) {
 56383:       case nsSizeMode_Fullscreen:
 72140:         SetMenuItemInfo(hMenu, SC_RESTORE, FALSE, &mii);
 56383:         // intentional fall through
 56383:       case nsSizeMode_Maximized:
 69677:         SetMenuItemInfo(hMenu, SC_SIZE, FALSE, &mii);
 69677:         SetMenuItemInfo(hMenu, SC_MOVE, FALSE, &mii);
 69677:         SetMenuItemInfo(hMenu, SC_MAXIMIZE, FALSE, &mii);
 56383:         break;
 56383:       case nsSizeMode_Minimized:
 69677:         SetMenuItemInfo(hMenu, SC_MINIMIZE, FALSE, &mii);
 56383:         break;
 56383:       case nsSizeMode_Normal:
 69677:         SetMenuItemInfo(hMenu, SC_RESTORE, FALSE, &mii);
 56383:         break;
 56383:     }
 56383:     LPARAM cmd =
 56383:       TrackPopupMenu(hMenu,
 56383:                      (TPM_LEFTBUTTON|TPM_RIGHTBUTTON|
 56383:                       TPM_RETURNCMD|TPM_TOPALIGN|
 56383:                       (isRtl ? TPM_RIGHTALIGN : TPM_LEFTALIGN)),
 56383:                      x, y, 0, hWnd, NULL);
 56383:     if (cmd) {
 56383:       PostMessage(hWnd, WM_SYSCOMMAND, cmd, 0);
 79626:       return true;
 79626:     }
 79626:   }
 79626:   return false;
 56383: }
 56383: 
119111: inline static mozilla::HangMonitor::ActivityType ActivityTypeForMessage(UINT msg)
119111: {
119111:   if ((msg >= WM_KEYFIRST && msg <= WM_IME_KEYLAST) ||
119111:       (msg >= WM_MOUSEFIRST && msg <= WM_MOUSELAST) ||
119111:       (msg >= MOZ_WM_MOUSEWHEEL_FIRST && msg <= MOZ_WM_MOUSEWHEEL_LAST) ||
119111:       (msg >= NS_WM_IMEFIRST && msg <= NS_WM_IMELAST)) {
119111:     return mozilla::HangMonitor::kUIActivity;
119111:   }
119111: 
119111:   // This may not actually be right, but we don't want to reset the timer if
119111:   // we're not actually processing a UI message.
119111:   return mozilla::HangMonitor::kActivityUIAVail;
119111: }
119111: 
 50680: // The WndProc procedure for all nsWindows in this toolkit. This merely catches
 50681: // exceptions and passes the real work to WindowProcInternal. See bug 587406
 50681: // and http://msdn.microsoft.com/en-us/library/ms633573%28VS.85%29.aspx
 29835: LRESULT CALLBACK nsWindow::WindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
 29835: {
119111:   HangMonitor::NotifyActivity(ActivityTypeForMessage(msg));
119111: 
 62476:   return mozilla::CallWindowProcCrashProtected(WindowProcInternal, hWnd, msg, wParam, lParam);
 50680: }
 50680: 
 50680: LRESULT CALLBACK nsWindow::WindowProcInternal(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
 50680: {
 59750:   if (::GetWindowLongPtrW(hWnd, GWLP_ID) == eFakeTrackPointScrollableID) {
 59750:     // This message was sent to the FAKETRACKPOINTSCROLLABLE.
 59750:     if (msg == WM_HSCROLL) {
 59750:       // Route WM_HSCROLL messages to the main window.
 59750:       hWnd = ::GetParent(::GetParent(hWnd));
 59750:     } else {
 59750:       // Handle all other messages with its original window procedure.
 59750:       WNDPROC prevWindowProc = (WNDPROC)::GetWindowLongPtr(hWnd, GWLP_USERDATA);
 59750:       return ::CallWindowProcW(prevWindowProc, hWnd, msg, wParam, lParam);
 59750:     }
 59750:   }
 59750: 
 68748:   if (msg == MOZ_WM_TRACE) {
 68748:     // This is a tracer event for measuring event loop latency.
 68748:     // See WidgetTraceEvent.cpp for more details.
 68748:     mozilla::SignalTracerThread();
 68748:     return 0;
 68748:   }
 68748: 
 38400:   // Get the window which caused the event and ask it to process the message
125942:   nsWindow *targetWindow = WinUtils::GetNSWindowPtr(hWnd);
125942:   NS_ASSERTION(targetWindow, "nsWindow* is null!");
125942:   if (!targetWindow)
125942:     return ::DefWindowProcW(hWnd, msg, wParam, lParam);
125942: 
125942:   // Hold the window for the life of this method, in case it gets
125942:   // destroyed during processing, unless we're in the dtor already.
125942:   nsCOMPtr<nsISupports> kungFuDeathGrip;
125942:   if (!targetWindow->mInDtor)
125942:     kungFuDeathGrip = do_QueryInterface((nsBaseWidget*)targetWindow);
125942: 
125942:   targetWindow->IPCWindowProcHandler(msg, wParam, lParam);
125942: 
125942:   // Create this here so that we store the last rolled up popup until after
 29835:   // the event has been processed.
 29835:   nsAutoRollup autoRollup;
 29835: 
 29835:   LRESULT popupHandlingResult;
 29835:   if (DealWithPopups(hWnd, msg, wParam, lParam, &popupHandlingResult))
 29835:     return popupHandlingResult;
 29835: 
 29835:   // Call ProcessMessage
 29835:   LRESULT retValue;
125942:   if (targetWindow->ProcessMessage(msg, wParam, lParam, &retValue)) {
 29835:     return retValue;
 29835:   }
 38401: 
125942:   LRESULT res = ::CallWindowProcW(targetWindow->GetPrevWindowProc(),
 29835:                                   hWnd, msg, wParam, lParam);
 38401: 
 38401:   return res;
 29835: }
 29835: 
 29835: // The main windows message processing method for plugins.
 29835: // The result means whether this method processed the native
 29835: // event for plugin. If false, the native event should be
 29835: // processed by the caller self.
 79445: bool
 29835: nsWindow::ProcessMessageForPlugin(const MSG &aMsg,
 29835:                                   LRESULT *aResult,
 79445:                                   bool &aCallDefWndProc)
 29835: {
 29835:   NS_PRECONDITION(aResult, "aResult must be non-null.");
 29835:   *aResult = 0;
 29835: 
 79626:   aCallDefWndProc = false;
 79445:   bool eventDispatched = false;
 29835:   switch (aMsg.message) {
 29835:     case WM_CHAR:
 29835:     case WM_SYSCHAR:
 29835:       *aResult = ProcessCharMessage(aMsg, &eventDispatched);
 29835:       break;
 29835: 
 29835:     case WM_KEYUP:
 29835:     case WM_SYSKEYUP:
 29835:       *aResult = ProcessKeyUpMessage(aMsg, &eventDispatched);
 29835:       break;
 29835: 
 29835:     case WM_KEYDOWN:
 29835:     case WM_SYSKEYDOWN:
 29835:       *aResult = ProcessKeyDownMessage(aMsg, &eventDispatched);
 29835:       break;
 29835: 
 29835:     case WM_DEADCHAR:
 29835:     case WM_SYSDEADCHAR:
 29835: 
 29835:     case WM_CUT:
 29835:     case WM_COPY:
 29835:     case WM_PASTE:
 29835:     case WM_CLEAR:
 29835:     case WM_UNDO:
 29835:       break;
 29835: 
 29835:     default:
 79626:       return false;
 29835:   }
 29835: 
 29835:   if (!eventDispatched)
 29835:     aCallDefWndProc = !DispatchPluginEvent(aMsg);
 29835:   DispatchPendingEvents();
 79626:   return true;
 29835: }
 29835: 
 71484: static void ForceFontUpdate()
 71484: {
 71484:   // update device context font cache
 71484:   // Dirty but easiest way:
 71484:   // Changing nsIPrefBranch entry which triggers callbacks
 71484:   // and flows into calling mDeviceContext->FlushFontCache()
 71484:   // to update the font cache in all the instance of Browsers
 71484:   static const char kPrefName[] = "font.internaluseonly.changed";
 79445:   bool fontInternalChange =
 79445:     Preferences::GetBool(kPrefName, false);
 71484:   Preferences::SetBool(kPrefName, !fontInternalChange);
 71484: }
 71484: 
 79445: static bool CleartypeSettingChanged()
 71484: {
 71484:   static int currentQuality = -1;
 71484:   BYTE quality = cairo_win32_get_system_text_quality();
 71484: 
 71484:   if (currentQuality == quality)
 79626:     return false;
 71484: 
 71484:   if (currentQuality < 0) {
 71484:     currentQuality = quality;
 79626:     return false;
 71484:   }
 71484:   currentQuality = quality;
 79626:   return true;
 71484: }
 71484: 
 29835: // The main windows message processing method.
 79445: bool nsWindow::ProcessMessage(UINT msg, WPARAM &wParam, LPARAM &lParam,
 29835:                                 LRESULT *aRetValue)
 29835: {
 29835:   // (Large blocks of code should be broken out into OnEvent handlers.)
 31532:   if (mWindowHook.Notify(mWnd, msg, wParam, lParam, aRetValue))
 79626:     return true;
 29835: 
 38103: #if defined(EVENT_DEBUG_OUTPUT)
 38103:   // First param shows all events, second param indicates whether
 38103:   // to show mouse move events. See nsWindowDbg for details.
 38103:   PrintEvent(msg, SHOW_REPEAT_EVENTS, SHOW_MOUSEMOVE_EVENTS);
 38103: #endif
 38103: 
 79445:   bool eatMessage;
 29835:   if (nsIMM32Handler::ProcessMessage(this, msg, wParam, lParam, aRetValue,
 29835:                                      eatMessage)) {
 79626:     return mWnd ? eatMessage : true;
 29835:   }
 29835: 
 91613:   if (MouseScrollHandler::ProcessMessage(this, msg, wParam, lParam, aRetValue,
 91613:                                          eatMessage)) {
 91613:     return mWnd ? eatMessage : true;
 91613:   }
 91613: 
 29835:   if (PluginHasFocus()) {
 79445:     bool callDefaultWndProc;
 86569:     MSG nativeMsg = WinUtils::InitMSG(msg, wParam, lParam);
 29835:     if (ProcessMessageForPlugin(nativeMsg, aRetValue, callDefaultWndProc)) {
 79626:       return mWnd ? !callDefaultWndProc : true;
 29835:     }
 29835:   }
 29835: 
 79445:   bool result = false;    // call the default nsWindow proc
 29835:   *aRetValue = 0;
 29835: 
 46200:   // Glass hit testing w/custom transparent margins
 46200:   LRESULT dwmHitResult;
 46200:   if (mCustomNonClient &&
 46200:       nsUXThemeData::CheckForCompositor() &&
 46200:       nsUXThemeData::dwmDwmDefWindowProcPtr(mWnd, msg, wParam, lParam, &dwmHitResult)) {
 46200:     *aRetValue = dwmHitResult;
 79626:     return true;
 46200:   }
 46200: 
 29835:   switch (msg) {
 29835:     // WM_QUERYENDSESSION must be handled by all windows.
 29835:     // Otherwise Windows thinks the window can just be killed at will.
 29835:     case WM_QUERYENDSESSION:
 29835:       if (sCanQuit == TRI_UNKNOWN)
 29835:       {
 29835:         // Ask if it's ok to quit, and store the answer until we
 29835:         // get WM_ENDSESSION signaling the round is complete.
 29835:         nsCOMPtr<nsIObserverService> obsServ =
 41540:           mozilla::services::GetObserverService();
 29835:         nsCOMPtr<nsISupportsPRBool> cancelQuit =
 29835:           do_CreateInstance(NS_SUPPORTS_PRBOOL_CONTRACTID);
 79626:         cancelQuit->SetData(false);
106838:         obsServ->NotifyObservers(cancelQuit, "quit-application-requested", nullptr);
 29835: 
 79445:         bool abortQuit;
 29835:         cancelQuit->GetData(&abortQuit);
 29835:         sCanQuit = abortQuit ? TRI_FALSE : TRI_TRUE;
 29835:       }
 29835:       *aRetValue = sCanQuit ? TRUE : FALSE;
 79626:       result = true;
 29835:       break;
 68855: 
 29835:     case WM_ENDSESSION:
 34610:     case MOZ_WM_APP_QUIT:
 34610:       if (msg == MOZ_WM_APP_QUIT || (wParam == TRUE && sCanQuit == TRI_TRUE))
 29835:       {
 29835:         // Let's fake a shutdown sequence without actually closing windows etc.
 29835:         // to avoid Windows killing us in the middle. A proper shutdown would
 29835:         // require having a chance to pump some messages. Unfortunately
 29835:         // Windows won't let us do that. Bug 212316.
 29835:         nsCOMPtr<nsIObserverService> obsServ =
 41540:           mozilla::services::GetObserverService();
 29835:         NS_NAMED_LITERAL_STRING(context, "shutdown-persist");
106838:         obsServ->NotifyObservers(nullptr, "quit-application-granted", nullptr);
106838:         obsServ->NotifyObservers(nullptr, "quit-application-forced", nullptr);
106838:         obsServ->NotifyObservers(nullptr, "quit-application", nullptr);
106838:         obsServ->NotifyObservers(nullptr, "profile-change-net-teardown", context.get());
106838:         obsServ->NotifyObservers(nullptr, "profile-change-teardown", context.get());
106838:         obsServ->NotifyObservers(nullptr, "profile-before-change", context.get());
 29835:         // Then a controlled but very quick exit.
 29835:         _exit(0);
 29835:       }
 29835:       sCanQuit = TRI_UNKNOWN;
 79626:       result = true;
 29835:       break;
 29835: 
 29835:     case WM_SYSCOLORCHANGE:
 82569:       OnSysColorChanged();
 29835:       break;
 29835: 
 58327:     case WM_THEMECHANGED:
 29835:     {
 46200:       // Update non-client margin offsets 
 46200:       UpdateNonClientMargins();
 58327:       nsUXThemeData::InitTitlebarInfo();
 55268:       nsUXThemeData::UpdateNativeThemeInfo();
 46200: 
108452:       NotifyThemeChanged();
 29835: 
 29835:       // Invalidate the window so that the repaint will
 29835:       // pick up the new theme.
 87336:       Invalidate(true, true, true);
 29835:     }
 29835:     break;
 29835: 
 29835:     case WM_FONTCHANGE:
 29835:     {
126616:       // We only handle this message for the hidden window,
126616:       // as we only need to update the (global) font list once
126616:       // for any given change, not once per window!
126616:       if (mWindowType != eWindowType_invisible) {
126616:         break;
126616:       }
126616: 
 29835:       nsresult rv;
 79445:       bool didChange = false;
 29835: 
 29835:       // update the global font list
 29835:       nsCOMPtr<nsIFontEnumerator> fontEnum = do_GetService("@mozilla.org/gfx/fontenumerator;1", &rv);
 29835:       if (NS_SUCCEEDED(rv)) {
 29835:         fontEnum->UpdateFontList(&didChange);
 71484:         ForceFontUpdate();
 29835:       } //if (NS_SUCCEEDED(rv))
 29835:     }
 29835:     break;
 29835: 
 46200:     case WM_NCCALCSIZE:
 46200:     {
 51380:       if (mCustomNonClient) {
108835:         // If `wParam` is `FALSE`, `lParam` points to a `RECT` that contains
108835:         // the proposed window rectangle for our window.  During our
108835:         // processing of the `WM_NCCALCSIZE` message, we are expected to
108835:         // modify the `RECT` that `lParam` points to, so that its value upon
108835:         // our return is the new client area.  We must return 0 if `wParam`
108835:         // is `FALSE`.
108835:         //
108835:         // If `wParam` is `TRUE`, `lParam` points to a `NCCALCSIZE_PARAMS`
108835:         // struct.  This struct contains an array of 3 `RECT`s, the first of
108835:         // which has the exact same meaning as the `RECT` that is pointed to
108835:         // by `lParam` when `wParam` is `FALSE`.  The remaining `RECT`s, in
108835:         // conjunction with our return value, can
108835:         // be used to specify portions of the source and destination window
108835:         // rectangles that are valid and should be preserved.  We opt not to
108835:         // implement an elaborate client-area preservation technique, and
108835:         // simply return 0, which means "preserve the entire old client area
108835:         // and align it with the upper-left corner of our new client area".
108835:         RECT *clientRect = wParam
108835:                          ? &(reinterpret_cast<NCCALCSIZE_PARAMS*>(lParam))->rgrc[0]
108835:                          : (reinterpret_cast<RECT*>(lParam));
108835:         clientRect->top      += (mCaptionHeight - mNonClientOffset.top);
108835:         clientRect->left     += (mHorResizeMargin - mNonClientOffset.left);
108835:         clientRect->right    -= (mHorResizeMargin - mNonClientOffset.right);
108835:         clientRect->bottom   -= (mVertResizeMargin - mNonClientOffset.bottom);
108835: 
 79626:         result = true;
 46200:         *aRetValue = 0;
 46200:       }
 46200:       break;
 46200:     }
 46200: 
 46200:     case WM_NCHITTEST:
 46200:     {
 46200:       /*
 46200:        * If an nc client area margin has been moved, we are responsible
 46200:        * for calculating where the resize margins are and returning the
 46200:        * appropriate set of hit test constants. DwmDefWindowProc (above)
 46200:        * will handle hit testing on it's command buttons if we are on a
 46200:        * composited desktop.
 46200:        */
 46200: 
 51380:       if (!mCustomNonClient)
 46200:         break;
 46200: 
 46200:       *aRetValue =
 46200:         ClientMarginHitTestPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
 79626:       result = true;
 46200:       break;
 46200:     }
 46200: 
 49251:     case WM_SETTEXT:
 49251:       /*
 49251:        * WM_SETTEXT paints the titlebar area. Avoid this if we have a
 49251:        * custom titlebar we paint ourselves.
 49251:        */
 49251: 
 50350:       if (!mCustomNonClient || mNonClientMargins.top == -1)
 49251:         break;
 49251: 
 49251:       {
 49251:         // From msdn, the way around this is to disable the visible state
 49251:         // temporarily. We need the text to be set but we don't want the
 49251:         // redraw to occur.
 49251:         DWORD style = GetWindowLong(mWnd, GWL_STYLE);
 49251:         SetWindowLong(mWnd, GWL_STYLE, style & ~WS_VISIBLE);
 49251:         *aRetValue = CallWindowProcW(GetPrevWindowProc(), mWnd,
 49251:                                      msg, wParam, lParam);
 49251:         SetWindowLong(mWnd, GWL_STYLE, style);
 79626:         return true;
 49251:       }
 49251: 
 49251:     case WM_NCACTIVATE:
 49251:     {
 49251:       /*
 49251:        * WM_NCACTIVATE paints nc areas. Avoid this and re-route painting
 49251:        * through WM_NCPAINT via InvalidateNonClientRegion.
 49251:        */
 49251: 
 49251:       if (!mCustomNonClient)
 49251:         break;
 49251: 
 49251:       // let the dwm handle nc painting on glass
 49251:       if(nsUXThemeData::CheckForCompositor())
 49251:         break;
 49251: 
 49251:       if (wParam == TRUE) {
 49251:         // going active
 49251:         *aRetValue = FALSE; // ignored
 79626:         result = true;
 79626:         UpdateGetWindowInfoCaptionStatus(true);
 49251:         // invalidate to trigger a paint
 49251:         InvalidateNonClientRegion();
 49251:         break;
 49251:       } else {
 49251:         // going inactive
 49251:         *aRetValue = TRUE; // go ahead and deactive
 79626:         result = true;
 79626:         UpdateGetWindowInfoCaptionStatus(false);
 49251:         // invalidate to trigger a paint
 49251:         InvalidateNonClientRegion();
 49251:         break;
 49251:       }
 49251:     }
 49251: 
 49251:     case WM_NCPAINT:
 49251:     {
 49251:       /*
 49251:        * Reset the non-client paint region so that it excludes the
 49251:        * non-client areas we paint manually. Then call defwndproc
 49251:        * to do the actual painting.
 49251:        */
 49251: 
 49251:       if (!mCustomNonClient)
 49251:         break;
 49251: 
 49251:       // let the dwm handle nc painting on glass
 49251:       if(nsUXThemeData::CheckForCompositor())
 49251:         break;
 49251: 
 49251:       HRGN paintRgn = ExcludeNonClientFromPaintRegion((HRGN)wParam);
 49251:       LRESULT res = CallWindowProcW(GetPrevWindowProc(), mWnd,
 49251:                                     msg, (WPARAM)paintRgn, lParam);
 49251:       if (paintRgn != (HRGN)wParam)
 49251:         DeleteObject(paintRgn);
 49251:       *aRetValue = res;
 79626:       result = true;
 49251:     }
 49251:     break;
 49251: 
 29835:     case WM_POWERBROADCAST:
 29835:       switch (wParam)
 29835:       {
 29835:         case PBT_APMSUSPEND:
 82031:           PostSleepWakeNotification(true);
 29835:           break;
 29835:         case PBT_APMRESUMEAUTOMATIC:
 29835:         case PBT_APMRESUMECRITICAL:
 29835:         case PBT_APMRESUMESUSPEND:
 82031:           PostSleepWakeNotification(false);
 82031:           break;
 29835:       }
 29835:       break;
 29835: 
 29835:     case WM_MOVE: // Window moved
 29835:     {
 48256:       RECT rect;
 48256:       ::GetWindowRect(mWnd, &rect);
 48256:       result = OnMove(rect.left, rect.top);
 29835:     }
 29835:     break;
 29835: 
 29835:     case WM_CLOSE: // close request
108457:       if (mWidgetListener)
108457:         mWidgetListener->RequestWindowClose(this);
 79626:       result = true; // abort window closure
 29835:       break;
 29835: 
 29835:     case WM_DESTROY:
 29835:       // clean up.
 29835:       OnDestroy();
 79626:       result = true;
 29835:       break;
 29835: 
 29835:     case WM_PAINT:
 71484:       if (CleartypeSettingChanged()) {
 71484:         ForceFontUpdate();
 71484:         gfxFontCache *fc = gfxFontCache::GetCache();
 71484:         if (fc) {
 71484:           fc->Flush();
 71484:         }
 71484:       }
 47756:       *aRetValue = (int) OnPaint(NULL, 0);
 79626:       result = true;
 29835:       break;
 29835: 
 29835:     case WM_PRINTCLIENT:
 47756:       result = OnPaint((HDC) wParam, 0);
 29835:       break;
 29835: 
 29835:     case WM_HOTKEY:
 29835:       result = OnHotKey(wParam, lParam);
 29835:       break;
 29835: 
 29835:     case WM_SYSCHAR:
 29835:     case WM_CHAR:
 29835:     {
 86569:       MSG nativeMsg = WinUtils::InitMSG(msg, wParam, lParam);
106838:       result = ProcessCharMessage(nativeMsg, nullptr);
 29835:       DispatchPendingEvents();
 29835:     }
 29835:     break;
 29835: 
 29835:     case WM_SYSKEYUP:
 29835:     case WM_KEYUP:
 29835:     {
 86569:       MSG nativeMsg = WinUtils::InitMSG(msg, wParam, lParam);
 62480:       nativeMsg.time = ::GetMessageTime();
106838:       result = ProcessKeyUpMessage(nativeMsg, nullptr);
 29835:       DispatchPendingEvents();
 29835:     }
 29835:     break;
 29835: 
 29835:     case WM_SYSKEYDOWN:
 29835:     case WM_KEYDOWN:
 29835:     {
 86569:       MSG nativeMsg = WinUtils::InitMSG(msg, wParam, lParam);
106838:       result = ProcessKeyDownMessage(nativeMsg, nullptr);
 29835:       DispatchPendingEvents();
 29835:     }
 29835:     break;
 29835: 
 29835:     // say we've dealt with erase background if widget does
 29835:     // not need auto-erasing
 29835:     case WM_ERASEBKGND:
 32194:       if (!AutoErase((HDC)wParam)) {
 29835:         *aRetValue = 1;
 79626:         result = true;
 29835:       }
 29835:       break;
 29835: 
 29835:     case WM_MOUSEMOVE:
 29835:     {
 79626:       mMousePresent = true;
 59195: 
 29835:       // Suppress dispatch of pending events
 29835:       // when mouse moves are generated by widget
 29835:       // creation instead of user input.
 29835:       LPARAM lParamScreen = lParamToScreen(lParam);
 29835:       POINT mp;
 29835:       mp.x      = GET_X_LPARAM(lParamScreen);
 29835:       mp.y      = GET_Y_LPARAM(lParamScreen);
 79445:       bool userMovedMouse = false;
 29835:       if ((sLastMouseMovePoint.x != mp.x) || (sLastMouseMovePoint.y != mp.y)) {
 79626:         userMovedMouse = true;
 29835:       }
 29835: 
 40485:       result = DispatchMouseEvent(NS_MOUSE_MOVE, wParam, lParam,
 79626:                                   false, nsMouseEvent::eLeftButton, MOUSE_INPUT_SOURCE());
 29835:       if (userMovedMouse) {
 29835:         DispatchPendingEvents();
 29835:       }
 29835:     }
 29835:     break;
 29835: 
 59195:     case WM_NCMOUSEMOVE:
 59195:       // If we receive a mouse move event on non-client chrome, make sure and
 59195:       // send an NS_MOUSE_EXIT event as well.
 60909:       if (mMousePresent && !sIsInMouseCapture)
 59195:         SendMessage(mWnd, WM_MOUSELEAVE, 0, 0);
 59195:     break;
 59195: 
 29835:     case WM_LBUTTONDOWN:
 29835:     {
 29835:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, wParam, lParam,
 79626:                                   false, nsMouseEvent::eLeftButton, MOUSE_INPUT_SOURCE());
 29835:       DispatchPendingEvents();
 29835:     }
 29835:     break;
 29835: 
 29835:     case WM_LBUTTONUP:
 29835:     {
 29835:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_UP, wParam, lParam,
 79626:                                   false, nsMouseEvent::eLeftButton, MOUSE_INPUT_SOURCE());
 29835:       DispatchPendingEvents();
 68855:     }
 68855:     break;
 68855: 
 29835:     case WM_MOUSELEAVE:
 29835:     {
 59195:       if (!mMousePresent)
 59195:         break;
 79626:       mMousePresent = false;
 59195: 
 29835:       // We need to check mouse button states and put them in for
 29835:       // wParam.
 29835:       WPARAM mouseState = (GetKeyState(VK_LBUTTON) ? MK_LBUTTON : 0)
 29835:         | (GetKeyState(VK_MBUTTON) ? MK_MBUTTON : 0)
 29835:         | (GetKeyState(VK_RBUTTON) ? MK_RBUTTON : 0);
 29835:       // Synthesize an event position because we don't get one from
 29835:       // WM_MOUSELEAVE.
 29835:       LPARAM pos = lParamToClient(::GetMessagePos());
 79626:       DispatchMouseEvent(NS_MOUSE_EXIT, mouseState, pos, false,
 40485:                          nsMouseEvent::eLeftButton, MOUSE_INPUT_SOURCE());
 29835:     }
 29835:     break;
 29835: 
 29835:     case WM_CONTEXTMENU:
 29835:     {
 29835:       // if the context menu is brought up from the keyboard, |lParam|
 48920:       // will be -1.
 29835:       LPARAM pos;
 79445:       bool contextMenukey = false;
 48920:       if (lParam == -1)
 29835:       {
 79626:         contextMenukey = true;
 29835:         pos = lParamToClient(GetMessagePos());
 29835:       }
 29835:       else
 29835:       {
 29835:         pos = lParamToClient(lParam);
 29835:       }
 40485: 
 29835:       result = DispatchMouseEvent(NS_CONTEXTMENU, wParam, pos, contextMenukey,
 29835:                                   contextMenukey ?
 29835:                                     nsMouseEvent::eLeftButton :
 40485:                                     nsMouseEvent::eRightButton, MOUSE_INPUT_SOURCE());
 55157:       if (lParam != -1 && !result && mCustomNonClient &&
 55157:           DispatchMouseEvent(NS_MOUSE_MOZHITTEST, wParam, pos,
 79626:                              false, nsMouseEvent::eLeftButton,
 55063:                              MOUSE_INPUT_SOURCE())) {
 55063:         // Blank area hit, throw up the system menu.
 56383:         DisplaySystemMenu(mWnd, mSizeMode, mIsRTL, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
 79626:         result = true;
 55157:       }
 55157:     }
 55157:     break;
 55157: 
 55157:     case WM_LBUTTONDBLCLK:
 79626:       result = DispatchMouseEvent(NS_MOUSE_DOUBLECLICK, wParam, lParam, false,
 55157:                                   nsMouseEvent::eLeftButton, MOUSE_INPUT_SOURCE());
 55157:       DispatchPendingEvents();
 55157:       break;
 55157: 
 55157:     case WM_MBUTTONDOWN:
 79626:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, wParam, lParam, false,
 55157:                                   nsMouseEvent::eMiddleButton, MOUSE_INPUT_SOURCE());
 55157:       DispatchPendingEvents();
 55157:       break;
 55157: 
 55157:     case WM_MBUTTONUP:
 79626:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_UP, wParam, lParam, false,
 55157:                                   nsMouseEvent::eMiddleButton, MOUSE_INPUT_SOURCE());
 55157:       DispatchPendingEvents();
 55157:       break;
 55157: 
 55157:     case WM_MBUTTONDBLCLK:
 79626:       result = DispatchMouseEvent(NS_MOUSE_DOUBLECLICK, wParam, lParam, false,
 55157:                                   nsMouseEvent::eMiddleButton, MOUSE_INPUT_SOURCE());
 55157:       DispatchPendingEvents();
 55157:       break;
 55157: 
 55157:     case WM_NCMBUTTONDOWN:
 79626:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, 0, lParamToClient(lParam), false,
 55157:                                   nsMouseEvent::eMiddleButton, MOUSE_INPUT_SOURCE());
 55157:       DispatchPendingEvents();
 55157:       break;
 55157: 
 55157:     case WM_NCMBUTTONUP:
 79626:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_UP, 0, lParamToClient(lParam), false,
 55157:                                   nsMouseEvent::eMiddleButton, MOUSE_INPUT_SOURCE());
 55157:       DispatchPendingEvents();
 55157:       break;
 55157: 
 55157:     case WM_NCMBUTTONDBLCLK:
 79626:       result = DispatchMouseEvent(NS_MOUSE_DOUBLECLICK, 0, lParamToClient(lParam), false,
 55157:                                   nsMouseEvent::eMiddleButton, MOUSE_INPUT_SOURCE());
 55157:       DispatchPendingEvents();
 55157:       break;
 55157: 
 55157:     case WM_RBUTTONDOWN:
 79626:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, wParam, lParam, false,
 55157:                                   nsMouseEvent::eRightButton, MOUSE_INPUT_SOURCE());
 55157:       DispatchPendingEvents();
 55157:       break;
 55157: 
 55157:     case WM_RBUTTONUP:
 79626:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_UP, wParam, lParam, false,
 40485:                                   nsMouseEvent::eRightButton, MOUSE_INPUT_SOURCE());
 29835:       DispatchPendingEvents();
 29835:       break;
 29835: 
 29835:     case WM_RBUTTONDBLCLK:
 79626:       result = DispatchMouseEvent(NS_MOUSE_DOUBLECLICK, wParam, lParam, false,
 40485:                                   nsMouseEvent::eRightButton, MOUSE_INPUT_SOURCE());
 55157:       DispatchPendingEvents();
 29835:       break;
 29835: 
 46334:     case WM_NCRBUTTONDOWN:
 46334:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, 0, lParamToClient(lParam), 
 79626:                                   false, nsMouseEvent::eRightButton,
 46334:                                   MOUSE_INPUT_SOURCE());
 46334:       DispatchPendingEvents();
 46334:       break;
 46334: 
 46334:     case WM_NCRBUTTONUP:
 46334:       result = DispatchMouseEvent(NS_MOUSE_BUTTON_UP, 0, lParamToClient(lParam),
 79626:                                   false, nsMouseEvent::eRightButton,
 46334:                                   MOUSE_INPUT_SOURCE());
 46334:       DispatchPendingEvents();
 46334:       break;
 46334: 
 46334:     case WM_NCRBUTTONDBLCLK:
 46334:       result = DispatchMouseEvent(NS_MOUSE_DOUBLECLICK, 0, lParamToClient(lParam),
 79626:                                   false, nsMouseEvent::eRightButton,
 46334:                                   MOUSE_INPUT_SOURCE());
 55157:       DispatchPendingEvents();
 55157:       break;
 46334: 
 63936:     case WM_EXITSIZEMOVE:
 63936:       if (!sIsInMouseCapture) {
108452:         NotifySizeMoveDone();
 63936:       }
 63936:       break;
 63936: 
 71877:     case WM_NCLBUTTONDBLCLK:
 71877:       DispatchMouseEvent(NS_MOUSE_DOUBLECLICK, 0, lParamToClient(lParam),
 79626:                          false, nsMouseEvent::eLeftButton,
 71877:                          MOUSE_INPUT_SOURCE());
 71877:       result = 
 71877:         DispatchMouseEvent(NS_MOUSE_BUTTON_UP, 0, lParamToClient(lParam),
 79626:                            false, nsMouseEvent::eLeftButton,
 71877:                            MOUSE_INPUT_SOURCE());
 71877:       DispatchPendingEvents();
 71877:       break;
 71877: 
 29835:     case WM_APPCOMMAND:
 29835:     {
108991:       uint32_t appCommand = GET_APPCOMMAND_LPARAM(lParam);
 29835: 
 29835:       switch (appCommand)
 29835:       {
 29835:         case APPCOMMAND_BROWSER_BACKWARD:
 29835:         case APPCOMMAND_BROWSER_FORWARD:
 29835:         case APPCOMMAND_BROWSER_REFRESH:
 29835:         case APPCOMMAND_BROWSER_STOP:
 29835:         case APPCOMMAND_BROWSER_SEARCH:
 29835:         case APPCOMMAND_BROWSER_FAVORITES:
 29835:         case APPCOMMAND_BROWSER_HOME:
127108:         case APPCOMMAND_CLOSE:
127108:         case APPCOMMAND_FIND:
127108:         case APPCOMMAND_HELP:
127108:         case APPCOMMAND_NEW:
127108:         case APPCOMMAND_OPEN:
127108:         case APPCOMMAND_PRINT:
127108:         case APPCOMMAND_SAVE:
127108:         case APPCOMMAND_FORWARD_MAIL:
127108:         case APPCOMMAND_REPLY_TO_MAIL:
127108:         case APPCOMMAND_SEND_MAIL:
127108:           // We shouldn't consume the message always because if we don't handle
127108:           // the message, the sender (typically, utility of keyboard or mouse)
127108:           // may send other key messages which indicate well known shortcut key.
127108:           if (DispatchCommandEvent(appCommand)) {
 29835:             // tell the driver that we handled the event
 29835:             *aRetValue = 1;
 79626:             result = true;
127108:           }
 79626:           break;
 79626:       }
 79626:       // default = false - tell the driver that the event was not handled
 29835:     }
 29835:     break;
 29835: 
 29835:     // The WM_ACTIVATE event is fired when a window is raised or lowered,
 29835:     // and the loword of wParam specifies which. But we don't want to tell
 29835:     // the focus system about this until the WM_SETFOCUS or WM_KILLFOCUS
 29835:     // events are fired. Instead, set either the sJustGotActivate or
108457:     // gJustGotDeactivate flags and activate/deactivate once the focus
108457:     // events arrive.
 29835:     case WM_ACTIVATE:
108460:       if (mWidgetListener) {
108991:         int32_t fActive = LOWORD(wParam);
 29835: 
 29835:         if (WA_INACTIVE == fActive) {
120269:           // when minimizing a window, the deactivation and focus events will
108457:           // be fired in the reverse order. Instead, just deactivate right away.
120269:           if (HIWORD(wParam))
108457:             DispatchFocusToTopLevelWindow(false);
 29835:           else
 79626:             sJustGotDeactivate = true;
 68855: 
 29835:           if (mIsTopWidgetWindow)
 29835:             mLastKeyboardLayout = gKbdLayout.GetLayout();
 29835: 
 29835:         } else {
 29835:           StopFlashing();
 29835: 
 79626:           sJustGotActivate = true;
 79626:           nsMouseEvent event(true, NS_MOUSE_ACTIVATE, this,
 29835:                              nsMouseEvent::eReal);
 29835:           InitEvent(event);
102101:           ModifierKeyState modifierKeyState;
 96889:           modifierKeyState.InitInputEvent(event);
 51212:           DispatchWindowEvent(&event);
 29835:           if (sSwitchKeyboardLayout && mLastKeyboardLayout)
 29835:             ActivateKeyboardLayout(mLastKeyboardLayout, 0);
 68855:         }
 68855:       }
 68855:       break;
 68855:       
 29835:     case WM_MOUSEACTIVATE:
 29835:       if (mWindowType == eWindowType_popup) {
 29835:         // a popup with a parent owner should not be activated when clicked
 29835:         // but should still allow the mouse event to be fired, so the return
 29835:         // value is set to MA_NOACTIVATE. But if the owner isn't the frontmost
 29835:         // window, just use default processing so that the window is activated.
 29835:         HWND owner = ::GetWindow(mWnd, GW_OWNER);
 29835:         if (owner && owner == ::GetForegroundWindow()) {
 29835:           *aRetValue = MA_NOACTIVATE;
 79626:           result = true;
 29835:         }
 29835:       }
 29835:       break;
 29835: 
 29835:     case WM_WINDOWPOSCHANGING:
 29835:     {
 29835:       LPWINDOWPOS info = (LPWINDOWPOS) lParam;
 29835:       OnWindowPosChanging(info);
 29835:     }
 29835:     break;
 29835: 
106923:     case WM_GETMINMAXINFO:
106923:     {
106923:       MINMAXINFO* mmi = (MINMAXINFO*)lParam;
106923:       // Set the constraints. The minimum size should also be constrained to the
106923:       // default window maximum size so that it fits on screen.
106923:       mmi->ptMinTrackSize.x =
108991:         NS_MIN((int32_t)mmi->ptMaxTrackSize.x,
108991:                NS_MAX((int32_t)mmi->ptMinTrackSize.x, mSizeConstraints.mMinSize.width));
106923:       mmi->ptMinTrackSize.y =
108991:         NS_MIN((int32_t)mmi->ptMaxTrackSize.y,
108991:         NS_MAX((int32_t)mmi->ptMinTrackSize.y, mSizeConstraints.mMinSize.height));
108991:       mmi->ptMaxTrackSize.x = NS_MIN((int32_t)mmi->ptMaxTrackSize.x, mSizeConstraints.mMaxSize.width);
108991:       mmi->ptMaxTrackSize.y = NS_MIN((int32_t)mmi->ptMaxTrackSize.y, mSizeConstraints.mMaxSize.height);
106923:     }
106923:     break;
106923: 
 29835:     case WM_SETFOCUS:
 60495:       // If previous focused window isn't ours, it must have received the
 60495:       // redirected message.  So, we should forget it.
 86569:       if (!WinUtils::IsOurProcessWindow(HWND(wParam))) {
 60495:         ForgetRedirectedKeyDownMessage();
 60495:       }
 29835:       if (sJustGotActivate) {
108457:         DispatchFocusToTopLevelWindow(true);
 29835:       }
 29835:       break;
 29835: 
 29835:     case WM_KILLFOCUS:
 89672:       if (sJustGotDeactivate) {
108457:         DispatchFocusToTopLevelWindow(false);
 29835:       }
 29835:       break;
 29835: 
 29835:     case WM_WINDOWPOSCHANGED:
 29835:     {
 29835:       WINDOWPOS *wp = (LPWINDOWPOS)lParam;
 31345:       OnWindowPosChanged(wp, result);
 31347:     }
 29835:     break;
 29835: 
 29835:     case WM_INPUTLANGCHANGEREQUEST:
 29835:       *aRetValue = TRUE;
 79626:       result = false;
 29835:       break;
 29835: 
 29835:     case WM_INPUTLANGCHANGE:
 29835:       result = OnInputLangChange((HKL)lParam);
 29835:       break;
 29835: 
 29835:     case WM_DESTROYCLIPBOARD:
 29835:     {
 29835:       nsIClipboard* clipboard;
 29835:       nsresult rv = CallGetService(kCClipboardCID, &clipboard);
 51212:       if(NS_SUCCEEDED(rv)) {
 29835:         clipboard->EmptyClipboard(nsIClipboard::kGlobalClipboard);
 29835:         NS_RELEASE(clipboard);
 29835:       }
 51212:     }
 29835:     break;
 29835: 
 29835: #ifdef ACCESSIBILITY
 29835:     case WM_GETOBJECT:
 29835:     {
 29835:       *aRetValue = 0;
 73809:       // Do explicit casting to make it working on 64bit systems (see bug 649236
 73809:       // for details).
 73809:       DWORD objId = static_cast<DWORD>(lParam);
 73809:       if (objId == OBJID_CLIENT) { // oleacc.dll will be loaded dynamically
122283:         a11y::Accessible* rootAccessible = GetRootAccessible(); // Held by a11y cache
 29835:         if (rootAccessible) {
 29835:           IAccessible *msaaAccessible = NULL;
 29835:           rootAccessible->GetNativeInterface((void**)&msaaAccessible); // does an addref
 29835:           if (msaaAccessible) {
 29835:             *aRetValue = LresultFromObject(IID_IAccessible, wParam, msaaAccessible); // does an addref
 29835:             msaaAccessible->Release(); // release extra addref
 79626:             result = true;  // We handled the WM_GETOBJECT message
 29835:           }
 29835:         }
 29835:       }
 29835:     }
 29835: #endif
 29835: 
 29835:     case WM_SYSCOMMAND:
 58330:     {
 58330:       WPARAM filteredWParam = (wParam &0xFFF0);
 29835:       // prevent Windows from trimming the working set. bug 76831
 58330:       if (!sTrimOnMinimize && filteredWParam == SC_MINIMIZE) {
 29835:         ::ShowWindow(mWnd, SW_SHOWMINIMIZED);
 79626:         result = true;
 29835:       }
 56383: 
 56383:       // Handle the system menu manually when we're in full screen mode
 56383:       // so we can set the appropriate options.
 58330:       if (filteredWParam == SC_KEYMENU && lParam == VK_SPACE &&
 56383:           mSizeMode == nsSizeMode_Fullscreen) {
 56383:         DisplaySystemMenu(mWnd, mSizeMode, mIsRTL,
 56383:                           MOZ_SYSCONTEXT_X_POS,
 56383:                           MOZ_SYSCONTEXT_Y_POS);
 79626:         result = true;
 56383:       }
 58330:     }
 29835:     break;
 29835: 
 29835:   case WM_DWMCOMPOSITIONCHANGED:
 57844:     // First, update the compositor state to latest one. All other methods
 57844:     // should use same state as here for consistency painting.
 79626:     nsUXThemeData::CheckForCompositor(true);
 57844: 
 46200:     UpdateNonClientMargins();
 57394:     RemovePropW(mWnd, kManageWindowInfoProperty);
 29835:     BroadcastMsg(mWnd, WM_DWMCOMPOSITIONCHANGED);
108452:     NotifyThemeChanged();
 39718:     UpdateGlass();
 87336:     Invalidate(true, true, true);
 29835:     break;
 29835: 
 41071:   case WM_UPDATEUISTATE:
 41071:   {
 41071:     // If the UI state has changed, fire an event so the UI updates the
 41071:     // keyboard cues based on the system setting and how the window was
 41071:     // opened. For example, a dialog opened via a keyboard press on a button
 41071:     // should enable cues, whereas the same dialog opened via a mouse click of
 41071:     // the button should not.
108991:     int32_t action = LOWORD(wParam);
 41071:     if (action == UIS_SET || action == UIS_CLEAR) {
108991:       int32_t flags = HIWORD(wParam);
108455:       UIStateChangeType showAccelerators = UIStateChangeType_NoChange;
108455:       UIStateChangeType showFocusRings = UIStateChangeType_NoChange;
 41071:       if (flags & UISF_HIDEACCEL)
108455:         showAccelerators = (action == UIS_SET) ? UIStateChangeType_Clear : UIStateChangeType_Set;
 41071:       if (flags & UISF_HIDEFOCUS)
108455:         showFocusRings = (action == UIS_SET) ? UIStateChangeType_Clear : UIStateChangeType_Set;
108455:       NotifyUIStateChanged(showAccelerators, showFocusRings);
 41071:     }
 41071: 
 41071:     break;
 41071:   }
 41071: 
 29835:   /* Gesture support events */
 29835:   case WM_TABLET_QUERYSYSTEMGESTURESTATUS:
 29835:     // According to MS samples, this must be handled to enable
 29835:     // rotational support in multi-touch drivers.
 79626:     result = true;
 29835:     *aRetValue = TABLET_ROTATE_GESTURE_ENABLE;
 29835:     break;
 29835: 
 48711:   case WM_TOUCH:
 48711:     result = OnTouch(wParam, lParam);
 48711:     if (result) {
 48711:       *aRetValue = 0;
 48711:     }
 48711:     break;
 48711: 
 29835:   case WM_GESTURE:
 29835:     result = OnGesture(wParam, lParam);
 29835:     break;
 31443: 
 31443:   case WM_GESTURENOTIFY:
 31443:     {
 31443:       if (mWindowType != eWindowType_invisible &&
 51608:           mWindowType != eWindowType_plugin) {
 51608:         // A GestureNotify event is dispatched to decide which single-finger panning
 51608:         // direction should be active (including none) and if pan feedback should
 51608:         // be displayed. Java and plugin windows can make their own calls.
 31443:         GESTURENOTIFYSTRUCT * gestureinfo = (GESTURENOTIFYSTRUCT*)lParam;
 31443:         nsPointWin touchPoint;
 31443:         touchPoint = gestureinfo->ptsLocation;
 31443:         touchPoint.ScreenToClient(mWnd);
 79626:         nsGestureNotifyEvent gestureNotifyEvent(true, NS_GESTURENOTIFY_EVENT_START, this);
 31443:         gestureNotifyEvent.refPoint = touchPoint;
 31443:         nsEventStatus status;
 31443:         DispatchEvent(&gestureNotifyEvent, status);
 31443:         mDisplayPanFeedback = gestureNotifyEvent.displayPanFeedback;
 48711:         if (!mTouchWindow)
 31443:           mGesture.SetWinGestureSupport(mWnd, gestureNotifyEvent.panDirection);
 31443:       }
 79626:       result = false; //should always bubble to DefWindowProc
 31443:     }
 31443:     break;
 29835: 
 31218:     case WM_CLEAR:
 31218:     {
 79626:       nsContentCommandEvent command(true, NS_CONTENT_COMMAND_DELETE, this);
 31218:       DispatchWindowEvent(&command);
 79626:       result = true;
 31218:     }
 31218:     break;
 31218: 
 31218:     case WM_CUT:
 31218:     {
 79626:       nsContentCommandEvent command(true, NS_CONTENT_COMMAND_CUT, this);
 31218:       DispatchWindowEvent(&command);
 79626:       result = true;
 31218:     }
 31218:     break;
 31218: 
 31218:     case WM_COPY:
 31218:     {
 79626:       nsContentCommandEvent command(true, NS_CONTENT_COMMAND_COPY, this);
 31218:       DispatchWindowEvent(&command);
 79626:       result = true;
 31218:     }
 31218:     break;
 31218: 
 31218:     case WM_PASTE:
 31218:     {
 79626:       nsContentCommandEvent command(true, NS_CONTENT_COMMAND_PASTE, this);
 31218:       DispatchWindowEvent(&command);
 79626:       result = true;
 31218:     }
 31218:     break;
 31218: 
 31218:     case EM_UNDO:
 31218:     {
 79626:       nsContentCommandEvent command(true, NS_CONTENT_COMMAND_UNDO, this);
 31218:       DispatchWindowEvent(&command);
 31218:       *aRetValue = (LRESULT)(command.mSucceeded && command.mIsEnabled);
 79626:       result = true;
 31218:     }
 31218:     break;
 31218: 
 31218:     case EM_REDO:
 31218:     {
 79626:       nsContentCommandEvent command(true, NS_CONTENT_COMMAND_REDO, this);
 31218:       DispatchWindowEvent(&command);
 31218:       *aRetValue = (LRESULT)(command.mSucceeded && command.mIsEnabled);
 79626:       result = true;
 31218:     }
 31218:     break;
 31218: 
 31218:     case EM_CANPASTE:
 31218:     {
 31218:       // Support EM_CANPASTE message only when wParam isn't specified or
 31218:       // is plain text format.
 31218:       if (wParam == 0 || wParam == CF_TEXT || wParam == CF_UNICODETEXT) {
 79626:         nsContentCommandEvent command(true, NS_CONTENT_COMMAND_PASTE,
 79626:                                       this, true);
 31218:         DispatchWindowEvent(&command);
 31218:         *aRetValue = (LRESULT)(command.mSucceeded && command.mIsEnabled);
 79626:         result = true;
 31218:       }
 31218:     }
 31218:     break;
 31218: 
 31218:     case EM_CANUNDO:
 31218:     {
 79626:       nsContentCommandEvent command(true, NS_CONTENT_COMMAND_UNDO,
 79626:                                     this, true);
 31218:       DispatchWindowEvent(&command);
 31218:       *aRetValue = (LRESULT)(command.mSucceeded && command.mIsEnabled);
 79626:       result = true;
 31218:     }
 31218:     break;
 31218: 
 31218:     case EM_CANREDO:
 31218:     {
 79626:       nsContentCommandEvent command(true, NS_CONTENT_COMMAND_REDO,
 79626:                                     this, true);
 31218:       DispatchWindowEvent(&command);
 31218:       *aRetValue = (LRESULT)(command.mSucceeded && command.mIsEnabled);
 79626:       result = true;
 31218:     }
 31218:     break;
 31985: 
 29835:     default:
 29835:     {
 29835: #ifdef NS_ENABLE_TSF
 29835:       if (msg == WM_USER_TSF_TEXTCHANGE) {
 29835:         nsTextStore::OnTextChangeMsg();
 29835:       }
 29835: #endif //NS_ENABLE_TSF
 33486:       if (msg == nsAppShell::GetTaskbarButtonCreatedMessage())
 33486:         SetHasTaskbarIconBeenCreated();
 37550:       if (msg == sOOPPPluginFocusEvent) {
 44190:         if (wParam == 1) {
 37550:           // With OOPP, the plugin window exists in another process and is a child of
 37550:           // this window. This window is a placeholder plugin window for the dom. We
 37550:           // receive this event when the child window receives focus. (sent from
 37550:           // PluginInstanceParent.cpp)
 37550:           ::SendMessage(mWnd, WM_MOUSEACTIVATE, 0, 0); // See nsPluginNativeWindowWin.cpp
 44190:         } else {
 44190:           // WM_KILLFOCUS was received by the child process.
 44190:           if (sJustGotDeactivate) {
108457:             DispatchFocusToTopLevelWindow(false);
 44190:           }
 44190:         }
 37550:       }
 29835:     }
 29835:     break;
 29835:   }
 29835: 
 29835:   //*aRetValue = result;
 29835:   if (mWnd) {
 29835:     return result;
 29835:   }
 29835:   else {
 29835:     //Events which caused mWnd destruction and aren't consumed
 29835:     //will crash during the Windows default processing.
 79626:     return true;
 29835:   }
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: Broadcast messaging
 29835:  *
 29835:  * Broadcast messages to all windows.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: // Enumerate all child windows sending aMsg to each of them
 29835: BOOL CALLBACK nsWindow::BroadcastMsgToChildren(HWND aWnd, LPARAM aMsg)
 29835: {
 29835:   WNDPROC winProc = (WNDPROC)::GetWindowLongPtrW(aWnd, GWLP_WNDPROC);
 29835:   if (winProc == &nsWindow::WindowProc) {
 29835:     // it's one of our windows so go ahead and send a message to it
 29835:     ::CallWindowProcW(winProc, aWnd, aMsg, 0, 0);
 29835:   }
 29835:   return TRUE;
 29835: }
 29835: 
 29835: // Enumerate all top level windows specifying that the children of each
 29835: // top level window should be enumerated. Do *not* send the message to
 29835: // each top level window since it is assumed that the toolkit will send
 29835: // aMsg to them directly.
 29835: BOOL CALLBACK nsWindow::BroadcastMsg(HWND aTopWindow, LPARAM aMsg)
 29835: {
 29835:   // Iterate each of aTopWindows child windows sending the aMsg
 29835:   // to each of them.
 29835:   ::EnumChildWindows(aTopWindow, nsWindow::BroadcastMsgToChildren, aMsg);
 29835:   return TRUE;
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: Event processing helpers
 29835:  *
 29835:  * Special processing for certain event types and 
 29835:  * synthesized events.
 29835:  *
 29835:  **************************************************************/
 29835: 
108991: int32_t
108991: nsWindow::ClientMarginHitTestPoint(int32_t mx, int32_t my)
 46200: {
 87238:   if (mSizeMode == nsSizeMode_Minimized ||
 87238:       mSizeMode == nsSizeMode_Fullscreen) {
 87238:     return HTCLIENT;
 87238:   }
 87238: 
 46200:   // Calculations are done in screen coords
 46200:   RECT winRect;
 46200:   GetWindowRect(mWnd, &winRect);
 46200: 
 46200:   // hit return constants:
 46200:   // HTBORDER                     - non-resizable border
 46200:   // HTBOTTOM, HTLEFT, HTRIGHT, HTTOP - resizable border
 46200:   // HTBOTTOMLEFT, HTBOTTOMRIGHT  - resizable corner
 46200:   // HTTOPLEFT, HTTOPRIGHT        - resizable corner
 46200:   // HTCAPTION                    - general title bar area
 46200:   // HTCLIENT                     - area considered the client
 46200:   // HTCLOSE                      - hovering over the close button
 46200:   // HTMAXBUTTON                  - maximize button
 46200:   // HTMINBUTTON                  - minimize button
 46200: 
108991:   int32_t testResult = HTCLIENT;
 46200: 
 87238:   bool isResizable = (mBorderStyle & (eBorderStyle_all |
 87238:                                       eBorderStyle_resizeh |
 87238:                                       eBorderStyle_default)) > 0 ? true : false;
 87238:   if (mSizeMode == nsSizeMode_Maximized)
 87238:     isResizable = false;
 87238: 
124757:   // Ensure being accessible to borders of window.  Even if contents are in
124757:   // this area, the area must behave as border.
124757:   nsIntMargin nonClientSize(NS_MAX(mHorResizeMargin - mNonClientOffset.left,
124757:                                    kResizableBorderMinSize),
124757:                             NS_MAX(mCaptionHeight - mNonClientOffset.top,
124757:                                    kResizableBorderMinSize),
124757:                             NS_MAX(mHorResizeMargin - mNonClientOffset.right,
124757:                                    kResizableBorderMinSize),
124757:                             NS_MAX(mVertResizeMargin - mNonClientOffset.bottom,
124757:                                    kResizableBorderMinSize));
124757: 
124757:   bool allowContentOverride = mSizeMode == nsSizeMode_Maximized ||
124757:                               (mx >= winRect.left + nonClientSize.left &&
124757:                                mx <= winRect.right - nonClientSize.right &&
124757:                                my >= winRect.top + nonClientSize.top &&
124757:                                my <= winRect.bottom - nonClientSize.bottom);
124757: 
124757:   // The border size.  If there is no content under mouse cursor, the border
124757:   // size should be larger than the values in system settings.  Otherwise,
124757:   // contents under the mouse cursor should be able to override the behavior.
124757:   // E.g., user must expect that Firefox button always opens the popup menu
124757:   // even when the user clicks on the above edge of it.
124757:   nsIntMargin borderSize(NS_MAX(nonClientSize.left, mHorResizeMargin),
124757:                          NS_MAX(nonClientSize.top, mVertResizeMargin),
124757:                          NS_MAX(nonClientSize.right, mHorResizeMargin),
124757:                          NS_MAX(nonClientSize.bottom, mVertResizeMargin));
124757: 
 79445:   bool top    = false;
 79445:   bool bottom = false;
 79445:   bool left   = false;
 79445:   bool right  = false;
 46200: 
124757:   if (my >= winRect.top && my < winRect.top + borderSize.top) {
 79626:     top = true;
124757:   } else if (my <= winRect.bottom && my > winRect.bottom - borderSize.bottom) {
 79626:     bottom = true;
124757:   }
124757: 
 87238:   // (the 2x case here doubles the resize area for corners)
124757:   int multiplier = (top || bottom) ? 2 : 1;
124757:   if (mx >= winRect.left &&
124757:       mx < winRect.left + (multiplier * borderSize.left)) {
 79626:     left = true;
124757:   } else if (mx <= winRect.right &&
124757:              mx > winRect.right - (multiplier * borderSize.right)) {
 79626:     right = true;
124757:   }
 46200: 
 87238:   if (isResizable) {
 46200:     if (top) {
 46200:       testResult = HTTOP;
 46200:       if (left)
 46200:         testResult = HTTOPLEFT;
 46200:       else if (right)
 46200:         testResult = HTTOPRIGHT;
 46200:     } else if (bottom) {
 46200:       testResult = HTBOTTOM;
 46200:       if (left)
 46200:         testResult = HTBOTTOMLEFT;
 46200:       else if (right)
 46200:         testResult = HTBOTTOMRIGHT;
 46200:     } else {
 46200:       if (left)
 46200:         testResult = HTLEFT;
 46200:       if (right)
 46200:         testResult = HTRIGHT;
 46200:     }
 87238:   } else {
 87238:     if (top)
 87238:       testResult = HTCAPTION;
 87238:     else if (bottom || left || right)
 87238:       testResult = HTBORDER;
 87238:   }
 46200: 
124758:   if (!sIsInMouseCapture && allowContentOverride) {
 46334:     LPARAM lParam = MAKELPARAM(mx, my);
 46334:     LPARAM lParamClient = lParamToClient(lParam);
 79445:     bool result = DispatchMouseEvent(NS_MOUSE_MOZHITTEST, 0, lParamClient,
 79626:                                      false, nsMouseEvent::eLeftButton, MOUSE_INPUT_SOURCE());
 46334:     if (result) {
 46334:       // The mouse is over a blank area
 46334:       testResult = testResult == HTCLIENT ? HTCAPTION : testResult;
 46334: 
 46334:     } else {
 46334:       // There's content over the mouse pointer. Set HTCLIENT
 46334:       // to possibly override a resizer border.
 46334:       testResult = HTCLIENT;
 46334:     }
 46334:   }
 46334: 
 46200:   return testResult;
 46200: }
 46200: 
 82031: void nsWindow::PostSleepWakeNotification(const bool aIsSleepMode)
 82031: {
 82031:   if (aIsSleepMode == gIsSleepMode)
 82031:     return;
 82031: 
 82031:   gIsSleepMode = aIsSleepMode;
 82031: 
 41540:   nsCOMPtr<nsIObserverService> observerService =
 41540:     mozilla::services::GetObserverService();
 29835:   if (observerService)
106838:     observerService->NotifyObservers(nullptr,
121564:       aIsSleepMode ? NS_WIDGET_SLEEP_OBSERVER_TOPIC :
121564:                      NS_WIDGET_WAKE_OBSERVER_TOPIC, nullptr);
 29835: }
 29835: 
 60495: // RemoveNextCharMessage() should be called by WM_KEYDOWN or WM_SYSKEYDOWM
 60495: // message handler.  If there is no WM_(SYS)CHAR message for it, this
 60495: // method does nothing.
 60495: // NOTE: WM_(SYS)CHAR message is posted by TranslateMessage() API which is
 60495: // called in message loop.  So, WM_(SYS)KEYDOWN message should have
 60495: // WM_(SYS)CHAR message in the queue if the keydown event causes character
 60495: // input.
 60495: 
 60495: /* static */
 60495: void nsWindow::RemoveNextCharMessage(HWND aWnd)
 60495: {
 60495:   MSG msg;
 60495:   if (::PeekMessageW(&msg, aWnd,
 60495:                      WM_KEYFIRST, WM_KEYLAST, PM_NOREMOVE | PM_NOYIELD) &&
 60495:       (msg.message == WM_CHAR || msg.message == WM_SYSCHAR)) {
 60495:     ::GetMessageW(&msg, aWnd, msg.message, msg.message);
 60495:   }
 60495: }
 60495: 
 79445: LRESULT nsWindow::ProcessCharMessage(const MSG &aMsg, bool *aEventDispatched)
 29835: {
 29835:   NS_PRECONDITION(aMsg.message == WM_CHAR || aMsg.message == WM_SYSCHAR,
 29835:                   "message is not keydown event");
 29835:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
 29835:          ("%s charCode=%d scanCode=%d\n",
 29835:           aMsg.message == WM_SYSCHAR ? "WM_SYSCHAR" : "WM_CHAR",
 29835:           aMsg.wParam, HIWORD(aMsg.lParam) & 0xFF));
 29835: 
 29835:   // These must be checked here too as a lone WM_CHAR could be received
 29835:   // if a child window didn't handle it (for example Alt+Space in a content window)
102101:   ModifierKeyState modKeyState;
 98715:   NativeKey nativeKey(gKbdLayout, this, aMsg);
 97476:   return OnChar(aMsg, nativeKey, modKeyState, aEventDispatched);
 29835: }
 29835: 
 79445: LRESULT nsWindow::ProcessKeyUpMessage(const MSG &aMsg, bool *aEventDispatched)
 29835: {
 29835:   NS_PRECONDITION(aMsg.message == WM_KEYUP || aMsg.message == WM_SYSKEYUP,
 29835:                   "message is not keydown event");
 29835:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
 29835:          ("%s VK=%d\n", aMsg.message == WM_SYSKEYDOWN ?
 29835:                         "WM_SYSKEYUP" : "WM_KEYUP", aMsg.wParam));
 29835: 
102101:   ModifierKeyState modKeyState;
 29835: 
 29835:   // Note: the original code passed (HIWORD(lParam)) to OnKeyUp as
 29835:   // scan code. However, this breaks Alt+Num pad input.
 29835:   // MSDN states the following:
 29835:   //  Typically, ToAscii performs the translation based on the
 29835:   //  virtual-key code. In some cases, however, bit 15 of the
 29835:   //  uScanCode parameter may be used to distinguish between a key
 29835:   //  press and a key release. The scan code is used for
 29835:   //  translating ALT+number key combinations.
 29835: 
 29835:   // ignore [shift+]alt+space so the OS can handle it
102101:   if (modKeyState.IsAlt() && !modKeyState.IsControl() &&
 29835:       IS_VK_DOWN(NS_VK_SPACE)) {
 29835:     return FALSE;
 29835:   }
 29835: 
 49149:   if (!nsIMM32Handler::IsComposingOn(this) &&
 39867:       (aMsg.message != WM_KEYUP || aMsg.wParam != VK_MENU)) {
 29835:     // Ignore VK_MENU if it's not a system key release, so that the menu bar does not trigger
 29835:     // This helps avoid triggering the menu bar for ALT key accelerators used in
 29835:     // assistive technologies such as Window-Eyes and ZoomText, and when using Alt+Tab
 29835:     // to switch back to Mozilla in Windows 95 and Windows 98
 29835:     return OnKeyUp(aMsg, modKeyState, aEventDispatched);
 29835:   }
 29835: 
 29835:   return 0;
 29835: }
 29835: 
 29835: LRESULT nsWindow::ProcessKeyDownMessage(const MSG &aMsg,
 79445:                                         bool *aEventDispatched)
 29835: {
 29835:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
 29835:          ("%s VK=%d\n", aMsg.message == WM_SYSKEYDOWN ?
 29835:                         "WM_SYSKEYDOWN" : "WM_KEYDOWN", aMsg.wParam));
 29835:   NS_PRECONDITION(aMsg.message == WM_KEYDOWN || aMsg.message == WM_SYSKEYDOWN,
 29835:                   "message is not keydown event");
 29835: 
 60495:   // If this method doesn't call OnKeyDown(), this method must clean up the
 60495:   // redirected message information itself.  For more information, see above
 60495:   // comment of AutoForgetRedirectedKeyDownMessage struct definition in
 60495:   // nsWindow.h.
 60495:   AutoForgetRedirectedKeyDownMessage forgetRedirectedMessage(this, aMsg);
 60495: 
102101:   ModifierKeyState modKeyState;
 29835: 
 29835:   // Note: the original code passed (HIWORD(lParam)) to OnKeyDown as
 29835:   // scan code. However, this breaks Alt+Num pad input.
 29835:   // MSDN states the following:
 29835:   //  Typically, ToAscii performs the translation based on the
 29835:   //  virtual-key code. In some cases, however, bit 15 of the
 29835:   //  uScanCode parameter may be used to distinguish between a key
 29835:   //  press and a key release. The scan code is used for
 29835:   //  translating ALT+number key combinations.
 29835: 
 29835:   // ignore [shift+]alt+space so the OS can handle it
102101:   if (modKeyState.IsAlt() && !modKeyState.IsControl() &&
 29835:       IS_VK_DOWN(NS_VK_SPACE))
 29835:     return FALSE;
 29835: 
 29835:   LRESULT result = 0;
102101:   if (modKeyState.IsAlt() && nsIMM32Handler::IsStatusChanged()) {
 29835:     nsIMM32Handler::NotifyEndStatusChange();
 49149:   } else if (!nsIMM32Handler::IsComposingOn(this)) {
106838:     result = OnKeyDown(aMsg, modKeyState, aEventDispatched, nullptr);
 60495:     // OnKeyDown cleaned up the redirected message information itself, so,
 60495:     // we should do nothing.
 79626:     forgetRedirectedMessage.mCancel = true;
 29835:   }
 29835: 
 29835:   if (aMsg.wParam == VK_MENU ||
102101:       (aMsg.wParam == VK_F10 && !modKeyState.IsShift())) {
 29835:     // We need to let Windows handle this keypress,
 79626:     // by returning false, if there's a native menu
 29835:     // bar somewhere in our containing window hierarchy.
 29835:     // Otherwise we handle the keypress and don't pass
 79626:     // it on to Windows, by returning true.
 79445:     bool hasNativeMenu = false;
 29835:     HWND hWnd = mWnd;
 29835:     while (hWnd) {
 29835:       if (::GetMenu(hWnd)) {
 79626:         hasNativeMenu = true;
 29835:         break;
 29835:       }
 29835:       hWnd = ::GetParent(hWnd);
 29835:     }
 29835:     result = !hasNativeMenu;
 29835:   }
 29835: 
 29835:   return result;
 29835: }
 29835: 
 29835: nsresult
108991: nsWindow::SynthesizeNativeKeyEvent(int32_t aNativeKeyboardLayout,
108991:                                    int32_t aNativeKeyCode,
108991:                                    uint32_t aModifierFlags,
 29835:                                    const nsAString& aCharacters,
 29835:                                    const nsAString& aUnmodifiedCharacters)
 29835: {
102106:   UINT keyboardLayoutListCount = ::GetKeyboardLayoutList(0, NULL);
102106:   NS_ASSERTION(keyboardLayoutListCount > 0,
102106:                "One keyboard layout must be installed at least");
102106:   HKL keyboardLayoutListBuff[50];
102106:   HKL* keyboardLayoutList =
102106:     keyboardLayoutListCount < 50 ? keyboardLayoutListBuff :
102106:                                    new HKL[keyboardLayoutListCount];
102106:   keyboardLayoutListCount =
102106:     ::GetKeyboardLayoutList(keyboardLayoutListCount, keyboardLayoutList);
102106:   NS_ASSERTION(keyboardLayoutListCount > 0,
102106:                "Failed to get all keyboard layouts installed on the system");
102106: 
 29835:   nsPrintfCString layoutName("%08x", aNativeKeyboardLayout);
 29835:   HKL loadedLayout = LoadKeyboardLayoutA(layoutName.get(), KLF_NOTELLSHELL);
102106:   if (loadedLayout == NULL) {
102106:     if (keyboardLayoutListBuff != keyboardLayoutList) {
102106:       delete [] keyboardLayoutList;
102106:     }
 29835:     return NS_ERROR_NOT_AVAILABLE;
102106:   }
 29835: 
 29835:   // Setup clean key state and load desired layout
 29835:   BYTE originalKbdState[256];
 29835:   ::GetKeyboardState(originalKbdState);
 29835:   BYTE kbdState[256];
 29835:   memset(kbdState, 0, sizeof(kbdState));
 29835:   // This changes the state of the keyboard for the current thread only,
 29835:   // and we'll restore it soon, so this should be OK.
 29835:   ::SetKeyboardState(kbdState);
 29835:   HKL oldLayout = gKbdLayout.GetLayout();
 29835:   gKbdLayout.LoadLayout(loadedLayout);
 29835: 
108991:   uint8_t argumentKeySpecific = 0;
105735:   switch (aNativeKeyCode) {
105735:     case VK_SHIFT:
105735:       aModifierFlags &= ~(nsIWidget::SHIFT_L | nsIWidget::SHIFT_R);
105735:       argumentKeySpecific = VK_LSHIFT;
105735:       break;
105735:     case VK_LSHIFT:
105735:       aModifierFlags &= ~nsIWidget::SHIFT_L;
105735:       argumentKeySpecific = aNativeKeyCode;
105735:       aNativeKeyCode = VK_SHIFT;
105735:       break;
105735:     case VK_RSHIFT:
105735:       aModifierFlags &= ~nsIWidget::SHIFT_R;
105735:       argumentKeySpecific = aNativeKeyCode;
105735:       aNativeKeyCode = VK_SHIFT;
105735:       break;
105735:     case VK_CONTROL:
105735:       aModifierFlags &= ~(nsIWidget::CTRL_L | nsIWidget::CTRL_R);
105735:       argumentKeySpecific = VK_LCONTROL;
105735:       break;
105735:     case VK_LCONTROL:
105735:       aModifierFlags &= ~nsIWidget::CTRL_L;
105735:       argumentKeySpecific = aNativeKeyCode;
105735:       aNativeKeyCode = VK_CONTROL;
105735:       break;
105735:     case VK_RCONTROL:
105735:       aModifierFlags &= ~nsIWidget::CTRL_R;
105735:       argumentKeySpecific = aNativeKeyCode;
105735:       aNativeKeyCode = VK_CONTROL;
105735:       break;
105735:     case VK_MENU:
105735:       aModifierFlags &= ~(nsIWidget::ALT_L | nsIWidget::ALT_R);
105735:       argumentKeySpecific = VK_LMENU;
105735:       break;
105735:     case VK_LMENU:
105735:       aModifierFlags &= ~nsIWidget::ALT_L;
105735:       argumentKeySpecific = aNativeKeyCode;
105735:       aNativeKeyCode = VK_MENU;
105735:       break;
105735:     case VK_RMENU:
105735:       aModifierFlags &= ~nsIWidget::ALT_R;
105735:       argumentKeySpecific = aNativeKeyCode;
105735:       aNativeKeyCode = VK_MENU;
105735:       break;
105735:     case VK_CAPITAL:
105735:       aModifierFlags &= ~nsIWidget::CAPS_LOCK;
105735:       argumentKeySpecific = VK_CAPITAL;
105735:       break;
105735:     case VK_NUMLOCK:
105735:       aModifierFlags &= ~nsIWidget::NUM_LOCK;
105735:       argumentKeySpecific = VK_NUMLOCK;
105735:       break;
105735:   }
105735: 
 29835:   nsAutoTArray<KeyPair,10> keySequence;
 29835:   SetupKeyModifiersSequence(&keySequence, aModifierFlags);
 29835:   NS_ASSERTION(aNativeKeyCode >= 0 && aNativeKeyCode < 256,
 29835:                "Native VK key code out of range");
105735:   keySequence.AppendElement(KeyPair(aNativeKeyCode, argumentKeySpecific));
 29835: 
 29835:   // Simulate the pressing of each modifier key and then the real key
108991:   for (uint32_t i = 0; i < keySequence.Length(); ++i) {
108991:     uint8_t key = keySequence[i].mGeneral;
108991:     uint8_t keySpecific = keySequence[i].mSpecific;
 29835:     kbdState[key] = 0x81; // key is down and toggled on if appropriate
 29835:     if (keySpecific) {
 29835:       kbdState[keySpecific] = 0x81;
 29835:     }
 29835:     ::SetKeyboardState(kbdState);
102101:     ModifierKeyState modKeyState;
105735:     UINT scanCode = ::MapVirtualKeyEx(argumentKeySpecific ?
105735:                                         argumentKeySpecific : aNativeKeyCode,
105735:                                       MAPVK_VK_TO_VSC, gKbdLayout.GetLayout());
 97476:     LPARAM lParam = static_cast<LPARAM>(scanCode << 16);
 97476:     // Add extended key flag to the lParam for right control key and right alt
 97476:     // key.
 97476:     if (keySpecific == VK_RCONTROL || keySpecific == VK_RMENU) {
 97476:       lParam |= 0x1000000;
 97476:     }
 97476:     MSG msg = WinUtils::InitMSG(WM_KEYDOWN, key, lParam);
102106:     if (i == keySequence.Length() - 1) {
102106:       bool makeDeadCharMessage =
102106:         gKbdLayout.IsDeadKey(key, modKeyState) && aCharacters.IsEmpty();
102106:       nsAutoString chars(aCharacters);
102106:       if (makeDeadCharMessage) {
102106:         UniCharsAndModifiers deadChars =
102106:           gKbdLayout.GetUniCharsAndModifiers(key, modKeyState);
102106:         chars = deadChars.ToString();
102106:         NS_ASSERTION(chars.Length() == 1,
102106:                      "Dead char must be only one character");
102106:       }
102106:       if (chars.IsEmpty()) {
106838:         OnKeyDown(msg, modKeyState, nullptr, nullptr);
102106:       } else {
102106:         nsFakeCharMessage fakeMsg = { chars.CharAt(0), scanCode,
102106:                                       makeDeadCharMessage };
106838:         OnKeyDown(msg, modKeyState, nullptr, &fakeMsg);
108991:         for (uint32_t j = 1; j < chars.Length(); j++) {
102106:           nsFakeCharMessage fakeMsg = { chars.CharAt(j), scanCode, false };
102106:           MSG msg = fakeMsg.GetCharMessage(mWnd);
102106:           NativeKey nativeKey(gKbdLayout, this, msg);
106838:           OnChar(msg, nativeKey, modKeyState, nullptr);
102106:         }
102106:       }
 29835:     } else {
106838:       OnKeyDown(msg, modKeyState, nullptr, nullptr);
 29835:     }
 29835:   }
108991:   for (uint32_t i = keySequence.Length(); i > 0; --i) {
108991:     uint8_t key = keySequence[i - 1].mGeneral;
108991:     uint8_t keySpecific = keySequence[i - 1].mSpecific;
 29835:     kbdState[key] = 0; // key is up and toggled off if appropriate
 29835:     if (keySpecific) {
 29835:       kbdState[keySpecific] = 0;
 29835:     }
 29835:     ::SetKeyboardState(kbdState);
102101:     ModifierKeyState modKeyState;
105735:     UINT scanCode = ::MapVirtualKeyEx(argumentKeySpecific ?
105735:                                         argumentKeySpecific : aNativeKeyCode,
105735:                                       MAPVK_VK_TO_VSC, gKbdLayout.GetLayout());
 97476:     LPARAM lParam = static_cast<LPARAM>(scanCode << 16);
 97476:     // Add extended key flag to the lParam for right control key and right alt
 97476:     // key.
 97476:     if (keySpecific == VK_RCONTROL || keySpecific == VK_RMENU) {
 97476:       lParam |= 0x1000000;
 97476:     }
 97476:     MSG msg = WinUtils::InitMSG(WM_KEYUP, key, lParam);
106838:     OnKeyUp(msg, modKeyState, nullptr);
 29835:   }
 29835: 
 29835:   // Restore old key state and layout
 29835:   ::SetKeyboardState(originalKbdState);
102106:   gKbdLayout.LoadLayout(oldLayout, true);
102106: 
102106:   // Don't unload the layout if it's installed actually.
108991:   for (uint32_t i = 0; i < keyboardLayoutListCount; i++) {
102106:     if (keyboardLayoutList[i] == loadedLayout) {
102106:       loadedLayout = 0;
102106:       break;
102106:     }
102106:   }
102106:   if (keyboardLayoutListBuff != keyboardLayoutList) {
102106:     delete [] keyboardLayoutList;
102106:   }
102106:   if (loadedLayout) {
102106:     ::UnloadKeyboardLayout(loadedLayout);
102106:   }
 29835:   return NS_OK;
 29835: }
 29835: 
 33863: nsresult
 33863: nsWindow::SynthesizeNativeMouseEvent(nsIntPoint aPoint,
108991:                                      uint32_t aNativeMessage,
108991:                                      uint32_t aModifierFlags)
 33863: {
114824:   ::SetCursorPos(aPoint.x, aPoint.y);
 33863: 
 33863:   INPUT input;
 33863:   memset(&input, 0, sizeof(input));
 33863: 
 33863:   input.type = INPUT_MOUSE;
 33863:   input.mi.dwFlags = aNativeMessage;
 33863:   ::SendInput(1, &input, sizeof(INPUT));
 33863: 
 33863:   return NS_OK;
 33863: }
 33863: 
 93735: nsresult
 93735: nsWindow::SynthesizeNativeMouseScrollEvent(nsIntPoint aPoint,
108991:                                            uint32_t aNativeMessage,
 93735:                                            double aDeltaX,
 93735:                                            double aDeltaY,
 93735:                                            double aDeltaZ,
108991:                                            uint32_t aModifierFlags,
108991:                                            uint32_t aAdditionalFlags)
 93735: {
 93735:   return MouseScrollHandler::SynthesizeNativeMouseScrollEvent(
 93735:            this, aPoint, aNativeMessage,
 93735:            (aNativeMessage == WM_MOUSEWHEEL || aNativeMessage == WM_VSCROLL) ?
108991:              static_cast<int32_t>(aDeltaY) : static_cast<int32_t>(aDeltaX),
 93735:            aModifierFlags, aAdditionalFlags);
 93735: }
 93735: 
 29835: /**************************************************************
 29835:  *
 29835:  * SECTION: OnXXX message handlers
 29835:  *
 29835:  * For message handlers that need to be broken out or
 29835:  * implemented in specific platform code.
 29835:  *
 29835:  **************************************************************/
 29835: 
 29835: BOOL nsWindow::OnInputLangChange(HKL aHKL)
 29835: {
 29835: #ifdef KE_DEBUG
 76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("OnInputLanguageChange\n"));
 29835: #endif
 29835:   gKbdLayout.LoadLayout(aHKL);
 79626:   return false;   // always pass to child window
 29835: }
 29835: 
 79445: void nsWindow::OnWindowPosChanged(WINDOWPOS *wp, bool& result)
 31345: {
106838:   if (wp == nullptr)
 31345:     return;
 31345: 
 34735: #ifdef WINSTATE_DEBUG_OUTPUT
 86569:   if (mWnd == WinUtils::GetTopLevelHWND(mWnd)) {
 76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("*** OnWindowPosChanged: [  top] "));
 76714:   } else {
 76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("*** OnWindowPosChanged: [child] "));
 76714:   }
 76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("WINDOWPOS flags:"));
 76714:   if (wp->flags & SWP_FRAMECHANGED) {
 76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("SWP_FRAMECHANGED "));
 76714:   }
 76714:   if (wp->flags & SWP_SHOWWINDOW) {
 76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("SWP_SHOWWINDOW "));
 76714:   }
 76714:   if (wp->flags & SWP_NOSIZE) {
 76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("SWP_NOSIZE "));
 76714:   }
 76714:   if (wp->flags & SWP_HIDEWINDOW) {
 76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("SWP_HIDEWINDOW "));
 76714:   }
 76714:   if (wp->flags & SWP_NOZORDER) {
 76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("SWP_NOZORDER "));
 76714:   }
 76714:   if (wp->flags & SWP_NOACTIVATE) {
 76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("SWP_NOACTIVATE "));
 76714:   }
 76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("\n"));
 31345: #endif
 31345: 
 34735:   // Handle window size mode changes
 46335:   if (wp->flags & SWP_FRAMECHANGED && mSizeMode != nsSizeMode_Fullscreen) {
 56369: 
 56369:     // Bug 566135 - Windows theme code calls show window on SW_SHOWMINIMIZED
 56369:     // windows when fullscreen games disable desktop composition. If we're
 56369:     // minimized and not being activated, ignore the event and let windows
 56369:     // handle it.
 56369:     if (mSizeMode == nsSizeMode_Minimized && (wp->flags & SWP_NOACTIVATE))
 56369:       return;
 56369: 
 31345:     WINDOWPLACEMENT pl;
 31345:     pl.length = sizeof(pl);
 31345:     ::GetWindowPlacement(mWnd, &pl);
 31345: 
108457:     // Windows has just changed the size mode of this window. The call to
108457:     // SizeModeChanged will trigger a call into SetSizeMode where we will
 31345:     // set the min/max window state again or for nsSizeMode_Normal, call
 31345:     // SetWindow with a parameter of SW_RESTORE. There's no need however as
 31345:     // this window's mode has already changed. Updating mSizeMode here
 31345:     // insures the SetSizeMode call is a no-op. Addresses a bug on Win7 related
 31345:     // to window docking. (bug 489258)
108457:     if (pl.showCmd == SW_SHOWMAXIMIZED)
108457:       mSizeMode = (mFullscreenMode ? nsSizeMode_Fullscreen : nsSizeMode_Maximized);
108457:     else if (pl.showCmd == SW_SHOWMINIMIZED)
108457:       mSizeMode = nsSizeMode_Minimized;
108457:     else if (mFullscreenMode)
108457:       mSizeMode = nsSizeMode_Fullscreen;
108457:     else
108457:       mSizeMode = nsSizeMode_Normal;
 31345: 
 34786:     // If !sTrimOnMinimize, we minimize windows using SW_SHOWMINIMIZED (See
 34786:     // SetSizeMode for internal calls, and WM_SYSCOMMAND for external). This
 34786:     // prevents the working set from being trimmed but keeps the window active.
 34786:     // After the window is minimized, we need to do some touch up work on the
 34786:     // active window. (bugs 76831 & 499816)
108457:     if (!sTrimOnMinimize && nsSizeMode_Minimized == mSizeMode)
 34786:       ActivateOtherWindowHelper(mWnd);
 34786: 
 34735: #ifdef WINSTATE_DEBUG_OUTPUT
 34735:     switch (mSizeMode) {
 34735:       case nsSizeMode_Normal:
 76714:           PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
 76714:                  ("*** mSizeMode: nsSizeMode_Normal\n"));
 34735:         break;
 34735:       case nsSizeMode_Minimized:
 76714:         PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
 76714:                ("*** mSizeMode: nsSizeMode_Minimized\n"));
 34735:         break;
 34735:       case nsSizeMode_Maximized:
 76714:           PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
 76714:                  ("*** mSizeMode: nsSizeMode_Maximized\n");
 34735:         break;
 34735:       default:
 76714:           PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("*** mSizeMode: ??????\n");
 34735:         break;
 34735:     };
 34735: #endif
 34735: 
108457:     if (mWidgetListener)
108457:       mWidgetListener->SizeModeChanged(mSizeMode);
108457: 
108457:     // If window was restored, window activation was bypassed during the 
 97778:     // SetSizeMode call originating from OnWindowPosChanging to avoid saving
108457:     // pre-restore attributes. Force activation now to get correct attributes.
 97778:     if (mLastSizeMode != nsSizeMode_Normal && mSizeMode == nsSizeMode_Normal)
108457:       DispatchFocusToTopLevelWindow(true);
 97778: 
 34735:     // Skip window size change events below on minimization.
 34735:     if (mSizeMode == nsSizeMode_Minimized)
 34735:       return;
 34735:   }
 34735: 
 34735:   // Handle window size changes
 56922:   if (!(wp->flags & SWP_NOSIZE)) {
 34735:     RECT r;
108991:     int32_t newWidth, newHeight;
 34735: 
 34735:     ::GetWindowRect(mWnd, &r);
 34735: 
 34735:     newWidth  = r.right - r.left;
 34735:     newHeight = r.bottom - r.top;
 34735:     nsIntRect rect(wp->x, wp->y, newWidth, newHeight);
 34735: 
 34735: #ifdef MOZ_XUL
 34735:     if (eTransparencyTransparent == mTransparencyMode)
 34735:       ResizeTranslucentWindow(newWidth, newHeight);
 34735: #endif
 34735: 
 34735:     if (newWidth > mLastSize.width)
 34735:     {
 34735:       RECT drect;
 34735: 
 34735:       // getting wider
 34735:       drect.left   = wp->x + mLastSize.width;
 34735:       drect.top    = wp->y;
 34735:       drect.right  = drect.left + (newWidth - mLastSize.width);
 34735:       drect.bottom = drect.top + newHeight;
 34735: 
 34735:       ::RedrawWindow(mWnd, &drect, NULL,
 34735:                      RDW_INVALIDATE |
 34735:                      RDW_NOERASE |
 34735:                      RDW_NOINTERNALPAINT |
 34735:                      RDW_ERASENOW |
 34735:                      RDW_ALLCHILDREN);
 34735:     }
 34735:     if (newHeight > mLastSize.height)
 34735:     {
 34735:       RECT drect;
 34735: 
 34735:       // getting taller
 34735:       drect.left   = wp->x;
 34735:       drect.top    = wp->y + mLastSize.height;
 34735:       drect.right  = drect.left + newWidth;
 34735:       drect.bottom = drect.top + (newHeight - mLastSize.height);
 34735: 
 34735:       ::RedrawWindow(mWnd, &drect, NULL,
 34735:                      RDW_INVALIDATE |
 34735:                      RDW_NOERASE |
 34735:                      RDW_NOINTERNALPAINT |
 34735:                      RDW_ERASENOW |
 34735:                      RDW_ALLCHILDREN);
 34735:     }
 34735: 
 34735:     mBounds.width    = newWidth;
 34735:     mBounds.height   = newHeight;
 34735:     mLastSize.width  = newWidth;
 34735:     mLastSize.height = newHeight;
 34735: 
 34735: #ifdef WINSTATE_DEBUG_OUTPUT
 76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
 76714:            ("*** Resize window: %d x %d x %d x %d\n", wp->x, wp->y, 
 76714:             newWidth, newHeight));
 34735: #endif
 34735:     
108835:     // If a maximized window is resized, recalculate the non-client margins.
 48424:     if (mSizeMode == nsSizeMode_Maximized) {
 79626:       if (UpdateNonClientMargins(nsSizeMode_Maximized, true)) {
 48424:         // gecko resize event already sent by UpdateNonClientMargins.
 79626:         result = true;
 48424:         return;
 48424:       }
 48424:     }
 48424: 
 34735:     // Recalculate the width and height based on the client area for gecko events.
 34735:     if (::GetClientRect(mWnd, &r)) {
 34735:       rect.width  = r.right - r.left;
 34735:       rect.height = r.bottom - r.top;
 34735:     }
 34735:     
 34735:     // Send a gecko resize event
 34735:     result = OnResize(rect);
 34735:   }
 34735: }
 34786: 
 34786: // static
 34786: void nsWindow::ActivateOtherWindowHelper(HWND aWnd)
 34786: {
 34786:   // Find the next window that is enabled, visible, and not minimized.
 34786:   HWND hwndBelow = ::GetNextWindow(aWnd, GW_HWNDNEXT);
 34786:   while (hwndBelow && (!::IsWindowEnabled(hwndBelow) || !::IsWindowVisible(hwndBelow) ||
 34786:                        ::IsIconic(hwndBelow))) {
 34786:     hwndBelow = ::GetNextWindow(hwndBelow, GW_HWNDNEXT);
 34786:   }
 34786: 
 34786:   // Push ourselves to the bottom of the stack, then activate the
 34786:   // next window.
 34786:   ::SetWindowPos(aWnd, HWND_BOTTOM, 0, 0, 0, 0,
 34786:                  SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
 34786:   if (hwndBelow)
 34786:     ::SetForegroundWindow(hwndBelow);
 34786: 
 34786:   // Play the minimize sound while we're here, since that is also
 34786:   // forgotten when we use SW_SHOWMINIMIZED.
 78043:   nsCOMPtr<nsISound> sound(do_CreateInstance("@mozilla.org/sound;1"));
 78043:   if (sound) {
 78043:     sound->PlaySystemSound(NS_LITERAL_STRING("Minimize"));
 78043:   }
 34786: }
 68855: 
 29835: void nsWindow::OnWindowPosChanging(LPWINDOWPOS& info)
 29835: {
 46332:   // Update non-client margins if the frame size is changing, and let the
 46332:   // browser know we are changing size modes, so alternative css can kick in.
 46335:   // If we're going into fullscreen mode, ignore this, since it'll reset
 46335:   // margins to normal mode. 
 56369:   if ((info->flags & SWP_FRAMECHANGED && !(info->flags & SWP_NOSIZE)) &&
 56369:       mSizeMode != nsSizeMode_Fullscreen) {
 46332:     WINDOWPLACEMENT pl;
 46332:     pl.length = sizeof(pl);
 46332:     ::GetWindowPlacement(mWnd, &pl);
108457:     nsSizeMode sizeMode;
 46332:     if (pl.showCmd == SW_SHOWMAXIMIZED)
 62115:       sizeMode = (mFullscreenMode ? nsSizeMode_Fullscreen : nsSizeMode_Maximized);
 46332:     else if (pl.showCmd == SW_SHOWMINIMIZED)
 46332:       sizeMode = nsSizeMode_Minimized;
 63113:     else if (mFullscreenMode)
 63113:       sizeMode = nsSizeMode_Fullscreen;
 46332:     else
 46332:       sizeMode = nsSizeMode_Normal;
 46332: 
108457:     if (mWidgetListener)
108457:       mWidgetListener->SizeModeChanged(sizeMode);
 46332: 
 79626:     UpdateNonClientMargins(sizeMode, false);
 46332:   }
 46332: 
 29835:   // enforce local z-order rules
 29835:   if (!(info->flags & SWP_NOZORDER)) {
 29835:     HWND hwndAfter = info->hwndInsertAfter;
 29835: 
 29835:     nsWindow *aboveWindow = 0;
108457:     nsWindowZ placement;
 29835: 
 29835:     if (hwndAfter == HWND_BOTTOM)
108457:       placement = nsWindowZBottom;
 29835:     else if (hwndAfter == HWND_TOP || hwndAfter == HWND_TOPMOST || hwndAfter == HWND_NOTOPMOST)
108457:       placement = nsWindowZTop;
 29835:     else {
108457:       placement = nsWindowZRelative;
 86569:       aboveWindow = WinUtils::GetNSWindowPtr(hwndAfter);
 29835:     }
108457: 
108457:     if (mWidgetListener) {
108457:       nsCOMPtr<nsIWidget> actualBelow = nullptr;
108457:       if (mWidgetListener->ZLevelChanged(false, &placement,
108457:                                          aboveWindow, getter_AddRefs(actualBelow))) {
108457:         if (placement == nsWindowZBottom)
 29835:           info->hwndInsertAfter = HWND_BOTTOM;
108457:         else if (placement == nsWindowZTop)
 29835:           info->hwndInsertAfter = HWND_TOP;
 29835:         else {
108457:           info->hwndInsertAfter = (HWND)actualBelow->GetNativeData(NS_NATIVE_WINDOW);
108457:         }
108457:       }
108457:     }
 29835:   }
 29835:   // prevent rude external programs from making hidden window visible
 29835:   if (mWindowType == eWindowType_invisible)
 29835:     info->flags &= ~SWP_SHOWWINDOW;
 29835: }
 29835: 
 40944: void nsWindow::UserActivity()
 40944: {
 40944:   // Check if we have the idle service, if not we try to get it.
 40944:   if (!mIdleService) {
 40944:     mIdleService = do_GetService("@mozilla.org/widget/idleservice;1");
 40944:   }
 40944: 
 40944:   // Check that we now have the idle service.
 40944:   if (mIdleService) {
103224:     mIdleService->ResetIdleTimeOut(0);
 40944:   }
 40944: }
 40944: 
 79445: bool nsWindow::OnTouch(WPARAM wParam, LPARAM lParam)
 48711: {
108991:   uint32_t cInputs = LOWORD(wParam);
 48711:   PTOUCHINPUT pInputs = new TOUCHINPUT[cInputs];
 48711: 
114690:   if (mGesture.GetTouchInputInfo((HTOUCHINPUT)lParam, cInputs, pInputs)) {
114690:     nsTouchEvent* touchEventToSend = nullptr;
114690:     nsTouchEvent* touchEndEventToSend = nullptr;
114690:     nsEventStatus status;
114690: 
114690:     // Walk across the touch point array processing each contact point
114690:     for (uint32_t i = 0; i < cInputs; i++) {
114690:       uint32_t msg;
114690: 
114690:       if (pInputs[i].dwFlags & (TOUCHEVENTF_DOWN | TOUCHEVENTF_MOVE)) {
114690:         // Create a standard touch event to send
114690:         if (!touchEventToSend) {
114690:           touchEventToSend = new nsTouchEvent(true, NS_TOUCH_MOVE, this);
114690:           touchEventToSend->time = ::GetMessageTime();
114690:           ModifierKeyState modifierKeyState;
114690:           modifierKeyState.InitInputEvent(*touchEventToSend);
114690:         }
114690: 
114690:         // Pres shell expects this event to be a NS_TOUCH_START if new contact
114690:         // points have been added since the last event sent.
114690:         if (pInputs[i].dwFlags & TOUCHEVENTF_DOWN) {
114690:           touchEventToSend->message = msg = NS_TOUCH_START;
114690:         } else {
114690:           msg = NS_TOUCH_MOVE;
114690:         }
114690:       } else if (pInputs[i].dwFlags & TOUCHEVENTF_UP) {
114690:         // Pres shell expects removed contacts points to be delivered in a
114690:         // separate NS_TOUCH_END event containing only the contact points
114690:         // that were removed.
114690:         if (!touchEndEventToSend) {
114690:           touchEndEventToSend = new nsTouchEvent(true, NS_TOUCH_END, this);
114690:           touchEndEventToSend->time = ::GetMessageTime();
114690:           ModifierKeyState modifierKeyState;
114690:           modifierKeyState.InitInputEvent(*touchEndEventToSend);
114690:         }
114690:         msg = NS_TOUCH_END;
114690:       } else {
114690:         // Filter out spurious Windows events we don't understand, like palm
114690:         // contact.
114690:         continue;
114690:       }
114690: 
114690:       // Setup the touch point we'll append to the touch event array
114690:       nsPointWin touchPoint;
114690:       touchPoint.x = TOUCH_COORD_TO_PIXEL(pInputs[i].x);
114690:       touchPoint.y = TOUCH_COORD_TO_PIXEL(pInputs[i].y);
114690:       touchPoint.ScreenToClient(mWnd);
114690:       nsCOMPtr<nsIDOMTouch> touch =
114690:         new nsDOMTouch(pInputs[i].dwID,
114690:                        touchPoint,
114690:                        /* radius, if known */
114690:                        pInputs[i].dwFlags & TOUCHINPUTMASKF_CONTACTAREA ?
114690:                          nsIntPoint(
114690:                            TOUCH_COORD_TO_PIXEL(pInputs[i].cxContact) / 2,
114690:                            TOUCH_COORD_TO_PIXEL(pInputs[i].cyContact) / 2) :
114690:                          nsIntPoint(1,1),
114690:                        /* rotation angle and force */
114690:                        0.0f, 0.0f);
114690: 
114690:       // Append to the appropriate event
114690:       if (msg == NS_TOUCH_START || msg == NS_TOUCH_MOVE) {
114690:         touchEventToSend->touches.AppendElement(touch);
114690:       } else {
114690:         touchEndEventToSend->touches.AppendElement(touch);
114690:       }
114690:     }
114690: 
114690:     // Dispatch touch start and move event if we have one.
114690:     if (touchEventToSend) {
114690:       DispatchEvent(touchEventToSend, status);
114690:       delete touchEventToSend;
114690:     }
114690: 
114690:     // Dispatch touch end event if we have one.
114690:     if (touchEndEventToSend) {
114690:       DispatchEvent(touchEndEventToSend, status);
114690:       delete touchEndEventToSend;
114690:     }
114690:   }
114690: 
 48711:   delete [] pInputs;
 48711:   mGesture.CloseTouchInputHandle((HTOUCHINPUT)lParam);
 79626:   return true;
 48711: }
 48711: 
108991: static int32_t RoundDown(double aDouble)
108991: {
108991:   return aDouble > 0 ? static_cast<int32_t>(floor(aDouble)) :
108991:                        static_cast<int32_t>(ceil(aDouble));
108070: }
108070: 
 29835: // Gesture event processing. Handles WM_GESTURE events.
 79445: bool nsWindow::OnGesture(WPARAM wParam, LPARAM lParam)
 29835: {
 29835:   // Treatment for pan events which translate into scroll events:
 29835:   if (mGesture.IsPanEvent(lParam)) {
 29835:     if ( !mGesture.ProcessPanMessage(mWnd, wParam, lParam) )
 79626:       return false; // ignore
 29835: 
 29835:     nsEventStatus status;
 29835: 
108070:     WheelEvent wheelEvent(true, NS_WHEEL_WHEEL, this);
108070: 
102101:     ModifierKeyState modifierKeyState;
108070:     modifierKeyState.InitInputEvent(wheelEvent);
108070: 
108070:     wheelEvent.button      = 0;
108070:     wheelEvent.time        = ::GetMessageTime();
108070:     wheelEvent.inputSource = nsIDOMMouseEvent::MOZ_SOURCE_TOUCH;
 29835: 
 79445:     bool endFeedback = true;
 29835: 
108070:     if (mGesture.PanDeltaToPixelScroll(wheelEvent)) {
108070:       DispatchEvent(&wheelEvent, status);
 30890:     }
 30890: 
 31443:     if (mDisplayPanFeedback) {
110714:       mGesture.UpdatePanFeedbackX(mWnd,
124775:                                   std::abs(RoundDown(wheelEvent.overflowDeltaX)),
108070:                                   endFeedback);
110714:       mGesture.UpdatePanFeedbackY(mWnd,
124775:                                   std::abs(RoundDown(wheelEvent.overflowDeltaY)),
108070:                                   endFeedback);
 29835:       mGesture.PanFeedbackFinalize(mWnd, endFeedback);
 30890:     }
 30890: 
 29835:     mGesture.CloseGestureInfoHandle((HGESTUREINFO)lParam);
 29835: 
 79626:     return true;
 29835:   }
 29835: 
 29835:   // Other gestures translate into simple gesture events:
 79626:   nsSimpleGestureEvent event(true, 0, this, 0, 0.0);
 29835:   if ( !mGesture.ProcessGestureMessage(mWnd, wParam, lParam, event) ) {
 79626:     return false; // fall through to DefWndProc
 29835:   }
 29835:   
 29835:   // Polish up and send off the new event
102101:   ModifierKeyState modifierKeyState;
 96889:   modifierKeyState.InitInputEvent(event);
 29835:   event.button    = 0;
 29835:   event.time      = ::GetMessageTime();
 77227:   event.inputSource = nsIDOMMouseEvent::MOZ_SOURCE_TOUCH;
 29835: 
 29835:   nsEventStatus status;
 29835:   DispatchEvent(&event, status);
 29835:   if (status == nsEventStatus_eIgnore) {
 79626:     return false; // Ignored, fall through
 29835:   }
 29835: 
 29835:   // Only close this if we process and return true.
 29835:   mGesture.CloseGestureInfoHandle((HGESTUREINFO)lParam);
 29835: 
 79626:   return true; // Handled
 29835: }
 68855: 
 60495: /* static */
 79445: bool nsWindow::IsRedirectedKeyDownMessage(const MSG &aMsg)
 60495: {
 60495:   return (aMsg.message == WM_KEYDOWN || aMsg.message == WM_SYSKEYDOWN) &&
 60495:          (sRedirectedKeyDown.message == aMsg.message &&
 86569:           WinUtils::GetScanCode(sRedirectedKeyDown.lParam) ==
 86569:             WinUtils::GetScanCode(aMsg.lParam));
 60495: }
 60495: 
 14962: /**
 14962:  * nsWindow::OnKeyDown peeks into the message queue and pulls out
 14962:  * WM_CHAR messages for processing. During testing we don't want to
 14962:  * mess with the real message queue. Instead we pass a
 14962:  * pseudo-WM_CHAR-message using this structure, and OnKeyDown will use
 14962:  * that as if it was in the message queue, and refrain from actually
 14962:  * looking at or touching the message queue.
 14962:  */
 22788: LRESULT nsWindow::OnKeyDown(const MSG &aMsg,
102101:                             const ModifierKeyState &aModKeyState,
 79445:                             bool *aEventDispatched,
 14962:                             nsFakeCharMessage* aFakeCharMessage)
     1: {
 98715:   NativeKey nativeKey(gKbdLayout, this, aMsg);
 97476:   UINT virtualKeyCode = nativeKey.GetOriginalVirtualKeyCode();
102104:   UniCharsAndModifiers inputtingChars =
102103:     gKbdLayout.OnKeyDown(virtualKeyCode, aModKeyState);
     1: 
     1:   // Use only DOMKeyCode for XP processing.
 60495:   // Use virtualKeyCode for gKbdLayout and native processing.
108991:   uint32_t DOMKeyCode = nativeKey.GetDOMKeyCode();
     1: 
     1: #ifdef DEBUG
 76714:   //PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("In OnKeyDown virt: %d\n", DOMKeyCode));
     1: #endif
     1: 
 79445:   static bool sRedirectedKeyDownEventPreventedDefault = false;
 79445:   bool noDefault;
 60495:   if (aFakeCharMessage || !IsRedirectedKeyDownMessage(aMsg)) {
 73536:     nsIMEContext IMEContext(mWnd);
 97476:     nsKeyEvent keydownEvent(true, NS_KEY_DOWN, this);
 97476:     keydownEvent.keyCode = DOMKeyCode;
 97476:     InitKeyEvent(keydownEvent, nativeKey, aModKeyState);
 97476:     noDefault = DispatchKeyEvent(keydownEvent, &aMsg);
 60495:     if (aEventDispatched) {
 79626:       *aEventDispatched = true;
 60495:     }
 60495: 
 60495:     // If IMC wasn't associated to the window but is associated it now (i.e.,
 60495:     // focus is moved from a non-editable editor to an editor by keydown
 60495:     // event handler), WM_CHAR and WM_SYSCHAR shouldn't cause first character
 60495:     // inputting if IME is opened.  But then, we should redirect the native
 60495:     // keydown message to IME.
 60495:     // However, note that if focus has been already moved to another
 60495:     // application, we shouldn't redirect the message to it because the keydown
 60495:     // message is processed by us, so, nobody shouldn't process it.
 60495:     HWND focusedWnd = ::GetFocus();
 73536:     nsIMEContext newIMEContext(mWnd);
 73536:     if (!noDefault && !aFakeCharMessage && focusedWnd && !PluginHasFocus() &&
 73536:         !IMEContext.get() && newIMEContext.get()) {
 60495:       RemoveNextCharMessage(focusedWnd);
 60495: 
 60495:       INPUT keyinput;
 60495:       keyinput.type = INPUT_KEYBOARD;
 60495:       keyinput.ki.wVk = aMsg.wParam;
 86569:       keyinput.ki.wScan = WinUtils::GetScanCode(aMsg.lParam);
 60495:       keyinput.ki.dwFlags = KEYEVENTF_SCANCODE;
 86569:       if (WinUtils::IsExtendedScanCode(aMsg.lParam)) {
 60495:         keyinput.ki.dwFlags |= KEYEVENTF_EXTENDEDKEY;
 60495:       }
 60495:       keyinput.ki.time = 0;
116099:       keyinput.ki.dwExtraInfo = 0;
 60495: 
 60495:       sRedirectedKeyDownEventPreventedDefault = noDefault;
 60495:       sRedirectedKeyDown = aMsg;
 60495: 
 60495:       ::SendInput(1, &keyinput, sizeof(keyinput));
 60495: 
 60495:       // Return here.  We shouldn't dispatch keypress event for this WM_KEYDOWN.
 60495:       // If it's needed, it will be dispatched after next (redirected)
 60495:       // WM_KEYDOWN.
 79626:       return true;
 60495:     }
 60495: 
 60495:     if (mOnDestroyCalled) {
 60495:       // If this was destroyed by the keydown event handler, we shouldn't
 60495:       // dispatch keypress event on this window.
 79626:       return true;
 60495:     }
 60495:   } else {
 60495:     noDefault = sRedirectedKeyDownEventPreventedDefault;
 60495:     // If this is redirected keydown message, we have dispatched the keydown
 60495:     // event already.
 60495:     if (aEventDispatched) {
 79626:       *aEventDispatched = true;
 60495:     }
 60495:   }
 60495: 
 60495:   ForgetRedirectedKeyDownMessage();
 60495: 
 60495:   // If the key was processed by IME, we shouldn't dispatch keypress event.
 60495:   if (aMsg.wParam == VK_PROCESSKEY) {
 60495:     return noDefault;
 60495:   }
     1: 
     1:   // If we won't be getting a WM_CHAR, WM_SYSCHAR or WM_DEADCHAR, synthesize a keypress
     1:   // for almost all keys
     1:   switch (DOMKeyCode) {
     1:     case NS_VK_SHIFT:
     1:     case NS_VK_CONTROL:
     1:     case NS_VK_ALT:
     1:     case NS_VK_CAPS_LOCK:
     1:     case NS_VK_NUM_LOCK:
 98715:     case NS_VK_SCROLL_LOCK:
 98715:     case NS_VK_WIN:
 98715:       return noDefault;
     1:   }
     1: 
102102:   bool isDeadKey = gKbdLayout.IsDeadKey(virtualKeyCode, aModKeyState);
126032:   EventFlags extraFlags;
126032:   extraFlags.mDefaultPrevented = noDefault;
     1:   MSG msg;
 14962:   BOOL gotMsg = aFakeCharMessage ||
 14962:     ::PeekMessageW(&msg, mWnd, WM_KEYFIRST, WM_KEYLAST, PM_NOREMOVE | PM_NOYIELD);
     1:   // Enter and backspace are always handled here to avoid for example the
     1:   // confusion between ctrl-enter and ctrl-J.
     1:   if (DOMKeyCode == NS_VK_RETURN || DOMKeyCode == NS_VK_BACK ||
105732:       ((aModKeyState.IsControl() || aModKeyState.IsAlt() || aModKeyState.IsWin())
102100:        && !isDeadKey && KeyboardLayout::IsPrintableCharKey(virtualKeyCode)))
     1:   {
     1:     // Remove a possible WM_CHAR or WM_SYSCHAR messages from the message queue.
     1:     // They can be more than one because of:
     1:     //  * Dead-keys not pairing with base character
     1:     //  * Some keyboard layouts may map up to 4 characters to the single key
 79445:     bool anyCharMessagesRemoved = false;
 14962: 
 14962:     if (aFakeCharMessage) {
 68737:       RemoveMessageAndDispatchPluginEvent(WM_KEYFIRST, WM_KEYLAST,
 68737:                                           aFakeCharMessage);
 79626:       anyCharMessagesRemoved = true;
 14962:     } else {
     1:       while (gotMsg && (msg.message == WM_CHAR || msg.message == WM_SYSCHAR))
     1:       {
 29835:         PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
 76714:                ("%s charCode=%d scanCode=%d\n", msg.message == WM_SYSCHAR ? 
 76714:                                                 "WM_SYSCHAR" : "WM_CHAR",
 14962:                 msg.wParam, HIWORD(msg.lParam) & 0xFF));
 22788:         RemoveMessageAndDispatchPluginEvent(WM_KEYFIRST, WM_KEYLAST);
 79626:         anyCharMessagesRemoved = true;
     1: 
     1:         gotMsg = ::PeekMessageW (&msg, mWnd, WM_KEYFIRST, WM_KEYLAST, PM_NOREMOVE | PM_NOYIELD);
     1:       }
 14962:     }
     1: 
 27961:     if (!anyCharMessagesRemoved && DOMKeyCode == NS_VK_BACK &&
 27961:         nsIMM32Handler::IsDoingKakuteiUndo(mWnd)) {
 27961:       NS_ASSERTION(!aFakeCharMessage,
 27961:                    "We shouldn't be touching the real msg queue");
 22788:       RemoveMessageAndDispatchPluginEvent(WM_CHAR, WM_CHAR);
     1:     }
     1:   }
     1:   else if (gotMsg &&
 14962:            (aFakeCharMessage ||
 14962:             msg.message == WM_CHAR || msg.message == WM_SYSCHAR || msg.message == WM_DEADCHAR)) {
 68737:     if (aFakeCharMessage) {
 68737:       MSG msg = aFakeCharMessage->GetCharMessage(mWnd);
102106:       if (msg.message == WM_DEADCHAR) {
102106:         return false;
102106:       }
102107: #ifdef DEBUG
102107:       if (KeyboardLayout::IsPrintableCharKey(virtualKeyCode)) {
102107:         nsPrintfCString log(
102107:           "virtualKeyCode=0x%02X, inputtingChar={ mChars=[ 0x%04X, 0x%04X, "
102107:           "0x%04X, 0x%04X, 0x%04X ], mLength=%d }, wParam=0x%04X",
102107:           virtualKeyCode, inputtingChars.mChars[0], inputtingChars.mChars[1],
102107:           inputtingChars.mChars[2], inputtingChars.mChars[3],
102107:           inputtingChars.mChars[4], inputtingChars.mLength, msg.wParam);
102107:         if (!inputtingChars.mLength) {
102107:           log.Insert("length is zero: ", 0);
102107:           NS_ERROR(log.get());
102107:           NS_ABORT();
102107:         } else if (inputtingChars.mChars[0] != msg.wParam) {
102107:           log.Insert("character mismatch: ", 0);
102107:           NS_ERROR(log.get());
102107:           NS_ABORT();
102107:         }
102107:       }
102107: #endif // #ifdef DEBUG
126032:       return OnChar(msg, nativeKey, aModKeyState, nullptr, &extraFlags);
 68737:     }
 14962: 
     1:     // If prevent default set for keydown, do same for keypress
     1:     ::GetMessageW(&msg, mWnd, msg.message, msg.message);
     1: 
 22788:     if (msg.message == WM_DEADCHAR) {
 22788:       if (!PluginHasFocus())
 79626:         return false;
     1: 
 22788:       // We need to send the removed message to focused plug-in.
 22788:       DispatchPluginEvent(msg);
 22788:       return noDefault;
 22788:     }
 22788: 
 29835:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
 14962:            ("%s charCode=%d scanCode=%d\n",
 14962:             msg.message == WM_SYSCHAR ? "WM_SYSCHAR" : "WM_CHAR",
 14962:             msg.wParam, HIWORD(msg.lParam) & 0xFF));
 14962: 
126032:     BOOL result = OnChar(msg, nativeKey, aModKeyState, nullptr, &extraFlags);
  7027:     // If a syschar keypress wasn't processed, Windows may want to
  7027:     // handle it to activate a native menu.
  7027:     if (!result && msg.message == WM_SYSCHAR)
  7027:       ::DefWindowProcW(mWnd, msg.message, msg.wParam, msg.lParam);
  7027:     return result;
 23335:   }
102101:   else if (!aModKeyState.IsControl() && !aModKeyState.IsAlt() &&
105732:             !aModKeyState.IsWin() &&
102105:             KeyboardLayout::IsPrintableCharKey(virtualKeyCode)) {
     1:     // If this is simple KeyDown event but next message is not WM_CHAR,
     1:     // this event may not input text, so we should ignore this event.
     1:     // See bug 314130.
 22788:     return PluginHasFocus() && noDefault;
     1:   }
     1: 
102100:   if (isDeadKey) {
 22788:     return PluginHasFocus() && noDefault;
102100:   }
     1: 
102104:   UniCharsAndModifiers shiftedChars;
102104:   UniCharsAndModifiers unshiftedChars;
108991:   uint32_t shiftedLatinChar = 0;
108991:   uint32_t unshiftedLatinChar = 0;
     1: 
102104:   if (!KeyboardLayout::IsPrintableCharKey(virtualKeyCode)) {
102104:     inputtingChars.Clear();
 14328:   }
 14328: 
102101:   if (aModKeyState.IsControl() ^ aModKeyState.IsAlt()) {
102104:     widget::ModifierKeyState capsLockState(
102104:       aModKeyState.GetModifiers() & MODIFIER_CAPSLOCK);
102104:     unshiftedChars =
102104:       gKbdLayout.GetUniCharsAndModifiers(virtualKeyCode, capsLockState);
102104:     capsLockState.Set(MODIFIER_SHIFT);
102104:     shiftedChars =
102104:       gKbdLayout.GetUniCharsAndModifiers(virtualKeyCode, capsLockState);
 14799: 
 14476:     // The current keyboard cannot input alphabets or numerics,
 14476:     // we should append them for Shortcut/Access keys.
 14476:     // E.g., for Cyrillic keyboard layout.
102104:     capsLockState.Unset(MODIFIER_SHIFT);
102104:     WidgetUtils::GetLatinCharCodeForKeyCode(DOMKeyCode,
102104:                                             capsLockState.GetModifiers(),
 98715:                                             &unshiftedLatinChar,
 98715:                                             &shiftedLatinChar);
 98715: 
 98715:     // If the shiftedLatinChar isn't 0, the key code is NS_VK_[A-Z].
 98715:     if (shiftedLatinChar) {
 98715:       // If the produced characters of the key on current keyboard layout
 98715:       // are same as computed Latin characters, we shouldn't append the
 98715:       // Latin characters to alternativeCharCode.
102104:       if (unshiftedLatinChar == unshiftedChars.mChars[0] &&
102104:           shiftedLatinChar == shiftedChars.mChars[0]) {
 14799:         shiftedLatinChar = unshiftedLatinChar = 0;
 14799:       }
 98715:     } else if (unshiftedLatinChar) {
 98715:       // If the shiftedLatinChar is 0, the keyCode doesn't produce
 98715:       // alphabet character.  At that time, the character may be produced
 98715:       // with Shift key.  E.g., on French keyboard layout, NS_VK_PERCENT
 98715:       // key produces LATIN SMALL LETTER U WITH GRAVE (U+00F9) without
 98715:       // Shift key but with Shift key, it produces '%'.
 98715:       // If the unshiftedLatinChar is produced by the key on current
 98715:       // keyboard layout, we shouldn't append it to alternativeCharCode.
102104:       if (unshiftedLatinChar == unshiftedChars.mChars[0] ||
102104:           unshiftedLatinChar == shiftedChars.mChars[0]) {
 98715:         unshiftedLatinChar = 0;
 14799:       }
 14799:     }
 14799: 
 14799:     // If the charCode is not ASCII character, we should replace the
 14799:     // charCode with ASCII character only when Ctrl is pressed.
 14799:     // But don't replace the charCode when the charCode is not same as
 14799:     // unmodified characters. In such case, Ctrl is sometimes used for a
 14799:     // part of character inputting key combination like Shift.
102101:     if (aModKeyState.IsControl()) {
108991:       uint32_t ch =
102101:         aModKeyState.IsShift() ? shiftedLatinChar : unshiftedLatinChar;
 14799:       if (ch &&
102104:           (!inputtingChars.mLength ||
102104:            inputtingChars.UniCharsCaseInsensitiveEqual(
102104:              aModKeyState.IsShift() ? shiftedChars : unshiftedChars))) {
102104:         inputtingChars.Clear();
102104:         inputtingChars.Append(ch, aModKeyState.GetModifiers());
102104:       }
102104:     }
102104:   }
102104: 
102104:   if (inputtingChars.mLength ||
102104:       shiftedChars.mLength || unshiftedChars.mLength) {
108991:     uint32_t num = NS_MAX(inputtingChars.mLength,
102104:                           NS_MAX(shiftedChars.mLength, unshiftedChars.mLength));
108991:     uint32_t skipUniChars = num - inputtingChars.mLength;
108991:     uint32_t skipShiftedChars = num - shiftedChars.mLength;
108991:     uint32_t skipUnshiftedChars = num - unshiftedChars.mLength;
102104:     UINT keyCode = !inputtingChars.mLength ? DOMKeyCode : 0;
108991:     for (uint32_t cnt = 0; cnt < num; cnt++) {
108991:       uint16_t uniChar, shiftedChar, unshiftedChar;
 14328:       uniChar = shiftedChar = unshiftedChar = 0;
102101:       ModifierKeyState modKeyState(aModKeyState);
 14328:       if (skipUniChars <= cnt) {
102104:         if (cnt - skipUniChars  < inputtingChars.mLength) {
 14328:           // If key in combination with Alt and/or Ctrl produces a different
 14328:           // character than without them then do not report these flags
 14328:           // because it is separate keyboard layout shift state. If dead-key
 14328:           // and base character does not produce a valid composite character
 14328:           // then both produced dead-key character and following base
 14328:           // character may have different modifier flags, too.
102102:           modKeyState.Unset(MODIFIER_SHIFT | MODIFIER_CONTROL | MODIFIER_ALT |
102102:                             MODIFIER_ALTGRAPH | MODIFIER_CAPSLOCK);
102104:           modKeyState.Set(inputtingChars.mModifiers[cnt - skipUniChars]);
102104:         }
102104:         uniChar = inputtingChars.mChars[cnt - skipUniChars];
 14328:       }
 14328:       if (skipShiftedChars <= cnt)
102104:         shiftedChar = shiftedChars.mChars[cnt - skipShiftedChars];
 14328:       if (skipUnshiftedChars <= cnt)
102104:         unshiftedChar = unshiftedChars.mChars[cnt - skipUnshiftedChars];
 14476:       nsAutoTArray<nsAlternativeCharCode, 5> altArray;
 14476: 
 14476:       if (shiftedChar || unshiftedChar) {
 14476:         nsAlternativeCharCode chars(unshiftedChar, shiftedChar);
 14476:         altArray.AppendElement(chars);
 14476:       }
 99731:       if (cnt == num - 1) {
 99731:         if (unshiftedLatinChar || shiftedLatinChar) {
 14476:           nsAlternativeCharCode chars(unshiftedLatinChar, shiftedLatinChar);
 14476:           altArray.AppendElement(chars);
 14476:         }
 14476: 
 99731:         // Typically, following virtual keycodes are used for a key which can
 99731:         // input the character.  However, these keycodes are also used for
 99731:         // other keys on some keyboard layout.  E.g., in spite of Shift+'1'
 99731:         // inputs '+' on Thai keyboard layout, a key which is at '=/+'
 99731:         // key on ANSI keyboard layout is VK_OEM_PLUS.  Native applications
 99731:         // handle it as '+' key if Ctrl key is pressed.
 99731:         PRUnichar charForOEMKeyCode = 0;
 99731:         switch (virtualKeyCode) {
 99731:           case VK_OEM_PLUS:   charForOEMKeyCode = '+'; break;
 99731:           case VK_OEM_COMMA:  charForOEMKeyCode = ','; break;
 99731:           case VK_OEM_MINUS:  charForOEMKeyCode = '-'; break;
 99731:           case VK_OEM_PERIOD: charForOEMKeyCode = '.'; break;
 99731:         }
 99731:         if (charForOEMKeyCode &&
102104:             charForOEMKeyCode != unshiftedChars.mChars[0] &&
102104:             charForOEMKeyCode != shiftedChars.mChars[0] &&
 99731:             charForOEMKeyCode != unshiftedLatinChar &&
 99731:             charForOEMKeyCode != shiftedLatinChar) {
 99731:           nsAlternativeCharCode OEMChars(charForOEMKeyCode, charForOEMKeyCode);
 99731:           altArray.AppendElement(OEMChars);
 99731:         }
 99731:       }
 99731: 
 97476:       nsKeyEvent keypressEvent(true, NS_KEY_PRESS, this);
127019:       keypressEvent.mFlags.Union(extraFlags);
 97476:       keypressEvent.charCode = uniChar;
 97476:       keypressEvent.alternativeCharCodes.AppendElements(altArray);
102101:       InitKeyEvent(keypressEvent, nativeKey, modKeyState);
106838:       DispatchKeyEvent(keypressEvent, nullptr);
     1:     }
 30405:   } else {
 97476:     nsKeyEvent keypressEvent(true, NS_KEY_PRESS, this);
127019:     keypressEvent.mFlags.Union(extraFlags);
 97476:     keypressEvent.keyCode = DOMKeyCode;
 97476:     InitKeyEvent(keypressEvent, nativeKey, aModKeyState);
106838:     DispatchKeyEvent(keypressEvent, nullptr);
 30405:   }
     1: 
     1:   return noDefault;
     1: }
     1: 
 29835: // OnKeyUp
 27961: LRESULT nsWindow::OnKeyUp(const MSG &aMsg,
102101:                           const ModifierKeyState &aModKeyState,
 79445:                           bool *aEventDispatched)
 22788: {
 98715:   // NOTE: VK_PROCESSKEY never comes with WM_KEYUP
 29835:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,
 97676:          ("nsWindow::OnKeyUp wParam(VK)=%d\n", aMsg.wParam));
 27961: 
 22788:   if (aEventDispatched)
 79626:     *aEventDispatched = true;
 97476:   nsKeyEvent keyupEvent(true, NS_KEY_UP, this);
 98715:   NativeKey nativeKey(gKbdLayout, this, aMsg);
 97676:   keyupEvent.keyCode = nativeKey.GetDOMKeyCode();
 97476:   InitKeyEvent(keyupEvent, nativeKey, aModKeyState);
 97476:   return DispatchKeyEvent(keyupEvent, &aMsg);
 22788: }
 22788: 
 29835: // OnChar
 97476: LRESULT nsWindow::OnChar(const MSG &aMsg,
 97476:                          const NativeKey& aNativeKey,
102101:                          const ModifierKeyState &aModKeyState,
126032:                          bool *aEventDispatched,
126032:                          const EventFlags *aExtraFlags)
 27961: {
     1:   // ignore [shift+]alt+space so the OS can handle it
102101:   if (aModKeyState.IsAlt() && !aModKeyState.IsControl() &&
 27961:       IS_VK_DOWN(NS_VK_SPACE)) {
     1:     return FALSE;
     1:   }
     1: 
108991:   uint32_t charCode = aMsg.wParam;
 16335:   // Ignore Ctrl+Enter (bug 318235)
102101:   if (aModKeyState.IsControl() && charCode == 0xA) {
 16335:     return FALSE;
 16335:   }
 16335: 
     1:   // WM_CHAR with Control and Alt (== AltGr) down really means a normal character
102101:   ModifierKeyState modKeyState(aModKeyState);
102101:   if (modKeyState.IsAlt() && modKeyState.IsControl()) {
102101:     modKeyState.Unset(MODIFIER_ALT | MODIFIER_CONTROL);
102101:   }
     1: 
 49149:   if (nsIMM32Handler::IsComposingOn(this)) {
 27961:     ResetInputState();
 27961:   }
 27961: 
 97676:   wchar_t uniChar;
102101:   // Ctrl+A Ctrl+Z, see Programming Windows 3.1 page 110 for details
102101:   if (modKeyState.IsControl() && charCode <= 0x1A) {
     1:     // need to account for shift here.  bug 16486
102101:     if (modKeyState.IsShift()) {
     1:       uniChar = charCode - 1 + 'A';
102101:     } else {
     1:       uniChar = charCode - 1 + 'a';
     1:     }
102101:   } else if (modKeyState.IsControl() && charCode <= 0x1F) {
     1:     // Fix for 50255 - <ctrl><[> and <ctrl><]> are not being processed.
     1:     // also fixes ctrl+\ (x1c), ctrl+^ (x1e) and ctrl+_ (x1f)
     1:     // for some reason the keypress handler need to have the uniChar code set
     1:     // with the addition of a upper case A not the lower case.
     1:     uniChar = charCode - 1 + 'A';
     1:   } else { // 0x20 - SPACE, 0x3D - EQUALS
102101:     if (charCode < 0x20 || (charCode == 0x3D && modKeyState.IsControl())) {
     1:       uniChar = 0;
     1:     } else {
     1:       uniChar = charCode;
     1:     }
     1:   }
     1: 
     1:   // Keep the characters unshifted for shortcuts and accesskeys and make sure
     1:   // that numbers are always passed as such (among others: bugs 50255 and 351310)
102101:   if (uniChar && (modKeyState.IsControl() || modKeyState.IsAlt())) {
 97676:     UINT virtualKeyCode = ::MapVirtualKeyEx(aNativeKey.GetScanCode(),
 97476:                                             MAPVK_VSC_TO_VK,
 22411:                                             gKbdLayout.GetLayout());
     1:     UINT unshiftedCharCode =
     1:       virtualKeyCode >= '0' && virtualKeyCode <= '9' ? virtualKeyCode :
102101:         modKeyState.IsShift() ? ::MapVirtualKeyEx(virtualKeyCode,
 27961:                                                   MAPVK_VK_TO_CHAR,
 22411:                                                   gKbdLayout.GetLayout()) : 0;
     1:     // ignore diacritics (top bit set) and key mapping errors (char code 0)
     1:     if ((INT)unshiftedCharCode > 0)
     1:       uniChar = unshiftedCharCode;
     1:   }
     1: 
     1:   // Fix for bug 285161 (and 295095) which was caused by the initial fix for bug 178110.
     1:   // When pressing (alt|ctrl)+char, the char must be lowercase unless shift is
     1:   // pressed too.
102101:   if (!modKeyState.IsShift() &&
102101:       (aModKeyState.IsAlt() || aModKeyState.IsControl())) {
     1:     uniChar = towlower(uniChar);
     1:   }
     1: 
 97476:   nsKeyEvent keypressEvent(true, NS_KEY_PRESS, this);
126032:   if (aExtraFlags) {
127019:     keypressEvent.mFlags.Union(*aExtraFlags);
126032:   }
 97476:   keypressEvent.charCode = uniChar;
 97676:   if (!keypressEvent.charCode) {
 97676:     keypressEvent.keyCode = aNativeKey.GetDOMKeyCode();
 97676:   }
102101:   InitKeyEvent(keypressEvent, aNativeKey, modKeyState);
 97476:   bool result = DispatchKeyEvent(keypressEvent, &aMsg);
 22788:   if (aEventDispatched)
 79626:     *aEventDispatched = true;
     1:   return result;
     1: }
     1: 
 29835: void
108991: nsWindow::SetupKeyModifiersSequence(nsTArray<KeyPair>* aArray, uint32_t aModifiers)
108991: {
108991:   for (uint32_t i = 0; i < ArrayLength(sModifierKeyMap); ++i) {
108991:     const uint32_t* map = sModifierKeyMap[i];
 14962:     if (aModifiers & map[0]) {
 14962:       aArray->AppendElement(KeyPair(map[1], map[2]));
 14962:     }
 14962:   }
 14962: }
 14962: 
106128: static BOOL WINAPI EnumFirstChild(HWND hwnd, LPARAM lParam)
106128: {
106128:   *((HWND*)lParam) = hwnd;
106128:   return FALSE;
106128: }
106128: 
106128: static void InvalidatePluginAsWorkaround(nsWindow *aWindow, const nsIntRect &aRect)
106128: {
106128:   aWindow->Invalidate(aRect);
106128: 
106128:   // XXX - Even more evil workaround!! See bug 762948, flash's bottom
106128:   // level sandboxed window doesn't seem to get our invalidate. We send
106128:   // an invalidate to it manually. This is totally specialized for this
106128:   // bug, for other child window structures this will just be a more or
106128:   // less bogus invalidate but since that should not have any bad
106128:   // side-effects this will have to do for now.
106128:   HWND current = (HWND)aWindow->GetNativeData(NS_NATIVE_WINDOW);
106128: 
106128:   RECT windowRect;
106128:   RECT parentRect;
106128: 
106128:   ::GetWindowRect(current, &parentRect);
106128:         
106128:   HWND next = current;
106128: 
106128:   do {
106128:     current = next;
106128: 
106128:     ::EnumChildWindows(current, &EnumFirstChild, (LPARAM)&next);
106128: 
106128:     ::GetWindowRect(next, &windowRect);
106128:     // This is relative to the screen, adjust it to be relative to the
106128:     // window we're reconfiguring.
106128:     windowRect.left -= parentRect.left;
106128:     windowRect.top -= parentRect.top;
106128:   } while (next != current && windowRect.top == 0 && windowRect.left == 0);
106128: 
106128:   if (windowRect.top == 0 && windowRect.left == 0) {
106128:     RECT rect;
106128:     rect.left   = aRect.x;
106128:     rect.top    = aRect.y;
106128:     rect.right  = aRect.XMost();
106128:     rect.bottom = aRect.YMost();
106128: 
106128:     ::InvalidateRect(next, &rect, FALSE);
106128:   }
106128: }
106128: 
 30515: nsresult
 30515: nsWindow::ConfigureChildren(const nsTArray<Configuration>& aConfigurations)
 30515: {
 30515:   // XXXroc we could use BeginDeferWindowPos/DeferWindowPos/EndDeferWindowPos
 30515:   // here, if that helps in some situations. So far I haven't seen a
 30515:   // need.
108991:   for (uint32_t i = 0; i < aConfigurations.Length(); ++i) {
 30515:     const Configuration& configuration = aConfigurations[i];
 30515:     nsWindow* w = static_cast<nsWindow*>(configuration.mChild);
 30515:     NS_ASSERTION(w->GetParent() == this,
 30515:                  "Configured widget is not a child");
 79626:     nsresult rv = w->SetWindowClipRegion(configuration.mClipRegion, true);
 51672:     NS_ENSURE_SUCCESS(rv, rv);
 30688:     nsIntRect bounds;
 30688:     w->GetBounds(bounds);
 30688:     if (bounds.Size() != configuration.mBounds.Size()) {
 30515:       w->Resize(configuration.mBounds.x, configuration.mBounds.y,
 30515:                 configuration.mBounds.width, configuration.mBounds.height,
 79626:                 true);
 30688:     } else if (bounds.TopLeft() != configuration.mBounds.TopLeft()) {
 30688:       w->Move(configuration.mBounds.x, configuration.mBounds.y);
 58644: 
 58644: 
 58644:       if (gfxWindowsPlatform::GetPlatform()->GetRenderMode() ==
 58644:           gfxWindowsPlatform::RENDER_DIRECT2D ||
105710:           GetLayerManager()->GetBackendType() != LAYERS_BASIC) {
 58644:         // XXX - Workaround for Bug 587508. This will invalidate the part of the
 58644:         // plugin window that might be touched by moving content somehow. The
 58644:         // underlying problem should be found and fixed!
 58644:         nsIntRegion r;
 58644:         r.Sub(bounds, configuration.mBounds);
 58644:         r.MoveBy(-bounds.x,
 58644:                  -bounds.y);
106128:         nsIntRect toInvalidate = r.GetBounds();
106128: 
106128:         InvalidatePluginAsWorkaround(w, toInvalidate);
 79626:       }
 79626:     }
 79626:     rv = w->SetWindowClipRegion(configuration.mClipRegion, false);
 30515:     NS_ENSURE_SUCCESS(rv, rv);
 30515:   }
 30515:   return NS_OK;
 30515: }
 30515: 
 30515: static HRGN
 30515: CreateHRGNFromArray(const nsTArray<nsIntRect>& aRects)
 30515: {
108991:   int32_t size = sizeof(RGNDATAHEADER) + sizeof(RECT)*aRects.Length();
108991:   nsAutoTArray<uint8_t,100> buf;
 30515:   if (!buf.SetLength(size))
 30515:     return NULL;
 30515:   RGNDATA* data = reinterpret_cast<RGNDATA*>(buf.Elements());
 30515:   RECT* rects = reinterpret_cast<RECT*>(data->Buffer);
 30515:   data->rdh.dwSize = sizeof(data->rdh);
 30515:   data->rdh.iType = RDH_RECTANGLES;
 30515:   data->rdh.nCount = aRects.Length();
 30515:   nsIntRect bounds;
108991:   for (uint32_t i = 0; i < aRects.Length(); ++i) {
 30515:     const nsIntRect& r = aRects[i];
 30515:     bounds.UnionRect(bounds, r);
 30515:     ::SetRect(&rects[i], r.x, r.y, r.XMost(), r.YMost());
 30515:   }
 30515:   ::SetRect(&data->rdh.rcBound, bounds.x, bounds.y, bounds.XMost(), bounds.YMost());
 30515:   return ::ExtCreateRegion(NULL, buf.Length(), data);
 30515: }
 30515: 
124362: static void
124362: ArrayFromRegion(const nsIntRegion& aRegion, nsTArray<nsIntRect>& aRects)
124362: {
 59749:   const nsIntRect* r;
 59749:   for (nsIntRegionRectIterator iter(aRegion); (r = iter.Next());) {
124362:     aRects.AppendElement(*r);
124362:   }
 59749: }
 59749: 
 30515: nsresult
 30515: nsWindow::SetWindowClipRegion(const nsTArray<nsIntRect>& aRects,
 79445:                               bool aIntersectWithExisting)
 30515: {
 30688:   if (!aIntersectWithExisting) {
 30688:     if (!StoreWindowClipRegion(aRects))
 30688:       return NS_OK;
 51672:   } else {
 51672:     // In this case still early return if nothing changed.
 51672:     if (mClipRects && mClipRectCount == aRects.Length() &&
 51672:         memcmp(mClipRects,
 51672:                aRects.Elements(),
 51672:                sizeof(nsIntRect)*mClipRectCount) == 0) {
 51672:       return NS_OK;
 51672:     }
 59749: 
 59749:     // get current rects
 59749:     nsTArray<nsIntRect> currentRects;
 59749:     GetWindowClipRegion(&currentRects);
 59749:     // create region from them
 59749:     nsIntRegion currentRegion = RegionFromArray(currentRects);
 59749:     // create region from new rects
 59749:     nsIntRegion newRegion = RegionFromArray(aRects);
 59749:     // intersect regions
 59749:     nsIntRegion intersection;
 59749:     intersection.And(currentRegion, newRegion);
 59749:     // create int rect array from intersection
124362:     nsTArray<nsIntRect> rects;
124362:     ArrayFromRegion(intersection, rects);
 59749:     // store
 59749:     if (!StoreWindowClipRegion(rects))
 59749:       return NS_OK;
 30688:   }
 30688: 
 30515:   HRGN dest = CreateHRGNFromArray(aRects);
 30515:   if (!dest)
 30515:     return NS_ERROR_OUT_OF_MEMORY;
 30515: 
 30515:   if (aIntersectWithExisting) {
 30515:     HRGN current = ::CreateRectRgn(0, 0, 0, 0);
 30515:     if (current) {
 30515:       if (::GetWindowRgn(mWnd, current) != 0 /*ERROR*/) {
 30515:         ::CombineRgn(dest, dest, current, RGN_AND);
 30515:       }
 30515:       ::DeleteObject(current);
 30515:     }
 30515:   }
 30515: 
 89735:   // If a plugin is not visible, especially if it is in a background tab,
 77660:   // it should not be able to steal keyboard focus.  This code checks whether
 77660:   // the region that the plugin is being clipped to is NULLREGION.  If it is,
 77660:   // the plugin window gets disabled.
 77660:   if(mWindowType == eWindowType_plugin) {
 77660:     if(NULLREGION == ::CombineRgn(dest, dest, dest, RGN_OR)) {
 91763:       ::ShowWindow(mWnd, SW_HIDE);
 77660:       ::EnableWindow(mWnd, FALSE);
 77660:     } else {
 77660:       ::EnableWindow(mWnd, TRUE);
 91763:       ::ShowWindow(mWnd, SW_SHOW);
 77660:     }
 77660:   }
 30515:   if (!::SetWindowRgn(mWnd, dest, TRUE)) {
 30515:     ::DeleteObject(dest);
 30515:     return NS_ERROR_FAILURE;
 30515:   }
 30515:   return NS_OK;
 30515: }
 30515: 
 30223: // WM_DESTROY event handler
     1: void nsWindow::OnDestroy()
     1: {
 79626:   mOnDestroyCalled = true;
     1: 
 30223:   // Make sure we don't get destroyed in the process of tearing down.
 30223:   nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
 30223:   
108456:   // Dispatch the destroy notification.
 30223:   if (!mInDtor)
108456:     NotifyWindowDestroyed();
 30223: 
 30223:   // Prevent the widget from sending additional events.
108460:   mWidgetListener = nullptr;
108461:   mAttachedWidgetListener = nullptr;
 30223: 
 30223:   // Free our subclass and clear |this| stored in the window props. We will no longer
 30223:   // receive events from Windows after this point.
     1:   SubclassWindow(FALSE);
  4186: 
108460:   // Once mWidgetListener is cleared and the subclass is reset, sCurrentWindow can be
 30223:   // cleared. (It's used in tracking windows for mouse events.)
 30223:   if (sCurrentWindow == this)
106838:     sCurrentWindow = nullptr;
 30223: 
 30223:   // Disconnects us from our parent, will call our GetParent().
 30223:   nsBaseWidget::Destroy();
 30223: 
 30223:   // Release references to children, device context, toolkit, and app shell.
 30223:   nsBaseWidget::OnDestroy();
 30223:   
 30223:   // Clear our native parent handle.
106838:   // XXX Windows will take care of this in the proper order, and SetParent(nullptr)'s
 30223:   // remove child on the parent already took place in nsBaseWidget's Destroy call above.
106838:   //SetParent(nullptr);
106838:   mParent = nullptr;
 30223: 
 30223:   // We have to destroy the native drag target before we null out our window pointer.
 79626:   EnableDragDrop(false);
  4186: 
 30223:   // If we're going away and for some reason we're still the rollup widget, rollup and
 30223:   // turn off capture.
120177:   nsIRollupListener* rollupListener = nsBaseWidget::GetActiveRollupListener();
127124:   nsCOMPtr<nsIWidget> rollupWidget;
127124:   if (rollupListener) {
127124:     rollupWidget = rollupListener->GetRollupWidget();
127124:   }
120177:   if (this == rollupWidget) {
120177:     if ( rollupListener )
120177:       rollupListener->Rollup(0, nullptr);
120177:     CaptureRollupEvents(nullptr, false);
 30223:   }
 30223: 
 73536:   // Restore the IM context.
 79626:   AssociateDefaultIMC(true);
 30223: 
 30223:   // Turn off mouse trails if enabled.
 30223:   MouseTrailer* mtrailer = nsToolkit::gMouseTrailer;
 30223:   if (mtrailer) {
 30223:     if (mtrailer->GetMouseTrailerWindow() == mWnd)
 30223:       mtrailer->DestroyTimer();
 30223: 
 30223:     if (mtrailer->GetCaptureWindow() == mWnd)
106838:       mtrailer->SetCaptureWindow(nullptr);
 30223:   }
 30223: 
 30223:   // Free GDI window class objects
     1:   if (mBrush) {
     1:     VERIFY(::DeleteObject(mBrush));
     1:     mBrush = NULL;
     1:   }
     1: 
 30223: 
 30223:   // Destroy any custom cursor resources.
 30223:   if (mCursor == -1)
 30223:     SetCursor(eCursor_standard);
 30223: 
 30223: #ifdef MOZ_XUL
 30223:   // Reset transparency
 30223:   if (eTransparencyTransparent == mTransparencyMode)
 30223:     SetupTranslucentWindowMemoryBitmap(eTransparencyOpaque);
 30223: #endif
 30223: 
 43073:   // Finalize panning feedback to possibly restore window displacement
 79626:   mGesture.PanFeedbackFinalize(mWnd, true);
 43073: 
 30223:   // Clear the main HWND.
 30223:   mWnd = NULL;
     1: }
     1: 
 29835: // OnMove
108991: bool nsWindow::OnMove(int32_t aX, int32_t aY)
     1: {
     1:   mBounds.x = aX;
     1:   mBounds.y = aY;
     1: 
108457:   return mWidgetListener ? mWidgetListener->WindowMoved(this, aX, aY) : false;
     1: }
     1: 
     1: // Send a resize message to the listener
 79445: bool nsWindow::OnResize(nsIntRect &aWindowRect)
     1: {
 38727: #ifdef CAIRO_HAS_D2D_SURFACE
 38727:   if (mD2DWindowSurface) {
 38727:     mD2DWindowSurface = NULL;
 87336:     Invalidate();
 38727:   }
 38727: #endif
 51610: 
109287:   bool result = mWidgetListener ?
109287:                 mWidgetListener->WindowResized(this, aWindowRect.width, aWindowRect.height) : false;
109287: 
108460:   // If there is an attached view, inform it as well as the normal widget listener.
108461:   if (mAttachedWidgetListener) {
109287:     return mAttachedWidgetListener->WindowResized(this, aWindowRect.width, aWindowRect.height);
109287:   }
109287: 
109287:   return result;
     1: }
     1: 
 79445: bool nsWindow::OnHotKey(WPARAM wParam, LPARAM lParam)
 29835: {
 79626:   return true;
 29835: }
 29835: 
 32194: // Can be overriden. Controls auto-erase of background.
 79445: bool nsWindow::AutoErase(HDC dc)
 32194: {
 79626:   return false;
     1: }
     1: 
 58814: void
 58814: nsWindow::AllowD3D9Callback(nsWindow *aWindow)
 58814: {
 58814:   if (aWindow->mLayerManager) {
 58814:     aWindow->mLayerManager->Destroy();
 58814:     aWindow->mLayerManager = NULL;
 58814:   }
 58814: }
 58814: 
 58814: void
 58814: nsWindow::AllowD3D9WithReinitializeCallback(nsWindow *aWindow)
 58814: {
 58814:   if (aWindow->mLayerManager) {
 58814:     aWindow->mLayerManager->Destroy();
 58814:     aWindow->mLayerManager = NULL;
 58814:     (void) aWindow->GetLayerManager();
 58814:   }
 58814: }
 58814: 
 58814: void
 58814: nsWindow::StartAllowingD3D9(bool aReinitialize)
 58814: {
 58814:   sAllowD3D9 = true;
 58814: 
 60398:   LayerManagerPrefs prefs;
 60398:   GetLayerManagerPrefs(&prefs);
 60398:   if (prefs.mDisableAcceleration) {
 60398:     // The guarantee here is, if there's *any* chance that after we
 60398:     // throw out our layer managers we'd create at least one new,
 60398:     // accelerated one, we *will* throw out all the current layer
 60398:     // managers.  We early-return here because currently, if
 60398:     // |disableAcceleration|, we will always use basic managers and
 60398:     // it's a waste to recreate them.
 60398:     //
 60398:     // NB: the above implies that it's eminently possible for us to
 60398:     // skip this early return but still recreate basic managers.
 60398:     // That's OK.  It's *not* OK to take this early return when we
 60398:     // *might* have created an accelerated manager.
 60398:     return;
 60398:   }
 60398: 
 58814:   if (aReinitialize) {
 58814:     EnumAllWindows(AllowD3D9WithReinitializeCallback);
 58814:   } else {
 58814:     EnumAllWindows(AllowD3D9Callback);
 58814:   }
 58814: }
 58814: 
 63258: bool
 63258: nsWindow::HasBogusPopupsDropShadowOnMultiMonitor() {
 63258:   if (sHasBogusPopupsDropShadowOnMultiMonitor == TRI_UNKNOWN) {
 63258:     // Since any change in the preferences requires a restart, this can be
 63258:     // done just once.
 63258:     // Check for Direct2D first.
 63258:     sHasBogusPopupsDropShadowOnMultiMonitor =
 63258:       gfxWindowsPlatform::GetPlatform()->GetRenderMode() ==
 63258:         gfxWindowsPlatform::RENDER_DIRECT2D ? TRI_TRUE : TRI_FALSE;
 63258:     if (!sHasBogusPopupsDropShadowOnMultiMonitor) {
 63258:       // Otherwise check if Direct3D 9 may be used.
 63258:       LayerManagerPrefs prefs;
 63258:       GetLayerManagerPrefs(&prefs);
 63258:       if (!prefs.mDisableAcceleration && !prefs.mPreferOpenGL) {
 63258:         nsCOMPtr<nsIGfxInfo> gfxInfo = do_GetService("@mozilla.org/gfx/info;1");
 63258:         if (gfxInfo) {
108991:           int32_t status;
 63258:           if (NS_SUCCEEDED(gfxInfo->GetFeatureStatus(nsIGfxInfo::FEATURE_DIRECT3D_9_LAYERS, &status))) {
 63258:             if (status == nsIGfxInfo::FEATURE_NO_INFO || prefs.mForceAcceleration)
 63258:             {
 63258:               sHasBogusPopupsDropShadowOnMultiMonitor = TRI_TRUE;
 63258:             }
 63258:           }
 63258:         }
 63258:       }
 63258:     }
 63258:   }
 63258:   return !!sHasBogusPopupsDropShadowOnMultiMonitor;
 63258: }
 63258: 
 82569: void
 82569: nsWindow::OnSysColorChanged()
 82569: {
 82569:   if (mWindowType == eWindowType_invisible) {
 82569:     ::EnumThreadWindows(GetCurrentThreadId(), nsWindow::BroadcastMsg, WM_SYSCOLORCHANGE);
 82569:   }
 82569:   else {
 82569:     // Note: This is sent for child windows as well as top-level windows.
 82569:     // The Win32 toolkit normally only sends these events to top-level windows.
 82569:     // But we cycle through all of the childwindows and send it to them as well
 82569:     // so all presentations get notified properly.
 82569:     // See nsWindow::GlobalMsgWindowProc.
108452:     NotifySysColorChanged();
 82569:   }
 82569: }
 82569: 
 29835: /**************************************************************
 29835:  **************************************************************
 29835:  **
 29835:  ** BLOCK: IME management and accessibility
 29835:  **
 29835:  ** Handles managing IME input and accessibility.
 29835:  **
 29835:  **************************************************************
 29835:  **************************************************************/
 29835: 
     1: NS_IMETHODIMP nsWindow::ResetInputState()
     1: {
     1: #ifdef DEBUG_KBSTATE
 76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("ResetInputState\n"));
     1: #endif
 24836: 
 24836: #ifdef NS_ENABLE_TSF
 79626:   nsTextStore::CommitComposition(false);
 24836: #endif //NS_ENABLE_TSF
 24836: 
 49149:   nsIMM32Handler::CommitComposition(this);
     1:   return NS_OK;
     1: }
     1: 
 82841: NS_IMETHODIMP_(void)
 82841: nsWindow::SetInputContext(const InputContext& aContext,
 82841:                           const InputContextAction& aAction)
 82840: {
 24836: #ifdef NS_ENABLE_TSF
 82841:   nsTextStore::SetInputContext(aContext);
 24836: #endif //NS_ENABLE_TSF
 49149:   if (nsIMM32Handler::IsComposing()) {
     1:     ResetInputState();
 49149:   }
120230:   void* nativeIMEContext = mInputContext.mNativeIMEContext;
 82840:   mInputContext = aContext;
120230:   mInputContext.mNativeIMEContext = nullptr;
 82842:   bool enable = (mInputContext.mIMEState.mEnabled == IMEState::ENABLED ||
 82842:                  mInputContext.mIMEState.mEnabled == IMEState::PLUGIN);
 25278: 
 73536:   AssociateDefaultIMC(enable);
 82842: 
120230:   if (enable) {
120230:     nsIMEContext IMEContext(mWnd);
120230:     mInputContext.mNativeIMEContext = static_cast<void*>(IMEContext.get());
120230:   }
120230:   // Restore the latest associated context when we cannot get actual context.
120230:   if (!mInputContext.mNativeIMEContext) {
120230:     mInputContext.mNativeIMEContext = nativeIMEContext;
120230:   }
120230: 
 82842:   if (enable &&
 82842:       mInputContext.mIMEState.mOpen != IMEState::DONT_CHANGE_OPEN_STATE) {
 82842:     bool open = (mInputContext.mIMEState.mOpen == IMEState::OPEN);
 82842: #ifdef NS_ENABLE_TSF
 82842:     nsTextStore::SetIMEOpenState(open);
 82842: #endif //NS_ENABLE_TSF
 82842:     nsIMEContext IMEContext(mWnd);
 82842:     if (IMEContext.IsValid()) {
 82842:       ::ImmSetOpenStatus(IMEContext.get(), open);
 82842:     }
 82842:   }
 82841: }
 82841: 
 82841: NS_IMETHODIMP_(InputContext)
 82841: nsWindow::GetInputContext()
   539: {
 82842:   mInputContext.mIMEState.mOpen = IMEState::CLOSED;
 82842:   switch (mInputContext.mIMEState.mEnabled) {
 82842:     case IMEState::ENABLED:
 82842:     case IMEState::PLUGIN: {
 82842:       nsIMEContext IMEContext(mWnd);
 82842:       if (IMEContext.IsValid()) {
 82842:         mInputContext.mIMEState.mOpen =
 82842:           ::ImmGetOpenStatus(IMEContext.get()) ? IMEState::OPEN :
 82842:                                                  IMEState::CLOSED;
 82842:       }
 82842: #ifdef NS_ENABLE_TSF
 82842:       if (mInputContext.mIMEState.mOpen == IMEState::CLOSED &&
 82842:           nsTextStore::GetIMEOpenState()) {
 82842:         mInputContext.mIMEState.mOpen = IMEState::OPEN;
 82842:       }
 82842: #endif //NS_ENABLE_TSF
 82842:     }
 82842:   }
 82841:   return mInputContext;
     1: }
     1: 
     1: NS_IMETHODIMP nsWindow::CancelIMEComposition()
     1: {
     1: #ifdef DEBUG_KBSTATE
 76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("CancelIMEComposition\n"));
     1: #endif 
 24836: 
 24836: #ifdef NS_ENABLE_TSF
 79626:   nsTextStore::CommitComposition(true);
 24836: #endif //NS_ENABLE_TSF
 24836: 
 49149:   nsIMM32Handler::CancelComposition(this);
     1:   return NS_OK;
     1: }
     1: 
  2475: NS_IMETHODIMP
108991: nsWindow::GetToggledKeyState(uint32_t aKeyCode, bool* aLEDState)
  2475: {
  2475: #ifdef DEBUG_KBSTATE
 76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("GetToggledKeyState\n"));
  2475: #endif 
  2475:   NS_ENSURE_ARG_POINTER(aLEDState);
  2475:   *aLEDState = (::GetKeyState(aKeyCode) & 1) != 0;
  2475:   return NS_OK;
  2475: }
     1: 
 24836: #ifdef NS_ENABLE_TSF
 24836: NS_IMETHODIMP
 79445: nsWindow::OnIMEFocusChange(bool aFocus)
 24836: {
 82840:   nsresult rv = nsTextStore::OnFocusChange(aFocus, this,
 82842:                                            mInputContext.mIMEState.mEnabled);
 27984:   if (rv == NS_ERROR_NOT_AVAILABLE)
121727:     rv = NS_OK; // TSF is not enabled, maybe.
 27984:   return rv;
 24836: }
 24836: 
 24836: NS_IMETHODIMP
108991: nsWindow::OnIMETextChange(uint32_t aStart,
108991:                           uint32_t aOldEnd,
108991:                           uint32_t aNewEnd)
 24836: {
 24836:   return nsTextStore::OnTextChange(aStart, aOldEnd, aNewEnd);
 24836: }
 24836: 
 24836: NS_IMETHODIMP
 24836: nsWindow::OnIMESelectionChange(void)
 24836: {
 24836:   return nsTextStore::OnSelectionChange();
 24836: }
121726: 
121726: nsIMEUpdatePreference
121726: nsWindow::GetIMEUpdatePreference()
121726: {
121726:   return nsTextStore::GetIMEUpdatePreference();
121726: }
121726: 
 24836: #endif //NS_ENABLE_TSF
 24836: 
 79445: bool nsWindow::AssociateDefaultIMC(bool aAssociate)
 73536: {
 73536:   nsIMEContext IMEContext(mWnd);
 73536: 
 73536:   if (aAssociate) {
 73536:     BOOL ret = ::ImmAssociateContextEx(mWnd, NULL, IACE_DEFAULT);
 73536: #ifdef DEBUG
 73536:     // Note that if IME isn't available with current keyboard layout,
 73536:     // IMM might not be installed on the system such as English Windows.
 73536:     // On such system, IMM APIs always fail.
 73536:     NS_ASSERTION(ret || !nsIMM32Handler::IsIMEAvailable(),
 73536:                  "ImmAssociateContextEx failed to restore default IMC");
 73536:     if (ret) {
 73536:       nsIMEContext newIMEContext(mWnd);
 73536:       NS_ASSERTION(!IMEContext.get() || newIMEContext.get() == IMEContext.get(),
 73536:                    "Unknown IMC had been associated");
 73536:     }
 73536: #endif
 73536:     return ret && !IMEContext.get();
 73536:   }
 73536: 
 73536:   if (mOnDestroyCalled) {
 73536:     // If OnDestroy() has been called, we shouldn't disassociate the default
 73536:     // IMC at destroying the window.
 79626:     return false;
 73536:   }
 73536: 
 73536:   if (!IMEContext.get()) {
 79626:     return false; // already disassociated
 73536:   }
 73536: 
 73536:   BOOL ret = ::ImmAssociateContextEx(mWnd, NULL, 0);
 73536:   NS_ASSERTION(ret, "ImmAssociateContextEx failed to disassociate the IMC");
 73536:   return ret != FALSE;
 73536: }
 73536: 
     1: #ifdef ACCESSIBILITY
 47996: 
 47996: #ifdef DEBUG_WMGETOBJECT
 47996: #define NS_LOG_WMGETOBJECT_WNDACC(aWnd)                                        \
122283:   a11y::Accessible* acc = aWnd ? aWind->GetAccessible() : nullptr;             \
 76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("     acc: %p", acc));                   \
 47996:   if (acc) {                                                                   \
 47996:     nsAutoString name;                                                         \
 47996:     acc->GetName(name);                                                        \
 76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS,                                         \
 76714:            (", accname: %s", NS_ConvertUTF16toUTF8(name).get()));              \
 47996:     nsCOMPtr<nsIAccessibleDocument> doc = do_QueryObject(acc);                 \
106838:     void *hwnd = nullptr;                                                      \
 47996:     doc->GetWindowHandle(&hwnd);                                               \
 76714:     PR_LOG(gWindowsLog, PR_LOG_ALWAYS, (", acc hwnd: %d", hwnd));              \
 47996:   }
 47996: 
 47996: #define NS_LOG_WMGETOBJECT_THISWND                                             \
 47996: {                                                                              \
 76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,                                           \
 76714:          ("\n*******Get Doc Accessible*******\nOrig Window: "));               \
 76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,                                           \
 76714:          ("\n  {\n     HWND: %d, parent HWND: %d, wndobj: %p,\n",              \
 76714:           mWnd, ::GetParent(mWnd), this));                                     \
 47996:   NS_LOG_WMGETOBJECT_WNDACC(this)                                              \
 76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("\n  }\n"));                             \
 47996: }
 47996: 
 47996: #define NS_LOG_WMGETOBJECT_WND(aMsg, aHwnd)                                    \
 47996: {                                                                              \
 86569:   nsWindow* wnd = WinUtils::GetNSWindowPtr(aHwnd);                             \
 76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS,                                           \
 76714:          ("Get " aMsg ":\n  {\n     HWND: %d, parent HWND: %d, wndobj: %p,\n", \
 76714:           aHwnd, ::GetParent(aHwnd), wnd));                                    \
 47996:   NS_LOG_WMGETOBJECT_WNDACC(wnd);                                              \
 76714:   PR_LOG(gWindowsLog, PR_LOG_ALWAYS, ("\n }\n"));                              \
 47996: }
 47996: #else
 47996: #define NS_LOG_WMGETOBJECT_THISWND
 47996: #define NS_LOG_WMGETOBJECT_WND(aMsg, aHwnd)
 47996: #endif // DEBUG_WMGETOBJECT
 47996: 
122283: a11y::Accessible*
 42313: nsWindow::GetRootAccessible()
     1: {
102366:   // If the pref was ePlatformIsDisabled, return null here, disabling a11y.
102366:   if (a11y::PlatformDisabledState() == a11y::ePlatformIsDisabled)
106838:     return nullptr;
 39169: 
 30223:   if (mInDtor || mOnDestroyCalled || mWindowType == eWindowType_invisible) {
106838:     return nullptr;
     1:   }
     1: 
 47996:   NS_LOG_WMGETOBJECT_THISWND
 47996:   NS_LOG_WMGETOBJECT_WND("This Window", mWnd);
 53976: 
108454:   return GetAccessible();
     1: }
     1: #endif
     1: 
 29835: /**************************************************************
 29835:  **************************************************************
 29835:  **
 29835:  ** BLOCK: Transparency
 29835:  **
 29835:  ** Window transparency helpers.
 29835:  **
 29835:  **************************************************************
 29835:  **************************************************************/
 29835: 
     1: #ifdef MOZ_XUL
     1: 
108991: void nsWindow::ResizeTranslucentWindow(int32_t aNewWidth, int32_t aNewHeight, bool force)
     1: {
     1:   if (!force && aNewWidth == mBounds.width && aNewHeight == mBounds.height)
     1:     return;
     1: 
 44140: #ifdef CAIRO_HAS_D2D_SURFACE
 43936:   if (gfxWindowsPlatform::GetPlatform()->GetRenderMode() ==
 43936:       gfxWindowsPlatform::RENDER_DIRECT2D) {
 43936:     nsRefPtr<gfxD2DSurface> newSurface =
 43936:       new gfxD2DSurface(gfxIntSize(aNewWidth, aNewHeight), gfxASurface::ImageFormatARGB32);
 43936:     mTransparentSurface = newSurface;
106838:     mMemoryDC = nullptr;
 44140:   } else
 44140: #endif
 44140:   {
 43936:     nsRefPtr<gfxWindowsSurface> newSurface =
 43936:       new gfxWindowsSurface(gfxIntSize(aNewWidth, aNewHeight), gfxASurface::ImageFormatARGB32);
 43936:     mTransparentSurface = newSurface;
 43936:     mMemoryDC = newSurface->GetDC();
 43936:   }
     1: }
     1: 
 16601: void nsWindow::SetWindowTranslucencyInner(nsTransparencyMode aMode)
 16601: {
 16601:   if (aMode == mTransparencyMode)
 16601:     return;
     1: 
 46335:   // stop on dialogs and popups!
 86569:   HWND hWnd = WinUtils::GetTopLevelHWND(mWnd, true);
 86569:   nsWindow* parent = WinUtils::GetNSWindowPtr(hWnd);
 46335: 
 46335:   if (!parent)
     1:   {
     1:     NS_WARNING("Trying to use transparent chrome in an embedded context");
 16601:     return;
     1:   }
     1: 
 46335:   if (parent != this) {
 46335:     NS_WARNING("Setting SetWindowTranslucencyInner on a parent this is not us!");
 46335:   }
 46335: 
 46335:   if (aMode == eTransparencyTransparent) {
 46335:     // If we're switching to the use of a transparent window, hide the chrome
 46335:     // on our parent.
 79626:     HideWindowChrome(true);
 46335:   } else if (mHideChrome && mTransparencyMode == eTransparencyTransparent) {
 46335:     // if we're switching out of transparent, re-enable our parent's chrome.
 79626:     HideWindowChrome(false);
 46335:   }
 46335: 
 46335:   LONG_PTR style = ::GetWindowLongPtrW(hWnd, GWL_STYLE),
 46335:     exStyle = ::GetWindowLongPtr(hWnd, GWL_EXSTYLE);
 46335:  
 46335:    if (parent->mIsVisible)
 46335:      style |= WS_VISIBLE;
 46335:    if (parent->mSizeMode == nsSizeMode_Maximized)
 46335:      style |= WS_MAXIMIZE;
 46335:    else if (parent->mSizeMode == nsSizeMode_Minimized)
 46335:      style |= WS_MINIMIZE;
 46335: 
 46335:    if (aMode == eTransparencyTransparent)
 16601:      exStyle |= WS_EX_LAYERED;
 46335:    else
 46335:      exStyle &= ~WS_EX_LAYERED;
 46234: 
 46234:   VERIFY_WINDOW_STYLE(style);
 46234:   ::SetWindowLongPtrW(hWnd, GWL_STYLE, style);
 46234:   ::SetWindowLongPtrW(hWnd, GWL_EXSTYLE, exStyle);
     1: 
 50770:   if (HasGlass())
 42856:     memset(&mGlassMargins, 0, sizeof mGlassMargins);
 16601:   mTransparencyMode = aMode;
 16601: 
 16601:   SetupTranslucentWindowMemoryBitmap(aMode);
 39718:   UpdateGlass();
 16601: }
 16601: 
 16601: void nsWindow::SetupTranslucentWindowMemoryBitmap(nsTransparencyMode aMode)
 16601: {
 16601:   if (eTransparencyTransparent == aMode) {
 79626:     ResizeTranslucentWindow(mBounds.width, mBounds.height, true);
     1:   } else {
106838:     mTransparentSurface = nullptr;
     1:     mMemoryDC = NULL;
     1:   }
     1: }
     1: 
104347: void nsWindow::ClearTranslucentWindow()
104347: {
104347:   if (mTransparentSurface) {
104347:     nsRefPtr<gfxContext> thebesContext = new gfxContext(mTransparentSurface);
104347:     thebesContext->SetOperator(gfxContext::OPERATOR_CLEAR);
104347:     thebesContext->Paint();
104347:     UpdateTranslucentWindow();
104347:  }
104347: }
104347: 
     1: nsresult nsWindow::UpdateTranslucentWindow()
     1: {
     1:   if (mBounds.IsEmpty())
     1:     return NS_OK;
     1: 
     1:   ::GdiFlush();
     1: 
     1:   BLENDFUNCTION bf = { AC_SRC_OVER, 0, 255, AC_SRC_ALPHA };
     1:   SIZE winSize = { mBounds.width, mBounds.height };
     1:   POINT srcPos = { 0, 0 };
 86569:   HWND hWnd = WinUtils::GetTopLevelHWND(mWnd, true);
     1:   RECT winRect;
     1:   ::GetWindowRect(hWnd, &winRect);
     1: 
 44140: #ifdef CAIRO_HAS_D2D_SURFACE
 43936:   if (gfxWindowsPlatform::GetPlatform()->GetRenderMode() ==
 43936:       gfxWindowsPlatform::RENDER_DIRECT2D) {
 43936:     mMemoryDC = static_cast<gfxD2DSurface*>(mTransparentSurface.get())->
 79626:       GetDC(true);
 43936:   }
 44140: #endif
     1:   // perform the alpha blend
 79445:   bool updateSuccesful = 
 43936:     ::UpdateLayeredWindow(hWnd, NULL, (POINT*)&winRect, &winSize, mMemoryDC, &srcPos, 0, &bf, ULW_ALPHA);
 43936: 
 44140: #ifdef CAIRO_HAS_D2D_SURFACE
 43936:   if (gfxWindowsPlatform::GetPlatform()->GetRenderMode() ==
 43936:       gfxWindowsPlatform::RENDER_DIRECT2D) {
 43936:     nsIntRect r(0, 0, 0, 0);
 43936:     static_cast<gfxD2DSurface*>(mTransparentSurface.get())->ReleaseDC(&r);
 43936:   }
 44140: #endif
 43936: 
 43936:   if (!updateSuccesful) {
  5223:     return NS_ERROR_FAILURE;
 43936:   }
  5223: 
  5223:   return NS_OK;
  5223: }
  5223: 
 19822: #endif //MOZ_XUL
 29835: 
 29835: /**************************************************************
 29835:  **************************************************************
 29835:  **
 29835:  ** BLOCK: Popup rollup hooks
 29835:  **
 29835:  ** Deals with CaptureRollup on popup windows.
 29835:  **
 29835:  **************************************************************
 29835:  **************************************************************/
 29835: 
 29835: // Schedules a timer for a window, so we can rollup after processing the hook event
 29835: void nsWindow::ScheduleHookTimer(HWND aWnd, UINT aMsgId)
 29835: {
 29835:   // In some cases multiple hooks may be scheduled
 29835:   // so ignore any other requests once one timer is scheduled
 29835:   if (sHookTimerId == 0) {
 29835:     // Remember the window handle and the message ID to be used later
 29835:     sRollupMsgId = aMsgId;
 29835:     sRollupMsgWnd = aWnd;
 29835:     // Schedule native timer for doing the rollup after
 29835:     // this event is done being processed
 29835:     sHookTimerId = ::SetTimer(NULL, 0, 0, (TIMERPROC)HookTimerForPopups);
 29835:     NS_ASSERTION(sHookTimerId, "Timer couldn't be created.");
 29835:   }
 29835: }
 29835: 
 29835: #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
 29835: int gLastMsgCode = 0;
 29835: extern MSGFEventMsgInfo gMSGFEvents[];
 29835: #endif
 29835: 
 29835: // Process Menu messages, rollup when popup is clicked.
 29835: LRESULT CALLBACK nsWindow::MozSpecialMsgFilter(int code, WPARAM wParam, LPARAM lParam)
 29835: {
 29835: #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
 29835:   if (sProcessHook) {
 29835:     MSG* pMsg = (MSG*)lParam;
 29835: 
 29835:     int inx = 0;
 29835:     while (gMSGFEvents[inx].mId != code && gMSGFEvents[inx].mStr != NULL) {
 29835:       inx++;
 29835:     }
 29835:     if (code != gLastMsgCode) {
 29835:       if (gMSGFEvents[inx].mId == code) {
 29835: #ifdef DEBUG
 76714:         PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
 76714:                ("MozSpecialMessageProc - code: 0x%X  - %s  hw: %p\n", 
 76714:                 code, gMSGFEvents[inx].mStr, pMsg->hwnd));
 29835: #endif
 29835:       } else {
 29835: #ifdef DEBUG
 76714:         PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
 76714:                ("MozSpecialMessageProc - code: 0x%X  - %d  hw: %p\n", 
 76714:                 code, gMSGFEvents[inx].mId, pMsg->hwnd));
 29835: #endif
 29835:       }
 29835:       gLastMsgCode = code;
 29835:     }
 29835:     PrintEvent(pMsg->message, FALSE, FALSE);
 29835:   }
 29835: #endif // #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
 29835: 
 29835:   if (sProcessHook && code == MSGF_MENU) {
 29835:     MSG* pMsg = (MSG*)lParam;
 29835:     ScheduleHookTimer( pMsg->hwnd, pMsg->message);
 29835:   }
 29835: 
 29835:   return ::CallNextHookEx(sMsgFilterHook, code, wParam, lParam);
 29835: }
 29835: 
 29835: // Process all mouse messages. Roll up when a click is in a native window
 29835: // that doesn't have an nsIWidget.
 29835: LRESULT CALLBACK nsWindow::MozSpecialMouseProc(int code, WPARAM wParam, LPARAM lParam)
 29835: {
 29835:   if (sProcessHook) {
 86569:     switch (WinUtils::GetNativeMessage(wParam)) {
 29835:       case WM_LBUTTONDOWN:
 29835:       case WM_RBUTTONDOWN:
 29835:       case WM_MBUTTONDOWN:
 29835:       case WM_MOUSEWHEEL:
 29835:       case WM_MOUSEHWHEEL:
 29835:       {
 29835:         MOUSEHOOKSTRUCT* ms = (MOUSEHOOKSTRUCT*)lParam;
 86569:         nsIWidget* mozWin = WinUtils::GetNSWindowPtr(ms->hwnd);
 29835:         if (mozWin) {
 29835:           // If this window is windowed plugin window, the mouse events are not
 29835:           // sent to us.
 33357:           if (static_cast<nsWindow*>(mozWin)->mWindowType == eWindowType_plugin)
 29835:             ScheduleHookTimer(ms->hwnd, (UINT)wParam);
 29835:         } else {
 29835:           ScheduleHookTimer(ms->hwnd, (UINT)wParam);
 29835:         }
 29835:         break;
 29835:       }
 29835:     }
 29835:   }
 29835:   return ::CallNextHookEx(sCallMouseHook, code, wParam, lParam);
 29835: }
 29835: 
 29835: // Process all messages. Roll up when the window is moving, or
 29835: // is resizing or when maximized or mininized.
 29835: LRESULT CALLBACK nsWindow::MozSpecialWndProc(int code, WPARAM wParam, LPARAM lParam)
 29835: {
 29835: #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
 29835:   if (sProcessHook) {
 29835:     CWPSTRUCT* cwpt = (CWPSTRUCT*)lParam;
 29835:     PrintEvent(cwpt->message, FALSE, FALSE);
 29835:   }
 29835: #endif
 29835: 
 29835:   if (sProcessHook) {
 29835:     CWPSTRUCT* cwpt = (CWPSTRUCT*)lParam;
 29835:     if (cwpt->message == WM_MOVING ||
 29835:         cwpt->message == WM_SIZING ||
 29835:         cwpt->message == WM_GETMINMAXINFO) {
 29835:       ScheduleHookTimer(cwpt->hwnd, (UINT)cwpt->message);
 29835:     }
 29835:   }
 29835: 
 29835:   return ::CallNextHookEx(sCallProcHook, code, wParam, lParam);
 29835: }
 29835: 
 29835: // Register the special "hooks" for dropdown processing.
 29835: void nsWindow::RegisterSpecialDropdownHooks()
 29835: {
 29835:   NS_ASSERTION(!sMsgFilterHook, "sMsgFilterHook must be NULL!");
 29835:   NS_ASSERTION(!sCallProcHook,  "sCallProcHook must be NULL!");
 29835: 
 29835:   DISPLAY_NMM_PRT("***************** Installing Msg Hooks ***************\n");
 29835: 
 29835:   // Install msg hook for moving the window and resizing
 29835:   if (!sMsgFilterHook) {
 29835:     DISPLAY_NMM_PRT("***** Hooking sMsgFilterHook!\n");
 29835:     sMsgFilterHook = SetWindowsHookEx(WH_MSGFILTER, MozSpecialMsgFilter, NULL, GetCurrentThreadId());
 29835: #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
 29835:     if (!sMsgFilterHook) {
 76714:       PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
 76714:              ("***** SetWindowsHookEx is NOT installed for WH_MSGFILTER!\n"));
 29835:     }
 29835: #endif
 29835:   }
 29835: 
 29835:   // Install msg hook for menus
 29835:   if (!sCallProcHook) {
 29835:     DISPLAY_NMM_PRT("***** Hooking sCallProcHook!\n");
 29835:     sCallProcHook  = SetWindowsHookEx(WH_CALLWNDPROC, MozSpecialWndProc, NULL, GetCurrentThreadId());
 29835: #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
 29835:     if (!sCallProcHook) {
 76714:       PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
 76714:              ("***** SetWindowsHookEx is NOT installed for WH_CALLWNDPROC!\n"));
 29835:     }
 29835: #endif
 29835:   }
 29835: 
 29835:   // Install msg hook for the mouse
 29835:   if (!sCallMouseHook) {
 29835:     DISPLAY_NMM_PRT("***** Hooking sCallMouseHook!\n");
 29835:     sCallMouseHook  = SetWindowsHookEx(WH_MOUSE, MozSpecialMouseProc, NULL, GetCurrentThreadId());
 29835: #ifdef POPUP_ROLLUP_DEBUG_OUTPUT
 29835:     if (!sCallMouseHook) {
 76714:       PR_LOG(gWindowsLog, PR_LOG_ALWAYS, 
 76714:              ("***** SetWindowsHookEx is NOT installed for WH_MOUSE!\n"));
 29835:     }
 29835: #endif
 29835:   }
 29835: }
 29835: 
 29835: // Unhook special message hooks for dropdowns.
 29835: void nsWindow::UnregisterSpecialDropdownHooks()
 29835: {
 29835:   DISPLAY_NMM_PRT("***************** De-installing Msg Hooks ***************\n");
 29835: 
 29835:   if (sCallProcHook) {
 29835:     DISPLAY_NMM_PRT("***** Unhooking sCallProcHook!\n");
 29835:     if (!::UnhookWindowsHookEx(sCallProcHook)) {
 29835:       DISPLAY_NMM_PRT("***** UnhookWindowsHookEx failed for sCallProcHook!\n");
 29835:     }
 29835:     sCallProcHook = NULL;
 29835:   }
 29835: 
 29835:   if (sMsgFilterHook) {
 29835:     DISPLAY_NMM_PRT("***** Unhooking sMsgFilterHook!\n");
 29835:     if (!::UnhookWindowsHookEx(sMsgFilterHook)) {
 29835:       DISPLAY_NMM_PRT("***** UnhookWindowsHookEx failed for sMsgFilterHook!\n");
 29835:     }
 29835:     sMsgFilterHook = NULL;
 29835:   }
 29835: 
 29835:   if (sCallMouseHook) {
 29835:     DISPLAY_NMM_PRT("***** Unhooking sCallMouseHook!\n");
 29835:     if (!::UnhookWindowsHookEx(sCallMouseHook)) {
 29835:       DISPLAY_NMM_PRT("***** UnhookWindowsHookEx failed for sCallMouseHook!\n");
 29835:     }
 29835:     sCallMouseHook = NULL;
 29835:   }
 29835: }
 29835: 
 29835: // This timer is designed to only fire one time at most each time a "hook" function
 29835: // is used to rollup the dropdown. In some cases, the timer may be scheduled from the
 29835: // hook, but that hook event or a subsequent event may roll up the dropdown before
 29835: // this timer function is executed.
 29835: //
 29835: // For example, if an MFC control takes focus, the combobox will lose focus and rollup
 29835: // before this function fires.
 29835: VOID CALLBACK nsWindow::HookTimerForPopups(HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime)
 29835: {
 29835:   if (sHookTimerId != 0) {
 29835:     // if the window is NULL then we need to use the ID to kill the timer
 29835:     BOOL status = ::KillTimer(NULL, sHookTimerId);
 29835:     NS_ASSERTION(status, "Hook Timer was not killed.");
 29835:     sHookTimerId = 0;
 29835:   }
 29835: 
 29835:   if (sRollupMsgId != 0) {
120177:     // Note: DealWithPopups does the check to make sure that the rollup widget is set.
 29835:     LRESULT popupHandlingResult;
 29835:     nsAutoRollup autoRollup;
 29835:     DealWithPopups(sRollupMsgWnd, sRollupMsgId, 0, 0, &popupHandlingResult);
 29835:     sRollupMsgId = 0;
 29835:     sRollupMsgWnd = NULL;
 29835:   }
 29835: }
 29835: 
 51000: BOOL CALLBACK nsWindow::ClearResourcesCallback(HWND aWnd, LPARAM aMsg)
 50583: {
 86569:     nsWindow *window = WinUtils::GetNSWindowPtr(aWnd);
 50583:     if (window) {
 51000:         window->ClearCachedResources();
 50583:     }  
 50583:     return TRUE;
 50583: }
 50583: 
 50583: void
 51000: nsWindow::ClearCachedResources()
 51000: {
 51000: #ifdef CAIRO_HAS_D2D_SURFACE
106838:     mD2DWindowSurface = nullptr;
 51000: #endif
 51000:     if (mLayerManager &&
105710:         mLayerManager->GetBackendType() == LAYERS_BASIC) {
 51000:       static_cast<BasicLayerManager*>(mLayerManager.get())->
 51000:         ClearCachedResources();
 51000:     }
 61525:     ::EnumChildWindows(mWnd, nsWindow::ClearResourcesCallback, 0);
 51000: }
 50583: 
 79445: static bool IsDifferentThreadWindow(HWND aWnd)
 29835: {
 29835:   return ::GetCurrentThreadId() != ::GetWindowThreadProcessId(aWnd, NULL);
 29835: }
 29835: 
 79445: bool
 29835: nsWindow::EventIsInsideWindow(UINT Msg, nsWindow* aWindow)
 29835: {
 29835:   RECT r;
 29835: 
 29835:   if (Msg == WM_ACTIVATEAPP)
 29835:     // don't care about activation/deactivation
 79626:     return false;
 29835: 
 29835:   ::GetWindowRect(aWindow->mWnd, &r);
 29835:   DWORD pos = ::GetMessagePos();
 29835:   POINT mp;
 29835:   mp.x = GET_X_LPARAM(pos);
 29835:   mp.y = GET_Y_LPARAM(pos);
 29835: 
 29835:   // was the event inside this window?
 79445:   return (bool) PtInRect(&r, mp);
 29835: }
 29835: 
 29835: // Handle events that may cause a popup (combobox, XPMenu, etc) to need to rollup.
127124: bool
 29835: nsWindow::DealWithPopups(HWND inWnd, UINT inMsg, WPARAM inWParam, LPARAM inLParam, LRESULT* outResult)
 29835: {
127124:   NS_ASSERTION(outResult, "Bad outResult");
127124: 
127124:   *outResult = MA_NOACTIVATE;
127124: 
127124:   if (!::IsWindowVisible(inWnd))
127124:     return false;
120177:   nsIRollupListener* rollupListener = nsBaseWidget::GetActiveRollupListener();
127124:   NS_ENSURE_TRUE(rollupListener, false);
120177:   nsCOMPtr<nsIWidget> rollupWidget = rollupListener->GetRollupWidget();
127124:   NS_ENSURE_TRUE(rollupWidget, false);
 29835: 
 86569:   inMsg = WinUtils::GetNativeMessage(inMsg);
 29835:   if (inMsg == WM_LBUTTONDOWN || inMsg == WM_RBUTTONDOWN || inMsg == WM_MBUTTONDOWN ||
 29835:       inMsg == WM_MOUSEWHEEL || inMsg == WM_MOUSEHWHEEL || inMsg == WM_ACTIVATE ||
 68855:       (inMsg == WM_KILLFOCUS && IsDifferentThreadWindow((HWND)inWParam)) ||
 29835:       inMsg == WM_NCRBUTTONDOWN ||
 29835:       inMsg == WM_MOVING ||
 29835:       inMsg == WM_SIZING ||
 29835:       inMsg == WM_NCLBUTTONDOWN ||
 29835:       inMsg == WM_NCMBUTTONDOWN ||
 29835:       inMsg == WM_MOUSEACTIVATE ||
 29835:       inMsg == WM_ACTIVATEAPP ||
127124:       inMsg == WM_MENUSELECT) {
 29835:     // Rollup if the event is outside the popup.
120177:     bool rollup = !nsWindow::EventIsInsideWindow(inMsg, (nsWindow*)(rollupWidget.get()));
 29835: 
127124:     if (rollup && (inMsg == WM_MOUSEWHEEL || inMsg == WM_MOUSEHWHEEL)) {
120177:       rollup = rollupListener->ShouldRollupOnMouseWheelEvent();
127124:       *outResult = MA_ACTIVATE;
 29835:     }
 29835: 
 29835:     // If we're dealing with menus, we probably have submenus and we don't
 29835:     // want to rollup if the click is in a parent menu of the current submenu.
115367:     uint32_t popupsToRollup = UINT32_MAX;
 29835:     if (rollup) {
 29835:       nsAutoTArray<nsIWidget*, 5> widgetChain;
120177:       uint32_t sameTypeCount = rollupListener->GetSubmenuWidgetChain(&widgetChain);
108991:       for ( uint32_t i = 0; i < widgetChain.Length(); ++i ) {
 29835:         nsIWidget* widget = widgetChain[i];
 29835:         if ( nsWindow::EventIsInsideWindow(inMsg, (nsWindow*)widget) ) {
 42263:           // don't roll up if the mouse event occurred within a menu of the
 42263:           // same type. If the mouse event occurred in a menu higher than
 29835:           // that, roll up, but pass the number of popups to Rollup so
 29835:           // that only those of the same type close up.
 29835:           if (i < sameTypeCount) {
 79626:             rollup = false;
127124:           } else {
 29835:             popupsToRollup = sameTypeCount;
 29835:           }
 29835:           break;
 29835:         }
 29835:       } // foreach parent menu widget
 29835:     }
 29835: 
126142:     if (inMsg == WM_MOUSEACTIVATE) {
 29835:       // Prevent the click inside the popup from causing a change in window
 29835:       // activation. Since the popup is shown non-activated, we need to eat
 29835:       // any requests to activate the window while it is displayed. Windows
 29835:       // will automatically activate the popup on the mousedown otherwise.
 29835:       if (!rollup) {
127124:         return true;
127124:       } else {
 29835:         UINT uMsg = HIWORD(inLParam);
127124:         if (uMsg == WM_MOUSEMOVE) {
 29835:           // WM_MOUSEACTIVATE cause by moving the mouse - X-mouse (eg. TweakUI)
 29835:           // must be enabled in Windows.
120177:           rollup = rollupListener->ShouldRollupOnMouseActivate();
127124:           if (!rollup) {
 29835:             return true;
 29835:           }
 29835:         }
 29835:       }
 29835:     }
 29835:     // if we've still determined that we should still rollup everything, do it.
 68855:     else if (rollup) {
 29835:       // only need to deal with the last rollup for left mouse down events.
 82030:       NS_ASSERTION(!mLastRollup, "mLastRollup is null");
120177:       bool consumeRollupEvent =
120177:         rollupListener->Rollup(popupsToRollup, inMsg == WM_LBUTTONDOWN ? &mLastRollup : nullptr);
 82030:       NS_IF_ADDREF(mLastRollup);
 29835: 
 29835:       // Tell hook to stop processing messages
 79626:       sProcessHook = false;
 29835:       sRollupMsgId = 0;
 29835:       sRollupMsgWnd = NULL;
 29835: 
 29835:       // return TRUE tells Windows that the event is consumed,
 29835:       // false allows the event to be dispatched
 29835:       //
 29835:       // So if we are NOT supposed to be consuming events, let it go through
 29835:       if (consumeRollupEvent && inMsg != WM_RBUTTONDOWN) {
 58173:         *outResult = MA_ACTIVATE;
 58173: 
 58173:         // However, don't activate panels
 58173:         if (inMsg == WM_MOUSEACTIVATE) {
 86569:           nsWindow* activateWindow = WinUtils::GetNSWindowPtr(inWnd);
 58173:           if (activateWindow) {
 58173:             nsWindowType wintype;
 58173:             activateWindow->GetWindowType(wintype);
 58173:             if (wintype == eWindowType_popup && activateWindow->PopupType() == ePopupTypePanel) {
120335:               *outResult = popupsToRollup != UINT32_MAX ? MA_NOACTIVATEANDEAT : MA_NOACTIVATE;
 58173:             }
 58173:           }
 58173:         }
127124:         return true;
 29835:       }
 29835:       // if we are only rolling up some popups, don't activate and don't let
 29835:       // the event go through. This prevents clicks menus higher in the
 29835:       // chain from opening when a context menu is open
115367:       if (popupsToRollup != UINT32_MAX && inMsg == WM_MOUSEACTIVATE) {
 29835:         *outResult = MA_NOACTIVATEANDEAT;
127124:         return true;
 29835:       }
 29835:     }
 29835:   } // if event that might trigger a popup to rollup
127124: 
127124:   return false;
 29835: }
 29835: 
 29835: /**************************************************************
 29835:  **************************************************************
 29835:  **
 29835:  ** BLOCK: Misc. utility methods and functions.
 29835:  **
 29835:  ** General use.
 29835:  **
 29835:  **************************************************************
 29835:  **************************************************************/
 29835: 
 29835: // Note that the result of GetTopLevelWindow method can be different from the
 86569: // result of WinUtils::GetTopLevelHWND().  The result can be non-floating
 86569: // window.  Because our top level window may be contained in another window
 86569: // which is not managed by us.
 79445: nsWindow* nsWindow::GetTopLevelWindow(bool aStopOnDialogOrPopup)
 29835: {
 29835:   nsWindow* curWindow = this;
 29835: 
 79626:   while (true) {
 29835:     if (aStopOnDialogOrPopup) {
 29835:       switch (curWindow->mWindowType) {
 29835:         case eWindowType_dialog:
 29835:         case eWindowType_popup:
 29835:           return curWindow;
 51212:         default:
 51212:           break;
 29835:       }
 29835:     }
 29835: 
 29835:     // Retrieve the top level parent or owner window
 79626:     nsWindow* parentWindow = curWindow->GetParentWindow(true);
 29835: 
 29835:     if (!parentWindow)
 29835:       return curWindow;
 29835: 
 29835:     curWindow = parentWindow;
 29835:   }
 29835: }
 29835: 
 29835: static BOOL CALLBACK gEnumWindowsProc(HWND hwnd, LPARAM lParam)
 29835: {
 29835:   DWORD pid;
 29835:   ::GetWindowThreadProcessId(hwnd, &pid);
 29835:   if (pid == GetCurrentProcessId() && ::IsWindowVisible(hwnd))
 29835:   {
 79626:     gWindowsVisible = true;
 29835:     return FALSE;
 29835:   }
 29835:   return TRUE;
 29835: }
 29835: 
 79445: bool nsWindow::CanTakeFocus()
 29835: {
 79626:   gWindowsVisible = false;
 29835:   EnumWindows(gEnumWindowsProc, 0);
 29835:   if (!gWindowsVisible) {
 79626:     return true;
 29835:   } else {
 29835:     HWND fgWnd = ::GetForegroundWindow();
 29835:     if (!fgWnd) {
 79626:       return true;
 29835:     }
 29835:     DWORD pid;
 29835:     GetWindowThreadProcessId(fgWnd, &pid);
 29835:     if (pid == GetCurrentProcessId()) {
 79626:       return true;
 79626:     }
 79626:   }
 79626:   return false;
 29835: }
 29835: 
 57092: void nsWindow::GetMainWindowClass(nsAString& aClass)
 57092: {
 70956:   NS_PRECONDITION(aClass.IsEmpty(), "aClass should be empty string");
 70956:   nsresult rv = Preferences::GetString("ui.window_class_override", &aClass);
 70956:   if (NS_FAILED(rv) || aClass.IsEmpty()) {
 57092:     aClass.AssignASCII(sDefaultMainWindowClass);
 57092:   }
 70956: }
 57092: 
 30750: LPARAM nsWindow::lParamToScreen(LPARAM lParam)
 30750: {
 30750:   POINT pt;
 30750:   pt.x = GET_X_LPARAM(lParam);
 30750:   pt.y = GET_Y_LPARAM(lParam);
 30750:   ::ClientToScreen(mWnd, &pt);
 30750:   return MAKELPARAM(pt.x, pt.y);
 30750: }
 30750: 
 30750: LPARAM nsWindow::lParamToClient(LPARAM lParam)
 30750: {
 30750:   POINT pt;
 30750:   pt.x = GET_X_LPARAM(lParam);
 30750:   pt.y = GET_Y_LPARAM(lParam);
 30750:   ::ScreenToClient(mWnd, &pt);
 30750:   return MAKELPARAM(pt.x, pt.y);
 30750: }
 30750: 
 84178: void nsWindow::PickerOpen()
 84178: {
 84178:   mPickerDisplayCount++;
 84178: }
 84178: 
 84178: void nsWindow::PickerClosed()
 84178: {
 84178:   NS_ASSERTION(mPickerDisplayCount > 0, "mPickerDisplayCount out of sync!");
 84178:   if (!mPickerDisplayCount)
 84178:     return;
 84178:   mPickerDisplayCount--;
 84178:   if (!mPickerDisplayCount && mDestroyCalled) {
 84178:     Destroy();
 84178:   }
 84178: }
 84178: 
 29835: /**************************************************************
 29835:  **************************************************************
 29835:  **
 29835:  ** BLOCK: ChildWindow impl.
 29835:  **
 29835:  ** Child window overrides.
 29835:  **
 29835:  **************************************************************
 29835:  **************************************************************/
 29835: 
 29835: // return the style for a child nsWindow
 29835: DWORD ChildWindow::WindowStyle()
 29835: {
 29835:   DWORD style = WS_CLIPCHILDREN | nsWindow::WindowStyle();
 29835:   if (!(style & WS_POPUP))
 29835:     style |= WS_CHILD; // WS_POPUP and WS_CHILD are mutually exclusive.
 29835:   VERIFY_WINDOW_STYLE(style);
 29835:   return style;
 31006: }
