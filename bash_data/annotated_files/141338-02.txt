     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "nsINameSpaceManager.h"
     1: #include "nsGkAtoms.h"
     1: #include "nsIDOMElement.h"
     1: #include "nsIBoxObject.h"
     1: #include "nsTreeColumns.h"
     1: #include "nsTreeUtils.h"
     1: #include "nsStyleContext.h"
 80058: #include "nsDOMClassInfoID.h"
 94340: #include "nsINodeInfo.h"
     1: #include "nsContentUtils.h"
  5197: #include "nsTreeBodyFrame.h"
141145: #include "mozilla/dom/Element.h"
141145: #include "mozilla/dom/TreeColumnsBinding.h"
141145: 
141145: using namespace mozilla;
     1: 
     1: // Column class that caches all the info about our column.
     1: nsTreeColumn::nsTreeColumn(nsTreeColumns* aColumns, nsIContent* aContent)
     1:   : mContent(aContent),
     1:     mColumns(aColumns),
106838:     mPrevious(nullptr)
     1: {
     1:   NS_ASSERTION(aContent &&
     1:                aContent->NodeInfo()->Equals(nsGkAtoms::treecol,
     1:                                             kNameSpaceID_XUL),
     1:                "nsTreeColumn's content must be a <xul:treecol>");
     1: 
     1:   Invalidate();
     1: }
     1: 
     1: nsTreeColumn::~nsTreeColumn()
     1: {
     1:   if (mNext) {
106838:     mNext->SetPrevious(nullptr);
     1:   }
     1: }
     1: 
 77324: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsTreeColumn)
122008:   NS_IMPL_CYCLE_COLLECTION_UNLINK(mContent)
 77324:   if (tmp->mNext) {
106838:     tmp->mNext->SetPrevious(nullptr);
122008:     NS_IMPL_CYCLE_COLLECTION_UNLINK(mNext)
 77324:   }
 77324: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 77324: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsTreeColumn)
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mContent)
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mNext)
 77324: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 31735: 
 31735: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsTreeColumn)
 31735: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsTreeColumn)
 31735: 
 40490: DOMCI_DATA(TreeColumn, nsTreeColumn)
 40490: 
     1: // QueryInterface implementation for nsTreeColumn
 31735: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsTreeColumn)
     1:   NS_INTERFACE_MAP_ENTRY(nsITreeColumn)
     1:   NS_INTERFACE_MAP_ENTRY(nsISupports)
 25059:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(TreeColumn)
 20988:   if (aIID.Equals(NS_GET_IID(nsTreeColumn))) {
 20988:     AddRef();
 20988:     *aInstancePtr = this;
 20988:     return NS_OK;
 20988:   }
     1:   else
     1: NS_INTERFACE_MAP_END
     1: 
     1: nsIFrame*
     1: nsTreeColumn::GetFrame()
     1: {
106838:   NS_ENSURE_TRUE(mContent, nullptr);
 31735: 
 36656:   return mContent->GetPrimaryFrame();
     1: }
     1: 
 79445: bool
  5625: nsTreeColumn::IsLastVisible(nsTreeBodyFrame* aBodyFrame)
  5625: {
 36656:   NS_ASSERTION(GetFrame(), "should have checked for this already");
  5625: 
  5625:   // cyclers are fixed width, don't adjust them
  5625:   if (IsCycler())
 80486:     return false;
  5625: 
  5625:   // we're certainly not the last visible if we're not visible
 36656:   if (GetFrame()->GetRect().width == 0)
 80486:     return false;
  5625: 
  5625:   // try to find a visible successor
  5625:   for (nsTreeColumn *next = GetNext(); next; next = next->GetNext()) {
 36656:     nsIFrame* frame = next->GetFrame();
  5625:     if (frame && frame->GetRect().width > 0)
 80486:       return false;
  5625:   }
 80486:   return true;
  5625: }
  5625: 
     1: nsresult
  5197: nsTreeColumn::GetRect(nsTreeBodyFrame* aBodyFrame, nscoord aY, nscoord aHeight, nsRect* aResult)
     1: {
 36656:   nsIFrame* frame = GetFrame();
     1:   if (!frame) {
     1:     *aResult = nsRect();
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
132812:   bool isRTL = aBodyFrame->StyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
     1:   *aResult = frame->GetRect();
     1:   aResult->y = aY;
     1:   aResult->height = aHeight;
 23612:   if (isRTL)
 23612:     aResult->x += aBodyFrame->mAdjustWidth;
 23612:   else if (IsLastVisible(aBodyFrame))
  5197:     aResult->width += aBodyFrame->mAdjustWidth;
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
  5197: nsTreeColumn::GetXInTwips(nsTreeBodyFrame* aBodyFrame, nscoord* aResult)
     1: {
 36656:   nsIFrame* frame = GetFrame();
     1:   if (!frame) {
     1:     *aResult = 0;
     1:     return NS_ERROR_FAILURE;
     1:   }
     1:   *aResult = frame->GetRect().x;
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
  5197: nsTreeColumn::GetWidthInTwips(nsTreeBodyFrame* aBodyFrame, nscoord* aResult)
     1: {
 36656:   nsIFrame* frame = GetFrame();
     1:   if (!frame) {
     1:     *aResult = 0;
     1:     return NS_ERROR_FAILURE;
     1:   }
     1:   *aResult = frame->GetRect().width;
  5625:   if (IsLastVisible(aBodyFrame))
  5197:     *aResult += aBodyFrame->mAdjustWidth;
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: NS_IMETHODIMP
     1: nsTreeColumn::GetElement(nsIDOMElement** aElement)
     1: {
 31735:   if (mContent) {
     1:     return CallQueryInterface(mContent, aElement);
     1:   }
106838:   *aElement = nullptr;
 31735:   return NS_ERROR_FAILURE;
 31735: }
     1: 
     1: NS_IMETHODIMP
     1: nsTreeColumn::GetColumns(nsITreeColumns** aColumns)
     1: {
     1:   NS_IF_ADDREF(*aColumns = mColumns);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsTreeColumn::GetX(int32_t* aX)
     1: {
     1:   nsIFrame* frame = GetFrame();
     1:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
     1: 
     1:   *aX = nsPresContext::AppUnitsToIntCSSPixels(frame->GetRect().x);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsTreeColumn::GetWidth(int32_t* aWidth)
     1: {
     1:   nsIFrame* frame = GetFrame();
     1:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
     1: 
     1:   *aWidth = nsPresContext::AppUnitsToIntCSSPixels(frame->GetRect().width);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTreeColumn::GetId(nsAString& aId)
     1: {
     1:   aId = GetId();
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTreeColumn::GetIdConst(const PRUnichar** aIdConst)
     1: {
     1:   *aIdConst = mId.get();
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTreeColumn::GetAtom(nsIAtom** aAtom)
     1: {
     1:   NS_IF_ADDREF(*aAtom = GetAtom());
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsTreeColumn::GetIndex(int32_t* aIndex)
     1: {
     1:   *aIndex = GetIndex();
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsTreeColumn::GetPrimary(bool* aPrimary)
     1: {
     1:   *aPrimary = IsPrimary();
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsTreeColumn::GetCycler(bool* aCycler)
     1: {
     1:   *aCycler = IsCycler();
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsTreeColumn::GetEditable(bool* aEditable)
     1: {
     1:   *aEditable = IsEditable();
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 79445: nsTreeColumn::GetSelectable(bool* aSelectable)
     1: {
     1:   *aSelectable = IsSelectable();
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsTreeColumn::GetType(int16_t* aType)
     1: {
     1:   *aType = GetType();
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTreeColumn::GetNext(nsITreeColumn** _retval)
     1: {
     1:   NS_IF_ADDREF(*_retval = GetNext());
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTreeColumn::GetPrevious(nsITreeColumn** _retval)
     1: {
     1:   NS_IF_ADDREF(*_retval = GetPrevious());
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTreeColumn::Invalidate()
     1: {
     1:   nsIFrame* frame = GetFrame();
     1:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
     1: 
     1:   // Fetch the Id.
     1:   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::id, mId);
     1: 
     1:   // If we have an Id, cache the Id as an atom.
     1:   if (!mId.IsEmpty()) {
     1:     mAtom = do_GetAtom(mId);
     1:   }
     1: 
     1:   // Cache our index.
     1:   nsTreeUtils::GetColumnIndex(mContent, &mIndex);
     1: 
132812:   const nsStyleVisibility* vis = frame->StyleVisibility();
     1: 
     1:   // Cache our text alignment policy.
132812:   const nsStyleText* textStyle = frame->StyleText();
     1: 
     1:   mTextAlignment = textStyle->mTextAlign;
 24696:   // DEFAULT or END alignment sometimes means RIGHT
 24696:   if ((mTextAlignment == NS_STYLE_TEXT_ALIGN_DEFAULT &&
 24696:        vis->mDirection == NS_STYLE_DIRECTION_RTL) ||
 24696:       (mTextAlignment == NS_STYLE_TEXT_ALIGN_END &&
 24696:        vis->mDirection == NS_STYLE_DIRECTION_LTR)) {
 24696:     mTextAlignment = NS_STYLE_TEXT_ALIGN_RIGHT;
 24697:   } else if (mTextAlignment == NS_STYLE_TEXT_ALIGN_DEFAULT ||
 24697:              mTextAlignment == NS_STYLE_TEXT_ALIGN_END) {
 24697:     mTextAlignment = NS_STYLE_TEXT_ALIGN_LEFT;
     1:   }
     1: 
     1:   // Figure out if we're the primary column (that has to have indentation
     1:   // and twisties drawn.
     1:   mIsPrimary = mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::primary,
     1:                                      nsGkAtoms::_true, eCaseMatters);
     1: 
     1:   // Figure out if we're a cycling column (one that doesn't cause a selection
     1:   // to happen).
     1:   mIsCycler = mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::cycler,
     1:                                     nsGkAtoms::_true, eCaseMatters);
     1: 
     1:   mIsEditable = mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::editable,
     1:                                      nsGkAtoms::_true, eCaseMatters);
     1: 
     1:   mIsSelectable = !mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::selectable,
     1:                                          nsGkAtoms::_false, eCaseMatters);
     1: 
     1:   mOverflow = mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::overflow,
     1:                                     nsGkAtoms::_true, eCaseMatters);
     1: 
     1:   // Figure out our column type. Default type is text.
     1:   mType = nsITreeColumn::TYPE_TEXT;
     1:   static nsIContent::AttrValuesArray typestrings[] =
106838:     {&nsGkAtoms::checkbox, &nsGkAtoms::progressmeter, nullptr};
     1:   switch (mContent->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::type,
     1:                                     typestrings, eCaseMatters)) {
     1:     case 0: mType = nsITreeColumn::TYPE_CHECKBOX; break;
     1:     case 1: mType = nsITreeColumn::TYPE_PROGRESSMETER; break;
     1:   }
     1: 
     1:   // Fetch the crop style.
     1:   mCropStyle = 0;
     1:   static nsIContent::AttrValuesArray cropstrings[] =
106838:     {&nsGkAtoms::center, &nsGkAtoms::left, &nsGkAtoms::start, nullptr};
     1:   switch (mContent->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::crop,
     1:                                     cropstrings, eCaseMatters)) {
     1:     case 0:
     1:       mCropStyle = 1;
     1:       break;
     1:     case 1:
     1:     case 2:
     1:       mCropStyle = 2;
     1:       break;
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: 
137520: nsTreeColumns::nsTreeColumns(nsTreeBodyFrame* aTree)
     1:   : mTree(aTree),
106838:     mFirstColumn(nullptr)
     1: {
141145:   SetIsDOMBinding();
     1: }
     1: 
     1: nsTreeColumns::~nsTreeColumns()
     1: {
 31233:   nsTreeColumns::InvalidateColumns();
     1: }
     1: 
141145: NS_IMPL_CYCLE_COLLECTION_WRAPPERCACHE_0(nsTreeColumns)
 40490: 
     1: // QueryInterface implementation for nsTreeColumns
141145: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsTreeColumns)
141145:   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
     1:   NS_INTERFACE_MAP_ENTRY(nsITreeColumns)
     1:   NS_INTERFACE_MAP_ENTRY(nsISupports)
     1: NS_INTERFACE_MAP_END
     1:                                                                                 
141145: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsTreeColumns)
141145: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsTreeColumns)
141145: 
141145: nsIContent*
141145: nsTreeColumns::GetParentObject() const
141145: {
141145:   return mTree ? mTree->GetBaseElement() : nullptr;
141145: }
141145: 
141145: /* virtual */ JSObject*
141145: nsTreeColumns::WrapObject(JSContext* aCx, JSObject* aScope)
141145: {
141145:   return dom::TreeColumnsBinding::Wrap(aCx, aScope, this);
141145: }
141145: 
141145: nsITreeBoxObject*
141145: nsTreeColumns::GetTree() const
141145: {
141145:   return mTree ? mTree->GetTreeBoxObject() : nullptr;
141145: }
     1: 
     1: NS_IMETHODIMP
     1: nsTreeColumns::GetTree(nsITreeBoxObject** _retval)
     1: {
141145:   NS_IF_ADDREF(*_retval = GetTree());
     1:   return NS_OK;
     1: }
     1: 
141145: uint32_t
141145: nsTreeColumns::Count()
141145: {
141145:   EnsureColumns();
141145:   uint32_t count = 0;
141145:   for (nsTreeColumn* currCol = mFirstColumn; currCol; currCol = currCol->GetNext()) {
141145:     ++count;
141145:   }
141145:   return count;
141145: }
141145: 
     1: NS_IMETHODIMP
108991: nsTreeColumns::GetCount(int32_t* _retval)
     1: {
141145:   *_retval = Count();
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsTreeColumns::GetLength(int32_t* _retval)
     1: {
141145:   *_retval = Length();
141145:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTreeColumns::GetFirstColumn(nsITreeColumn** _retval)
     1: {
     1:   NS_IF_ADDREF(*_retval = GetFirstColumn());
     1:   return NS_OK;
     1: }
     1: 
141145: nsTreeColumn*
141145: nsTreeColumns::GetLastColumn()
     1: {
     1:   EnsureColumns();
     1:   nsTreeColumn* currCol = mFirstColumn;
     1:   while (currCol) {
     1:     nsTreeColumn* next = currCol->GetNext();
     1:     if (!next) {
141145:       return currCol;
     1:     }
     1:     currCol = next;
     1:   }
141145:   return nullptr;
141145: }
141145: 
141145: NS_IMETHODIMP
141145: nsTreeColumns::GetLastColumn(nsITreeColumn** _retval)
141145: {
141145:   NS_IF_ADDREF(*_retval = GetLastColumn());
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTreeColumns::GetPrimaryColumn(nsITreeColumn** _retval)
     1: {
     1:   NS_IF_ADDREF(*_retval = GetPrimaryColumn());
     1:   return NS_OK;
     1: }
     1: 
141145: nsTreeColumn*
141145: nsTreeColumns::GetSortedColumn()
     1: {
     1:   EnsureColumns();
     1:   for (nsTreeColumn* currCol = mFirstColumn; currCol; currCol = currCol->GetNext()) {
 31735:     if (currCol->mContent &&
 31735:         nsContentUtils::HasNonEmptyAttr(currCol->mContent, kNameSpaceID_None,
     1:                                         nsGkAtoms::sortDirection)) {
141145:       return currCol;
     1:     }
     1:   }
141145:   return nullptr;
141145: }
141145: 
141145: NS_IMETHODIMP
141145: nsTreeColumns::GetSortedColumn(nsITreeColumn** _retval)
141145: {
141145:   NS_IF_ADDREF(*_retval = GetSortedColumn());
     1:   return NS_OK;
     1: }
     1: 
141145: nsTreeColumn*
141145: nsTreeColumns::GetKeyColumn()
     1: {
     1:   EnsureColumns();
     1: 
141145:   nsTreeColumn* first = nullptr;
141145:   nsTreeColumn* primary = nullptr;
141145:   nsTreeColumn* sorted = nullptr;
     1: 
     1:   for (nsTreeColumn* currCol = mFirstColumn; currCol; currCol = currCol->GetNext()) {
     1:     // Skip hidden columns.
 31735:     if (!currCol->mContent ||
 31735:         currCol->mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::hidden,
     1:                                        nsGkAtoms::_true, eCaseMatters))
     1:       continue;
     1: 
     1:     // Skip non-text column
     1:     if (currCol->GetType() != nsITreeColumn::TYPE_TEXT)
     1:       continue;
     1: 
     1:     if (!first)
     1:       first = currCol;
     1:     
     1:     if (nsContentUtils::HasNonEmptyAttr(currCol->mContent, kNameSpaceID_None,
     1:                                         nsGkAtoms::sortDirection)) {
     1:       // Use sorted column as the key.
     1:       sorted = currCol;
     1:       break;
     1:     }
     1: 
     1:     if (currCol->IsPrimary())
     1:       if (!primary)
     1:         primary = currCol;
     1:   }
     1: 
     1:   if (sorted)
141145:     return sorted;
141145:   if (primary)
141145:     return primary;
141145:   return first;
141145: }
     1: 
141145: NS_IMETHODIMP
141145: nsTreeColumns::GetKeyColumn(nsITreeColumn** _retval)
141145: {
141145:   NS_IF_ADDREF(*_retval = GetKeyColumn());
     1:   return NS_OK;
     1: }
     1: 
141145: nsTreeColumn*
141145: nsTreeColumns::GetColumnFor(dom::Element* aElement)
141145: {
141145:   EnsureColumns();
141145:   for (nsTreeColumn* currCol = mFirstColumn; currCol; currCol = currCol->GetNext()) {
141145:     if (currCol->mContent == aElement) {
141145:       return currCol;
141145:     }
141145:   }
141145:   return nullptr;
141145: }
141145: 
     1: NS_IMETHODIMP
     1: nsTreeColumns::GetColumnFor(nsIDOMElement* aElement, nsITreeColumn** _retval)
     1: {
141145:   nsCOMPtr<dom::Element> element = do_QueryInterface(aElement);
141145:   NS_ADDREF(*_retval = GetColumnFor(element));
     1:   return NS_OK;
     1: }
     1: 
141145: nsTreeColumn*
141145: nsTreeColumns::NamedGetter(const nsAString& aId, bool& aFound)
 21159: {
 21159:   EnsureColumns();
 21159:   for (nsTreeColumn* currCol = mFirstColumn; currCol; currCol = currCol->GetNext()) {
 21159:     if (currCol->GetId().Equals(aId)) {
141145:       aFound = true;
 21159:       return currCol;
 21159:     }
 21159:   }
141145:   aFound = false;
106838:   return nullptr;
 21159: }
 21159: 
141145: nsTreeColumn*
141145: nsTreeColumns::GetNamedColumn(const nsAString& aId)
141145: {
141145:   bool dummy;
141145:   return NamedGetter(aId, dummy);
141145: }
141145: 
     1: NS_IMETHODIMP
     1: nsTreeColumns::GetNamedColumn(const nsAString& aId, nsITreeColumn** _retval)
     1: {
 21159:   NS_IF_ADDREF(*_retval = GetNamedColumn(aId));
     1:   return NS_OK;
     1: }
     1: 
141145: void
141145: nsTreeColumns::GetSupportedNames(nsTArray<nsString>& aNames)
141145: {
141145:   for (nsTreeColumn* currCol = mFirstColumn; currCol; currCol = currCol->GetNext()) {
141145:     aNames.AppendElement(currCol->GetId());
141145:   }
141145: }
141145: 
141145: 
141145: nsTreeColumn*
141145: nsTreeColumns::IndexedGetter(uint32_t aIndex, bool& aFound)
 20752: {
 20752:   EnsureColumns();
 20752:   for (nsTreeColumn* currCol = mFirstColumn; currCol; currCol = currCol->GetNext()) {
141145:     if (currCol->GetIndex() == static_cast<int32_t>(aIndex)) {
141145:       aFound = true;
 20752:       return currCol;
 20752:     }
 20752:   }
141145:   aFound = false;
106838:   return nullptr;
 20752: }
 20752: 
141145: nsTreeColumn*
141145: nsTreeColumns::GetColumnAt(uint32_t aIndex)
141145: {
141145:   bool dummy;
141145:   return IndexedGetter(aIndex, dummy);
141145: }
141145: 
     1: NS_IMETHODIMP
108991: nsTreeColumns::GetColumnAt(int32_t aIndex, nsITreeColumn** _retval)
     1: {
141145:   NS_IF_ADDREF(*_retval = GetColumnAt(static_cast<uint32_t>(aIndex)));
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTreeColumns::InvalidateColumns()
     1: {
 31233:   for (nsTreeColumn* currCol = mFirstColumn; currCol;
 31233:        currCol = currCol->GetNext()) {
106838:     currCol->SetColumns(nullptr);
 31233:   }
     1:   NS_IF_RELEASE(mFirstColumn);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsTreeColumns::RestoreNaturalOrder()
     1: {
     1:   if (!mTree)
     1:     return NS_OK;
     1: 
137520:   nsIContent* content = mTree->GetBaseElement();
     1: 
 25233:   // Strong ref, since we'll be setting attributes
 25233:   nsCOMPtr<nsIContent> colsContent =
 25233:     nsTreeUtils::GetImmediateChild(content, nsGkAtoms::treecols);
     1:   if (!colsContent)
     1:     return NS_OK;
     1: 
141338:   for (uint32_t i = 0; i < colsContent->GetChildCount(); ++i) {
141338:     nsCOMPtr<nsIContent> child = colsContent->GetChildAt(i);
     1:     nsAutoString ordinal;
     1:     ordinal.AppendInt(i);
 80486:     child->SetAttr(kNameSpaceID_None, nsGkAtoms::ordinal, ordinal, true);
     1:   }
     1: 
 31233:   nsTreeColumns::InvalidateColumns();
     1: 
141338:   if (mTree) {
     1:     mTree->Invalidate();
141338:   }
     1:   return NS_OK;
     1: }
     1: 
     1: nsTreeColumn*
     1: nsTreeColumns::GetPrimaryColumn()
     1: {
     1:   EnsureColumns();
     1:   for (nsTreeColumn* currCol = mFirstColumn; currCol; currCol = currCol->GetNext()) {
     1:     if (currCol->IsPrimary()) {
     1:       return currCol;
     1:     }
     1:   }
106838:   return nullptr;
     1: }
     1: 
     1: void
     1: nsTreeColumns::EnsureColumns()
     1: {
     1:   if (mTree && !mFirstColumn) {
137520:     nsIContent* treeContent = mTree->GetBaseElement();
 25233:     nsIContent* colsContent =
 25233:       nsTreeUtils::GetDescendantChild(treeContent, nsGkAtoms::treecols);
     1:     if (!colsContent)
     1:       return;
     1: 
 25233:     nsIContent* colContent =
 25233:       nsTreeUtils::GetDescendantChild(colsContent, nsGkAtoms::treecol);
     1:     if (!colContent)
     1:       return;
     1: 
 36656:     nsIFrame* colFrame = colContent->GetPrimaryFrame();
     1:     if (!colFrame)
     1:       return;
     1: 
     1:     colFrame = colFrame->GetParent();
     1:     if (!colFrame)
     1:       return;
     1: 
 77154:     colFrame = colFrame->GetFirstPrincipalChild();
     1:     if (!colFrame)
     1:       return;
     1: 
     1:     // Now that we have the first visible column,
     1:     // we can enumerate the columns in visible order
106838:     nsTreeColumn* currCol = nullptr;
     1:     while (colFrame) {
     1:       nsIContent* colContent = colFrame->GetContent();
     1: 
     1:       if (colContent->NodeInfo()->Equals(nsGkAtoms::treecol,
     1:                                          kNameSpaceID_XUL)) {
     1:         // Create a new column structure.
     1:         nsTreeColumn* col = new nsTreeColumn(this, colContent);
     1:         if (!col)
     1:           return;
     1: 
     1:         if (currCol) {
     1:           currCol->SetNext(col);
     1:           col->SetPrevious(currCol);
     1:         }
     1:         else {
     1:           NS_ADDREF(mFirstColumn = col);
     1:         }
     1:         currCol = col;
     1:       }
     1: 
     1:       colFrame = colFrame->GetNextSibling();
     1:     }
     1:   }
     1: }
