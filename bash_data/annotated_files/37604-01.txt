    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Daniel Veditz <dveditz@netscape.com>
    1:  *   Samir Gehani <sgehani@netscape.com>
    1:  *   Mitch Stoltz <mstoltz@netscape.com>
    1:  *   Jeroen Dobbelaere <jeroen.dobbelaere@acunia.com>
    1:  *   Jeff Walden <jwalden+code@mit.edu>
31399:  *   Taras Glek <tglek@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * This module implements a simple archive extractor for the PKZIP format.
    1:  *
    1:  * The underlying nsZipArchive is NOT thread-safe. Do not pass references
    1:  * or pointers to it across thread boundaries.
    1:  */
    1: 
    1: #define READTYPE  PRInt32
    1: #include "zlib.h"
    1: #include "nsISupportsUtils.h"
    1: #include "nsRecyclingAllocator.h"
31399: #include "prio.h"
31399: #include "plstr.h"
31399: #include "prlog.h"
31399: #include "stdlib.h"
31399: #include "nsWildCard.h"
31399: #include "nsZipArchive.h"
    1: 
    1: /**
    1:  * Global allocator used with zlib. Destroyed in module shutdown.
    1:  */
    1: #define NBUCKETS 6
    1: nsRecyclingAllocator *gZlibAllocator = NULL;
    1: 
    1: // For placement new used for arena allocations of zip file list
    1: #include NEW_H
    1: #define ZIP_ARENABLOCKSIZE (1*1024)
    1: 
    1: #ifdef XP_UNIX
    1:     #include <sys/types.h>
    1:     #include <sys/stat.h>
    1:     #include <limits.h>
    1:     #include <unistd.h>
    1: #elif defined(XP_WIN) || defined(XP_OS2)
    1:     #include <io.h>
    1: #elif defined(XP_BEOS)
    1:     #include <unistd.h>
    1: #endif
    1: 
29587: #ifdef __SYMBIAN32__
29587:     #include <sys/syslimits.h>
29587: #endif /*__SYMBIAN32__*/
29587: 
29587: 
    1: #ifndef XP_UNIX /* we need some constants defined in limits.h and unistd.h */
    1: #  ifndef S_IFMT
    1: #    define S_IFMT 0170000
    1: #  endif
    1: #  ifndef S_IFLNK
    1: #    define S_IFLNK  0120000
    1: #  endif
    1: #  ifndef PATH_MAX
    1: #    define PATH_MAX 1024
    1: #  endif
    1: #endif  /* XP_UNIX */
    1: 
33990: 
33990: static const PRUint32 kMaxNameLength = PATH_MAX; /* Maximum name length */
33990: // For synthetic zip entries. Date/time corresponds to 1980-01-01 00:00.
33990: static const PRUint16 kSyntheticTime = 0;
33990: static const PRUint16 kSyntheticDate = (1 + (1 << 5) + (0 << 9));
33990: 
37369: static PRUint16 xtoint(const PRUint8 *ii);
37369: static PRUint32 xtolong(const PRUint8 *ll);
33990: static PRUint32 HashName(const char* aName, PRUint16 nameLen);
    1: #if defined(XP_UNIX) || defined(XP_BEOS)
    1: static nsresult ResolveSymlink(const char *path);
    1: #endif
    1: 
    1: //***********************************************************
    1: // Allocators for use with zlib
    1: //
33711: // Use a recycling allocator, for re-use of of the zlib buffers.
33711: // For every inflation the following allocations are done:
33711: // zlibAlloc(1, 9520)
33711: // zlibAlloc(32768, 1)
    1: //***********************************************************
    1: 
20261: static void *
    1: zlibAlloc(void *opaque, uInt items, uInt size)
    1: {
    1:   nsRecyclingAllocator *zallocator = (nsRecyclingAllocator *)opaque;
34056:   if (zallocator) {
34056:     return gZlibAllocator->Malloc(items * size);
    1:   }
34056:   return malloc(items * size);
    1: }
    1: 
20261: static void
    1: zlibFree(void *opaque, void *ptr)
    1: {
    1:   nsRecyclingAllocator *zallocator = (nsRecyclingAllocator *)opaque;
    1:   if (zallocator)
    1:     zallocator->Free(ptr);
    1:   else
    1:     free(ptr);
    1: }
    1: 
    1: nsresult gZlibInit(z_stream *zs)
    1: {
    1:   memset(zs, 0, sizeof(z_stream));
    1:   //-- ensure we have our zlib allocator for better performance
    1:   if (!gZlibAllocator) {
    1:     gZlibAllocator = new nsRecyclingAllocator(NBUCKETS, NS_DEFAULT_RECYCLE_TIMEOUT, "libjar");
    1:   }
    1:   if (gZlibAllocator) {
    1:     zs->zalloc = zlibAlloc;
    1:     zs->zfree = zlibFree;
    1:     zs->opaque = gZlibAllocator;
    1:   }
    1:   int zerr = inflateInit2(zs, -MAX_WBITS);
33668:   if (zerr != Z_OK) return NS_ERROR_OUT_OF_MEMORY;
    1: 
33668:   return NS_OK;
    1: }
    1: 
31399: nsZipHandle::nsZipHandle()
37439:   : mFileData(nsnull)
31399:   , mLen(0)
31399:   , mMap(nsnull)
31399:   , mRefCnt(0)
31399: {
31399:   MOZ_COUNT_CTOR(nsZipHandle);
31399: }
31399: 
31399: NS_IMPL_THREADSAFE_ADDREF(nsZipHandle)
31399: NS_IMPL_THREADSAFE_RELEASE(nsZipHandle)
31399: 
31399: nsresult nsZipHandle::Init(PRFileDesc *fd, nsZipHandle **ret)
31399: {
31399:   PRInt64 size = PR_Available64(fd);
31399:   if (size >= PR_INT32_MAX)
31399:     return NS_ERROR_FILE_TOO_BIG;
31399: 
31399:   PRFileMap *map = PR_CreateFileMap(fd, size, PR_PROT_READONLY);
31399:   if (!map)
31399:     return NS_ERROR_FAILURE;
31399:   
34662:   PRUint8 *buf = (PRUint8*) PR_MemMap(map, 0, (PRUint32) size);
34662:   // Bug 525755: PR_MemMap fails when fd points at something other than a normal file.
34662:   if (!buf) {
34662:     PR_CloseFileMap(map);
34662:     return NS_ERROR_FAILURE;
34662:   }
34662: 
31399:   nsZipHandle *handle = new nsZipHandle();
33443:   if (!handle) {
35430:     PR_MemUnmap(buf, size);
33443:     PR_CloseFileMap(map);
31399:     return NS_ERROR_OUT_OF_MEMORY;
33443:   }
31399: 
31399:   handle->mMap = map;
31399:   handle->mLen = (PRUint32) size;
34662:   handle->mFileData = buf;
31399:   handle->AddRef();
31399:   *ret = handle;
31399:   return NS_OK;
31399: }
31399: 
31399: nsZipHandle::~nsZipHandle()
31399: {
33443:   if (mFileData) {
31399:     PR_MemUnmap(mFileData, mLen);
31399:     PR_CloseFileMap(mMap);
33443:     mFileData = nsnull;
33443:     mMap = nsnull;
33443:   }
31399:   MOZ_COUNT_DTOR(nsZipHandle);
31399: }
31399: 
    1: //***********************************************************
    1: //      nsZipArchive  --  public methods
    1: //***********************************************************
    1: 
    1: 
    1: //---------------------------------------------
    1: //  nsZipArchive::OpenArchive
    1: //---------------------------------------------
37439: nsresult nsZipArchive::OpenArchive(nsIFile *aZipFile)
    1: {
37439:   nsresult rv;
37439:   nsCOMPtr<nsILocalFile> localFile = do_QueryInterface(aZipFile, &rv);
37439:   if (NS_FAILED(rv)) return rv;
37439: 
37439:   PRFileDesc* fd;
37439:   rv = localFile->OpenNSPRFileDesc(PR_RDONLY, 0000, &fd);
37439:   if (NS_FAILED(rv)) return rv;
37439: 
37439:   rv = nsZipHandle::Init(fd, getter_AddRefs(mFd));
37439:   PR_Close(fd);
31399:   if (NS_FAILED(rv))
31399:     return rv;
    1: 
    1:   // Initialize our arena
    1:   PL_INIT_ARENA_POOL(&mArena, "ZipArena", ZIP_ARENABLOCKSIZE);
    1: 
    1:   //-- get table of contents for archive
    1:   return BuildFileList();
    1: }
    1: 
    1: //---------------------------------------------
    1: //  nsZipArchive::Test
    1: //---------------------------------------------
    1: nsresult nsZipArchive::Test(const char *aEntryName)
    1: {
    1:   nsZipItem* currItem;
    1: 
    1:   if (aEntryName) // only test specified item
    1:   {
    1:     currItem = GetItem(aEntryName);
    1:     if (!currItem)
33668:       return NS_ERROR_FILE_TARGET_DOES_NOT_EXIST;
    1:     //-- don't test (synthetic) directory items
33990:     if (currItem->IsDirectory())
33668:       return NS_OK;
    1:     return ExtractFile(currItem, 0, 0);
    1:   }
    1: 
    1:   // test all items in archive
    1:   for (int i = 0; i < ZIP_TABSIZE; i++) {
    1:     for (currItem = mFiles[i]; currItem; currItem = currItem->next) {
    1:       //-- don't test (synthetic) directory items
33990:       if (currItem->IsDirectory())
    1:         continue;
    1:       nsresult rv = ExtractFile(currItem, 0, 0);
33668:       if (rv != NS_OK)
    1:         return rv;
    1:     }
    1:   }
    1: 
33668:   return NS_OK;
    1: }
    1: 
    1: //---------------------------------------------
    1: //  nsZipArchive::CloseArchive
    1: //---------------------------------------------
    1: nsresult nsZipArchive::CloseArchive()
    1: {
    1:   if (mFd) {
    1:     PL_FinishArenaPool(&mArena);
33443:     mFd = NULL;
    1:   }
    1: 
    1:   // CAUTION:
    1:   // We don't need to delete each of the nsZipItem as the memory for
    1:   // the zip item and the filename it holds are both allocated from the Arena.
    1:   // Hence, destroying the Arena is like destroying all the memory
    1:   // for all the nsZipItem in one shot. But if the ~nsZipItem is doing
    1:   // anything more than cleaning up memory, we should start calling it.
    1:   // Let us also cleanup the mFiles table for re-use on the next 'open' call
33443:   memset(mFiles, 0, sizeof(mFiles));
33443:   mBuiltSynthetics = false;
33668:   return NS_OK;
    1: }
    1: 
    1: //---------------------------------------------
    1: // nsZipArchive::GetItem
    1: //---------------------------------------------
    1: nsZipItem*  nsZipArchive::GetItem(const char * aEntryName)
    1: {
    1:   if (aEntryName) {
33990:     PRUint32 len = strlen(aEntryName);
    1:     //-- If the request is for a directory, make sure that synthetic entries 
    1:     //-- are created for the directories without their own entry.
    1:     if (!mBuiltSynthetics) {
    1:         if ((len > 0) && (aEntryName[len-1] == '/')) {
33668:             if (BuildSynthetics() != NS_OK)
    1:                 return 0;
    1:         }
    1:     }
    1: 
33990:     nsZipItem* item = mFiles[ HashName(aEntryName, len) ];
    1:     while (item) {
33990:       if ((len == item->nameLength) && 
33990:          (!memcmp(aEntryName, item->Name(), len)))
    1:         return item; //-- found it
    1:       item = item->next;
    1:     }
    1:   }
    1:   return 0;
    1: }
    1: 
    1: //---------------------------------------------
    1: // nsZipArchive::ExtractFile
    1: // This extracts the item to the filehandle provided.
    1: // If 'aFd' is null, it only tests the extraction.
    1: // On extraction error(s) it removes the file.
    1: // When needed, it also resolves the symlink.
    1: //---------------------------------------------
    1: nsresult nsZipArchive::ExtractFile(nsZipItem *item, const char *outname,
    1:                                    PRFileDesc* aFd)
    1: {
    1:   if (!item)
33668:     return NS_ERROR_ILLEGAL_VALUE;
    1:   if (!mFd)
33668:     return NS_ERROR_FAILURE;
    1: 
    1:   // Directory extraction is handled in nsJAR::Extract,
    1:   // so the item to be extracted should never be a directory
33990:   PR_ASSERT(!item->IsDirectory());
    1: 
    1:   nsresult rv;
    1: 
    1:   //-- extract the file using the appropriate method
33990:   switch(item->Compression())
    1:   {
    1:     case STORED:
33443:       rv = CopyItemToDisk(item, aFd);
    1:       break;
    1: 
    1:     case DEFLATED:
33443:       rv = InflateItem(item, aFd);
    1:       break;
    1: 
    1:     default:
    1:       //-- unsupported compression type
33668:       rv = NS_ERROR_NOT_IMPLEMENTED;
    1:   }
    1: 
    1:   //-- delete the file on errors, or resolve symlink if needed
    1:   if (aFd) {
    1:     PR_Close(aFd);
33668:     if (rv != NS_OK)
    1:       PR_Delete(outname);
    1: #if defined(XP_UNIX) || defined(XP_BEOS)
33990:     else if (item->IsSymlink())
    1:       rv = ResolveSymlink(outname);
    1: #endif
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: //---------------------------------------------
    1: // nsZipArchive::FindInit
    1: //---------------------------------------------
    1: PRInt32
    1: nsZipArchive::FindInit(const char * aPattern, nsZipFind **aFind)
    1: {
    1:   if (!aFind)
33668:     return NS_ERROR_ILLEGAL_VALUE;
    1: 
    1:   // null out param in case an error happens
    1:   *aFind = NULL;
    1: 
    1:   PRBool  regExp = PR_FALSE;
    1:   char*   pattern = 0;
    1: 
    1:   // Create synthetic directory entries on demand
    1:   nsresult rv = BuildSynthetics();
33668:   if (rv != NS_OK)
    1:     return rv;
    1: 
    1:   // validate the pattern
    1:   if (aPattern)
    1:   {
    1:     switch (NS_WildCardValid((char*)aPattern))
    1:     {
    1:       case INVALID_SXP:
33668:         return NS_ERROR_ILLEGAL_VALUE;
    1: 
    1:       case NON_SXP:
    1:         regExp = PR_FALSE;
    1:         break;
    1: 
    1:       case VALID_SXP:
    1:         regExp = PR_TRUE;
    1:         break;
    1: 
    1:       default:
    1:         // undocumented return value from RegExpValid!
    1:         PR_ASSERT(PR_FALSE);
33668:         return NS_ERROR_ILLEGAL_VALUE;
    1:     }
    1: 
    1:     pattern = PL_strdup(aPattern);
    1:     if (!pattern)
33668:       return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   *aFind = new nsZipFind(this, pattern, regExp);
    1:   if (!*aFind) {
27026:     PL_strfree(pattern);
33668:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
33668:   return NS_OK;
    1: }
    1: 
    1: 
    1: 
    1: //---------------------------------------------
    1: // nsZipFind::FindNext
    1: //---------------------------------------------
33990: nsresult nsZipFind::FindNext(const char ** aResult, PRUint16 *aNameLen)
    1: {
33990:   if (!mArchive || !aResult || !aNameLen)
33668:     return NS_ERROR_ILLEGAL_VALUE;
    1: 
    1:   *aResult = 0;
33990:   *aNameLen = 0;
    1: 
    1:   // we start from last match, look for next
    1:   while (mSlot < ZIP_TABSIZE)
    1:   {
    1:     // move to next in current chain, or move to new slot
    1:     mItem = mItem ? mItem->next : mArchive->mFiles[mSlot];
    1: 
    1:     PRBool found = PR_FALSE;
    1:     if (!mItem)
    1:       ++mSlot;                          // no more in this chain, move to next slot
    1:     else if (!mPattern)
    1:       found = PR_TRUE;            // always match
    1:     else if (mRegExp)
33990:     {
33990:       char buf[kMaxNameLength+1];
33990:       memcpy(buf, mItem->Name(), mItem->nameLength);
33990:       buf[mItem->nameLength]='\0';
33990:       found = (NS_WildCardMatch(buf, mPattern, PR_FALSE) == MATCH);
33990:     }
    1:     else
33990:       found = ((mItem->nameLength == strlen(mPattern)) &&
33990:                (memcmp(mItem->Name(), mPattern, mItem->nameLength) == 0));
    1:     if (found) {
33990:       // Need also to return the name length, as it is NOT zero-terminatdd...
33990:       *aResult = mItem->Name();
33990:       *aNameLen = mItem->nameLength;
33668:       return NS_OK;
    1:     }
    1:   }
    1: 
33668:   return NS_ERROR_FILE_TARGET_DOES_NOT_EXIST;
    1: }
    1: 
    1: #if defined(XP_UNIX) || defined(XP_BEOS)
    1: //---------------------------------------------
    1: // ResolveSymlink
    1: //---------------------------------------------
    1: static nsresult ResolveSymlink(const char *path)
    1: {
    1:   PRFileDesc * fIn = PR_Open(path, PR_RDONLY, 0000);
    1:   if (!fIn)
33668:     return NS_ERROR_FILE_DISK_FULL;
    1: 
    1:   char buf[PATH_MAX+1];
    1:   PRInt32 length = PR_Read(fIn, (void*)buf, PATH_MAX);
    1:   PR_Close(fIn);
    1: 
    1:   if ( (length <= 0)
    1:     || ((buf[length] = 0, PR_Delete(path)) != 0)
    1:     || (symlink(buf, path) != 0))
    1:   {
33668:      return NS_ERROR_FILE_DISK_FULL;
    1:   }
33668:   return NS_OK;
    1: }
    1: #endif
    1: 
    1: //***********************************************************
    1: //      nsZipArchive  --  private implementation
    1: //***********************************************************
    1: 
    1: //---------------------------------------------
    1: //  nsZipArchive::CreateZipItem
    1: //---------------------------------------------
33990: nsZipItem* nsZipArchive::CreateZipItem()
    1: {
    1:   // Arena allocate the nsZipItem
    1:   void *mem;
33990:   PL_ARENA_ALLOCATE(mem, &mArena, sizeof(nsZipItem));
    1:   return (nsZipItem*)mem;
    1: }
    1: 
    1: //---------------------------------------------
    1: //  nsZipArchive::BuildFileList
    1: //---------------------------------------------
    1: nsresult nsZipArchive::BuildFileList()
    1: {
31798:   // Get archive size using end pos
31399:   PRUint8* buf;
33990:   PRUint8* startp = mFd->mFileData;
33990:   PRUint8* endp = startp + mFd->mLen;
    1: 
31798:   for (buf = endp - ZIPEND_SIZE; xtolong(buf) != ENDSIG; buf--)
31798:   {
33990:     if (buf == startp) {
31798:       // We're at the beginning of the file, and still no sign
31798:       // of the end signature.  File must be corrupted!
33668:       return NS_ERROR_FILE_CORRUPTED;
31798:     }
31798:   }
33990:   PRUint32 centralOffset = xtolong(((ZipEnd *)buf)->offset_central_dir);
    1: 
31798:   //-- Read the central directory headers
33990:   buf = startp + centralOffset;
37604:   if (endp - buf < PRInt32(sizeof(PRUint32)))
37464:       return NS_ERROR_FILE_CORRUPTED;
31798:   PRUint32 sig = xtolong(buf);
31798:   while (sig == CENTRALSIG) {
31798:     // Make sure there is enough data available.
31798:     if (endp - buf < ZIPCENTRAL_SIZE)
33668:       return NS_ERROR_FILE_CORRUPTED;
    1: 
31798:     // Read the fixed-size data.
31798:     ZipCentral* central = (ZipCentral*)buf;
    1: 
    1:     PRUint16 namelen = xtoint(central->filename_len);
    1:     PRUint16 extralen = xtoint(central->extrafield_len);
    1:     PRUint16 commentlen = xtoint(central->commentfield_len);
    1: 
33990:     // Point to the next item at the top of loop
33990:     buf += ZIPCENTRAL_SIZE + namelen + extralen + commentlen;
33990: 
31798:     // Sanity check variable sizes and refuse to deal with
31798:     // anything too big: it's likely a corrupt archive.
33990:     if (namelen > kMaxNameLength || buf >= endp)
33668:       return NS_ERROR_FILE_CORRUPTED;
13296: 
33990:     nsZipItem* item = CreateZipItem();
    1:     if (!item)
33668:       return NS_ERROR_OUT_OF_MEMORY;
    1: 
33990:     item->central = central;
33990:     item->nameLength = namelen;
33990:     item->isSynthetic = false;
    1: 
31798:     // Add item to file table
33990:     PRUint32 hash = HashName(item->Name(), namelen);
    1:     item->next = mFiles[hash];
    1:     mFiles[hash] = item;
    1: 
31798:     sig = xtolong(buf);
    1:   } /* while reading central directory records */
    1: 
    1:   if (sig != ENDSIG)
33668:     return NS_ERROR_FILE_CORRUPTED;
33668:   return NS_OK;
    1: }
    1: 
    1: //---------------------------------------------
    1: //  nsZipArchive::BuildSynthetics
    1: //---------------------------------------------
    1: nsresult nsZipArchive::BuildSynthetics()
    1: {
    1:   if (mBuiltSynthetics)
33668:     return NS_OK;
33443:   mBuiltSynthetics = true;
    1: 
    1:   // Create synthetic entries for any missing directories.
    1:   // Do this when all ziptable has scanned to prevent double entries.
    1:   for (int i = 0; i < ZIP_TABSIZE; ++i)
    1:   {
    1:     for (nsZipItem* item = mFiles[i]; item != 0; item = item->next)
    1:     {
    1:       if (item->isSynthetic)
    1:         continue;
    1:     
    1:       //-- add entries for directories in the current item's path
    1:       //-- go from end to beginning, because then we can stop trying
    1:       //-- to create diritems if we find that the diritem we want to
    1:       //-- create already exists
    1:       //-- start just before the last char so as to not add the item
    1:       //-- twice if it's a directory
33990:       PRUint16 namelen = item->nameLength;
33990:       const char *name = item->Name();
33990:       for (PRUint16 dirlen = namelen - 1; dirlen > 0; dirlen--)
    1:       {
33990:         if (name[dirlen-1] != '/')
    1:           continue;
    1: 
33990:         // Is the directory already in the file table?
33990:         PRUint32 hash = HashName(item->Name(), dirlen);
    1:         PRBool found = PR_FALSE;
    1:         for (nsZipItem* zi = mFiles[hash]; zi != NULL; zi = zi->next)
    1:         {
33990:           if ((dirlen == zi->nameLength) &&
33990:               (0 == memcmp(item->Name(), zi->Name(), dirlen)))
    1:           {
    1:             // we've already added this dir and all its parents
    1:             found = PR_TRUE;
    1:             break;
    1:           }
    1:         }
    1:         // if the directory was found, break out of the directory
    1:         // creation loop now that we know all implicit directories
    1:         // are there -- otherwise, start creating the zip item
    1:         if (found)
    1:           break;
    1: 
33990:         nsZipItem* diritem = CreateZipItem();
    1:         if (!diritem)
33668:           return NS_ERROR_OUT_OF_MEMORY;
    1: 
33990:         // Point to the central record of the original item for the name part.
33990:         diritem->central =  item->central;
33990:         diritem->nameLength = dirlen;
33990:         diritem->isSynthetic = true;
    1: 
    1:         // add diritem to the file table
    1:         diritem->next = mFiles[hash];
    1:         mFiles[hash] = diritem;
    1:       } /* end processing of dirs in item's name */
    1:     }
    1:   }
33668:   return NS_OK;
    1: }
    1: 
33443: nsZipHandle* nsZipArchive::GetFD()
31399: {
33443:   if (!mFd)
31399:     return NULL;
31399:   return mFd.get();
31399: }
    1: 
    1: //---------------------------------------------
33443: // nsZipArchive::GetData
    1: //---------------------------------------------
33443: PRUint8* nsZipArchive::GetData(nsZipItem* aItem)
    1: {
    1:   PR_ASSERT (aItem);
    1: 
    1:   //-- read local header to get variable length values and calculate
    1:   //-- the real data offset
33990:   PRUint32 len = mFd->mLen;
33990:   PRUint8* data = mFd->mFileData;
33990:   PRUint32 offset = aItem->LocalOffset();
33990:   if (offset + ZIPLOCAL_SIZE > len)
33443:     return nsnull;
33443: 
33443:   // -- check signature before using the structure, in case the zip file is corrupt
33990:   ZipLocal* Local = (ZipLocal*)(data + offset);
33443:   if ((xtolong(Local->signature) != LOCALSIG))
33443:     return nsnull;
33443: 
    1:   //-- NOTE: extralen is different in central header and local header
    1:   //--       for archives created using the Unix "zip" utility. To set
    1:   //--       the offset accurately we need the _local_ extralen.
33990:   offset += ZIPLOCAL_SIZE +
31399:             xtoint(Local->filename_len) +
31399:             xtoint(Local->extrafield_len);
    1: 
33443:   // -- check if there is enough source data in the file
33990:   if (offset + aItem->Size() > len)
33443:     return nsnull;
33443: 
33990:   return data + offset;
    1: }
    1: 
    1: //---------------------------------------------
    1: // nsZipArchive::CopyItemToDisk
    1: //---------------------------------------------
    1: nsresult
33443: nsZipArchive::CopyItemToDisk(nsZipItem *item, PRFileDesc* outFD)
    1: {
33443:   PR_ASSERT(item);
    1: 
33443:   //-- get to the start of file's data
33443:   const PRUint8* itemData = GetData(item);
33443:   if (!itemData)
33668:     return NS_ERROR_FILE_CORRUPTED;
32208: 
33990:   if (outFD && PR_Write(outFD, itemData, item->Size()) < (READTYPE)item->Size())
    1:   {
    1:     //-- Couldn't write all the data (disk full?)
33668:     return NS_ERROR_FILE_DISK_FULL;
    1:   }
    1: 
33443:   //-- Calculate crc
33990:   PRUint32 crc = crc32(0L, (const unsigned char*)itemData, item->Size());
    1:   //-- verify crc32
33990:   if (crc != item->CRC32())
33668:       return NS_ERROR_FILE_CORRUPTED;
    1: 
33668:   return NS_OK;
    1: }
    1: 
    1: 
    1: //---------------------------------------------
    1: // nsZipArchive::InflateItem
    1: //---------------------------------------------
33443: nsresult nsZipArchive::InflateItem(nsZipItem * item, PRFileDesc* outFD)
    1: /*
    1:  * This function inflates an archive item to disk, to the
    1:  * file specified by outFD. If outFD is zero, the extracted data is
    1:  * not written, only checked for CRC, so this is in effect same as 'Test'.
    1:  */
    1: {
33443:   PR_ASSERT(item);
    1:   //-- allocate deflation buffers
    1:   Bytef outbuf[ZIP_BUFLEN];
    1: 
    1:   //-- set up the inflate
    1:   z_stream    zs;
    1:   nsresult status = gZlibInit(&zs);
33668:   if (status != NS_OK)
33668:     return NS_ERROR_FAILURE;
    1: 
    1:   //-- inflate loop
33990:   zs.avail_in = item->Size();
33443:   zs.next_in = (Bytef*)GetData(item);
33443:   if (!zs.next_in)
33668:     return NS_ERROR_FILE_CORRUPTED;
    1: 
    1:   PRUint32  crc = crc32(0L, Z_NULL, 0);
    1:   int zerr = Z_OK;
    1:   while (zerr == Z_OK)
    1:   {
33443:     zs.next_out = outbuf;
33443:     zs.avail_out = ZIP_BUFLEN;
    1: 
33443:     zerr = inflate(&zs, Z_PARTIAL_FLUSH);
33443:     if (zerr != Z_OK && zerr != Z_STREAM_END)
    1:     {
33668:       status = (zerr == Z_MEM_ERROR) ? NS_ERROR_OUT_OF_MEMORY : NS_ERROR_FILE_CORRUPTED;
    1:       break;
    1:     }
33443:     PRUint32 count = zs.next_out - outbuf;
    1: 
33443:     //-- incrementally update crc32
33443:     crc = crc32(crc, (const unsigned char*)outbuf, count);
    1: 
33443:     if (outFD && PR_Write(outFD, outbuf, count) < (READTYPE)count)
    1:     {
33668:       status = NS_ERROR_FILE_DISK_FULL;
    1:       break;
    1:     }
    1:   } // while
    1: 
    1:   //-- free zlib internal state
    1:   inflateEnd(&zs);
    1: 
33443:   //-- verify crc32
33990:   if ((status == NS_OK) && (crc != item->CRC32()))
33443:   {
33668:     status = NS_ERROR_FILE_CORRUPTED;
33443:   }
    1:   return status;
    1: }
    1: 
    1: //------------------------------------------
    1: // nsZipArchive constructor and destructor
    1: //------------------------------------------
    1: 
    1: nsZipArchive::nsZipArchive() :
33443:   mBuiltSynthetics(false)
    1: {
    1:   MOZ_COUNT_CTOR(nsZipArchive);
    1: 
    1:   // initialize the table to NULL
33443:   memset(mFiles, 0, sizeof(mFiles));
    1: }
    1: 
    1: nsZipArchive::~nsZipArchive()
    1: {
    1:   CloseArchive();
    1: 
    1:   MOZ_COUNT_DTOR(nsZipArchive);
    1: }
    1: 
    1: 
    1: //------------------------------------------
    1: // nsZipFind constructor and destructor
    1: //------------------------------------------
    1: 
    1: nsZipFind::nsZipFind(nsZipArchive* aZip, char* aPattern, PRBool aRegExp) : 
    1:   mArchive(aZip),
    1:   mPattern(aPattern),
    1:   mItem(0),
    1:   mSlot(0),
    1:   mRegExp(aRegExp)
    1: {
    1:   MOZ_COUNT_CTOR(nsZipFind);
    1: }
    1: 
    1: nsZipFind::~nsZipFind()
    1: {
27026:   PL_strfree(mPattern);
    1: 
    1:   MOZ_COUNT_DTOR(nsZipFind);
    1: }
    1: 
    1: //------------------------------------------
    1: // helper functions
    1: //------------------------------------------
    1: 
    1: /* 
    1:  * HashName 
    1:  *
    1:  * returns a hash key for the entry name 
    1:  */
33990: static PRUint32 HashName(const char* aName, PRUint16 len)
    1: {
    1:   PR_ASSERT(aName != 0);
    1: 
33990:   const PRUint8* p = (const PRUint8*)aName;
33990:   const PRUint8* endp = p + len;
    1:   PRUint32 val = 0;
33990:   while (p != endp) {
33990:     val = val*37 + *p++;
    1:   }
    1: 
    1:   return (val % ZIP_TABSIZE);
    1: }
    1: 
    1: /*
    1:  *  x t o i n t
    1:  *
    1:  *  Converts a two byte ugly endianed integer
    1:  *  to our platform's integer.
    1:  */
37369: static PRUint16 xtoint (const PRUint8 *ii)
    1: {
    1:   return (PRUint16) ((ii [0]) | (ii [1] << 8));
    1: }
    1: 
    1: /*
    1:  *  x t o l o n g
    1:  *
    1:  *  Converts a four byte ugly endianed integer
    1:  *  to our platform's integer.
    1:  */
37369: static PRUint32 xtolong (const PRUint8 *ll)
    1: {
    1:   return (PRUint32)( (ll [0] <<  0) |
    1:                      (ll [1] <<  8) |
    1:                      (ll [2] << 16) |
    1:                      (ll [3] << 24) );
    1: }
    1: 
37369: /*
37369:  * GetModTime
37369:  *
37369:  * returns last modification time in microseconds
37369:  */
37369: static PRTime GetModTime(PRUint16 aDate, PRUint16 aTime)
37369: {
37369:   // Note that on DST shift we can't handle correctly the hour that is valid
37369:   // in both DST zones
37369:   PRExplodedTime time;
37369: 
37369:   time.tm_usec = 0;
37369: 
37369:   time.tm_hour = (aTime >> 11) & 0x1F;
37369:   time.tm_min = (aTime >> 5) & 0x3F;
37369:   time.tm_sec = (aTime & 0x1F) * 2;
37369: 
37369:   time.tm_year = (aDate >> 9) + 1980;
37369:   time.tm_month = ((aDate >> 5) & 0x0F) - 1;
37369:   time.tm_mday = aDate & 0x1F;
37369: 
37369:   time.tm_params.tp_gmt_offset = 0;
37369:   time.tm_params.tp_dst_offset = 0;
37369: 
37369:   PR_NormalizeTime(&time, PR_GMTParameters);
37369:   time.tm_params.tp_gmt_offset = PR_LocalTimeParameters(&time).tp_gmt_offset;
37369:   PR_NormalizeTime(&time, PR_GMTParameters);
37369:   time.tm_params.tp_dst_offset = PR_LocalTimeParameters(&time).tp_dst_offset;
37369: 
37369:   return PR_ImplodeTime(&time);
37369: }
37369: 
37369: PRUint32 nsZipItem::LocalOffset()
    1: {
33990:   return xtolong(central->localhdr_offset);
33990: }
33990: 
37369: PRUint32 nsZipItem::Size()
33990: {
33990:   return isSynthetic ? 0 : xtolong(central->size);
33990: }
33990: 
37369: PRUint32 nsZipItem::RealSize()
33990: {
33990:   return isSynthetic ? 0 : xtolong(central->orglen);
33990: }
33990: 
37369: PRUint32 nsZipItem::CRC32()
33990: {
33990:   return isSynthetic ? 0 : xtolong(central->crc32);
33990: }
33990: 
37369: PRUint16 nsZipItem::Date()
33990: {
33990:   return isSynthetic ? kSyntheticDate : xtoint(central->date);
33990: }
33990: 
37369: PRUint16 nsZipItem::Time()
33990: {
33990:   return isSynthetic ? kSyntheticTime : xtoint(central->time);
33990: }
33990: 
37369: PRUint16 nsZipItem::Compression()
33990: {
33990:   return isSynthetic ? STORED : xtoint(central->method);
33990: }
33990: 
37369: bool nsZipItem::IsDirectory()
33990: {
33990:   return isSynthetic || ((nameLength > 0) && ('/' == Name()[nameLength - 1]));
33990: }
33990: 
37369: PRUint16 nsZipItem::Mode()
33990: {
33990:   if (isSynthetic) return 0755;
33990:   return ((PRUint16)(central->external_attributes[2]) | 0x100);
    1: }
    1: 
37369: const PRUint8 * nsZipItem::GetExtraField(PRUint16 aTag, PRUint16 *aBlockSize)
37369: {
37369:   if (isSynthetic) return NULL;
37369: 
37369:   const unsigned char *buf = ((const unsigned char*)central) + ZIPCENTRAL_SIZE +
37369:                              nameLength;
37369:   PRUint32 buflen = (PRUint32)xtoint(central->extrafield_len);
37369:   PRUint32 pos = 0;
37369:   PRUint16 tag, blocksize;
37369: 
37369:   while (buf && (pos + 4) <= buflen) {
37369:     tag = xtoint(buf + pos);
37369:     blocksize = xtoint(buf + pos + 2);
37369: 
37369:     if (aTag == tag && (pos + 4 + blocksize) <= buflen) {
37369:       *aBlockSize = blocksize;
37369:       return buf + pos;
37369:     }
37369: 
37369:     pos += blocksize + 4;
37369:   }
37369: 
37369:   return NULL;
37369: }
37369: 
37369: 
37369: PRTime nsZipItem::LastModTime()
37369: {
37369:   if (isSynthetic) return GetModTime(kSyntheticDate, kSyntheticTime);
37369: 
37369:   // Try to read timestamp from extra field
37369:   PRUint16 blocksize;
37369:   const PRUint8 *tsField = GetExtraField(EXTENDED_TIMESTAMP_FIELD, &blocksize);
37369:   if (tsField && blocksize >= 5 && tsField[4] & EXTENDED_TIMESTAMP_MODTIME) {
37369:     return (PRTime)(xtolong(tsField + 5)) * PR_USEC_PER_SEC;
37369:   }
37369: 
37369:   return GetModTime(Date(), Time());
37369: }
37369: 
    1: #if defined(XP_UNIX) || defined(XP_BEOS)
37369: bool nsZipItem::IsSymlink()
    1: {
33990:   if (isSynthetic) return false;
33990:   return (xtoint(central->external_attributes+2) & S_IFMT) == S_IFLNK;
    1: }
    1: #endif
37369: 
