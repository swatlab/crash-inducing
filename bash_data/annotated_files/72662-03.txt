    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim: set ts=2 sw=2 et tw=78: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Johnny Stenback <jst@netscape.com>
    1:  *   L. David Baron  <dbaron@dbaron.org>
    1:  *   Pierre Phaneuf  <pp@ludusdesign.com>
    1:  *   Pete Collins    <petejc@collab.net>
    1:  *   James Ross      <silver@warwickcompsoc.co.uk>
16977:  *   Ryan Jones      <sciguyryan@gmail.com>
72272:  *   Ms2ger <ms2ger@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * Base class for all our document implementations.
    1:  */
    1: 
37838: #ifdef MOZ_LOGGING
37838: // so we can get logging even in release builds
37838: #define FORCE_PR_LOG 1
37838: #endif
37838: #include "prlog.h"
    1: #include "plstr.h"
 7783: #include "prprf.h"
    1: 
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsDocument.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "nsContentList.h"
    1: #include "nsIObserver.h"
    1: #include "nsIBaseWindow.h"
47937: #include "mozilla/css/Loader.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIScriptRuntime.h"
    1: #include "nsCOMArray.h"
    1: 
    1: #include "nsGUIEvent.h"
46273: #include "nsPLDOMEvent.h"
    1: 
    1: #include "nsIDOMStyleSheet.h"
    1: #include "nsDOMAttribute.h"
    1: #include "nsIDOMDOMStringList.h"
    1: #include "nsIDOMDOMImplementation.h"
    1: #include "nsIDOMDocumentXBL.h"
41653: #include "mozilla/FunctionTimer.h"
    1: #include "nsGenericElement.h"
16977: #include "nsGenericHTMLElement.h"
    1: #include "nsIDOMCDATASection.h"
    1: #include "nsIDOMProcessingInstruction.h"
    1: #include "nsDOMString.h"
    1: #include "nsNodeUtils.h"
 5440: #include "nsLayoutUtils.h" // for GetFrameForPoint
 5440: #include "nsIFrame.h"
46908: #include "nsITabChild.h"
    1: 
    1: #include "nsRange.h"
    1: #include "nsIDOMText.h"
    1: #include "nsIDOMComment.h"
    1: #include "nsDOMDocumentType.h"
16103: #include "nsNodeIterator.h"
    1: #include "nsTreeWalker.h"
    1: 
    1: #include "nsIServiceManager.h"
    1: 
    1: #include "nsContentCID.h"
    1: #include "nsDOMError.h"
    1: #include "nsIPresShell.h"
    1: #include "nsPresContext.h"
62765: #include "nsIJSON.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsNodeInfoManager.h"
    1: #include "nsIXBLService.h"
    1: #include "nsIFileChannel.h"
    1: #include "nsIMultiPartChannel.h"
    1: #include "nsIRefreshURI.h"
    1: #include "nsIWebNavigation.h"
    1: #include "nsIScriptError.h"
    1: 
    1: #include "nsNetUtil.h"     // for NS_MakeAbsoluteURI
    1: 
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsIPrincipal.h"
    1: 
    1: #include "nsIDOMWindowInternal.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIDOMElement.h"
29018: #include "nsFocusManager.h"
    1: 
    1: // for radio group stuff
    1: #include "nsIDOMHTMLInputElement.h"
    1: #include "nsIRadioVisitor.h"
    1: #include "nsIFormControl.h"
    1: 
    1: #include "nsXMLEventsManager.h"
    1: 
    1: #include "nsBidiUtils.h"
    1: 
    1: #include "nsIDOMUserDataHandler.h"
    1: #include "nsScriptEventManager.h"
    1: #include "nsIDOMXPathEvaluator.h"
    1: #include "nsIXPathEvaluatorInternal.h"
    1: #include "nsIParserService.h"
    1: #include "nsContentCreatorFunctions.h"
    1: 
    1: #include "nsIScriptContext.h"
    1: #include "nsBindingManager.h"
    1: #include "nsIDOMHTMLDocument.h"
    1: #include "nsIDOMHTMLFormElement.h"
    1: #include "nsIRequest.h"
    1: #include "nsILink.h"
38871: #include "nsFileDataProtocolHandler.h"
    1: 
    1: #include "nsICharsetAlias.h"
    1: #include "nsIParser.h"
    1: #include "nsIContentSink.h"
    1: 
    1: #include "nsDateTimeFormatCID.h"
    1: #include "nsIDateTimeFormat.h"
    1: #include "nsEventDispatcher.h"
   62: #include "nsMutationEvent.h"
    1: #include "nsIDOMXPathEvaluator.h"
    1: #include "nsDOMCID.h"
    1: 
29420: #include "jsapi.h"
    1: #include "nsIJSContextStack.h"
    1: #include "nsIXPConnect.h"
    1: #include "nsCycleCollector.h"
 1353: #include "nsCCUncollectableMarker.h"
 2324: #include "nsIContentPolicy.h"
20078: #include "nsContentPolicyUtils.h"
20078: #include "nsICategoryManager.h"
20078: #include "nsIDocumentLoaderFactory.h"
20078: #include "nsIContentViewer.h"
20078: #include "nsIXMLContentSink.h"
20078: #include "nsContentErrors.h"
20078: #include "nsIXULDocument.h"
20078: #include "nsIPrompt.h"
21811: #include "nsIPropertyBag2.h"
29539: #include "nsIDOMPageTransitionEvent.h"
12256: #include "nsFrameLoader.h"
42357: #include "nsEscape.h"
34389: #ifdef MOZ_MEDIA
34207: #include "nsHTMLMediaElement.h"
34389: #endif // MOZ_MEDIA
12256: 
14228: #include "mozAutoDocUpdate.h"
41629: #include "nsGlobalWindow.h"
61406: #include "mozilla/dom/indexedDB/IndexedDatabaseManager.h"
72298: #include "nsDOMNavigationTiming.h"
14228: 
23697: #ifdef MOZ_SMIL
23697: #include "nsSMILAnimationController.h"
23697: #include "imgIContainer.h"
25961: #include "nsSVGUtils.h"
23697: #endif // MOZ_SMIL
23697: 
50698: #include "nsRefreshDriver.h"
50698: 
37418: // FOR CSP (autogenerated by xpidl)
37418: #include "nsIContentSecurityPolicy.h"
47342: #include "nsCSPService.h"
42984: #include "nsHTMLStyleSheet.h"
42984: #include "nsHTMLCSSStyleSheet.h"
37418: 
38488: #include "mozilla/dom/Link.h"
52011: #include "nsIHTMLDocument.h"
62607: #include "nsXULAppAPI.h"
68879: #include "nsDOMTouchEvent.h"
52011: 
70840: #include "mozilla/Preferences.h"
70840: 
70840: using namespace mozilla;
38488: using namespace mozilla::dom;
38488: 
57140: typedef nsTArray<Link*> LinkArray;
57140: 
38488: 
    1: #ifdef PR_LOGGING
    1: static PRLogModuleInfo* gDocumentLeakPRLog;
37418: static PRLogModuleInfo* gCspPRLog;
    1: #endif
    1: 
69024: #define NAME_NOT_VALID ((nsSimpleContentList*)1)
15474: 
15474: nsIdentifierMapEntry::~nsIdentifierMapEntry()
15474: {
15474: }
15474: 
15474: void
15474: nsIdentifierMapEntry::Traverse(nsCycleCollectionTraversalCallback* aCallback)
15474: {
18993:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*aCallback,
18993:                                      "mIdentifierMap mNameContentList");
19130:   aCallback->NoteXPCOMChild(static_cast<nsIDOMNodeList*>(mNameContentList));
18993: 
18993:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*aCallback, "mIdentifierMap mDocAllList");
15474:   aCallback->NoteXPCOMChild(static_cast<nsIDOMNodeList*>(mDocAllList));
33810: 
50428:   if (mImageElement) {
50428:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*aCallback,
50428:                                        "mIdentifierMap mImageElement element");
50428:     nsIContent* imageElement = mImageElement;
50428:     aCallback->NoteXPCOMChild(imageElement);
50428:   }
15474: }
15474: 
50428: PRBool
50428: nsIdentifierMapEntry::IsEmpty()
50428: {
50428:   return mIdContentList.Count() == 0 && !mNameContentList &&
50428:          !mChangeCallbacks && !mImageElement;
50428: }
50428: 
41635: Element*
41635: nsIdentifierMapEntry::GetIdElement()
41635: {
41635:   return static_cast<Element*>(mIdContentList.SafeElementAt(0));
15474: }
15474: 
50428: Element*
50428: nsIdentifierMapEntry::GetImageIdElement()
50428: {
50428:   return mImageElement ? mImageElement.get() : GetIdElement();
50428: }
50428: 
15475: void
15475: nsIdentifierMapEntry::AppendAllIdContent(nsCOMArray<nsIContent>* aElements)
15475: {
15475:   for (PRInt32 i = 0; i < mIdContentList.Count(); ++i) {
41635:     aElements->AppendObject(static_cast<Element*>(mIdContentList[i]));
15475:   }
15475: }
15475: 
15515: void
15515: nsIdentifierMapEntry::AddContentChangeCallback(nsIDocument::IDTargetObserver aCallback,
50428:                                                void* aData, PRBool aForImage)
15515: {
15515:   if (!mChangeCallbacks) {
15515:     mChangeCallbacks = new nsTHashtable<ChangeCallbackEntry>;
15515:     if (!mChangeCallbacks)
15515:       return;
15515:     mChangeCallbacks->Init();
15515:   }
15515: 
50428:   ChangeCallback cc = { aCallback, aData, aForImage };
15515:   mChangeCallbacks->PutEntry(cc);
15515: }
15515: 
15515: void
15515: nsIdentifierMapEntry::RemoveContentChangeCallback(nsIDocument::IDTargetObserver aCallback,
50428:                                                   void* aData, PRBool aForImage)
15515: {
15515:   if (!mChangeCallbacks)
15515:     return;
50428:   ChangeCallback cc = { aCallback, aData, aForImage };
15515:   mChangeCallbacks->RemoveEntry(cc);
15515:   if (mChangeCallbacks->Count() == 0) {
15515:     mChangeCallbacks = nsnull;
15515:   }
15515: }
15515: 
15515: struct FireChangeArgs {
41635:   Element* mFrom;
41635:   Element* mTo;
50428:   PRBool mImageOnly;
50428:   PRBool mHaveImageOverride;
15515: };
15515: 
20261: static PLDHashOperator
15515: FireChangeEnumerator(nsIdentifierMapEntry::ChangeCallbackEntry *aEntry, void *aArg)
15515: {
15515:   FireChangeArgs* args = static_cast<FireChangeArgs*>(aArg);
50428:   // Don't fire image changes for non-image observers, and don't fire element
50428:   // changes for image observers when an image override is active.
50428:   if (aEntry->mKey.mForImage ? (args->mHaveImageOverride && !args->mImageOnly) :
50428:                                args->mImageOnly)
50428:     return PL_DHASH_NEXT;
15515:   return aEntry->mKey.mCallback(args->mFrom, args->mTo, aEntry->mKey.mData)
15515:       ? PL_DHASH_NEXT : PL_DHASH_REMOVE;
15515: }
15515: 
15515: void
41635: nsIdentifierMapEntry::FireChangeCallbacks(Element* aOldElement,
50428:                                           Element* aNewElement,
50428:                                           PRBool aImageOnly)
15515: {
15515:   if (!mChangeCallbacks)
15515:     return;
15515: 
50428:   FireChangeArgs args = { aOldElement, aNewElement, aImageOnly, !!mImageElement };
15515:   mChangeCallbacks->EnumerateEntries(FireChangeEnumerator, &args);
15515: }
15515: 
15474: PRBool
41635: nsIdentifierMapEntry::AddIdElement(Element* aElement)
41635: {
41635:   NS_PRECONDITION(aElement, "Must have element");
15474:   NS_PRECONDITION(mIdContentList.IndexOf(nsnull) < 0,
15474:                   "Why is null in our list?");
26475: 
26475: #ifdef DEBUG
41635:   Element* currentElement =
41635:     static_cast<Element*>(mIdContentList.SafeElementAt(0));
26475: #endif
15474: 
15474:   // Common case
15474:   if (mIdContentList.Count() == 0) {
41635:     if (!mIdContentList.AppendElement(aElement))
15515:       return PR_FALSE;
41635:     NS_ASSERTION(currentElement == nsnull, "How did that happen?");
41635:     FireChangeCallbacks(nsnull, aElement);
15515:     return PR_TRUE;
15474:   }
15474: 
26475:   // We seem to have multiple content nodes for the same id, or XUL is messing
26475:   // with us.  Search for the right place to insert the content.
15474:   PRInt32 start = 0;
15474:   PRInt32 end = mIdContentList.Count();
15474:   do {
15474:     NS_ASSERTION(start < end, "Bogus start/end");
15474:     
15474:     PRInt32 cur = (start + end) / 2;
15474:     NS_ASSERTION(cur >= start && cur < end, "What happened here?");
15474: 
41635:     Element* curElement = static_cast<Element*>(mIdContentList[cur]);
41635:     if (curElement == aElement) {
15474:       // Already in the list, so already in the right spot.  Get out of here.
26475:       // XXXbz this only happens because XUL does all sorts of random
26475:       // UpdateIdTableEntry calls.  Hate, hate, hate!
15474:       return PR_TRUE;
15474:     }
15474: 
41635:     if (nsContentUtils::PositionIsBefore(aElement, curElement)) {
15474:       end = cur;
15474:     } else {
15474:       start = cur + 1;
15474:     }
15474:   } while (start != end);
15474: 
41635:   if (!mIdContentList.InsertElementAt(aElement, start))
15515:     return PR_FALSE;
51858: 
15515:   if (start == 0) {
41635:     Element* oldElement =
41635:       static_cast<Element*>(mIdContentList.SafeElementAt(1));
41635:     NS_ASSERTION(currentElement == oldElement, "How did that happen?");
41635:     FireChangeCallbacks(oldElement, aElement);
15515:   }
15515:   return PR_TRUE;
15474: }
15474: 
50428: void
41635: nsIdentifierMapEntry::RemoveIdElement(Element* aElement)
15474: {
51858:   NS_PRECONDITION(aElement, "Missing element");
51858: 
15515:   // This should only be called while the document is in an update.
15515:   // Assertions near the call to this method guarantee this.
15515: 
51858:   // This could fire in OOM situations
51858:   // Only assert this in HTML documents for now as XUL does all sorts of weird
51858:   // crap.
51858:   NS_ASSERTION(!aElement->GetOwnerDoc() ||
51858:                !aElement->GetOwnerDoc()->IsHTML() ||
51858:                mIdContentList.IndexOf(aElement) >= 0,
51858:                "Removing id entry that doesn't exist");
51858: 
15474:   // XXXbz should this ever Compact() I guess when all the content is gone
15474:   // we'll just get cleaned up in the natural order of things...
41635:   Element* currentElement =
41635:     static_cast<Element*>(mIdContentList.SafeElementAt(0));
51858:   mIdContentList.RemoveElement(aElement);
41635:   if (currentElement == aElement) {
41635:     FireChangeCallbacks(currentElement,
41635:                         static_cast<Element*>(mIdContentList.SafeElementAt(0)));
15515:   }
50428: }
50428: 
50428: void
50428: nsIdentifierMapEntry::SetImageElement(Element* aElement)
50428: {
50428:   Element* oldElement = GetImageIdElement();
50428:   mImageElement = aElement;
50428:   Element* newElement = GetImageIdElement();
50428:   if (oldElement != newElement) {
50428:     FireChangeCallbacks(oldElement, newElement, PR_TRUE);
50428:   }
15474: }
15474: 
15474: void
69024: nsIdentifierMapEntry::AddNameElement(nsIDocument* aDocument, Element* aElement)
15474: {
68823:   if (!mNameContentList) {
69024:     mNameContentList = new nsSimpleContentList(aDocument);
68823:   }
68823: 
41635:   mNameContentList->AppendElement(aElement);
15474: }
15474: 
15474: void
41635: nsIdentifierMapEntry::RemoveNameElement(Element* aElement)
15474: {
68823:   NS_ASSERTION(mNameContentList &&
68823:                mNameContentList->IndexOf(aElement, PR_FALSE) >= 0,
68823:                "Attmpting to remove named element that doesn't exist");
41635:   mNameContentList->RemoveElement(aElement);
15474: }
15474: 
    1: // Helper structs for the content->subdoc map
    1: 
    1: class SubDocMapEntry : public PLDHashEntryHdr
    1: {
    1: public:
    1:   // Both of these are strong references
    1:   nsIContent *mKey; // must be first, to look like PLDHashEntryStub
    1:   nsIDocument *mSubDocument;
    1: };
    1: 
    1: struct FindContentData
    1: {
    1:   FindContentData(nsIDocument *aSubDoc)
    1:     : mSubDocument(aSubDoc), mResult(nsnull)
    1:   {
    1:   }
    1: 
    1:   nsISupports *mSubDocument;
    1:   nsIContent *mResult;
    1: };
    1: 
    1: 
    1: /**
    1:  * A struct that holds all the information about a radio group.
    1:  */
    1: struct nsRadioGroupStruct
    1: {
63105:   nsRadioGroupStruct()
63105:     : mRequiredRadioCount(0)
63107:     , mGroupSuffersFromValueMissing(false)
63105:   {}
63105: 
    1:   /**
    1:    * A strong pointer to the currently selected radio button.
    1:    */
    1:   nsCOMPtr<nsIDOMHTMLInputElement> mSelectedRadioButton;
 6365:   nsCOMArray<nsIFormControl> mRadioButtons;
63105:   PRUint32 mRequiredRadioCount;
63107:   bool mGroupSuffersFromValueMissing;
    1: };
    1: 
    1: 
    1: nsDOMStyleSheetList::nsDOMStyleSheetList(nsIDocument *aDocument)
    1: {
    1:   mLength = -1;
    1:   // Not reference counted to avoid circular references.
    1:   // The document will tell us when its going away.
    1:   mDocument = aDocument;
    1:   mDocument->AddObserver(this);
    1: }
    1: 
    1: nsDOMStyleSheetList::~nsDOMStyleSheetList()
    1: {
    1:   if (mDocument) {
    1:     mDocument->RemoveObserver(this);
    1:   }
    1: }
    1: 
40490: DOMCI_DATA(StyleSheetList, nsDOMStyleSheetList)
40490: 
    1: // XXX couldn't we use the GetIIDs method from CSSStyleSheetList here?
    1: // QueryInterface implementation for nsDOMStyleSheetList
 9123: NS_INTERFACE_TABLE_HEAD(nsDOMStyleSheetList)
 9123:   NS_INTERFACE_TABLE3(nsDOMStyleSheetList,
 9123:                       nsIDOMStyleSheetList,
 9123:                       nsIDocumentObserver,
 9123:                       nsIMutationObserver)
 9123:   NS_INTERFACE_TABLE_TO_MAP_SEGUE
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(StyleSheetList)
    1: NS_INTERFACE_MAP_END
    1: 
    1: 
    1: NS_IMPL_ADDREF(nsDOMStyleSheetList)
    1: NS_IMPL_RELEASE(nsDOMStyleSheetList)
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsDOMStyleSheetList::GetLength(PRUint32* aLength)
    1: {
    1:   if (mDocument) {
    1:     // XXX Find the number and then cache it. We'll use the
    1:     // observer notification to figure out if new ones have
    1:     // been added or removed.
    1:     if (-1 == mLength) {
    1:       mLength = mDocument->GetNumberOfStyleSheets();
    1: 
    1: #ifdef DEBUG
    1:       PRInt32 i;
    1:       for (i = 0; i < mLength; i++) {
    1:         nsIStyleSheet *sheet = mDocument->GetStyleSheetAt(i);
    1:         nsCOMPtr<nsIDOMStyleSheet> domss(do_QueryInterface(sheet));
    1:         NS_ASSERTION(domss, "All \"normal\" sheets implement nsIDOMStyleSheet");
    1:       }
    1: #endif
    1:     }
    1:     *aLength = mLength;
    1:   }
    1:   else {
    1:     *aLength = 0;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
20752: nsIStyleSheet*
20752: nsDOMStyleSheetList::GetItemAt(PRUint32 aIndex)
20752: {
20752:   if (!mDocument || aIndex >= (PRUint32)mDocument->GetNumberOfStyleSheets()) {
20752:     return nsnull;
20752:   }
20752: 
    1:   nsIStyleSheet *sheet = mDocument->GetStyleSheetAt(aIndex);
    1:   NS_ASSERTION(sheet, "Must have a sheet");
20752: 
20752:   return sheet;
20752: }
20752: 
20752: NS_IMETHODIMP
20752: nsDOMStyleSheetList::Item(PRUint32 aIndex, nsIDOMStyleSheet** aReturn)
20752: {
20752:   nsIStyleSheet *sheet = GetItemAt(aIndex);
20752:   if (!sheet) {
20752:       *aReturn = nsnull;
20752: 
20752:       return NS_OK;
20752:   }
20752: 
    1:   return CallQueryInterface(sheet, aReturn);
    1: }
    1: 
    1: void
    1: nsDOMStyleSheetList::NodeWillBeDestroyed(const nsINode *aNode)
    1: {
    1:   mDocument = nsnull;
    1: }
    1: 
    1: void
    1: nsDOMStyleSheetList::StyleSheetAdded(nsIDocument *aDocument,
    1:                                      nsIStyleSheet* aStyleSheet,
    1:                                      PRBool aDocumentSheet)
    1: {
    1:   if (aDocumentSheet && -1 != mLength) {
    1:     nsCOMPtr<nsIDOMStyleSheet> domss(do_QueryInterface(aStyleSheet));
    1:     if (domss) {
    1:       mLength++;
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsDOMStyleSheetList::StyleSheetRemoved(nsIDocument *aDocument,
    1:                                        nsIStyleSheet* aStyleSheet,
    1:                                        PRBool aDocumentSheet)
    1: {
    1:   if (aDocumentSheet && -1 != mLength) {
    1:     nsCOMPtr<nsIDOMStyleSheet> domss(do_QueryInterface(aStyleSheet));
    1:     if (domss) {
    1:       mLength--;
    1:     }
    1:   }
    1: }
    1: 
    1: // nsOnloadBlocker implementation
    1: NS_IMPL_ISUPPORTS1(nsOnloadBlocker, nsIRequest)
    1: 
    1: NS_IMETHODIMP
    1: nsOnloadBlocker::GetName(nsACString &aResult)
    1: { 
    1:   aResult.AssignLiteral("about:document-onload-blocker");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsOnloadBlocker::IsPending(PRBool *_retval)
    1: {
    1:   *_retval = PR_TRUE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsOnloadBlocker::GetStatus(nsresult *status)
    1: {
    1:   *status = NS_OK;
    1:   return NS_OK;
    1: } 
    1: 
    1: NS_IMETHODIMP
    1: nsOnloadBlocker::Cancel(nsresult status)
    1: {
    1:   return NS_OK;
    1: }
    1: NS_IMETHODIMP
    1: nsOnloadBlocker::Suspend(void)
    1: {
    1:   return NS_OK;
    1: }
    1: NS_IMETHODIMP
    1: nsOnloadBlocker::Resume(void)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsOnloadBlocker::GetLoadGroup(nsILoadGroup * *aLoadGroup)
    1: {
    1:   *aLoadGroup = nsnull;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsOnloadBlocker::SetLoadGroup(nsILoadGroup * aLoadGroup)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsOnloadBlocker::GetLoadFlags(nsLoadFlags *aLoadFlags)
    1: {
    1:   *aLoadFlags = nsIRequest::LOAD_NORMAL;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsOnloadBlocker::SetLoadFlags(nsLoadFlags aLoadFlags)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: // ==================================================================
20078: 
20078: nsExternalResourceMap::nsExternalResourceMap()
20078:   : mHaveShutDown(PR_FALSE)
20078: {
20078:   mMap.Init();
20078:   mPendingLoads.Init();
20078: }
20078: 
20078: nsIDocument*
20078: nsExternalResourceMap::RequestResource(nsIURI* aURI,
20078:                                        nsINode* aRequestingNode,
20078:                                        nsDocument* aDisplayDocument,
20078:                                        ExternalResourceLoad** aPendingLoad)
20078: {
20078:   // If we ever start allowing non-same-origin loads here, we might need to do
20078:   // something interesting with aRequestingPrincipal even for the hashtable
20078:   // gets.
20078:   NS_PRECONDITION(aURI, "Must have a URI");
20078:   NS_PRECONDITION(aRequestingNode, "Must have a node");
20078:   *aPendingLoad = nsnull;
20078:   if (mHaveShutDown) {
20078:     return nsnull;
20078:   }
20078:   
20078:   // First, make sure we strip the ref from aURI.
20078:   nsCOMPtr<nsIURI> clone;
70215:   nsresult rv = aURI->CloneIgnoringRef(getter_AddRefs(clone));
70215:   if (NS_FAILED(rv) || !clone) {
20078:     return nsnull;
20078:   }
20078:   
20078:   ExternalResource* resource;
20078:   mMap.Get(clone, &resource);
20078:   if (resource) {
20078:     return resource->mDocument;
20078:   }
20078: 
20078:   nsRefPtr<PendingLoad> load;
20078:   mPendingLoads.Get(clone, getter_AddRefs(load));
20078:   if (load) {
70215:     load.forget(aPendingLoad);
20078:     return nsnull;
20078:   }
20078: 
20078:   load = new PendingLoad(aDisplayDocument);
20078: 
20078:   if (!mPendingLoads.Put(clone, load)) {
20078:     return nsnull;
20078:   }
20078: 
20078:   if (NS_FAILED(load->StartLoad(clone, aRequestingNode))) {
20078:     // Make sure we don't thrash things by trying this load again, since
20078:     // chances are it failed for good reasons (security check, etc).
20078:     AddExternalResource(clone, nsnull, nsnull, aDisplayDocument);
20078:   } else {
70215:     load.forget(aPendingLoad);
20078:   }
20078: 
20078:   return nsnull;
20078: }
20078: 
20078: struct
20078: nsExternalResourceEnumArgs
20078: {
20078:   nsIDocument::nsSubDocEnumFunc callback;
20078:   void *data;
20078: };
20078: 
20705: static PLDHashOperator
20078: ExternalResourceEnumerator(nsIURI* aKey,
20078:                            nsExternalResourceMap::ExternalResource* aData,
20078:                            void* aClosure)
20078: {
20078:   nsExternalResourceEnumArgs* args =
20078:     static_cast<nsExternalResourceEnumArgs*>(aClosure);
20463:   PRBool next =
20463:     aData->mDocument ? args->callback(aData->mDocument, args->data) : PR_TRUE;
20078:   return next ? PL_DHASH_NEXT : PL_DHASH_STOP;
20078: }
20078: 
20078: void
20078: nsExternalResourceMap::EnumerateResources(nsIDocument::nsSubDocEnumFunc aCallback,
20078:                                           void* aData)
20078: {
20078:   nsExternalResourceEnumArgs args = { aCallback, aData };
20078:   mMap.EnumerateRead(ExternalResourceEnumerator, &args);
20078: }
20078: 
20705: static PLDHashOperator
20078: ExternalResourceTraverser(nsIURI* aKey,
20078:                           nsExternalResourceMap::ExternalResource* aData,
20078:                           void* aClosure)
20078: {
20078:   nsCycleCollectionTraversalCallback *cb = 
20078:     static_cast<nsCycleCollectionTraversalCallback*>(aClosure);
20078: 
20078:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb,
20078:                                      "mExternalResourceMap.mMap entry"
20078:                                      "->mDocument");
20078:   cb->NoteXPCOMChild(aData->mDocument);
20078: 
20078:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb,
20078:                                      "mExternalResourceMap.mMap entry"
20078:                                      "->mViewer");
20078:   cb->NoteXPCOMChild(aData->mViewer);
20078: 
20078:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb,
20078:                                      "mExternalResourceMap.mMap entry"
20078:                                      "->mLoadGroup");
20078:   cb->NoteXPCOMChild(aData->mLoadGroup);
20078: 
20078:   return PL_DHASH_NEXT;
20078: }
20078: 
20078: void
20078: nsExternalResourceMap::Traverse(nsCycleCollectionTraversalCallback* aCallback) const
20078: {
20078:   // mPendingLoads will get cleared out as the requests complete, so
20078:   // no need to worry about those here.
20078:   mMap.EnumerateRead(ExternalResourceTraverser, aCallback);
20078: }
20078: 
49570: static PLDHashOperator
49570: ExternalResourceHider(nsIURI* aKey,
49570:                       nsExternalResourceMap::ExternalResource* aData,
49570:                       void* aClosure)
49570: {
50640:   if (aData->mViewer) {
49570:     aData->mViewer->Hide();
50640:   }
49570:   return PL_DHASH_NEXT;
49570: }
49570: 
49570: void
49570: nsExternalResourceMap::HideViewers()
49570: {
49570:   mMap.EnumerateRead(ExternalResourceHider, nsnull);
49570: }
49570: 
49570: static PLDHashOperator
49570: ExternalResourceShower(nsIURI* aKey,
49570:                        nsExternalResourceMap::ExternalResource* aData,
49570:                        void* aClosure)
49570: {
51653:   if (aData->mViewer) {
49570:     aData->mViewer->Show();
51653:   }
49570:   return PL_DHASH_NEXT;
49570: }
49570: 
49570: void
49570: nsExternalResourceMap::ShowViewers()
49570: {
49570:   mMap.EnumerateRead(ExternalResourceShower, nsnull);
49570: }
49570: 
60736: void
60736: TransferZoomLevels(nsIDocument* aFromDoc,
60736:                    nsIDocument* aToDoc)
60736: {
60736:   NS_ABORT_IF_FALSE(aFromDoc && aToDoc,
60736:                     "transferring zoom levels from/to null doc");
60736: 
60736:   nsIPresShell* fromShell = aFromDoc->GetShell();
60736:   if (!fromShell)
60736:     return;
60736: 
60736:   nsPresContext* fromCtxt = fromShell->GetPresContext();
60736:   if (!fromCtxt)
60736:     return;
60736: 
60736:   nsIPresShell* toShell = aToDoc->GetShell();
60736:   if (!toShell)
60736:     return;
60736: 
60736:   nsPresContext* toCtxt = toShell->GetPresContext();
60736:   if (!toCtxt)
60736:     return;
60736: 
60736:   toCtxt->SetFullZoom(fromCtxt->GetFullZoom());
63383:   toCtxt->SetMinFontSize(fromCtxt->MinFontSize());
60736:   toCtxt->SetTextZoom(fromCtxt->TextZoom());
60736: }
60736: 
62341: void
62341: TransferShowingState(nsIDocument* aFromDoc, nsIDocument* aToDoc)
62341: {
62341:   NS_ABORT_IF_FALSE(aFromDoc && aToDoc,
62341:                     "transferring showing state from/to null doc");
62341: 
62341:   if (aFromDoc->IsShowing()) {
62341:     aToDoc->OnPageShow(PR_TRUE, nsnull);
62341:   }
62341: }
62341: 
20078: nsresult
20078: nsExternalResourceMap::AddExternalResource(nsIURI* aURI,
20078:                                            nsIDocumentViewer* aViewer,
20078:                                            nsILoadGroup* aLoadGroup,
20078:                                            nsIDocument* aDisplayDocument)
20078: {
20078:   NS_PRECONDITION(aURI, "Unexpected call");
20078:   NS_PRECONDITION((aViewer && aLoadGroup) || (!aViewer && !aLoadGroup),
20078:                   "Must have both or neither");
20078:   
20078:   nsRefPtr<PendingLoad> load;
20078:   mPendingLoads.Get(aURI, getter_AddRefs(load));
20078:   mPendingLoads.Remove(aURI);
20078: 
20078:   nsresult rv = NS_OK;
20078:   
20078:   nsCOMPtr<nsIDocument> doc;
20078:   if (aViewer) {
37433:     doc = aViewer->GetDocument();
20078:     NS_ASSERTION(doc, "Must have a document");
20078: 
20078:     nsCOMPtr<nsIXULDocument> xulDoc = do_QueryInterface(doc);
20078:     if (xulDoc) {
20078:       // We don't handle XUL stuff here yet.
20078:       rv = NS_ERROR_NOT_AVAILABLE;
20078:     } else {
20078:       doc->SetDisplayDocument(aDisplayDocument);
20078: 
49570:       // Make sure that hiding our viewer will tear down its presentation.
49570:       aViewer->SetSticky(PR_FALSE);
49570: 
23738:       rv = aViewer->Init(nsnull, nsIntRect(0, 0, 0, 0));
20078:       if (NS_SUCCEEDED(rv)) {
20078:         rv = aViewer->Open(nsnull, nsnull);
20078:       }
20078:     }
20078:     
20078:     if (NS_FAILED(rv)) {
20078:       doc = nsnull;
20078:       aViewer = nsnull;
20078:       aLoadGroup = nsnull;
20078:     }
20078:   }
20078: 
20078:   ExternalResource* newResource = new ExternalResource();
20078:   if (newResource && !mMap.Put(aURI, newResource)) {
20078:     delete newResource;
20078:     newResource = nsnull;
20078:     if (NS_SUCCEEDED(rv)) {
20078:       rv = NS_ERROR_OUT_OF_MEMORY;
20078:     }
20078:   }
20078: 
20078:   if (newResource) {
20078:     newResource->mDocument = doc;
20078:     newResource->mViewer = aViewer;
20078:     newResource->mLoadGroup = aLoadGroup;
60736:     if (doc) {
60736:       TransferZoomLevels(aDisplayDocument, doc);
62341:       TransferShowingState(aDisplayDocument, doc);
60736:     }
20078:   }
20078: 
20078:   const nsTArray< nsCOMPtr<nsIObserver> > & obs = load->Observers();
20078:   for (PRUint32 i = 0; i < obs.Length(); ++i) {
20078:     obs[i]->Observe(doc, "external-resource-document-created", nsnull);
20078:   }
20078: 
20078:   return rv;
20078: }
20078: 
20078: NS_IMPL_ISUPPORTS2(nsExternalResourceMap::PendingLoad,
20078:                    nsIStreamListener,
20078:                    nsIRequestObserver)
20078: 
20078: NS_IMETHODIMP
20078: nsExternalResourceMap::PendingLoad::OnStartRequest(nsIRequest *aRequest,
20078:                                                    nsISupports *aContext)
20078: {
20078:   nsExternalResourceMap& map = mDisplayDocument->ExternalResourceMap();
20078:   if (map.HaveShutDown()) {
20078:     return NS_BINDING_ABORTED;
20078:   }
20078: 
20078:   nsCOMPtr<nsIDocumentViewer> viewer;
20078:   nsCOMPtr<nsILoadGroup> loadGroup;
20078:   nsresult rv = SetupViewer(aRequest, getter_AddRefs(viewer),
20078:                             getter_AddRefs(loadGroup));
20078: 
20078:   // Make sure to do this no matter what
20078:   nsresult rv2 = map.AddExternalResource(mURI, viewer, loadGroup,
20078:                                          mDisplayDocument);
20078:   if (NS_FAILED(rv)) {
20078:     return rv;
20078:   }
20078:   if (NS_FAILED(rv2)) {
20078:     mTargetListener = nsnull;
20078:     return rv2;
20078:   }
20078:   
20078:   return mTargetListener->OnStartRequest(aRequest, aContext);
20078: }
20078: 
20078: nsresult
20078: nsExternalResourceMap::PendingLoad::SetupViewer(nsIRequest* aRequest,
20078:                                                 nsIDocumentViewer** aViewer,
20078:                                                 nsILoadGroup** aLoadGroup)
20078: {
20078:   NS_PRECONDITION(!mTargetListener, "Unexpected call to OnStartRequest");
20078:   *aViewer = nsnull;
20078:   *aLoadGroup = nsnull;
20078:   
20078:   nsCOMPtr<nsIChannel> chan(do_QueryInterface(aRequest));
20078:   NS_ENSURE_TRUE(chan, NS_ERROR_UNEXPECTED);
20078: 
20078:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(aRequest));
20078:   if (httpChannel) {
20078:     PRBool requestSucceeded;
20078:     if (NS_FAILED(httpChannel->GetRequestSucceeded(&requestSucceeded)) ||
20078:         !requestSucceeded) {
20078:       // Bail out on this load, since it looks like we have an HTTP error page
20078:       return NS_BINDING_ABORTED;
20078:     }
20078:   }
20078:  
20078:   nsCAutoString type;
20078:   chan->GetContentType(type);
20078: 
20078:   nsCOMPtr<nsILoadGroup> loadGroup;
20078:   chan->GetLoadGroup(getter_AddRefs(loadGroup));
20078: 
20078:   // Give this document its own loadgroup
20078:   nsCOMPtr<nsILoadGroup> newLoadGroup =
20078:         do_CreateInstance(NS_LOADGROUP_CONTRACTID);
20078:   NS_ENSURE_TRUE(newLoadGroup, NS_ERROR_OUT_OF_MEMORY);
20078:   newLoadGroup->SetLoadGroup(loadGroup);
20078: 
20078:   nsCOMPtr<nsIInterfaceRequestor> callbacks;
20078:   loadGroup->GetNotificationCallbacks(getter_AddRefs(callbacks));
20078: 
20078:   nsCOMPtr<nsIInterfaceRequestor> newCallbacks =
20078:     new LoadgroupCallbacks(callbacks);
20078:   newLoadGroup->SetNotificationCallbacks(newCallbacks);
20078: 
20078:   // This is some serious hackery cribbed from docshell
20078:   nsCOMPtr<nsICategoryManager> catMan =
20078:     do_GetService(NS_CATEGORYMANAGER_CONTRACTID);
20078:   NS_ENSURE_TRUE(catMan, NS_ERROR_NOT_AVAILABLE);
20078:   nsXPIDLCString contractId;
20078:   nsresult rv = catMan->GetCategoryEntry("Gecko-Content-Viewers", type.get(),
20078:                                          getter_Copies(contractId));
20078:   NS_ENSURE_SUCCESS(rv, rv);
20078:   nsCOMPtr<nsIDocumentLoaderFactory> docLoaderFactory =
20078:     do_GetService(contractId);
20078:   NS_ENSURE_TRUE(docLoaderFactory, NS_ERROR_NOT_AVAILABLE);
20078: 
20078:   nsCOMPtr<nsIContentViewer> viewer;
20078:   nsCOMPtr<nsIStreamListener> listener;
20078:   rv = docLoaderFactory->CreateInstance("external-resource", chan, newLoadGroup,
20078:                                         type.get(), nsnull, nsnull,
20078:                                         getter_AddRefs(listener),
20078:                                         getter_AddRefs(viewer));
20078:   NS_ENSURE_SUCCESS(rv, rv);
20078: 
20078:   nsCOMPtr<nsIDocumentViewer> docViewer = do_QueryInterface(viewer);
20078:   NS_ENSURE_TRUE(docViewer, NS_ERROR_UNEXPECTED);
20078: 
20078:   nsCOMPtr<nsIParser> parser = do_QueryInterface(listener);
20078:   if (!parser) {
20078:     /// We don't want to deal with the various fake documents yet
20078:     return NS_ERROR_NOT_IMPLEMENTED;
20078:   }
20078: 
20078:   // We can't handle HTML and other weird things here yet.
20078:   nsIContentSink* sink = parser->GetContentSink();
20078:   nsCOMPtr<nsIXMLContentSink> xmlSink = do_QueryInterface(sink);
20078:   if (!xmlSink) {
20078:     return NS_ERROR_NOT_IMPLEMENTED;
20078:   }
20078: 
20078:   listener.swap(mTargetListener);
20078:   docViewer.swap(*aViewer);
20078:   newLoadGroup.swap(*aLoadGroup);
20078:   return NS_OK;
20078: }
20078: 
20078: NS_IMETHODIMP
20078: nsExternalResourceMap::PendingLoad::OnDataAvailable(nsIRequest* aRequest,
20078:                                                     nsISupports* aContext,
20078:                                                     nsIInputStream* aStream,
20078:                                                     PRUint32 aOffset,
20078:                                                     PRUint32 aCount)
20078: {
20078:   NS_PRECONDITION(mTargetListener, "Shouldn't be getting called!");
20078:   if (mDisplayDocument->ExternalResourceMap().HaveShutDown()) {
20078:     return NS_BINDING_ABORTED;
20078:   }
20078:   return mTargetListener->OnDataAvailable(aRequest, aContext, aStream, aOffset,
20078:                                           aCount);
20078: }
20078: 
20078: NS_IMETHODIMP
20078: nsExternalResourceMap::PendingLoad::OnStopRequest(nsIRequest* aRequest,
20078:                                                   nsISupports* aContext,
20078:                                                   nsresult aStatus)
20078: {
20078:   // mTargetListener might be null if SetupViewer or AddExternalResource failed
20078:   if (mTargetListener) {
20078:     nsCOMPtr<nsIStreamListener> listener;
20078:     mTargetListener.swap(listener);
20078:     return listener->OnStopRequest(aRequest, aContext, aStatus);
20078:   }
20078: 
20078:   return NS_OK;
20078: }
20078: 
20078: nsresult
20078: nsExternalResourceMap::PendingLoad::StartLoad(nsIURI* aURI,
20078:                                               nsINode* aRequestingNode)
20078: {
20078:   NS_PRECONDITION(aURI, "Must have a URI");
20078:   NS_PRECONDITION(aRequestingNode, "Must have a node");
20078: 
20078:   // Time to start a load.  First, the security checks.
20078: 
20078:   nsIPrincipal* requestingPrincipal = aRequestingNode->NodePrincipal();
20078: 
20078:   nsresult rv = nsContentUtils::GetSecurityManager()->
20078:     CheckLoadURIWithPrincipal(requestingPrincipal, aURI,
20078:                               nsIScriptSecurityManager::STANDARD);
20078:   NS_ENSURE_SUCCESS(rv, rv);
20078:   
20078:   rv = requestingPrincipal->CheckMayLoad(aURI, PR_TRUE);
20078:   NS_ENSURE_SUCCESS(rv, rv);
20078: 
20078:   PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
20078:   rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_OTHER,
20078:                                  aURI,
20078:                                  requestingPrincipal,
20078:                                  aRequestingNode,
20078:                                  EmptyCString(), //mime guess
20078:                                  nsnull,         //extra
20078:                                  &shouldLoad,
20078:                                  nsContentUtils::GetContentPolicy(),
20078:                                  nsContentUtils::GetSecurityManager());
20078:   if (NS_FAILED(rv)) return rv;
20078:   if (NS_CP_REJECTED(shouldLoad)) {
20078:     // Disallowed by content policy
20078:     return NS_ERROR_CONTENT_BLOCKED;
20078:   }
20078: 
20078:   nsIDocument* doc = aRequestingNode->GetOwnerDoc();
20078:   if (!doc) {
20078:     return NS_ERROR_NOT_AVAILABLE;
20078:   }
20078: 
21937:   nsCOMPtr<nsIInterfaceRequestor> req = nsContentUtils::GetSameOriginChecker();
21937:   NS_ENSURE_TRUE(req, NS_ERROR_OUT_OF_MEMORY);
21937: 
20078:   nsCOMPtr<nsILoadGroup> loadGroup = doc->GetDocumentLoadGroup();
20078:   nsCOMPtr<nsIChannel> channel;
21937:   rv = NS_NewChannel(getter_AddRefs(channel), aURI, nsnull, loadGroup, req);
20078:   NS_ENSURE_SUCCESS(rv, rv);
20078: 
20078:   mURI = aURI;
20078: 
20078:   return channel->AsyncOpen(this, nsnull);
20078: }
20078: 
20078: NS_IMPL_ISUPPORTS1(nsExternalResourceMap::LoadgroupCallbacks,
20078:                    nsIInterfaceRequestor)
20078: 
21877: #define IMPL_SHIM(_i) \
21877:   NS_IMPL_ISUPPORTS1(nsExternalResourceMap::LoadgroupCallbacks::_i##Shim, _i)
21877: 
21877: IMPL_SHIM(nsILoadContext)
21878: IMPL_SHIM(nsIProgressEventSink)
21878: IMPL_SHIM(nsIChannelEventSink)
21878: IMPL_SHIM(nsISecurityEventSink)
21878: IMPL_SHIM(nsIApplicationCacheContainer)
21877: 
21877: #undef IMPL_SHIM
21877: 
21877: #define IID_IS(_i) aIID.Equals(NS_GET_IID(_i))
21877: 
21877: #define TRY_SHIM(_i)                                                       \
21877:   PR_BEGIN_MACRO                                                           \
21877:     if (IID_IS(_i)) {                                                      \
21877:       nsCOMPtr<_i> real = do_GetInterface(mCallbacks);                     \
21877:       if (!real) {                                                         \
21877:         return NS_NOINTERFACE;                                             \
21877:       }                                                                    \
21877:       nsCOMPtr<_i> shim = new _i##Shim(this, real);                        \
21877:       if (!shim) {                                                         \
21877:         return NS_ERROR_OUT_OF_MEMORY;                                     \
21877:       }                                                                    \
21877:       *aSink = shim.forget().get();                                        \
21877:       return NS_OK;                                                        \
21877:     }                                                                      \
21877:   PR_END_MACRO
21877: 
20078: NS_IMETHODIMP
20078: nsExternalResourceMap::LoadgroupCallbacks::GetInterface(const nsIID & aIID,
20078:                                                         void **aSink)
20078: {
20078:   if (mCallbacks &&
46908:       (IID_IS(nsIPrompt) || IID_IS(nsIAuthPrompt) || IID_IS(nsIAuthPrompt2) ||
46908:        IID_IS(nsITabChild))) {
20078:     return mCallbacks->GetInterface(aIID, aSink);
20078:   }
21877: 
21877:   *aSink = nsnull;
21877: 
21877:   TRY_SHIM(nsILoadContext);
21877:   TRY_SHIM(nsIProgressEventSink);
21877:   TRY_SHIM(nsIChannelEventSink);
21877:   TRY_SHIM(nsISecurityEventSink);
21877:   TRY_SHIM(nsIApplicationCacheContainer);
21877:     
21877:   return NS_NOINTERFACE;
21877: }
21877: 
21877: #undef TRY_SHIM
20078: #undef IID_IS
20078: 
20078: nsExternalResourceMap::ExternalResource::~ExternalResource()
20078: {
20078:   if (mViewer) {
20078:     mViewer->Close(nsnull);
20078:     mViewer->Destroy();
20078:   }
20078: }
20078: 
20078: // ==================================================================
    1: // =
    1: // ==================================================================
    1: 
    1: // If we ever have an nsIDocumentObserver notification for stylesheet title
    1: // changes, we could make this inherit from nsDOMStringList instead of
    1: // reimplementing nsIDOMDOMStringList.
    1: class nsDOMStyleSheetSetList : public nsIDOMDOMStringList
    1:                           
    1: {
    1: public:
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   NS_DECL_NSIDOMDOMSTRINGLIST
    1: 
    1:   nsDOMStyleSheetSetList(nsIDocument* aDocument);
    1: 
    1:   void Disconnect()
    1:   {
    1:     mDocument = nsnull;
    1:   }
    1: 
    1: protected:
    1:   // Rebuild our list of style sets
23904:   nsresult GetSets(nsTArray<nsString>& aStyleSets);
    1:   
    1:   nsIDocument* mDocument;  // Our document; weak ref.  It'll let us know if it
    1:                            // dies.
    1: };
    1: 
    1: NS_IMPL_ADDREF(nsDOMStyleSheetSetList)
    1: NS_IMPL_RELEASE(nsDOMStyleSheetSetList)
21218: NS_INTERFACE_TABLE_HEAD(nsDOMStyleSheetSetList)
21218:   NS_OFFSET_AND_INTERFACE_TABLE_BEGIN(nsDOMStyleSheetSetList)
21218:     NS_INTERFACE_TABLE_ENTRY(nsDOMStyleSheetSetList, nsIDOMDOMStringList)
21218:   NS_OFFSET_AND_INTERFACE_TABLE_END
21218:   NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(DOMStringList)
    1: NS_INTERFACE_MAP_END
    1: 
    1: nsDOMStyleSheetSetList::nsDOMStyleSheetSetList(nsIDocument* aDocument)
    1:   : mDocument(aDocument)
    1: {
    1:   NS_ASSERTION(mDocument, "Must have document!");
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMStyleSheetSetList::Item(PRUint32 aIndex, nsAString& aResult)
    1: {
23904:   nsTArray<nsString> styleSets;
    1:   nsresult rv = GetSets(styleSets);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
23904:   if (aIndex >= styleSets.Length()) {
    1:     SetDOMStringToNull(aResult);
    1:   } else {
23904:     aResult = styleSets[aIndex];
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMStyleSheetSetList::GetLength(PRUint32 *aLength)
    1: {
23904:   nsTArray<nsString> styleSets;
    1:   nsresult rv = GetSets(styleSets);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
23904:   *aLength = styleSets.Length();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMStyleSheetSetList::Contains(const nsAString& aString, PRBool *aResult)
    1: {
23904:   nsTArray<nsString> styleSets;
    1:   nsresult rv = GetSets(styleSets);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
23904:   *aResult = styleSets.Contains(aString);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
23904: nsDOMStyleSheetSetList::GetSets(nsTArray<nsString>& aStyleSets)
    1: {
    1:   if (!mDocument) {
    1:     return NS_OK; // Spec says "no exceptions", and we have no style sets if we
    1:                   // have no document, for sure
    1:   }
    1:   
    1:   PRInt32 count = mDocument->GetNumberOfStyleSheets();
    1:   nsAutoString title;
    1:   nsAutoString temp;
    1:   for (PRInt32 index = 0; index < count; index++) {
    1:     nsIStyleSheet* sheet = mDocument->GetStyleSheetAt(index);
    1:     NS_ASSERTION(sheet, "Null sheet in sheet list!");
    1:     sheet->GetTitle(title);
23904:     if (!title.IsEmpty() && !aStyleSets.Contains(title) &&
23904:         !aStyleSets.AppendElement(title)) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // ==================================================================
    1: // =
    1: // ==================================================================
    1: 
48378: class nsDOMImplementation : public nsIDOMDOMImplementation
    1: {
    1: public:
 6475:   nsDOMImplementation(nsIScriptGlobalObject* aScriptObject,
 6475:                       nsIURI* aDocumentURI,
    1:                       nsIURI* aBaseURI,
    1:                       nsIPrincipal* aPrincipal);
    1:   virtual ~nsDOMImplementation();
    1: 
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   // nsIDOMDOMImplementation
    1:   NS_DECL_NSIDOMDOMIMPLEMENTATION
    1: 
    1: protected:
 6475:   nsWeakPtr mScriptObject;
    1:   nsCOMPtr<nsIURI> mDocumentURI;
    1:   nsCOMPtr<nsIURI> mBaseURI;
    1:   nsCOMPtr<nsIPrincipal> mPrincipal;
    1: };
    1: 
    1: 
    1: nsresult
    1: NS_NewDOMImplementation(nsIDOMDOMImplementation** aInstancePtrResult)
    1: {
 6475:   *aInstancePtrResult = new nsDOMImplementation(nsnull, nsnull, nsnull, nsnull);
    1:   if (!*aInstancePtrResult) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   NS_ADDREF(*aInstancePtrResult);
    1: 
    1:   return NS_OK;
    1: }
    1: 
 6475: nsDOMImplementation::nsDOMImplementation(nsIScriptGlobalObject* aScriptObject,
 6475:                                          nsIURI* aDocumentURI,
    1:                                          nsIURI* aBaseURI,
    1:                                          nsIPrincipal* aPrincipal)
 6475:   : mScriptObject(do_GetWeakReference(aScriptObject)),
 6475:     mDocumentURI(aDocumentURI),
    1:     mBaseURI(aBaseURI),
    1:     mPrincipal(aPrincipal)
    1: {
    1: }
    1: 
    1: nsDOMImplementation::~nsDOMImplementation()
    1: {
    1: }
    1: 
40490: DOMCI_DATA(DOMImplementation, nsDOMImplementation)
40490: 
    1: // QueryInterface implementation for nsDOMImplementation
    1: NS_INTERFACE_MAP_BEGIN(nsDOMImplementation)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMDOMImplementation)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMDOMImplementation)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(DOMImplementation)
    1: NS_INTERFACE_MAP_END
    1: 
    1: 
    1: NS_IMPL_ADDREF(nsDOMImplementation)
    1: NS_IMPL_RELEASE(nsDOMImplementation)
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsDOMImplementation::HasFeature(const nsAString& aFeature,
    1:                                 const nsAString& aVersion,
    1:                                 PRBool* aReturn)
    1: {
    1:   return nsGenericElement::InternalIsSupported(
 3233:            static_cast<nsIDOMDOMImplementation*>(this),
    1:            aFeature, aVersion, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMImplementation::CreateDocumentType(const nsAString& aQualifiedName,
    1:                                         const nsAString& aPublicId,
    1:                                         const nsAString& aSystemId,
    1:                                         nsIDOMDocumentType** aReturn)
    1: {
    1:   *aReturn = nsnull;
    1: 
    1:   nsresult rv = nsContentUtils::CheckQName(aQualifiedName);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIAtom> name = do_GetAtom(aQualifiedName);
    1:   NS_ENSURE_TRUE(name, NS_ERROR_OUT_OF_MEMORY);
    1: 
15348:   // Indicate that there is no internal subset (not just an empty one)
15348:   nsAutoString voidString;
15348:   voidString.SetIsVoid(PR_TRUE);
68470:   return NS_NewDOMDocumentType(aReturn, nsnull, mPrincipal, name, aPublicId,
68470:                                aSystemId, voidString);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMImplementation::CreateDocument(const nsAString& aNamespaceURI,
    1:                                     const nsAString& aQualifiedName,
    1:                                     nsIDOMDocumentType* aDoctype,
    1:                                     nsIDOMDocument** aReturn)
    1: {
    1:   *aReturn = nsnull;
    1: 
    1:   nsresult rv;
    1:   if (!aQualifiedName.IsEmpty()) {
    1:     nsIParserService *parserService = nsContentUtils::GetParserService();
    1:     NS_ENSURE_TRUE(parserService, NS_ERROR_FAILURE);
    1: 
    1:     const nsAFlatString& qName = PromiseFlatString(aQualifiedName);
    1:     const PRUnichar *colon;
    1:     rv = parserService->CheckQName(qName, PR_TRUE, &colon);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     if (colon &&
    1:         (DOMStringIsNull(aNamespaceURI) ||
    1:          (Substring(qName.get(), colon).EqualsLiteral("xml") &&
    1:           !aNamespaceURI.EqualsLiteral("http://www.w3.org/XML/1998/namespace")))) {
    1:       return NS_ERROR_DOM_NAMESPACE_ERR;
    1:     }
    1:   }
    1:   else if (DOMStringIsNull(aQualifiedName) &&
    1:            !DOMStringIsNull(aNamespaceURI)) {
    1:     return NS_ERROR_DOM_NAMESPACE_ERR;
    1:   }
    1: 
    1:   if (aDoctype) {
    1:     nsCOMPtr<nsIDOMDocument> owner;
    1:     aDoctype->GetOwnerDocument(getter_AddRefs(owner));
    1:     if (owner) {
    1:       return NS_ERROR_DOM_WRONG_DOCUMENT_ERR;
    1:     }
    1:   }
    1: 
 6475:   nsCOMPtr<nsIScriptGlobalObject> scriptHandlingObject =
 6475:     do_QueryReferent(mScriptObject);
 6475:   
54461:   NS_ENSURE_STATE(!mScriptObject || scriptHandlingObject);
54461: 
    1:   return nsContentUtils::CreateDocument(aNamespaceURI, aQualifiedName, aDoctype,
    1:                                         mDocumentURI, mBaseURI, mPrincipal,
 6475:                                         scriptHandlingObject, aReturn);
    1: }
    1: 
52011: NS_IMETHODIMP
52011: nsDOMImplementation::CreateHTMLDocument(const nsAString& aTitle,
52011:                                         nsIDOMDocument** aReturn)
52011: {
52011:   *aReturn = NULL;
52011: 
52011:   nsCOMPtr<nsIDOMDocumentType> doctype;
52011:   // Indicate that there is no internal subset (not just an empty one)
52011:   nsAutoString voidString;
52011:   voidString.SetIsVoid(true);
54461:   nsresult rv = NS_NewDOMDocumentType(getter_AddRefs(doctype),
52011:                                       NULL, // aNodeInfoManager
52011:                                       mPrincipal, // aPrincipal
52011:                                       nsGkAtoms::html, // aName
52011:                                       EmptyString(), // aPublicId
52011:                                       EmptyString(), // aSystemId
52011:                                       voidString); // aInternalSubset
52011:   NS_ENSURE_SUCCESS(rv, rv);
52011: 
54461: 
54461:   nsCOMPtr<nsIScriptGlobalObject> scriptHandlingObject =
54461:     do_QueryReferent(mScriptObject);
54461: 
54461:   NS_ENSURE_STATE(!mScriptObject || scriptHandlingObject);
54461:                                                        
54461:   nsCOMPtr<nsIDOMDocument> document;
54461:   rv = nsContentUtils::CreateDocument(EmptyString(), EmptyString(),
54461:                                       doctype, mDocumentURI, mBaseURI,
54461:                                       mPrincipal, scriptHandlingObject,
54461:                                       getter_AddRefs(document));
52011:   NS_ENSURE_SUCCESS(rv, rv);
54461:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(document);
52011: 
52011:   nsCOMPtr<nsIContent> root;
52011:   rv = doc->CreateElem(NS_LITERAL_STRING("html"), NULL, kNameSpaceID_XHTML,
52011:                        false, getter_AddRefs(root));
52011:   NS_ENSURE_SUCCESS(rv, rv);
52011:   rv = doc->AppendChildTo(root, false);
52011:   NS_ENSURE_SUCCESS(rv, rv);
52011: 
52011:   nsCOMPtr<nsIContent> head;
52011:   rv = doc->CreateElem(NS_LITERAL_STRING("head"), NULL, kNameSpaceID_XHTML,
52011:                        false, getter_AddRefs(head));
52011:   NS_ENSURE_SUCCESS(rv, rv);
52011:   rv = root->AppendChildTo(head, false);
52011:   NS_ENSURE_SUCCESS(rv, rv);
52011: 
52011:   nsCOMPtr<nsIContent> title;
52011:   rv = doc->CreateElem(NS_LITERAL_STRING("title"), NULL, kNameSpaceID_XHTML,
52011:                        false, getter_AddRefs(title));
52011:   NS_ENSURE_SUCCESS(rv, rv);
52011:   rv = head->AppendChildTo(title, false);
52011:   NS_ENSURE_SUCCESS(rv, rv);
52011: 
52011:   nsCOMPtr<nsIContent> titleText;
52011:   rv = NS_NewTextNode(getter_AddRefs(titleText), doc->NodeInfoManager());
52011:   NS_ENSURE_SUCCESS(rv, rv);
52011:   rv = titleText->SetText(aTitle, false);
52011:   NS_ENSURE_SUCCESS(rv, rv);
52011:   rv = title->AppendChildTo(titleText, false);
52011:   NS_ENSURE_SUCCESS(rv, rv);
52011: 
52011:   nsCOMPtr<nsIContent> body;
52011:   rv = doc->CreateElem(NS_LITERAL_STRING("body"), NULL, kNameSpaceID_XHTML,
52011:                        false, getter_AddRefs(body));
52011:   NS_ENSURE_SUCCESS(rv, rv);
52011:   rv = root->AppendChildTo(body, false);
52011:   NS_ENSURE_SUCCESS(rv, rv);
52011: 
52011:   document.forget(aReturn);
52011: 
52011:   return NS_OK;
52011: }
52011: 
    1: // ==================================================================
    1: // =
    1: // ==================================================================
    1: 
    1:   // NOTE! nsDocument::operator new() zeroes out all members, so don't
    1:   // bother initializing members to 0.
    1: 
    1: nsDocument::nsDocument(const char* aContentType)
34205:   : nsIDocument()
52149:   , mAnimatingImages(PR_TRUE)
    1: {
46309:   SetContentTypeInternal(nsDependentCString(aContentType));
    1:   
    1: #ifdef PR_LOGGING
    1:   if (!gDocumentLeakPRLog)
    1:     gDocumentLeakPRLog = PR_NewLogModule("DocumentLeak");
    1: 
    1:   if (gDocumentLeakPRLog)
    1:     PR_LOG(gDocumentLeakPRLog, PR_LOG_DEBUG,
    1:            ("DOCUMENT %p created", this));
37418: 
37418:   if (!gCspPRLog)
37418:     gCspPRLog = PR_NewLogModule("CSP");
    1: #endif
    1: 
    1:   // Start out mLastStyleSheetSet as null, per spec
    1:   SetDOMStringToNull(mLastStyleSheetSet);
    1: }
    1: 
20261: static PLDHashOperator
11731: ClearAllBoxObjects(const void* aKey, nsPIBoxObject* aBoxObject, void* aUserArg)
11731: {
11731:   if (aBoxObject) {
11731:     aBoxObject->Clear();
11731:   }
11731:   return PL_DHASH_NEXT;
11731: }
11731: 
    1: nsDocument::~nsDocument()
    1: {
    1: #ifdef PR_LOGGING
    1:   if (gDocumentLeakPRLog)
    1:     PR_LOG(gDocumentLeakPRLog, PR_LOG_DEBUG,
    1:            ("DOCUMENT %p destroyed", this));
    1: #endif
    1: 
    1: #ifdef DEBUG
 3233:   nsCycleCollector_DEBUG_wasFreed(static_cast<nsIDocument*>(this));
    1: #endif
    1: 
    1:   mInDestructor = PR_TRUE;
50721:   mInUnlinkOrDeletion = PR_TRUE;
    1: 
    1:   // Clear mObservers to keep it in sync with the mutationobserver list
    1:   mObservers.Clear();
    1: 
    1:   if (mStyleSheetSetList) {
    1:     mStyleSheetSetList->Disconnect();
    1:   }
    1: 
69160: #ifdef MOZ_SMIL
69078:   if (mAnimationController) {
69078:     mAnimationController->Disconnect();
69078:   }
69160: #endif // MOZ_SMIL
69078: 
    1:   mParentDocument = nsnull;
    1: 
    1:   // Kill the subdocument map, doing this will release its strong
    1:   // references, if any.
    1:   if (mSubDocuments) {
    1:     PL_DHashTableDestroy(mSubDocuments);
    1: 
    1:     mSubDocuments = nsnull;
    1:   }
    1: 
    1:   // Destroy link map now so we don't waste time removing
    1:   // links one by one
43079:   DestroyElementMaps();
    1: 
14228:   nsAutoScriptBlocker scriptBlocker;
14228: 
 8938:   PRInt32 indx; // must be signed
    1:   PRUint32 count = mChildren.ChildCount();
    1:   for (indx = PRInt32(count) - 1; indx >= 0; --indx) {
    1:     mChildren.ChildAt(indx)->UnbindFromTree();
    1:     mChildren.RemoveChildAt(indx);
    1:   }
42105:   mFirstChild = nsnull;
41634:   mCachedRootElement = nsnull;
    1: 
    1:   // Let the stylesheets know we're going away
    1:   indx = mStyleSheets.Count();
    1:   while (--indx >= 0) {
    1:     mStyleSheets[indx]->SetOwningDocument(nsnull);
    1:   }
    1:   indx = mCatalogSheets.Count();
    1:   while (--indx >= 0) {
    1:     mCatalogSheets[indx]->SetOwningDocument(nsnull);
    1:   }
    1:   if (mAttrStyleSheet)
    1:     mAttrStyleSheet->SetOwningDocument(nsnull);
    1:   if (mStyleAttrStyleSheet)
    1:     mStyleAttrStyleSheet->SetOwningDocument(nsnull);
    1: 
    1:   if (mListenerManager) {
    1:     mListenerManager->Disconnect();
    1:   }
    1: 
    1:   if (mScriptLoader) {
    1:     mScriptLoader->DropDocumentReference();
    1:   }
    1: 
    1:   if (mCSSLoader) {
    1:     // Could be null here if Init() failed
    1:     mCSSLoader->DropDocumentReference();
    1:     NS_RELEASE(mCSSLoader);
    1:   }
    1: 
    1:   // XXX Ideally we'd do this cleanup in the nsIDocument destructor.
    1:   if (mNodeInfoManager) {
    1:     mNodeInfoManager->DropDocumentReference();
    1:     NS_RELEASE(mNodeInfoManager);
    1:   }
    1: 
    1:   if (mAttrStyleSheet) {
    1:     mAttrStyleSheet->SetOwningDocument(nsnull);
    1:   }
    1:   
    1:   if (mStyleAttrStyleSheet) {
    1:     mStyleAttrStyleSheet->SetOwningDocument(nsnull);
    1:   }
    1: 
    1:   delete mHeaderData;
11731: 
11731:   if (mBoxObjectTable) {
11731:     mBoxObjectTable->EnumerateRead(ClearAllBoxObjects, nsnull);
    1:     delete mBoxObjectTable;
11731:   }
28045: 
28045:   mPendingTitleChangeEvent.Revoke();
38871: 
38871:   for (PRUint32 i = 0; i < mFileDataUris.Length(); ++i) {
38871:     nsFileDataProtocolHandler::RemoveFileDataEntry(mFileDataUris[i]);
38871:   }
50815: 
50815:   // We don't want to leave residual locks on images. Make sure we're in an
50815:   // unlocked state, and then clear the table.
50815:   SetImageLockingState(PR_FALSE);
50815:   mImageTracker.Clear();
    1: }
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsDocument)
    1: 
12033: NS_INTERFACE_TABLE_HEAD(nsDocument)
21618:   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
21218:   NS_DOCUMENT_INTERFACE_TABLE_BEGIN(nsDocument)
12033:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDocument)
12033:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOMDocumentXBL)
12033:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIScriptObjectPrincipal)
72322:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOMEventTarget)
12033:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsISupportsWeakReference)
12033:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIRadioGroupContainer)
63105:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIRadioGroupContainer_MOZILLA_2_0_BRANCH)
12033:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIMutationObserver)
18430:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIApplicationCacheContainer)
68879:     NS_INTERFACE_TABLE_ENTRY(nsDocument, nsIDOMDocumentTouch)
21218:   NS_OFFSET_AND_INTERFACE_TABLE_END
21218:   NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
21218:   NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsDocument)
41908:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMXPathNSResolver,
41908:                                  new nsNode3Tearoff(this))
41909:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMNodeSelector,
41909:                                  new nsNodeSelectorTearoff(this))
12033:   if (aIID.Equals(NS_GET_IID(nsIDOMXPathEvaluator)) ||
12033:       aIID.Equals(NS_GET_IID(nsIXPathEvaluatorInternal))) {
12033:     if (!mXPathEvaluatorTearoff) {
12033:       nsresult rv;
12033:       mXPathEvaluatorTearoff =
12033:         do_CreateInstance(NS_XPATH_EVALUATOR_CONTRACTID,
12033:                           static_cast<nsIDocument *>(this), &rv);
12033:       NS_ENSURE_SUCCESS(rv, rv);
12033:     }
12033: 
12033:     return mXPathEvaluatorTearoff->QueryInterface(aIID, aInstancePtr);
12033:   }
12033:   else
12033: NS_INTERFACE_MAP_END
12033: 
12033: 
67682: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsDocument)
67682: NS_IMPL_CYCLE_COLLECTING_RELEASE_WITH_DESTROY(nsDocument, 
 1391:                                               nsNodeUtils::LastRelease(this))
    1: 
20261: static PLDHashOperator
    1: SubDocTraverser(PLDHashTable *table, PLDHashEntryHdr *hdr, PRUint32 number,
    1:                 void *arg)
    1: {
 3233:   SubDocMapEntry *entry = static_cast<SubDocMapEntry*>(hdr);
    1:   nsCycleCollectionTraversalCallback *cb = 
 3233:     static_cast<nsCycleCollectionTraversalCallback*>(arg);
    1: 
13202:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "mSubDocuments entry->mKey");
    1:   cb->NoteXPCOMChild(entry->mKey);
13202:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "mSubDocuments entry->mSubDocument");
    1:   cb->NoteXPCOMChild(entry->mSubDocument);
    1: 
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
20261: static PLDHashOperator
20078: RadioGroupsTraverser(const nsAString& aKey, nsRadioGroupStruct* aData,
20078:                      void* aClosure)
 6365: {
    1:   nsCycleCollectionTraversalCallback *cb = 
 3233:     static_cast<nsCycleCollectionTraversalCallback*>(aClosure);
    1: 
13202:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb,
13202:                                    "mRadioGroups entry->mSelectedRadioButton");
 6365:   cb->NoteXPCOMChild(aData->mSelectedRadioButton);
 6365: 
 6365:   PRUint32 i, count = aData->mRadioButtons.Count();
    1:   for (i = 0; i < count; ++i) {
13202:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb,
13202:                                        "mRadioGroups entry->mRadioButtons[i]");
 6365:     cb->NoteXPCOMChild(aData->mRadioButtons[i]);
 6365:   }
 6365: 
 6365:   return PL_DHASH_NEXT;
    1: }
    1: 
20261: static PLDHashOperator
11731: BoxObjectTraverser(const void* key, nsPIBoxObject* boxObject, void* userArg)
    1: {
    1:   nsCycleCollectionTraversalCallback *cb = 
 3233:     static_cast<nsCycleCollectionTraversalCallback*>(userArg);
    1:  
13202:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(*cb, "mBoxObjectTable entry");
    1:   cb->NoteXPCOMChild(boxObject);
    1: 
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
20261: static PLDHashOperator
15474: IdentifierMapEntryTraverse(nsIdentifierMapEntry *aEntry, void *aArg)
15474: {
15474:   nsCycleCollectionTraversalCallback *cb =
15474:     static_cast<nsCycleCollectionTraversalCallback*>(aArg);
15474:   aEntry->Traverse(cb);
15474:   return PL_DHASH_NEXT;
15474: }
15474: 
53870: static const char* kNSURIs[] = {
53870:   " ([none])",
53870:   " (xmlns)",
53870:   " (xml)",
53870:   " (xhtml)",
53870:   " (XLink)",
53870:   " (XSLT)",
53870:   " (XBL)",
53870:   " (MathML)",
53870:   " (RDF)",
53870:   " (XUL)"
53870: };
53870: 
53870: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INTERNAL(nsDocument)
53870:   if (NS_UNLIKELY(cb.WantDebugInfo())) {
69565:     char name[512];
53870:     PRUint32 nsid = tmp->GetDefaultNamespaceID();
53870:     nsCAutoString uri;
53870:     if (tmp->mDocumentURI)
53870:       tmp->mDocumentURI->GetSpec(uri);
53870:     if (nsid < NS_ARRAY_LENGTH(kNSURIs)) {
53870:       PR_snprintf(name, sizeof(name), "nsDocument%s %s", kNSURIs[nsid],
53870:                   uri.get());
53870:     }
53870:     else {
53870:       PR_snprintf(name, sizeof(name), "nsDocument %s", uri.get());
53870:     }
72420:     cb.DescribeRefCountedNode(tmp->mRefCnt.get(), sizeof(nsDocument), name);
53870:   }
53870:   else {
72420:     NS_IMPL_CYCLE_COLLECTION_DESCRIBE(nsDocument, tmp->mRefCnt.get())
53870:   }
53870: 
30001:   // Always need to traverse script objects, so do that before we check
30001:   // if we're uncollectable.
30001:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
30001: 
30096:   if (nsCCUncollectableMarker::InGeneration(cb, tmp->GetMarkedCCGeneration())) {
25691:     return NS_SUCCESS_INTERRUPTED_TRAVERSE;
 1353:   }
 1353: 
15474:   tmp->mIdentifierMap.EnumerateEntries(IdentifierMapEntryTraverse, &cb);
15474: 
20078:   tmp->mExternalResourceMap.Traverse(&cb);
20078: 
13669:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mNodeInfo)
13669: 
    1:   // Traverse the mChildren nsAttrAndChildArray.
    1:   for (PRInt32 indx = PRInt32(tmp->mChildren.ChildCount()); indx > 0; --indx) {
13202:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mChildren[i]");
    1:     cb.NoteXPCOMChild(tmp->mChildren.ChildAt(indx - 1));
    1:   }
    1: 
 1391:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_USERDATA
 1391: 
    1:   // Traverse all nsIDocument pointer members.
41634:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mCachedRootElement)
13669:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_MEMBER(mNodeInfoManager,
13669:                                                   nsNodeInfoManager)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mSecurityInfo)
20078:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDisplayDocument)
    1: 
    1:   // Traverse all nsDocument nsCOMPtrs.
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mParser)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mScriptGlobalObject)
72328:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_MEMBER(mListenerManager,
72328:                                                   nsEventListenerManager)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDOMStyleSheets)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mScriptLoader)
    1: 
20078:   tmp->mRadioGroups.EnumerateRead(RadioGroupsTraverser, &cb);
    1: 
    1:   // The boxobject for an element will only exist as long as it's in the
    1:   // document, so we'll traverse the table here instead of from the element.
    1:   if (tmp->mBoxObjectTable) {
    1:     tmp->mBoxObjectTable->EnumerateRead(BoxObjectTraverser, &cb);
    1:   }
    1: 
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mChannel)
36782:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mStyleAttrStyleSheet, nsIStyleSheet)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mScriptEventManager)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mXPathEvaluatorTearoff)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mLayoutHistoryState)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnloadBlocker)
33055:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFirstBaseNodeWithHref)
34007:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDOMImplementation)
71030:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mImageMaps,
71030:                                                        nsIDOMNodeList)
38006:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOriginalDocument)
46309:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mCachedEncoder)
69563:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mStateObjectCached)
    1: 
    1:   // Traverse all our nsCOMArrays.
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mStyleSheets)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mCatalogSheets)
30065:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mPreloadingImages)
    1: 
52255:   for (PRUint32 i = 0; i < tmp->mAnimationFrameListeners.Length(); ++i) {
52255:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mAnimationFrameListeners[i]");
52255:     cb.NoteXPCOMChild(tmp->mAnimationFrameListeners[i]);
52255:   }
52255: 
23697: #ifdef MOZ_SMIL
23697:   // Traverse animation components
23697:   if (tmp->mAnimationController) {
23697:     tmp->mAnimationController->Traverse(&cb);
23697:   }
23697: #endif // MOZ_SMIL
23697: 
    1:   if (tmp->mSubDocuments && tmp->mSubDocuments->ops) {
    1:     PL_DHashTableEnumerate(tmp->mSubDocuments, SubDocTraverser, &cb);
    1:   }
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
    1: 
30001: NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN(nsDocument)
30001:   NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
30001: NS_IMPL_CYCLE_COLLECTION_TRACE_END
30001: 
30001: 
    1: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsDocument)
50721:   tmp->mInUnlinkOrDeletion = PR_TRUE;
50721: 
20078:   // Clear out our external resources
20078:   tmp->mExternalResourceMap.Shutdown();
20078: 
14228:   nsAutoScriptBlocker scriptBlocker;
14228: 
    1:   // Unlink the mChildren nsAttrAndChildArray.
    1:   for (PRInt32 indx = PRInt32(tmp->mChildren.ChildCount()) - 1; 
    1:        indx >= 0; --indx) {
    1:     tmp->mChildren.ChildAt(indx)->UnbindFromTree();
    1:     tmp->mChildren.RemoveChildAt(indx);
    1:   }
42105:   tmp->mFirstChild = nsnull;
    1: 
41634:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mCachedRootElement)
20078:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDisplayDocument)
33055:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mFirstBaseNodeWithHref)
34007:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDOMImplementation)
71030:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mImageMaps)
38006:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOriginalDocument)
46309:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mCachedEncoder)
 8938: 
67680:   NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
 1391:   NS_IMPL_CYCLE_COLLECTION_UNLINK_USERDATA
 1391: 
    1:   tmp->mParentDocument = nsnull;
    1: 
30065:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mPreloadingImages)
30065: 
49019:   
49019:   if (tmp->mBoxObjectTable) {
49019:    tmp->mBoxObjectTable->EnumerateRead(ClearAllBoxObjects, nsnull);
49019:    delete tmp->mBoxObjectTable;
49019:    tmp->mBoxObjectTable = nsnull;
49019:  }
49019: 
    1:   // nsDocument has a pretty complex destructor, so we're going to
    1:   // assume that *most* cycles you actually want to break somewhere
    1:   // else, and not unlink an awful lot here.
    1:   //
    1:   // In rare cases where you think an unlink will help here, add one
    1:   // manually.
50721: 
50721:   tmp->mInUnlinkOrDeletion = PR_FALSE;
59625: 
59625:   tmp->mIdentifierMap.Clear();
    1: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
    1: 
    1: 
    1: nsresult
    1: nsDocument::Init()
    1: {
13669:   if (mCSSLoader || mNodeInfoManager || mScriptLoader) {
    1:     return NS_ERROR_ALREADY_INITIALIZED;
    1:   }
    1: 
15474:   mIdentifierMap.Init();
38488:   (void)mStyledLinks.Init();
 6365:   mRadioGroups.Init();
    1: 
    1:   // Force initialization.
    1:   nsINode::nsSlots* slots = GetSlots();
 8678:   NS_ENSURE_TRUE(slots,NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // Prepend self as mutation-observer whether we need it or not (some
    1:   // subclasses currently do, other don't). This is because the code in
    1:   // nsNodeUtils always notifies the first observer first, expecting the
    1:   // first observer to be the document.
 9596:   NS_ENSURE_TRUE(slots->mMutationObservers.PrependElementUnlessExists(static_cast<nsIMutationObserver*>(this)),
    1:                  NS_ERROR_OUT_OF_MEMORY);
    1: 
    1: 
    1:   mOnloadBlocker = new nsOnloadBlocker();
    1:   NS_ENSURE_TRUE(mOnloadBlocker, NS_ERROR_OUT_OF_MEMORY);
    1: 
38851:   mCSSLoader = new mozilla::css::Loader(this);
    1:   NS_ENSURE_TRUE(mCSSLoader, NS_ERROR_OUT_OF_MEMORY);
38851:   NS_ADDREF(mCSSLoader);
33262:   // Assume we're not quirky, until we know otherwise
    1:   mCSSLoader->SetCompatibilityMode(eCompatibility_FullStandards);
    1: 
11169:   mNodeInfoManager = new nsNodeInfoManager();
11169:   NS_ENSURE_TRUE(mNodeInfoManager, NS_ERROR_OUT_OF_MEMORY);
11169: 
11169:   NS_ADDREF(mNodeInfoManager);
11169: 
11169:   nsresult  rv = mNodeInfoManager->Init(this);
11169:   NS_ENSURE_SUCCESS(rv, rv);
11169: 
11169:   mNodeInfo = mNodeInfoManager->GetDocumentNodeInfo();
11169:   NS_ENSURE_TRUE(mNodeInfo, NS_ERROR_OUT_OF_MEMORY);
71770:   NS_ABORT_IF_FALSE(mNodeInfo->NodeType() == nsIDOMNode::DOCUMENT_NODE,
71770:                     "Bad NodeType in aNodeInfo");
11169: 
    1:   NS_ASSERTION(GetOwnerDoc() == this, "Our nodeinfo is busted!");
    1: 
 2007:   mScriptLoader = new nsScriptLoader(this);
 2007:   NS_ENSURE_TRUE(mScriptLoader, NS_ERROR_OUT_OF_MEMORY);
 2007: 
50815:   if (!mImageTracker.Init()) {
50815:     return NS_ERROR_OUT_OF_MEMORY;
50815:   }
50815: 
    1:   return NS_OK;
    1: }
    1: 
41182: void 
41182: nsIDocument::DeleteAllProperties()
41182: {
41182:   for (PRUint32 i = 0; i < GetPropertyTableCount(); ++i) {
41182:     PropertyTable(i)->DeleteAllProperties();
41182:   }
41182: }
41182: 
41182: void
41182: nsIDocument::DeleteAllPropertiesFor(nsINode* aNode)
41182: {
41182:   for (PRUint32 i = 0; i < GetPropertyTableCount(); ++i) {
41182:     PropertyTable(i)->DeleteAllPropertiesFor(aNode);
41182:   }
41182: }
41182: 
41182: nsPropertyTable*
41182: nsIDocument::GetExtraPropertyTable(PRUint16 aCategory)
41182: {
41182:   NS_ASSERTION(aCategory > 0, "Category 0 should have already been handled");
41702:   while (aCategory >= mExtraPropertyTables.Length() + 1) {
41182:     mExtraPropertyTables.AppendElement(new nsPropertyTable());
41182:   }
41182:   return mExtraPropertyTables[aCategory - 1];
41182: }
41182: 
    1: nsresult
    1: nsDocument::AddXMLEventsContent(nsIContent *aXMLEventsElement)
    1: {
    1:   if (!mXMLEventsManager) {
    1:     mXMLEventsManager = new nsXMLEventsManager();
    1:     NS_ENSURE_TRUE(mXMLEventsManager, NS_ERROR_OUT_OF_MEMORY);
    1:     AddObserver(mXMLEventsManager);
    1:   }
    1:   mXMLEventsManager->AddXMLEventsContent(aXMLEventsElement);
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsDocument::Reset(nsIChannel* aChannel, nsILoadGroup* aLoadGroup)
    1: {
    1:   nsCOMPtr<nsIURI> uri;
    1:   nsCOMPtr<nsIPrincipal> principal;
    1:   if (aChannel) {
    1:     // Note: this code is duplicated in nsXULDocument::StartDocumentLoad and
    1:     // nsScriptSecurityManager::GetChannelPrincipal.    
    1:     // Note: this should match nsDocShell::OnLoadingSite
 7109:     NS_GetFinalChannelURI(aChannel, getter_AddRefs(uri));
    1: 
    1:     nsIScriptSecurityManager *securityManager =
    1:       nsContentUtils::GetSecurityManager();
    1:     if (securityManager) {
    1:       securityManager->GetChannelPrincipal(aChannel,
    1:                                            getter_AddRefs(principal));
    1:     }
    1:   }
    1: 
    1:   ResetToURI(uri, aLoadGroup, principal);
    1: 
21811:   nsCOMPtr<nsIPropertyBag2> bag = do_QueryInterface(aChannel);
21811:   if (bag) {
21811:     nsCOMPtr<nsIURI> baseURI;
21811:     bag->GetPropertyAsInterface(NS_LITERAL_STRING("baseURI"),
21811:                                 NS_GET_IID(nsIURI), getter_AddRefs(baseURI));
21811:     if (baseURI) {
21811:       mDocumentBaseURI = baseURI;
21811:     }
21811:   }
21811: 
    1:   mChannel = aChannel;
    1: }
    1: 
    1: void
    1: nsDocument::ResetToURI(nsIURI *aURI, nsILoadGroup *aLoadGroup,
    1:                        nsIPrincipal* aPrincipal)
    1: {
    1:   NS_PRECONDITION(aURI, "Null URI passed to ResetToURI");
    1: 
    1: #ifdef PR_LOGGING
    1:   if (gDocumentLeakPRLog && PR_LOG_TEST(gDocumentLeakPRLog, PR_LOG_DEBUG)) {
    1:     nsCAutoString spec;
    1:     aURI->GetSpec(spec);
    1:     PR_LogPrint("DOCUMENT %p ResetToURI %s", this, spec.get());
    1:   }
    1: #endif
    1: 
    1:   SetPrincipal(nsnull);
    1:   mSecurityInfo = nsnull;
    1: 
    1:   mDocumentLoadGroup = nsnull;
    1: 
    1:   // Delete references to sub-documents and kill the subdocument map,
    1:   // if any. It holds strong references
    1:   if (mSubDocuments) {
    1:     PL_DHashTableDestroy(mSubDocuments);
    1: 
    1:     mSubDocuments = nsnull;
    1:   }
    1: 
    1:   // Destroy link map now so we don't waste time removing
    1:   // links one by one
43079:   DestroyElementMaps();
    1: 
50721:   PRBool oldVal = mInUnlinkOrDeletion;
50721:   mInUnlinkOrDeletion = PR_TRUE;
    1:   PRUint32 count = mChildren.ChildCount();
11681:   { // Scope for update
11681:     MOZ_AUTO_DOC_UPDATE(this, UPDATE_CONTENT_MODEL, PR_TRUE);    
    1:     for (PRInt32 i = PRInt32(count) - 1; i >= 0; i--) {
    1:       nsCOMPtr<nsIContent> content = mChildren.ChildAt(i);
    1: 
48038:       nsIContent* previousSibling = content->GetPreviousSibling();
48038: 
42105:       if (nsINode::GetFirstChild() == content) {
42105:         mFirstChild = content->GetNextSibling();
42105:       }
33055:       mChildren.RemoveChildAt(i);
48038:       nsNodeUtils::ContentRemoved(this, content, i, previousSibling);
    1:       content->UnbindFromTree();
    1:     }
11681:   }
50721:   mInUnlinkOrDeletion = oldVal;
41634:   mCachedRootElement = nsnull;
    1: 
    1:   // Reset our stylesheets
    1:   ResetStylesheetsToURI(aURI);
    1:   
    1:   // Release the listener manager
    1:   if (mListenerManager) {
    1:     mListenerManager->Disconnect();
    1:     mListenerManager = nsnull;
    1:   }
    1: 
    1:   // Release the stylesheets list.
    1:   mDOMStyleSheets = nsnull;
    1: 
59194:   // Clear the original URI so SetDocumentURI sets it.
59194:   mOriginalURI = nsnull;
59194: 
    1:   SetDocumentURI(aURI);
33055:   // If mDocumentBaseURI is null, nsIDocument::GetBaseURI() returns
33055:   // mDocumentURI.
33055:   mDocumentBaseURI = nsnull;
    1: 
    1:   if (aLoadGroup) {
    1:     mDocumentLoadGroup = do_GetWeakReference(aLoadGroup);
    1:     // there was an assertion here that aLoadGroup was not null.  This
28078:     // is no longer valid: nsDocShell::SetDocument does not create a
28078:     // load group, and it works just fine
28078: 
28078:     // XXXbz what does "just fine" mean exactly?  And given that there
28078:     // is no nsDocShell::SetDocument, what is this talking about?
    1:   }
    1: 
    1:   mLastModified.Truncate();
    1:   // XXXbz I guess we're assuming that the caller will either pass in
    1:   // a channel with a useful type or call SetContentType?
46309:   SetContentTypeInternal(EmptyCString());
    1:   mContentLanguage.Truncate();
    1:   mBaseTarget.Truncate();
    1:   mReferrer.Truncate();
    1: 
    1:   mXMLDeclarationBits = 0;
    1: 
    1:   // Now get our new principal
    1:   if (aPrincipal) {
    1:     SetPrincipal(aPrincipal);
    1:   } else {
    1:     nsIScriptSecurityManager *securityManager =
    1:       nsContentUtils::GetSecurityManager();
    1:     if (securityManager) {
    1:       nsCOMPtr<nsIPrincipal> principal;
    1:       nsresult rv =
    1:         securityManager->GetCodebasePrincipal(mDocumentURI,
    1:                                               getter_AddRefs(principal));
    1:       if (NS_SUCCEEDED(rv)) {
    1:         SetPrincipal(principal);
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsDocument::ResetStylesheetsToURI(nsIURI* aURI)
    1: {
    1:   NS_PRECONDITION(aURI, "Null URI passed to ResetStylesheetsToURI");
    1: 
    1:   mozAutoDocUpdate upd(this, UPDATE_STYLE, PR_TRUE);
    1:   
    1:   // The stylesheets should forget us
    1:   PRInt32 indx = mStyleSheets.Count();
    1:   while (--indx >= 0) {
    1:     nsIStyleSheet* sheet = mStyleSheets[indx];
    1:     sheet->SetOwningDocument(nsnull);
    1: 
42332:     if (sheet->IsApplicable()) {
    1:       RemoveStyleSheetFromStyleSets(sheet);
    1:     }
    1: 
    1:     // XXX Tell observers?
    1:   }
    1: 
    1:   indx = mCatalogSheets.Count();
    1:   while (--indx >= 0) {
    1:     nsIStyleSheet* sheet = mCatalogSheets[indx];
    1:     sheet->SetOwningDocument(nsnull);
    1: 
42332:     if (sheet->IsApplicable()) {
46225:       nsCOMPtr<nsIPresShell> shell = GetShell();
36917:       if (shell) {
 1722:         shell->StyleSet()->RemoveStyleSheet(nsStyleSet::eAgentSheet, sheet);
    1:       }
    1:     }
    1: 
    1:     // XXX Tell observers?
    1:   }
    1: 
    1: 
    1:   // Release all the sheets
    1:   mStyleSheets.Clear();
    1:   // NOTE:  We don't release the catalog sheets.  It doesn't really matter
    1:   // now, but it could in the future -- in which case not releasing them
    1:   // is probably the right thing to do.
    1: 
    1:   // Now reset our inline style and attribute sheets.
42399:   nsresult rv = NS_OK;
    1:   if (mAttrStyleSheet) {
    1:     // Remove this sheet from all style sets
46225:     nsCOMPtr<nsIPresShell> shell = GetShell();
36917:     if (shell) {
60634:       shell->StyleSet()->RemoveStyleSheet(nsStyleSet::ePresHintSheet,
60633:                                           mAttrStyleSheet);
    1:     }
42399:     mAttrStyleSheet->Reset(aURI);
    1:   } else {
    1:     rv = NS_NewHTMLStyleSheet(getter_AddRefs(mAttrStyleSheet), aURI, this);
    1:     NS_ENSURE_SUCCESS(rv, rv);
42399:   }
    1: 
    1:   // Don't use AddStyleSheet, since it'll put the sheet into style
    1:   // sets in the document level, which is not desirable here.
    1:   mAttrStyleSheet->SetOwningDocument(this);
    1:   
    1:   if (mStyleAttrStyleSheet) {
    1:     // Remove this sheet from all style sets
46225:     nsCOMPtr<nsIPresShell> shell = GetShell();
36917:     if (shell) {
 1722:       shell->StyleSet()->
    1:         RemoveStyleSheet(nsStyleSet::eStyleAttrSheet, mStyleAttrStyleSheet);
    1:     }
42399:     mStyleAttrStyleSheet->Reset(aURI);
    1:   } else {
36782:     mStyleAttrStyleSheet = new nsHTMLCSSStyleSheet();
36782:     NS_ENSURE_TRUE(mStyleAttrStyleSheet, NS_ERROR_OUT_OF_MEMORY);
36782:     rv = mStyleAttrStyleSheet->Init(aURI, this);
    1:     NS_ENSURE_SUCCESS(rv, rv);
42399:   }
    1: 
    1:   // The loop over style sets below will handle putting this sheet
    1:   // into style sets as needed.
    1:   mStyleAttrStyleSheet->SetOwningDocument(this);
    1: 
    1:   // Now set up our style sets
46225:   nsCOMPtr<nsIPresShell> shell = GetShell();
36917:   if (shell) {
 1722:     FillStyleSet(shell->StyleSet());
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsDocument::FillStyleSet(nsStyleSet* aStyleSet)
    1: {
    1:   NS_PRECONDITION(aStyleSet, "Must have a style set");
60634:   NS_PRECONDITION(aStyleSet->SheetCount(nsStyleSet::ePresHintSheet) == 0,
60634:                   "Style set already has a preshint sheet?");
    1:   NS_PRECONDITION(aStyleSet->SheetCount(nsStyleSet::eDocSheet) == 0,
    1:                   "Style set already has document sheets?");
    1:   NS_PRECONDITION(aStyleSet->SheetCount(nsStyleSet::eStyleAttrSheet) == 0,
    1:                   "Style set already has style attr sheets?");
    1:   NS_PRECONDITION(mStyleAttrStyleSheet, "No style attr stylesheet?");
    1:   NS_PRECONDITION(mAttrStyleSheet, "No attr stylesheet?");
    1:   
60634:   aStyleSet->AppendStyleSheet(nsStyleSet::ePresHintSheet, mAttrStyleSheet);
    1: 
    1:   aStyleSet->AppendStyleSheet(nsStyleSet::eStyleAttrSheet,
    1:                               mStyleAttrStyleSheet);
    1: 
    1:   PRInt32 i;
    1:   for (i = mStyleSheets.Count() - 1; i >= 0; --i) {
    1:     nsIStyleSheet* sheet = mStyleSheets[i];
42332:     if (sheet->IsApplicable()) {
    1:       aStyleSet->AddDocStyleSheet(sheet, this);
    1:     }
    1:   }
    1: 
    1:   for (i = mCatalogSheets.Count() - 1; i >= 0; --i) {
    1:     nsIStyleSheet* sheet = mCatalogSheets[i];
42332:     if (sheet->IsApplicable()) {
    1:       aStyleSet->AppendStyleSheet(nsStyleSet::eAgentSheet, sheet);
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsDocument::StartDocumentLoad(const char* aCommand, nsIChannel* aChannel,
    1:                               nsILoadGroup* aLoadGroup,
    1:                               nsISupports* aContainer,
    1:                               nsIStreamListener **aDocListener,
    1:                               PRBool aReset, nsIContentSink* aSink)
    1: {
    1: #ifdef PR_LOGGING
    1:   if (gDocumentLeakPRLog && PR_LOG_TEST(gDocumentLeakPRLog, PR_LOG_DEBUG)) {
    1:     nsCOMPtr<nsIURI> uri;
    1:     aChannel->GetURI(getter_AddRefs(uri));
    1:     nsCAutoString spec;
    1:     if (uri)
    1:       uri->GetSpec(spec);
    1:     PR_LogPrint("DOCUMENT %p StartDocumentLoad %s", this, spec.get());
    1:   }
    1: #endif
    1: 
23639:   SetReadyStateInternal(READYSTATE_LOADING);
23639: 
 4064:   if (nsCRT::strcmp(kLoadAsData, aCommand) == 0) {
 4064:     mLoadedAsData = PR_TRUE;
 4064:     // We need to disable script & style loading in this case.
 4064:     // We leave them disabled even in EndLoad(), and let anyone
 4064:     // who puts the document on display to worry about enabling.
 4064: 
 4064:     // Do not load/process scripts when loading as data
 4064:     ScriptLoader()->SetEnabled(PR_FALSE);
 4064: 
 4064:     // styles
 4064:     CSSLoader()->SetEnabled(PR_FALSE); // Do not load/process styles when loading as data
20078:   } else if (nsCRT::strcmp("external-resource", aCommand) == 0) {
20078:     // Allow CSS, but not scripts
20078:     ScriptLoader()->SetEnabled(PR_FALSE);
 4064:   }
 4064: 
10474:   mMayStartLayout = PR_FALSE;
10474: 
16447:   mHaveInputEncoding = PR_TRUE;
16447: 
    1:   if (aReset) {
    1:     Reset(aChannel, aLoadGroup);
    1:   }
    1: 
    1:   nsCAutoString contentType;
    1:   if (NS_SUCCEEDED(aChannel->GetContentType(contentType))) {
    1:     // XXX this is only necessary for viewsource:
    1:     nsACString::const_iterator start, end, semicolon;
    1:     contentType.BeginReading(start);
    1:     contentType.EndReading(end);
    1:     semicolon = start;
    1:     FindCharInReadable(';', semicolon, end);
46309:     SetContentTypeInternal(Substring(start, semicolon));
    1:   }
    1: 
    1:   RetrieveRelevantHeaders(aChannel);
    1: 
    1:   mChannel = aChannel;
    1: 
55818:   nsresult rv = InitCSP();
37418:   NS_ENSURE_SUCCESS(rv, rv);
37418: 
37418:   return NS_OK;
37418: }
37418: 
37418: nsresult
37418: nsDocument::InitCSP()
37418: {
47342:   if (CSPService::sCSPEnabled) {
37418:     nsAutoString cspHeaderValue;
37418:     nsAutoString cspROHeaderValue;
37418: 
37418:     this->GetHeaderData(nsGkAtoms::headerCSP, cspHeaderValue);
37418:     this->GetHeaderData(nsGkAtoms::headerCSPReportOnly, cspROHeaderValue);
37418: 
37418:     PRBool system = PR_FALSE;
37418:     nsIScriptSecurityManager *ssm = nsContentUtils::GetSecurityManager();
37418: 
37418:     if (NS_SUCCEEDED(ssm->IsSystemPrincipal(NodePrincipal(), &system)) && system) {
37418:       // only makes sense to register new CSP if this document is not priviliged
37418:       return NS_OK;
37418:     }
37418: 
37418:     if (cspHeaderValue.IsEmpty() && cspROHeaderValue.IsEmpty()) {
37418:       // no CSP header present, stop processing
37418:       return NS_OK;
37418:     }
37418: 
37418: #ifdef PR_LOGGING 
37418:     PR_LOG(gCspPRLog, PR_LOG_DEBUG, ("CSP header specified for document %p", this));
37418: #endif
37418: 
37418:     nsresult rv;
37418:     nsCOMPtr<nsIContentSecurityPolicy> mCSP;
37418:     mCSP = do_CreateInstance("@mozilla.org/contentsecuritypolicy;1", &rv);
37418: 
37418:     if (NS_FAILED(rv)) {
37418: #ifdef PR_LOGGING 
37418:       PR_LOG(gCspPRLog, PR_LOG_DEBUG, ("Failed to create CSP object: %x", rv));
37418: #endif
37418:       return rv;
37418:     }
37418: 
37418:     // Store the request context for violation reports
37418:     nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(mChannel);
37418:     mCSP->ScanRequestData(httpChannel);
37418: 
37418:     // Start parsing the policy
37418:     nsCOMPtr<nsIURI> chanURI;
37418:     mChannel->GetURI(getter_AddRefs(chanURI));
37418: 
37418: #ifdef PR_LOGGING 
37418:     PR_LOG(gCspPRLog, PR_LOG_DEBUG, ("CSP Loaded"));
37418: #endif
37418: 
47165:     // ReportOnly mode is enabled *only* if there are no regular-strength CSP
47165:     // headers present.  If there are, then we ignore the ReportOnly mode and
47165:     // toss a warning into the error console, proceeding with enforcing the
47165:     // regular-strength CSP.
47165:     if (cspHeaderValue.IsEmpty()) {
47165:       mCSP->SetReportOnlyMode(true);
47165:       mCSP->RefinePolicy(cspROHeaderValue, chanURI);
37418: #ifdef PR_LOGGING 
37418:       {
37418:         PR_LOG(gCspPRLog, PR_LOG_DEBUG, 
47165:                 ("CSP (report only) refined, policy: \"%s\"", 
47165:                   NS_ConvertUTF16toUTF8(cspROHeaderValue).get()));
47165:       }
47165: #endif
47165:     } else {
47165:       //XXX(sstamm): maybe we should post a warning when both read only and regular 
47165:       // CSP headers are present.
47165:       mCSP->RefinePolicy(cspHeaderValue, chanURI);
47165: #ifdef PR_LOGGING 
47165:       {
47165:         PR_LOG(gCspPRLog, PR_LOG_DEBUG, 
47165:                ("CSP refined, policy: \"%s\"",
47162:                 NS_ConvertUTF16toUTF8(cspHeaderValue).get()));
47162:       }
47162: #endif
47162:     }
37418: 
37926:     // Check for frame-ancestor violation
37926:     nsCOMPtr<nsIDocShell> docShell = do_QueryReferent(mDocumentContainer);
37926:     if (docShell) {
37926:         PRBool safeAncestry = false;
37926: 
37926:         // PermitsAncestry sends violation reports when necessary
37926:         rv = mCSP->PermitsAncestry(docShell, &safeAncestry);
37926:         NS_ENSURE_SUCCESS(rv, rv);
37926: 
37926:         if (!safeAncestry) {
37926: #ifdef PR_LOGGING
37926:             PR_LOG(gCspPRLog, PR_LOG_DEBUG, 
37926:                    ("CSP doesn't like frame's ancestry, not loading."));
37926: #endif
37926:             // stop!  ERROR page!
37926:             mChannel->Cancel(NS_ERROR_CSP_FRAME_ANCESTOR_VIOLATION);
37926:         }
37926:     }
37926: 
37418:     //Copy into principal
37418:     nsIPrincipal* principal = GetPrincipal();
37418: 
37418:     if (principal) {
37418:         principal->SetCsp(mCSP);
37418: #ifdef PR_LOGGING
37418:         PR_LOG(gCspPRLog, PR_LOG_DEBUG, 
37418:                 ("Inserted CSP into principal %p", principal));
37418:     }
37418:     else {
37418:       PR_LOG(gCspPRLog, PR_LOG_DEBUG, 
37418:               ("Couldn't copy CSP into absent principal %p", principal));
37418: #endif
37418:     }
37418:   }
37418: #ifdef PR_LOGGING
37418:   else { //CSP was not enabled!
37418:     PR_LOG(gCspPRLog, PR_LOG_DEBUG, 
37418:            ("CSP is disabled, skipping CSP init for document %p", this));
37418:   }
37418: #endif
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsDocument::StopDocumentLoad()
    1: {
    1:   if (mParser) {
    1:     mParser->Terminate();
    1:   }
    1: }
    1: 
    1: void
    1: nsDocument::SetDocumentURI(nsIURI* aURI)
    1: {
41900:   nsCOMPtr<nsIURI> oldBase = GetDocBaseURI();
    1:   mDocumentURI = NS_TryToMakeImmutable(aURI);
41900:   nsIURI* newBase = GetDocBaseURI();
33055: 
33055:   PRBool equalBases = PR_FALSE;
33055:   if (oldBase && newBase) {
33055:     oldBase->Equals(newBase, &equalBases);
33055:   }
33055:   else {
33055:     equalBases = !oldBase && !newBase;
33055:   }
33055: 
59194:   // If this is the first time we're setting the document's URI, set the
59194:   // document's original URI.
59194:   if (!mOriginalURI)
59194:     mOriginalURI = mDocumentURI;
59194: 
33055:   // If changing the document's URI changed the base URI of the document, we
33055:   // need to refresh the hrefs of all the links on the page.
33055:   if (!equalBases) {
33055:     RefreshLinkHrefs();
33055:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetLastModified(nsAString& aLastModified)
    1: {
    1:   if (!mLastModified.IsEmpty()) {
    1:     aLastModified.Assign(mLastModified);
    1:   } else {
    1:     // If we for whatever reason failed to find the last modified time
    1:     // (or even the current time), fall back to what NS4.x returned.
    1:     aLastModified.Assign(NS_LITERAL_STRING("01/01/1970 00:00:00"));
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
15474: void
43079: nsDocument::AddToNameTable(Element *aElement, nsIAtom* aName)
15474: {
43946:   nsIdentifierMapEntry *entry =
68823:     mIdentifierMap.PutEntry(nsDependentAtomString(aName));
68823: 
68823:   // Null for out-of-memory
43079:   if (entry) {
69024:     entry->AddNameElement(this, aElement);
43079:   }
43079: }
43079: 
43079: void
43079: nsDocument::RemoveFromNameTable(Element *aElement, nsIAtom* aName)
43079: {
43079:   // Speed up document teardown
68823:   if (mIdentifierMap.Count() == 0)
15474:     return;
15474: 
43946:   nsIdentifierMapEntry *entry =
43946:     mIdentifierMap.GetEntry(nsDependentAtomString(aName));
43079:   if (!entry) // Should never be false unless we had OOM when adding the entry
15474:     return;
43079: 
43079:   entry->RemoveNameElement(aElement);
15474: }
15474: 
15474: void
43079: nsDocument::AddToIdTable(Element *aElement, nsIAtom* aId)
43079: {
43946:   nsIdentifierMapEntry *entry =
43946:     mIdentifierMap.PutEntry(nsDependentAtomString(aId));
26475: 
26475:   if (entry) { /* True except on OOM */
41635:     entry->AddIdElement(aElement);
15474:   }
15474: }
15474: 
15474: void
43079: nsDocument::RemoveFromIdTable(Element *aElement, nsIAtom* aId)
43079: {
43079:   NS_ASSERTION(aId, "huhwhatnow?");
43079: 
43079:   // Speed up document teardown
43079:   if (mIdentifierMap.Count() == 0) {
15474:     return;
43079:   }
43079: 
43946:   nsIdentifierMapEntry *entry =
43946:     mIdentifierMap.GetEntry(nsDependentAtomString(aId));
43079:   if (!entry) // Can be null for XML elements with changing ids.
15474:     return;
15474: 
50428:   entry->RemoveIdElement(aElement);
50428:   if (entry->IsEmpty()) {
43946:     mIdentifierMap.RawRemoveEntry(entry);
15474:   }
15474: }
15474: 
    1: nsIPrincipal*
    1: nsDocument::GetPrincipal()
    1: {
    1:   return NodePrincipal();
    1: }
    1: 
28460: extern PRBool sDisablePrefetchHTTPSPref;
28460: 
    1: void
    1: nsDocument::SetPrincipal(nsIPrincipal *aNewPrincipal)
    1: {
28460:   if (aNewPrincipal && mAllowDNSPrefetch && sDisablePrefetchHTTPSPref) {
28460:     nsCOMPtr<nsIURI> uri;
28460:     aNewPrincipal->GetURI(getter_AddRefs(uri));
28460:     PRBool isHTTPS;
28460:     if (!uri || NS_FAILED(uri->SchemeIs("https", &isHTTPS)) ||
28460:         isHTTPS) {
28460:       mAllowDNSPrefetch = PR_FALSE;
28460:     }
28460:   }
    1:   mNodeInfoManager->SetDocumentPrincipal(aNewPrincipal);
    1: }
    1: 
    1: NS_IMETHODIMP
18430: nsDocument::GetApplicationCache(nsIApplicationCache **aApplicationCache)
18430: {
18430:   NS_IF_ADDREF(*aApplicationCache = mApplicationCache);
18430: 
18430:   return NS_OK;
18430: }
18430: 
18430: NS_IMETHODIMP
18430: nsDocument::SetApplicationCache(nsIApplicationCache *aApplicationCache)
18430: {
18430:   mApplicationCache = aApplicationCache;
18430: 
18430:   return NS_OK;
18430: }
18430: 
18430: NS_IMETHODIMP
    1: nsDocument::GetContentType(nsAString& aContentType)
    1: {
46309:   CopyUTF8toUTF16(GetContentTypeInternal(), aContentType);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsDocument::SetContentType(const nsAString& aContentType)
    1: {
46309:   NS_ASSERTION(GetContentTypeInternal().IsEmpty() ||
46309:                GetContentTypeInternal().Equals(NS_ConvertUTF16toUTF8(aContentType)),
    1:                "Do you really want to change the content-type?");
    1: 
46309:   SetContentTypeInternal(NS_ConvertUTF16toUTF8(aContentType));
    1: }
    1: 
    1: /* Return true if the document is in the focused top-level window, and is an
    1:  * ancestor of the focused DOMWindow. */
    1: NS_IMETHODIMP
    1: nsDocument::HasFocus(PRBool* aResult)
    1: {
    1:   *aResult = PR_FALSE;
    1: 
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   if (!fm)
29018:     return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:   // Is there a focused DOMWindow?
29018:   nsCOMPtr<nsIDOMWindow> focusedWindow;
29018:   fm->GetFocusedWindow(getter_AddRefs(focusedWindow));
29018:   if (!focusedWindow)
29018:     return NS_OK;
    1: 
    1:   // Are we an ancestor of the focused DOMWindow?
    1:   nsCOMPtr<nsIDOMDocument> domDocument;
    1:   focusedWindow->GetDocument(getter_AddRefs(domDocument));
    1:   nsCOMPtr<nsIDocument> document = do_QueryInterface(domDocument);
    1: 
    1:   for (nsIDocument* currentDoc = document; currentDoc;
    1:        currentDoc = currentDoc->GetParentDocument()) {
    1:     if (currentDoc == this) {
    1:       // Yes, we are an ancestor
    1:       *aResult = PR_TRUE;
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetReferrer(nsAString& aReferrer)
    1: {
    1:   CopyUTF8toUTF16(mReferrer, aReferrer);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetActiveElement(nsIDOMElement **aElement)
    1: {
    1:   *aElement = nsnull;
    1: 
    1:   // Get the focused element.
29018:   nsCOMPtr<nsPIDOMWindow> window = GetWindow();
69718:   if (window) {
29018:     nsCOMPtr<nsPIDOMWindow> focusedWindow;
29018:     nsIContent* focusedContent =
69718:       nsFocusManager::GetFocusedDescendant(window, PR_FALSE,
69718:                                            getter_AddRefs(focusedWindow));
29018:     // be safe and make sure the element is from this document
69718:     if (focusedContent && focusedContent->GetOwnerDoc() == this) {
29018:       CallQueryInterface(focusedContent, aElement);
29018:       return NS_OK;
    1:     }
69718:   }
    1: 
    1:   // No focused element anywhere in this document.  Try to get the BODY.
    1:   nsCOMPtr<nsIDOMHTMLDocument> htmlDoc =
 3233:     do_QueryInterface(static_cast<nsIDocument*>(this));
    1:   if (htmlDoc) {
    1:     nsCOMPtr<nsIDOMHTMLElement> bodyElement;
    1:     htmlDoc->GetBody(getter_AddRefs(bodyElement));
    1:     if (bodyElement) {
    1:       *aElement = bodyElement;
    1:       NS_ADDREF(*aElement);
 7851:     }
 7851:     // Because of IE compatibility, return null when html document doesn't have
 7851:     // a body.
    1:     return NS_OK;
    1:   }
    1: 
    1:   // If we couldn't get a BODY, return the root element.
    1:   return GetDocumentElement(aElement);
    1: }
    1: 
    1: NS_IMETHODIMP
54146: nsDocument::GetCurrentScript(nsIDOMElement **aElement)
54146: {
54146:   nsIScriptElement* script = mScriptLoader->GetCurrentScript();
54146:   if (script) {
54146:     return CallQueryInterface(script, aElement);
54146:   }
54146:   
54146:   *aElement = nsnull;
54146: 
54146:   return NS_OK;
54146: }
54146: 
54146: NS_IMETHODIMP
40200: nsDocument::ElementFromPoint(float aX, float aY, nsIDOMElement** aReturn)
 5440: {
21333:   return ElementFromPointHelper(aX, aY, PR_FALSE, PR_TRUE, aReturn);
21333: }
21333: 
21333: nsresult
40200: nsDocument::ElementFromPointHelper(float aX, float aY,
21333:                                    PRBool aIgnoreRootScrollFrame,
21333:                                    PRBool aFlushLayout,
21333:                                    nsIDOMElement** aReturn)
21333: {
 5440:   NS_ENSURE_ARG_POINTER(aReturn);
 5440:   *aReturn = nsnull;
 5440:   // As per the the spec, we return null if either coord is negative
31237:   if (!aIgnoreRootScrollFrame && (aX < 0 || aY < 0))
 5440:     return NS_OK;
 5440: 
 5440:   nscoord x = nsPresContext::CSSPixelsToAppUnits(aX);
 5440:   nscoord y = nsPresContext::CSSPixelsToAppUnits(aY);
 5440:   nsPoint pt(x, y);
 5440: 
 5440:   // Make sure the layout information we get is up-to-date, and
 5440:   // ensure we get a root frame (for everything but XUL)
21333:   if (aFlushLayout)
 5440:     FlushPendingNotifications(Flush_Layout);
 5440: 
46225:   nsIPresShell *ps = GetShell();
 5440:   NS_ENSURE_STATE(ps);
 5440:   nsIFrame *rootFrame = ps->GetRootFrame();
 5440: 
 5440:   // XUL docs, unlike HTML, have no frame tree until everything's done loading
 5440:   if (!rootFrame)
 5440:     return NS_OK; // return null to premature XUL callers as a reminder to wait
 5440: 
21333:   nsIFrame *ptFrame = nsLayoutUtils::GetFrameForPoint(rootFrame, pt, PR_TRUE,
21333:                                                       aIgnoreRootScrollFrame);
 5440:   if (!ptFrame)
 5440:     return NS_OK;
 5440: 
 5440:   nsIContent* ptContent = ptFrame->GetContent();
 5440:   NS_ENSURE_STATE(ptContent);
 5440: 
 5440:   // If the content is in a subdocument, try to get the element from |this| doc
 5440:   nsIDocument *currentDoc = ptContent->GetCurrentDoc();
 5440:   if (currentDoc && (currentDoc != this)) {
 5440:     *aReturn = CheckAncestryAndGetFrame(currentDoc).get();
 5440:     return NS_OK;
 5440:   }
 5440: 
 5440:   // If we have an anonymous element (such as an internal div from a textbox),
 5440:   // or a node that isn't an element (such as a text frame node),
 5440:   // replace it with the first non-anonymous parent node of type element.
 5440:   while (ptContent &&
41636:          (!ptContent->IsElement() ||
26031:           ptContent->IsInAnonymousSubtree())) {
16126:     // XXXldb: Faster to jump to GetBindingParent if non-null?
 5440:     ptContent = ptContent->GetParent();
 5440:   }
 5440:  
 5440:   if (ptContent)
 5440:     CallQueryInterface(ptContent, aReturn);
 5440:   return NS_OK;
 5440: }
 5440: 
40568: nsresult
40568: nsDocument::NodesFromRectHelper(float aX, float aY,
40568:                                 float aTopSize, float aRightSize,
40568:                                 float aBottomSize, float aLeftSize,
40568:                                 PRBool aIgnoreRootScrollFrame,
40568:                                 PRBool aFlushLayout,
40568:                                 nsIDOMNodeList** aReturn)
40568: {
40568:   NS_ENSURE_ARG_POINTER(aReturn);
40568:   
69024:   nsSimpleContentList* elements = new nsSimpleContentList(this);
40568:   NS_ADDREF(elements);
40568:   *aReturn = elements;
40568: 
40568:   // Following the same behavior of elementFromPoint,
40568:   // we don't return anything if either coord is negative
40568:   if (!aIgnoreRootScrollFrame && (aX < 0 || aY < 0))
40568:     return NS_OK;
40568: 
40568:   nscoord x = nsPresContext::CSSPixelsToAppUnits(aX - aLeftSize);
40568:   nscoord y = nsPresContext::CSSPixelsToAppUnits(aY - aTopSize);
40568:   nscoord w = nsPresContext::CSSPixelsToAppUnits(aLeftSize + aRightSize) + 1;
40568:   nscoord h = nsPresContext::CSSPixelsToAppUnits(aTopSize + aBottomSize) + 1;
40568: 
40568:   nsRect rect(x, y, w, h);
40568: 
40568:   // Make sure the layout information we get is up-to-date, and
40568:   // ensure we get a root frame (for everything but XUL)
40568:   if (aFlushLayout) {
40568:     FlushPendingNotifications(Flush_Layout);
40568:   }
40568: 
46225:   nsIPresShell *ps = GetShell();
40568:   NS_ENSURE_STATE(ps);
40568:   nsIFrame *rootFrame = ps->GetRootFrame();
40568: 
40568:   // XUL docs, unlike HTML, have no frame tree until everything's done loading
40568:   if (!rootFrame)
40568:     return NS_OK; // return nothing to premature XUL callers as a reminder to wait
40568: 
40568:   nsTArray<nsIFrame*> outFrames;
40568:   nsLayoutUtils::GetFramesForArea(rootFrame, rect, outFrames,
40568:                                   PR_TRUE, aIgnoreRootScrollFrame);
40568: 
40568:   PRInt32 length = outFrames.Length();
40568:   if (!length)
40568:     return NS_OK;
40568: 
40568:   // Used to filter out repeated elements in sequence.
40568:   nsIContent* lastAdded = nsnull;
40568: 
40568:   for (PRInt32 i = 0; i < length; i++) {
40568: 
40568:     nsIContent* ptContent = outFrames.ElementAt(i)->GetContent();
40568:     NS_ENSURE_STATE(ptContent);
40568: 
40568:     // If the content is in a subdocument, try to get the element from |this| doc
40568:     nsIDocument *currentDoc = ptContent->GetCurrentDoc();
40568:     if (currentDoc && (currentDoc != this)) {
40568:       // XXX felipe: I can't get this type right without the intermediate vars
40568:       nsCOMPtr<nsIDOMElement> x = CheckAncestryAndGetFrame(currentDoc);
40568:       nsCOMPtr<nsIContent> elementDoc = do_QueryInterface(x);
40568:       if (elementDoc != lastAdded) {
40568:         elements->AppendElement(elementDoc);
40568:         lastAdded = elementDoc;
40568:       }
40568:       continue;
40568:     }
40568: 
40568:     // If we have an anonymous element (such as an internal div from a textbox),
40568:     // or a node that isn't an element or a text node,
40568:     // replace it with the first non-anonymous parent node.
40568:     while (ptContent &&
41636:            (!(ptContent->IsElement() ||
40568:               ptContent->IsNodeOfType(nsINode::eTEXT)) ||
40568:             ptContent->IsInAnonymousSubtree())) {
40568:       // XXXldb: Faster to jump to GetBindingParent if non-null?
40568:       ptContent = ptContent->GetParent();
40568:     }
40568:    
40568:     if (ptContent && ptContent != lastAdded) {
40568:       elements->AppendElement(ptContent);
40568:       lastAdded = ptContent;
40568:     }
40568:   }
40568:   return NS_OK;
40568: }
40568: 
 5440: NS_IMETHODIMP
    1: nsDocument::GetElementsByClassName(const nsAString& aClasses,
    1:                                    nsIDOMNodeList** aReturn)
    1: {
41910:   return nsContentUtils::GetElementsByClassName(this, aClasses, aReturn);
    1: }
    1: 
32435: NS_IMETHODIMP
32435: nsDocument::ReleaseCapture()
32435: {
32435:   // only release the capture if the caller can access it. This prevents a
32435:   // page from stopping a scrollbar grab for example.
32435:   nsCOMPtr<nsIDOMNode> node = do_QueryInterface(nsIPresShell::GetCapturingContent());
32435:   if (node && nsContentUtils::CanCallerAccess(node)) {
32435:     nsIPresShell::SetCapturingContent(nsnull, 0);
32435:   }
32435:   return NS_OK;
32435: }
32435: 
    1: nsresult
    1: nsDocument::SetBaseURI(nsIURI* aURI)
    1: {
41221:   if (!aURI && !mDocumentBaseURI) {
41221:     return NS_OK;
41221:   }
41221:   
41221:   // Don't do anything if the URI wasn't actually changed.
41221:   if (aURI && mDocumentBaseURI) {
41221:     PRBool equalBases = PR_FALSE;
41221:     mDocumentBaseURI->Equals(aURI, &equalBases);
41221:     if (equalBases) {
41221:       return NS_OK;
41221:     }
41221:   }
41221: 
    1:   if (aURI) {
    1:     mDocumentBaseURI = NS_TryToMakeImmutable(aURI);
    1:   } else {
    1:     mDocumentBaseURI = nsnull;
    1:   }
33055:   RefreshLinkHrefs();
41221: 
41221:   return NS_OK;
    1: }
    1: 
    1: void
41221: nsDocument::GetBaseTarget(nsAString &aBaseTarget)
41221: {
60507:   aBaseTarget = mBaseTarget;
    1: }
    1: 
    1: void
    1: nsDocument::SetDocumentCharacterSet(const nsACString& aCharSetID)
    1: {
    1:   if (!mCharacterSet.Equals(aCharSetID)) {
    1:     mCharacterSet = aCharSetID;
    1: 
    1: #ifdef DEBUG
    1:     nsCOMPtr<nsICharsetAlias> calias(do_GetService(NS_CHARSETALIAS_CONTRACTID));
    1:     if (calias) {
    1:       nsCAutoString canonicalName;
    1:       calias->GetPreferred(aCharSetID, canonicalName);
    1:       NS_ASSERTION(canonicalName.Equals(aCharSetID),
    1:                    "charset name must be canonical");
    1:     }
    1: #endif
    1: 
26413:     PRInt32 n = mCharSetObservers.Length();
    1: 
    1:     for (PRInt32 i = 0; i < n; i++) {
26413:       nsIObserver* observer = mCharSetObservers.ElementAt(i);
 3233: 
 3233:       observer->Observe(static_cast<nsIDocument *>(this), "charset",
    1:                         NS_ConvertASCIItoUTF16(aCharSetID).get());
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsDocument::AddCharSetObserver(nsIObserver* aObserver)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aObserver);
    1: 
    1:   NS_ENSURE_TRUE(mCharSetObservers.AppendElement(aObserver), NS_ERROR_FAILURE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsDocument::RemoveCharSetObserver(nsIObserver* aObserver)
    1: {
    1:   mCharSetObservers.RemoveElement(aObserver);
    1: }
    1: 
    1: void
    1: nsDocument::GetHeaderData(nsIAtom* aHeaderField, nsAString& aData) const
    1: {
    1:   aData.Truncate();
    1:   const nsDocHeaderData* data = mHeaderData;
    1:   while (data) {
    1:     if (data->mField == aHeaderField) {
    1:       aData = data->mData;
    1: 
    1:       break;
    1:     }
    1:     data = data->mNext;
    1:   }
    1: }
    1: 
    1: void
    1: nsDocument::SetHeaderData(nsIAtom* aHeaderField, const nsAString& aData)
    1: {
    1:   if (!aHeaderField) {
    1:     NS_ERROR("null headerField");
    1:     return;
    1:   }
    1: 
    1:   if (!mHeaderData) {
    1:     if (!aData.IsEmpty()) { // don't bother storing empty string
    1:       mHeaderData = new nsDocHeaderData(aHeaderField, aData);
    1:     }
    1:   }
    1:   else {
    1:     nsDocHeaderData* data = mHeaderData;
    1:     nsDocHeaderData** lastPtr = &mHeaderData;
    1:     PRBool found = PR_FALSE;
    1:     do {  // look for existing and replace
    1:       if (data->mField == aHeaderField) {
    1:         if (!aData.IsEmpty()) {
    1:           data->mData.Assign(aData);
    1:         }
    1:         else {  // don't store empty string
    1:           *lastPtr = data->mNext;
    1:           data->mNext = nsnull;
    1:           delete data;
    1:         }
    1:         found = PR_TRUE;
    1: 
    1:         break;
    1:       }
    1:       lastPtr = &(data->mNext);
    1:       data = *lastPtr;
    1:     } while (data);
    1: 
    1:     if (!aData.IsEmpty() && !found) {
    1:       // didn't find, append
    1:       *lastPtr = new nsDocHeaderData(aHeaderField, aData);
    1:     }
    1:   }
    1: 
    1:   if (aHeaderField == nsGkAtoms::headerContentLanguage) {
    1:     CopyUTF16toUTF8(aData, mContentLanguage);
    1:   }
    1: 
    1:   // Set the default script-type on the root element.
    1:   if (aHeaderField == nsGkAtoms::headerContentScriptType) {
41634:     Element *root = GetRootElement();
    1:     if (root) {
    1:       // Get the script-type ID for this value.
    1:       nsresult rv;
    1:       nsCOMPtr<nsIScriptRuntime> runtime;
    1:       rv = NS_GetScriptRuntime(aData, getter_AddRefs(runtime));
    1:       if (NS_FAILED(rv) || runtime == nsnull) {
    1:         NS_WARNING("The script-type is unknown");
    1:       } else {
    1:         root->SetScriptTypeID(runtime->GetScriptTypeID());
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (aHeaderField == nsGkAtoms::headerDefaultStyle) {
    1:     // Only mess with our stylesheets if we don't have a lastStyleSheetSet, per
    1:     // spec.
    1:     if (DOMStringIsNull(mLastStyleSheetSet)) {
    1:       // Calling EnableStyleSheetsForSetInternal, not SetSelectedStyleSheetSet,
    1:       // per spec.  The idea here is that we're changing our preferred set and
    1:       // that shouldn't change the value of lastStyleSheetSet.  Also, we're
    1:       // using the Internal version so we can update the CSSLoader and not have
    1:       // to worry about null strings.
    1:       EnableStyleSheetsForSetInternal(aData, PR_TRUE);
    1:     }
    1:   }
    1: 
    1:   if (aHeaderField == nsGkAtoms::refresh) {
    1:     // We get into this code before we have a script global yet, so get to
    1:     // our container via mDocumentContainer.
    1:     nsCOMPtr<nsIRefreshURI> refresher = do_QueryReferent(mDocumentContainer);
    1:     if (refresher) {
    1:       // Note: using mDocumentURI instead of mBaseURI here, for consistency
    1:       // (used to just use the current URI of our webnavigation, but that
    1:       // should really be the same thing).  Note that this code can run
    1:       // before the current URI of the webnavigation has been updated, so we
    1:       // can't assert equality here.
    1:       refresher->SetupRefreshURIFromHeader(mDocumentURI,
 6396:                                            NS_ConvertUTF16toUTF8(aData));
    1:     }
    1:   }
28460: 
28460:   if (aHeaderField == nsGkAtoms::headerDNSPrefetchControl &&
28460:       mAllowDNSPrefetch) {
28460:     // Chromium treats any value other than 'on' (case insensitive) as 'off'.
28460:     mAllowDNSPrefetch = aData.IsEmpty() || aData.LowerCaseEqualsLiteral("on");
28460:   }
    1: }
    1: 
    1: PRBool
    1: nsDocument::TryChannelCharset(nsIChannel *aChannel,
    1:                               PRInt32& aCharsetSource,
    1:                               nsACString& aCharset)
    1: {
    1:   if(kCharsetFromChannel <= aCharsetSource) {
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   if (aChannel) {
    1:     nsCAutoString charsetVal;
    1:     nsresult rv = aChannel->GetContentCharset(charsetVal);
    1:     if (NS_SUCCEEDED(rv)) {
    1:       nsCOMPtr<nsICharsetAlias> calias(do_GetService(NS_CHARSETALIAS_CONTRACTID));
    1:       if (calias) {
    1:         nsCAutoString preferred;
    1:         rv = calias->GetPreferred(charsetVal,
    1:                                   preferred);
    1:         if(NS_SUCCEEDED(rv)) {
    1:           aCharset = preferred;
    1:           aCharsetSource = kCharsetFromChannel;
    1:           return PR_TRUE;
    1:         }
    1:       }
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: nsresult
    1: nsDocument::CreateShell(nsPresContext* aContext, nsIViewManager* aViewManager,
    1:                         nsStyleSet* aStyleSet,
    1:                         nsIPresShell** aInstancePtrResult)
    1: {
    1:   // Don't add anything here.  Add it to |doCreateShell| instead.
    1:   // This exists so that subclasses can pass other values for the 4th
    1:   // parameter some of the time.
    1:   return doCreateShell(aContext, aViewManager, aStyleSet,
    1:                        eCompatibility_FullStandards, aInstancePtrResult);
    1: }
    1: 
    1: nsresult
    1: nsDocument::doCreateShell(nsPresContext* aContext,
    1:                           nsIViewManager* aViewManager, nsStyleSet* aStyleSet,
    1:                           nsCompatibility aCompatMode,
    1:                           nsIPresShell** aInstancePtrResult)
    1: {
    1:   *aInstancePtrResult = nsnull;
    1: 
36917:   NS_ASSERTION(!mPresShell, "We have a presshell already!");
36917: 
58185:   NS_ENSURE_FALSE(GetBFCacheEntry(), NS_ERROR_FAILURE);
    1: 
    1:   FillStyleSet(aStyleSet);
    1:   
    1:   nsCOMPtr<nsIPresShell> shell;
    1:   nsresult rv = NS_NewPresShell(getter_AddRefs(shell));
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   rv = shell->Init(this, aContext, aViewManager, aStyleSet, aCompatMode);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Note: we don't hold a ref to the shell (it holds a ref to us)
36917:   mPresShell = shell;
35581: 
49570:   mExternalResourceMap.ShowViewers();
49570: 
63939:   if (mScriptGlobalObject) {
63939:     RescheduleAnimationFrameNotifications();
63939:   }
63939: 
63939:   shell.swap(*aInstancePtrResult);
63939: 
63939:   return NS_OK;
63939: }
63939: 
63939: void
63939: nsDocument::RescheduleAnimationFrameNotifications()
63939: {
52255:   nsRefreshDriver* rd = mPresShell->GetPresContext()->RefreshDriver();
50368:   if (mHavePendingPaint) {
52255:     rd->ScheduleBeforePaintEvent(this);
52255:   }
52255:   if (!mAnimationFrameListeners.IsEmpty()) {
52255:     rd->ScheduleAnimationFrameListeners(this);
50368:   }
    1: }
    1: 
49570: void
52255: nsIDocument::TakeAnimationFrameListeners(AnimationListenerList& aListeners)
52255: {
52255:   aListeners.AppendElements(mAnimationFrameListeners);
52255:   mAnimationFrameListeners.Clear();
52255: }
52255: 
52255: void
49570: nsDocument::DeleteShell()
49570: {
49570:   mExternalResourceMap.HideViewers();
63939:   if (mScriptGlobalObject) {
63939:     RevokeAnimationFrameNotifications();
63939:   }
63939:   mPresShell = nsnull;
63939: }
63939: 
63939: void
63939: nsDocument::RevokeAnimationFrameNotifications()
63939: {
50368:   if (mHavePendingPaint) {
50368:     mPresShell->GetPresContext()->RefreshDriver()->RevokeBeforePaintEvent(this);
50368:   }
52255:   if (!mAnimationFrameListeners.IsEmpty()) {
52255:     mPresShell->GetPresContext()->RefreshDriver()->
52255:       RevokeAnimationFrameListeners(this);
52255:   }
49570: }
49570: 
20261: static void
    1: SubDocClearEntry(PLDHashTable *table, PLDHashEntryHdr *entry)
    1: {
 3233:   SubDocMapEntry *e = static_cast<SubDocMapEntry *>(entry);
    1: 
    1:   NS_RELEASE(e->mKey);
 8462:   if (e->mSubDocument) {
 8462:     e->mSubDocument->SetParentDocument(nsnull);
 8462:     NS_RELEASE(e->mSubDocument);
 8462:   }
    1: }
    1: 
20261: static PRBool
    1: SubDocInitEntry(PLDHashTable *table, PLDHashEntryHdr *entry, const void *key)
    1: {
    1:   SubDocMapEntry *e =
 3233:     const_cast<SubDocMapEntry *>
 3233:               (static_cast<const SubDocMapEntry *>(entry));
 3233: 
 3233:   e->mKey = const_cast<nsIContent *>
 3233:                       (static_cast<const nsIContent *>(key));
    1:   NS_ADDREF(e->mKey);
    1: 
    1:   e->mSubDocument = nsnull;
    1:   return PR_TRUE;
    1: }
    1: 
    1: nsresult
    1: nsDocument::SetSubDocumentFor(nsIContent *aContent, nsIDocument* aSubDoc)
    1: {
    1:   NS_ENSURE_TRUE(aContent, NS_ERROR_UNEXPECTED);
    1: 
    1:   if (!aSubDoc) {
    1:     // aSubDoc is nsnull, remove the mapping
    1: 
    1:     if (mSubDocuments) {
    1:       SubDocMapEntry *entry =
 3233:         static_cast<SubDocMapEntry*>
 3233:                    (PL_DHashTableOperate(mSubDocuments, aContent,
    1:                                             PL_DHASH_LOOKUP));
    1: 
    1:       if (PL_DHASH_ENTRY_IS_BUSY(entry)) {
    1:         PL_DHashTableRawRemove(mSubDocuments, entry);
    1:       }
    1:     }
    1:   } else {
    1:     if (!mSubDocuments) {
    1:       // Create a new hashtable
    1: 
    1:       static PLDHashTableOps hash_table_ops =
    1:       {
    1:         PL_DHashAllocTable,
    1:         PL_DHashFreeTable,
    1:         PL_DHashVoidPtrKeyStub,
    1:         PL_DHashMatchEntryStub,
    1:         PL_DHashMoveEntryStub,
    1:         SubDocClearEntry,
    1:         PL_DHashFinalizeStub,
    1:         SubDocInitEntry
    1:       };
    1: 
    1:       mSubDocuments = PL_NewDHashTable(&hash_table_ops, nsnull,
    1:                                        sizeof(SubDocMapEntry), 16);
    1:       if (!mSubDocuments) {
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:       }
    1:     }
    1: 
    1:     // Add a mapping to the hash table
    1:     SubDocMapEntry *entry =
 3233:       static_cast<SubDocMapEntry*>
 3233:                  (PL_DHashTableOperate(mSubDocuments, aContent,
    1:                                           PL_DHASH_ADD));
    1: 
    1:     if (!entry) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     if (entry->mSubDocument) {
    1:       entry->mSubDocument->SetParentDocument(nsnull);
    1: 
    1:       // Release the old sub document
    1:       NS_RELEASE(entry->mSubDocument);
    1:     }
    1: 
    1:     entry->mSubDocument = aSubDoc;
    1:     NS_ADDREF(entry->mSubDocument);
    1: 
    1:     aSubDoc->SetParentDocument(this);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsIDocument*
    1: nsDocument::GetSubDocumentFor(nsIContent *aContent) const
    1: {
    1:   if (mSubDocuments) {
    1:     SubDocMapEntry *entry =
 3233:       static_cast<SubDocMapEntry*>
 3233:                  (PL_DHashTableOperate(mSubDocuments, aContent,
    1:                                           PL_DHASH_LOOKUP));
    1: 
    1:     if (PL_DHASH_ENTRY_IS_BUSY(entry)) {
    1:       return entry->mSubDocument;
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
20261: static PLDHashOperator
    1: FindContentEnumerator(PLDHashTable *table, PLDHashEntryHdr *hdr,
    1:                       PRUint32 number, void *arg)
    1: {
 3233:   SubDocMapEntry *entry = static_cast<SubDocMapEntry*>(hdr);
 3233:   FindContentData *data = static_cast<FindContentData*>(arg);
    1: 
    1:   if (entry->mSubDocument == data->mSubDocument) {
    1:     data->mResult = entry->mKey;
    1: 
    1:     return PL_DHASH_STOP;
    1:   }
    1: 
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
    1: nsIContent*
    1: nsDocument::FindContentForSubDocument(nsIDocument *aDocument) const
    1: {
    1:   NS_ENSURE_TRUE(aDocument, nsnull);
    1: 
    1:   if (!mSubDocuments) {
    1:     return nsnull;
    1:   }
    1: 
    1:   FindContentData data(aDocument);
    1:   PL_DHashTableEnumerate(mSubDocuments, FindContentEnumerator, &data);
    1: 
    1:   return data.mResult;
    1: }
    1: 
    1: PRBool
    1: nsDocument::IsNodeOfType(PRUint32 aFlags) const
    1: {
    1:     return !(aFlags & ~eDOCUMENT);
    1: }
    1: 
71768: PRUint16
71768: nsDocument::NodeType()
71768: {
71768:     return (PRUint16)nsIDOMNode::DOCUMENT_NODE;
71768: }
71768: 
71768: void
71768: nsDocument::NodeName(nsAString& aNodeName)
71768: {
71768:   aNodeName.AssignLiteral("#document");
71768: }
71768: 
41634: Element*
41634: nsDocument::GetRootElementInternal() const
 8938: {
 8938:   // Loop backwards because any non-elements, such as doctypes and PIs
 8938:   // are likely to appear before the root element.
 8938:   PRUint32 i;
 8938:   for (i = mChildren.ChildCount(); i > 0; --i) {
 8938:     nsIContent* child = mChildren.ChildAt(i - 1);
41634:     if (child->IsElement()) {
41634:       const_cast<nsDocument*>(this)->mCachedRootElement = child;
41634:       return child->AsElement();
41634:     }
41634:   }
41634:   
41634:   const_cast<nsDocument*>(this)->mCachedRootElement = nsnull;
 8938:   return nsnull;
 8938: }
 8938: 
 8938: nsIContent *
    1: nsDocument::GetChildAt(PRUint32 aIndex) const
    1: {
    1:   return mChildren.GetSafeChildAt(aIndex);
    1: }
    1: 
    1: PRInt32
    1: nsDocument::IndexOf(nsINode* aPossibleChild) const
    1: {
    1:   return mChildren.IndexOfChild(aPossibleChild);
    1: }
    1: 
    1: PRUint32
    1: nsDocument::GetChildCount() const
    1: {
    1:   return mChildren.ChildCount();
    1: }
    1: 
15810: nsIContent * const *
22251: nsDocument::GetChildArray(PRUint32* aChildCount) const
22251: {
22251:   return mChildren.GetChildArray(aChildCount);
15810: }
15810:   
15810: 
    1: nsresult
    1: nsDocument::InsertChildAt(nsIContent* aKid, PRUint32 aIndex,
    1:                           PRBool aNotify)
    1: {
41634:   if (aKid->IsElement() && GetRootElement()) {
    1:     NS_ERROR("Inserting element child when we already have one");
    1:     return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
    1:   }
    1: 
42105:   return doInsertChildAt(aKid, aIndex, aNotify, mChildren);
    1: }
    1: 
    1: nsresult
    1: nsDocument::AppendChildTo(nsIContent* aKid, PRBool aNotify)
    1: {
    1:   // Make sure to _not_ call the subclass InsertChildAt here.  If
    1:   // subclasses wanted to hook into this stuff, they would have
    1:   // overridden AppendChildTo.
    1:   // XXXbz maybe this should just be a non-virtual method on nsINode?
    1:   // Feels that way to me...
    1:   return nsDocument::InsertChildAt(aKid, GetChildCount(), aNotify);
    1: }
    1: 
    1: nsresult
70878: nsDocument::RemoveChildAt(PRUint32 aIndex, PRBool aNotify)
70878: {
    1:   nsCOMPtr<nsIContent> oldKid = GetChildAt(aIndex);
 8938:   if (!oldKid) {
 8938:     return NS_OK;
 8938:   }
 8938: 
41636:   if (oldKid->IsElement()) {
 8938:     // Destroy the link map up front before we mess with the child list.
43079:     DestroyElementMaps();
 8938:   }
 8938: 
42105:   nsresult rv =
70878:     doRemoveChildAt(aIndex, aNotify, oldKid, mChildren);
41634:   mCachedRootElement = nsnull;
    1:   return rv;
    1: }
    1: 
    1: PRInt32
    1: nsDocument::GetNumberOfStyleSheets() const
    1: {
    1:   return mStyleSheets.Count();
    1: }
    1: 
    1: nsIStyleSheet*
    1: nsDocument::GetStyleSheetAt(PRInt32 aIndex) const
    1: {
    1:   NS_ENSURE_TRUE(0 <= aIndex && aIndex < mStyleSheets.Count(), nsnull);
    1:   return mStyleSheets[aIndex];
    1: }
    1: 
    1: PRInt32
    1: nsDocument::GetIndexOfStyleSheet(nsIStyleSheet* aSheet) const
    1: {
    1:   return mStyleSheets.IndexOf(aSheet);
    1: }
    1: 
    1: void
    1: nsDocument::AddStyleSheetToStyleSets(nsIStyleSheet* aSheet)
    1: {
46225:   nsCOMPtr<nsIPresShell> shell = GetShell();
36917:   if (shell) {
 1722:     shell->StyleSet()->AddDocStyleSheet(aSheet, this);
    1:   }
    1: }
    1: 
    1: void
    1: nsDocument::AddStyleSheet(nsIStyleSheet* aSheet)
    1: {
    1:   NS_PRECONDITION(aSheet, "null arg");
    1:   mStyleSheets.AppendObject(aSheet);
    1:   aSheet->SetOwningDocument(this);
    1: 
42332:   if (aSheet->IsApplicable()) {
    1:     AddStyleSheetToStyleSets(aSheet);
    1:   }
    1: 
    1:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleSheetAdded, (this, aSheet, PR_TRUE));
    1: }
    1: 
    1: void
    1: nsDocument::RemoveStyleSheetFromStyleSets(nsIStyleSheet* aSheet)
    1: {
46225:   nsCOMPtr<nsIPresShell> shell = GetShell();
36917:   if (shell) {
 1722:     shell->StyleSet()->RemoveStyleSheet(nsStyleSet::eDocSheet, aSheet);
 1722:   }
    1: }
    1: 
    1: void
    1: nsDocument::RemoveStyleSheet(nsIStyleSheet* aSheet)
    1: {
    1:   NS_PRECONDITION(aSheet, "null arg");
    1:   nsCOMPtr<nsIStyleSheet> sheet = aSheet; // hold ref so it won't die too soon
    1: 
    1:   if (!mStyleSheets.RemoveObject(aSheet)) {
    1:     NS_NOTREACHED("stylesheet not found");
    1:     return;
    1:   }
    1: 
    1:   if (!mIsGoingAway) {
42332:     if (aSheet->IsApplicable()) {
    1:       RemoveStyleSheetFromStyleSets(aSheet);
    1:     }
    1: 
    1:     NS_DOCUMENT_NOTIFY_OBSERVERS(StyleSheetRemoved, (this, aSheet, PR_TRUE));
    1:   }
    1: 
    1:   aSheet->SetOwningDocument(nsnull);
    1: }
    1: 
    1: void
    1: nsDocument::UpdateStyleSheets(nsCOMArray<nsIStyleSheet>& aOldSheets,
    1:                               nsCOMArray<nsIStyleSheet>& aNewSheets)
    1: {
    1:   BeginUpdate(UPDATE_STYLE);
    1: 
    1:   // XXX Need to set the sheet on the ownernode, if any
    1:   NS_PRECONDITION(aOldSheets.Count() == aNewSheets.Count(),
    1:                   "The lists must be the same length!");
    1:   PRInt32 count = aOldSheets.Count();
    1: 
    1:   nsCOMPtr<nsIStyleSheet> oldSheet;
    1:   PRInt32 i;
    1:   for (i = 0; i < count; ++i) {
    1:     oldSheet = aOldSheets[i];
    1: 
    1:     // First remove the old sheet.
    1:     NS_ASSERTION(oldSheet, "None of the old sheets should be null");
    1:     PRInt32 oldIndex = mStyleSheets.IndexOf(oldSheet);
    1:     RemoveStyleSheet(oldSheet);  // This does the right notifications
    1: 
    1:     // Now put the new one in its place.  If it's null, just ignore it.
    1:     nsIStyleSheet* newSheet = aNewSheets[i];
    1:     if (newSheet) {
    1:       mStyleSheets.InsertObjectAt(newSheet, oldIndex);
    1:       newSheet->SetOwningDocument(this);
42332:       if (newSheet->IsApplicable()) {
    1:         AddStyleSheetToStyleSets(newSheet);
    1:       }
    1: 
    1:       NS_DOCUMENT_NOTIFY_OBSERVERS(StyleSheetAdded, (this, newSheet, PR_TRUE));
    1:     }
    1:   }
    1: 
    1:   EndUpdate(UPDATE_STYLE);
    1: }
    1: 
    1: void
    1: nsDocument::InsertStyleSheetAt(nsIStyleSheet* aSheet, PRInt32 aIndex)
    1: {
    1:   NS_PRECONDITION(aSheet, "null ptr");
    1:   mStyleSheets.InsertObjectAt(aSheet, aIndex);
    1: 
    1:   aSheet->SetOwningDocument(this);
    1: 
42332:   if (aSheet->IsApplicable()) {
    1:     AddStyleSheetToStyleSets(aSheet);
    1:   }
    1: 
    1:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleSheetAdded, (this, aSheet, PR_TRUE));
    1: }
    1: 
    1: 
    1: void
    1: nsDocument::SetStyleSheetApplicableState(nsIStyleSheet* aSheet,
    1:                                          PRBool aApplicable)
    1: {
    1:   NS_PRECONDITION(aSheet, "null arg");
    1: 
    1:   // If we're actually in the document style sheet list
    1:   if (-1 != mStyleSheets.IndexOf(aSheet)) {
    1:     if (aApplicable) {
    1:       AddStyleSheetToStyleSets(aSheet);
    1:     } else {
    1:       RemoveStyleSheetFromStyleSets(aSheet);
    1:     }
    1:   }
    1: 
    1:   // We have to always notify, since this will be called for sheets
    1:   // that are children of sheets in our style set, as well as some
    1:   // sheets for nsHTMLEditor.
    1: 
    1:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleSheetApplicableStateChanged,
    1:                                (this, aSheet, aApplicable));
    1: }
    1: 
    1: // These three functions are a lot like the implementation of the
    1: // corresponding API for regular stylesheets.
    1: 
    1: PRInt32
    1: nsDocument::GetNumberOfCatalogStyleSheets() const
    1: {
    1:   return mCatalogSheets.Count();
    1: }
    1: 
    1: nsIStyleSheet*
    1: nsDocument::GetCatalogStyleSheetAt(PRInt32 aIndex) const
    1: {
    1:   NS_ENSURE_TRUE(0 <= aIndex && aIndex < mCatalogSheets.Count(), nsnull);
    1:   return mCatalogSheets[aIndex];
    1: }
    1: 
    1: void
    1: nsDocument::AddCatalogStyleSheet(nsIStyleSheet* aSheet)
    1: {
    1:   mCatalogSheets.AppendObject(aSheet);
    1:   aSheet->SetOwningDocument(this);
    1: 
42332:   if (aSheet->IsApplicable()) {
    1:     // This is like |AddStyleSheetToStyleSets|, but for an agent sheet.
46225:     nsCOMPtr<nsIPresShell> shell = GetShell();
36917:     if (shell) {
 1722:       shell->StyleSet()->AppendStyleSheet(nsStyleSet::eAgentSheet, aSheet);
 1722:     }
    1:   }
    1:                                                                                 
    1:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleSheetAdded, (this, aSheet, PR_FALSE));
    1: }
    1: 
    1: void
    1: nsDocument::EnsureCatalogStyleSheet(const char *aStyleSheetURI)
    1: {
38851:   mozilla::css::Loader* cssLoader = CSSLoader();
38851:   if (cssLoader->GetEnabled()) {
    1:     PRInt32 sheetCount = GetNumberOfCatalogStyleSheets();
    1:     for (PRInt32 i = 0; i < sheetCount; i++) {
    1:       nsIStyleSheet* sheet = GetCatalogStyleSheetAt(i);
    1:       NS_ASSERTION(sheet, "unexpected null stylesheet in the document");
    1:       if (sheet) {
    1:         nsCAutoString uriStr;
42400:         sheet->GetSheetURI()->GetSpec(uriStr);
    1:         if (uriStr.Equals(aStyleSheetURI))
    1:           return;
    1:       }
    1:     }
    1: 
    1:     nsCOMPtr<nsIURI> uri;
    1:     NS_NewURI(getter_AddRefs(uri), aStyleSheetURI);
    1:     if (uri) {
42163:       nsRefPtr<nsCSSStyleSheet> sheet;
26242:       cssLoader->LoadSheetSync(uri, PR_TRUE, PR_TRUE, getter_AddRefs(sheet));
    1:       if (sheet) {
    1:         BeginUpdate(UPDATE_STYLE);
    1:         AddCatalogStyleSheet(sheet);
    1:         EndUpdate(UPDATE_STYLE);
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: nsIScriptGlobalObject*
    1: nsDocument::GetScriptGlobalObject() const
    1: {
    1:    // If we're going away, we've already released the reference to our
    1:    // ScriptGlobalObject.  We can, however, try to obtain it for the
    1:    // caller through our docshell.
    1: 
14469:    // We actually need to start returning the docshell's script global
14469:    // object as soon as nsDocumentViewer::Close has called
14469:    // RemovedFromDocShell on us.
14469:    if (mRemovedFromDocShell) {
    1:      nsCOMPtr<nsIInterfaceRequestor> requestor =
    1:        do_QueryReferent(mDocumentContainer);
    1:      if (requestor) {
    1:        nsCOMPtr<nsIScriptGlobalObject> globalObject = do_GetInterface(requestor);
    1:        return globalObject;
    1:      }
    1:    }
    1: 
    1:    return mScriptGlobalObject;
    1: }
    1: 
    1: nsIScriptGlobalObject*
    1: nsDocument::GetScopeObject()
    1: {
    1:   nsCOMPtr<nsIScriptGlobalObject> scope(do_QueryReferent(mScopeObject));
    1:   return scope;
    1: }
    1: 
34207: static void
34207: NotifyActivityChanged(nsIContent *aContent, void *aUnused)
34207: {
34207: #ifdef MOZ_MEDIA
34207:   nsCOMPtr<nsIDOMHTMLMediaElement> domMediaElem(do_QueryInterface(aContent));
34207:   if (domMediaElem) {
34207:     nsHTMLMediaElement* mediaElem = static_cast<nsHTMLMediaElement*>(aContent);
34207:     mediaElem->NotifyOwnerDocumentActivityChanged();
34207:   }
34207: #endif
34207: }
34207: 
34207: void
34207: nsIDocument::SetContainer(nsISupports* aContainer)
34207: {
34207:   mDocumentContainer = do_GetWeakReference(aContainer);
34207:   EnumerateFreezableElements(NotifyActivityChanged, nsnull);
34207: }
34207: 
    1: void
    1: nsDocument::SetScriptGlobalObject(nsIScriptGlobalObject *aScriptGlobalObject)
    1: {
    1: #ifdef DEBUG
    1:   {
    1:     nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(aScriptGlobalObject));
    1: 
    1:     NS_ASSERTION(!win || win->IsInnerWindow(),
    1:                  "Script global object must be an inner window!");
    1:   }
    1: #endif
36915: #ifdef MOZ_SMIL
36864:   NS_ABORT_IF_FALSE(aScriptGlobalObject || !mAnimationController ||
36864:                     mAnimationController->IsPausedByType(
36864:                         nsSMILTimeContainer::PAUSE_PAGEHIDE |
36864:                         nsSMILTimeContainer::PAUSE_BEGIN),
36864:                     "Clearing window pointer while animations are unpaused");
36915: #endif // MOZ_SMIL
    1: 
    1:   if (mScriptGlobalObject && !aScriptGlobalObject) {
    1:     // We're detaching from the window.  We need to grab a pointer to
    1:     // our layout history state now.
    1:     mLayoutHistoryState = GetLayoutHistoryState();
    1: 
63939:     if (mPresShell) {
63939:       RevokeAnimationFrameNotifications();
63939:     }
63939: 
    1:     // Also make sure to remove our onload blocker now if we haven't done it yet
    1:     if (mOnloadBlockCount != 0) {
    1:       nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
    1:       if (loadGroup) {
    1:         loadGroup->RemoveRequest(mOnloadBlocker, nsnull, NS_OK);
    1:       }
    1:     }
    1:   }
    1: 
    1:   mScriptGlobalObject = aScriptGlobalObject;
    1: 
    1:   if (aScriptGlobalObject) {
18343:     mScriptObject = nsnull;
 6475:     mHasHadScriptHandlingObject = PR_TRUE;
    1:     // Go back to using the docshell for the layout history state
    1:     mLayoutHistoryState = nsnull;
    1:     mScopeObject = do_GetWeakReference(aScriptGlobalObject);
28460: 
29979: #ifdef DEBUG
31428:     if (!mWillReparent) {
29979:       // We really shouldn't have a wrapper here but if we do we need to make sure
29979:       // it has the correct parent.
62690:       JSObject *obj = GetWrapperPreserveColor();
29420:       if (obj) {
29420:         JSObject *newScope = aScriptGlobalObject->GetGlobalJSObject();
29420:         nsIScriptContext *scx = aScriptGlobalObject->GetContext();
29420:         JSContext *cx = scx ? (JSContext *)scx->GetNativeContext() : nsnull;
29420:         if (!cx) {
29420:           nsContentUtils::ThreadJSContextStack()->Peek(&cx);
29420:           if (!cx) {
29420:             nsContentUtils::ThreadJSContextStack()->GetSafeJSContext(&cx);
29420:             NS_ASSERTION(cx, "Uhoh, no context, this is bad!");
29420:           }
29420:         }
29420:         if (cx) {
29979:           NS_ASSERTION(JS_GetGlobalForObject(cx, obj) == newScope,
29979:                        "Wrong scope, this is really bad!");
29979:         }
29979:       }
31428:     }
29979: #endif
29420: 
28460:     if (mAllowDNSPrefetch) {
28460:       nsCOMPtr<nsIDocShell> docShell = do_QueryReferent(mDocumentContainer);
28460:       if (docShell) {
28460: #ifdef DEBUG
28460:         nsCOMPtr<nsIWebNavigation> webNav =
28460:           do_GetInterface(aScriptGlobalObject);
28460:         NS_ASSERTION(SameCOMIdentity(webNav, docShell),
28460:                      "Unexpected container or script global?");
28460: #endif
28460:         PRBool allowDNSPrefetch;
28460:         docShell->GetAllowDNSPrefetch(&allowDNSPrefetch);
28460:         mAllowDNSPrefetch = allowDNSPrefetch;
28460:       }
28460:     }
63939: 
63939:     if (mPresShell) {
63939:       RescheduleAnimationFrameNotifications();
63939:     }
    1:   }
 9596: 
 9596:   // Remember the pointer to our window (or lack there of), to avoid
 9596:   // having to QI every time it's asked for.
 9596:   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(mScriptGlobalObject);
 9596:   mWindow = window;
    1: }
    1: 
 6475: nsIScriptGlobalObject*
42823: nsDocument::GetScriptHandlingObjectInternal() const
42823: {
42823:   NS_ASSERTION(!mScriptGlobalObject,
42823:                "Do not call this when mScriptGlobalObject is set!");
 6475: 
 6475:   nsCOMPtr<nsIScriptGlobalObject> scriptHandlingObject =
 6475:     do_QueryReferent(mScriptObject);
 8094:   nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(scriptHandlingObject);
 8094:   if (win) {
 8947:     NS_ASSERTION(win->IsInnerWindow(), "Should have inner window here!");
 8094:     nsPIDOMWindow* outer = win->GetOuterWindow();
 8094:     if (!outer || outer->GetCurrentInnerWindow() != win) {
 8094:       NS_WARNING("Wrong inner/outer window combination!");
 8094:       return nsnull;
 8094:     }
 8094:   }
 6475:   return scriptHandlingObject;
 6475: }
 6475: void
 6475: nsDocument::SetScriptHandlingObject(nsIScriptGlobalObject* aScriptObject)
 6475: {
 6475:   NS_ASSERTION(!mScriptGlobalObject ||
 6475:                mScriptGlobalObject == aScriptObject,
 6475:                "Wrong script object!");
 8947:   nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(aScriptObject);
 8947:   NS_ASSERTION(!win || win->IsInnerWindow(), "Should have inner window here!");
15633:   mScopeObject = mScriptObject = do_GetWeakReference(aScriptObject);
 6475:   if (aScriptObject) {
 6475:     mHasHadScriptHandlingObject = PR_TRUE;
 6475:   }
 6475: }
 6475: 
    1: nsPIDOMWindow *
63954: nsDocument::GetWindowInternal() const
41409: {
41409:   NS_ASSERTION(!mWindow, "This should not be called when mWindow is not null!");
 9596: 
    1:   nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(GetScriptGlobalObject()));
    1: 
    1:   if (!win) {
    1:     return nsnull;
    1:   }
    1: 
    1:   return win->GetOuterWindow();
    1: }
    1: 
    1: nsPIDOMWindow *
40925: nsDocument::GetInnerWindowInternal()
40925: {
40925:   NS_ASSERTION(mRemovedFromDocShell,
40925:                "This document should have been removed from docshell!");
22210: 
    1:   nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(GetScriptGlobalObject()));
    1: 
    1:   return win;
    1: }
    1: 
    1: nsScriptLoader*
 2007: nsDocument::ScriptLoader()
 2007: {
    1:   return mScriptLoader;
    1: }
    1: 
51393: PRBool
51393: nsDocument::InternalAllowXULXBL()
51393: {
58024:   if (nsContentUtils::AllowXULXBLForPrincipal(NodePrincipal())) {
51393:     mAllowXULXBL = eTriTrue;
51393:     return PR_TRUE;
51393:   }
51393: 
51393:   mAllowXULXBL = eTriFalse;
51393:   return PR_FALSE;
51393: }
51393: 
    1: // Note: We don't hold a reference to the document observer; we assume
    1: // that it has a live reference to the document.
    1: void
    1: nsDocument::AddObserver(nsIDocumentObserver* aObserver)
    1: {
57140:   NS_ASSERTION(mObservers.IndexOf(aObserver) == nsTArray<int>::NoIndex,
41925:                "Observer already in the list");
41925:   mObservers.AppendElement(aObserver);
    1:   AddMutationObserver(aObserver);
    1: }
    1: 
    1: PRBool
    1: nsDocument::RemoveObserver(nsIDocumentObserver* aObserver)
    1: {
    1:   // If we're in the process of destroying the document (and we're
    1:   // informing the observers of the destruction), don't remove the
    1:   // observers from the list. This is not a big deal, since we
    1:   // don't hold a live reference to the observers.
    1:   if (!mInDestructor) {
    1:     RemoveMutationObserver(aObserver);
 9536:     return mObservers.RemoveElement(aObserver);
    1:   }
    1: 
    1:   return mObservers.Contains(aObserver);
    1: }
    1: 
    1: void
24482: nsDocument::MaybeEndOutermostXBLUpdate()
24482: {
24482:   // Only call BindingManager()->EndOutermostUpdate() when
24482:   // we're not in an update and it is safe to run scripts.
24482:   if (mUpdateNestLevel == 0 && mInXBLUpdate) {
24482:     if (nsContentUtils::IsSafeToRunScript()) {
24482:       mInXBLUpdate = PR_FALSE;
24482:       BindingManager()->EndOutermostUpdate();
24482:     } else if (!mInDestructor) {
24482:       nsContentUtils::AddScriptRunner(
41361:         NS_NewRunnableMethod(this, &nsDocument::MaybeEndOutermostXBLUpdate));
24482:     }
24482:   }
24482: }
24482: 
24482: void
    1: nsDocument::BeginUpdate(nsUpdateType aUpdateType)
    1: {
24482:   if (mUpdateNestLevel == 0 && !mInXBLUpdate) {
24482:     mInXBLUpdate = PR_TRUE;
13669:     BindingManager()->BeginOutermostUpdate();
 2025:   }
 2025:   
    1:   ++mUpdateNestLevel;
13098:   nsContentUtils::AddScriptBlocker();
26217:   NS_DOCUMENT_NOTIFY_OBSERVERS(BeginUpdate, (this, aUpdateType));
14319: }
    1: 
    1: void
    1: nsDocument::EndUpdate(nsUpdateType aUpdateType)
    1: {
26217:   NS_DOCUMENT_NOTIFY_OBSERVERS(EndUpdate, (this, aUpdateType));
26217: 
13098:   nsContentUtils::RemoveScriptBlocker();
    1: 
    1:   --mUpdateNestLevel;
24482: 
 2025:   // This set of updates may have created XBL bindings.  Let the
 2025:   // binding manager know we're done.
24482:   MaybeEndOutermostXBLUpdate();
24482: 
24482:   MaybeInitializeFinalizeFrameLoaders();
    1: }
    1: 
    1: void
    1: nsDocument::BeginLoad()
    1: {
    1:   // Block onload here to prevent having to deal with blocking and
    1:   // unblocking it while we know the document is loading.
    1:   BlockOnload();
    1: 
16373:   if (mScriptLoader) {
16373:     mScriptLoader->BeginDeferringScripts();
16373:   }
16373: 
    1:   NS_DOCUMENT_NOTIFY_OBSERVERS(BeginLoad, (this));
    1: }
    1: 
43946: void
43946: nsDocument::ReportEmptyGetElementByIdArg()
43946: {
43946:   nsContentUtils::ReportToConsole(nsContentUtils::eDOM_PROPERTIES,
    1:                                   "EmptyGetElementByIdParam",
    1:                                   nsnull, 0,
    1:                                   nsnull,
    1:                                   EmptyString(), 0, 0,
    1:                                   nsIScriptError::warningFlag,
59513:                                   "DOM", this);
    1: }
    1: 
42425: Element*
43079: nsDocument::GetElementById(const nsAString& aElementId)
42425: {
43946:   if (!CheckGetElementByIdArg(aElementId)) {
42425:     return nsnull;
42425:   }
42425: 
43946:   nsIdentifierMapEntry *entry = mIdentifierMap.GetEntry(aElementId);
43079:   return entry ? entry->GetIdElement() : nsnull;
42425: }
42425: 
42425: NS_IMETHODIMP
42425: nsDocument::GetElementById(const nsAString& aId, nsIDOMElement** aReturn)
42425: {
43079:   Element *content = GetElementById(aId);
42425:   if (content) {
43079:     return CallQueryInterface(content, aReturn);
43079:   }
43079: 
42156:   *aReturn = nsnull;
43079: 
43079:   return NS_OK;
15474: }
15474: 
42325: Element*
15515: nsDocument::AddIDTargetObserver(nsIAtom* aID, IDTargetObserver aObserver,
50428:                                 void* aData, PRBool aForImage)
15515: {
43946:   nsDependentAtomString id(aID);
43946: 
43946:   if (!CheckGetElementByIdArg(id))
15515:     return nsnull;
15515: 
43946:   nsIdentifierMapEntry *entry = mIdentifierMap.PutEntry(id);
15515:   NS_ENSURE_TRUE(entry, nsnull);
15515: 
50428:   entry->AddContentChangeCallback(aObserver, aData, aForImage);
50428:   return aForImage ? entry->GetImageIdElement() : entry->GetIdElement();
15515: }
15515: 
15515: void
50428: nsDocument::RemoveIDTargetObserver(nsIAtom* aID, IDTargetObserver aObserver,
50428:                                    void* aData, PRBool aForImage)
15515: {
43946:   nsDependentAtomString id(aID);
43946: 
43946:   if (!CheckGetElementByIdArg(id))
15515:     return;
15515: 
43946:   nsIdentifierMapEntry *entry = mIdentifierMap.GetEntry(id);
22725:   if (!entry) {
15515:     return;
22725:   }
15515: 
50428:   entry->RemoveContentChangeCallback(aObserver, aData, aForImage);
50428: }
50428: 
50428: NS_IMETHODIMP
50428: nsDocument::MozSetImageElement(const nsAString& aImageElementId,
50428:                                nsIDOMElement* aImageElement)
50428: {
50428:   if (aImageElementId.IsEmpty())
50428:     return NS_OK;
50428: 
63249:   // Hold a script blocker while calling SetImageElement since that can call
63249:   // out to id-observers
63249:   nsAutoScriptBlocker scriptBlocker;
63249: 
50428:   nsCOMPtr<nsIContent> content = do_QueryInterface(aImageElement);
50428:   nsIdentifierMapEntry *entry = mIdentifierMap.PutEntry(aImageElementId);
50428:   if (entry) {
50428:     entry->SetImageElement(content ? content->AsElement() : nsnull);
50428:     if (entry->IsEmpty()) {
50428:       mIdentifierMap.RemoveEntry(aImageElementId);
50428:     }
50428:   }
50428:   return NS_OK;
50428: }
50428: 
50428: Element*
50428: nsDocument::LookupImageElement(const nsAString& aId)
50428: {
50428:   if (aId.IsEmpty())
50428:     return nsnull;
50428: 
63586:   nsIdentifierMapEntry *entry = mIdentifierMap.GetEntry(aId);
50428:   return entry ? entry->GetImageIdElement() : nsnull;
15515: }
15515: 
    1: void
    1: nsDocument::DispatchContentLoadedEvents()
    1: {
41653:   NS_TIME_FUNCTION;
 6205:   // If you add early returns from this method, make sure you're
 6205:   // calling UnblockOnload properly.
 6205:   
30065:   // Unpin references to preloaded images
30065:   mPreloadingImages.Clear();
30065: 
72298:   if (mTiming) {
72298:     mTiming->NotifyDOMContentLoadedStart(nsIDocument::GetDocumentURI());
72298:   }
72298:     
    1:   // Fire a DOM event notifying listeners that this document has been
    1:   // loaded (excluding images and other loads initiated by this
    1:   // document).
 3233:   nsContentUtils::DispatchTrustedEvent(this, static_cast<nsIDocument*>(this),
    1:                                        NS_LITERAL_STRING("DOMContentLoaded"),
    1:                                        PR_TRUE, PR_TRUE);
    1: 
72298:   if (mTiming) {
72298:     mTiming->NotifyDOMContentLoadedEnd(nsIDocument::GetDocumentURI());
72298:   }
72298: 
    1:   // If this document is a [i]frame, fire a DOMFrameContentLoaded
    1:   // event on all parent documents notifying that the HTML (excluding
    1:   // other external files such as images and stylesheets) in a frame
    1:   // has finished loading.
    1: 
    1:   // target_frame is the [i]frame element that will be used as the
    1:   // target for the event. It's the [i]frame whose content is done
    1:   // loading.
    1:   nsCOMPtr<nsIDOMEventTarget> target_frame;
    1: 
11417:   if (mParentDocument) {
11417:     target_frame =
11417:       do_QueryInterface(mParentDocument->FindContentForSubDocument(this));
    1:   }
    1: 
    1:   if (target_frame) {
11417:     nsCOMPtr<nsIDocument> parent = mParentDocument;
14930:     do {
70359:       nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(parent);
    1: 
    1:       nsCOMPtr<nsIDOMEvent> event;
    1:       nsCOMPtr<nsIPrivateDOMEvent> privateEvent;
70359:       if (domDoc) {
70359:         domDoc->CreateEvent(NS_LITERAL_STRING("Events"),
    1:                             getter_AddRefs(event));
    1: 
    1:         privateEvent = do_QueryInterface(event);
    1:       }
    1: 
    1:       if (event && privateEvent) {
    1:         event->InitEvent(NS_LITERAL_STRING("DOMFrameContentLoaded"), PR_TRUE,
    1:                          PR_TRUE);
    1: 
    1:         privateEvent->SetTarget(target_frame);
    1:         privateEvent->SetTrusted(PR_TRUE);
    1: 
    1:         // To dispatch this event we must manually call
    1:         // nsEventDispatcher::Dispatch() on the ancestor document since the
    1:         // target is not in the same document, so the event would never reach
    1:         // the ancestor document if we used the normal event
    1:         // dispatching code.
    1: 
20234:         nsEvent* innerEvent = privateEvent->GetInternalNSEvent();
    1:         if (innerEvent) {
    1:           nsEventStatus status = nsEventStatus_eIgnore;
    1: 
46225:           nsIPresShell *shell = parent->GetShell();
    1:           if (shell) {
39823:             nsRefPtr<nsPresContext> context = shell->GetPresContext();
    1: 
    1:             if (context) {
11417:               nsEventDispatcher::Dispatch(parent, context, innerEvent, event,
11417:                                           &status);
11417:             }
11417:           }
11417:         }
11417:       }
14930:       
14930:       parent = parent->GetParentDocument();
14930:     } while (parent);
    1:   }
 6205: 
25379:   // If the document has a manifest attribute, fire a MozApplicationManifest
25379:   // event.
41634:   Element* root = GetRootElement();
25379:   if (root && root->HasAttr(kNameSpaceID_None, nsGkAtoms::manifest)) {
25379:     nsContentUtils::DispatchChromeEvent(this, static_cast<nsIDocument*>(this),
25379:                                         NS_LITERAL_STRING("MozApplicationManifest"),
25379:                                         PR_TRUE, PR_TRUE);
25379:   }
25379: 
 6205:   UnblockOnload(PR_TRUE);
    1: }
    1: 
    1: void
    1: nsDocument::EndLoad()
    1: {
 6177:   // Drop the ref to our parser, if any, but keep hold of the sink so that we
 6177:   // can flush it from FlushPendingNotifications as needed.  We might have to
 6177:   // do that to get a StartLayout() to happen.
 6170:   if (mParser) {
 6170:     mWeakSink = do_GetWeakReference(mParser->GetContentSink());
    1:     mParser = nsnull;
 6170:   }
    1:   
    1:   NS_DOCUMENT_NOTIFY_OBSERVERS(EndLoad, (this));
24144:   
24144:   if (!mSynchronousDOMContentLoaded) {
24144:     nsRefPtr<nsIRunnable> ev =
41361:       NS_NewRunnableMethod(this, &nsDocument::DispatchContentLoadedEvents);
24144:     NS_DispatchToCurrentThread(ev);
24144:   } else {
24144:     DispatchContentLoadedEvents();
24144:   }
    1: }
    1: 
    1: void
64120: nsDocument::ContentStateChanged(nsIContent* aContent, nsEventStates aStateMask)
64120: {
71103:   NS_PRECONDITION(!nsContentUtils::IsSafeToRunScript(),
71103:                   "Someone forgot a scriptblocker");
64120:   NS_DOCUMENT_NOTIFY_OBSERVERS(ContentStateChanged,
64120:                                (this, aContent, aStateMask));
    1: }
    1: 
    1: void
56168: nsDocument::DocumentStatesChanged(nsEventStates aStateMask)
39698: {
39698:   // Invalidate our cached state.
39698:   mGotDocumentState &= ~aStateMask;
39698:   mDocumentState &= ~aStateMask;
39698: 
39698:   NS_DOCUMENT_NOTIFY_OBSERVERS(DocumentStatesChanged, (this, aStateMask));
39698: }
39698: 
39698: void
    1: nsDocument::StyleRuleChanged(nsIStyleSheet* aStyleSheet,
    1:                              nsIStyleRule* aOldStyleRule,
    1:                              nsIStyleRule* aNewStyleRule)
    1: {
    1:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleRuleChanged,
    1:                                (this, aStyleSheet,
    1:                                 aOldStyleRule, aNewStyleRule));
    1: }
    1: 
    1: void
    1: nsDocument::StyleRuleAdded(nsIStyleSheet* aStyleSheet,
    1:                            nsIStyleRule* aStyleRule)
    1: {
    1:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleRuleAdded,
    1:                                (this, aStyleSheet, aStyleRule));
    1: }
    1: 
    1: void
    1: nsDocument::StyleRuleRemoved(nsIStyleSheet* aStyleSheet,
    1:                              nsIStyleRule* aStyleRule)
    1: {
    1:   NS_DOCUMENT_NOTIFY_OBSERVERS(StyleRuleRemoved,
    1:                                (this, aStyleSheet, aStyleRule));
    1: }
    1: 
    1: 
    1: //
    1: // nsIDOMDocument interface
    1: //
    1: NS_IMETHODIMP
    1: nsDocument::GetDoctype(nsIDOMDocumentType** aDoctype)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aDoctype);
    1: 
    1:   *aDoctype = nsnull;
    1:   PRInt32 i, count;
    1:   count = mChildren.ChildCount();
    1:   for (i = 0; i < count; i++) {
 8938:     CallQueryInterface(mChildren.ChildAt(i), aDoctype);
 8938: 
 8938:     if (*aDoctype) {
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetImplementation(nsIDOMDOMImplementation** aImplementation)
    1: {
34007:   if (!mDOMImplementation) {
    1:     nsCOMPtr<nsIURI> uri;
    1:     NS_NewURI(getter_AddRefs(uri), "about:blank");
    1:     NS_ENSURE_TRUE(uri, NS_ERROR_OUT_OF_MEMORY);
 6475:     PRBool hasHadScriptObject = PR_TRUE;
 6475:     nsIScriptGlobalObject* scriptObject =
 6475:       GetScriptHandlingObject(hasHadScriptObject);
 6475:     NS_ENSURE_STATE(scriptObject || !hasHadScriptObject);
34007:     mDOMImplementation = new nsDOMImplementation(scriptObject, uri, uri,
 6475:                                                  NodePrincipal());
34007:     if (!mDOMImplementation) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
34007:   }
34007: 
34007:   NS_ADDREF(*aImplementation = mDOMImplementation);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetDocumentElement(nsIDOMElement** aDocumentElement)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aDocumentElement);
    1: 
41634:   Element* root = GetRootElement();
 8938:   if (root) {
 8938:     return CallQueryInterface(root, aDocumentElement);
 8938:   }
 8938: 
    1:   *aDocumentElement = nsnull;
 8938: 
 8938:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateElement(const nsAString& aTagName,
    1:                           nsIDOMElement** aReturn)
    1: {
    1:   *aReturn = nsnull;
48124:   nsCOMPtr<nsIContent> content;
48124:   nsresult rv = CreateElement(aTagName, getter_AddRefs(content));
48124:   NS_ENSURE_SUCCESS(rv, rv);
48124:   return CallQueryInterface(content, aReturn);
48124: }
48124: 
48124: PRBool IsLowercaseASCII(const nsAString& aValue)
48124: {
48124:   PRInt32 len = aValue.Length();
48124:   for (PRInt32 i = 0; i < len; ++i) {
48124:     PRUnichar c = aValue[i];
48124:     if (!(0x0061 <= (c) && ((c) <= 0x007a))) {
48124:       return PR_FALSE;
48124:     }
48124:   }
48124:   return PR_TRUE;
48124: }
48124: 
48124: nsresult
48124: nsDocument::CreateElement(const nsAString& aTagName,
48124:                           nsIContent** aReturn)
48124: {
48124:   *aReturn = nsnull;
    1: 
    1:   nsresult rv = nsContentUtils::CheckQName(aTagName, PR_FALSE);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
48124:   PRBool needsLowercase = IsHTML() && !IsLowercaseASCII(aTagName);
48124:   nsAutoString lcTagName;
48124:   if (needsLowercase) {
48124:     ToLowerCase(aTagName, lcTagName);
48124:   }
48124: 
61268:   rv = CreateElem(needsLowercase ? lcTagName : aTagName,
53947:                   nsnull,
48124:                   IsHTML() ? kNameSpaceID_XHTML : GetDefaultNamespaceID(),
48124:                   PR_TRUE, aReturn);
48124:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateElementNS(const nsAString& aNamespaceURI,
    1:                             const nsAString& aQualifiedName,
    1:                             nsIDOMElement** aReturn)
    1: {
    1:   *aReturn = nsnull;
58381:   nsCOMPtr<nsIContent> content;
58381:   nsresult rv = CreateElementNS(aNamespaceURI, aQualifiedName,
58381:                                 getter_AddRefs(content));
58381:   NS_ENSURE_SUCCESS(rv, rv);
58381:   return CallQueryInterface(content, aReturn);
58381: }
58381: 
58381: nsresult
58381: nsDocument::CreateElementNS(const nsAString& aNamespaceURI,
58381:                             const nsAString& aQualifiedName,
58381:                             nsIContent** aReturn)
58381: {
    1:   nsCOMPtr<nsINodeInfo> nodeInfo;
    1:   nsresult rv = nsContentUtils::GetNodeInfoFromQName(aNamespaceURI,
    1:                                                      aQualifiedName,
    1:                                                      mNodeInfoManager,
71770:                                                      nsIDOMNode::ELEMENT_NODE,
    1:                                                      getter_AddRefs(nodeInfo));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
48124:   PRInt32 ns = nodeInfo->NamespaceID();
58391:   return NS_NewElement(aReturn, ns,
58381:                        nodeInfo.forget(), NOT_FROM_PARSER);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateTextNode(const nsAString& aData, nsIDOMText** aReturn)
    1: {
    1:   *aReturn = nsnull;
48124:   nsCOMPtr<nsIContent> content;
48124:   nsresult rv = CreateTextNode(aData, getter_AddRefs(content));
48124:   NS_ENSURE_SUCCESS(rv, rv);
48124:   return CallQueryInterface(content, aReturn);
48124: }
48124: 
48124: nsresult
48124: nsDocument::CreateTextNode(const nsAString& aData, nsIContent** aReturn)
48124: {
48124:   nsresult rv = NS_NewTextNode(aReturn, mNodeInfoManager);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     // Don't notify; this node is still being created.
48124:     (*aReturn)->SetText(aData, PR_FALSE);
48124:   }
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateDocumentFragment(nsIDOMDocumentFragment** aReturn)
    1: {
    1:   return NS_NewDocumentFragment(aReturn, mNodeInfoManager);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateComment(const nsAString& aData, nsIDOMComment** aReturn)
    1: {
    1:   *aReturn = nsnull;
    1: 
    1:   // Make sure the substring "--" is not present in aData.  Otherwise
    1:   // we'll create a document that can't be serialized.
    1:   if (FindInReadable(NS_LITERAL_STRING("--"), aData)) {
    1:     return NS_ERROR_DOM_INVALID_CHARACTER_ERR;
    1:   }
    1: 
    1:   nsCOMPtr<nsIContent> comment;
    1:   nsresult rv = NS_NewCommentNode(getter_AddRefs(comment), mNodeInfoManager);
    1: 
    1:   if (NS_SUCCEEDED(rv)) {
    1:     // Don't notify; this node is still being created.
    1:     comment->SetText(aData, PR_FALSE);
    1: 
    1:     rv = CallQueryInterface(comment, aReturn);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateCDATASection(const nsAString& aData,
    1:                                nsIDOMCDATASection** aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aReturn);
    1:   *aReturn = nsnull;
    1: 
69474:   if (IsHTML()) {
69474:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
69474:   }
69474: 
69474:   if (FindInReadable(NS_LITERAL_STRING("]]>"), aData)) {
    1:     return NS_ERROR_DOM_INVALID_CHARACTER_ERR;
69474:   }
    1: 
    1:   nsCOMPtr<nsIContent> content;
    1:   nsresult rv = NS_NewXMLCDATASection(getter_AddRefs(content),
    1:                                       mNodeInfoManager);
    1: 
    1:   if (NS_SUCCEEDED(rv)) {
    1:     // Don't notify; this node is still being created.
    1:     content->SetText(aData, PR_FALSE);
    1: 
    1:     rv = CallQueryInterface(content, aReturn);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateProcessingInstruction(const nsAString& aTarget,
    1:                                         const nsAString& aData,
    1:                                         nsIDOMProcessingInstruction** aReturn)
    1: {
    1:   *aReturn = nsnull;
    1: 
69474:   // There are no PIs for HTML
69474:   if (IsHTML()) {
69474:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
69474:   }
69474: 
    1:   nsresult rv = nsContentUtils::CheckQName(aTarget, PR_FALSE);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (FindInReadable(NS_LITERAL_STRING("?>"), aData)) {
    1:     return NS_ERROR_DOM_INVALID_CHARACTER_ERR;
    1:   }
    1: 
    1:   nsCOMPtr<nsIContent> content;
    1:   rv = NS_NewXMLProcessingInstruction(getter_AddRefs(content),
    1:                                       mNodeInfoManager, aTarget, aData);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   return CallQueryInterface(content, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateAttribute(const nsAString& aName,
    1:                             nsIDOMAttr** aReturn)
    1: {
    1:   *aReturn = nsnull;
72272: 
72272:   WarnOnceAbout(eCreateAttribute);
72272: 
    1:   NS_ENSURE_TRUE(mNodeInfoManager, NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsresult rv = nsContentUtils::CheckQName(aName, PR_FALSE);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsINodeInfo> nodeInfo;
    1:   rv = mNodeInfoManager->GetNodeInfo(aName, nsnull, kNameSpaceID_None,
71770:                                      nsIDOMNode::ATTRIBUTE_NODE,
    1:                                      getter_AddRefs(nodeInfo));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
72272:   nsAutoString value;
72272:   nsCOMPtr<nsIDOMAttr> attribute =
72272:     new nsDOMAttribute(nsnull, nodeInfo.forget(), value, PR_FALSE);
72272:   attribute.forget(aReturn);
72272:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateAttributeNS(const nsAString & aNamespaceURI,
    1:                               const nsAString & aQualifiedName,
    1:                               nsIDOMAttr **aResult)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aResult);
    1:   *aResult = nsnull;
    1: 
72272:   WarnOnceAbout(eCreateAttributeNS);
72272: 
    1:   nsCOMPtr<nsINodeInfo> nodeInfo;
    1:   nsresult rv = nsContentUtils::GetNodeInfoFromQName(aNamespaceURI,
    1:                                                      aQualifiedName,
    1:                                                      mNodeInfoManager,
71770:                                                      nsIDOMNode::ATTRIBUTE_NODE,
    1:                                                      getter_AddRefs(nodeInfo));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsAutoString value;
72272:   nsCOMPtr<nsIDOMAttr> attribute =
55774:     new nsDOMAttribute(nsnull, nodeInfo.forget(), value, PR_TRUE);
72272:   attribute.forget(aResult);
72272:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetElementsByTagName(const nsAString& aTagname,
    1:                                  nsIDOMNodeList** aReturn)
    1: {
42425:   nsRefPtr<nsContentList> list = GetElementsByTagName(aTagname);
    1:   NS_ENSURE_TRUE(list, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // transfer ref to aReturn
42425:   *aReturn = list.forget().get();
42425:   return NS_OK;
42425: }
42425: 
42425: already_AddRefed<nsContentList>
    1: nsDocument::GetElementsByTagNameNS(const nsAString& aNamespaceURI,
42425:                                    const nsAString& aLocalName)
    1: {
    1:   PRInt32 nameSpaceId = kNameSpaceID_Wildcard;
    1: 
    1:   if (!aNamespaceURI.EqualsLiteral("*")) {
    1:     nsresult rv =
    1:       nsContentUtils::NameSpaceManager()->RegisterNameSpace(aNamespaceURI,
    1:                                                             nameSpaceId);
42425:     NS_ENSURE_SUCCESS(rv, nsnull);
    1:   }
    1: 
63637:   NS_ASSERTION(nameSpaceId != kNameSpaceID_Unknown, "Unexpected namespace ID!");
63637: 
63637:   return NS_GetContentList(this, nameSpaceId, aLocalName);
42425: }
42425: 
42425: NS_IMETHODIMP
42425: nsDocument::GetElementsByTagNameNS(const nsAString& aNamespaceURI,
42425:                                    const nsAString& aLocalName,
42425:                                    nsIDOMNodeList** aReturn)
42425: {
42425:   nsRefPtr<nsContentList> list = GetElementsByTagNameNS(aNamespaceURI,
42425:                                                         aLocalName);
    1:   NS_ENSURE_TRUE(list, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // transfer ref to aReturn
42425:   *aReturn = list.forget().get();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetAsync(PRBool *aAsync)
    1: {
    1:   NS_ERROR("nsDocument::GetAsync() should be overriden by subclass!");
    1: 
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::SetAsync(PRBool aAsync)
    1: {
    1:   NS_ERROR("nsDocument::SetAsync() should be overriden by subclass!");
    1: 
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::Load(const nsAString& aUrl, PRBool *aReturn)
    1: {
    1:   NS_ERROR("nsDocument::Load() should be overriden by subclass!");
    1: 
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetStyleSheets(nsIDOMStyleSheetList** aStyleSheets)
    1: {
    1:   if (!mDOMStyleSheets) {
    1:     mDOMStyleSheets = new nsDOMStyleSheetList(this);
    1:     if (!mDOMStyleSheets) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   *aStyleSheets = mDOMStyleSheets;
    1:   NS_ADDREF(*aStyleSheets);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetSelectedStyleSheetSet(nsAString& aSheetSet)
    1: {
    1:   aSheetSet.Truncate();
    1:   
    1:   // Look through our sheets, find the selected set title
    1:   PRInt32 count = GetNumberOfStyleSheets();
    1:   nsAutoString title;
    1:   for (PRInt32 index = 0; index < count; index++) {
    1:     nsIStyleSheet* sheet = GetStyleSheetAt(index);
    1:     NS_ASSERTION(sheet, "Null sheet in sheet list!");
    1: 
    1:     nsCOMPtr<nsIDOMStyleSheet> domSheet = do_QueryInterface(sheet);
    1:     NS_ASSERTION(domSheet, "Sheet must QI to nsIDOMStyleSheet");
    1:     PRBool disabled;
    1:     domSheet->GetDisabled(&disabled);
    1:     if (disabled) {
    1:       // Disabled sheets don't affect the currently selected set
    1:       continue;
    1:     }
    1:     
    1:     sheet->GetTitle(title);
    1: 
    1:     if (aSheetSet.IsEmpty()) {
    1:       aSheetSet = title;
    1:     } else if (!title.IsEmpty() && !aSheetSet.Equals(title)) {
    1:       // Sheets from multiple sets enabled; return null string, per spec.
    1:       SetDOMStringToNull(aSheetSet);
    1:       break;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::SetSelectedStyleSheetSet(const nsAString& aSheetSet)
    1: {
    1:   if (DOMStringIsNull(aSheetSet)) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Must update mLastStyleSheetSet before doing anything else with stylesheets
    1:   // or CSSLoaders.
    1:   mLastStyleSheetSet = aSheetSet;
    1:   EnableStyleSheetsForSetInternal(aSheetSet, PR_TRUE);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetLastStyleSheetSet(nsAString& aSheetSet)
    1: {
    1:   aSheetSet = mLastStyleSheetSet;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetPreferredStyleSheetSet(nsAString& aSheetSet)
    1: {
    1:   GetHeaderData(nsGkAtoms::headerDefaultStyle, aSheetSet);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetStyleSheetSets(nsIDOMDOMStringList** aList)
    1: {
    1:   if (!mStyleSheetSetList) {
    1:     mStyleSheetSetList = new nsDOMStyleSheetSetList(this);
    1:     if (!mStyleSheetSetList) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   NS_ADDREF(*aList = mStyleSheetSetList);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::EnableStyleSheetsForSet(const nsAString& aSheetSet)
    1: {
    1:   // Per spec, passing in null is a no-op.
    1:   if (!DOMStringIsNull(aSheetSet)) {
    1:     // Note: must make sure to not change the CSSLoader's preferred sheet --
    1:     // that value should be equal to either our lastStyleSheetSet (if that's
    1:     // non-null) or to our preferredStyleSheetSet.  And this method doesn't
    1:     // change either of those.
    1:     EnableStyleSheetsForSetInternal(aSheetSet, PR_FALSE);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsDocument::EnableStyleSheetsForSetInternal(const nsAString& aSheetSet,
    1:                                             PRBool aUpdateCSSLoader)
    1: {
    1:   BeginUpdate(UPDATE_STYLE);
    1:   PRInt32 count = GetNumberOfStyleSheets();
    1:   nsAutoString title;
    1:   for (PRInt32 index = 0; index < count; index++) {
    1:     nsIStyleSheet* sheet = GetStyleSheetAt(index);
    1:     NS_ASSERTION(sheet, "Null sheet in sheet list!");
    1:     sheet->GetTitle(title);
    1:     if (!title.IsEmpty()) {
    1:       sheet->SetEnabled(title.Equals(aSheetSet));
    1:     }
    1:   }
    1:   if (aUpdateCSSLoader) {
    1:     CSSLoader()->SetPreferredSheet(aSheetSet);
    1:   }
    1:   EndUpdate(UPDATE_STYLE);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetCharacterSet(nsAString& aCharacterSet)
    1: {
    1:   CopyASCIItoUTF16(GetDocumentCharacterSet(), aCharacterSet);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::ImportNode(nsIDOMNode* aImportedNode,
    1:                        PRBool aDeep,
    1:                        nsIDOMNode** aResult)
    1: {
    1:   NS_ENSURE_ARG(aImportedNode);
    1: 
    1:   *aResult = nsnull;
    1: 
    1:   nsresult rv = nsContentUtils::CheckSameOrigin(this, aImportedNode);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   PRUint16 nodeType;
    1:   aImportedNode->GetNodeType(&nodeType);
    1:   switch (nodeType) {
    1:     case nsIDOMNode::ATTRIBUTE_NODE:
    1:     case nsIDOMNode::DOCUMENT_FRAGMENT_NODE:
    1:     case nsIDOMNode::ELEMENT_NODE:
    1:     case nsIDOMNode::PROCESSING_INSTRUCTION_NODE:
    1:     case nsIDOMNode::TEXT_NODE:
    1:     case nsIDOMNode::CDATA_SECTION_NODE:
    1:     case nsIDOMNode::COMMENT_NODE:
    1:     {
    1:       nsCOMPtr<nsINode> imported = do_QueryInterface(aImportedNode);
    1:       NS_ENSURE_TRUE(imported, NS_ERROR_FAILURE);
    1: 
    1:       nsCOMPtr<nsIDOMNode> newNode;
    1:       nsCOMArray<nsINode> nodesWithProperties;
    1:       rv = nsNodeUtils::Clone(imported, aDeep, mNodeInfoManager,
    1:                               nodesWithProperties, getter_AddRefs(newNode));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       nsIDocument *ownerDoc = imported->GetOwnerDoc();
    1:       if (ownerDoc) {
    1:         rv = nsNodeUtils::CallUserDataHandlers(nodesWithProperties, ownerDoc,
    1:                                                nsIDOMUserDataHandler::NODE_IMPORTED,
    1:                                                PR_TRUE);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:       }
    1: 
    1:       newNode.swap(*aResult);
    1: 
    1:       return NS_OK;
    1:     }
    1:     case nsIDOMNode::ENTITY_NODE:
    1:     case nsIDOMNode::ENTITY_REFERENCE_NODE:
    1:     case nsIDOMNode::NOTATION_NODE:
    1:     {
    1:       return NS_ERROR_NOT_IMPLEMENTED;
    1:     }
    1:     default:
    1:     {
    1:       NS_WARNING("Don't know how to clone this nodetype for importNode.");
    1: 
    1:       return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
    1:     }
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::AddBinding(nsIDOMElement* aContent, const nsAString& aURI)
    1: {
    1:   NS_ENSURE_ARG(aContent);
    1:   
    1:   nsresult rv = nsContentUtils::CheckSameOrigin(this, aContent);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aContent));
    1: 
    1:   nsCOMPtr<nsIURI> uri;
    1:   rv = NS_NewURI(getter_AddRefs(uri), aURI);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
 3645:   // Figure out the right principal to use
 3645:   nsCOMPtr<nsIPrincipal> subject;
 3645:   nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
 3645:   if (secMan) {
 3645:     rv = secMan->GetSubjectPrincipal(getter_AddRefs(subject));
 3645:     NS_ENSURE_SUCCESS(rv, rv);
 3645:   }
 3645: 
 3645:   if (!subject) {
 3645:     // Fall back to our principal.  Or should we fall back to the null
 3645:     // principal?  The latter would just mean no binding loads....
 3645:     subject = NodePrincipal();
 3645:   }
 3645:   
13669:   return BindingManager()->AddLayeredBinding(content, uri, subject);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::RemoveBinding(nsIDOMElement* aContent, const nsAString& aURI)
    1: {
    1:   NS_ENSURE_ARG(aContent);
    1: 
    1:   nsresult rv = nsContentUtils::CheckSameOrigin(this, aContent);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   nsCOMPtr<nsIURI> uri;
    1:   rv = NS_NewURI(getter_AddRefs(uri), aURI);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aContent));
13669:   return BindingManager()->RemoveLayeredBinding(content, uri);
    1: }
    1: 
    1: NS_IMETHODIMP
 2324: nsDocument::LoadBindingDocument(const nsAString& aURI)
    1: {
    1:   nsCOMPtr<nsIURI> uri;
    1:   nsresult rv = NS_NewURI(getter_AddRefs(uri), aURI,
    1:                           mCharacterSet.get(),
41900:                           GetDocBaseURI());
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 3645:   // Figure out the right principal to use
 3645:   nsCOMPtr<nsIPrincipal> subject;
 3645:   nsIScriptSecurityManager* secMan = nsContentUtils::GetSecurityManager();
 3645:   if (secMan) {
 3645:     rv = secMan->GetSubjectPrincipal(getter_AddRefs(subject));
 3645:     NS_ENSURE_SUCCESS(rv, rv);
 3645:   }
 3645: 
 3645:   if (!subject) {
 3645:     // Fall back to our principal.  Or should we fall back to the null
 3645:     // principal?  The latter would just mean no binding loads....
 3645:     subject = NodePrincipal();
 3645:   }
 3645:   
13669:   BindingManager()->LoadBindingDocument(this, uri, subject);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetBindingParent(nsIDOMNode* aNode, nsIDOMElement** aResult)
    1: {
    1:   *aResult = nsnull;
    1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aNode));
    1:   if (!content)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIDOMElement> elt(do_QueryInterface(content->GetBindingParent()));
    1:   NS_IF_ADDREF(*aResult = elt);
    1:   return NS_OK;
    1: }
    1: 
    1: static nsresult
    1: GetElementByAttribute(nsIContent* aContent, nsIAtom* aAttrName,
    1:                       const nsAString& aAttrValue, PRBool aUniversalMatch,
    1:                       nsIDOMElement** aResult)
    1: {
    1:   if (aUniversalMatch ? aContent->HasAttr(kNameSpaceID_None, aAttrName) :
    1:                         aContent->AttrValueIs(kNameSpaceID_None, aAttrName,
    1:                                               aAttrValue, eCaseMatters)) {
    1:     return CallQueryInterface(aContent, aResult);
    1:   }
    1: 
    1:   PRUint32 childCount = aContent->GetChildCount();
    1: 
    1:   for (PRUint32 i = 0; i < childCount; ++i) {
    1:     nsIContent *current = aContent->GetChildAt(i);
    1: 
    1:     GetElementByAttribute(current, aAttrName, aAttrValue, aUniversalMatch,
    1:                           aResult);
    1: 
    1:     if (*aResult)
    1:       return NS_OK;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetAnonymousElementByAttribute(nsIDOMElement* aElement,
    1:                                            const nsAString& aAttrName,
    1:                                            const nsAString& aAttrValue,
    1:                                            nsIDOMElement** aResult)
    1: {
    1:   *aResult = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMNodeList> nodeList;
    1:   GetAnonymousNodes(aElement, getter_AddRefs(nodeList));
    1: 
    1:   if (!nodeList)
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsIAtom> attribute = do_GetAtom(aAttrName);
    1: 
    1:   PRUint32 length;
    1:   nodeList->GetLength(&length);
    1: 
    1:   PRBool universalMatch = aAttrValue.EqualsLiteral("*");
    1: 
    1:   for (PRUint32 i = 0; i < length; ++i) {
    1:     nsCOMPtr<nsIDOMNode> current;
    1:     nodeList->Item(i, getter_AddRefs(current));
    1: 
    1:     nsCOMPtr<nsIContent> content(do_QueryInterface(current));
    1: 
    1:     GetElementByAttribute(content, attribute, aAttrValue, universalMatch,
    1:                           aResult);
    1:     if (*aResult)
    1:       return NS_OK;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetAnonymousNodes(nsIDOMElement* aElement,
    1:                               nsIDOMNodeList** aResult)
    1: {
    1:   *aResult = nsnull;
    1: 
    1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aElement));
13669:   return BindingManager()->GetAnonymousNodesFor(content, aResult);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateRange(nsIDOMRange** aReturn)
    1: {
    1:   nsresult rv = NS_NewRange(aReturn);
    1: 
    1:   if (NS_SUCCEEDED(rv)) {
    1:     (*aReturn)->SetStart(this, 0);
    1:     (*aReturn)->SetEnd(this, 0);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateNodeIterator(nsIDOMNode *aRoot,
    1:                                PRUint32 aWhatToShow,
    1:                                nsIDOMNodeFilter *aFilter,
    1:                                PRBool aEntityReferenceExpansion,
    1:                                nsIDOMNodeIterator **_retval)
    1: {
16103:   *_retval = nsnull;
16103: 
16103:   if (!aRoot)
16103:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
16103: 
16103:   nsresult rv = nsContentUtils::CheckSameOrigin(this, aRoot);
16103:   NS_ENSURE_SUCCESS(rv, rv);
16103: 
16103:   NS_ENSURE_ARG_POINTER(_retval);
16103: 
16103:   nsCOMPtr<nsINode> root = do_QueryInterface(aRoot);
16103:   NS_ENSURE_TRUE(root, NS_ERROR_DOM_NOT_SUPPORTED_ERR);
16103: 
16103:   nsNodeIterator *iterator = new nsNodeIterator(root,
16103:                                                 aWhatToShow,
16103:                                                 aFilter,
16103:                                                 aEntityReferenceExpansion);
16103:   NS_ENSURE_TRUE(iterator, NS_ERROR_OUT_OF_MEMORY);
16103: 
16103:   NS_ADDREF(*_retval = iterator);
16103: 
16103:   return NS_OK; 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateTreeWalker(nsIDOMNode *aRoot,
    1:                              PRUint32 aWhatToShow,
    1:                              nsIDOMNodeFilter *aFilter,
    1:                              PRBool aEntityReferenceExpansion,
    1:                              nsIDOMTreeWalker **_retval)
    1: {
    1:   *_retval = nsnull;
    1: 
16103:   if (!aRoot)
    1:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
    1: 
    1:   nsresult rv = nsContentUtils::CheckSameOrigin(this, aRoot);
16103:   NS_ENSURE_SUCCESS(rv, rv);
16103: 
16103:   NS_ENSURE_ARG_POINTER(_retval);
16103: 
16103:   nsCOMPtr<nsINode> root = do_QueryInterface(aRoot);
16103:   NS_ENSURE_TRUE(root, NS_ERROR_DOM_NOT_SUPPORTED_ERR);
16103: 
16103:   nsTreeWalker* walker = new nsTreeWalker(root,
16103:                                           aWhatToShow,
16103:                                           aFilter,
16103:                                           aEntityReferenceExpansion);
16103:   NS_ENSURE_TRUE(walker, NS_ERROR_OUT_OF_MEMORY);
16103: 
16103:   NS_ADDREF(*_retval = walker);
16103: 
16103:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
69169: nsDocument::GetDefaultView(nsIDOMWindow** aDefaultView)
69169: {
69169:   *aDefaultView = nsnull;
68870:   nsPIDOMWindow* win = GetWindow();
69169:   if (!win) {
69169:     return NS_OK;
69169:   }
68870:   return CallQueryInterface(win, aDefaultView);
68870: }
68870: 
    1: NS_IMETHODIMP
    1: nsDocument::GetLocation(nsIDOMLocation **_retval)
    1: {
    1:   NS_ENSURE_ARG_POINTER(_retval);
    1:   *_retval = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMWindowInternal> w(do_QueryInterface(mScriptGlobalObject));
    1: 
    1:   if (!w) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   return w->GetLocation(_retval);
    1: }
    1: 
41634: Element*
41634: nsIDocument::GetHtmlElement()
41634: {
41634:   Element* rootElement = GetRootElement();
41634:   if (rootElement && rootElement->Tag() == nsGkAtoms::html &&
41634:       rootElement->IsHTML())
41634:     return rootElement;
16977:   return nsnull;
16977: }
16977: 
41634: Element*
41634: nsIDocument::GetHtmlChildElement(nsIAtom* aTag)
41634: {
41634:   Element* html = GetHtmlElement();
16977:   if (!html)
16977:     return nsnull;
16977: 
16977:   // Look for the element with aTag inside html. This needs to run
16977:   // forwards to find the first such element.
16977:   for (PRUint32 i = 0; i < html->GetChildCount(); ++i) {
16977:     nsIContent* result = html->GetChildAt(i);
33329:     if (result->Tag() == aTag && result->IsHTML())
41634:       return result->AsElement();
16977:   }
16977:   return nsnull;
16977: }
16977: 
16977: nsIContent*
33329: nsDocument::GetTitleContent(PRUint32 aNamespace)
16977: {
16977:   // mMayHaveTitleElement will have been set to true if any HTML or SVG
16977:   // <title> element has been bound to this document. So if it's false,
16977:   // we know there is nothing to do here. This avoids us having to search
16977:   // the whole DOM if someone calls document.title on a large document
16977:   // without a title.
16977:   if (!mMayHaveTitleElement)
16977:     return nsnull;
16977: 
16977:   nsRefPtr<nsContentList> list =
63637:     NS_GetContentList(this, aNamespace, NS_LITERAL_STRING("title"));
16977: 
38707:   return list->Item(0, PR_FALSE);
16977: }
16977: 
16977: void
33329: nsDocument::GetTitleFromElement(PRUint32 aNamespace, nsAString& aTitle)
33329: {
33329:   nsIContent* title = GetTitleContent(aNamespace);
16977:   if (!title)
16977:     return;
16977:   nsContentUtils::GetNodeTextContent(title, PR_FALSE, aTitle);
16977: }
16977: 
    1: NS_IMETHODIMP
    1: nsDocument::GetTitle(nsAString& aTitle)
    1: {
16977:   aTitle.Truncate();
16977: 
41634:   nsIContent *rootElement = GetRootElement();
41634:   if (!rootElement)
16977:     return NS_OK;
16977: 
16977:   nsAutoString tmp;
16977: 
41634:   switch (rootElement->GetNameSpaceID()) {
16977: #ifdef MOZ_XUL
16977:     case kNameSpaceID_XUL:
41634:       rootElement->GetAttr(kNameSpaceID_None, nsGkAtoms::title, tmp);
16977:       break;
16977: #endif
16977:     case kNameSpaceID_SVG:
41634:       if (rootElement->Tag() == nsGkAtoms::svg) {
33329:         GetTitleFromElement(kNameSpaceID_SVG, tmp);
16977:         break;
16977:       } // else fall through
16977:     default:
33329:       GetTitleFromElement(kNameSpaceID_XHTML, tmp);
16977:       break;
16977:   }
16977: 
16977:   tmp.CompressWhitespace();
16977:   aTitle = tmp;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::SetTitle(const nsAString& aTitle)
    1: {
41634:   Element *rootElement = GetRootElement();
41634:   if (!rootElement)
41634:     return NS_OK;
41634: 
41634:   switch (rootElement->GetNameSpaceID()) {
16977:     case kNameSpaceID_SVG:
16977:       return NS_OK; // SVG doesn't support setting a title
16977: #ifdef MOZ_XUL
16977:     case kNameSpaceID_XUL:
41634:       return rootElement->SetAttr(kNameSpaceID_None, nsGkAtoms::title,
16977:                                   aTitle, PR_TRUE);
16977: #endif
16977:   }
16977: 
16977:   // Batch updates so that mutation events don't change "the title
16977:   // element" under us
16977:   mozAutoDocUpdate updateBatch(this, UPDATE_CONTENT_MODEL, PR_TRUE);
16977: 
33329:   nsIContent* title = GetTitleContent(kNameSpaceID_XHTML);
16977:   if (!title) {
41634:     Element *head = GetHeadElement();
16977:     if (!head)
16977:       return NS_OK;
16977: 
16977:     {
16977:       nsCOMPtr<nsINodeInfo> titleInfo;
19197:       titleInfo = mNodeInfoManager->GetNodeInfo(nsGkAtoms::title, nsnull,
71770:                                                 kNameSpaceID_XHTML,
71770:                                                 nsIDOMNode::ELEMENT_NODE);
16977:       if (!titleInfo)
16977:         return NS_OK;
48124:       title = NS_NewHTMLTitleElement(titleInfo.forget());
16977:       if (!title)
16977:         return NS_OK;
16977:     }
16977: 
16977:     head->AppendChildTo(title, PR_TRUE);
16977:   }
16977: 
16977:   return nsContentUtils::SetNodeTextContent(title, aTitle, PR_FALSE);
16977: }
16977: 
16977: void
16977: nsDocument::NotifyPossibleTitleChange(PRBool aBoundTitleElement)
16977: {
16977:   if (aBoundTitleElement) {
16977:     mMayHaveTitleElement = PR_TRUE;
16977:   }
16977:   if (mPendingTitleChangeEvent.IsPending())
16977:     return;
16977: 
41359:   nsRefPtr<nsRunnableMethod<nsDocument, void, false> > event =
41361:     NS_NewNonOwningRunnableMethod(this,
16977:       &nsDocument::DoNotifyPossibleTitleChange);
16977:   nsresult rv = NS_DispatchToCurrentThread(event);
16977:   if (NS_SUCCEEDED(rv)) {
16977:     mPendingTitleChangeEvent = event;
16977:   }
16977: }
16977: 
16977: void
16977: nsDocument::DoNotifyPossibleTitleChange()
16977: {
16977:   mPendingTitleChangeEvent.Forget();
18363:   mHaveFiredTitleChange = PR_TRUE;
16977: 
16977:   nsAutoString title;
16977:   GetTitle(title);
16977: 
46225:   nsCOMPtr<nsIPresShell> shell = GetShell();
36917:   if (shell) {
    1:     nsCOMPtr<nsISupports> container = shell->GetPresContext()->GetContainer();
36917:     if (container) {
    1:       nsCOMPtr<nsIBaseWindow> docShellWin = do_QueryInterface(container);
36917:       if (docShellWin) {
71728:         docShellWin->SetTitle(title.get());
16977:       }
36917:     }
36917:   }
    1: 
    1:   // Fire a DOM event for the title change.
25813:   nsContentUtils::DispatchChromeEvent(this, static_cast<nsIDocument*>(this),
    1:                                       NS_LITERAL_STRING("DOMTitleChanged"),
    1:                                       PR_TRUE, PR_TRUE);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetBoxObjectFor(nsIDOMElement* aElement, nsIBoxObject** aResult)
    1: {
    1:   nsCOMPtr<nsIContent> content(do_QueryInterface(aElement));
    1:   NS_ENSURE_TRUE(content, NS_ERROR_UNEXPECTED);
 1839: 
11731:   nsIDocument* doc = content->GetOwnerDoc();
 1839:   NS_ENSURE_TRUE(doc == this, NS_ERROR_DOM_WRONG_DOCUMENT_ERR);
    1: 
33329:   if (!mHasWarnedAboutBoxObjects && !content->IsXUL()) {
11731:     mHasWarnedAboutBoxObjects = PR_TRUE;
11731:     nsContentUtils::ReportToConsole(nsContentUtils::eDOM_PROPERTIES,
11731:                                     "UseOfGetBoxObjectForWarning",
11731:                                     nsnull, 0,
59513:                                     nsnull,
11731:                                     EmptyString(), 0, 0,
11731:                                     nsIScriptError::warningFlag,
59513:                                     "BoxObjects", this);
11731:   }
11731: 
    1:   *aResult = nsnull;
    1: 
    1:   if (!mBoxObjectTable) {
11731:     mBoxObjectTable = new nsInterfaceHashtable<nsVoidPtrHashKey, nsPIBoxObject>;
    1:     if (mBoxObjectTable && !mBoxObjectTable->Init(12)) {
    1:       mBoxObjectTable = nsnull;
    1:     }
    1:   } else {
    1:     // Want to use Get(content, aResult); but it's the wrong type
    1:     *aResult = mBoxObjectTable->GetWeak(content);
    1:     if (*aResult) {
    1:       NS_ADDREF(*aResult);
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   PRInt32 namespaceID;
13669:   nsCOMPtr<nsIAtom> tag = BindingManager()->ResolveTag(content, &namespaceID);
    1: 
    1:   nsCAutoString contractID("@mozilla.org/layout/xul-boxobject");
    1:   if (namespaceID == kNameSpaceID_XUL) {
    1:     if (tag == nsGkAtoms::browser ||
    1:         tag == nsGkAtoms::editor ||
    1:         tag == nsGkAtoms::iframe)
    1:       contractID += "-container";
    1:     else if (tag == nsGkAtoms::menu)
    1:       contractID += "-menu";
    1:     else if (tag == nsGkAtoms::popup ||
    1:              tag == nsGkAtoms::menupopup ||
 3129:              tag == nsGkAtoms::panel ||
    1:              tag == nsGkAtoms::tooltip)
    1:       contractID += "-popup";
    1:     else if (tag == nsGkAtoms::tree)
    1:       contractID += "-tree";
    1:     else if (tag == nsGkAtoms::listbox)
    1:       contractID += "-listbox";
    1:     else if (tag == nsGkAtoms::scrollbox)
    1:       contractID += "-scrollbox";
    1:   }
    1:   contractID += ";1";
    1: 
    1:   nsCOMPtr<nsPIBoxObject> boxObject(do_CreateInstance(contractID.get()));
    1:   if (!boxObject)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   boxObject->Init(content);
    1: 
    1:   if (mBoxObjectTable) {
    1:     mBoxObjectTable->Put(content, boxObject.get());
    1:   }
    1: 
    1:   *aResult = boxObject;
    1:   NS_ADDREF(*aResult);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsDocument::ClearBoxObjectFor(nsIContent* aContent)
    1: {
    1:   if (mBoxObjectTable) {
    1:     nsPIBoxObject *boxObject = mBoxObjectTable->GetWeak(aContent);
    1:     if (boxObject) {
    1:       boxObject->Clear();
    1:       mBoxObjectTable->Remove(aContent);
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsDocument::GetXBLChildNodesFor(nsIContent* aContent, nsIDOMNodeList** aResult)
    1: {
13669:   return BindingManager()->GetXBLChildNodesFor(aContent, aResult);
    1: }
    1: 
    1: nsresult
    1: nsDocument::GetContentListFor(nsIContent* aContent, nsIDOMNodeList** aResult)
    1: {
13669:   return BindingManager()->GetContentListFor(aContent, aResult);
    1: }
    1: 
    1: void
    1: nsDocument::FlushSkinBindings()
    1: {
13669:   BindingManager()->FlushSkinBindings();
    1: }
    1: 
12256: nsresult
13433: nsDocument::InitializeFrameLoader(nsFrameLoader* aLoader)
13433: {
13433:   mInitializableFrameLoaders.RemoveElement(aLoader);
13433:   // Don't even try to initialize.
13433:   if (mInDestructor) {
13433:     NS_WARNING("Trying to initialize a frame loader while"
13433:                "document is being deleted");
13433:     return NS_ERROR_FAILURE;
13433:   }
23256: 
13433:   mInitializableFrameLoaders.AppendElement(aLoader);
23256:   if (!mFrameLoaderRunner) {
24482:     mFrameLoaderRunner =
41361:       NS_NewRunnableMethod(this, &nsDocument::MaybeInitializeFinalizeFrameLoaders);
23256:     NS_ENSURE_TRUE(mFrameLoaderRunner, NS_ERROR_OUT_OF_MEMORY);
23256:     nsContentUtils::AddScriptRunner(mFrameLoaderRunner);
13433:   }
13433:   return NS_OK;
13433: }
13433: 
13433: nsresult
12256: nsDocument::FinalizeFrameLoader(nsFrameLoader* aLoader)
12256: {
13433:   mInitializableFrameLoaders.RemoveElement(aLoader);
12256:   if (mInDestructor) {
12256:     return NS_ERROR_FAILURE;
12256:   }
23256: 
12256:   mFinalizableFrameLoaders.AppendElement(aLoader);
23256:   if (!mFrameLoaderRunner) {
24482:     mFrameLoaderRunner =
41361:       NS_NewRunnableMethod(this, &nsDocument::MaybeInitializeFinalizeFrameLoaders);
23256:     NS_ENSURE_TRUE(mFrameLoaderRunner, NS_ERROR_OUT_OF_MEMORY);
23256:     nsContentUtils::AddScriptRunner(mFrameLoaderRunner);
12256:   }
12256:   return NS_OK;
12256: }
12256: 
14464: void
24482: nsDocument::MaybeInitializeFinalizeFrameLoaders()
24482: {
24482:   if (mDelayFrameLoaderInitialization || mUpdateNestLevel != 0) {
24482:     // This method will be recalled when mUpdateNestLevel drops to 0,
24482:     // or when !mDelayFrameLoaderInitialization.
23256:     mFrameLoaderRunner = nsnull;
23256:     return;
23256:   }
23256: 
24482:   // We're not in an update, but it is not safe to run scripts, so
24482:   // postpone frameloader initialization and finalization.
24482:   if (!nsContentUtils::IsSafeToRunScript()) {
24482:     if (!mInDestructor && !mFrameLoaderRunner &&
24482:         (mInitializableFrameLoaders.Length() ||
24482:          mFinalizableFrameLoaders.Length())) {
24482:       mFrameLoaderRunner =
41361:         NS_NewRunnableMethod(this, &nsDocument::MaybeInitializeFinalizeFrameLoaders);
24482:       nsContentUtils::AddScriptRunner(mFrameLoaderRunner);
24482:     }
24482:     return;
24482:   }
24482:   mFrameLoaderRunner = nsnull;
24482: 
14660:   // Don't use a temporary array for mInitializableFrameLoaders, because
14660:   // loading a frame may cause some other frameloader to be removed from the
14660:   // array. But be careful to keep the loader alive when starting the load!
14660:   while (mInitializableFrameLoaders.Length()) {
14660:     nsRefPtr<nsFrameLoader> loader = mInitializableFrameLoaders[0];
14660:     mInitializableFrameLoaders.RemoveElementAt(0);
14660:     NS_ASSERTION(loader, "null frameloader in the array?");
14660:     loader->ReallyStartLoading();
14660:   }
14660: 
14660:   PRUint32 length = mFinalizableFrameLoaders.Length();
14464:   if (length > 0) {
14464:     nsTArray<nsRefPtr<nsFrameLoader> > loaders;
14464:     mFinalizableFrameLoaders.SwapElements(loaders);
14464:     for (PRUint32 i = 0; i < length; ++i) {
14464:       loaders[i]->Finalize();
14464:     }
14464:   }
14464: }
14464: 
14660: void
14660: nsDocument::TryCancelFrameLoaderInitialization(nsIDocShell* aShell)
14660: {
14660:   PRUint32 length = mInitializableFrameLoaders.Length();
14660:   for (PRUint32 i = 0; i < length; ++i) {
14660:     if (mInitializableFrameLoaders[i]->GetExistingDocShell() == aShell) {
14660:       mInitializableFrameLoaders.RemoveElementAt(i);
14660:       return;
14660:     }
14660:   }
14660: }
14660: 
14757: PRBool
14757: nsDocument::FrameLoaderScheduledToBeFinalized(nsIDocShell* aShell)
14757: {
14757:   if (aShell) {
14757:     PRUint32 length = mFinalizableFrameLoaders.Length();
14757:     for (PRUint32 i = 0; i < length; ++i) {
14757:       if (mFinalizableFrameLoaders[i]->GetExistingDocShell() == aShell) {
14757:         return PR_TRUE;
14757:       }
14757:     }
14757:   }
14757:   return PR_FALSE;
14757: }
14757: 
20078: nsIDocument*
20078: nsDocument::RequestExternalResource(nsIURI* aURI,
20078:                                     nsINode* aRequestingNode,
20078:                                     ExternalResourceLoad** aPendingLoad)
20078: {
20078:   NS_PRECONDITION(aURI, "Must have a URI");
20078:   NS_PRECONDITION(aRequestingNode, "Must have a node");
20078:   if (mDisplayDocument) {
20078:     return mDisplayDocument->RequestExternalResource(aURI,
20078:                                                      aRequestingNode,
20078:                                                      aPendingLoad);
20078:   }
20078: 
20078:   return mExternalResourceMap.RequestResource(aURI, aRequestingNode,
20078:                                               this, aPendingLoad);
20078: }
20078: 
20078: void
20078: nsDocument::EnumerateExternalResources(nsSubDocEnumFunc aCallback, void* aData)
20078: {
20078:   mExternalResourceMap.EnumerateResources(aCallback, aData);
20078: }
20078: 
23697: #ifdef MOZ_SMIL
23697: nsSMILAnimationController*
23697: nsDocument::GetAnimationController()
23697: {
23697:   // We create the animation controller lazily because most documents won't want
23697:   // one and only SVG documents and the like will call this
23697:   if (mAnimationController)
23697:     return mAnimationController;
35510:   // Refuse to create an Animation Controller if SMIL is disabled, and also
35510:   // for data documents.
36884:   if (!NS_SMILEnabled() || mLoadedAsData || mLoadedAsInteractiveData)
25961:     return nsnull;
23697: 
69077:   mAnimationController = new nsSMILAnimationController(this);
23697:   
23697:   // If there's a presContext then check the animation mode and pause if
23697:   // necessary.
46225:   nsIPresShell *shell = GetShell();
23697:   if (mAnimationController && shell) {
23697:     nsPresContext *context = shell->GetPresContext();
23697:     if (context &&
23697:         context->ImageAnimationMode() == imgIContainer::kDontAnimMode) {
23697:       mAnimationController->Pause(nsSMILTimeContainer::PAUSE_USERPREF);
23697:     }
23697:   }
23697: 
57187:   // If we're hidden (or being hidden), notify the newly-created animation
57187:   // controller. (Skip this check for SVG-as-an-image documents, though,
57187:   // because they don't get OnPageShow / OnPageHide calls).
57187:   if (!mIsShowing && !mIsBeingUsedAsImage) {
57025:     mAnimationController->OnPageHide();
57025:   }
57025: 
23697:   return mAnimationController;
23697: }
23697: #endif // MOZ_SMIL
23697: 
    1: struct DirTable {
    1:   const char* mName;
    1:   PRUint8     mValue;
    1: };
    1: 
    1: static const DirTable dirAttributes[] = {
    1:   {"ltr", IBMBIDI_TEXTDIRECTION_LTR},
    1:   {"rtl", IBMBIDI_TEXTDIRECTION_RTL},
    1:   {0}
    1: };
    1: 
    1: /**
    1:  * Retrieve the "direction" property of the document.
    1:  *
    1:  * @lina 01/09/2001
    1:  */
    1: NS_IMETHODIMP
    1: nsDocument::GetDir(nsAString& aDirection)
    1: {
    1:   PRUint32 options = GetBidiOptions();
    1:   for (const DirTable* elt = dirAttributes; elt->mName; elt++) {
    1:     if (GET_BIDI_OPTION_DIRECTION(options) == elt->mValue) {
    1:       CopyASCIItoUTF16(elt->mName, aDirection);
    1:       break;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /**
    1:  * Set the "direction" property of the document.
    1:  *
    1:  * @lina 01/09/2001
    1:  */
    1: NS_IMETHODIMP
    1: nsDocument::SetDir(const nsAString& aDirection)
    1: {
    1:   PRUint32 options = GetBidiOptions();
    1: 
    1:   for (const DirTable* elt = dirAttributes; elt->mName; elt++) {
    1:     if (aDirection == NS_ConvertASCIItoUTF16(elt->mName)) {
    1:       if (GET_BIDI_OPTION_DIRECTION(options) != elt->mValue) {
    1:         SET_BIDI_OPTION_DIRECTION(options, elt->mValue);
46225:         nsIPresShell *shell = GetShell();
    1:         if (shell) {
    1:           nsPresContext *context = shell->GetPresContext();
    1:           NS_ENSURE_TRUE(context, NS_ERROR_UNEXPECTED);
    1:           context->SetBidi(options, PR_TRUE);
    1:         } else {
    1:           // No presentation; just set it on ourselves
    1:           SetBidiOptions(options);
    1:         }
    1:       }
    1: 
    1:       break;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: //
    1: // nsIDOMNode methods
    1: //
    1: NS_IMETHODIMP
    1: nsDocument::GetNodeName(nsAString& aNodeName)
    1: {
    1:   aNodeName.AssignLiteral("#document");
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetNodeValue(nsAString& aNodeValue)
    1: {
    1:   SetDOMStringToNull(aNodeValue);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::SetNodeValue(const nsAString& aNodeValue)
    1: {
    1:   // The DOM spec says that when nodeValue is defined to be null "setting it
    1:   // has no effect", so we don't throw an exception.
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetNodeType(PRUint16* aNodeType)
    1: {
    1:   *aNodeType = nsIDOMNode::DOCUMENT_NODE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetParentNode(nsIDOMNode** aParentNode)
    1: {
    1:   *aParentNode = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetChildNodes(nsIDOMNodeList** aChildNodes)
    1: {
23258:   return nsINode::GetChildNodes(aChildNodes);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::HasChildNodes(PRBool* aHasChildNodes)
    1: {
    1:   NS_ENSURE_ARG(aHasChildNodes);
    1: 
    1:   *aHasChildNodes = (mChildren.ChildCount() != 0);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::HasAttributes(PRBool* aHasAttributes)
    1: {
    1:   NS_ENSURE_ARG(aHasAttributes);
    1: 
    1:   *aHasAttributes = PR_FALSE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetFirstChild(nsIDOMNode** aFirstChild)
    1: {
23258:   return nsINode::GetFirstChild(aFirstChild);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetLastChild(nsIDOMNode** aLastChild)
    1: {
23258:   return nsINode::GetLastChild(aLastChild);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetPreviousSibling(nsIDOMNode** aPreviousSibling)
    1: {
    1:   *aPreviousSibling = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetNextSibling(nsIDOMNode** aNextSibling)
    1: {
    1:   *aNextSibling = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetAttributes(nsIDOMNamedNodeMap** aAttributes)
    1: {
    1:   *aAttributes = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetNamespaceURI(nsAString& aNamespaceURI)
    1: {
    1:   SetDOMStringToNull(aNamespaceURI);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetPrefix(nsAString& aPrefix)
    1: {
    1:   SetDOMStringToNull(aPrefix);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetLocalName(nsAString& aLocalName)
    1: {
    1:   SetDOMStringToNull(aLocalName);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::InsertBefore(nsIDOMNode* aNewChild, nsIDOMNode* aRefChild,
    1:                          nsIDOMNode** aReturn)
    1: {
39585:   return ReplaceOrInsertBefore(PR_FALSE, aNewChild, aRefChild, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::ReplaceChild(nsIDOMNode* aNewChild, nsIDOMNode* aOldChild,
    1:                          nsIDOMNode** aReturn)
    1: {
39585:   return ReplaceOrInsertBefore(PR_TRUE, aNewChild, aOldChild, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::RemoveChild(nsIDOMNode* aOldChild, nsIDOMNode** aReturn)
    1: {
39585:   return nsINode::RemoveChild(aOldChild, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::AppendChild(nsIDOMNode* aNewChild, nsIDOMNode** aReturn)
    1: {
    1:   return nsDocument::InsertBefore(aNewChild, nsnull, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CloneNode(PRBool aDeep, nsIDOMNode** aReturn)
    1: {
58904:   return nsNodeUtils::CloneNodeImpl(this, aDeep, !mCreatingStaticClone, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::Normalize()
    1: {
72437:   return nsIDocument::Normalize();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::IsSupported(const nsAString& aFeature, const nsAString& aVersion,
    1:                         PRBool* aReturn)
    1: {
 3233:   return nsGenericElement::InternalIsSupported(static_cast<nsIDOMDocument*>(this),
    1:                                                aFeature, aVersion, aReturn);
    1: }
    1: 
71768: NS_IMETHODIMP
71768: nsDocument::GetDOMBaseURI(nsAString &aURI)
71768: {
71768:   return nsIDocument::GetDOMBaseURI(aURI);
71768: }
71768: 
71768: NS_IMETHODIMP
    1: nsDocument::GetTextContent(nsAString &aTextContent)
    1: {
    1:   SetDOMStringToNull(aTextContent);
71768:   return NS_OK;
71768: }
71768: 
71768: NS_IMETHODIMP
71768: nsDocument::IsEqualNode(nsIDOMNode* aOther, PRBool* aResult)
71768: {
71769:   return nsINode::IsEqualNode(aOther, aResult);
71768: }
71768: 
71768: NS_IMETHODIMP
71768: nsDocument::CompareDocumentPosition(nsIDOMNode *other,
71768:                                    PRUint16 *aResult)
71768: {
71768:   return nsINode::CompareDocumentPosition(other, aResult);
71768: }
71768: 
71768: NS_IMETHODIMP
71768: nsDocument::SetTextContent(const nsAString & aTextContent)
71768: {
71768:   return nsINode::SetTextContent(aTextContent);
71768: }
71768: 
71768: NS_IMETHODIMP
71768: nsDocument::IsSameNode(nsIDOMNode *other, PRBool *aResult)
71768: {
71768:   *aResult = other == this;
71768:   return NS_OK;
71768: }
71768: 
71768: NS_IMETHODIMP
71768: nsDocument::LookupPrefix(const nsAString & namespaceURI, nsAString & aResult)
71768: {
71768:   SetDOMStringToNull(aResult);
71768:   return NS_OK;
71768: }
71768: 
71768: NS_IMETHODIMP
71768: nsDocument::IsDefaultNamespace(const nsAString & namespaceURI,
71768:                               PRBool *aResult)
71768: {
71768:   *aResult = namespaceURI.IsEmpty();
71768:   return NS_OK;
71768: }
71768: 
71768: NS_IMETHODIMP
71768: nsDocument::LookupNamespaceURI(const nsAString & prefix,
71768:                               nsAString & aResult)
71768: {
71768:   SetDOMStringToNull(aResult);
71768:   return NS_OK;
71768: }
71768: 
71768: NS_IMETHODIMP
71768: nsDocument::SetUserData(const nsAString & key,
71768:                        nsIVariant *data, nsIDOMUserDataHandler *handler,
71768:                        nsIVariant **aResult)
71768: {
71768:   return nsINode::SetUserData(key, data, handler, aResult);
71768: }
71768: 
71768: NS_IMETHODIMP
71768: nsDocument::GetUserData(const nsAString & key,
71768:                         nsIVariant **aResult)
71768: {
71768:   return nsINode::GetUserData(key, aResult);
41906: }
41906: 
41906: NS_IMETHODIMP
    1: nsDocument::GetInputEncoding(nsAString& aInputEncoding)
    1: {
16447:   if (mHaveInputEncoding) {
    1:     return GetCharacterSet(aInputEncoding);
    1:   }
    1: 
16447:   SetDOMStringToNull(aInputEncoding);
16447:   return NS_OK;
16447: }
16447: 
    1: NS_IMETHODIMP
    1: nsDocument::GetXmlEncoding(nsAString& aXmlEncoding)
    1: {
69474:   if (!IsHTML() &&
69474:       mXMLDeclarationBits & XML_DECLARATION_BITS_DECLARATION_EXISTS &&
    1:       mXMLDeclarationBits & XML_DECLARATION_BITS_ENCODING_EXISTS) {
    1:     // XXX We don't store the encoding given in the xml declaration.
    1:     // For now, just output the inputEncoding which we do store.
    1:     GetInputEncoding(aXmlEncoding);
    1:   } else {
    1:     SetDOMStringToNull(aXmlEncoding);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetXmlStandalone(PRBool *aXmlStandalone)
    1: {
    1:   *aXmlStandalone = 
69474:     !IsHTML() &&
    1:     mXMLDeclarationBits & XML_DECLARATION_BITS_DECLARATION_EXISTS &&
    1:     mXMLDeclarationBits & XML_DECLARATION_BITS_STANDALONE_EXISTS &&
    1:     mXMLDeclarationBits & XML_DECLARATION_BITS_STANDALONE_YES;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::SetXmlStandalone(PRBool aXmlStandalone)
    1: {
69474:   return IsHTML() ? NS_ERROR_DOM_NOT_SUPPORTED_ERR : NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetXmlVersion(nsAString& aXmlVersion)
    1: {
69474:   if (IsHTML()) {
69474:     SetDOMStringToNull(aXmlVersion);
69474:     return NS_OK;
69474:   }
69474: 
    1:   // If there is no declaration, the value is "1.0".
    1: 
    1:   // XXX We only support "1.0", so always output "1.0" until that changes.
    1:   aXmlVersion.AssignLiteral("1.0");
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::SetXmlVersion(const nsAString& aXmlVersion)
    1: {
69474:   return IsHTML() ? NS_ERROR_DOM_NOT_SUPPORTED_ERR : NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetDocumentURI(nsAString& aDocumentURI)
    1: {
    1:   if (mDocumentURI) {
    1:     nsCAutoString uri;
    1:     mDocumentURI->GetSpec(uri);
    1:     CopyUTF8toUTF16(uri, aDocumentURI);
    1:   } else {
    1:     SetDOMStringToNull(aDocumentURI);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::SetDocumentURI(const nsAString& aDocumentURI)
    1: {
    1:   // Not allowing this yet, need to think about security ramifications first.
    1:   // We use mDocumentURI to get principals for this document.
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: static void BlastSubtreeToPieces(nsINode *aNode);
    1: 
20261: PLDHashOperator
47799: BlastFunc(nsAttrHashKey::KeyType aKey, nsDOMAttribute *aData, void* aUserArg)
    1: {
    1:   nsCOMPtr<nsIAttribute> *attr =
 3233:     static_cast<nsCOMPtr<nsIAttribute>*>(aUserArg);
    1: 
47799:   *attr = aData;
    1: 
    1:   NS_ASSERTION(attr->get(),
    1:                "non-nsIAttribute somehow made it into the hashmap?!");
    1: 
    1:   return PL_DHASH_STOP;
    1: }
    1: 
    1: static void
    1: BlastSubtreeToPieces(nsINode *aNode)
    1: {
    1:   PRUint32 i, count;
41636:   if (aNode->IsElement()) {
 3233:     nsGenericElement *element = static_cast<nsGenericElement*>(aNode);
    1:     const nsDOMAttributeMap *map = element->GetAttributeMap();
    1:     if (map) {
    1:       nsCOMPtr<nsIAttribute> attr;
    1:       while (map->Enumerate(BlastFunc, &attr) > 0) {
    1:         BlastSubtreeToPieces(attr);
    1: 
19629: #ifdef DEBUG
19629:         nsresult rv =
19629: #endif
19629:           element->UnsetAttr(attr->NodeInfo()->NamespaceID(),
    1:                              attr->NodeInfo()->NameAtom(),
    1:                              PR_FALSE);
    1: 
    1:         // XXX Should we abort here?
    1:         NS_ASSERTION(NS_SUCCEEDED(rv), "Uhoh, UnsetAttr shouldn't fail!");
    1:       }
    1:     }
    1:   }
    1: 
    1:   count = aNode->GetChildCount();
    1:   for (i = 0; i < count; ++i) {
    1:     BlastSubtreeToPieces(aNode->GetChildAt(0));
19629: #ifdef DEBUG
19629:     nsresult rv =
19629: #endif
19629:       aNode->RemoveChildAt(0, PR_FALSE);
    1: 
    1:     // XXX Should we abort here?
    1:     NS_ASSERTION(NS_SUCCEEDED(rv), "Uhoh, RemoveChildAt shouldn't fail!");
    1:   }
    1: }
    1: 
69574: 
69574: class nsUserDataCaller : public nsRunnable
69574: {
69574: public:
69574:   nsUserDataCaller(nsCOMArray<nsINode>& aNodesWithProperties,
69574:                    nsIDocument* aOwnerDoc)
69574:     : mNodesWithProperties(aNodesWithProperties),
69574:       mOwnerDoc(aOwnerDoc)
69574:   {
69574:   }
69574: 
69574:   NS_IMETHOD Run()
69574:   {
69574:     nsNodeUtils::CallUserDataHandlers(mNodesWithProperties, mOwnerDoc,
69574:                                       nsIDOMUserDataHandler::NODE_ADOPTED,
69574:                                       PR_FALSE);
69574:     return NS_OK;
69574:   }
69574: 
69574: private:
69574:   nsCOMArray<nsINode> mNodesWithProperties;
69574:   nsCOMPtr<nsIDocument> mOwnerDoc;
69574: };
69574: 
    1: NS_IMETHODIMP
    1: nsDocument::AdoptNode(nsIDOMNode *aAdoptedNode, nsIDOMNode **aResult)
    1: {
    1:   NS_ENSURE_ARG(aAdoptedNode);
    1: 
    1:   *aResult = nsnull;
    1: 
    1:   nsresult rv = nsContentUtils::CheckSameOrigin(this, aAdoptedNode);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
69574:   nsCOMPtr<nsINode> adoptedNode = do_QueryInterface(aAdoptedNode);
69574:   
69574:   // Scope firing mutation events so that we don't carry any state that
69574:   // might be stale
69574:   {
69574:     nsINode* parent = adoptedNode->GetNodeParent();
69574:     if (parent) {
69574:       nsContentUtils::MaybeFireNodeRemoved(adoptedNode, parent,
69574:                                            adoptedNode->GetOwnerDoc());
69574:     }
69574:   }
69574: 
69574:   nsAutoScriptBlocker scriptBlocker;
69574: 
    1:   PRUint16 nodeType;
    1:   aAdoptedNode->GetNodeType(&nodeType);
    1:   switch (nodeType) {
    1:     case nsIDOMNode::ATTRIBUTE_NODE:
    1:     {
    1:       // Remove from ownerElement.
69574:       nsCOMPtr<nsIDOMAttr> adoptedAttr = do_QueryInterface(aAdoptedNode);
69574:       NS_ASSERTION(adoptedAttr, "Attribute not implementing nsIDOMAttr");
    1: 
    1:       nsCOMPtr<nsIDOMElement> ownerElement;
    1:       rv = adoptedAttr->GetOwnerElement(getter_AddRefs(ownerElement));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       if (ownerElement) {
    1:         nsCOMPtr<nsIDOMAttr> newAttr;
    1:         rv = ownerElement->RemoveAttributeNode(adoptedAttr,
    1:                                                getter_AddRefs(newAttr));
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:         newAttr.swap(adoptedAttr);
    1:       }
    1: 
    1:       break;
    1:     }
    1:     case nsIDOMNode::DOCUMENT_FRAGMENT_NODE:
    1:     case nsIDOMNode::ELEMENT_NODE:
    1:     case nsIDOMNode::PROCESSING_INSTRUCTION_NODE:
    1:     case nsIDOMNode::TEXT_NODE:
    1:     case nsIDOMNode::CDATA_SECTION_NODE:
    1:     case nsIDOMNode::COMMENT_NODE:
    1:     {
    1:       // We don't want to adopt an element into its own contentDocument or into
    1:       // a descendant contentDocument, so we check if the frameElement of this
    1:       // document or any of its parents is the adopted node or one of its
    1:       // descendants.
    1:       nsIDocument *doc = this;
    1:       do {
    1:         nsPIDOMWindow *win = doc->GetWindow();
    1:         if (win) {
    1:           nsCOMPtr<nsINode> node =
    1:             do_QueryInterface(win->GetFrameElementInternal());
    1:           if (node &&
    1:               nsContentUtils::ContentIsDescendantOf(node, adoptedNode)) {
    1:             return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
    1:           }
    1:         }
    1:       } while ((doc = doc->GetParentDocument()));
    1: 
    1:       // Remove from parent.
69574:       nsINode* parent = adoptedNode->GetNodeParent();
    1:       if (parent) {
69574:         rv = parent->RemoveChildAt(parent->IndexOf(adoptedNode), PR_TRUE);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:       }
    1: 
    1:       break;
    1:     }
    1:     case nsIDOMNode::ENTITY_REFERENCE_NODE:
    1:     {
    1:       return NS_ERROR_NOT_IMPLEMENTED;
    1:     }
    1:     case nsIDOMNode::DOCUMENT_NODE:
    1:     case nsIDOMNode::DOCUMENT_TYPE_NODE:
    1:     case nsIDOMNode::ENTITY_NODE:
    1:     case nsIDOMNode::NOTATION_NODE:
    1:     {
    1:       return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
    1:     }
    1:     default:
    1:     {
    1:       NS_WARNING("Don't know how to adopt this nodetype for adoptNode.");
    1: 
    1:       return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
    1:     }
    1:   }
    1: 
    1:   nsIDocument *oldDocument = adoptedNode->GetOwnerDoc();
    1:   PRBool sameDocument = oldDocument == this;
    1: 
    1:   JSContext *cx = nsnull;
    1:   JSObject *newScope = nsnull;
59445:   if (!sameDocument) {
59444:     rv = nsContentUtils::GetContextAndScope(oldDocument, this, &cx, &newScope);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   nsCOMArray<nsINode> nodesWithProperties;
    1:   rv = nsNodeUtils::Adopt(adoptedNode, sameDocument ? nsnull : mNodeInfoManager,
59445:                           cx, newScope, nodesWithProperties);
    1:   if (NS_FAILED(rv)) {
    1:     // Disconnect all nodes from their parents, since some have the old document
    1:     // as their ownerDocument and some have this as their ownerDocument.
    1:     BlastSubtreeToPieces(adoptedNode);
    1: 
    1:     if (!sameDocument && oldDocument) {
41182:       PRUint32 count = nodesWithProperties.Count();
41182:       for (PRUint32 j = 0; j < oldDocument->GetPropertyTableCount(); ++j) {
41182:         for (PRUint32 i = 0; i < count; ++i) {
    1:           // Remove all properties.
41182:           oldDocument->PropertyTable(j)->
    1:             DeleteAllPropertiesFor(nodesWithProperties[i]);
    1:         }
    1:       }
41182:     }
    1: 
    1:     return rv;
    1:   }
    1: 
41182:   PRUint32 count = nodesWithProperties.Count();
    1:   if (!sameDocument && oldDocument) {
41182:     for (PRUint32 j = 0; j < oldDocument->GetPropertyTableCount(); ++j) {
41182:       nsPropertyTable *oldTable = oldDocument->PropertyTable(j);
41182:       nsPropertyTable *newTable = PropertyTable(j);
41182:       for (PRUint32 i = 0; i < count; ++i) {
41182:         if (NS_SUCCEEDED(rv)) {
    1:           rv = oldTable->TransferOrDeleteAllPropertiesFor(nodesWithProperties[i],
    1:                                                           newTable);
41182:         } else {
41182:           oldTable->DeleteAllPropertiesFor(nodesWithProperties[i]);
41182:         }
41182:       }
41182:     }
41182: 
    1:     if (NS_FAILED(rv)) {
    1:       // Disconnect all nodes from their parents.
    1:       BlastSubtreeToPieces(adoptedNode);
    1: 
    1:       return rv;
    1:     }
    1:   }
    1: 
69574:   if (nodesWithProperties.Count()) {
69574:     nsContentUtils::AddScriptRunner(new nsUserDataCaller(nodesWithProperties,
69574:                                                          this));
69574:   }
69574: 
69574:   NS_ASSERTION(adoptedNode->GetOwnerDoc() == this,
69574:                "Should still be in the document we just got adopted into");
39584: 
    1:   return CallQueryInterface(adoptedNode, aResult);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetOwnerDocument(nsIDOMDocument** aOwnerDocument)
    1: {
23258:   return nsINode::GetOwnerDocument(aOwnerDocument);
    1: }
    1: 
72328: nsEventListenerManager*
29474: nsDocument::GetListenerManager(PRBool aCreateIfNotFound)
29474: {
72328:   if (!mListenerManager && aCreateIfNotFound) {
72328:     mListenerManager =
72328:       new nsEventListenerManager(static_cast<nsIDOMEventTarget*>(this));
72328:   }
72298: 
29474:   return mListenerManager;
    1: }
    1: 
    1: nsresult
    1: nsDocument::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
    1: {
    1:   aVisitor.mCanHandle = PR_TRUE;
    1:    // FIXME! This is a hack to make middle mouse paste working also in Editor.
    1:    // Bug 329119
    1:   aVisitor.mForceContentDispatch = PR_TRUE;
    1: 
    1:   // Load events must not propagate to |window| object, see bug 335251.
    1:   if (aVisitor.mEvent->message != NS_LOAD) {
41629:     nsGlobalWindow* window = static_cast<nsGlobalWindow*>(GetWindow());
72326:     aVisitor.mParentTarget = static_cast<nsIDOMEventTarget*>(window);
72298:   }
72298:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::CreateEvent(const nsAString& aEventType, nsIDOMEvent** aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aReturn);
    1:   *aReturn = nsnull;
    1: 
    1:   // Obtain a presentation shell
    1: 
46225:   nsIPresShell *shell = GetShell();
    1: 
    1:   nsPresContext *presContext = nsnull;
    1: 
    1:   if (shell) {
    1:     // Retrieve the context
    1:     presContext = shell->GetPresContext();
    1:   }
    1: 
    1:   // Create event even without presContext.
    1:   return nsEventDispatcher::CreateEvent(presContext, nsnull,
    1:                                         aEventType, aReturn);
    1: }
    1: 
69754: void
69754: nsDocument::FlushPendingNotifications(mozFlushType aType)
69754: {
69754:   if ((!IsHTML() || aType > Flush_ContentAndNotify) &&
69754:       (mParser || mWeakSink)) {
 6170:     nsCOMPtr<nsIContentSink> sink;
 6170:     if (mParser) {
 6170:       sink = mParser->GetContentSink();
 6170:     } else {
 6170:       sink = do_QueryReferent(mWeakSink);
42227:       if (!sink) {
42227:         mWeakSink = nsnull;
42227:       }
 6170:     }
    1:     // Determine if it is safe to flush the sink notifications
    1:     // by determining if it safe to flush all the presshells.
 6170:     if (sink && (aType == Flush_Content || IsSafeToFlush())) {
    1:       sink->FlushPendingNotifications(aType);
    1:     }
42227:   }
    1: 
    1:   // Should we be flushing pending binding constructors in here?
    1: 
19869:   if (aType <= Flush_ContentAndNotify) {
    1:     // Nothing to do here
    1:     return;
    1:   }
    1: 
    1:   // If we have a parent we must flush the parent too to ensure that our
30709:   // container is reflowed if its size was changed.  But if it's not safe to
11417:   // flush ourselves, then don't flush the parent, since that can cause things
11417:   // like resizes of our frame's widget, which we can't handle while flushing
11417:   // is unsafe.
16227:   // Since media queries mean that a size change of our container can
16227:   // affect style, we need to promote a style flush on ourself to a
16227:   // layout flush on our parent, since we need our container to be the
16227:   // correct size to determine the correct style.
11417:   if (mParentDocument && IsSafeToFlush()) {
16227:     mozFlushType parentType = aType;
27993:     if (aType >= Flush_Style)
38390:       parentType = NS_MAX(Flush_Layout, aType);
16227:     mParentDocument->FlushPendingNotifications(parentType);
    1:   }
    1: 
46225:   nsCOMPtr<nsIPresShell> shell = GetShell();
36917:   if (shell) {
    1:     shell->FlushPendingNotifications(aType);
    1:   }
    1: }
    1: 
40701: static PRBool
40701: Flush(nsIDocument* aDocument, void* aData)
40701: {
40701:   const mozFlushType* type = static_cast<const mozFlushType*>(aData);
40701:   aDocument->FlushPendingNotifications(*type);
40701:   return PR_TRUE;
40701: }
40701: 
40701: void
40701: nsDocument::FlushExternalResources(mozFlushType aType)
40701: {
40701:   NS_ASSERTION(aType >= Flush_Style,
40701:     "should only need to flush for style or higher in external resources");
40701: 
40701:   if (GetDisplayDocument()) {
40701:     return;
40701:   }
40701:   EnumerateExternalResources(Flush, &aType);
40701: }
40701: 
    1: nsIScriptEventManager*
    1: nsDocument::GetScriptEventManager()
    1: {
    1:   if (!mScriptEventManager) {
    1:     mScriptEventManager = new nsScriptEventManager(this);
    1:     // automatically AddRefs
    1:   }
    1: 
    1:   return mScriptEventManager;
    1: }
    1: 
    1: void
    1: nsDocument::SetXMLDeclaration(const PRUnichar *aVersion,
    1:                               const PRUnichar *aEncoding,
    1:                               const PRInt32 aStandalone)
    1: {
    1:   if (!aVersion || *aVersion == '\0') {
    1:     mXMLDeclarationBits = 0;
    1:     return;
    1:   }
    1: 
    1:   mXMLDeclarationBits = XML_DECLARATION_BITS_DECLARATION_EXISTS;
    1: 
    1:   if (aEncoding && *aEncoding != '\0') {
    1:     mXMLDeclarationBits |= XML_DECLARATION_BITS_ENCODING_EXISTS;
    1:   }
    1: 
    1:   if (aStandalone == 1) {
    1:     mXMLDeclarationBits |= XML_DECLARATION_BITS_STANDALONE_EXISTS |
    1:                            XML_DECLARATION_BITS_STANDALONE_YES;
    1:   }
    1:   else if (aStandalone == 0) {
    1:     mXMLDeclarationBits |= XML_DECLARATION_BITS_STANDALONE_EXISTS;
    1:   }
    1: }
    1: 
    1: void
    1: nsDocument::GetXMLDeclaration(nsAString& aVersion, nsAString& aEncoding,
    1:                               nsAString& aStandalone)
    1: {
    1:   aVersion.Truncate();
    1:   aEncoding.Truncate();
    1:   aStandalone.Truncate();
    1: 
    1:   if (!(mXMLDeclarationBits & XML_DECLARATION_BITS_DECLARATION_EXISTS)) {
    1:     return;
    1:   }
    1: 
    1:   // always until we start supporting 1.1 etc.
    1:   aVersion.AssignLiteral("1.0");
    1: 
    1:   if (mXMLDeclarationBits & XML_DECLARATION_BITS_ENCODING_EXISTS) {
    1:     // This is what we have stored, not necessarily what was written
    1:     // in the original
    1:     GetCharacterSet(aEncoding);
    1:   }
    1: 
    1:   if (mXMLDeclarationBits & XML_DECLARATION_BITS_STANDALONE_EXISTS) {
    1:     if (mXMLDeclarationBits & XML_DECLARATION_BITS_STANDALONE_YES) {
    1:       aStandalone.AssignLiteral("yes");
    1:     } else {
    1:       aStandalone.AssignLiteral("no");
    1:     }
    1:   }
    1: }
    1: 
    1: PRBool
    1: nsDocument::IsScriptEnabled()
    1: {
    1:   nsCOMPtr<nsIScriptSecurityManager> sm(do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID));
20078:   NS_ENSURE_TRUE(sm, PR_FALSE);
    1: 
    1:   nsIScriptGlobalObject* globalObject = GetScriptGlobalObject();
20078:   NS_ENSURE_TRUE(globalObject, PR_FALSE);
    1: 
    1:   nsIScriptContext *scriptContext = globalObject->GetContext();
20078:   NS_ENSURE_TRUE(scriptContext, PR_FALSE);
    1: 
    1:   JSContext* cx = (JSContext *) scriptContext->GetNativeContext();
20078:   NS_ENSURE_TRUE(cx, PR_FALSE);
    1: 
    1:   PRBool enabled;
    1:   nsresult rv = sm->CanExecuteScripts(cx, NodePrincipal(), &enabled);
20078:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
    1:   return enabled;
    1: }
    1: 
    1: nsresult
    1: nsDocument::GetRadioGroup(const nsAString& aName,
    1:                           nsRadioGroupStruct **aRadioGroup)
    1: {
    1:   nsAutoString tmKey(aName);
31946:   if(IsHTML())
    1:      ToLowerCase(tmKey); //should case-insensitive.
 6365:   if (mRadioGroups.Get(tmKey, aRadioGroup))
 6365:     return NS_OK;
 6365: 
 6365:   nsAutoPtr<nsRadioGroupStruct> radioGroup(new nsRadioGroupStruct());
    1:   NS_ENSURE_TRUE(radioGroup, NS_ERROR_OUT_OF_MEMORY);
 6365:   NS_ENSURE_TRUE(mRadioGroups.Put(tmKey, radioGroup), NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   *aRadioGroup = radioGroup;
 6365:   radioGroup.forget();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::SetCurrentRadioButton(const nsAString& aName,
    1:                                   nsIDOMHTMLInputElement* aRadio)
    1: {
    1:   nsRadioGroupStruct* radioGroup = nsnull;
    1:   GetRadioGroup(aName, &radioGroup);
    1:   if (radioGroup) {
    1:     radioGroup->mSelectedRadioButton = aRadio;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetCurrentRadioButton(const nsAString& aName,
    1:                                   nsIDOMHTMLInputElement** aRadio)
    1: {
    1:   nsRadioGroupStruct* radioGroup = nsnull;
    1:   GetRadioGroup(aName, &radioGroup);
    1:   if (radioGroup) {
    1:     *aRadio = radioGroup->mSelectedRadioButton;
    1:     NS_IF_ADDREF(*aRadio);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetPositionInGroup(nsIDOMHTMLInputElement *aRadio,
    1:                                PRInt32 *aPositionIndex,
    1:                                PRInt32 *aItemsInGroup)
    1: {
    1:   *aPositionIndex = 0;
    1:   *aItemsInGroup = 1;
    1:   nsAutoString name;
    1:   aRadio->GetName(name);
    1:   if (name.IsEmpty()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsRadioGroupStruct* radioGroup = nsnull;
    1:   nsresult rv = GetRadioGroup(name, &radioGroup);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIFormControl> radioControl(do_QueryInterface(aRadio));
    1:   NS_ASSERTION(radioControl, "Radio button should implement nsIFormControl");
    1:   *aPositionIndex = radioGroup->mRadioButtons.IndexOf(radioControl);
    1:   NS_ASSERTION(*aPositionIndex >= 0, "Radio button not found in its own group");
    1:   *aItemsInGroup = radioGroup->mRadioButtons.Count();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::GetNextRadioButton(const nsAString& aName,
    1:                                const PRBool aPrevious,
    1:                                nsIDOMHTMLInputElement*  aFocusedRadio,
    1:                                nsIDOMHTMLInputElement** aRadioOut)
    1: {
    1:   // XXX Can we combine the HTML radio button method impls of 
    1:   //     nsDocument and nsHTMLFormControl?
    1:   // XXX Why is HTML radio button stuff in nsDocument, as 
    1:   //     opposed to nsHTMLDocument?
    1:   *aRadioOut = nsnull;
    1: 
    1:   nsRadioGroupStruct* radioGroup = nsnull;
    1:   GetRadioGroup(aName, &radioGroup);
    1:   if (!radioGroup) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // Return the radio button relative to the focused radio button.
    1:   // If no radio is focused, get the radio relative to the selected one.
    1:   nsCOMPtr<nsIDOMHTMLInputElement> currentRadio;
    1:   if (aFocusedRadio) {
    1:     currentRadio = aFocusedRadio;
    1:   }
    1:   else {
    1:     currentRadio = radioGroup->mSelectedRadioButton;
    1:     if (!currentRadio) {
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:   }
    1:   nsCOMPtr<nsIFormControl> radioControl(do_QueryInterface(currentRadio));
    1:   PRInt32 index = radioGroup->mRadioButtons.IndexOf(radioControl);
    1:   if (index < 0) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   PRInt32 numRadios = radioGroup->mRadioButtons.Count();
    1:   PRBool disabled;
    1:   nsCOMPtr<nsIDOMHTMLInputElement> radio;
    1:   do {
    1:     if (aPrevious) {
    1:       if (--index < 0) {
    1:         index = numRadios -1;
    1:       }
    1:     }
    1:     else if (++index >= numRadios) {
    1:       index = 0;
    1:     }
 6365:     radio = do_QueryInterface(radioGroup->mRadioButtons[index]);
    1:     NS_ASSERTION(radio, "mRadioButtons holding a non-radio button");
    1:     radio->GetDisabled(&disabled);
    1:   } while (disabled && radio != currentRadio);
    1: 
    1:   NS_IF_ADDREF(*aRadioOut = radio);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::AddToRadioGroup(const nsAString& aName,
    1:                             nsIFormControl* aRadio)
    1: {
    1:   nsRadioGroupStruct* radioGroup = nsnull;
    1:   GetRadioGroup(aName, &radioGroup);
    1:   if (radioGroup) {
 6365:     radioGroup->mRadioButtons.AppendObject(aRadio);
63105: 
63105:     nsCOMPtr<nsIContent> element = do_QueryInterface(aRadio);
63105:     NS_ASSERTION(element, "radio controls have to be content elements");
63105:     if (element->HasAttr(kNameSpaceID_None, nsGkAtoms::required)) {
63105:       radioGroup->mRequiredRadioCount++;
63105:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::RemoveFromRadioGroup(const nsAString& aName,
    1:                                  nsIFormControl* aRadio)
    1: {
    1:   nsRadioGroupStruct* radioGroup = nsnull;
    1:   GetRadioGroup(aName, &radioGroup);
    1:   if (radioGroup) {
 6365:     radioGroup->mRadioButtons.RemoveObject(aRadio);
63105: 
63105:     nsCOMPtr<nsIContent> element = do_QueryInterface(aRadio);
63105:     NS_ASSERTION(element, "radio controls have to be content elements");
63105:     if (element->HasAttr(kNameSpaceID_None, nsGkAtoms::required)) {
63105:       radioGroup->mRequiredRadioCount--;
63105:       NS_ASSERTION(radioGroup->mRequiredRadioCount >= 0,
63105:                    "mRequiredRadioCount shouldn't be negative!");
63105:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDocument::WalkRadioGroup(const nsAString& aName,
    1:                            nsIRadioVisitor* aVisitor,
    1:                            PRBool aFlushContent)
    1: {
    1:   nsRadioGroupStruct* radioGroup = nsnull;
    1:   GetRadioGroup(aName, &radioGroup);
    1:   if (!radioGroup) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   for (int i = 0; i < radioGroup->mRadioButtons.Count(); i++) {
67869:     if (!aVisitor->Visit(radioGroup->mRadioButtons[i])) {
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
63105: PRUint32
63105: nsDocument::GetRequiredRadioCount(const nsAString& aName) const
63105: {
63105:   nsRadioGroupStruct* radioGroup = nsnull;
63105:   // TODO: we should call GetRadioGroup here (and make it const) but for that
63105:   // we would need to have an explicit CreateRadioGroup() instead of create
63105:   // one when GetRadioGroup is called. See bug 636123.
63105:   nsAutoString tmKey(aName);
63105:   if (IsHTML())
63105:      ToLowerCase(tmKey); //should case-insensitive.
63105:   mRadioGroups.Get(tmKey, &radioGroup);
63105: 
63105:   return radioGroup ? radioGroup->mRequiredRadioCount : 0;
63105: }
63105: 
63105: void
63105: nsDocument::RadioRequiredChanged(const nsAString& aName, nsIFormControl* aRadio)
63105: {
63105:   nsRadioGroupStruct* radioGroup = nsnull;
63105:   GetRadioGroup(aName, &radioGroup);
63105: 
63105:   if (!radioGroup) {
63105:     return;
63105:   }
63105: 
63105:   nsCOMPtr<nsIContent> element = do_QueryInterface(aRadio);
63105:   NS_ASSERTION(element, "radio controls have to be content elements");
63105:   if (element->HasAttr(kNameSpaceID_None, nsGkAtoms::required)) {
63105:     radioGroup->mRequiredRadioCount++;
63105:   } else {
63105:     radioGroup->mRequiredRadioCount--;
63105:     NS_ASSERTION(radioGroup->mRequiredRadioCount >= 0,
63105:                  "mRequiredRadioCount shouldn't be negative!");
63105:   }
63105: }
63105: 
63107: bool
63107: nsDocument::GetValueMissingState(const nsAString& aName) const
63107: {
63107:   nsRadioGroupStruct* radioGroup = nsnull;
63107:   // TODO: we should call GetRadioGroup here (and make it const) but for that
63107:   // we would need to have an explicit CreateRadioGroup() instead of create
63107:   // one when GetRadioGroup is called. See bug 636123.
63107:   nsAutoString tmKey(aName);
63107:   if (IsHTML())
63107:      ToLowerCase(tmKey); //should case-insensitive.
63107:   mRadioGroups.Get(tmKey, &radioGroup);
63107: 
63107:   return radioGroup && radioGroup->mGroupSuffersFromValueMissing;
63107: }
63107: 
63107: void
63107: nsDocument::SetValueMissingState(const nsAString& aName, bool aValue)
63107: {
63107:   nsRadioGroupStruct* radioGroup = nsnull;
63107:   GetRadioGroup(aName, &radioGroup);
63107: 
63107:   if (!radioGroup) {
63107:     return;
63107:   }
63107: 
63107:   radioGroup->mGroupSuffersFromValueMissing = aValue;
63107: }
63107: 
    1: void
    1: nsDocument::RetrieveRelevantHeaders(nsIChannel *aChannel)
    1: {
    1:   nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(aChannel);
    1:   PRTime modDate = LL_ZERO;
    1:   nsresult rv;
    1: 
    1:   if (httpChannel) {
    1:     nsCAutoString tmp;
    1:     rv = httpChannel->GetResponseHeader(NS_LITERAL_CSTRING("last-modified"),
    1:                                         tmp);
    1: 
    1:     if (NS_SUCCEEDED(rv)) {
    1:       PRTime time;
    1:       PRStatus st = PR_ParseTimeString(tmp.get(), PR_TRUE, &time);
    1:       if (st == PR_SUCCESS) {
    1:         modDate = time;
    1:       }
    1:     }
    1: 
    1:     // The misspelled key 'referer' is as per the HTTP spec
    1:     rv = httpChannel->GetRequestHeader(NS_LITERAL_CSTRING("referer"),
    1:                                        mReferrer);
    1:     if (NS_FAILED(rv)) {
    1:       mReferrer.Truncate();
    1:     }
    1: 
    1:     static const char *const headers[] = {
    1:       "default-style",
    1:       "content-style-type",
    1:       "content-language",
    1:       "content-disposition",
    1:       "refresh",
21577:       "x-dns-prefetch-control",
37418:       "x-content-security-policy",
41197:       "x-content-security-policy-report-only",
48017:       "x-frame-options",
    1:       // add more http headers if you need
    1:       // XXXbz don't add content-location support without reading bug
    1:       // 238654 and its dependencies/dups first.
    1:       0
    1:     };
    1:     
    1:     nsCAutoString headerVal;
    1:     const char *const *name = headers;
    1:     while (*name) {
    1:       rv =
    1:         httpChannel->GetResponseHeader(nsDependentCString(*name), headerVal);
    1:       if (NS_SUCCEEDED(rv) && !headerVal.IsEmpty()) {
    1:         nsCOMPtr<nsIAtom> key = do_GetAtom(*name);
    1:         SetHeaderData(key, NS_ConvertASCIItoUTF16(headerVal));
    1:       }
    1:       ++name;
    1:     }
    1:   } else {
    1:     nsCOMPtr<nsIFileChannel> fileChannel = do_QueryInterface(aChannel);
    1:     if (fileChannel) {
    1:       nsCOMPtr<nsIFile> file;
    1:       fileChannel->GetFile(getter_AddRefs(file));
    1:       if (file) {
    1:         PRTime msecs;
    1:         rv = file->GetLastModifiedTime(&msecs);
    1: 
    1:         if (NS_SUCCEEDED(rv)) {
    1:           PRInt64 intermediateValue;
    1:           LL_I2L(intermediateValue, PR_USEC_PER_MSEC);
    1:           LL_MUL(modDate, msecs, intermediateValue);
    1:         }
    1:       }
    1:     } else {
51738:       nsCOMPtr<nsIMultiPartChannel> partChannel = do_QueryInterface(aChannel);
51738:       if (partChannel) {
    1:         nsCAutoString contentDisp;
51738:         rv = partChannel->GetContentDisposition(contentDisp);
    1:         if (NS_SUCCEEDED(rv) && !contentDisp.IsEmpty()) {
    1:           SetHeaderData(nsGkAtoms::headerContentDisposition,
    1:                         NS_ConvertASCIItoUTF16(contentDisp));
    1:         }
    1:       }
    1:     }
51738:   }
    1: 
    1:   if (LL_IS_ZERO(modDate)) {
    1:     // We got nothing from our attempt to ask nsIFileChannel and
    1:     // nsIHttpChannel for the last modified time. Return the current
    1:     // time.
    1:     modDate = PR_Now();
    1:   }
    1: 
    1:   mLastModified.Truncate();
    1:   if (LL_NE(modDate, LL_ZERO)) {
    1:     PRExplodedTime prtime;
    1:     PR_ExplodeTime(modDate, PR_LocalTimeParameters, &prtime);
    1:     // "MM/DD/YYYY hh:mm:ss"
 7783:     char formatedTime[24];
 7783:     if (PR_snprintf(formatedTime, sizeof(formatedTime),
 7783:                     "%02ld/%02ld/%04hd %02ld:%02ld:%02ld",
    1:                     prtime.tm_month + 1, prtime.tm_mday, prtime.tm_year,
    1:                     prtime.tm_hour     ,  prtime.tm_min,  prtime.tm_sec)) {
    1:       CopyASCIItoUTF16(nsDependentCString(formatedTime), mLastModified);
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult
48124: nsDocument::CreateElem(const nsAString& aName, nsIAtom *aPrefix, PRInt32 aNamespaceID,
    1:                        PRBool aDocumentDefaultType, nsIContent **aResult)
    1: {
    1: #ifdef DEBUG
    1:   nsAutoString qName;
    1:   if (aPrefix) {
    1:     aPrefix->ToString(qName);
    1:     qName.Append(':');
    1:   }
48124:   qName.Append(aName);
    1: 
11568:   // Note: "a:b:c" is a valid name in non-namespaces XML, and
11568:   // nsDocument::CreateElement can call us with such a name and no prefix,
11568:   // which would cause an error if we just used PR_TRUE here.
11568:   PRBool nsAware = aPrefix != nsnull || aNamespaceID != GetDefaultNamespaceID();
11568:   NS_ASSERTION(NS_SUCCEEDED(nsContentUtils::CheckQName(qName, nsAware)),
11568:                "Don't pass invalid prefixes to nsDocument::CreateElem, "
    1:                "check caller.");
    1: #endif
    1: 
    1:   *aResult = nsnull;
    1:   
    1:   PRInt32 elementType = aDocumentDefaultType ? mDefaultElementType :
    1:     aNamespaceID;
    1: 
    1:   nsCOMPtr<nsINodeInfo> nodeInfo;
48124:   mNodeInfoManager->GetNodeInfo(aName, aPrefix, aNamespaceID,
71770:                                 nsIDOMNode::ELEMENT_NODE,
48124:                                 getter_AddRefs(nodeInfo));
19747:   NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);
    1: 
56805:   return NS_NewElement(aResult, elementType, nodeInfo.forget(),
56805:                        NOT_FROM_PARSER);
    1: }
    1: 
    1: PRBool
    1: nsDocument::IsSafeToFlush() const
    1: {
46225:   nsCOMPtr<nsIPresShell> shell = GetShell();
39668:   if (!shell)
39668:     return PR_TRUE;
39668: 
39668:   return shell->IsSafeToFlush();
    1: }
    1: 
    1: nsresult
    1: nsDocument::Sanitize()
    1: {
    1:   // Sanitize the document by resetting all password fields and any form
    1:   // fields with autocomplete=off to their default values.  We do this now,
    1:   // instead of when the presentation is restored, to offer some protection
    1:   // in case there is ever an exploit that allows a cached document to be
    1:   // accessed from a different document.
    1: 
    1:   // First locate all input elements, regardless of whether they are
    1:   // in a form, and reset the password and autocomplete=off elements.
    1: 
    1:   nsCOMPtr<nsIDOMNodeList> nodes;
    1:   nsresult rv = GetElementsByTagName(NS_LITERAL_STRING("input"),
    1:                                      getter_AddRefs(nodes));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRUint32 length = 0;
    1:   if (nodes)
    1:     nodes->GetLength(&length);
    1: 
    1:   nsCOMPtr<nsIDOMNode> item;
    1:   nsAutoString value;
    1:   PRUint32 i;
    1: 
    1:   for (i = 0; i < length; ++i) {
    1:     nodes->Item(i, getter_AddRefs(item));
    1:     NS_ASSERTION(item, "null item in node list!");
    1: 
    1:     nsCOMPtr<nsIDOMHTMLInputElement> input = do_QueryInterface(item);
    1:     if (!input)
    1:       continue;
    1: 
    1:     PRBool resetValue = PR_FALSE;
    1: 
    1:     input->GetAttribute(NS_LITERAL_STRING("autocomplete"), value);
    1:     if (value.LowerCaseEqualsLiteral("off")) {
    1:       resetValue = PR_TRUE;
    1:     } else {
    1:       input->GetType(value);
    1:       if (value.LowerCaseEqualsLiteral("password"))
    1:         resetValue = PR_TRUE;
    1:     }
    1: 
    1:     if (resetValue) {
    1:       nsCOMPtr<nsIFormControl> fc = do_QueryInterface(input);
    1:       fc->Reset();
    1:     }
    1:   }
    1: 
    1:   // Now locate all _form_ elements that have autocomplete=off and reset them
    1:   rv = GetElementsByTagName(NS_LITERAL_STRING("form"), getter_AddRefs(nodes));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   length = 0;
    1:   if (nodes)
    1:     nodes->GetLength(&length);
    1: 
    1:   for (i = 0; i < length; ++i) {
    1:     nodes->Item(i, getter_AddRefs(item));
    1:     NS_ASSERTION(item, "null item in nodelist");
    1: 
    1:     nsCOMPtr<nsIDOMHTMLFormElement> form = do_QueryInterface(item);
    1:     if (!form)
    1:       continue;
    1: 
    1:     form->GetAttribute(NS_LITERAL_STRING("autocomplete"), value);
    1:     if (value.LowerCaseEqualsLiteral("off"))
    1:       form->Reset();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: struct SubDocEnumArgs
    1: {
    1:   nsIDocument::nsSubDocEnumFunc callback;
    1:   void *data;
    1: };
    1: 
20261: static PLDHashOperator
    1: SubDocHashEnum(PLDHashTable *table, PLDHashEntryHdr *hdr,
    1:                PRUint32 number, void *arg)
    1: {
 3233:   SubDocMapEntry *entry = static_cast<SubDocMapEntry*>(hdr);
 3233:   SubDocEnumArgs *args = static_cast<SubDocEnumArgs*>(arg);
    1: 
    1:   nsIDocument *subdoc = entry->mSubDocument;
    1:   PRBool next = subdoc ? args->callback(subdoc, args->data) : PR_TRUE;
    1: 
    1:   return next ? PL_DHASH_NEXT : PL_DHASH_STOP;
    1: }
    1: 
    1: void
    1: nsDocument::EnumerateSubDocuments(nsSubDocEnumFunc aCallback, void *aData)
    1: {
    1:   if (mSubDocuments) {
    1:     SubDocEnumArgs args = { aCallback, aData };
    1:     PL_DHashTableEnumerate(mSubDocuments, SubDocHashEnum, &args);
    1:   }
    1: }
    1: 
20261: static PLDHashOperator
    1: CanCacheSubDocument(PLDHashTable *table, PLDHashEntryHdr *hdr,
    1:                     PRUint32 number, void *arg)
    1: {
 3233:   SubDocMapEntry *entry = static_cast<SubDocMapEntry*>(hdr);
 3233:   PRBool *canCacheArg = static_cast<PRBool*>(arg);
    1: 
    1:   nsIDocument *subdoc = entry->mSubDocument;
    1: 
    1:   // The aIgnoreRequest we were passed is only for us, so don't pass it on.
    1:   PRBool canCache = subdoc ? subdoc->CanSavePresentation(nsnull) : PR_FALSE;
    1:   if (!canCache) {
    1:     *canCacheArg = PR_FALSE;
    1:     return PL_DHASH_STOP;
    1:   }
    1: 
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
    1: #ifdef DEBUG_bryner
    1: #define DEBUG_PAGE_CACHE
    1: #endif
    1: 
    1: PRBool
    1: nsDocument::CanSavePresentation(nsIRequest *aNewRequest)
    1: {
25722:   if (EventHandlingSuppressed()) {
25722:     return PR_FALSE;
25722:   }
25722: 
25722:   nsPIDOMWindow* win = GetInnerWindow();
25722:   if (win && win->TimeoutSuspendCount()) {
25722:     return PR_FALSE;
25722:   }
25722: 
    1:   // Check our event listener manager for unload/beforeunload listeners.
72326:   nsCOMPtr<nsIDOMEventTarget> piTarget = do_QueryInterface(mScriptGlobalObject);
 1418:   if (piTarget) {
72328:     nsEventListenerManager* manager =
29474:       piTarget->GetListenerManager(PR_FALSE);
    1:     if (manager && manager->HasUnloadListeners()) {
    1:       return PR_FALSE;
    1:     }
    1:   }
    1: 
61406:   // Check if we have pending network requests
    1:   nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
    1:   if (loadGroup) {
    1:     nsCOMPtr<nsISimpleEnumerator> requests;
    1:     loadGroup->GetRequests(getter_AddRefs(requests));
    1: 
    1:     PRBool hasMore = PR_FALSE;
    1: 
71166:     // We want to bail out if we have any requests other than aNewRequest (or
71166:     // in the case when aNewRequest is a part of a multipart response the base
71166:     // channel the multipart response is coming in on).
71166:     nsCOMPtr<nsIChannel> baseChannel;
71166:     nsCOMPtr<nsIMultiPartChannel> part(do_QueryInterface(aNewRequest));
71166:     if (part) {
71166:       part->GetBaseChannel(getter_AddRefs(baseChannel));
71166:     }
71166: 
    1:     while (NS_SUCCEEDED(requests->HasMoreElements(&hasMore)) && hasMore) {
    1:       nsCOMPtr<nsISupports> elem;
    1:       requests->GetNext(getter_AddRefs(elem));
    1: 
    1:       nsCOMPtr<nsIRequest> request = do_QueryInterface(elem);
71166:       if (request && request != aNewRequest && request != baseChannel) {
    1: #ifdef DEBUG_PAGE_CACHE
    1:         nsCAutoString requestName, docSpec;
    1:         request->GetName(requestName);
    1:         if (mDocumentURI)
    1:           mDocumentURI->GetSpec(docSpec);
    1: 
    1:         printf("document %s has request %s\n",
    1:                docSpec.get(), requestName.get());
    1: #endif
    1:         return PR_FALSE;
    1:       }
    1:     }
    1:   }
    1: 
61406:   // Check if we have running IndexedDB transactions
61406:   indexedDB::IndexedDatabaseManager* idbManager =
61406:     indexedDB::IndexedDatabaseManager::Get();
61406:   if (idbManager && idbManager->HasOpenTransactions(win)) {
61406:     return PR_FALSE;
61406:   }
61406: 
    1:   PRBool canCache = PR_TRUE;
    1:   if (mSubDocuments)
    1:     PL_DHashTableEnumerate(mSubDocuments, CanCacheSubDocument, &canCache);
    1: 
    1:   return canCache;
    1: }
    1: 
    1: void
    1: nsDocument::Destroy()
    1: {
    1:   // The ContentViewer wants to release the document now.  So, tell our content
    1:   // to drop any references to the document so that it can be destroyed.
    1:   if (mIsGoingAway)
    1:     return;
    1: 
    1:   mIsGoingAway = PR_TRUE;
 8462: 
14469:   RemovedFromDocShell();
14188: 
50721:   PRBool oldVal = mInUnlinkOrDeletion;
50721:   mInUnlinkOrDeletion = PR_TRUE;
 8462:   PRUint32 i, count = mChildren.ChildCount();
 8462:   for (i = 0; i < count; ++i) {
 8462:     mChildren.ChildAt(i)->DestroyContent();
 8462:   }
50721:   mInUnlinkOrDeletion = oldVal;
 8462: 
    1:   mLayoutHistoryState = nsnull;
    1: 
20078:   // Shut down our external resource map.  We might not need this for
20078:   // leak-fixing if we fix DocumentViewerImpl to do cycle-collection, but
20078:   // tearing down all those frame trees right now is the right thing to do.
20078:   mExternalResourceMap.Shutdown();
21384: 
21384:   // XXX We really should let cycle collection do this, but that currently still
21384:   //     leaks (see https://bugzilla.mozilla.org/show_bug.cgi?id=406684).
30001:   nsContentUtils::ReleaseWrapper(static_cast<nsINode*>(this), this);
    1: }
    1: 
14188: void
14469: nsDocument::RemovedFromDocShell()
14469: {
14469:   if (mRemovedFromDocShell)
14188:     return;
14188: 
14469:   mRemovedFromDocShell = PR_TRUE;
34207:   EnumerateFreezableElements(NotifyActivityChanged, nsnull); 
14188: 
14188:   PRUint32 i, count = mChildren.ChildCount();
14188:   for (i = 0; i < count; ++i) {
14188:     mChildren.ChildAt(i)->SaveSubtreeState();
14188:   }
14188: }
14188: 
    1: already_AddRefed<nsILayoutHistoryState>
    1: nsDocument::GetLayoutHistoryState() const
    1: {
    1:   nsILayoutHistoryState* state = nsnull;
    1:   if (!mScriptGlobalObject) {
    1:     NS_IF_ADDREF(state = mLayoutHistoryState);
    1:   } else {
    1:     nsCOMPtr<nsIDocShell> docShell(do_QueryReferent(mDocumentContainer));
    1:     if (docShell) {
    1:       docShell->GetLayoutHistoryState(&state);
    1:     }
    1:   }
    1: 
    1:   return state;
    1: }
    1: 
    1: void
40932: nsDocument::EnsureOnloadBlocker()
40932: {
40932:   // If mScriptGlobalObject is null, we shouldn't be messing with the loadgroup
40932:   // -- it's not ours.
40932:   if (mOnloadBlockCount != 0 && mScriptGlobalObject) {
40932:     nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
40932:     if (loadGroup) {
40932:       // Check first to see if mOnloadBlocker is in the loadgroup.
40932:       nsCOMPtr<nsISimpleEnumerator> requests;
40932:       loadGroup->GetRequests(getter_AddRefs(requests));
40932: 
40932:       PRBool hasMore = PR_FALSE;
40932:       while (NS_SUCCEEDED(requests->HasMoreElements(&hasMore)) && hasMore) {
40932:         nsCOMPtr<nsISupports> elem;
40932:         requests->GetNext(getter_AddRefs(elem));
40932:         nsCOMPtr<nsIRequest> request = do_QueryInterface(elem);
40932:         if (request && request == mOnloadBlocker) {
40932:           return;
40932:         }
40932:       }
40932: 
40932:       // Not in the loadgroup, so add it.
40932:       loadGroup->AddRequest(mOnloadBlocker, nsnull);
40932:     }
40932:   }
40932: }
40932: 
40932: void
41406: nsDocument::AsyncBlockOnload()
41406: {
41406:   while (mAsyncOnloadBlockCount) {
41406:     --mAsyncOnloadBlockCount;
41406:     BlockOnload();
41406:   }
41406: }
41406: 
41406: void
    1: nsDocument::BlockOnload()
    1: {
20078:   if (mDisplayDocument) {
20078:     mDisplayDocument->BlockOnload();
20078:     return;
20078:   }
20078:   
    1:   // If mScriptGlobalObject is null, we shouldn't be messing with the loadgroup
    1:   // -- it's not ours.
    1:   if (mOnloadBlockCount == 0 && mScriptGlobalObject) {
41406:     if (!nsContentUtils::IsSafeToRunScript()) {
41406:       // Because AddRequest may lead to OnStateChange calls in chrome,
41406:       // block onload only when there are no script blockers.
41406:       ++mAsyncOnloadBlockCount;
41406:       if (mAsyncOnloadBlockCount == 1) {
41406:         nsContentUtils::AddScriptRunner(
41410:           NS_NewRunnableMethod(this, &nsDocument::AsyncBlockOnload));
41406:       }
41406:       return;
41406:     }
    1:     nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
    1:     if (loadGroup) {
    1:       loadGroup->AddRequest(mOnloadBlocker, nsnull);
    1:     }
    1:   }
    1:   ++mOnloadBlockCount;      
    1: }
    1: 
    1: void
    1: nsDocument::UnblockOnload(PRBool aFireSync)
    1: {
20078:   if (mDisplayDocument) {
20078:     mDisplayDocument->UnblockOnload(aFireSync);
20078:     return;
20078:   }
20078: 
41406:   if (mOnloadBlockCount == 0 && mAsyncOnloadBlockCount == 0) {
    1:     NS_NOTREACHED("More UnblockOnload() calls than BlockOnload() calls; dropping call");
    1:     return;
    1:   }
    1: 
    1:   --mOnloadBlockCount;
    1: 
    1:   // If mScriptGlobalObject is null, we shouldn't be messing with the loadgroup
    1:   // -- it's not ours.
    1:   if (mOnloadBlockCount == 0 && mScriptGlobalObject) {
41406:     if (aFireSync && mAsyncOnloadBlockCount == 0) {
    1:       // Increment mOnloadBlockCount, since DoUnblockOnload will decrement it
    1:       ++mOnloadBlockCount;
    1:       DoUnblockOnload();
    1:     } else {
    1:       PostUnblockOnloadEvent();
    1:     }
    1:   }
    1: }
    1: 
    1: class nsUnblockOnloadEvent : public nsRunnable {
    1: public:
    1:   nsUnblockOnloadEvent(nsDocument *doc) : mDoc(doc) {}
    1:   NS_IMETHOD Run() {
    1:     mDoc->DoUnblockOnload();
    1:     return NS_OK;
    1:   }
    1: private:  
    1:   nsRefPtr<nsDocument> mDoc;
    1: };
    1: 
    1: void
    1: nsDocument::PostUnblockOnloadEvent()
    1: {
    1:   nsCOMPtr<nsIRunnable> evt = new nsUnblockOnloadEvent(this);
    1:   nsresult rv = NS_DispatchToCurrentThread(evt);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     // Stabilize block count so we don't post more events while this one is up
    1:     ++mOnloadBlockCount;
    1:   } else {
    1:     NS_WARNING("failed to dispatch nsUnblockOnloadEvent");
    1:   }
    1: }
    1: 
    1: void
    1: nsDocument::DoUnblockOnload()
    1: {
20078:   NS_PRECONDITION(!mDisplayDocument,
20078:                   "Shouldn't get here for resource document");
20078:   NS_PRECONDITION(mOnloadBlockCount != 0,
    1:                   "Shouldn't have a count of zero here, since we stabilized in "
    1:                   "PostUnblockOnloadEvent");
    1:   
    1:   --mOnloadBlockCount;
    1: 
    1:   if (mOnloadBlockCount != 0) {
    1:     // We blocked again after the last unblock.  Nothing to do here.  We'll
    1:     // post a new event when we unblock again.
    1:     return;
    1:   }
    1: 
41406:   if (mAsyncOnloadBlockCount != 0) {
41406:     // We need to wait until the async onload block has been handled.
41406:     PostUnblockOnloadEvent();
41406:   }
41406: 
    1:   // If mScriptGlobalObject is null, we shouldn't be messing with the loadgroup
    1:   // -- it's not ours.
    1:   if (mScriptGlobalObject) {
    1:     nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
    1:     if (loadGroup) {
    1:       loadGroup->RemoveRequest(mOnloadBlocker, nsnull, NS_OK);
    1:     }
    1:   }
    1: }
    1: 
    1: /* See if document is a child of this.  If so, return the frame element in this
    1:  * document that holds currentDoc (or an ancestor). */
    1: already_AddRefed<nsIDOMElement>
    1: nsDocument::CheckAncestryAndGetFrame(nsIDocument* aDocument) const
    1: {
    1:   nsIDocument* parentDoc;
    1:   for (parentDoc = aDocument->GetParentDocument();
 3233:        parentDoc != static_cast<const nsIDocument* const>(this);
    1:        parentDoc = parentDoc->GetParentDocument()) {
    1:     if (!parentDoc) {
    1:       return nsnull;
    1:     }
    1: 
    1:     aDocument = parentDoc;
    1:   }
    1: 
    1:   // In a child document.  Get the appropriate frame.
    1:   nsPIDOMWindow* currentWindow = aDocument->GetWindow();
    1:   if (!currentWindow) {
    1:     return nsnull;
    1:   }
    1:   nsIDOMElement* frameElement = currentWindow->GetFrameElementInternal();
    1:   if (!frameElement) {
    1:     return nsnull;
    1:   }
    1: 
    1:   // Sanity check result
    1:   nsCOMPtr<nsIDOMDocument> domDocument;
    1:   frameElement->GetOwnerDocument(getter_AddRefs(domDocument));
    1:   if (domDocument != this) {
    1:     NS_ERROR("Child documents should live in windows the parent owns");
    1:     return nsnull;
    1:   }
    1: 
    1:   NS_ADDREF(frameElement);
    1:   return frameElement;
    1: }
    1: 
    1: void
72326: nsDocument::DispatchPageTransition(nsIDOMEventTarget* aDispatchTarget,
29539:                                    const nsAString& aType,
29539:                                    PRBool aPersisted)
29539: {
29539:   if (aDispatchTarget) {
29539:     nsCOMPtr<nsIDOMEvent> event;
29539:     CreateEvent(NS_LITERAL_STRING("pagetransition"), getter_AddRefs(event));
29539:     nsCOMPtr<nsIDOMPageTransitionEvent> ptEvent = do_QueryInterface(event);
29539:     nsCOMPtr<nsIPrivateDOMEvent> pEvent = do_QueryInterface(ptEvent);
29539:     if (pEvent && NS_SUCCEEDED(ptEvent->InitPageTransitionEvent(aType, PR_TRUE,
29539:                                                                 PR_TRUE,
29539:                                                                 aPersisted))) {
29539:       pEvent->SetTrusted(PR_TRUE);
29539:       pEvent->SetTarget(this);
29539:       nsEventDispatcher::DispatchDOMEvent(aDispatchTarget, nsnull, event,
29539:                                           nsnull, nsnull);
29539:     }
29539:   }
    1: }
    1: 
36864: static PRBool
36864: NotifyPageShow(nsIDocument* aDocument, void* aData)
36864: {
36869:   const PRBool* aPersistedPtr = static_cast<const PRBool*>(aData);
36869:   aDocument->OnPageShow(*aPersistedPtr, nsnull);
36864:   return PR_TRUE;
36864: }
36864: 
    1: void
36864: nsDocument::OnPageShow(PRBool aPersisted,
36864:                        nsIDOMEventTarget* aDispatchStartTarget)
    1: {
    1:   mVisible = PR_TRUE;
34207: 
34207:   EnumerateFreezableElements(NotifyActivityChanged, nsnull);
36869:   EnumerateExternalResources(NotifyPageShow, &aPersisted);
36864: 
41634:   Element* root = GetRootElement();
 8938:   if (aPersisted && root) {
    1:     // Send out notifications that our <link> elements are attached.
 8938:     nsRefPtr<nsContentList> links = NS_GetContentList(root,
53966:                                                       kNameSpaceID_Unknown,
63637:                                                       NS_LITERAL_STRING("link"));
53966: 
    1:     PRUint32 linkCount = links->Length(PR_TRUE);
    1:     for (PRUint32 i = 0; i < linkCount; ++i) {
    1:       nsCOMPtr<nsILink> link = do_QueryInterface(links->Item(i, PR_FALSE));
    1:       if (link) {
    1:         link->LinkAdded();
    1:       }
    1:     }
    1:   }
    1: 
25572:   // See nsIDocument
25572:   if (!aDispatchStartTarget) {
25575:     // Set mIsShowing before firing events, in case those event handlers
25575:     // move us around.
23147:     mIsShowing = PR_TRUE;
25572:   }
23147:  
23697: #ifdef MOZ_SMIL
23697:   if (mAnimationController) {
23697:     mAnimationController->OnPageShow();
23697:   }
23697: #endif
52149: 
52149:   if (aPersisted) {
52149:     SetImagesNeedAnimating(PR_TRUE);
52149:   }
52149: 
72327:   nsCOMPtr<nsIDOMEventTarget> target = aDispatchStartTarget;
72327:   if (!target) {
72327:     target = do_QueryInterface(GetWindow());
72327:   }
29539:   DispatchPageTransition(target, NS_LITERAL_STRING("pageshow"), aPersisted);
25572: }
    1: 
36864: static PRBool
36864: NotifyPageHide(nsIDocument* aDocument, void* aData)
36864: {
36869:   const PRBool* aPersistedPtr = static_cast<const PRBool*>(aData);
36869:   aDocument->OnPageHide(*aPersistedPtr, nsnull);
36864:   return PR_TRUE;
36864: }
36864: 
    1: void
36864: nsDocument::OnPageHide(PRBool aPersisted,
36864:                        nsIDOMEventTarget* aDispatchStartTarget)
    1: {
    1:   // Send out notifications that our <link> elements are detached,
    1:   // but only if this is not a full unload.
41634:   Element* root = GetRootElement();
 8938:   if (aPersisted && root) {
 8938:     nsRefPtr<nsContentList> links = NS_GetContentList(root,
53966:                                                       kNameSpaceID_Unknown,
63637:                                                       NS_LITERAL_STRING("link"));
53966: 
    1:     PRUint32 linkCount = links->Length(PR_TRUE);
    1:     for (PRUint32 i = 0; i < linkCount; ++i) {
    1:       nsCOMPtr<nsILink> link = do_QueryInterface(links->Item(i, PR_FALSE));
    1:       if (link) {
    1:         link->LinkRemoved();
    1:       }
    1:     }
    1:   }
    1: 
25572:   // See nsIDocument
25572:   if (!aDispatchStartTarget) {
25575:     // Set mIsShowing before firing events, in case those event handlers
25575:     // move us around.
23147:     mIsShowing = PR_FALSE;
25572:   }
23147: 
23697: #ifdef MOZ_SMIL
23697:   if (mAnimationController) {
23697:     mAnimationController->OnPageHide();
23697:   }
23697: #endif
23697:   
52149:   if (aPersisted) {
52149:     SetImagesNeedAnimating(PR_FALSE);
52149:   }
52149: 
    1:   // Now send out a PageHide event.
72327:   nsCOMPtr<nsIDOMEventTarget> target = aDispatchStartTarget;
72327:   if (!target) {
72327:     target = do_QueryInterface(GetWindow());
72327:   }
29539:   DispatchPageTransition(target, NS_LITERAL_STRING("pagehide"), aPersisted);
    1: 
    1:   mVisible = PR_FALSE;
36869:   EnumerateExternalResources(NotifyPageHide, &aPersisted);
34207:   EnumerateFreezableElements(NotifyActivityChanged, nsnull);
    1: }
    1: 
   62: void
   62: nsDocument::WillDispatchMutationEvent(nsINode* aTarget)
   62: {
   62:   NS_ASSERTION(mSubtreeModifiedDepth != 0 ||
   62:                mSubtreeModifiedTargets.Count() == 0,
   62:                "mSubtreeModifiedTargets not cleared after dispatching?");
   62:   ++mSubtreeModifiedDepth;
   62:   if (aTarget) {
 3137:     // MayDispatchMutationEvent is often called just before this method,
 3137:     // so it has already appended the node to mSubtreeModifiedTargets.
 3137:     PRInt32 count = mSubtreeModifiedTargets.Count();
 3137:     if (!count || mSubtreeModifiedTargets[count - 1] != aTarget) {
   62:       mSubtreeModifiedTargets.AppendObject(aTarget);
   62:     }
   62:   }
 3137: }
   62: 
   62: void
   62: nsDocument::MutationEventDispatched(nsINode* aTarget)
   62: {
   62:   --mSubtreeModifiedDepth;
   62:   if (mSubtreeModifiedDepth == 0) {
   62:     PRInt32 count = mSubtreeModifiedTargets.Count();
   62:     if (!count) {
   62:       return;
   62:     }
   62: 
   62:     nsCOMPtr<nsPIDOMWindow> window;
   62:     window = do_QueryInterface(GetScriptGlobalObject());
   62:     if (window &&
   62:         !window->HasMutationListeners(NS_EVENT_BITS_MUTATION_SUBTREEMODIFIED)) {
   62:       mSubtreeModifiedTargets.Clear();
   62:       return;
   62:     }
   62: 
   62:     nsCOMArray<nsINode> realTargets;
   62:     for (PRInt32 i = 0; i < count; ++i) {
   62:       nsINode* possibleTarget = mSubtreeModifiedTargets[i];
13936:       nsCOMPtr<nsIContent> content = do_QueryInterface(possibleTarget);
13936:       if (content && content->IsInNativeAnonymousSubtree()) {
13936:         continue;
13936:       }
   62: 
   62:       nsINode* commonAncestor = nsnull;
   62:       PRInt32 realTargetCount = realTargets.Count();
   62:       for (PRInt32 j = 0; j < realTargetCount; ++j) {
   62:         commonAncestor =
   62:           nsContentUtils::GetCommonAncestor(possibleTarget, realTargets[j]);
   62:         if (commonAncestor) {
   62:           realTargets.ReplaceObjectAt(commonAncestor, j);
   62:           break;
   62:         }
   62:       }
   62:       if (!commonAncestor) {
   62:         realTargets.AppendObject(possibleTarget);
   62:       }
   62:     }
   62: 
   62:     mSubtreeModifiedTargets.Clear();
   62: 
   62:     PRInt32 realTargetCount = realTargets.Count();
   62:     for (PRInt32 k = 0; k < realTargetCount; ++k) {
   62:       nsMutationEvent mutation(PR_TRUE, NS_MUTATION_SUBTREEMODIFIED);
69573:       (new nsPLDOMEvent(realTargets[k], mutation))->RunDOMEventWhenSafe();
   62:     }
   62:   }
   62: }
   62: 
    1: void
38488: nsDocument::AddStyleRelevantLink(Link* aLink)
38488: {
38488:   NS_ASSERTION(aLink, "Passing in a null link.  Expect crashes RSN!");
38488: #ifdef DEBUG
38488:   nsPtrHashKey<Link>* entry = mStyledLinks.GetEntry(aLink);
38488:   NS_ASSERTION(!entry, "Document already knows about this Link!");
38488:   mStyledLinksCleared = false;
38488: #endif
38488:   (void)mStyledLinks.PutEntry(aLink);
    1: }
    1: 
    1: void
38488: nsDocument::ForgetLink(Link* aLink)
38488: {
38488:   NS_ASSERTION(aLink, "Passing in a null link.  Expect crashes RSN!");
38488: #ifdef DEBUG
38488:   nsPtrHashKey<Link>* entry = mStyledLinks.GetEntry(aLink);
38488:   NS_ASSERTION(entry || mStyledLinksCleared,
38488:                "Document knows nothing about this Link!");
38488: #endif
38488:   (void)mStyledLinks.RemoveEntry(aLink);
    1: }
    1: 
    1: void
43079: nsDocument::DestroyElementMaps()
    1: {
38488: #ifdef DEBUG
38488:   mStyledLinksCleared = true;
38488: #endif
38488:   mStyledLinks.Clear();
43079:   mIdentifierMap.Clear();
38488: }
38488: 
38488: static
38488: PLDHashOperator
38488: EnumerateStyledLinks(nsPtrHashKey<Link>* aEntry, void* aArray)
38488: {
57140:   LinkArray* array = static_cast<LinkArray*>(aArray);
38488:   (void)array->AppendElement(aEntry->GetKey());
33055:   return PL_DHASH_NEXT;
33055: }
33055: 
33055: void
33055: nsDocument::RefreshLinkHrefs()
33055: {
38488:   // Get a list of all links we know about.  We will reset them, which will
38488:   // remove them from the document, so we need a copy of what is in the
38488:   // hashtable.
57140:   LinkArray linksToNotify(mStyledLinks.Count());
38488:   (void)mStyledLinks.EnumerateEntries(EnumerateStyledLinks, &linksToNotify);
38488: 
38488:   // Reset all of our styled links.
71103:   nsAutoScriptBlocker scriptBlocker;
57140:   for (LinkArray::size_type i = 0; i < linksToNotify.Length(); i++) {
38488:     linksToNotify[i]->ResetLinkState(true);
33055:   }
33055: }
33055: 
19384: nsresult
19384: nsDocument::CloneDocHelper(nsDocument* clone) const
19384: {
35581:   clone->mIsStaticDocument = mCreatingStaticClone;
35581: 
19384:   // Init document
19384:   nsresult rv = clone->Init();
19384:   NS_ENSURE_SUCCESS(rv, rv);
19384: 
19384:   // Set URI/principal
19384:   clone->nsDocument::SetDocumentURI(nsIDocument::GetDocumentURI());
19384:   // Must set the principal first, since SetBaseURI checks it.
19384:   clone->SetPrincipal(NodePrincipal());
22362:   clone->mDocumentBaseURI = mDocumentBaseURI;
19384: 
35581:   if (mCreatingStaticClone) {
35581:     nsCOMPtr<nsIChannel> channel = GetChannel();
35581:     nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
35581:     if (channel && loadGroup) {
35581:       clone->Reset(channel, loadGroup);
35581:     } else {
35581:       nsIURI* uri = static_cast<const nsIDocument*>(this)->GetDocumentURI();
35581:       if (uri) {
35581:         clone->ResetToURI(uri, loadGroup, NodePrincipal());
35581:       }
35581:     }
35581:     nsCOMPtr<nsISupports> container = GetContainer();
35581:     clone->SetContainer(container);
35581:   }
35581: 
19384:   // Set scripting object
19384:   PRBool hasHadScriptObject = PR_TRUE;
19384:   nsIScriptGlobalObject* scriptObject =
19384:     GetScriptHandlingObject(hasHadScriptObject);
19384:   NS_ENSURE_STATE(scriptObject || !hasHadScriptObject);
19384:   clone->SetScriptHandlingObject(scriptObject);
19384: 
19384:   // Make the clone a data document
19384:   clone->SetLoadedAsData(PR_TRUE);
19384: 
19384:   // Misc state
19384: 
19384:   // State from nsIDocument
19384:   clone->mCharacterSet = mCharacterSet;
19384:   clone->mCharacterSetSource = mCharacterSetSource;
19384:   clone->mCompatMode = mCompatMode;
19384:   clone->mBidiOptions = mBidiOptions;
19384:   clone->mContentLanguage = mContentLanguage;
46309:   clone->SetContentTypeInternal(GetContentTypeInternal());
19384:   clone->mSecurityInfo = mSecurityInfo;
19384: 
19384:   // State from nsDocument
19384:   clone->mIsRegularHTML = mIsRegularHTML;
19384:   clone->mXMLDeclarationBits = mXMLDeclarationBits;
19384:   clone->mBaseTarget = mBaseTarget;
23639:   return NS_OK;
23639: }
23639: 
23639: void
23639: nsDocument::SetReadyStateInternal(ReadyState rs)
23639: {
23639:   mReadyState = rs;
72298:   if (mTiming) {
72298:     switch (rs) {
72298:       case READYSTATE_LOADING:
72298:         mTiming->NotifyDOMLoading(nsIDocument::GetDocumentURI());
72298:         break;
72298:       case READYSTATE_INTERACTIVE:
72298:         mTiming->NotifyDOMInteractive(nsIDocument::GetDocumentURI());
72298:         break;
72298:       case READYSTATE_COMPLETE:
72298:         mTiming->NotifyDOMComplete(nsIDocument::GetDocumentURI());
72298:         break;
72298:       default:
72298:         NS_WARNING("Unexpected ReadyState value");
72298:         break;
72298:     }
72298:   }
72298:   // At the time of loading start, we don't have timing object, record time.
72298:   if (READYSTATE_LOADING == rs) {
72298:     mLoadingTimeStamp = mozilla::TimeStamp::Now();
72298:   }
46273: 
46273:   nsRefPtr<nsPLDOMEvent> plevent =
46273:     new nsPLDOMEvent(this, NS_LITERAL_STRING("readystatechange"), PR_FALSE, PR_FALSE); 
46273:   if (plevent) {
46273:     plevent->RunDOMEventWhenSafe();
46273:   }
23639: }
23639: 
29975: nsIDocument::ReadyState
29975: nsDocument::GetReadyStateEnum()
29975: {
29975:   return mReadyState;
29975: }
23639: 
23639: NS_IMETHODIMP
23639: nsDocument::GetReadyState(nsAString& aReadyState)
23639: {
23639:   switch(mReadyState) {
23639:   case READYSTATE_LOADING :
23639:     aReadyState.Assign(NS_LITERAL_STRING("loading"));
23639:     break;
23639:   case READYSTATE_INTERACTIVE :
23639:     aReadyState.Assign(NS_LITERAL_STRING("interactive"));
23639:     break;
23639:   case READYSTATE_COMPLETE :
23639:     aReadyState.Assign(NS_LITERAL_STRING("complete"));
23639:     break;  
23639:   default:
23639:     aReadyState.Assign(NS_LITERAL_STRING("uninitialized"));
23639:   }
23639:   return NS_OK;
23639: }
25722: 
25722: static PRBool
25722: SuppressEventHandlingInDocument(nsIDocument* aDocument, void* aData)
25722: {
25722:   aDocument->SuppressEventHandling(*static_cast<PRUint32*>(aData));
25722:   return PR_TRUE;
25722: }
25722: 
25722: void
25722: nsDocument::SuppressEventHandling(PRUint32 aIncrease)
25722: {
25722:   mEventsSuppressed += aIncrease;
25722:   EnumerateSubDocuments(SuppressEventHandlingInDocument, &aIncrease);
25722: }
25722: 
26591: static void
26591: FireOrClearDelayedEvents(nsTArray<nsCOMPtr<nsIDocument> >& aDocuments,
26591:                          PRBool aFireEvents)
26591: {
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   if (!fm)
29018:     return;
29018: 
26591:   for (PRUint32 i = 0; i < aDocuments.Length(); ++i) {
26591:     if (!aDocuments[i]->EventHandlingSuppressed()) {
29018:       fm->FireDelayedEvents(aDocuments[i]);
46225:       nsCOMPtr<nsIPresShell> shell = aDocuments[i]->GetShell();
36917:       if (shell) {
26591:         shell->FireOrClearDelayedEvents(aFireEvents);
26591:       }
26591:     }
26591:   }
26591: }
26591: 
30065: void
30065: nsDocument::MaybePreLoadImage(nsIURI* uri)
30065: {
30065:   // Early exit if the img is already present in the img-cache
30065:   // which indicates that the "real" load has already started and
30065:   // that we shouldn't preload it.
37354:   PRInt16 blockingStatus;
37354:   if (nsContentUtils::IsImageInCache(uri) ||
37354:       !nsContentUtils::CanLoadImage(uri, static_cast<nsIDocument *>(this),
37354:                                     this, NodePrincipal(), &blockingStatus)) {
30065:     return;
30065:   }
30065: 
30065:   // Image not in cache - trigger preload
30065:   nsCOMPtr<imgIRequest> request;
30065:   nsresult rv =
30065:     nsContentUtils::LoadImage(uri,
30065:                               this,
30065:                               NodePrincipal(),
30065:                               mDocumentURI, // uri of document used as referrer
30065:                               nsnull,       // no observer
30065:                               nsIRequest::LOAD_NORMAL,
30065:                               getter_AddRefs(request));
30065: 
30065:   // Pin image-reference to avoid evicting it from the img-cache before
30065:   // the "real" load occurs. Unpinned in DispatchContentLoadedEvents and
30065:   // unlink
30065:   if (NS_SUCCEEDED(rv)) {
30065:     mPreloadingImages.AppendObject(request);
30065:   }
30065: }
37354: 
56168: nsEventStates
39698: nsDocument::GetDocumentState()
39698: {
56168:   if (!mGotDocumentState.HasState(NS_DOCUMENT_STATE_RTL_LOCALE)) {
39698:     if (IsDocumentRightToLeft()) {
39698:       mDocumentState |= NS_DOCUMENT_STATE_RTL_LOCALE;
39698:     }
39698:     mGotDocumentState |= NS_DOCUMENT_STATE_RTL_LOCALE;
39698:   }
56168:   if (!mGotDocumentState.HasState(NS_DOCUMENT_STATE_WINDOW_INACTIVE)) {
46225:     nsIPresShell* shell = GetShell();
39698:     if (shell && shell->GetPresContext() &&
39698:         shell->GetPresContext()->IsTopLevelWindowInactive()) {
39698:       mDocumentState |= NS_DOCUMENT_STATE_WINDOW_INACTIVE;
39698:     }
39698:     mGotDocumentState |= NS_DOCUMENT_STATE_WINDOW_INACTIVE;
39698:   }
39698:   return mDocumentState;
39698: }
39698: 
38850: namespace {
38850: 
38850: /**
38850:  * Stub for LoadSheet(), since all we want is to get the sheet into
38850:  * the CSSLoader's style cache
38850:  */
38850: class StubCSSLoaderObserver : public nsICSSLoaderObserver {
38850: public:
38850:   NS_IMETHOD
42163:   StyleSheetLoaded(nsCSSStyleSheet*, PRBool, nsresult)
38850:   {
38850:     return NS_OK;
38850:   }
38850:   NS_DECL_ISUPPORTS
38850: };
38850: NS_IMPL_ISUPPORTS1(StubCSSLoaderObserver, nsICSSLoaderObserver)
38850: 
38850: }
38850: 
38850: void
38850: nsDocument::PreloadStyle(nsIURI* uri, const nsAString& charset)
38850: {
38850:   // The CSSLoader will retain this object after we return.
38850:   nsCOMPtr<nsICSSLoaderObserver> obs = new StubCSSLoaderObserver();
38850: 
38850:   // Charset names are always ASCII.
38850:   CSSLoader()->LoadSheet(uri, NodePrincipal(),
38850:                          NS_LossyConvertUTF16toASCII(charset),
38850:                          obs);
38850: }
38850: 
38850: nsresult
38850: nsDocument::LoadChromeSheetSync(nsIURI* uri, PRBool isAgentSheet,
42163:                                 nsCSSStyleSheet** sheet)
38850: {
38850:   return CSSLoader()->LoadSheetSync(uri, isAgentSheet, isAgentSheet, sheet);
38850: }
38850: 
26591: class nsDelayedEventDispatcher : public nsRunnable
26591: {
26591: public:
26591:   nsDelayedEventDispatcher(nsTArray<nsCOMPtr<nsIDocument> >& aDocuments)
26591:   {
26591:     mDocuments.SwapElements(aDocuments);
26591:   }
26591:   virtual ~nsDelayedEventDispatcher() {}
26591: 
26591:   NS_IMETHOD Run()
26591:   {
26591:     FireOrClearDelayedEvents(mDocuments, PR_TRUE);
26591:     return NS_OK;
26591:   }
26591: 
26591: private:
26591:   nsTArray<nsCOMPtr<nsIDocument> > mDocuments;
26591: };
26591: 
25722: static PRBool
25722: GetAndUnsuppressSubDocuments(nsIDocument* aDocument, void* aData)
25722: {
25722:   PRUint32 suppression = aDocument->EventHandlingSuppressed();
25722:   if (suppression > 0) {
25722:     static_cast<nsDocument*>(aDocument)->DecreaseEventSuppression();
25722:   }
26591:   nsTArray<nsCOMPtr<nsIDocument> >* docs =
26591:     static_cast<nsTArray<nsCOMPtr<nsIDocument> >* >(aData);
26591:   docs->AppendElement(aDocument);
25722:   aDocument->EnumerateSubDocuments(GetAndUnsuppressSubDocuments, docs);
25722:   return PR_TRUE;
25722: }
25722: 
25722: void
25722: nsDocument::UnsuppressEventHandlingAndFireEvents(PRBool aFireEvents)
25722: {
25722:   if (mEventsSuppressed > 0) {
25722:     --mEventsSuppressed;
25722:   }
26591: 
26591:   nsTArray<nsCOMPtr<nsIDocument> > documents;
26591:   documents.AppendElement(this);
25722:   EnumerateSubDocuments(GetAndUnsuppressSubDocuments, &documents);
26591: 
26591:   if (aFireEvents) {
26591:     NS_DispatchToCurrentThread(new nsDelayedEventDispatcher(documents));
26591:   } else {
26591:     FireOrClearDelayedEvents(documents, PR_FALSE);
26591:   }
26591: }
26591: 
34394: nsISupports*
34394: nsDocument::GetCurrentContentSink()
34394: {
34394:   return mParser ? mParser->GetContentSink() : nsnull;
34394: }
34394: 
28108: void
53994: nsDocument::RegisterFileDataUri(const nsACString& aUri)
38871: {
38871:   mFileDataUris.AppendElement(aUri);
38871: }
38871: 
38871: void
53994: nsDocument::UnregisterFileDataUri(const nsACString& aUri)
53994: {
53994:   mFileDataUris.RemoveElement(aUri);
53994: }
53994: 
53994: void
69754: nsDocument::SetScrollToRef(nsIURI *aDocumentURI)
69754: {
69754:   if (!aDocumentURI) {
69754:     return;
69754:   }
69754: 
69754:   nsCAutoString ref;
69754: 
69754:   // Since all URI's that pass through here aren't URL's we can't
69754:   // rely on the nsIURI implementation for providing a way for
69754:   // finding the 'ref' part of the URI, we'll haveto revert to
69754:   // string routines for finding the data past '#'
69754: 
69754:   aDocumentURI->GetSpec(ref);
69754: 
69754:   nsReadingIterator<char> start, end;
69754: 
69754:   ref.BeginReading(start);
69754:   ref.EndReading(end);
69754: 
69754:   if (FindCharInReadable('#', start, end)) {
69754:     ++start; // Skip over the '#'
69754: 
69754:     mScrollToRef = Substring(start, end);
69754:   }
69754: }
69754: 
69754: void
42357: nsDocument::ScrollToRef()
42357: {
69754:   if (mScrolledToRefAlready) {
69754:     return;
69754:   }
69754: 
69754:   if (mScrollToRef.IsEmpty()) {
69754:     return;
69754:   }
69754: 
69754:   char* tmpstr = ToNewCString(mScrollToRef);
69754:   if (!tmpstr) {
69754:     return;
69754:   }
69754: 
69754:   nsUnescape(tmpstr);
69754:   nsCAutoString unescapedRef;
69754:   unescapedRef.Assign(tmpstr);
69754:   nsMemory::Free(tmpstr);
69754: 
69754:   nsresult rv = NS_ERROR_FAILURE;
69754:   // We assume that the bytes are in UTF-8, as it says in the spec:
69754:   // http://www.w3.org/TR/html4/appendix/notes.html#h-B.2.1
69754:   NS_ConvertUTF8toUTF16 ref(unescapedRef);
69754: 
69754:   nsCOMPtr<nsIPresShell> shell = GetShell();
69754:   if (shell) {
69754:     // Check an empty string which might be caused by the UTF-8 conversion
69754:     if (!ref.IsEmpty()) {
69754:       // Note that GoToAnchor will handle flushing layout as needed.
69754:       rv = shell->GoToAnchor(ref, mChangeScrollPosWhenScrollingToRef);
69754:     } else {
69754:       rv = NS_ERROR_FAILURE;
69754:     }
69754: 
69754:     // If UTF-8 URI failed then try to assume the string as a
69754:     // document's charset.
69754: 
69754:     if (NS_FAILED(rv)) {
69754:       const nsACString &docCharset = GetDocumentCharacterSet();
69754: 
69754:       rv = nsContentUtils::ConvertStringFromCharset(docCharset, unescapedRef, ref);
69754: 
69754:       if (NS_SUCCEEDED(rv) && !ref.IsEmpty()) {
69754:         rv = shell->GoToAnchor(ref, mChangeScrollPosWhenScrollingToRef);
69754:       }
69754:     }
69754:     if (NS_SUCCEEDED(rv)) {
69754:       mScrolledToRefAlready = PR_TRUE;
69754:     }
69754:   }
69754: }
69754: 
69754: void
69754: nsDocument::ResetScrolledToRefAlready()
69754: {
69754:   mScrolledToRefAlready = PR_FALSE;
69754: }
69754: 
69754: void
69754: nsDocument::SetChangeScrollPosWhenScrollingToRef(PRBool aValue)
69754: {
69754:   mChangeScrollPosWhenScrollingToRef = aValue;
42357: }
42357: 
42357: void
28108: nsIDocument::RegisterFreezableElement(nsIContent* aContent)
28108: {
28108:   if (!mFreezableElements) {
28108:     mFreezableElements = new nsTHashtable<nsPtrHashKey<nsIContent> >();
28108:     if (!mFreezableElements)
28108:       return;
28108:     mFreezableElements->Init();
28108:   }
28108:   mFreezableElements->PutEntry(aContent);
28108: }
28108: 
28108: PRBool
28108: nsIDocument::UnregisterFreezableElement(nsIContent* aContent)
28108: {
28108:   if (!mFreezableElements)
28108:     return PR_FALSE;
28108:   if (!mFreezableElements->GetEntry(aContent))
28108:     return PR_FALSE;
28108:   mFreezableElements->RemoveEntry(aContent);
28108:   return PR_TRUE;
28108: }
28108: 
28108: struct EnumerateFreezablesData {
28108:   nsIDocument::FreezableElementEnumerator mEnumerator;
28108:   void* mData;
28108: };
28108: 
28108: static PLDHashOperator
28108: EnumerateFreezables(nsPtrHashKey<nsIContent>* aEntry, void* aData)
28108: {
28108:   EnumerateFreezablesData* data = static_cast<EnumerateFreezablesData*>(aData);
28108:   data->mEnumerator(aEntry->GetKey(), data->mData);
28108:   return PL_DHASH_NEXT;
28108: }
28108: 
28108: void
28108: nsIDocument::EnumerateFreezableElements(FreezableElementEnumerator aEnumerator,
28108:                                         void* aData)
28108: {
28108:   if (!mFreezableElements)
28108:     return;
28108:   EnumerateFreezablesData data = { aEnumerator, aData };
28108:   mFreezableElements->EnumerateEntries(EnumerateFreezables, &data);
28108: }
35581: 
35581: already_AddRefed<nsIDocument>
35581: nsIDocument::CreateStaticClone(nsISupports* aCloneContainer)
35581: {
35581:   nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(this);
35581:   NS_ENSURE_TRUE(domDoc, nsnull);
35581:   mCreatingStaticClone = PR_TRUE;
35581: 
35581:   // Make document use different container during cloning.
35581:   nsCOMPtr<nsISupports> originalContainer = GetContainer();
35581:   SetContainer(aCloneContainer);
35581:   nsCOMPtr<nsIDOMNode> clonedNode;
35581:   nsresult rv = domDoc->CloneNode(PR_TRUE, getter_AddRefs(clonedNode));
35581:   SetContainer(originalContainer);
35581: 
35581:   nsCOMPtr<nsIDocument> clonedDoc;
35581:   if (NS_SUCCEEDED(rv)) {
35581:     clonedDoc = do_QueryInterface(clonedNode);
35581:     nsCOMPtr<nsIDOMDocument> clonedDOMDoc = do_QueryInterface(clonedDoc);
35581:     if (clonedDOMDoc) {
35581:       clonedDoc->mOriginalDocument = this;
35581:       PRInt32 sheetsCount = GetNumberOfStyleSheets();
35581:       for (PRInt32 i = 0; i < sheetsCount; ++i) {
42163:         nsRefPtr<nsCSSStyleSheet> sheet = do_QueryObject(GetStyleSheetAt(i));
35581:         if (sheet) {
42332:           if (sheet->IsApplicable()) {
42163:             nsRefPtr<nsCSSStyleSheet> clonedSheet =
42162:               sheet->Clone(nsnull, nsnull, clonedDoc, nsnull);
35581:             NS_WARN_IF_FALSE(clonedSheet, "Cloning a stylesheet didn't work!");
35581:             if (clonedSheet) {
35581:               clonedDoc->AddStyleSheet(clonedSheet);
35581:             }
35581:           }
35581:         }
35581:       }
35581: 
35581:       sheetsCount = GetNumberOfCatalogStyleSheets();
35581:       for (PRInt32 i = 0; i < sheetsCount; ++i) {
42163:         nsRefPtr<nsCSSStyleSheet> sheet =
42163:           do_QueryObject(GetCatalogStyleSheetAt(i));
35581:         if (sheet) {
42332:           if (sheet->IsApplicable()) {
42163:             nsRefPtr<nsCSSStyleSheet> clonedSheet =
42162:               sheet->Clone(nsnull, nsnull, clonedDoc, nsnull);
35581:             NS_WARN_IF_FALSE(clonedSheet, "Cloning a stylesheet didn't work!");
35581:             if (clonedSheet) {
35581:               clonedDoc->AddCatalogStyleSheet(clonedSheet);
35581:             }
35581:           }
35581:         }
35581:       }
35581:     }
35581:   }
35581:   mCreatingStaticClone = PR_FALSE;
35581:   return clonedDoc.forget();
35581: }
50368: 
50368: void
52255: nsIDocument::ScheduleBeforePaintEvent(nsIAnimationFrameListener* aListener)
52255: {
52255:   if (aListener) {
52255:     PRBool alreadyRegistered = !mAnimationFrameListeners.IsEmpty();
52255:     if (mAnimationFrameListeners.AppendElement(aListener) &&
52255:         !alreadyRegistered && mPresShell) {
52255:       mPresShell->GetPresContext()->RefreshDriver()->
52255:         ScheduleAnimationFrameListeners(this);
52255:     }
52255: 
52255:     return;
52255:   }
52255: 
50368:   if (!mHavePendingPaint) {
50368:     // We don't want to use GetShell() here, because we want to schedule the
50368:     // paint even if we're frozen.  Either we'll get unfrozen and then the
50368:     // event will fire, or we'll quietly go away at some point.
50368:     mHavePendingPaint =
50368:       !mPresShell ||
50368:       mPresShell->GetPresContext()->RefreshDriver()->
50368:         ScheduleBeforePaintEvent(this);
50368:   }
52255: 
50368: }
50815: 
63882: nsresult
69563: nsDocument::GetStateObject(nsIVariant** aState)
69563: {
69563:   // Get the document's current state object. This is the object backing both
69563:   // history.state and popStateEvent.state.
69563:   //
69563:   // mStateObjectContainer may be null; this just means that there's no
69563:   // current state object.
62765: 
62765:   nsCOMPtr<nsIVariant> stateObj;
69563:   if (!mStateObjectCached && mStateObjectContainer) {
69563:     JSContext *cx = nsContentUtils::GetContextFromDocument(this);
69563:     mStateObjectContainer->
69563:       DeserializeToVariant(cx, getter_AddRefs(mStateObjectCached));
69563:   }
69563: 
69563:   NS_IF_ADDREF(*aState = mStateObjectCached);
62765:   
62765:   return NS_OK;
62765: }
62765: 
72298: nsDOMNavigationTiming*
72298: nsDocument::GetNavigationTiming() const
72298: {
72298:   return mTiming;
72298: }
72298: 
72298: nsresult
72298: nsDocument::SetNavigationTiming(nsDOMNavigationTiming* aTiming)
72298: {
72298:   mTiming = aTiming;
72298:   if (!mLoadingTimeStamp.IsNull() && mTiming) {
72298:     mTiming->SetDOMLoadingTimeStamp(nsIDocument::GetDocumentURI(), mLoadingTimeStamp);
72298:   }
72298:   return NS_OK;
72298: }
72298: 
71030: Element*
71031: nsDocument::FindImageMap(const nsAString& aUseMapValue)
71031: {
71031:   if (aUseMapValue.IsEmpty()) {
71031:     return nsnull;
71031:   }
71031: 
71031:   nsAString::const_iterator start, end;
71031:   aUseMapValue.BeginReading(start);
71031:   aUseMapValue.EndReading(end);
71031: 
71031:   PRInt32 hash = aUseMapValue.FindChar('#');
71031:   if (hash < 0) {
71031:     return nsnull;
71031:   }
71031:   // aUsemap contains a '#', set start to point right after the '#'
71031:   start.advance(hash + 1);
71031: 
71031:   if (start == end) {
71031:     return nsnull; // aUsemap == "#"
71031:   }
71031: 
71031:   const nsAString& mapName = Substring(start, end);
71031: 
71030:   if (!mImageMaps) {
71030:     mImageMaps = new nsContentList(this, kNameSpaceID_XHTML, nsGkAtoms::map, nsGkAtoms::map);
71030:   }
71030: 
71030:   PRUint32 i, n = mImageMaps->Length(PR_TRUE);
71030:   for (i = 0; i < n; ++i) {
71030:     nsIContent* map = mImageMaps->GetNodeAt(i);
71031:     if (map->AttrValueIs(kNameSpaceID_None, nsGkAtoms::id, mapName,
71030:                          eCaseMatters) ||
71031:         map->AttrValueIs(kNameSpaceID_None, nsGkAtoms::name, mapName,
71030:                          eIgnoreCase)) {
71030:       return map->AsElement();
71030:     }
71030:   }
71030: 
71030:   return nsnull;
71030: }
71030: 
72662: #define DEPRECATED_OPERATION(_op) #_op "Warning",
72272: static const char* kWarnings[] = {
72662: #include "nsDeprecatedOperationList.h"
72272: };
72662: #undef DEPRECATED_OPERATION
72272: 
72272: void
72272: nsIDocument::WarnOnceAbout(DeprecatedOperations aOperation)
72272: {
72272:   PR_STATIC_ASSERT(NS_ARRAY_LENGTH(kWarnings) < 32);
72272:   if (mWarnedAbout & (1 << aOperation)) {
72272:     return;
72272:   }
72272:   mWarnedAbout |= (1 << aOperation);
72272:   nsContentUtils::ReportToConsole(nsContentUtils::eDOM_PROPERTIES,
72272:                                   kWarnings[aOperation],
72272:                                   nsnull, 0,
72272:                                   nsnull,
72272:                                   EmptyString(), 0, 0,
72272:                                   nsIScriptError::warningFlag,
72272:                                   "DOM Core", this);
72272: }
72272: 
50815: nsresult
50815: nsDocument::AddImage(imgIRequest* aImage)
50815: {
50815:   NS_ENSURE_ARG_POINTER(aImage);
50815: 
50815:   // See if the image is already in the hashtable. If it is, get the old count.
50815:   PRUint32 oldCount = 0;
50815:   mImageTracker.Get(aImage, &oldCount);
50815: 
50815:   // Put the image in the hashtable, with the proper count.
50815:   PRBool success = mImageTracker.Put(aImage, oldCount + 1);
50815:   if (!success)
50815:     return NS_ERROR_OUT_OF_MEMORY;
50815: 
61325:   nsresult rv = NS_OK;
61325: 
50815:   // If this is the first insertion and we're locking images, lock this image
50815:   // too.
61325:   if (oldCount == 0 && mLockingImages) {
61325:     rv = aImage->LockImage();
61325:     if (NS_SUCCEEDED(rv))
52149:       rv = aImage->RequestDecode();
52149:   }
52149: 
52149:   // If this is the first insertion and we're animating images, request
52149:   // that this image be animated too.
52149:   if (oldCount == 0 && mAnimatingImages) {
61325:     nsresult rv2 = aImage->IncrementAnimationConsumers();
61325:     rv = NS_SUCCEEDED(rv) ? rv2 : rv;
61325:   }
61325: 
61325:   return rv;
50815: }
50815: 
50815: nsresult
50815: nsDocument::RemoveImage(imgIRequest* aImage)
50815: {
50815:   NS_ENSURE_ARG_POINTER(aImage);
50815: 
50815:   // Get the old count. It should exist and be > 0.
50815:   PRUint32 count;
68468: #ifdef DEBUG
68468:   PRBool found =
68468: #endif
68468:   mImageTracker.Get(aImage, &count);
50815:   NS_ABORT_IF_FALSE(found, "Removing image that wasn't in the tracker!");
50815:   NS_ABORT_IF_FALSE(count > 0, "Entry in the cache tracker with count 0!");
50815: 
50815:   // We're removing, so decrement the count.
50815:   count--;
50815: 
50815:   // If the count is now zero, remove from the tracker.
50815:   // Otherwise, set the new value.
50815:   if (count == 0) {
50815:     mImageTracker.Remove(aImage);
50815:   } else {
50815:     mImageTracker.Put(aImage, count);
50815:   }
50815: 
61325:   nsresult rv = NS_OK;
61325: 
50815:   // If we removed the image from the tracker and we're locking images, unlock
50815:   // this image.
61325:   if (count == 0 && mLockingImages)
61325:     rv = aImage->UnlockImage();
50815: 
52149:   // If we removed the image from the tracker and we're animating images,
52149:   // remove our request to animate this image.
61325:   if (count == 0 && mAnimatingImages) {
61325:     nsresult rv2 = aImage->DecrementAnimationConsumers();
61325:     rv = NS_SUCCEEDED(rv) ? rv2 : rv;
61325:   }
61325: 
61325:   return rv;
50815: }
50815: 
50815: PLDHashOperator LockEnumerator(imgIRequest* aKey,
50815:                                PRUint32 aData,
50815:                                void*    userArg)
50815: {
50815:   aKey->LockImage();
50815:   aKey->RequestDecode();
50815:   return PL_DHASH_NEXT;
50815: }
50815: 
50815: PLDHashOperator UnlockEnumerator(imgIRequest* aKey,
50815:                                  PRUint32 aData,
50815:                                  void*    userArg)
50815: {
50815:   aKey->UnlockImage();
50815:   return PL_DHASH_NEXT;
50815: }
50815: 
50815: 
50815: nsresult
50815: nsDocument::SetImageLockingState(PRBool aLocked)
50815: {
62607:   if (XRE_GetProcessType() == GeckoProcessType_Content &&
70840:       !Preferences::GetBool("content.image.allow_locking", PR_TRUE)) {
62607:     return NS_OK;
62607:   }
62607: 
50815:   // If there's no change, there's nothing to do.
50815:   if (mLockingImages == aLocked)
50815:     return NS_OK;
50815: 
50815:   // Otherwise, iterate over our images and perform the appropriate action.
50815:   mImageTracker.EnumerateRead(aLocked ? LockEnumerator
50815:                                       : UnlockEnumerator,
50815:                               nsnull);
50815: 
50815:   // Update state.
50815:   mLockingImages = aLocked;
50815: 
50815:   return NS_OK;
50815: }
52149: 
52149: PLDHashOperator IncrementAnimationEnumerator(imgIRequest* aKey,
52149:                                              PRUint32 aData,
52149:                                              void*    userArg)
52149: {
52149:   aKey->IncrementAnimationConsumers();
52149:   return PL_DHASH_NEXT;
52149: }
52149: 
52149: PLDHashOperator DecrementAnimationEnumerator(imgIRequest* aKey,
52149:                                              PRUint32 aData,
52149:                                              void*    userArg)
52149: {
52149:   aKey->DecrementAnimationConsumers();
52149:   return PL_DHASH_NEXT;
52149: }
52149: 
52149: void
52149: nsDocument::SetImagesNeedAnimating(PRBool aAnimating)
52149: {
52149:   // If there's no change, there's nothing to do.
52149:   if (mAnimatingImages == aAnimating)
52149:     return;
52149: 
52149:   // Otherwise, iterate over our images and perform the appropriate action.
52149:   mImageTracker.EnumerateRead(aAnimating ? IncrementAnimationEnumerator
52149:                                          : DecrementAnimationEnumerator,
52149:                               nsnull);
52149: 
52149:   // Update state.
52149:   mAnimatingImages = aAnimating;
52149: }
68879: 
68879: NS_IMETHODIMP
69169: nsDocument::CreateTouch(nsIDOMWindow* aView,
68879:                         nsIDOMEventTarget* aTarget,
68879:                         PRInt32 aIdentifier,
68879:                         PRInt32 aPageX,
68879:                         PRInt32 aPageY,
68879:                         PRInt32 aScreenX,
68879:                         PRInt32 aScreenY,
68879:                         PRInt32 aClientX,
68879:                         PRInt32 aClientY,
68879:                         PRInt32 aRadiusX,
68879:                         PRInt32 aRadiusY,
68879:                         float aRotationAngle,
68879:                         float aForce,
69025:                         nsIDOMTouch** aRetVal)
69025: {
69025:   NS_ADDREF(*aRetVal = new nsDOMTouch(aTarget,
68879:                                       aIdentifier,
68879:                                       aPageX,
68879:                                       aPageY,
68879:                                       aScreenX,
68879:                                       aScreenY,
68879:                                       aClientX,
68879:                                       aClientY,
68879:                                       aRadiusX,
68879:                                       aRadiusY,
68879:                                       aRotationAngle,
68879:                                       aForce));
69025:   return NS_OK;
68879: }
68879: 
68879: NS_IMETHODIMP
68879: nsDocument::CreateTouchList(nsIVariant* aPoints,
68879:                             nsIDOMTouchList** aRetVal)
68879: {
68879:   nsRefPtr<nsDOMTouchList> retval = new nsDOMTouchList();
68879:   if (aPoints) {
68879:     PRUint16 type;
68879:     aPoints->GetDataType(&type);
68879:     if (type == nsIDataType::VTYPE_INTERFACE ||
68879:         type == nsIDataType::VTYPE_INTERFACE_IS) {
68879:       nsCOMPtr<nsISupports> data;
68879:       aPoints->GetAsISupports(getter_AddRefs(data));
69025:       nsCOMPtr<nsIDOMTouch> point = do_QueryInterface(data);
68879:       if (point) {
68879:         retval->Append(point);
68879:       }
68879:     } else if (type == nsIDataType::VTYPE_ARRAY) {
68879:       PRUint16 valueType;
68879:       nsIID iid;
68879:       PRUint32 valueCount;
68879:       void* rawArray;
68879:       aPoints->GetAsArray(&valueType, &iid, &valueCount, &rawArray);
68879:       if (valueType == nsIDataType::VTYPE_INTERFACE ||
68879:           valueType == nsIDataType::VTYPE_INTERFACE_IS) {
68879:         nsISupports** values = static_cast<nsISupports**>(rawArray);
68879:         for (PRUint32 i = 0; i < valueCount; ++i) {
68879:           nsCOMPtr<nsISupports> supports = dont_AddRef(values[i]);
69025:           nsCOMPtr<nsIDOMTouch> point = do_QueryInterface(supports);
68879:           if (point) {
68879:             retval->Append(point);
68879:           }
68879:         }
68879:       }
68879:       nsMemory::Free(rawArray);
68879:     }
68879:   }
68879: 
68879:   *aRetVal = retval.forget().get();
68879:   return NS_OK;
68879: }
70432: 
