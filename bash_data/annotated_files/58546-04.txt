    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Daniel Glazman <glazman@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef nsHTMLEditRules_h__
    1: #define nsHTMLEditRules_h__
    1: 
    1: #include "nsTextEditRules.h"
    1: #include "nsIHTMLEditRules.h"
    1: #include "nsIEditActionListener.h"
    1: #include "nsCOMArray.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsString.h"
    1: #include "nsEditorUtils.h"
    1: #include "TypeInState.h"
    1: #include "nsReadableUtils.h"
27986: #include "nsTArray.h"
    1: 
    1: class nsIDOMElement;
    1: class nsIEditor;
    1: class nsHTMLEditor;
    1: 
    1: struct StyleCache : public PropItem
    1: {
    1:   PRBool mPresent;
    1:   
 8943:   StyleCache() : PropItem(), mPresent(PR_FALSE) {
 8943:     MOZ_COUNT_CTOR(StyleCache);
 8943:   }
 8943: 
    1:   StyleCache(nsIAtom *aTag, const nsAString &aAttr, const nsAString &aValue) : 
 8943:              PropItem(aTag, aAttr, aValue), mPresent(PR_FALSE) {
 8943:     MOZ_COUNT_CTOR(StyleCache);
 8943:   }
 8943: 
 8943:   ~StyleCache() {
 8943:     MOZ_COUNT_DTOR(StyleCache);
 8943:   }
    1: };
    1: 
    1: 
    1: #define SIZE_STYLE_TABLE 19
    1: 
28153: class nsHTMLEditRules : public nsTextEditRules, public nsIHTMLEditRules, public nsIEditActionListener
    1: {
    1: public:
    1: 
    1:   NS_DECL_ISUPPORTS_INHERITED
    1:   
    1:             nsHTMLEditRules();
    1:   virtual   ~nsHTMLEditRules();
    1: 
    1: 
    1:   // nsIEditRules methods
40703:   NS_IMETHOD Init(nsPlaintextEditor *aEditor);
28152:   NS_IMETHOD DetachEditor();
    1:   NS_IMETHOD BeforeEdit(PRInt32 action, nsIEditor::EDirection aDirection);
    1:   NS_IMETHOD AfterEdit(PRInt32 action, nsIEditor::EDirection aDirection);
    1:   NS_IMETHOD WillDoAction(nsISelection *aSelection, nsRulesInfo *aInfo, PRBool *aCancel, PRBool *aHandled);
    1:   NS_IMETHOD DidDoAction(nsISelection *aSelection, nsRulesInfo *aInfo, nsresult aResult);
57481:   NS_IMETHOD DocumentModified();
    1: 
    1:   // nsIHTMLEditRules methods
    1:   
    1:   NS_IMETHOD GetListState(PRBool *aMixed, PRBool *aOL, PRBool *aUL, PRBool *aDL);
    1:   NS_IMETHOD GetListItemState(PRBool *aMixed, PRBool *aLI, PRBool *aDT, PRBool *aDD);
    1:   NS_IMETHOD GetIndentState(PRBool *aCanIndent, PRBool *aCanOutdent);
    1:   NS_IMETHOD GetAlignment(PRBool *aMixed, nsIHTMLEditor::EAlignment *aAlign);
    1:   NS_IMETHOD GetParagraphState(PRBool *aMixed, nsAString &outFormat);
    1:   NS_IMETHOD MakeSureElemStartsOrEndsOnCR(nsIDOMNode *aNode);
    1: 
    1:   // nsIEditActionListener methods
    1:   
    1:   NS_IMETHOD WillCreateNode(const nsAString& aTag, nsIDOMNode *aParent, PRInt32 aPosition);
    1:   NS_IMETHOD DidCreateNode(const nsAString& aTag, nsIDOMNode *aNode, nsIDOMNode *aParent, PRInt32 aPosition, nsresult aResult);
    1:   NS_IMETHOD WillInsertNode(nsIDOMNode *aNode, nsIDOMNode *aParent, PRInt32 aPosition);
    1:   NS_IMETHOD DidInsertNode(nsIDOMNode *aNode, nsIDOMNode *aParent, PRInt32 aPosition, nsresult aResult);
    1:   NS_IMETHOD WillDeleteNode(nsIDOMNode *aChild);
    1:   NS_IMETHOD DidDeleteNode(nsIDOMNode *aChild, nsresult aResult);
    1:   NS_IMETHOD WillSplitNode(nsIDOMNode *aExistingRightNode, PRInt32 aOffset);
    1:   NS_IMETHOD DidSplitNode(nsIDOMNode *aExistingRightNode, PRInt32 aOffset, nsIDOMNode *aNewLeftNode, nsresult aResult);
    1:   NS_IMETHOD WillJoinNodes(nsIDOMNode *aLeftNode, nsIDOMNode *aRightNode, nsIDOMNode *aParent);
    1:   NS_IMETHOD DidJoinNodes(nsIDOMNode  *aLeftNode, nsIDOMNode *aRightNode, nsIDOMNode *aParent, nsresult aResult);
    1:   NS_IMETHOD WillInsertText(nsIDOMCharacterData *aTextNode, PRInt32 aOffset, const nsAString &aString);
    1:   NS_IMETHOD DidInsertText(nsIDOMCharacterData *aTextNode, PRInt32 aOffset, const nsAString &aString, nsresult aResult);
    1:   NS_IMETHOD WillDeleteText(nsIDOMCharacterData *aTextNode, PRInt32 aOffset, PRInt32 aLength);
    1:   NS_IMETHOD DidDeleteText(nsIDOMCharacterData *aTextNode, PRInt32 aOffset, PRInt32 aLength, nsresult aResult);
    1:   NS_IMETHOD WillDeleteRange(nsIDOMRange *aRange);
    1:   NS_IMETHOD DidDeleteRange(nsIDOMRange *aRange);
    1:   NS_IMETHOD WillDeleteSelection(nsISelection *aSelection);
    1:   NS_IMETHOD DidDeleteSelection(nsISelection *aSelection);
    1: 
    1: protected:
    1: 
    1:   enum RulesEndpoint
    1:   {
    1:     kStart,
    1:     kEnd
    1:   };
    1: 
    1:   enum BRLocation
    1:   {
    1:     kBeforeBlock,
    1:     kBlockEnd
    1:   };
    1: 
    1:   // nsHTMLEditRules implementation methods
    1:   nsresult WillInsert(nsISelection *aSelection, PRBool *aCancel);
    1: #ifdef XXX_DEAD_CODE
    1:   nsresult DidInsert(nsISelection *aSelection, nsresult aResult);
    1: #endif
    1:   nsresult WillInsertText(  PRInt32          aAction,
    1:                             nsISelection *aSelection, 
    1:                             PRBool          *aCancel,
    1:                             PRBool          *aHandled,
    1:                             const nsAString *inString,
    1:                             nsAString       *outString,
    1:                             PRInt32          aMaxLength);
    1:   nsresult WillLoadHTML(nsISelection *aSelection, PRBool *aCancel);
    1:   nsresult WillInsertBreak(nsISelection *aSelection, PRBool *aCancel, PRBool *aHandled);
    1:   nsresult StandardBreakImpl(nsIDOMNode *aNode, PRInt32 aOffset, nsISelection *aSelection);
    1:   nsresult DidInsertBreak(nsISelection *aSelection, nsresult aResult);
    1:   nsresult SplitMailCites(nsISelection *aSelection, PRBool aPlaintext, PRBool *aHandled);
    1:   nsresult WillDeleteSelection(nsISelection *aSelection, nsIEditor::EDirection aAction, 
    1:                                PRBool *aCancel, PRBool *aHandled);
    1:   nsresult DidDeleteSelection(nsISelection *aSelection, 
    1:                               nsIEditor::EDirection aDir, 
    1:                               nsresult aResult);
    1:   nsresult InsertBRIfNeeded(nsISelection *aSelection);
    1:   nsresult GetGoodSelPointForNode(nsIDOMNode *aNode, nsIEditor::EDirection aAction, 
    1:                                   nsCOMPtr<nsIDOMNode> *outSelNode, PRInt32 *outSelOffset);
    1:   nsresult JoinBlocks(nsCOMPtr<nsIDOMNode> *aLeftBlock, nsCOMPtr<nsIDOMNode> *aRightBlock, PRBool *aCanceled);
    1:   nsresult MoveBlock(nsIDOMNode *aLeft, nsIDOMNode *aRight, PRInt32 aLeftOffset, PRInt32 aRightOffset);
    1:   nsresult MoveNodeSmart(nsIDOMNode *aSource, nsIDOMNode *aDest, PRInt32 *aOffset);
    1:   nsresult MoveContents(nsIDOMNode *aSource, nsIDOMNode *aDest, PRInt32 *aOffset);
    1:   nsresult DeleteNonTableElements(nsIDOMNode *aNode);
    1:   nsresult WillMakeList(nsISelection *aSelection, const nsAString *aListType, PRBool aEntireList, const nsAString *aBulletType, PRBool *aCancel, PRBool *aHandled, const nsAString *aItemType=nsnull);
    1:   nsresult WillRemoveList(nsISelection *aSelection, PRBool aOrderd, PRBool *aCancel, PRBool *aHandled);
    1:   nsresult WillIndent(nsISelection *aSelection, PRBool *aCancel, PRBool *aHandled);
    1:   nsresult WillCSSIndent(nsISelection *aSelection, PRBool *aCancel, PRBool *aHandled);
    1:   nsresult WillHTMLIndent(nsISelection *aSelection, PRBool *aCancel, PRBool *aHandled);
    1:   nsresult WillOutdent(nsISelection *aSelection, PRBool *aCancel, PRBool *aHandled);
    1:   nsresult WillAlign(nsISelection *aSelection, const nsAString *alignType, PRBool *aCancel, PRBool *aHandled);
    1:   nsresult WillAbsolutePosition(nsISelection *aSelection, PRBool *aCancel, PRBool * aHandled);
    1:   nsresult WillRemoveAbsolutePosition(nsISelection *aSelection, PRBool *aCancel, PRBool * aHandled);
    1:   nsresult WillRelativeChangeZIndex(nsISelection *aSelection, PRInt32 aChange, PRBool *aCancel, PRBool * aHandled);
    1:   nsresult WillMakeDefListItem(nsISelection *aSelection, const nsAString *aBlockType, PRBool aEntireList, PRBool *aCancel, PRBool *aHandled);
    1:   nsresult WillMakeBasicBlock(nsISelection *aSelection, const nsAString *aBlockType, PRBool *aCancel, PRBool *aHandled);
    1:   nsresult DidMakeBasicBlock(nsISelection *aSelection, nsRulesInfo *aInfo, nsresult aResult);
    1:   nsresult DidAbsolutePosition();
    1:   nsresult AlignInnerBlocks(nsIDOMNode *aNode, const nsAString *alignType);
    1:   nsresult AlignBlockContents(nsIDOMNode *aNode, const nsAString *alignType);
    1:   nsresult AppendInnerFormatNodes(nsCOMArray<nsIDOMNode>& aArray,
    1:                                   nsIDOMNode *aNode);
    1:   nsresult GetFormatString(nsIDOMNode *aNode, nsAString &outFormat);
    1:   nsresult GetInnerContent(nsIDOMNode *aNode, nsCOMArray<nsIDOMNode>& outArrayOfNodes, PRInt32 *aIndex, PRBool aList = PR_TRUE, PRBool aTble = PR_TRUE);
    1:   nsCOMPtr<nsIDOMNode> IsInListItem(nsIDOMNode *aNode);
    1:   nsresult ReturnInHeader(nsISelection *aSelection, nsIDOMNode *aHeader, nsIDOMNode *aTextNode, PRInt32 aOffset);
    1:   nsresult ReturnInParagraph(nsISelection *aSelection, nsIDOMNode *aHeader, nsIDOMNode *aTextNode, PRInt32 aOffset, PRBool *aCancel, PRBool *aHandled);
    1:   nsresult SplitParagraph(nsIDOMNode *aPara,
    1:                           nsIDOMNode *aBRNode, 
    1:                           nsISelection *aSelection,
    1:                           nsCOMPtr<nsIDOMNode> *aSelNode, 
    1:                           PRInt32 *aOffset);
    1:   nsresult ReturnInListItem(nsISelection *aSelection, nsIDOMNode *aHeader, nsIDOMNode *aTextNode, PRInt32 aOffset);
    1:   nsresult AfterEditInner(PRInt32 action, nsIEditor::EDirection aDirection);
    1:   nsresult RemovePartOfBlock(nsIDOMNode *aBlock, 
    1:                              nsIDOMNode *aStartChild, 
    1:                              nsIDOMNode *aEndChild,
    1:                              nsCOMPtr<nsIDOMNode> *aLeftNode = 0,
    1:                              nsCOMPtr<nsIDOMNode> *aRightNode = 0);
    1:   nsresult SplitBlock(nsIDOMNode *aBlock, 
    1:                       nsIDOMNode *aStartChild, 
    1:                       nsIDOMNode *aEndChild,
    1:                       nsCOMPtr<nsIDOMNode> *aLeftNode = 0,
    1:                       nsCOMPtr<nsIDOMNode> *aRightNode = 0,
    1:                       nsCOMPtr<nsIDOMNode> *aMiddleNode = 0);
    1:   nsresult OutdentPartOfBlock(nsIDOMNode *aBlock, 
    1:                               nsIDOMNode *aStartChild, 
    1:                               nsIDOMNode *aEndChild,
    1:                               PRBool aIsBlockIndentedWithCSS,
    1:                               nsCOMPtr<nsIDOMNode> *aLeftNode = 0,
    1:                               nsCOMPtr<nsIDOMNode> *aRightNode = 0);
    1:   nsresult ConvertListType(nsIDOMNode *aList, nsCOMPtr<nsIDOMNode> *outList, const nsAString& aListType, const nsAString& aItemType);
    1:   nsresult CreateStyleForInsertText(nsISelection *aSelection, nsIDOMDocument *aDoc);
    1:   nsresult IsEmptyBlock(nsIDOMNode *aNode, 
    1:                         PRBool *outIsEmptyBlock, 
    1:                         PRBool aMozBRDoesntCount = PR_FALSE,
    1:                         PRBool aListItemsNotEmpty = PR_FALSE);
    1:   nsresult CheckForEmptyBlock(nsIDOMNode *aStartNode, 
    1:                               nsIDOMNode *aBodyNode,
    1:                               nsISelection *aSelection,
    1:                               PRBool *aHandled);
    1:   nsresult CheckForInvisibleBR(nsIDOMNode *aBlock, nsHTMLEditRules::BRLocation aWhere, 
    1:                                nsCOMPtr<nsIDOMNode> *outBRNode, PRInt32 aOffset=0);
    1:   PRBool ExpandSelectionForDeletion(nsISelection *aSelection);
    1:   PRBool IsFirstNode(nsIDOMNode *aNode);
    1:   PRBool IsLastNode(nsIDOMNode *aNode);
    1: #ifdef XXX_DEAD_CODE
    1:   PRBool AtStartOfBlock(nsIDOMNode *aNode, PRInt32 aOffset, nsIDOMNode *aBlock);
    1:   PRBool AtEndOfBlock(nsIDOMNode *aNode, PRInt32 aOffset, nsIDOMNode *aBlock);
    1: #endif
    1:   nsresult NormalizeSelection(nsISelection *inSelection);
    1:   nsresult GetPromotedPoint(RulesEndpoint aWhere, nsIDOMNode *aNode, PRInt32 aOffset, 
    1:                             PRInt32 actionID, nsCOMPtr<nsIDOMNode> *outNode, PRInt32 *outOffset);
    1:   nsresult GetPromotedRanges(nsISelection *inSelection, 
    1:                              nsCOMArray<nsIDOMRange> &outArrayOfRanges, 
    1:                              PRInt32 inOperationType);
    1:   nsresult PromoteRange(nsIDOMRange *inRange, PRInt32 inOperationType);
    1:   nsresult GetNodesForOperation(nsCOMArray<nsIDOMRange>& inArrayOfRanges, 
    1:                                 nsCOMArray<nsIDOMNode>& outArrayOfNodes, 
    1:                                 PRInt32 inOperationType,
    1:                                 PRBool aDontTouchContent=PR_FALSE);
    1:   nsresult GetChildNodesForOperation(nsIDOMNode *inNode, 
    1:                                      nsCOMArray<nsIDOMNode>& outArrayOfNodes);
    1:   nsresult GetNodesFromPoint(DOMPoint point,
    1:                              PRInt32 operation,
    1:                              nsCOMArray<nsIDOMNode>& arrayOfNodes,
    1:                              PRBool dontTouchContent);
    1:   nsresult GetNodesFromSelection(nsISelection *selection,
    1:                                  PRInt32 operation,
    1:                                  nsCOMArray<nsIDOMNode>& arrayOfNodes,
    1:                                  PRBool aDontTouchContent=PR_FALSE);
    1:   nsresult GetListActionNodes(nsCOMArray<nsIDOMNode> &outArrayOfNodes, PRBool aEntireList, PRBool aDontTouchContent=PR_FALSE);
    1:   nsresult GetDefinitionListItemTypes(nsIDOMNode *aNode, PRBool &aDT, PRBool &aDD);
    1:   nsresult GetParagraphFormatNodes(nsCOMArray<nsIDOMNode>& outArrayOfNodes, PRBool aDontTouchContent=PR_FALSE);
    1:   nsresult LookInsideDivBQandList(nsCOMArray<nsIDOMNode>& aNodeArray);
    1:   nsresult BustUpInlinesAtRangeEndpoints(nsRangeStore &inRange);
    1:   nsresult BustUpInlinesAtBRs(nsIDOMNode *inNode, 
    1:                               nsCOMArray<nsIDOMNode>& outArrayOfNodes);
    1:   nsCOMPtr<nsIDOMNode> GetHighestInlineParent(nsIDOMNode* aNode);
    1:   nsresult MakeTransitionList(nsCOMArray<nsIDOMNode>& inArrayOfNodes, 
27986:                               nsTArray<PRPackedBool> &inTransitionArray);
    1:   nsresult RemoveBlockStyle(nsCOMArray<nsIDOMNode>& arrayOfNodes);
    1:   nsresult ApplyBlockStyle(nsCOMArray<nsIDOMNode>& arrayOfNodes, const nsAString *aBlockTag);
    1:   nsresult MakeBlockquote(nsCOMArray<nsIDOMNode>& arrayOfNodes);
    1:   nsresult SplitAsNeeded(const nsAString *aTag, nsCOMPtr<nsIDOMNode> *inOutParent, PRInt32 *inOutOffset);
    1:   nsresult AddTerminatingBR(nsIDOMNode *aBlock);
    1:   nsresult JoinNodesSmart( nsIDOMNode *aNodeLeft, 
    1:                            nsIDOMNode *aNodeRight, 
    1:                            nsCOMPtr<nsIDOMNode> *aOutMergeParent, 
    1:                            PRInt32 *aOutMergeOffset);
    1:   nsresult GetTopEnclosingMailCite(nsIDOMNode *aNode, nsCOMPtr<nsIDOMNode> *aOutCiteNode, PRBool aPlaintext);
    1:   nsresult PopListItem(nsIDOMNode *aListItem, PRBool *aOutOfList);
    1:   nsresult RemoveListStructure(nsIDOMNode *aList);
    1:   nsresult CacheInlineStyles(nsIDOMNode *aNode);
    1:   nsresult ReapplyCachedStyles(); 
    1:   nsresult ClearCachedStyles();
    1:   nsresult AdjustSpecialBreaks(PRBool aSafeToAskFrames = PR_FALSE);
    1:   nsresult AdjustWhitespace(nsISelection *aSelection);
    1:   nsresult PinSelectionToNewBlock(nsISelection *aSelection);
    1:   nsresult CheckInterlinePosition(nsISelection *aSelection);
    1:   nsresult AdjustSelection(nsISelection *aSelection, nsIEditor::EDirection aAction);
    1:   nsresult FindNearSelectableNode(nsIDOMNode *aSelNode, 
    1:                                   PRInt32 aSelOffset, 
    1:                                   nsIEditor::EDirection &aDirection,
    1:                                   nsCOMPtr<nsIDOMNode> *outSelectableNode);
    1:   nsresult InDifferentTableElements(nsIDOMNode *aNode1, nsIDOMNode *aNode2, PRBool *aResult);
    1:   nsresult RemoveEmptyNodes();
    1:   nsresult SelectionEndpointInNode(nsIDOMNode *aNode, PRBool *aResult);
    1:   nsresult UpdateDocChangeRange(nsIDOMRange *aRange);
    1:   nsresult ConfirmSelectionInBody();
    1:   nsresult InsertMozBRIfNeeded(nsIDOMNode *aNode);
    1:   PRBool   IsEmptyInline(nsIDOMNode *aNode);
    1:   PRBool   ListIsEmptyLine(nsCOMArray<nsIDOMNode> &arrayOfNodes);
    1:   nsresult RemoveAlignment(nsIDOMNode * aNode, const nsAString & aAlignType, PRBool aChildrenOnly);
    1:   nsresult MakeSureElemStartsOrEndsOnCR(nsIDOMNode *aNode, PRBool aStarts);
    1:   nsresult AlignBlock(nsIDOMElement * aElement, const nsAString * aAlignType, PRBool aContentsOnly);
    1:   nsresult RelativeChangeIndentationOfElementNode(nsIDOMNode *aNode, PRInt8 aRelativeChange);
57481:   void DocumentModifiedWorker();
    1: 
    1: // data members
    1: protected:
    1:   nsHTMLEditor           *mHTMLEditor;
    1:   nsCOMPtr<nsIDOMRange>   mDocChangeRange;
    1:   PRPackedBool            mListenerEnabled;
    1:   PRPackedBool            mReturnInEmptyLIKillsList;
    1:   PRPackedBool            mDidDeleteSelection;
    1:   PRPackedBool            mDidRangedDelete;
58546:   PRPackedBool            mRestoreContentEditableCount;
    1:   nsCOMPtr<nsIDOMRange>   mUtilRange;
    1:   PRUint32                mJoinOffset;  // need to remember an int across willJoin/didJoin...
    1:   nsCOMPtr<nsIDOMNode>    mNewBlock;
    1:   nsRangeStore            mRangeItem;
    1:   StyleCache              mCachedStyles[SIZE_STYLE_TABLE];
    1: };
    1: 
    1: nsresult NS_NewHTMLEditRules(nsIEditRules** aInstancePtrResult);
    1: 
    1: #endif //nsHTMLEditRules_h__
    1: 
