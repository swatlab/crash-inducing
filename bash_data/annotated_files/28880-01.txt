    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2002
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *  Brian Ryner <bryner@brianryner.com>  (Original Author)
 2120:  *  Michael Ventnor <m.ventnor@gmail.com>
 8720:  *  Teune van Steeg <t.vansteeg@gmail.com>
16193:  *  Karl Tomlinson <karlt+@karlt.net>, Mozilla Corporation
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsNativeThemeGTK.h"
    1: #include "nsThemeConstants.h"
    1: #include "gtkdrawing.h"
    1: 
    1: #include "nsIObserverService.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIFrame.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIDocument.h"
    1: #include "nsIContent.h"
    1: #include "nsIEventStateManager.h"
    1: #include "nsIViewManager.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsILookAndFeel.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsGfxCIID.h"
    1: #include "nsTransform2D.h"
    1: #include "nsIMenuFrame.h"
    1: #include "prlink.h"
    1: #include "nsIDOMHTMLInputElement.h"
24022: #include "nsIDOMNSHTMLInputElement.h"
    1: #include "nsWidgetAtoms.h"
    1: 
    1: #include <gdk/gdkprivate.h>
 7932: #include <gtk/gtk.h>
    1: 
    1: #include "gfxContext.h"
    1: #include "gfxPlatformGtk.h"
16529: #include "gfxGdkNativeRenderer.h"
    1: 
    1: NS_IMPL_ISUPPORTS2(nsNativeThemeGTK, nsITheme, nsIObserver)
    1: 
16529: static int gLastGdkError;
    1: 
    1: nsNativeThemeGTK::nsNativeThemeGTK()
    1: {
    1:   if (moz_gtk_init() != MOZ_GTK_SUCCESS) {
    1:     memset(mDisabledWidgetTypes, 0xff, sizeof(mDisabledWidgetTypes));
    1:     return;
    1:   }
    1: 
    1:   // We have to call moz_gtk_shutdown before the event loop stops running.
    1:   nsCOMPtr<nsIObserverService> obsServ =
    1:     do_GetService("@mozilla.org/observer-service;1");
    1:   obsServ->AddObserver(this, "xpcom-shutdown", PR_FALSE);
    1: 
    1:   memset(mDisabledWidgetTypes, 0, sizeof(mDisabledWidgetTypes));
    1:   memset(mSafeWidgetStates, 0, sizeof(mSafeWidgetStates));
    1: }
    1: 
    1: nsNativeThemeGTK::~nsNativeThemeGTK() {
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNativeThemeGTK::Observe(nsISupports *aSubject, const char *aTopic,
    1:                           const PRUnichar *aData)
    1: {
    1:   if (!nsCRT::strcmp(aTopic, "xpcom-shutdown")) {
    1:     moz_gtk_shutdown();
    1:   } else {
    1:     NS_NOTREACHED("unexpected topic");
    1:     return NS_ERROR_UNEXPECTED;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsNativeThemeGTK::RefreshWidgetWindow(nsIFrame* aFrame)
    1: {
    1:   nsIPresShell *shell = GetPresShell(aFrame);
    1:   if (!shell)
    1:     return;
    1: 
    1:   nsIViewManager* vm = shell->GetViewManager();
    1:   if (!vm)
    1:     return;
    1:  
    1:   vm->UpdateAllViews(NS_VMREFRESH_NO_SYNC);
    1: }
    1: 
28880: static PRBool IsFrameContentNodeOfType(nsIFrame *aFrame, PRUint32 aFlags)
28880: {
28880:   nsIContent *content = aFrame ? nsnull : aFrame->GetContent();
28880:   if (!content)
28880:     return false;
28880:   return content->IsNodeOfType(aFlags);
28880: }
28880: 
    1: static PRBool IsWidgetTypeDisabled(PRUint8* aDisabledVector, PRUint8 aWidgetType) {
19277:   return (aDisabledVector[aWidgetType >> 3] & (1 << (aWidgetType & 7))) != 0;
    1: }
    1: 
    1: static void SetWidgetTypeDisabled(PRUint8* aDisabledVector, PRUint8 aWidgetType) {
    1:   aDisabledVector[aWidgetType >> 3] |= (1 << (aWidgetType & 7));
    1: }
    1: 
    1: static inline PRUint16
    1: GetWidgetStateKey(PRUint8 aWidgetType, GtkWidgetState *aWidgetState)
    1: {
    1:   return (aWidgetState->active |
    1:           aWidgetState->focused << 1 |
    1:           aWidgetState->inHover << 2 |
    1:           aWidgetState->disabled << 3 |
    1:           aWidgetState->isDefault << 4 |
    1:           aWidgetType << 5);
    1: }
    1: 
    1: static PRBool IsWidgetStateSafe(PRUint8* aSafeVector,
    1:                                 PRUint8 aWidgetType,
    1:                                 GtkWidgetState *aWidgetState)
    1: {
    1:   PRUint8 key = GetWidgetStateKey(aWidgetType, aWidgetState);
19277:   return (aSafeVector[key >> 3] & (1 << (key & 7))) != 0;
    1: }
    1: 
    1: static void SetWidgetStateSafe(PRUint8 *aSafeVector,
    1:                                PRUint8 aWidgetType,
    1:                                GtkWidgetState *aWidgetState)
    1: {
    1:   PRUint8 key = GetWidgetStateKey(aWidgetType, aWidgetState);
    1:   aSafeVector[key >> 3] |= (1 << (key & 7));
    1: }
    1: 
 9052: static GtkTextDirection GetTextDirection(nsIFrame* aFrame)
 9052: {
 9052:   if (!aFrame)
 9052:     return GTK_TEXT_DIR_NONE;
 9052: 
 9052:   switch (aFrame->GetStyleVisibility()->mDirection) {
 9052:     case NS_STYLE_DIRECTION_RTL:
 9052:       return GTK_TEXT_DIR_RTL;
 9052:     case NS_STYLE_DIRECTION_LTR:
 9052:       return GTK_TEXT_DIR_LTR;
 9052:   }
 9052: 
 9052:   return GTK_TEXT_DIR_NONE;
 9052: }
 9052: 
    1: PRBool
    1: nsNativeThemeGTK::GetGtkWidgetAndState(PRUint8 aWidgetType, nsIFrame* aFrame,
    1:                                        GtkThemeWidgetType& aGtkWidgetType,
    1:                                        GtkWidgetState* aState,
    1:                                        gint* aWidgetFlags)
    1: {
    1:   if (aState) {
    1:     if (!aFrame) {
    1:       // reset the entire struct to zero
    1:       memset(aState, 0, sizeof(GtkWidgetState));
    1:     } else {
    1: 
    1:       // For XUL checkboxes and radio buttons, the state of the parent
    1:       // determines our state.
    1:       nsIFrame *stateFrame = aFrame;
21220:       if (aFrame && ((aWidgetFlags && (aWidgetType == NS_THEME_CHECKBOX ||
21220:                                        aWidgetType == NS_THEME_RADIO)) ||
    1:                      aWidgetType == NS_THEME_CHECKBOX_LABEL ||
    1:                      aWidgetType == NS_THEME_RADIO_LABEL)) {
    1: 
    1:         nsIAtom* atom = nsnull;
28880:         if (IsFrameContentNodeOfType(aFrame, nsINode::eXUL)) {
    1:           if (aWidgetType == NS_THEME_CHECKBOX_LABEL ||
    1:               aWidgetType == NS_THEME_RADIO_LABEL) {
    1:             // Adjust stateFrame so GetContentState finds the correct state.
    1:             stateFrame = aFrame = aFrame->GetParent()->GetParent();
    1:           } else {
    1:             // GetContentState knows to look one frame up for radio/checkbox
    1:             // widgets, so don't adjust stateFrame here.
    1:             aFrame = aFrame->GetParent();
    1:           }
    1:           if (aWidgetFlags) {
    1:             if (!atom) {
21220:               atom = (aWidgetType == NS_THEME_CHECKBOX ||
    1:                       aWidgetType == NS_THEME_CHECKBOX_LABEL) ? nsWidgetAtoms::checked
    1:                                                               : nsWidgetAtoms::selected;
    1:             }
    1:             *aWidgetFlags = CheckBooleanAttr(aFrame, atom);
    1:           }
    1:         } else {
    1:           if (aWidgetFlags) {
28880:             nsCOMPtr<nsIDOMHTMLInputElement> inputElt(do_QueryInterface(aFrame->GetContent()));
24022:             *aWidgetFlags = 0;
    1:             if (inputElt) {
    1:               PRBool isHTMLChecked;
    1:               inputElt->GetChecked(&isHTMLChecked);
24022:               if (isHTMLChecked)
24022:                 *aWidgetFlags |= MOZ_GTK_WIDGET_CHECKED;
24022:             }
24022: 
24447:             if (GetIndeterminate(aFrame))
24022:               *aWidgetFlags |= MOZ_GTK_WIDGET_INCONSISTENT;
    1:           }
    1:         }
10753:       } else if (aWidgetType == NS_THEME_TOOLBAR_BUTTON_DROPDOWN ||
10753:                  aWidgetType == NS_THEME_TREEVIEW_HEADER_SORTARROW) {
10753:         stateFrame = aFrame->GetParent();
    1:       }
    1: 
    1:       PRInt32 eventState = GetContentState(stateFrame, aWidgetType);
    1: 
 2120:       aState->disabled = (IsDisabled(aFrame) || IsReadOnly(aFrame));
    1:       aState->active  = (eventState & NS_EVENT_STATE_ACTIVE) == NS_EVENT_STATE_ACTIVE;
    1:       aState->focused = (eventState & NS_EVENT_STATE_FOCUS) == NS_EVENT_STATE_FOCUS;
    1:       aState->inHover = (eventState & NS_EVENT_STATE_HOVER) == NS_EVENT_STATE_HOVER;
 5558:       aState->isDefault = IsDefaultButton(aFrame);
    1:       aState->canDefault = FALSE; // XXX fix me
 8575:       aState->depressed = FALSE;
    1: 
28880:       if (IsFrameContentNodeOfType(aFrame, nsINode::eXUL)) {
    1:         // For these widget types, some element (either a child or parent)
    1:         // actually has element focus, so we check the focused attribute
    1:         // to see whether to draw in the focused state.
    1:         if (aWidgetType == NS_THEME_TEXTFIELD ||
 1191:             aWidgetType == NS_THEME_TEXTFIELD_MULTILINE ||
    1:             aWidgetType == NS_THEME_DROPDOWN_TEXTFIELD ||
 9589:             aWidgetType == NS_THEME_SPINNER_TEXTFIELD ||
    1:             aWidgetType == NS_THEME_RADIO_CONTAINER ||
 2844:             aWidgetType == NS_THEME_RADIO_LABEL) {
    1:           aState->focused = IsFocused(aFrame);
21220:         } else if (aWidgetType == NS_THEME_RADIO ||
21220:                    aWidgetType == NS_THEME_CHECKBOX) {
 2844:           // In XUL, checkboxes and radios shouldn't have focus rings, their labels do
 2844:           aState->focused = FALSE;
    1:         }
    1: 
    1:         if (aWidgetType == NS_THEME_SCROLLBAR_THUMB_VERTICAL ||
    1:             aWidgetType == NS_THEME_SCROLLBAR_THUMB_HORIZONTAL) {
    1:           // for scrollbars we need to go up two to go from the thumb to
    1:           // the slider to the actual scrollbar object
    1:           nsIFrame *tmpFrame = aFrame->GetParent()->GetParent();
    1: 
13622:           aState->curpos = CheckIntAttr(tmpFrame, nsWidgetAtoms::curpos, 0);
13622:           aState->maxpos = CheckIntAttr(tmpFrame, nsWidgetAtoms::maxpos, 100);
    1:         }
    1: 
    1:         if (aWidgetType == NS_THEME_SCROLLBAR_BUTTON_UP ||
    1:             aWidgetType == NS_THEME_SCROLLBAR_BUTTON_DOWN ||
    1:             aWidgetType == NS_THEME_SCROLLBAR_BUTTON_LEFT ||
    1:             aWidgetType == NS_THEME_SCROLLBAR_BUTTON_RIGHT) {
11325:           // set the state to disabled when the scrollbar is scrolled to
11325:           // the beginning or the end, depending on the button type.
13622:           PRInt32 curpos = CheckIntAttr(aFrame, nsWidgetAtoms::curpos, 0);
13622:           PRInt32 maxpos = CheckIntAttr(aFrame, nsWidgetAtoms::maxpos, 100);
11325:           if ((curpos == 0 && (aWidgetType == NS_THEME_SCROLLBAR_BUTTON_UP ||
11325:                 aWidgetType == NS_THEME_SCROLLBAR_BUTTON_LEFT)) ||
11325:               (curpos == maxpos &&
11325:                (aWidgetType == NS_THEME_SCROLLBAR_BUTTON_DOWN ||
11325:                 aWidgetType == NS_THEME_SCROLLBAR_BUTTON_RIGHT)))
11325:             aState->disabled = PR_TRUE;
11325: 
11325:           // In order to simulate native GTK scrollbar click behavior,
11325:           // we set the active attribute on the element to true if it's
11325:           // pressed with any mouse button.
11325:           // This allows us to show that it's active without setting :active
11325:           else if (CheckBooleanAttr(aFrame, nsWidgetAtoms::active))
    1:             aState->active = PR_TRUE;
10223: 
10223:           if (aWidgetFlags) {
10223:             *aWidgetFlags = GetScrollbarButtonType(aFrame);
10223:             if (aWidgetType - NS_THEME_SCROLLBAR_BUTTON_UP < 2)
10223:               *aWidgetFlags |= MOZ_GTK_STEPPER_VERTICAL;
10223:           }
    1:         }
    1: 
    1:         // menu item state is determined by the attribute "_moz-menuactive",
    1:         // and not by the mouse hovering (accessibility).  as a special case,
    1:         // menus which are children of a menu bar are only marked as prelight
    1:         // if they are open, not on normal hover.
    1: 
    1:         if (aWidgetType == NS_THEME_MENUITEM ||
    1:             aWidgetType == NS_THEME_CHECKMENUITEM ||
 8423:             aWidgetType == NS_THEME_RADIOMENUITEM ||
 8883:             aWidgetType == NS_THEME_MENUSEPARATOR ||
 8423:             aWidgetType == NS_THEME_MENUARROW) {
    1:           PRBool isTopLevel = PR_FALSE;
23554:           nsIMenuFrame *menuFrame = do_QueryFrame(aFrame);
    1:           if (menuFrame) {
 3129:             isTopLevel = menuFrame->IsOnMenuBar();
    1:           }
    1: 
    1:           if (isTopLevel) {
 3129:             aState->inHover = menuFrame->IsOpen();
 8647:             *aWidgetFlags |= MOZ_TOPLEVEL_MENU_ITEM;
    1:           } else {
    1:             aState->inHover = CheckBooleanAttr(aFrame, nsWidgetAtoms::mozmenuactive);
 8647:             *aWidgetFlags &= ~MOZ_TOPLEVEL_MENU_ITEM;
    1:           }
    1: 
    1:           aState->active = FALSE;
    1:         
    1:           if (aWidgetType == NS_THEME_CHECKMENUITEM ||
    1:               aWidgetType == NS_THEME_RADIOMENUITEM) {
28880:             *aWidgetFlags = 0;
28880:             if (aFrame && aFrame->GetContent()) {
28880:               *aWidgetFlags = aFrame->GetContent()->
    1:                 AttrValueIs(kNameSpaceID_None, nsWidgetAtoms::checked,
    1:                             nsWidgetAtoms::_true, eIgnoreCase);
    1:             }
    1:           }
28880:         }
 8575: 
 8575:         // A button with drop down menu open or an activated toggle button
 8575:         // should always appear depressed.
 8575:         if (aWidgetType == NS_THEME_BUTTON ||
 8575:             aWidgetType == NS_THEME_TOOLBAR_BUTTON ||
10220:             aWidgetType == NS_THEME_TOOLBAR_DUAL_BUTTON ||
10753:             aWidgetType == NS_THEME_TOOLBAR_BUTTON_DROPDOWN ||
10766:             aWidgetType == NS_THEME_DROPDOWN ||
10766:             aWidgetType == NS_THEME_DROPDOWN_BUTTON) {
10753:           if (aWidgetType == NS_THEME_TOOLBAR_BUTTON_DROPDOWN)
10753:             aFrame = aFrame->GetParent();
10753: 
26124:           PRBool menuOpen = IsOpenButton(aFrame);
 8575:           aState->depressed = IsCheckedButton(aFrame) || menuOpen;
 8575:           // we must not highlight buttons with open drop down menus on hover.
 8575:           aState->inHover = aState->inHover && !menuOpen;
 8575:         }
11504: 
11504:         // When the input field of the drop down button has focus, some themes
11504:         // should draw focus for the drop down button as well.
11504:         if (aWidgetType == NS_THEME_DROPDOWN_BUTTON && aWidgetFlags) {
11504:           *aWidgetFlags = CheckBooleanAttr(aFrame, nsWidgetAtoms::parentfocused);
11504:         }
    1:       }
    1:     }
 2844:   }
    1: 
    1:   switch (aWidgetType) {
    1:   case NS_THEME_BUTTON:
    1:   case NS_THEME_TOOLBAR_BUTTON:
    1:   case NS_THEME_TOOLBAR_DUAL_BUTTON:
    1:     if (aWidgetFlags)
    1:       *aWidgetFlags = (aWidgetType == NS_THEME_BUTTON) ? GTK_RELIEF_NORMAL : GTK_RELIEF_NONE;
    1:     aGtkWidgetType = MOZ_GTK_BUTTON;
    1:     break;
    1:   case NS_THEME_CHECKBOX:
    1:   case NS_THEME_RADIO:
21220:     aGtkWidgetType = (aWidgetType == NS_THEME_RADIO) ? MOZ_GTK_RADIOBUTTON : MOZ_GTK_CHECKBUTTON;
    1:     break;
    1:   case NS_THEME_SCROLLBAR_BUTTON_UP:
    1:   case NS_THEME_SCROLLBAR_BUTTON_DOWN:
    1:   case NS_THEME_SCROLLBAR_BUTTON_LEFT:
    1:   case NS_THEME_SCROLLBAR_BUTTON_RIGHT:
    1:     aGtkWidgetType = MOZ_GTK_SCROLLBAR_BUTTON;
    1:     break;
    1:   case NS_THEME_SCROLLBAR_TRACK_VERTICAL:
    1:     aGtkWidgetType = MOZ_GTK_SCROLLBAR_TRACK_VERTICAL;
    1:     break;
    1:   case NS_THEME_SCROLLBAR_TRACK_HORIZONTAL:
    1:     aGtkWidgetType = MOZ_GTK_SCROLLBAR_TRACK_HORIZONTAL;
    1:     break;
    1:   case NS_THEME_SCROLLBAR_THUMB_VERTICAL:
    1:     aGtkWidgetType = MOZ_GTK_SCROLLBAR_THUMB_VERTICAL;
    1:     break;
    1:   case NS_THEME_SCROLLBAR_THUMB_HORIZONTAL:
    1:     aGtkWidgetType = MOZ_GTK_SCROLLBAR_THUMB_HORIZONTAL;
    1:     break;
 9590:   case NS_THEME_SPINNER:
 9590:     aGtkWidgetType = MOZ_GTK_SPINBUTTON;
 9590:     break;
    1:   case NS_THEME_SPINNER_UP_BUTTON:
    1:     aGtkWidgetType = MOZ_GTK_SPINBUTTON_UP;
    1:     break;
    1:   case NS_THEME_SPINNER_DOWN_BUTTON:
    1:     aGtkWidgetType = MOZ_GTK_SPINBUTTON_DOWN;
    1:     break;
 9590:   case NS_THEME_SPINNER_TEXTFIELD:
 9590:     aGtkWidgetType = MOZ_GTK_SPINBUTTON_ENTRY;
 9590:     break;
    1:   case NS_THEME_SCALE_HORIZONTAL:
    1:     if (aWidgetFlags)
    1:       *aWidgetFlags = GTK_ORIENTATION_HORIZONTAL;
    1:     aGtkWidgetType = MOZ_GTK_SCALE_HORIZONTAL;
    1:     break;
    1:   case NS_THEME_SCALE_THUMB_HORIZONTAL:
    1:     if (aWidgetFlags)
    1:       *aWidgetFlags = GTK_ORIENTATION_HORIZONTAL;
    1:     aGtkWidgetType = MOZ_GTK_SCALE_THUMB_HORIZONTAL;
    1:     break;
    1:   case NS_THEME_SCALE_VERTICAL:
    1:     if (aWidgetFlags)
    1:       *aWidgetFlags = GTK_ORIENTATION_VERTICAL;
    1:     aGtkWidgetType = MOZ_GTK_SCALE_VERTICAL;
    1:     break;
 8574:   case NS_THEME_TOOLBAR_SEPARATOR:
 8574:     aGtkWidgetType = MOZ_GTK_TOOLBAR_SEPARATOR;
 8574:     break;
    1:   case NS_THEME_SCALE_THUMB_VERTICAL:
    1:     if (aWidgetFlags)
    1:       *aWidgetFlags = GTK_ORIENTATION_VERTICAL;
    1:     aGtkWidgetType = MOZ_GTK_SCALE_THUMB_VERTICAL;
    1:     break;
    1:   case NS_THEME_TOOLBAR_GRIPPER:
    1:     aGtkWidgetType = MOZ_GTK_GRIPPER;
    1:     break;
 7723:   case NS_THEME_RESIZER:
 7723:     aGtkWidgetType = MOZ_GTK_RESIZER;
 7723:     break;
    1:   case NS_THEME_TEXTFIELD:
 1191:   case NS_THEME_TEXTFIELD_MULTILINE:
 7646:     aGtkWidgetType = MOZ_GTK_ENTRY;
 7646:     break;
15481:   case NS_THEME_TEXTFIELD_CARET:
15481:     aGtkWidgetType = MOZ_GTK_ENTRY_CARET;
15481:     break;
 2303:   case NS_THEME_LISTBOX:
 7646:   case NS_THEME_TREEVIEW:
 7646:     aGtkWidgetType = MOZ_GTK_TREEVIEW;
 7646:     break;
 7646:   case NS_THEME_TREEVIEW_HEADER_CELL:
13247:     if (aWidgetFlags) {
13247:       // In this case, the flag denotes whether the header is the sorted one or not
13247:       if (GetTreeSortDirection(aFrame) == eTreeSortDirection_Natural)
13247:         *aWidgetFlags = PR_FALSE;
13247:       else
13247:         *aWidgetFlags = PR_TRUE;
13247:     }
 7646:     aGtkWidgetType = MOZ_GTK_TREE_HEADER_CELL;
    1:     break;
 7932:   case NS_THEME_TREEVIEW_HEADER_SORTARROW:
 7932:     if (aWidgetFlags) {
 7932:       switch (GetTreeSortDirection(aFrame)) {
 7932:         case eTreeSortDirection_Ascending:
 7932:           *aWidgetFlags = GTK_ARROW_DOWN;
 7932:           break;
 7932:         case eTreeSortDirection_Descending:
 7932:           *aWidgetFlags = GTK_ARROW_UP;
 7932:           break;
 7932:         case eTreeSortDirection_Natural:
 7932:         default:
 7932:           /* GTK_ARROW_NONE is implemented since GTK 2.10
 7932:            * This prevents the treecolums from getting smaller
 7932:            * and wider when switching sort direction off and on
 7932:            * */
 7932: #if GTK_CHECK_VERSION(2,10,0)
 7932:           *aWidgetFlags = GTK_ARROW_NONE;
 7932: #else
 7932:           return PR_FALSE; // Don't draw when we shouldn't
 7932: #endif // GTK_CHECK_VERSION(2,10,0)
 7932:           break;
 7932:       }
 7932:     }
 7932:     aGtkWidgetType = MOZ_GTK_TREE_HEADER_SORTARROW;
 7932:     break;
 8004:   case NS_THEME_TREEVIEW_TWISTY:
 9778:     aGtkWidgetType = MOZ_GTK_TREEVIEW_EXPANDER;
 8004:     if (aWidgetFlags)
 8004:       *aWidgetFlags = GTK_EXPANDER_COLLAPSED;
 8004:     break;
 8004:   case NS_THEME_TREEVIEW_TWISTY_OPEN:
 9778:     aGtkWidgetType = MOZ_GTK_TREEVIEW_EXPANDER;
 8004:     if (aWidgetFlags)
 8004:       *aWidgetFlags = GTK_EXPANDER_EXPANDED;
 8004:     break;
    1:   case NS_THEME_DROPDOWN:
    1:     aGtkWidgetType = MOZ_GTK_DROPDOWN;
13512:     if (aWidgetFlags)
28880:         *aWidgetFlags = IsFrameContentNodeOfType(aFrame, nsINode::eHTML);
    1:     break;
    1:   case NS_THEME_DROPDOWN_TEXT:
    1:     return PR_FALSE; // nothing to do, but prevents the bg from being drawn
10253:   case NS_THEME_DROPDOWN_TEXTFIELD:
10253:     aGtkWidgetType = MOZ_GTK_DROPDOWN_ENTRY;
10253:     break;
    1:   case NS_THEME_DROPDOWN_BUTTON:
    1:     aGtkWidgetType = MOZ_GTK_DROPDOWN_ARROW;
    1:     break;
10361:   case NS_THEME_TOOLBAR_BUTTON_DROPDOWN:
10361:     aGtkWidgetType = MOZ_GTK_TOOLBARBUTTON_ARROW;
10361:     break;
    1:   case NS_THEME_CHECKBOX_CONTAINER:
    1:     aGtkWidgetType = MOZ_GTK_CHECKBUTTON_CONTAINER;
    1:     break;
    1:   case NS_THEME_RADIO_CONTAINER:
    1:     aGtkWidgetType = MOZ_GTK_RADIOBUTTON_CONTAINER;
    1:     break;
    1:   case NS_THEME_CHECKBOX_LABEL:
    1:     aGtkWidgetType = MOZ_GTK_CHECKBUTTON_LABEL;
    1:     break;
    1:   case NS_THEME_RADIO_LABEL:
    1:     aGtkWidgetType = MOZ_GTK_RADIOBUTTON_LABEL;
    1:     break;
    1:   case NS_THEME_TOOLBAR:
    1:     aGtkWidgetType = MOZ_GTK_TOOLBAR;
    1:     break;
    1:   case NS_THEME_TOOLTIP:
    1:     aGtkWidgetType = MOZ_GTK_TOOLTIP;
    1:     break;
    1:   case NS_THEME_STATUSBAR_PANEL:
 8020:   case NS_THEME_STATUSBAR_RESIZER_PANEL:
    1:     aGtkWidgetType = MOZ_GTK_FRAME;
    1:     break;
    1:   case NS_THEME_PROGRESSBAR:
    1:   case NS_THEME_PROGRESSBAR_VERTICAL:
    1:     aGtkWidgetType = MOZ_GTK_PROGRESSBAR;
    1:     break;
    1:   case NS_THEME_PROGRESSBAR_CHUNK:
    1:   case NS_THEME_PROGRESSBAR_CHUNK_VERTICAL:
    1:     aGtkWidgetType = MOZ_GTK_PROGRESS_CHUNK;
    1:     break;
11754:   case NS_THEME_TAB_SCROLLARROW_BACK:
11754:   case NS_THEME_TAB_SCROLLARROW_FORWARD:
11754:     if (aWidgetFlags)
11754:       *aWidgetFlags = aWidgetType == NS_THEME_TAB_SCROLLARROW_BACK ?
11754:                         GTK_ARROW_LEFT : GTK_ARROW_RIGHT;
11754:     aGtkWidgetType = MOZ_GTK_TAB_SCROLLARROW;
11754:     break;
    1:   case NS_THEME_TAB_PANELS:
    1:     aGtkWidgetType = MOZ_GTK_TABPANELS;
    1:     break;
    1:   case NS_THEME_TAB:
    1:     {
    1:       if (aWidgetFlags) {
 9594:         /* First bits will be used to store max(0,-bmargin) where bmargin
 9594:          * is the bottom margin of the tab in pixels  (resp. top margin,
 9594:          * for bottom tabs). */
10065:         nscoord margin;
 9594:         if (IsBottomTab(aFrame)) {
 9594:             *aWidgetFlags = MOZ_GTK_TAB_BOTTOM;
 9594:             margin = aFrame->GetUsedMargin().top;
 9594:         } else {
    1:             *aWidgetFlags = 0;
 9594:             margin = aFrame->GetUsedMargin().bottom;
 9594:         }
    1: 
 9594:         *aWidgetFlags |= PR_MIN(MOZ_GTK_TAB_MARGIN_MASK,
 9594:                                 PR_MAX(0, aFrame->PresContext()->
 9594:                                    AppUnitsToDevPixels(-margin) ));
 9594: 
 9594:         if (IsSelectedTab(aFrame))
    1:           *aWidgetFlags |= MOZ_GTK_TAB_SELECTED;
    1: 
 9594:         if (IsFirstTab(aFrame))
    1:           *aWidgetFlags |= MOZ_GTK_TAB_FIRST;
    1:       }
    1: 
    1:       aGtkWidgetType = MOZ_GTK_TAB;
    1:     }
    1:     break;
 9586:   case NS_THEME_SPLITTER:
 9586:     if (IsHorizontal(aFrame))
 9586:       aGtkWidgetType = MOZ_GTK_SPLITTER_VERTICAL;
 9586:     else 
 9586:       aGtkWidgetType = MOZ_GTK_SPLITTER_HORIZONTAL;
 9586:     break;
    1:   case NS_THEME_MENUBAR:
    1:     aGtkWidgetType = MOZ_GTK_MENUBAR;
    1:     break;
    1:   case NS_THEME_MENUPOPUP:
    1:     aGtkWidgetType = MOZ_GTK_MENUPOPUP;
    1:     break;
    1:   case NS_THEME_MENUITEM:
    1:     aGtkWidgetType = MOZ_GTK_MENUITEM;
    1:     break;
 8883:   case NS_THEME_MENUSEPARATOR:
 8883:     aGtkWidgetType = MOZ_GTK_MENUSEPARATOR;
 8883:     break;
 8423:   case NS_THEME_MENUARROW:
 8423:     aGtkWidgetType = MOZ_GTK_MENUARROW;
 8423:     break;
    1:   case NS_THEME_CHECKMENUITEM:
    1:     aGtkWidgetType = MOZ_GTK_CHECKMENUITEM;
    1:     break;
    1:   case NS_THEME_RADIOMENUITEM:
    1:     aGtkWidgetType = MOZ_GTK_RADIOMENUITEM;
    1:     break;
    1:   case NS_THEME_WINDOW:
    1:   case NS_THEME_DIALOG:
    1:     aGtkWidgetType = MOZ_GTK_WINDOW;
    1:     break;
    1:   default:
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
16529: class ThemeRenderer : public gfxGdkNativeRenderer {
    1: public:
    1:   ThemeRenderer(GtkWidgetState aState, GtkThemeWidgetType aGTKWidgetType,
 9052:                 gint aFlags, GtkTextDirection aDirection,
 9052:                 const GdkRectangle& aGDKRect, const GdkRectangle& aGDKClip)
    1:     : mState(aState), mGTKWidgetType(aGTKWidgetType), mFlags(aFlags),
 9052:       mDirection(aDirection), mGDKRect(aGDKRect), mGDKClip(aGDKClip) {}
16529:   nsresult NativeDraw(GdkDrawable * drawable, short offsetX, short offsetY,
16529:                       GdkRectangle * clipRects, PRUint32 numClipRects);
    1: private:
    1:   GtkWidgetState mState;
    1:   GtkThemeWidgetType mGTKWidgetType;
    1:   gint mFlags;
 9052:   GtkTextDirection mDirection;
    1:   GdkWindow* mWindow;
    1:   const GdkRectangle& mGDKRect;
    1:   const GdkRectangle& mGDKClip;
    1: };
    1: 
    1: nsresult
16529: ThemeRenderer::NativeDraw(GdkDrawable * drawable, short offsetX, 
16529:         short offsetY, GdkRectangle * clipRects, PRUint32 numClipRects)
    1: {
    1:   GdkRectangle gdk_rect = mGDKRect;
    1:   gdk_rect.x += offsetX;
    1:   gdk_rect.y += offsetY;
    1: 
    1:   GdkRectangle gdk_clip = mGDKClip;
    1:   gdk_clip.x += offsetX;
    1:   gdk_clip.y += offsetY;
    1:   
16529:   NS_ASSERTION(numClipRects == 0, "We don't support clipping!!!");
16529:   moz_gtk_widget_paint(mGTKWidgetType, drawable, &gdk_rect, &gdk_clip,
16529:                        &mState, mFlags, mDirection);
16458: 
    1:   return NS_OK;
    1: }
    1: 
    1: static PRBool
    1: GetExtraSizeForWidget(PRUint8 aWidgetType, nsIntMargin* aExtra)
    1: {
    1:   *aExtra = nsIntMargin(0,0,0,0);
    1:   // Allow an extra one pixel above and below the thumb for certain
    1:   // GTK2 themes (Ximian Industrial, Bluecurve, Misty, at least);
    1:   // see moz_gtk_scrollbar_thumb_paint in gtk2drawing.c
    1:   switch (aWidgetType) {
    1:   case NS_THEME_SCROLLBAR_THUMB_VERTICAL:
    1:     aExtra->top = aExtra->bottom = 1;
    1:     return PR_TRUE;
    1:   case NS_THEME_SCROLLBAR_THUMB_HORIZONTAL:
    1:     aExtra->left = aExtra->right = 1;
    1:     return PR_TRUE;
12733: 
12733:   // Include the indicator spacing (the padding around the control).
12733:   case NS_THEME_CHECKBOX:
12733:   case NS_THEME_RADIO:
12733:     {
12733:       gint indicator_size, indicator_spacing;
12733: 
21220:       if (aWidgetType == NS_THEME_CHECKBOX) {
12733:         moz_gtk_checkbox_get_metrics(&indicator_size, &indicator_spacing);
12733:       } else {
12733:         moz_gtk_radio_get_metrics(&indicator_size, &indicator_spacing);
12733:       }
12733: 
12733:       aExtra->top = indicator_spacing;
12733:       aExtra->right = indicator_spacing;
12733:       aExtra->bottom = indicator_spacing;
12733:       aExtra->left = indicator_spacing;
12733:       return PR_TRUE;
12733:     }
    1:   default:
    1:     return PR_FALSE;
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNativeThemeGTK::DrawWidgetBackground(nsIRenderingContext* aContext,
    1:                                        nsIFrame* aFrame,
    1:                                        PRUint8 aWidgetType,
    1:                                        const nsRect& aRect,
16193:                                        const nsRect& aDirtyRect)
    1: {
    1:   GtkWidgetState state;
    1:   GtkThemeWidgetType gtkWidgetType;
 9052:   GtkTextDirection direction = GetTextDirection(aFrame);
    1:   gint flags;
    1:   if (!GetGtkWidgetAndState(aWidgetType, aFrame, gtkWidgetType, &state,
    1:                             &flags))
    1:     return NS_OK;
    1: 
16193:   gfxContext* ctx = aContext->ThebesContext();
16193:   nsPresContext *presContext = aFrame->PresContext();
    1: 
16193:   gfxRect rect = presContext->AppUnitsToGfxUnits(aRect);
16193:   gfxRect dirtyRect = presContext->AppUnitsToGfxUnits(aDirtyRect);
16193: 
16193:   // Align to device pixels where sensible
16193:   // to provide crisper and faster drawing.
16193:   // Don't snap if it's a non-unit scale factor. We're going to have to take
16193:   // slow paths then in any case.
16193:   PRBool snapXY = ctx->UserToDevicePixelSnapped(rect);
16193:   if (snapXY) {
16193:     // Leave rect in device coords but make dirtyRect consistent.
16193:     dirtyRect = ctx->UserToDevice(dirtyRect);
16193:   }
16193: 
16193:   // Translate the dirty rect so that it is wrt the widget top-left.
16193:   dirtyRect.MoveBy(-rect.pos);
16193:   // Round out the dirty rect to gdk pixels to ensure that gtk draws
16193:   // enough pixels for interpolation to device pixels.
16193:   dirtyRect.RoundOut();
16193: 
16193:   // GTK themes can only draw an integer number of pixels
16193:   // (even when not snapped).
16193:   nsIntRect widgetRect(0, 0, NS_lround(rect.Width()), NS_lround(rect.Height()));
16193: 
16193:   // This is the rectangle that will actually be drawn, in gdk pixels
16193:   nsIntRect drawingRect(PRInt32(dirtyRect.X()),
16193:                         PRInt32(dirtyRect.Y()),
16193:                         PRInt32(dirtyRect.Width()),
16193:                         PRInt32(dirtyRect.Height()));
16193:   if (!drawingRect.IntersectRect(widgetRect, drawingRect))
16193:     return NS_OK;
16193: 
    1:   nsIntMargin extraSize;
16193:   // The margin should be applied to the widget rect rather than the dirty
16193:   // rect but nsCSSRendering::PaintBackgroundWithSC has already intersected
16193:   // the dirty rect with the uninflated widget rect.
16193:   if (GetExtraSizeForWidget(aWidgetType, &extraSize)) {
16193:     drawingRect.Inflate(extraSize);
16193:   }
16193: 
16193:   // gdk rectangles are wrt the drawing rect.
16193: 
16193:   // The gdk_clip is just advisory here, meanining "you don't
16193:   // need to draw outside this rect if you don't feel like it!"
16193:   GdkRectangle gdk_clip = {0, 0, drawingRect.width, drawingRect.height};
16193: 
16193:   GdkRectangle gdk_rect = {-drawingRect.x, -drawingRect.y,
16193:                            widgetRect.width, widgetRect.height};
16193: 
16193:   ThemeRenderer renderer(state, gtkWidgetType, flags, direction,
16193:                          gdk_rect, gdk_clip);
16193: 
16193:   // We require the use of the default screen and visual
16193:   // because I'm afraid that otherwise the GTK theme may explode.
16193:   // Some themes (e.g. Clearlooks) just don't clip properly to any
16193:   // clip rect we provide, so we cannot advertise support for clipping within
16193:   // the widget bounds.
16529:   PRUint32 rendererFlags = gfxGdkNativeRenderer::DRAW_SUPPORTS_OFFSET;
    1: 
    1:   // translate everything so (0,0) is the top left of the drawingRect
16193:   gfxContextAutoSaveRestore autoSR(ctx);
16193:   if (snapXY) {
16193:     // Rects are in device coords.
16193:     ctx->IdentityMatrix(); 
16193:   }
16193:   ctx->Translate(rect.pos + gfxPoint(drawingRect.x, drawingRect.y));
    1: 
    1:   NS_ASSERTION(!IsWidgetTypeDisabled(mDisabledWidgetTypes, aWidgetType),
    1:                "Trying to render an unsafe widget!");
    1: 
    1:   PRBool safeState = IsWidgetStateSafe(mSafeWidgetStates, aWidgetType, &state);
    1:   if (!safeState) {
16529:     gLastGdkError = 0;
16529:     gdk_error_trap_push ();
    1:   }
    1: 
16529:   renderer.Draw(ctx, drawingRect.width, drawingRect.height, rendererFlags, nsnull);
    1: 
    1:   if (!safeState) {
    1:     gdk_flush();
16529:     gLastGdkError = gdk_error_trap_pop ();
    1: 
16529:     if (gLastGdkError) {
    1: #ifdef DEBUG
    1:       printf("GTK theme failed for widget type %d, error was %d, state was "
  830:              "[active=%d,focused=%d,inHover=%d,disabled=%d]\n",
16529:              aWidgetType, gLastGdkError, state.active, state.focused,
    1:              state.inHover, state.disabled);
    1: #endif
    1:       NS_WARNING("GTK theme failed; disabling unsafe widget");
    1:       SetWidgetTypeDisabled(mDisabledWidgetTypes, aWidgetType);
    1:       // force refresh of the window, because the widget was not
    1:       // successfully drawn it must be redrawn using the default look
    1:       RefreshWidgetWindow(aFrame);
    1:     } else {
    1:       SetWidgetStateSafe(mSafeWidgetStates, aWidgetType, &state);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNativeThemeGTK::GetWidgetBorder(nsIDeviceContext* aContext, nsIFrame* aFrame,
23738:                                   PRUint8 aWidgetType, nsIntMargin* aResult)
    1: {
 9594:   GtkTextDirection direction = GetTextDirection(aFrame);
 2120:   aResult->top = aResult->left = aResult->right = aResult->bottom = 0;
    1:   switch (aWidgetType) {
    1:   case NS_THEME_SCROLLBAR_TRACK_VERTICAL:
    1:   case NS_THEME_SCROLLBAR_TRACK_HORIZONTAL:
    1:     {
    1:       MozGtkScrollbarMetrics metrics;
    1:       moz_gtk_get_scrollbar_metrics(&metrics);
 2120:       aResult->top = aResult->left = aResult->right = aResult->bottom = metrics.trough_border;
    1:     }
    1:     break;
    1:   case NS_THEME_TOOLBOX:
    1:     // gtk has no toolbox equivalent.  So, although we map toolbox to
    1:     // gtk's 'toolbar' for purposes of painting the widget background,
    1:     // we don't use the toolbar border for toolbox.
    1:     break;
    1:   case NS_THEME_TOOLBAR_DUAL_BUTTON:
    1:     // TOOLBAR_DUAL_BUTTON is an interesting case.  We want a border to draw
    1:     // around the entire button + dropdown, and also an inner border if you're
    1:     // over the button part.  But, we want the inner button to be right up
    1:     // against the edge of the outer button so that the borders overlap.
    1:     // To make this happen, we draw a button border for the outer button,
    1:     // but don't reserve any space for it.
    1:     break;
 9594:   case NS_THEME_TAB:
 9594:     // Top tabs have no bottom border, bottom tabs have no top border
 9594:     moz_gtk_get_widget_border(MOZ_GTK_TAB, &aResult->left, &aResult->top,
 9594:                               &aResult->right, &aResult->bottom, direction,
 9594:                               FALSE);
 9594:     if (IsBottomTab(aFrame))
 9594:         aResult->top = 0;
 9594:     else
 9594:         aResult->bottom = 0;
 9594:     break;
    1:   default:
    1:     {
    1:       GtkThemeWidgetType gtkWidgetType;
    1:       if (GetGtkWidgetAndState(aWidgetType, aFrame, gtkWidgetType, nsnull,
    1:                                nsnull))
 2120:         moz_gtk_get_widget_border(gtkWidgetType, &aResult->left, &aResult->top,
 9052:                                   &aResult->right, &aResult->bottom, direction,
28880:                                   IsFrameContentNodeOfType(aFrame, nsINode::eHTML));
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsNativeThemeGTK::GetWidgetPadding(nsIDeviceContext* aContext,
    1:                                    nsIFrame* aFrame, PRUint8 aWidgetType,
23738:                                    nsIntMargin* aResult)
    1: {
12732:   switch (aWidgetType) {
12732:     case NS_THEME_BUTTON_FOCUS:
12732:     case NS_THEME_TOOLBAR_BUTTON:
12732:     case NS_THEME_TOOLBAR_DUAL_BUTTON:
12732:     case NS_THEME_TAB_SCROLLARROW_BACK:
12732:     case NS_THEME_TAB_SCROLLARROW_FORWARD:
12883:     case NS_THEME_DROPDOWN_BUTTON:
12732:     // Radios and checkboxes return a fixed size in GetMinimumWidgetSize
12732:     // and have a meaningful baseline, so they can't have
12732:     // author-specified padding.
12732:     case NS_THEME_CHECKBOX:
12732:     case NS_THEME_RADIO:
    1:       aResult->SizeTo(0, 0, 0, 0);
    1:       return PR_TRUE;
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRBool
    1: nsNativeThemeGTK::GetWidgetOverflow(nsIDeviceContext* aContext,
    1:                                     nsIFrame* aFrame, PRUint8 aWidgetType,
13812:                                     nsRect* aOverflowRect)
    1: {
10065:   nsMargin m;
10065:   PRInt32 p2a;
 9594:   if (aWidgetType == NS_THEME_TAB)
 9594:   {
 9594:     if (!IsSelectedTab(aFrame))
    1:       return PR_FALSE;
 9594: 
10065:     p2a = aContext->AppUnitsPerDevPixel();
10065: 
 9594:     if (IsBottomTab(aFrame)) {
10065:       m = nsMargin(0, NSIntPixelsToAppUnits(moz_gtk_get_tab_thickness(), p2a)
 9594:                       + PR_MIN(0, aFrame->GetUsedMargin().top), 0, 0);
 9594:     } else {
10065:       m = nsMargin(0, 0, 0,
10065:                    NSIntPixelsToAppUnits(moz_gtk_get_tab_thickness(), p2a)
 9594:                    + PR_MIN(0, aFrame->GetUsedMargin().bottom));
 9594:     }
10065:   } else {
10065:     nsIntMargin extraSize;
10065:     if (!GetExtraSizeForWidget(aWidgetType, &extraSize))
 9594:       return PR_FALSE;
 9594: 
10065:     p2a = aContext->AppUnitsPerDevPixel();
10065:     m = nsMargin(NSIntPixelsToAppUnits(extraSize.left, p2a),
    1:                  NSIntPixelsToAppUnits(extraSize.top, p2a),
    1:                  NSIntPixelsToAppUnits(extraSize.right, p2a),
    1:                  NSIntPixelsToAppUnits(extraSize.bottom, p2a));
10065:   }
10065: 
13812:   aOverflowRect->Inflate(m);
    1:   return PR_TRUE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNativeThemeGTK::GetMinimumWidgetSize(nsIRenderingContext* aContext,
    1:                                        nsIFrame* aFrame, PRUint8 aWidgetType,
23738:                                        nsIntSize* aResult, PRBool* aIsOverridable)
    1: {
    1:   aResult->width = aResult->height = 0;
    1:   *aIsOverridable = PR_TRUE;
    1: 
    1:   switch (aWidgetType) {
    1:     case NS_THEME_SCROLLBAR_BUTTON_UP:
    1:     case NS_THEME_SCROLLBAR_BUTTON_DOWN:
    1:       {
    1:         MozGtkScrollbarMetrics metrics;
    1:         moz_gtk_get_scrollbar_metrics(&metrics);
    1: 
    1:         aResult->width = metrics.slider_width;
    1:         aResult->height = metrics.stepper_size;
    1:         *aIsOverridable = PR_FALSE;
    1:       }
    1:       break;
    1:     case NS_THEME_SCROLLBAR_BUTTON_LEFT:
    1:     case NS_THEME_SCROLLBAR_BUTTON_RIGHT:
    1:       {
    1:         MozGtkScrollbarMetrics metrics;
    1:         moz_gtk_get_scrollbar_metrics(&metrics);
    1: 
    1:         aResult->width = metrics.stepper_size;
    1:         aResult->height = metrics.slider_width;
    1:         *aIsOverridable = PR_FALSE;
    1:       }
    1:       break;
 9586:     case NS_THEME_SPLITTER:
 9586:     {
 9586:       gint metrics;
 9586:       if (IsHorizontal(aFrame)) {
 9586:         moz_gtk_splitter_get_metrics(GTK_ORIENTATION_HORIZONTAL, &metrics);
 9586:         aResult->width = metrics;
 9586:         aResult->height = 0;
 9586:       } else {
 9586:         moz_gtk_splitter_get_metrics(GTK_ORIENTATION_VERTICAL, &metrics);
 9586:         aResult->width = 0;
 9586:         aResult->height = metrics;
 9586:       }
 9586:       *aIsOverridable = PR_FALSE;
 9586:     }
 9586:     break;
    1:     case NS_THEME_SCROLLBAR_THUMB_VERTICAL:
    1:     case NS_THEME_SCROLLBAR_THUMB_HORIZONTAL:
    1:       {
    1:         MozGtkScrollbarMetrics metrics;
    1:         moz_gtk_get_scrollbar_metrics(&metrics);
    1: 
10613:         nsRect rect = aFrame->GetParent()->GetRect();
10613:         PRInt32 p2a = aFrame->PresContext()->DeviceContext()->
10613:                         AppUnitsPerDevPixel();
10613:         nsMargin margin;
10613: 
10613:         /* Get the available space, if that is smaller then the minimum size,
10613:          * adjust the mininum size to fit into it.
10613:          * Setting aIsOverridable to PR_TRUE has no effect for thumbs. */
10613:         aFrame->GetMargin(margin);
10613:         rect.Deflate(margin);
10613:         aFrame->GetParent()->GetBorderAndPadding(margin);
10613:         rect.Deflate(margin);
10613: 
    1:         if (aWidgetType == NS_THEME_SCROLLBAR_THUMB_VERTICAL) {
    1:           aResult->width = metrics.slider_width;
10613:           aResult->height = PR_MIN(NSAppUnitsToIntPixels(rect.height, p2a),
10613:                                    metrics.min_slider_size);
    1:         } else {
    1:           aResult->height = metrics.slider_width;
10613:           aResult->width = PR_MIN(NSAppUnitsToIntPixels(rect.width, p2a),
10613:                                   metrics.min_slider_size);
    1:         }
    1: 
    1:         *aIsOverridable = PR_FALSE;
    1:       }
    1:       break;
    1:     case NS_THEME_SCALE_THUMB_HORIZONTAL:
    1:     case NS_THEME_SCALE_THUMB_VERTICAL:
    1:       {
    1:         gint thumb_length, thumb_height;
    1: 
    1:         if (aWidgetType == NS_THEME_SCALE_THUMB_VERTICAL) {
    1:           moz_gtk_get_scalethumb_metrics(GTK_ORIENTATION_VERTICAL, &thumb_length, &thumb_height);
    1:           aResult->width = thumb_height;
    1:           aResult->height = thumb_length;
    1:         } else {
    1:           moz_gtk_get_scalethumb_metrics(GTK_ORIENTATION_HORIZONTAL, &thumb_length, &thumb_height);
    1:           aResult->width = thumb_length;
    1:           aResult->height = thumb_height;
    1:         }
    1: 
    1:         *aIsOverridable = PR_FALSE;
    1:       }
    1:       break;
11754:     case NS_THEME_TAB_SCROLLARROW_BACK:
11754:     case NS_THEME_TAB_SCROLLARROW_FORWARD:
11754:       {
11754:         moz_gtk_get_tab_scroll_arrow_size(&aResult->width, &aResult->height);
11754:         *aIsOverridable = PR_FALSE;
11754:       }
11754:       break;
    1:   case NS_THEME_DROPDOWN_BUTTON:
    1:     {
12930:       moz_gtk_get_combo_box_entry_button_size(&aResult->width,
12930:                                               &aResult->height);
    1:       *aIsOverridable = PR_FALSE;
    1:     }
    1:     break;
 8883:   case NS_THEME_MENUSEPARATOR:
 8883:     {
 8883:       gint separator_height;
 8883: 
 8883:       moz_gtk_get_menu_separator_height(&separator_height);
 8883:       aResult->height = separator_height;
 8883:     
 8883:       *aIsOverridable = PR_FALSE;
 8883:     }
 8883:     break;
    1:   case NS_THEME_CHECKBOX:
    1:   case NS_THEME_RADIO:
    1:     {
    1:       gint indicator_size, indicator_spacing;
    1: 
21220:       if (aWidgetType == NS_THEME_CHECKBOX) {
    1:         moz_gtk_checkbox_get_metrics(&indicator_size, &indicator_spacing);
    1:       } else {
    1:         moz_gtk_radio_get_metrics(&indicator_size, &indicator_spacing);
    1:       }
    1: 
    1:       // Include space for the indicator and the padding around it.
12733:       aResult->width = indicator_size;
12733:       aResult->height = indicator_size;
    1:       *aIsOverridable = PR_FALSE;
    1:     }
    1:     break;
12954:   case NS_THEME_TOOLBAR_BUTTON_DROPDOWN:
12954:     {
12954:         moz_gtk_get_downarrow_size(&aResult->width, &aResult->height);
12954:         *aIsOverridable = PR_FALSE;
12954:     }
12954:     break;
    1:   case NS_THEME_CHECKBOX_CONTAINER:
    1:   case NS_THEME_RADIO_CONTAINER:
    1:   case NS_THEME_CHECKBOX_LABEL:
    1:   case NS_THEME_RADIO_LABEL:
    1:   case NS_THEME_BUTTON:
13148:   case NS_THEME_DROPDOWN:
    1:   case NS_THEME_TOOLBAR_BUTTON:
 7646:   case NS_THEME_TREEVIEW_HEADER_CELL:
    1:     {
    1:       // Just include our border, and let the box code augment the size.
    1: 
    1:       nsCOMPtr<nsIDeviceContext> dc;
    1:       aContext->GetDeviceContext(*getter_AddRefs(dc));
    1: 
23738:       nsIntMargin border;
    1:       nsNativeThemeGTK::GetWidgetBorder(dc, aFrame, aWidgetType, &border);
    1:       aResult->width = border.left + border.right;
    1:       aResult->height = border.top + border.bottom;
    1:     }
    1:     break;
 8574:   case NS_THEME_TOOLBAR_SEPARATOR:
 8574:     {
 8574:       gint separator_width;
 8574:     
 8574:       moz_gtk_get_toolbar_separator_width(&separator_width);
 8574:     
 8574:       aResult->width = separator_width;
 8574:     }
 8574:     break;
 9590:   case NS_THEME_SPINNER:
 9590:     // hard code these sizes
 9590:     aResult->width = 14;
 9590:     aResult->height = 26;
 9590:     break;
 7932:   case NS_THEME_TREEVIEW_HEADER_SORTARROW:
    1:   case NS_THEME_SPINNER_UP_BUTTON:
    1:   case NS_THEME_SPINNER_DOWN_BUTTON:
    1:     // hard code these sizes
    1:     aResult->width = 14;
    1:     aResult->height = 13;
    1:     break;
 8892:   case NS_THEME_RESIZER:
 8892:     // same as Windows to make our lives easier
 8892:     aResult->width = aResult->height = 15;
 8892:     break;
 8004:   case NS_THEME_TREEVIEW_TWISTY:
 8004:   case NS_THEME_TREEVIEW_TWISTY_OPEN:
 8004:     {
 8004:       gint expander_size;
 8004: 
 9778:       moz_gtk_get_treeview_expander_size(&expander_size);
 8004:       aResult->width = aResult->height = expander_size;
 8004:       *aIsOverridable = PR_FALSE;
 8004:     }
 8004:     break;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNativeThemeGTK::WidgetStateChanged(nsIFrame* aFrame, PRUint8 aWidgetType, 
    1:                                      nsIAtom* aAttribute, PRBool* aShouldRepaint)
    1: {
    1:   // Some widget types just never change state.
    1:   if (aWidgetType == NS_THEME_TOOLBOX ||
    1:       aWidgetType == NS_THEME_TOOLBAR ||
    1:       aWidgetType == NS_THEME_STATUSBAR ||
    1:       aWidgetType == NS_THEME_STATUSBAR_PANEL ||
    1:       aWidgetType == NS_THEME_STATUSBAR_RESIZER_PANEL ||
    1:       aWidgetType == NS_THEME_PROGRESSBAR_CHUNK ||
    1:       aWidgetType == NS_THEME_PROGRESSBAR_CHUNK_VERTICAL ||
    1:       aWidgetType == NS_THEME_PROGRESSBAR ||
    1:       aWidgetType == NS_THEME_PROGRESSBAR_VERTICAL ||
    1:       aWidgetType == NS_THEME_MENUBAR ||
    1:       aWidgetType == NS_THEME_MENUPOPUP ||
    1:       aWidgetType == NS_THEME_TOOLTIP ||
 8883:       aWidgetType == NS_THEME_MENUSEPARATOR ||
    1:       aWidgetType == NS_THEME_WINDOW ||
    1:       aWidgetType == NS_THEME_DIALOG) {
    1:     *aShouldRepaint = PR_FALSE;
    1:     return NS_OK;
    1:   }
    1: 
11325:   if ((aWidgetType == NS_THEME_SCROLLBAR_BUTTON_UP ||
11325:        aWidgetType == NS_THEME_SCROLLBAR_BUTTON_DOWN ||
11325:        aWidgetType == NS_THEME_SCROLLBAR_BUTTON_LEFT ||
11325:        aWidgetType == NS_THEME_SCROLLBAR_BUTTON_RIGHT) &&
11325:       (aAttribute == nsWidgetAtoms::curpos ||
11325:        aAttribute == nsWidgetAtoms::maxpos)) {
11325:     *aShouldRepaint = PR_TRUE;
11325:     return NS_OK;
11325:   }
11325: 
    1:   // XXXdwh Not sure what can really be done here.  Can at least guess for
    1:   // specific widgets that they're highly unlikely to have certain states.
    1:   // For example, a toolbar doesn't care about any states.
    1:   if (!aAttribute) {
    1:     // Hover/focus/active changed.  Always repaint.
    1:     *aShouldRepaint = PR_TRUE;
    1:   }
    1:   else {
    1:     // Check the attribute to see if it's relevant.  
    1:     // disabled, checked, dlgtype, default, etc.
    1:     *aShouldRepaint = PR_FALSE;
    1:     if (aAttribute == nsWidgetAtoms::disabled ||
    1:         aAttribute == nsWidgetAtoms::checked ||
    1:         aAttribute == nsWidgetAtoms::selected ||
    1:         aAttribute == nsWidgetAtoms::focused ||
 2120:         aAttribute == nsWidgetAtoms::readonly ||
 5558:         aAttribute == nsWidgetAtoms::_default ||
10220:         aAttribute == nsWidgetAtoms::mozmenuactive ||
11504:         aAttribute == nsWidgetAtoms::open ||
11504:         aAttribute == nsWidgetAtoms::parentfocused)
    1:       *aShouldRepaint = PR_TRUE;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNativeThemeGTK::ThemeChanged()
    1: {
    1:   // this totally sucks.  this method is really supposed to be
    1:   // static, which is why we can call it without any initialization.
    1:   static NS_DEFINE_CID(kDeviceContextCID, NS_DEVICE_CONTEXT_CID);
    1:   nsCOMPtr<nsIDeviceContext> dctx = do_CreateInstance(kDeviceContextCID);
    1:   dctx->ClearCachedSystemFonts();
    1: 
    1:   memset(mDisabledWidgetTypes, 0, sizeof(mDisabledWidgetTypes));
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP_(PRBool)
    1: nsNativeThemeGTK::ThemeSupportsWidget(nsPresContext* aPresContext,
    1:                                       nsIFrame* aFrame,
    1:                                       PRUint8 aWidgetType)
    1: {
    1:   if (IsWidgetTypeDisabled(mDisabledWidgetTypes, aWidgetType))
    1:     return PR_FALSE;
    1: 
    1:   switch (aWidgetType) {
    1:   case NS_THEME_BUTTON:
    1:   case NS_THEME_BUTTON_FOCUS:
    1:   case NS_THEME_RADIO:
    1:   case NS_THEME_CHECKBOX:
    1:   case NS_THEME_TOOLBOX: // N/A
    1:   case NS_THEME_TOOLBAR:
    1:   case NS_THEME_TOOLBAR_BUTTON:
    1:   case NS_THEME_TOOLBAR_DUAL_BUTTON: // so we can override the border with 0
10361:   case NS_THEME_TOOLBAR_BUTTON_DROPDOWN:
 8574:   case NS_THEME_TOOLBAR_SEPARATOR:
    1:   case NS_THEME_TOOLBAR_GRIPPER:
    1:   case NS_THEME_STATUSBAR:
    1:   case NS_THEME_STATUSBAR_PANEL:
 8020:   case NS_THEME_STATUSBAR_RESIZER_PANEL:
 8892:   case NS_THEME_RESIZER:
 2303:   case NS_THEME_LISTBOX:
    1:     // case NS_THEME_LISTBOX_LISTITEM:
 7646:   case NS_THEME_TREEVIEW:
    1:     // case NS_THEME_TREEVIEW_TREEITEM:
 8004:   case NS_THEME_TREEVIEW_TWISTY:
    1:     // case NS_THEME_TREEVIEW_LINE:
    1:     // case NS_THEME_TREEVIEW_HEADER:
 7646:   case NS_THEME_TREEVIEW_HEADER_CELL:
 7932:   case NS_THEME_TREEVIEW_HEADER_SORTARROW:
 8004:   case NS_THEME_TREEVIEW_TWISTY_OPEN:
    1:     case NS_THEME_PROGRESSBAR:
    1:     case NS_THEME_PROGRESSBAR_CHUNK:
    1:     case NS_THEME_PROGRESSBAR_VERTICAL:
    1:     case NS_THEME_PROGRESSBAR_CHUNK_VERTICAL:
    1:     case NS_THEME_TAB:
    1:     // case NS_THEME_TAB_PANEL:
    1:     case NS_THEME_TAB_PANELS:
11754:     case NS_THEME_TAB_SCROLLARROW_BACK:
11754:     case NS_THEME_TAB_SCROLLARROW_FORWARD:
    1:   case NS_THEME_TOOLTIP:
 9590:   case NS_THEME_SPINNER:
    1:   case NS_THEME_SPINNER_UP_BUTTON:
    1:   case NS_THEME_SPINNER_DOWN_BUTTON:
 9590:   case NS_THEME_SPINNER_TEXTFIELD:
    1:     // case NS_THEME_SCROLLBAR:  (n/a for gtk)
 3459:     // case NS_THEME_SCROLLBAR_SMALL: (n/a for gtk)
    1:   case NS_THEME_SCROLLBAR_BUTTON_UP:
    1:   case NS_THEME_SCROLLBAR_BUTTON_DOWN:
    1:   case NS_THEME_SCROLLBAR_BUTTON_LEFT:
    1:   case NS_THEME_SCROLLBAR_BUTTON_RIGHT:
    1:   case NS_THEME_SCROLLBAR_TRACK_HORIZONTAL:
    1:   case NS_THEME_SCROLLBAR_TRACK_VERTICAL:
    1:   case NS_THEME_SCROLLBAR_THUMB_HORIZONTAL:
    1:   case NS_THEME_SCROLLBAR_THUMB_VERTICAL:
    1:   case NS_THEME_TEXTFIELD:
 1191:   case NS_THEME_TEXTFIELD_MULTILINE:
15481:   case NS_THEME_TEXTFIELD_CARET:
    1:   case NS_THEME_DROPDOWN_TEXTFIELD:
    1:   case NS_THEME_SCALE_HORIZONTAL:
    1:   case NS_THEME_SCALE_THUMB_HORIZONTAL:
    1:   case NS_THEME_SCALE_VERTICAL:
    1:   case NS_THEME_SCALE_THUMB_VERTICAL:
    1:     // case NS_THEME_SCALE_THUMB_START:
    1:     // case NS_THEME_SCALE_THUMB_END:
    1:     // case NS_THEME_SCALE_TICK:
    1:   case NS_THEME_CHECKBOX_CONTAINER:
    1:   case NS_THEME_RADIO_CONTAINER:
    1:   case NS_THEME_CHECKBOX_LABEL:
    1:   case NS_THEME_RADIO_LABEL:
    1:   case NS_THEME_MENUBAR:
    1:   case NS_THEME_MENUPOPUP:
    1:   case NS_THEME_MENUITEM:
 8423:   case NS_THEME_MENUARROW:
 8883:   case NS_THEME_MENUSEPARATOR:
    1:   case NS_THEME_CHECKMENUITEM:
    1:   case NS_THEME_RADIOMENUITEM:
 9586:   case NS_THEME_SPLITTER:
    1:   case NS_THEME_WINDOW:
    1:   case NS_THEME_DIALOG:
    1:   case NS_THEME_DROPDOWN:
    1:   case NS_THEME_DROPDOWN_TEXT:
    1:     return !IsWidgetStyled(aPresContext, aFrame, aWidgetType);
 7180: 
 7180:   case NS_THEME_DROPDOWN_BUTTON:
 7180:     // "Native" dropdown buttons cause padding and margin problems, but only
 7180:     // in HTML so allow them in XUL.
28880:     return (!aFrame || IsFrameContentNodeOfType(aFrame, nsINode::eXUL)) &&
 7180:            !IsWidgetStyled(aPresContext, aFrame, aWidgetType);
 7180: 
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: NS_IMETHODIMP_(PRBool)
    1: nsNativeThemeGTK::WidgetIsContainer(PRUint8 aWidgetType)
    1: {
    1:   // XXXdwh At some point flesh all of this out.
    1:   if (aWidgetType == NS_THEME_DROPDOWN_BUTTON ||
21220:       aWidgetType == NS_THEME_RADIO ||
21220:       aWidgetType == NS_THEME_CHECKBOX ||
11754:       aWidgetType == NS_THEME_TAB_SCROLLARROW_BACK ||
11754:       aWidgetType == NS_THEME_TAB_SCROLLARROW_FORWARD)
    1:     return PR_FALSE;
    1:   return PR_TRUE;
    1: }
    1: 
    1: PRBool
    1: nsNativeThemeGTK::ThemeDrawsFocusForWidget(nsPresContext* aPresContext, nsIFrame* aFrame, PRUint8 aWidgetType)
    1: {
 2120:    if (aWidgetType == NS_THEME_DROPDOWN ||
 7646:       aWidgetType == NS_THEME_BUTTON || 
 7646:       aWidgetType == NS_THEME_TREEVIEW_HEADER_CELL)
 2120:     return PR_TRUE;
 2120:   
    1:   return PR_FALSE;
    1: }
 1582: 
 1582: PRBool
 1582: nsNativeThemeGTK::ThemeNeedsComboboxDropmarker()
 1582: {
 2120:   return PR_FALSE;
 1582: }
22675: 
22675: nsTransparencyMode
22675: nsNativeThemeGTK::GetWidgetTransparency(PRUint8 aWidgetType)
22675: {
22675:   return eTransparencyOpaque;
22675: }
