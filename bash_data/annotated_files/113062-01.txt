111677: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
111677:  * vim: set ts=4 sw=4 et tw=79:
111677:  *
111677:  * ***** BEGIN LICENSE BLOCK *****
111677:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
111677:  *
111677:  * The contents of this file are subject to the Mozilla Public License Version
111677:  * 1.1 (the "License"); you may not use this file except in compliance with
111677:  * the License. You may obtain a copy of the License at
111677:  * http://www.mozilla.org/MPL/
111677:  *
111677:  * Software distributed under the License is distributed on an "AS IS" basis,
111677:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
111677:  * for the specific language governing rights and limitations under the
111677:  * License.
111677:  *
111677:  * The Original Code is Mozilla Communicator client code, released
111677:  * March 31, 1998.
111677:  *
111677:  * The Initial Developer of the Original Code is
111677:  * Netscape Communications Corporation.
111677:  * Portions created by the Initial Developer are Copyright (C) 1998
111677:  * the Initial Developer. All Rights Reserved.
111677:  *
111677:  * Contributor(s):
111758:  *   Andrew Drake <adrake@adrake.org>
111677:  *
111677:  * Alternatively, the contents of this file may be used under the terms of
111677:  * either of the GNU General Public License Version 2 or later (the "GPL"),
111677:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
111677:  * in which case the provisions of the GPL or the LGPL are applicable instead
111677:  * of those above. If you wish to allow use of your version of this file only
111677:  * under the terms of either the GPL or the LGPL, and not to allow others to
111677:  * use your version of this file under the terms of the MPL, indicate your
111677:  * decision by deleting the provisions above and replace them with the notice
111677:  * and other provisions required by the GPL or the LGPL. If you do not delete
111677:  * the provisions above, a recipient may use your version of this file under
111677:  * the terms of any one of the MPL, the GPL or the LGPL.
111677:  *
111677:  * ***** END LICENSE BLOCK ***** */
111677: 
111677: #include "Ion.h"
111706: #include "IonAnalysis.h"
111706: #include "IonBuilder.h"
111736: #include "IonSpewer.h"
112262: #include "LIR.h"
112302: #include "AliasAnalysis.h"
111732: #include "GreedyAllocator.h"
111744: #include "LICM.h"
111756: #include "ValueNumbering.h"
112912: #include "RangeAnalysis.h"
111758: #include "LinearScan.h"
111804: #include "jscompartment.h"
111845: #include "IonCompartment.h"
111930: #include "CodeGenerator.h"
111706: 
111706: #if defined(JS_CPU_X86)
111706: # include "x86/Lowering-x86.h"
111706: #elif defined(JS_CPU_X64)
111706: # include "x64/Lowering-x64.h"
111706: #elif defined(JS_CPU_ARM)
111706: # include "arm/Lowering-arm.h"
111706: #endif
113019: #include "gc/Marking.h"
111793: #include "jsgcinlines.h"
112042: #include "jsinferinlines.h"
112042: #include "jsobjinlines.h"
111818: #include "vm/Stack-inl.h"
112837: #include "ion/IonFrames-inl.h"
113053: #include "ion/CompilerRoot.h"
111677: 
111677: using namespace js;
111677: using namespace js::ion;
111677: 
113053: // Global variables.
111791: IonOptions ion::js_IonOptions;
111791: 
111793: // Assert that IonCode is gc::Cell aligned.
111793: JS_STATIC_ASSERT(sizeof(IonCode) % gc::Cell::CellSize == 0);
111793: 
111677: #ifdef JS_THREADSAFE
111677: static bool IonTLSInitialized = false;
111677: static PRUintn IonTLSIndex;
112150: 
112150: static inline IonContext *
112150: CurrentIonContext()
112150: {
112150:     return (IonContext *)PR_GetThreadPrivate(IonTLSIndex);
112150: }
112150: 
112150: bool
112150: ion::SetIonContext(IonContext *ctx)
112150: {
112150:     return PR_SetThreadPrivate(IonTLSIndex, ctx) == PR_SUCCESS;
112150: }
112150: 
111677: #else
112150: 
111677: static IonContext *GlobalIonContext;
112150: 
112150: static inline IonContext *
112150: CurrentIonContext()
112150: {
112150:     return GlobalIonContext;
112150: }
112150: 
112150: bool
112150: ion::SetIonContext(IonContext *ctx)
112150: {
112150:     GlobalIonContext = ctx;
112150:     return true;
112150: }
111677: #endif
111677: 
112150: IonContext *
112150: ion::GetIonContext()
112150: {
112150:     JS_ASSERT(CurrentIonContext());
112150:     return CurrentIonContext();
112150: }
112150: 
111677: IonContext::IonContext(JSContext *cx, TempAllocator *temp)
111677:   : cx(cx),
112150:     temp(temp),
112150:     prev_(CurrentIonContext())
111677: {
111677:     SetIonContext(this);
111706: }
111677: 
111677: IonContext::~IonContext()
111677: {
112150:     SetIonContext(prev_);
111677: }
111677: 
111782: bool
111782: ion::InitializeIon()
111677: {
111677: #ifdef JS_THREADSAFE
111677:     if (!IonTLSInitialized) {
111677:         PRStatus status = PR_NewThreadPrivateIndex(&IonTLSIndex, NULL);
111677:         if (status != PR_SUCCESS)
111677:             return false;
111677:         IonTLSInitialized = true;
111677:     }
111677: #endif
111734:     CheckLogging();
111677:     return true;
111677: }
111677: 
111805: IonCompartment::IonCompartment()
111805:   : execAlloc_(NULL),
111935:     enterJIT_(NULL),
111935:     bailoutHandler_(NULL),
112161:     argumentsRectifier_(NULL),
112310:     invalidator_(NULL),
112161:     functionWrappers_(NULL)
111805: {
111805: }
111805: 
111805: bool
111805: IonCompartment::initialize(JSContext *cx)
111805: {
113019:     execAlloc_ = cx->runtime->getExecAlloc(cx);
111817:     if (!execAlloc_)
111805:         return false;
111805: 
112161:     functionWrappers_ = cx->new_<VMWrapperMap>(cx);
112161:     if (!functionWrappers_ || !functionWrappers_->init())
112161:         return false;
112161: 
111805:     return true;
111805: }
111805: 
111817: void
111817: IonCompartment::mark(JSTracer *trc, JSCompartment *compartment)
111817: {
112776:     // This function marks Ion code objects that must be kept alive if there is
112776:     // any Ion code currently running. These pointers are marked at the start
112776:     // of incremental GC. Entering Ion code in the middle of an incremental GC
112776:     // triggers a read barrier on both these pointers, so they will still be
112776:     // marked in that case.
112818: 
112818:     bool mustMarkEnterJIT = false;
112818:     for (IonActivationIterator iter(trc->runtime); iter.more(); ++iter) {
112818:         if (iter.activation()->compartment() != compartment)
112818:             continue;
112874: 
112874:         // Both OSR and normal function calls depend on the EnterJIT code
112874:         // existing for entrance and exit.
112818:         mustMarkEnterJIT = true;
112818:     }
111936: 
112776:     // These must be available if we could be running JIT code; they are not
112776:     // traced as normal through IonCode or IonScript objects
112818:     if (mustMarkEnterJIT)
112729:         MarkIonCodeRoot(trc, enterJIT_.unsafeGetAddress(), "enterJIT");
111935: 
112161:     // functionWrappers_ are not marked because this is a WeakCache of VM
112161:     // function implementations.
111935: }
111817: 
111817: void
112964: IonCompartment::sweep(FreeOp *fop)
111817: {
112673:     if (enterJIT_ && IsAboutToBeFinalized(enterJIT_))
111817:         enterJIT_ = NULL;
112673:     if (bailoutHandler_ && IsAboutToBeFinalized(bailoutHandler_))
111935:         bailoutHandler_ = NULL;
112673:     if (argumentsRectifier_ && IsAboutToBeFinalized(argumentsRectifier_))
112077:         argumentsRectifier_ = NULL;
112673:     if (invalidator_ && IsAboutToBeFinalized(invalidator_))
112407:         invalidator_ = NULL;
112726:     if (preBarrier_ && IsAboutToBeFinalized(preBarrier_))
112726:         preBarrier_ = NULL;
111935: 
111935:     for (size_t i = 0; i < bailoutTables_.length(); i++) {
112673:         if (bailoutTables_[i] && IsAboutToBeFinalized(bailoutTables_[i]))
111935:             bailoutTables_[i] = NULL;
111935:     }
112161: 
112161:     // Sweep cache of VM function implementations.
112964:     functionWrappers_->sweep(fop);
111935: }
111935: 
111935: IonCode *
111935: IonCompartment::getBailoutTable(const FrameSizeClass &frameClass)
111935: {
111935:     JS_ASSERT(frameClass != FrameSizeClass::None());
111935:     return bailoutTables_[frameClass.classId()];
111935: }
111935: 
111935: IonCode *
111935: IonCompartment::getBailoutTable(JSContext *cx, const FrameSizeClass &frameClass)
111935: {
111935:     uint32 id = frameClass.classId();
111935: 
111935:     if (id >= bailoutTables_.length()) {
111935:         size_t numToPush = id - bailoutTables_.length() + 1;
111935:         if (!bailoutTables_.reserve(bailoutTables_.length() + numToPush))
111935:             return NULL;
111935:         for (size_t i = 0; i < numToPush; i++)
111935:             bailoutTables_.infallibleAppend(NULL);
111935:     }
111935: 
111935:     if (!bailoutTables_[id])
111935:         bailoutTables_[id] = generateBailoutTable(cx, id);
111935: 
111935:     return bailoutTables_[id];
111817: }
111817: 
111805: IonCompartment::~IonCompartment()
111805: {
112161:     Foreground::delete_(functionWrappers_);
111805: }
111805: 
112874: IonActivation::IonActivation(JSContext *cx, StackFrame *fp)
111935:   : cx_(cx),
112521:     compartment_(cx->compartment),
112479:     prev_(cx->runtime->ionActivation),
111935:     entryfp_(fp),
112192:     bailout_(NULL),
112479:     prevIonTop_(cx->runtime->ionTop),
112971:     prevIonJSContext_(cx->runtime->ionJSContext)
111935: {
112241:     fp->setRunningInIon();
112479:     cx->runtime->ionJSContext = cx;
112479:     cx->runtime->ionActivation = this;
112530:     cx->runtime->ionStackLimit = cx->runtime->nativeStackLimit;
111935: }
111935: 
111935: IonActivation::~IonActivation()
111935: {
112479:     JS_ASSERT(cx_->runtime->ionActivation == this);
111935:     JS_ASSERT(!bailout_);
111935: 
112241:     entryfp_->clearRunningInIon();
112479:     cx_->runtime->ionActivation = prev();
112479:     cx_->runtime->ionTop = prevIonTop_;
112479:     cx_->runtime->ionJSContext = prevIonJSContext_;
111935: }
111935: 
111793: IonCode *
111865: IonCode::New(JSContext *cx, uint8 *code, uint32 bufferSize, JSC::ExecutablePool *pool)
111793: {
112249:     IonCode *codeObj = gc::NewGCThing<IonCode>(cx, gc::FINALIZE_IONCODE, sizeof(IonCode));
111793:     if (!codeObj) {
111793:         pool->release();
111793:         return NULL;
111793:     }
111793: 
111865:     new (codeObj) IonCode(code, bufferSize, pool);
111793:     return codeObj;
111793: }
111793: 
111782: void
111865: IonCode::copyFrom(MacroAssembler &masm)
111865: {
111865:     // Store the IonCode pointer right before the code buffer, so we can
111865:     // recover the gcthing from relocation tables.
111865:     *(IonCode **)(code_ - sizeof(IonCode *)) = this;
111865: 
111865:     insnSize_ = masm.instructionsSize();
111865:     masm.executableCopy(code_);
111865: 
111920:     dataSize_ = masm.dataSize();
111975:     masm.processDeferredData(this, code_ + dataOffset());
111920: 
112122:     jumpRelocTableBytes_ = masm.jumpRelocationTableBytes();
112122:     masm.copyJumpRelocationTable(code_ + jumpRelocTableOffset());
112122: 
112122:     dataRelocTableBytes_ = masm.dataRelocationTableBytes();
112122:     masm.copyDataRelocationTable(code_ + dataRelocTableOffset());
112122: 
111975:     masm.processCodeLabels(this);
111865: }
111865: 
111865: void
111865: IonCode::trace(JSTracer *trc)
111865: {
112521:     // Note that we cannot mark invalidated scripts, since we've basically
112521:     // corrupted the code stream by injecting bailouts.
112521:     if (invalidated())
112521:         return;
112521: 
112122:     if (jumpRelocTableBytes_) {
112122:         uint8 *start = code_ + jumpRelocTableOffset();
112122:         CompactBufferReader reader(start, start + jumpRelocTableBytes_);
112122:         MacroAssembler::TraceJumpRelocations(trc, this, reader);
112122:     }
112122:     if (dataRelocTableBytes_) {
112122:         uint8 *start = code_ + dataRelocTableOffset();
112122:         CompactBufferReader reader(start, start + dataRelocTableBytes_);
112122:         MacroAssembler::TraceDataRelocations(trc, this, reader);
111865:     }
111865: }
111865: 
111865: void
112964: IonCode::finalize(FreeOp *fop)
111782: {
112964:     JS_ASSERT(!fop->onBackgroundThread());
111782:     if (pool_)
111782:         pool_->release();
111793: }
111793: 
112199: void
112199: IonCode::readBarrier(IonCode *code)
112199: {
112199: #ifdef JSGC_INCREMENTAL
112199:     if (!code)
112199:         return;
112199: 
112199:     JSCompartment *comp = code->compartment();
112199:     if (comp->needsBarrier())
112811:         MarkIonCodeUnbarriered(comp->barrierTracer(), &code, "ioncode read barrier");
112199: #endif
112199: }
112199: 
112199: void
112199: IonCode::writeBarrierPre(IonCode *code)
112199: {
112199: #ifdef JSGC_INCREMENTAL
112199:     if (!code)
112199:         return;
112199: 
112199:     JSCompartment *comp = code->compartment();
112199:     if (comp->needsBarrier())
112811:         MarkIonCodeUnbarriered(comp->barrierTracer(), &code, "ioncode write barrier");
112199: #endif
112199: }
112199: 
112199: void
112199: IonCode::writeBarrierPost(IonCode *code, void *addr)
112199: {
112199: #ifdef JSGC_INCREMENTAL
112199:     // Nothing to do.
112199: #endif
112199: }
112199: 
111818: IonScript::IonScript()
111935:   : method_(NULL),
111935:     deoptTable_(NULL),
112219:     osrPc_(NULL),
112219:     osrEntryOffset_(0),
112505:     invalidateEpilogueOffset_(0),
112505:     invalidateEpilogueDataOffset_(0),
112219:     forbidOsr_(false),
111935:     snapshots_(0),
111935:     snapshotsSize_(0),
111935:     bailoutTable_(0),
112223:     bailoutEntries_(0),
112223:     constantTable_(0),
112223:     constantEntries_(0),
112505:     safepointIndexOffset_(0),
112505:     safepointIndexEntries_(0),
112337:     frameLocals_(0),
112337:     frameSize_(0),
112337:     safepointsStart_(0),
112337:     safepointsSize_(0),
112315:     cacheList_(0),
112337:     cacheEntries_(0),
112337:     refcount_(0)
111818: {
111818: }
111818: 
111818: IonScript *
112331: IonScript::New(JSContext *cx, uint32 frameLocals, uint32 frameSize, size_t snapshotsSize,
112505:                size_t bailoutEntries, size_t constants, size_t safepointIndices,
112505:                size_t osiIndices, size_t cacheEntries, size_t safepointsSize)
111818: {
111935:     if (snapshotsSize >= MAX_BUFFER_SIZE ||
111935:         (bailoutEntries >= MAX_BUFFER_SIZE / sizeof(uint32)))
111935:     {
111935:         js_ReportOutOfMemory(cx);
111935:         return NULL;
111818:     }
111818: 
111935:     // This should not overflow on x86, because the memory is already allocated
111935:     // *somewhere* and if their total overflowed there would be no memory left
111935:     // at all.
111935:     size_t bytes = snapshotsSize +
111975:                    bailoutEntries * sizeof(uint32) +
112223:                    constants * sizeof(Value) +
112505:                    safepointIndices * sizeof(SafepointIndex) +
112505:                    osiIndices * sizeof(OsiIndex) +
112331:                    cacheEntries * sizeof(IonCache) +
112331:                    safepointsSize;
111935:     uint8 *buffer = (uint8 *)cx->malloc_(sizeof(IonScript) + bytes);
111935:     if (!buffer)
111935:         return NULL;
111935: 
111935:     IonScript *script = reinterpret_cast<IonScript *>(buffer);
111935:     new (script) IonScript();
111935: 
112331:     uint32 offsetCursor = sizeof(IonScript);
112223: 
112331:     script->snapshots_ = offsetCursor;
111935:     script->snapshotsSize_ = snapshotsSize;
112331:     offsetCursor += snapshotsSize;
111935: 
112331:     script->bailoutTable_ = offsetCursor;
111935:     script->bailoutEntries_ = bailoutEntries;
112331:     offsetCursor += bailoutEntries * sizeof(uint32);
111935: 
112331:     script->constantTable_ = offsetCursor;
111975:     script->constantEntries_ = constants;
112331:     offsetCursor += constants * sizeof(Value);
112223: 
112505:     script->safepointIndexOffset_ = offsetCursor;
112505:     script->safepointIndexEntries_ = safepointIndices;
112505:     offsetCursor += safepointIndices * sizeof(SafepointIndex);
112505: 
112505:     script->osiIndexOffset_ = offsetCursor;
112505:     script->osiIndexEntries_ = osiIndices;
112505:     offsetCursor += osiIndices * sizeof(OsiIndex);
112315: 
112331:     script->cacheList_ = offsetCursor;
112315:     script->cacheEntries_ = cacheEntries;
112331:     offsetCursor += cacheEntries * sizeof(IonCache);
112331: 
112331:     script->safepointsStart_ = offsetCursor;
112331:     script->safepointsSize_ = safepointsSize;
112331:     offsetCursor += safepointsSize;
112331: 
112331:     script->frameLocals_ = frameLocals;
112331:     script->frameSize_ = frameSize;
111975: 
111935:     return script;
111935: }
111935: 
111793: void
112326: IonScript::trace(JSTracer *trc)
111793: {
112542:     if (method_)
112729:         MarkIonCode(trc, &method_, "method");
112521: 
111935:     if (deoptTable_)
112729:         MarkIonCode(trc, &deoptTable_, "deoptimizationTable");
112521: 
112521:     for (size_t i = 0; i < numConstants(); i++)
112717:         gc::MarkValue(trc, &getConstant(i), "constant");
111935: }
111935: 
111935: void
111935: IonScript::copySnapshots(const SnapshotWriter *writer)
111935: {
112331:     JS_ASSERT(writer->size() == snapshotsSize_);
111935:     memcpy((uint8 *)this + snapshots_, writer->buffer(), snapshotsSize_);
111935: }
111935: 
111935: void
112331: IonScript::copySafepoints(const SafepointWriter *writer)
112331: {
112331:     JS_ASSERT(writer->size() == safepointsSize_);
112331:     memcpy((uint8 *)this + safepointsStart_, writer->buffer(), safepointsSize_);
112331: }
112331: 
112331: void
111935: IonScript::copyBailoutTable(const SnapshotOffset *table)
111935: {
111935:     memcpy(bailoutTable(), table, bailoutEntries_ * sizeof(uint32));
111782: }
111782: 
111782: void
112521: IonScript::copyConstants(const HeapValue *vp)
111975: {
112521:     for (size_t i = 0; i < constantEntries_; i++)
112521:         constants()[i].init(vp[i]);
111975: }
111975: 
111975: void
112505: IonScript::copySafepointIndices(const SafepointIndex *si, MacroAssembler &masm)
112223: {
112492:     /*
112492:      * Jumps in the caches reflect the offset of those jumps in the compiled
112492:      * code, not the absolute positions of the jumps. Update according to the
112492:      * final code address now.
112492:      */
112505:     SafepointIndex *table = safepointIndices();
112505:     memcpy(table, si, safepointIndexEntries_ * sizeof(SafepointIndex));
112505:     for (size_t i = 0; i < safepointIndexEntries_; i++)
112739:         table[i].adjustDisplacement(masm.actualOffset(table[i].displacement()));
112223: }
112223: 
112315: void
112693: IonScript::copyOsiIndices(const OsiIndex *oi, MacroAssembler &masm)
112505: {
112505:     memcpy(osiIndices(), oi, osiIndexEntries_ * sizeof(OsiIndex));
112781:     for (unsigned i = 0; i < osiIndexEntries_; i++)
112693:         osiIndices()[i].fixUpOffset(masm);
112505: }
112505: 
112505: void
112482: IonScript::copyCacheEntries(const IonCache *caches, MacroAssembler &masm)
112315: {
112315:     memcpy(cacheList(), caches, numCaches() * sizeof(IonCache));
112315: 
112315:     /*
112315:      * Jumps in the caches reflect the offset of those jumps in the compiled
112315:      * code, not the absolute positions of the jumps. Update according to the
112315:      * final code address now.
112315:      */
112315:     for (size_t i = 0; i < numCaches(); i++)
112482:         getCache(i).updateBaseAddress(method_, masm);
112315: }
112315: 
112505: const SafepointIndex *
112505: IonScript::getSafepointIndex(uint32 disp) const
112223: {
112505:     JS_ASSERT(safepointIndexEntries_ > 0);
112223: 
112505:     const SafepointIndex *table = safepointIndices();
112505:     if (safepointIndexEntries_ == 1) {
112331:         JS_ASSERT(disp == table[0].displacement());
112313:         return &table[0];
112313:     }
112313: 
112310:     size_t minEntry = 0;
112505:     size_t maxEntry = safepointIndexEntries_ - 1;
112331:     uint32 min = table[minEntry].displacement();
112331:     uint32 max = table[maxEntry].displacement();
112223: 
112313:     // Raise if the element is not in the list.
112313:     JS_ASSERT(min <= disp && disp <= max);
112223: 
112313:     // Approximate the location of the FrameInfo.
112313:     size_t guess = (disp - min) * (maxEntry - minEntry) / (max - min) + minEntry;
112331:     uint32 guessDisp = table[guess].displacement();
112223: 
112331:     if (table[guess].displacement() == disp)
112313:         return &table[guess];
112313: 
112313:     // Doing a linear scan from the guess should be more efficient in case of
112313:     // small group which are equally distributed on the code.
112313:     //
112313:     // such as:  <...      ...    ...  ...  .   ...    ...>
112313:     if (guessDisp > disp) {
112313:         while (--guess >= minEntry) {
112331:             guessDisp = table[guess].displacement();
112313:             JS_ASSERT(guessDisp >= disp);
112223:             if (guessDisp == disp)
112313:                 return &table[guess];
112313:         }
112223:     } else {
112313:         while (++guess <= maxEntry) {
112331:             guessDisp = table[guess].displacement();
112313:             JS_ASSERT(guessDisp <= disp);
112313:             if (guessDisp == disp)
112313:                 return &table[guess];
112223:         }
112223:     }
112223: 
112313:     JS_NOT_REACHED("displacement not found.");
112313:     return NULL;
112223: }
112223: 
112505: const OsiIndex *
112505: IonScript::getOsiIndex(uint32 disp) const
112505: {
112505:     for (const OsiIndex *it = osiIndices(), *end = osiIndices() + osiIndexEntries_;
112505:          it != end;
112505:          ++it)
112505:     {
112505:         if (it->returnPointDisplacement() == disp)
112505:             return it;
112505:     }
112505: 
112505:     JS_NOT_REACHED("Failed to find OSI point return address");
112505:     return NULL;
112505: }
112505: 
112505: const OsiIndex *
112505: IonScript::getOsiIndex(uint8 *retAddr) const
112505: {
112505:     IonSpew(IonSpew_Invalidate, "IonScript %p has method %p raw %p", (void *) this, (void *)
112505:             method(), method()->raw());
112505: 
112874:     JS_ASSERT(containsCodeAddress(retAddr));
112505:     uint32 disp = retAddr - method()->raw();
112505:     return getOsiIndex(disp);
112505: }
112223: 
112223: void
112326: IonScript::Trace(JSTracer *trc, IonScript *script)
111804: {
112326:     if (script != ION_DISABLED_SCRIPT)
112326:         script->trace(trc);
111804: }
111804: 
111804: void
112964: IonScript::Destroy(FreeOp *fop, IonScript *script)
111782: {
112964:     fop->free_(script);
111782: }
111782: 
111734: static bool
111734: TestCompiler(IonBuilder &builder, MIRGraph &graph)
111706: {
112006:     IonSpewNewFunction(&graph, builder.script);
111706: 
111706:     if (!builder.build())
111706:         return false;
112006:     IonSpewPass("BuildSSA");
112870:     // Note: don't call AssertGraphCoherency before SplitCriticalEdges,
112870:     // the graph is not in RPO at this point.
111706: 
111749:     if (!SplitCriticalEdges(&builder, graph))
111749:         return false;
112006:     IonSpewPass("Split Critical Edges");
112219:     AssertGraphCoherency(graph);
111749: 
112870:     if (!RenumberBlocks(graph))
111706:         return false;
112870:     IonSpewPass("Renumber Blocks");
112219:     AssertGraphCoherency(graph);
111706: 
111738:     if (!BuildDominatorTree(graph))
111738:         return false;
112006:     // No spew: graph not changed.
111738: 
112383:     // This must occur before any code elimination.
112831:     if (!EliminatePhis(graph))
112082:         return false;
112831:     IonSpewPass("Eliminate phis");
112755:     AssertGraphCoherency(graph);
112082: 
111718:     if (!BuildPhiReverseMapping(graph))
111718:         return false;
112006:     // No spew: graph not changed.
111718: 
112383:     // This pass also removes copies.
111706:     if (!ApplyTypeInformation(graph))
111706:         return false;
112006:     IonSpewPass("Apply types");
112755:     AssertGraphCoherency(graph);
111706: 
112302:     // Alias analysis is required for LICM and GVN so that we don't move
112302:     // loads across stores.
112302:     if (js_IonOptions.licm || js_IonOptions.gvn) {
112302:         AliasAnalysis analysis(graph);
112302:         if (!analysis.analyze())
112302:             return false;
112302:         IonSpewPass("Alias analysis");
112755:         AssertGraphCoherency(graph);
112302:     }
112302: 
112987:     if (js_IonOptions.rangeAnalysis) {
112987:         RangeAnalysis rangeAnalysis(graph);
112987:         if (!rangeAnalysis.analyzeEarly())
112987:             return false;
112987:         IonSpewPass("Range Analysis (Early)");
112987:         AssertGraphCoherency(graph);
112987:     }
112987: 
111791:     if (js_IonOptions.gvn) {
111791:         ValueNumberer gvn(graph, js_IonOptions.gvnIsOptimistic);
111756:         if (!gvn.analyze())
111756:             return false;
112006:         IonSpewPass("GVN");
112755:         AssertGraphCoherency(graph);
111791:     }
111756: 
111985:     if (!EliminateDeadCode(graph))
111985:         return false;
112006:     IonSpewPass("DCE");
112755:     AssertGraphCoherency(graph);
111985: 
111791:     if (js_IonOptions.licm) {
111744:         LICM licm(graph);
111744:         if (!licm.analyze())
111744:             return false;
112006:         IonSpewPass("LICM");
112755:         AssertGraphCoherency(graph);
111791:     }
111744: 
112912:     if (js_IonOptions.rangeAnalysis) {
112912:         RangeAnalysis rangeAnalysis(graph);
112987:         if (!rangeAnalysis.analyzeLate())
112912:             return false;
112987:         IonSpewPass("Range Analysis (Late)");
112912:         AssertGraphCoherency(graph);
112912:     }
112912: 
111900:     LIRGraph lir(graph);
111962:     LIRGenerator lirgen(&builder, graph, lir);
111706:     if (!lirgen.generate())
111706:         return false;
112006:     IonSpewPass("Generate LIR");
111706: 
111791:     if (js_IonOptions.lsra) {
111763:         LinearScanAllocator regalloc(&lirgen, lir);
111758:         if (!regalloc.go())
111758:             return false;
112006:         IonSpewPass("Allocate Registers", &regalloc);
111791:     } else {
111791:         GreedyAllocator greedy(&builder, lir);
111791:         if (!greedy.allocate())
111791:             return false;
112006:         IonSpewPass("Allocate Registers");
111791:     }
111736: 
111768:     CodeGenerator codegen(&builder, lir);
111768:     if (!codegen.generate())
111768:         return false;
112006:     // No spew: graph not changed.
111768: 
112006:     IonSpewEndFunction();
111732: 
111734:     return true;
111734: }
111734: 
111734: static bool
112219: IonCompile(JSContext *cx, JSScript *script, StackFrame *fp, jsbytecode *osrPc)
111734: {
112097:     TempAllocator temp(&cx->tempLifoAlloc());
111734:     IonContext ictx(cx, &temp);
111734: 
111805:     if (!cx->compartment->ensureIonCompartmentExists(cx))
111805:         return false;
111804: 
112142:     MIRGraph graph(temp);
112042:     JSFunction *fun = fp->isFunctionFrame() ? fp->fun() : NULL;
112219:     CompileInfo *info = cx->tempLifoAlloc().new_<CompileInfo>(script, fun, osrPc);
112142:     if (!info)
112142:         return false;
111734: 
112042:     types::AutoEnterTypeInference enter(cx, true);
112042:     TypeInferenceOracle oracle;
112042: 
112042:     if (!oracle.init(cx, script))
112042:         return false;
112042: 
112447:     types::AutoEnterCompilation enterCompiler(cx, script, false, 0);
113053:     AutoCompilerRoots roots(script->compartment()->rt);
112042: 
112999:     IonBuilder builder(cx, fp->scopeChain(), temp, graph, &oracle, *info);
112247:     if (!TestCompiler(builder, graph)) {
112247:         IonSpew(IonSpew_Abort, "IM Compilation failed.");
111734:         return false;
112247:     }
112988: 
111734:     return true;
111734: }
111734: 
111935: static bool
111935: CheckFrame(StackFrame *fp)
111935: {
111935:     if (fp->isEvalFrame()) {
111935:         // Eval frames are not yet supported. Supporting this will require new
111935:         // logic in pushBailoutFrame to deal with linking prev.
112716:         // Additionally, JSOP_DEFVAR support will require baking in isEvalFrame().
111935:         IonSpew(IonSpew_Abort, "eval frame");
111935:         return false;
111935:     }
111935: 
111935:     if (fp->hasCallObj()) {
111935:         // Functions with call objects aren't supported yet. To support them,
111935:         // we need to fix bug 659577 which would prevent aliasing locals to
111935:         // stack slots.
111935:         IonSpew(IonSpew_Abort, "frame has callobj");
111935:         return false;
111935:     }
111935: 
112979:     if (fp->hasArgsObj() || fp->script()->argumentsHasLocalBinding()) {
111935:         // Functions with arguments objects, or scripts that use arguments, are
111935:         // not supported yet.
111935:         IonSpew(IonSpew_Abort, "frame has argsobj");
111935:         return false;
111935:     }
111935: 
111935:     if (fp->isGeneratorFrame()) {
111935:         // Err... no.
111935:         IonSpew(IonSpew_Abort, "generator frame");
111935:         return false;
111935:     }
111935: 
111935:     if (fp->isDebuggerFrame()) {
111935:         IonSpew(IonSpew_Abort, "debugger frame");
111935:         return false;
111935:     }
111935: 
111935:     // This check is to not overrun the stack. Eventually, we will want to
111935:     // handle this when we support JSOP_ARGUMENTS or function calls.
112425:     if (fp->isFunctionFrame() && fp->numActualArgs() >= SNAPSHOT_MAX_NARGS) {
111935:         IonSpew(IonSpew_Abort, "too many actual args");
111935:         return false;
111935:     }
111935: 
112650:     if (!fp->script()->compileAndGo) {
112650:         IonSpew(IonSpew_Abort, "not compile-and-go");
112650:         return false;
112650:     }
112650: 
112425:     JS_ASSERT_IF(fp->maybeFun(), !fp->fun()->isHeavyweight());
111935:     return true;
111935: }
111935: 
112858: static MethodStatus
112858: Compile(JSContext *cx, JSScript *script, js::StackFrame *fp, jsbytecode *osrPc)
112858: {
112985:     JS_ASSERT(ion::IsEnabled(cx));
112858:     JS_ASSERT_IF(osrPc != NULL, (JSOp)*osrPc == JSOP_LOOPENTRY);
112858: 
112858:     if (cx->compartment->debugMode()) {
112858:         IonSpew(IonSpew_Abort, "debugging");
112858:         return Method_CantCompile;
112858:     }
112858: 
112858:     if (!CheckFrame(fp))
112858:         return Method_CantCompile;
112858: 
112858:     if (script->ion) {
112858:         if (!script->ion->method())
112858:             return Method_CantCompile;
112858:         return Method_Compiled;
112858:     }
112858: 
112858:     if (script->incUseCount() <= js_IonOptions.usesBeforeCompile)
112858:         return Method_Skipped;
112858: 
112858:     if (!IonCompile(cx, script, fp, osrPc))
112858:         return Method_CantCompile;
112858: 
112858:     // Compilation succeeded, but we invalidated right away. 
112858:     return script->hasIonScript() ? Method_Compiled : Method_Skipped;
112858: }
112858: 
112219: // Decide if a transition from interpreter execution to Ion code should occur.
112219: // May compile or recompile the target JSScript.
111792: MethodStatus
112219: ion::CanEnterAtBranch(JSContext *cx, JSScript *script, StackFrame *fp, jsbytecode *pc)
111734: {
112985:     JS_ASSERT(ion::IsEnabled(cx));
112504:     JS_ASSERT((JSOp)*pc == JSOP_LOOPENTRY);
112219: 
112381:     // Skip if the script has been disabled.
112381:     if (script->ion == ION_DISABLED_SCRIPT)
112381:         return Method_Skipped;
112381: 
112381:     // Ignore OSR if the code is expected to result in a bailout.
112381:     if (script->ion && script->ion->isOsrForbidden())
112381:         return Method_Skipped;
112381: 
112219:     // Optionally ignore on user request.
112219:     if (!js_IonOptions.osr)
112219:         return Method_Skipped;
112219: 
112219:     // Attempt compilation. Returns Method_Compiled if already compiled.
112219:     MethodStatus status = Compile(cx, script, fp, pc);
112858:     if (status != Method_Compiled) {
112858:         if (status == Method_CantCompile)
112858:             script->ion = ION_DISABLED_SCRIPT;
112219:         return status;
112858:     }
112219: 
112219:     if (script->ion->osrPc() != pc)
112219:         return Method_Skipped;
112219: 
112858:     // This can GC, so afterward, script->ion is not guaranteed to be valid.
112874:     if (!cx->compartment->ionCompartment()->enterJIT(cx))
112858:         return Method_Error;
112858: 
112858:     if (!script->ion)
112858:         return Method_Skipped;
112858: 
112219:     return Method_Compiled;
112219: }
112219: 
112219: MethodStatus
112959: ion::CanEnter(JSContext *cx, JSScript *script, StackFrame *fp, bool newType)
112219: {
112985:     JS_ASSERT(ion::IsEnabled(cx));
112381: 
112858:     // Skip if the script has been disabled.
112381:     if (script->ion == ION_DISABLED_SCRIPT)
112858:         return Method_Skipped;
112381: 
112959:     // If constructing, allocate a new |this| object before building Ion.
112959:     // Creating |this| is done before building Ion because it may change the
112959:     // type information and invalidate compilation results.
112959:     if (fp->isConstructing() && fp->functionThis().isPrimitive()) {
112984:         RootedVarObject callee(cx, &fp->callee());
112984:         RootedVarObject obj(cx, js_CreateThisForFunction(cx, callee, newType));
112959:         if (!obj)
112959:             return Method_Skipped;
112959:         fp->functionThis().setObject(*obj);
112959:     }
112959: 
112858:     // Attempt compilation. Returns Method_Compiled if already compiled.
112858:     MethodStatus status = Compile(cx, script, fp, NULL);
112858:     if (status != Method_Compiled) {
112858:         if (status == Method_CantCompile)
112858:             script->ion = ION_DISABLED_SCRIPT;
112858:         return status;
112069:     }
112069: 
112858:     // This can GC, so afterward, script->ion is not guaranteed to be valid.
112858:     if (!cx->compartment->ionCompartment()->enterJIT(cx))
112858:         return Method_Error;
112001: 
112858:     if (!script->ion)
112041:         return Method_Skipped;
112041: 
112858:     return Method_Compiled;
111792: }
111792: 
113058: static IonExecStatus
112874: EnterIon(JSContext *cx, StackFrame *fp, void *jitcode)
111792: {
113062:     JS_CHECK_RECURSION(cx, return false);
112985:     JS_ASSERT(ion::IsEnabled(cx));
111935:     JS_ASSERT(CheckFrame(fp));
111792: 
112874:     EnterIonCode enter = cx->compartment->ionCompartment()->enterJITInfallible();
112874: 
111818:     int argc = 0;
111818:     Value *argv = NULL;
111818: 
111934:     void *calleeToken;
111818:     if (fp->isFunctionFrame()) {
112401:         argc = CountArgSlots(fp->fun()) - 1;
111934:         argv = fp->formalArgs() - 1;
112249:         calleeToken = CalleeToToken(fp->callee().toFunction());
111934:     } else {
111934:         calleeToken = CalleeToToken(fp->script());
111792:     }
111792: 
112874:     // Caller must construct |this| before invoking the Ion function.
112874:     JS_ASSERT_IF(fp->isConstructing(), fp->functionThis().isObject());
112874: 
111818:     Value result;
111818:     {
111818:         AssertCompartmentUnchanged pcc(cx);
111935:         IonContext ictx(cx, NULL);
112874:         IonActivation activation(cx, fp);
111818:         JSAutoResolveFlags rf(cx, RESOLVE_INFER);
111935: 
112874:         // Single transition point from Interpreter to Ion.
112874:         enter(jitcode, argc, argv, fp, calleeToken, &result);
113058:     }
112219: 
113058:     if (result.isMagic() && result.whyMagic() == JS_ION_BAILOUT)
113058:         return IonExec_Bailout;
111818: 
111818:     JS_ASSERT(fp == cx->fp());
112756:     JS_ASSERT(!cx->runtime->hasIonReturnOverride());
111818: 
111818:     // The trampoline wrote the return value but did not set the HAS_RVAL flag.
111818:     fp->setReturnValue(result);
112396:     if (fp->isFunctionFrame())
112396:         fp->updateEpilogueFlags();
111818: 
112874:     // Ion callers wrap primitive constructor return.
112874:     if (!result.isMagic() && fp->isConstructing() && fp->returnValue().isPrimitive())
112874:         fp->setReturnValue(ObjectValue(fp->constructorThis()));
112874: 
113058:     JS_ASSERT_IF(result.isMagic(), result.isMagic(JS_ION_ERROR));
113058:     return result.isMagic() ? IonExec_Error : IonExec_Ok;
111818: }
111818: 
113058: IonExecStatus
112959: ion::Cannon(JSContext *cx, StackFrame *fp)
112219: {
112219:     JSScript *script = fp->script();
112219:     IonScript *ion = script->ion;
112219:     IonCode *code = ion->method();
112219:     void *jitcode = code->raw();
112219: 
112874:     return EnterIon(cx, fp, jitcode);
112219: }
112219: 
113058: IonExecStatus
112219: ion::SideCannon(JSContext *cx, StackFrame *fp, jsbytecode *pc)
112219: {
112219:     JSScript *script = fp->script();
112219:     IonScript *ion = script->ion;
112219:     IonCode *code = ion->method();
112219:     void *osrcode = code->raw() + ion->osrEntryOffset();
112219: 
112219:     JS_ASSERT(ion->osrPc() == pc);
112219: 
112874:     return EnterIon(cx, fp, osrcode);
112219: }
112219: 
112310: static void
112964: InvalidateActivation(FreeOp *fop, uint8 *ionTop, bool invalidateAll)
112310: {
112519:     IonSpew(IonSpew_Invalidate, "BEGIN invalidating activation");
112519: 
112310:     size_t frameno = 1;
112310: 
113011:     for (IonFrameIterator it(ionTop); !it.done(); ++it, ++frameno) {
112310:         JS_ASSERT_IF(frameno == 1, it.type() == IonFrame_Exit);
112310: 
112310: #ifdef DEBUG
112310:         switch (it.type()) {
112310:           case IonFrame_Exit:
112310:             IonSpew(IonSpew_Invalidate, "#%d exit frame @ %p", frameno, it.fp());
112310:             break;
112310:           case IonFrame_JS:
112505:           {
112837:             JS_ASSERT(it.isScripted());
112505:             IonSpew(IonSpew_Invalidate, "#%d JS frame @ %p", frameno, it.fp());
112505:             IonSpew(IonSpew_Invalidate, "   token: %p", it.jsFrame()->calleeToken());
112505:             IonSpew(IonSpew_Invalidate, "   script: %p; %s:%d", it.script(),
112310:                     it.script()->filename, it.script()->lineno);
112310:             break;
112505:           }
112310:           case IonFrame_Rectifier:
112310:             IonSpew(IonSpew_Invalidate, "#%d rectifier frame @ %p", frameno, it.fp());
112310:             break;
112507:           case IonFrame_Bailed_Rectifier:
112507:             IonSpew(IonSpew_Invalidate, "#%d bailed rectifier frame @ %p", frameno, it.fp());
112507:             break;
113058:           case IonFrame_Osr:
113058:             IonSpew(IonSpew_Invalidate, "#%d osr frame @ %p", frameno, it.fp());
113058:             break;
112310:           case IonFrame_Entry:
112310:             IonSpew(IonSpew_Invalidate, "#%d entry frame @ %p", frameno, it.fp());
112310:             break;
112310:         }
112505:         IonSpew(IonSpew_Invalidate, "   return address %p", it.returnAddress());
112310: #endif
112310: 
112837:         if (!it.isScripted())
112310:             continue;
112310: 
112519:         // See if the frame has already been invalidated.
112519:         if (it.checkInvalidation())
112519:             continue;
112519: 
112310:         JSScript *script = it.script();
112521:         if (!script->hasIonScript())
112521:             continue;
112521: 
112521:         if (!invalidateAll && !script->ion->invalidated())
112310:             continue;
112310: 
112505:         // This frame needs to be invalidated. We do the following:
112505:         //
112505:         // 1. Determine safepoint that corresponds to the current call.
112505:         // 2. From safepoint, get distance to the OSI-patchable offset.
112505:         // 3. From the IonScript, determine the distance between the
112505:         //    call-patchable offset and the invalidation epilogue.
112505:         // 4. Patch the OSI point with a call-relative to the
112505:         //    invalidation epilogue.
112505:         //
112505:         // The code generator ensures that there's enough space for us
112505:         // to patch in a call-relative operation at each invalidation
112505:         // point.
112505:         //
112505:         // Note: you can't simplify this mechanism to "just patch the
112505:         // instruction immediately after the call" because things may
112505:         // need to move into a well-defined register state (using move
112505:         // instructions after the call) in to capture an appropriate
112505:         // snapshot after the call occurs.
112357: 
112310:         IonSpew(IonSpew_Invalidate, "   ! requires invalidation");
112505:         IonScript *ionScript = script->ion;
112505:         ionScript->incref();
112505:         IonSpew(IonSpew_Invalidate, "   ionScript %p ref %u", (void *) ionScript,
112505:                 unsigned(ionScript->refcount()));
112310: 
112505:         const SafepointIndex *si = ionScript->getSafepointIndex(it.returnAddressToFp());
112505:         IonCode *ionCode = ionScript->method();
112310: 
112656:         ionCode->setInvalidated();
112656: 
112505:         // Write the delta (from the return address offset to the
112505:         // IonScript pointer embedded into the invalidation epilogue)
112505:         // where the safepointed call instruction used to be. We rely on
112505:         // the call sequence causing the safepoint being >= the size of
112505:         // a uint32, which is checked during safepoint index
112505:         // construction.
112505:         CodeLocationLabel dataLabelToMunge(it.returnAddressToFp());
112505:         ptrdiff_t delta = ionScript->invalidateEpilogueDataOffset() -
112505:                           (it.returnAddressToFp() - ionCode->raw());
112505:         Assembler::patchWrite_Imm32(dataLabelToMunge, Imm32(delta));
112310: 
112505:         CodeLocationLabel osiPatchPoint = SafepointReader::InvalidationPatchPoint(ionScript, si);
112505:         CodeLocationLabel invalidateEpilogue(ionCode, ionScript->invalidateEpilogueOffset());
112505: 
112505:         IonSpew(IonSpew_Invalidate, "   -> patching address to call instruction %p",
112505:                 (void *) osiPatchPoint.raw());
112505:         Assembler::patchWrite_NearCall(osiPatchPoint, invalidateEpilogue);
112310:     }
112310: 
112519:     IonSpew(IonSpew_Invalidate, "END invalidating activation");
112310: }
112310: 
112310: void
112964: ion::InvalidateAll(FreeOp *fop, JSCompartment *c)
112521: {
112964:     for (IonActivationIterator iter(fop->runtime()); iter.more(); ++iter) {
112521:         if (iter.activation()->compartment() == c) {
112521:             IonSpew(IonSpew_Invalidate, "Invalidating all frames for GC");
112964:             InvalidateActivation(fop, iter.top(), true);
112521:         }
112521:     }
112521: }
112521: 
112521: void
112964: ion::Invalidate(FreeOp *fop, const Vector<types::RecompileInfo> &invalid, bool resetUses)
112310: {
112400:     // Add an invalidation reference to all invalidated IonScripts to indicate
112400:     // to the traversal which frames have been invalidated.
112399:     for (size_t i = 0; i < invalid.length(); i++) {
112447:         if (invalid[i].script->hasIonScript())
112447:             invalid[i].script->ion->incref();
112310:     }
112310: 
112964:     for (IonActivationIterator iter(fop->runtime()); iter.more(); ++iter)
112964:         InvalidateActivation(fop, iter.top(), false);
112310: 
112399:     // Drop the references added above. If a script was never active, its
112399:     // IonScript will be immediately destroyed. Otherwise, it will be held live
112505:     // until its last invalidated frame is destroyed.
112399:     for (size_t i = 0; i < invalid.length(); i++) {
112447:         if (invalid[i].script->hasIonScript()) {
112964:             invalid[i].script->ion->decref(fop);
112447:             invalid[i].script->ion = NULL;
112310:         }
112399:     }
112437: 
112437:     // Wait for the scripts to get warm again before doing another compile,
112437:     // unless we are recompiling *because* a script got hot.
112437:     if (resetUses) {
112437:         for (size_t i = 0; i < invalid.length(); i++)
112447:             invalid[i].script->resetUseCount();
112437:     }
112399: }
112399: 
112521: void
112964: ion::FinishInvalidation(FreeOp *fop, JSScript *script)
112521: {
112521:     if (!script->hasIonScript())
112521:         return;
112521: 
112521:     /*
112521:      * If this script has Ion code on the stack, invalidation() will return
112521:      * true. In this case we have to wait until destroying it.
112521:      */
112521:     if (!script->ion->invalidated())
112964:         ion::IonScript::Destroy(fop, script->ion);
112521: 
112521:     /* In all cases, NULL out script->ion to avoid re-entry. */
112521:     script->ion = NULL;
112521: }
112521: 
112726: void
112726: ion::MarkFromIon(JSCompartment *comp, Value *vp)
112726: {
112726:     gc::MarkValueUnbarriered(comp->barrierTracer(), vp, "write barrier");
112726: }
112726: 
