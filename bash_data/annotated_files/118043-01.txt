 19246: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 19246: 
 36001: #include "base/basictypes.h"
 36001: 
 80467: /* This must occur *after* layers/PLayers.h to avoid typedefs conflicts. */
 80467: #include "mozilla/Util.h"
 80467: 
 19246: #include "prtypes.h"
 19246: #include "prmem.h"
 35740: #include "prenv.h"
 19246: #include "prclist.h"
 38922: 
 79734: #include "jsfriendapi.h"
 38922: 
 70185: #include "nsPluginHost.h"
 19246: #include "nsNPAPIPlugin.h"
 19246: #include "nsNPAPIPluginInstance.h"
 19246: #include "nsNPAPIPluginStreamListener.h"
101150: #include "nsPluginStreamListenerPeer.h"
 19246: #include "nsIServiceManager.h"
 19246: #include "nsThreadUtils.h"
 94707: #include "mozilla/Preferences.h"
115860: #include "nsPluginInstanceOwner.h"
 19246: 
 19246: #include "nsPluginsDir.h"
 19246: #include "nsPluginSafety.h"
 19246: #include "nsPluginLogging.h"
 19246: 
 19246: #include "nsIJSContextStack.h"
 19246: 
 19246: #include "nsIDOMElement.h"
 19246: #include "nsPIDOMWindow.h"
 19246: #include "nsIDocument.h"
 78254: #include "nsIContent.h"
 19246: #include "nsIScriptGlobalObject.h"
 19246: #include "nsIScriptContext.h"
 78254: #include "nsIUnicodeNormalizer.h"
 19246: #include "nsDOMJSUtils.h"
 19246: #include "nsIPrincipal.h"
 50621: #include "nsWildCard.h"
 78254: #include "nsContentUtils.h"
 19246: 
 19246: #include "nsIXPConnect.h"
 19246: 
 19246: #include "nsIObserverService.h"
 19246: #include <prinrval.h>
 19246: 
 72514: #ifdef MOZ_WIDGET_COCOA
 19246: #include <Carbon/Carbon.h>
 41147: #include <ApplicationServices/ApplicationServices.h>
 41147: #include <OpenGL/OpenGL.h>
 86966: #include "nsCocoaFeatures.h"
 19246: #endif
 19246: 
 19246: // needed for nppdf plugin
103111: #if (MOZ_WIDGET_GTK)
 19246: #include <gdk/gdk.h>
 19246: #include <gdk/gdkx.h>
103111: #if (MOZ_WIDGET_GTK == 2)
 19246: #include "gtk2xtbin.h"
 19246: #endif
103111: #endif
 19246: 
 32955: #ifdef XP_OS2
 32955: #define INCL_DOS
 32955: #define INCL_DOSERRORS
 32955: #include <os2.h>
 32955: #endif
 32955: 
 19246: #include "nsJSNPRuntime.h"
 23571: #include "nsIHttpAuthManager.h"
 23571: #include "nsICookieService.h"
 96781: #include "nsILoadContext.h"
 96781: #include "nsIDocShell.h"
 19246: 
 57925: #include "nsNetUtil.h"
 57925: 
 64576: #include "mozilla/Mutex.h"
 36010: #include "mozilla/PluginLibrary.h"
 36010: using mozilla::PluginLibrary;
 36010: 
 36010: #include "mozilla/PluginPRLibrary.h"
 36010: using mozilla::PluginPRLibrary;
 35802: 
 35893: #include "mozilla/plugins/PluginModuleParent.h"
 35893: using mozilla::plugins::PluginModuleParent;
 35740: 
 43912: #ifdef MOZ_X11
 43912: #include "mozilla/X11Util.h"
 43912: #endif
 43912: 
 62857: #ifdef XP_WIN
 62857: #include <windows.h>
106567: #include "nsWindowsHelpers.h"
115772: #ifdef ACCESSIBILITY
115772: #include "mozilla/a11y/Compatibility.h"
115772: #endif
 62857: #endif
 62857: 
 82142: #ifdef MOZ_WIDGET_ANDROID
 89219: #include <android/log.h>
 89219: #include "android_npapi.h"
 78424: #include "ANPBase.h"
 78424: #include "AndroidBridge.h"
107562: #undef LOG
 78424: #define LOG(args...)  __android_log_print(ANDROID_LOG_INFO, "GeckoPlugins" , ## args)
 78424: #endif
 78424: 
 64576: using namespace mozilla;
 39850: using namespace mozilla::plugins::parent;
 39850: 
 39850: // We should make this const...
 39850: static NPNetscapeFuncs sBrowserFuncs = {
 39850:   sizeof(sBrowserFuncs),
 39850:   (NP_VERSION_MAJOR << 8) + NP_VERSION_MINOR,
 39850:   _geturl,
 39850:   _posturl,
 39850:   _requestread,
 39850:   _newstream,
 39850:   _write,
 39850:   _destroystream,
 39850:   _status,
 39850:   _useragent,
 39850:   _memalloc,
 39850:   _memfree,
 39850:   _memflush,
 39850:   _reloadplugins,
 39850:   _getJavaEnv,
 39850:   _getJavaPeer,
 39850:   _geturlnotify,
 39850:   _posturlnotify,
 39850:   _getvalue,
 39850:   _setvalue,
 39850:   _invalidaterect,
 39850:   _invalidateregion,
 39850:   _forceredraw,
 39850:   _getstringidentifier,
 39850:   _getstringidentifiers,
 39850:   _getintidentifier,
 39850:   _identifierisstring,
 39850:   _utf8fromidentifier,
 39850:   _intfromidentifier,
 39850:   _createobject,
 39850:   _retainobject,
 39850:   _releaseobject,
 39850:   _invoke,
 39850:   _invokeDefault,
 39850:   _evaluate,
 39850:   _getproperty,
 39850:   _setproperty,
 39850:   _removeproperty,
 39850:   _hasproperty,
 39850:   _hasmethod,
 39850:   _releasevariantvalue,
 39850:   _setexception,
 39850:   _pushpopupsenabledstate,
 39850:   _poppopupsenabledstate,
 39850:   _enumerate,
 39850:   _pluginthreadasynccall,
 39850:   _construct,
 39850:   _getvalueforurl,
 39850:   _setvalueforurl,
 39850:   _getauthenticationinfo,
 39850:   _scheduletimer,
 39850:   _unscheduletimer,
 39850:   _popupcontextmenu,
 57157:   _convertpoint,
 57157:   NULL, // handleevent, unimplemented
 57157:   NULL, // unfocusinstance, unimplemented
 93035:   _urlredirectresponse,
 93035:   _initasyncsurface,
 93035:   _finalizeasyncsurface,
 93035:   _setcurrentasyncsurface
 39850: };
 39850: 
106838: static Mutex *sPluginThreadAsyncCallLock = nullptr;
 19246: static PRCList sPendingAsyncCalls = PR_INIT_STATIC_CLIST(&sPendingAsyncCalls);
 19246: 
 19246: // POST/GET stream type
 19246: enum eNPPStreamTypeInternal {
 19246:   eNPPStreamTypeInternal_Get,
 19246:   eNPPStreamTypeInternal_Post
 19246: };
 19246: 
 19246: static NS_DEFINE_IID(kMemoryCID, NS_MEMORY_CID);
 19246: 
118043: PRIntervalTime NS_NotifyBeginPluginCall()
118043: {
118043:   nsNPAPIPluginInstance::BeginPluginCall();
118043:   return PR_IntervalNow();
118043: }
118043: 
 19246: // This function sends a notification using the observer service to any object
 19246: // registered to listen to the "experimental-notify-plugin-call" subject.
 19246: // Each "experimental-notify-plugin-call" notification carries with it the run
 19246: // time value in milliseconds that the call took to execute.
 19246: void NS_NotifyPluginCall(PRIntervalTime startTime) 
 19246: {
118043:   nsNPAPIPluginInstance::EndPluginCall();
118043: 
 19246:   PRIntervalTime endTime = PR_IntervalNow() - startTime;
 19246:   nsCOMPtr<nsIObserverService> notifyUIService =
 41540:     mozilla::services::GetObserverService();
 28733:   if (!notifyUIService)
 28733:     return;
 28733: 
 19246:   float runTimeInSeconds = float(endTime) / PR_TicksPerSecond();
 19246:   nsAutoString runTimeString;
 19246:   runTimeString.AppendFloat(runTimeInSeconds);
 19246:   const PRUnichar* runTime = runTimeString.get();
106838:   notifyUIService->NotifyObservers(nullptr, "experimental-notify-plugin-call",
 19246:                                    runTime);
 19246: }
 19246: 
 40564: static void CheckClassInitialized()
 19246: {
 79445:   static bool initialized = false;
 19246: 
 19246:   if (initialized)
 19246:     return;
 19246: 
 20125:   if (!sPluginThreadAsyncCallLock)
 64576:     sPluginThreadAsyncCallLock = new Mutex("nsNPAPIPlugin.sPluginThreadAsyncCallLock");
 19246: 
 79533:   initialized = true;
 19246: 
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,("NPN callbacks initialized\n"));
 19246: }
 19246: 
 69716: NS_IMPL_ISUPPORTS0(nsNPAPIPlugin)
 19246: 
 40564: nsNPAPIPlugin::nsNPAPIPlugin()
 19246: {
 37780:   memset((void*)&mPluginFuncs, 0, sizeof(mPluginFuncs));
 37780:   mPluginFuncs.size = sizeof(mPluginFuncs);
 58535:   mPluginFuncs.version = (NP_VERSION_MAJOR << 8) | NP_VERSION_MINOR;
 40564: 
106838:   mLibrary = nullptr;
 19246: }
 19246: 
 30212: nsNPAPIPlugin::~nsNPAPIPlugin()
 19246: {
 37780:   delete mLibrary;
106838:   mLibrary = nullptr;
 19246: }
 19246: 
 36304: void
 39794: nsNPAPIPlugin::PluginCrashed(const nsAString& pluginDumpID,
 39794:                              const nsAString& browserDumpID)
 36304: {
 36304:   nsRefPtr<nsPluginHost> host = dont_AddRef(nsPluginHost::GetInst());
 39794:   host->PluginCrashed(this, pluginDumpID, browserDumpID);
 36304: }
 35811: 
 79445: bool
 54127: nsNPAPIPlugin::RunPluginOOP(const nsPluginTag *aPluginTag)
 35811: {
 35811:   if (PR_GetEnv("MOZ_DISABLE_OOP_PLUGINS")) {
 79533:     return false;
 35811:   }
 35811: 
 55878:   if (!aPluginTag) {
 79533:     return false;
 55878:   }
 55878: 
115772: #ifdef ACCESSIBILITY
115772:   // Certain assistive technologies don't want oop Flash, thus we have a special
115772:   // pref for them to disable oop Flash (refer to bug 785047 for details).
115772:   bool useA11yPref = false;
103457: #ifdef XP_WIN
115772:   useA11yPref =  a11y::Compatibility::IsJAWS();
116096: #endif
116096: #endif
116096: 
116096: #ifdef XP_WIN
103457:   // On Windows Vista+, we force Flash to run in OOPP mode because Adobe
103457:   // doesn't test Flash in-process and there are known stability bugs.
103457:   if (aPluginTag->mIsFlashPlugin && IsVistaOrLater()) {
115772: #ifdef ACCESSIBILITY
115772:     if (!useA11yPref)
103457:       return true;
115772: #else
115772:     return true;
115772: #endif
103457:   }
103457: #endif
103457: 
 94707:   nsIPrefBranch* prefs = Preferences::GetRootBranch();
 37609:   if (!prefs) {
 79533:     return false;
 37609:   }
 37609: 
 37609:   // Get per-library whitelist/blacklist pref string
 37609:   // "dom.ipc.plugins.enabled.filename.dll" and fall back to the default value
 37609:   // of "dom.ipc.plugins.enabled"
 50621:   // The "filename.dll" part can contain shell wildcard pattern
 50621: 
110974:   nsAutoCString prefFile(aPluginTag->mFullPath.get());
108991:   int32_t slashPos = prefFile.RFindCharInSet("/\\");
 37609:   if (kNotFound == slashPos)
 79533:     return false;
 50621:   prefFile.Cut(0, slashPos + 1);
 50621:   ToLowerCase(prefFile);
 50621: 
 54674: #ifdef XP_MACOSX
 54674: #if defined(__i386__)
110974:   nsAutoCString prefGroupKey("dom.ipc.plugins.enabled.i386.");
 54674: #elif defined(__x86_64__)
110974:   nsAutoCString prefGroupKey("dom.ipc.plugins.enabled.x86_64.");
 54674: #elif defined(__ppc__)
110974:   nsAutoCString prefGroupKey("dom.ipc.plugins.enabled.ppc.");
 54674: #endif
 54674: #else
110974:   nsAutoCString prefGroupKey("dom.ipc.plugins.enabled.");
 54674: #endif
 50621: 
115772: #ifdef ACCESSIBILITY
115772:   if (useA11yPref)
115772:     prefGroupKey.AssignLiteral("dom.ipc.plugins.enabled.a11y.");
115772: #endif
115772: 
 55878:   // Java plugins include a number of different file names,
 55878:   // so use the mime type (mIsJavaPlugin) and a special pref.
 55878:   if (aPluginTag->mIsJavaPlugin &&
 94707:       !Preferences::GetBool("dom.ipc.plugins.java.enabled", true)) {
 79533:     return false;
 55878:   }
 55878: 
108991:   uint32_t prefCount;
 50621:   char** prefNames;
 50621:   nsresult rv = prefs->GetChildList(prefGroupKey.get(),
 50621:                                     &prefCount, &prefNames);
 37609: 
 79445:   bool oopPluginsEnabled = false;
 79445:   bool prefSet = false;
 50621: 
 50621:   if (NS_SUCCEEDED(rv) && prefCount > 0) {
108991:     uint32_t prefixLength = prefGroupKey.Length();
108991:     for (uint32_t currentPref = 0; currentPref < prefCount; currentPref++) {
 50621:       // Get the mask
 50621:       const char* maskStart = prefNames[currentPref] + prefixLength;
 79445:       bool match = false;
 50621: 
 50621:       int valid = NS_WildCardValid(maskStart);
 50621:       if (valid == INVALID_SXP) {
 50621:          continue;
 50621:       }
 50621:       else if(valid == NON_SXP) {
 50621:         // mask is not a shell pattern, compare it as normal string
 50621:         match = (strcmp(prefFile.get(), maskStart) == 0);
 50621:       }
 50621:       else {
 50621:         match = (NS_WildCardMatch(prefFile.get(), maskStart, 0) == MATCH);
 50621:       }
 50621: 
 94707:       if (match && NS_SUCCEEDED(Preferences::GetBool(prefNames[currentPref],
 50621:                                                      &oopPluginsEnabled))) {
 79533:         prefSet = true;
 50621:         break;
 50621:       }
 50621:     }
 50621:     NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(prefCount, prefNames);
 50621:   }
 50621: 
 50621:   if (!prefSet) {
 94707:     oopPluginsEnabled =
 54674: #ifdef XP_MACOSX
 54674: #if defined(__i386__)
 94707:     Preferences::GetBool("dom.ipc.plugins.enabled.i386", false);
 54674: #elif defined(__x86_64__)
 94707:     Preferences::GetBool("dom.ipc.plugins.enabled.x86_64", false);
 54674: #elif defined(__ppc__)
 94707:     Preferences::GetBool("dom.ipc.plugins.enabled.ppc", false);
 54674: #endif
 54674: #else
115772: #ifdef ACCESSIBILITY
115772:     useA11yPref ? Preferences::GetBool("dom.ipc.plugins.enabled.a11y", false) :
115772: #endif
 94707:     Preferences::GetBool("dom.ipc.plugins.enabled", false);
 54674: #endif
 50621:   }
 50621: 
 37609:   return oopPluginsEnabled;
 35811: }
 35811: 
 36010: inline PluginLibrary*
 54127: GetNewPluginLibrary(nsPluginTag *aPluginTag)
 35811: {
 54127:   if (!aPluginTag) {
106838:     return nullptr;
 54127:   }
 54127: 
 54127:   if (nsNPAPIPlugin::RunPluginOOP(aPluginTag)) {
 64609:     return PluginModuleParent::LoadModule(aPluginTag->mFullPath.get());
 40216:   }
 64609:   return new PluginPRLibrary(aPluginTag->mFullPath.get(), aPluginTag->mLibrary);
 35811: }
 35811: 
 40564: // Creates an nsNPAPIPlugin object. One nsNPAPIPlugin object exists per plugin (not instance).
 19246: nsresult
 62174: nsNPAPIPlugin::CreatePlugin(nsPluginTag *aPluginTag, nsNPAPIPlugin** aResult)
 19246: {
106838:   *aResult = nullptr;
 40564: 
 54127:   if (!aPluginTag) {
 50781:     return NS_ERROR_FAILURE;
 50781:   }
 50781: 
 19246:   CheckClassInitialized();
 19246: 
 40564:   nsRefPtr<nsNPAPIPlugin> plugin = new nsNPAPIPlugin();
 40564:   if (!plugin)
 40564:     return NS_ERROR_OUT_OF_MEMORY;
 19246: 
 54127:   PluginLibrary* pluginLib = GetNewPluginLibrary(aPluginTag);
 40564:   if (!pluginLib) {
 19246:     return NS_ERROR_FAILURE;
 19246:   }
 19246: 
 82142: #if defined(XP_MACOSX) || defined(MOZ_WIDGET_ANDROID)
 40564:   if (!pluginLib->HasRequiredFunctions()) {
 40564:     NS_WARNING("Not all necessary functions exposed by plugin, it will not load.");
 19246:     return NS_ERROR_FAILURE;
 19246:   }
 40564: #endif
 40564: 
 40564:   plugin->mLibrary = pluginLib;
 40564:   pluginLib->SetPlugin(plugin);
 40564: 
 40564:   NPError pluginCallError;
 40564:   nsresult rv;
 40564: 
 40564: // Exchange NPAPI entry points.
 40564: #if defined(XP_WIN) || defined(XP_OS2)
 40564:   // NP_GetEntryPoints must be called before NP_Initialize on Windows.
 40564:   rv = pluginLib->NP_GetEntryPoints(&plugin->mPluginFuncs, &pluginCallError);
 40564:   if (rv != NS_OK || pluginCallError != NPERR_NO_ERROR) {
 19246:     return NS_ERROR_FAILURE;
 19246:   }
 22811: 
 40564:   // NP_Initialize must be called after NP_GetEntryPoints on Windows.
 40564:   rv = pluginLib->NP_Initialize(&sBrowserFuncs, &pluginCallError);
 40564:   if (rv != NS_OK || pluginCallError != NPERR_NO_ERROR) {
 40564:     return NS_ERROR_FAILURE;
 40564:   }
 40564: #elif defined(XP_MACOSX)
 40564:   // NP_Initialize must be called before NP_GetEntryPoints on Mac OS X.
 40564:   // We need to match WebKit's behavior.
 40564:   rv = pluginLib->NP_Initialize(&sBrowserFuncs, &pluginCallError);
 40564:   if (rv != NS_OK || pluginCallError != NPERR_NO_ERROR) {
 40564:     return NS_ERROR_FAILURE;
 40564:   }
 40564: 
 40564:   rv = pluginLib->NP_GetEntryPoints(&plugin->mPluginFuncs, &pluginCallError);
 40564:   if (rv != NS_OK || pluginCallError != NPERR_NO_ERROR) {
 40564:     return NS_ERROR_FAILURE;
 40564:   }
 82142: #elif defined(MOZ_WIDGET_GONK)
 40564: #else
 40564:   rv = pluginLib->NP_Initialize(&sBrowserFuncs, &plugin->mPluginFuncs, &pluginCallError);
 40564:   if (rv != NS_OK || pluginCallError != NPERR_NO_ERROR) {
 40564:     return NS_ERROR_FAILURE;
 40564:   }
 19246: #endif
 40564: 
 40564:   *aResult = plugin.forget().get();
 19246:   return NS_OK;
 19246: }
 19246: 
 47965: PluginLibrary*
 47965: nsNPAPIPlugin::GetLibrary()
 47965: {
 47965:   return mLibrary;
 47965: }
 47965: 
 47965: NPPluginFuncs*
 47965: nsNPAPIPlugin::PluginFuncs()
 47965: {
 47965:   return &mPluginFuncs;
 47965: }
 47965: 
 69716: nsresult
 37780: nsNPAPIPlugin::Shutdown()
 19246: {
 19246:   NPP_PLUGIN_LOG(PLUGIN_LOG_BASIC,
 19246:                  ("NPP Shutdown to be called: this=%p\n", this));
 19246: 
 36010:   NPError shutdownError;
 37780:   mLibrary->NP_Shutdown(&shutdownError);
 69090: 
 19246:   return NS_OK;
 19246: }
 19246: 
 80593: nsresult
 80593: nsNPAPIPlugin::RetainStream(NPStream *pstream, nsISupports **aRetainedPeer)
 80593: {
 80593:   if (!aRetainedPeer)
 80593:     return NS_ERROR_NULL_POINTER;
 80593: 
 80593:   *aRetainedPeer = NULL;
 80593: 
 80593:   if (!pstream || !pstream->ndata)
106974:     return NS_ERROR_NULL_POINTER;
 80593: 
 98780:   nsNPAPIStreamWrapper* streamWrapper = static_cast<nsNPAPIStreamWrapper*>(pstream->ndata);
 98780:   nsNPAPIPluginStreamListener* listener = streamWrapper->GetStreamListener();
 98780:   if (!listener) {
106974:     return NS_ERROR_NULL_POINTER;
 98780:   }
 98780: 
101150:   nsIStreamListener* streamListener = listener->GetStreamListenerPeer();
101150:   if (!streamListener) {
106974:     return NS_ERROR_NULL_POINTER;
101150:   }
101150: 
101150:   *aRetainedPeer = streamListener;
 80593:   NS_ADDREF(*aRetainedPeer);
 80593:   return NS_OK;
 80593: }
 80593: 
 19246: // Create a new NPP GET or POST (given in the type argument) url
 19246: // stream that may have a notify callback
 19246: NPError
 19246: MakeNewNPAPIStreamInternal(NPP npp, const char *relativeURL, const char *target,
 19246:                           eNPPStreamTypeInternal type,
 79445:                           bool bDoNotify = false,
106838:                           void *notifyData = nullptr, uint32_t len = 0,
106838:                           const char *buf = nullptr, NPBool file = false)
 19246: {
 19246:   if (!npp)
 19246:     return NPERR_INVALID_INSTANCE_ERROR;
 19246: 
 19246:   PluginDestructionGuard guard(npp);
 19246: 
 39211:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *) npp->ndata;
 39211:   if (!inst || !inst->IsRunning())
 19246:     return NPERR_INVALID_INSTANCE_ERROR;
 19246: 
 70185:   nsCOMPtr<nsIPluginHost> pluginHostCOM = do_GetService(MOZ_PLUGIN_HOST_CONTRACTID);
 70185:   nsPluginHost *pluginHost = static_cast<nsPluginHost*>(pluginHostCOM.get());
 70185:   if (!pluginHost) {
 70185:     return NPERR_GENERIC_ERROR;
 70185:   }
 19246: 
 98780:   nsRefPtr<nsNPAPIPluginStreamListener> listener;
 55320:   // Set aCallNotify here to false.  If pluginHost->GetURL or PostURL fail,
 55320:   // the listener's destructor will do the notification while we are about to
 55320:   // return a failure code.
 60021:   // Call SetCallNotify(true) below after we are sure we cannot return a failure 
 55320:   // code.
 60021:   if (!target) {
 60021:     inst->NewStreamListener(relativeURL, notifyData,
 60021:                             getter_AddRefs(listener));
 60021:     if (listener) {
 98780:       listener->SetCallNotify(false);
 60021:     }
 60021:   }
 19246: 
 19246:   switch (type) {
 19246:   case eNPPStreamTypeInternal_Get:
 19246:     {
 67851:       if (NS_FAILED(pluginHost->GetURL(inst, relativeURL, target, listener,
 67851:                                        NULL, NULL, false)))
 19246:         return NPERR_GENERIC_ERROR;
 19246:       break;
 19246:     }
 19246:   case eNPPStreamTypeInternal_Post:
 19246:     {
 67851:       if (NS_FAILED(pluginHost->PostURL(inst, relativeURL, len, buf, file, target, listener, NULL, NULL, false, 0, NULL)))
 19246:         return NPERR_GENERIC_ERROR;
 19246:       break;
 19246:     }
 19246:   default:
 31561:     NS_ERROR("how'd I get here");
 19246:   }
 19246: 
 55320:   if (listener) {
 55320:     // SetCallNotify(bDoNotify) here, see comment above.
 98780:     listener->SetCallNotify(bDoNotify);
 55320:   }
 55320: 
 19246:   return NPERR_NO_ERROR;
 19246: }
 19246: 
 69691: #if defined(MOZ_MEMORY_WINDOWS)
 36125: extern "C" size_t malloc_usable_size(const void *ptr);
 36125: #endif
 36125: 
 36125: namespace {
 36125: 
 36125: static char *gNPPException;
 36125: 
 36125: class nsPluginThreadRunnable : public nsRunnable,
 36125:                                public PRCList
 36125: {
 36125: public:
 36125:   nsPluginThreadRunnable(NPP instance, PluginThreadCallback func,
 36125:                          void *userData);
 36125:   virtual ~nsPluginThreadRunnable();
 36125: 
 36125:   NS_IMETHOD Run();
 36125: 
 79445:   bool IsForInstance(NPP instance)
 36125:   {
 36125:     return (mInstance == instance);
 36125:   }
 36125: 
 36125:   void Invalidate()
 36125:   {
106838:     mFunc = nullptr;
 36125:   }
 36125: 
 79445:   bool IsValid()
 36125:   {
106838:     return (mFunc != nullptr);
 36125:   }
 36125: 
 36125: private:  
 36125:   NPP mInstance;
 36125:   PluginThreadCallback mFunc;
 36125:   void *mUserData;
 36125: };
 36125: 
 36125: static nsIDocument *
 36125: GetDocumentFromNPP(NPP npp)
 36125: {
106838:   NS_ENSURE_TRUE(npp, nullptr);
 36125: 
 36125:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)npp->ndata;
106838:   NS_ENSURE_TRUE(inst, nullptr);
 36125: 
 36125:   PluginDestructionGuard guard(inst);
 36125: 
115860:   nsRefPtr<nsPluginInstanceOwner> owner = inst->GetOwner();
106838:   NS_ENSURE_TRUE(owner, nullptr);
 36125: 
 36125:   nsCOMPtr<nsIDocument> doc;
 36125:   owner->GetDocument(getter_AddRefs(doc));
 36125: 
 36125:   return doc;
 36125: }
 36125: 
 36125: static JSContext *
 36125: GetJSContextFromDoc(nsIDocument *doc)
 36125: {
 36125:   nsIScriptGlobalObject *sgo = doc->GetScriptGlobalObject();
106838:   NS_ENSURE_TRUE(sgo, nullptr);
 36125: 
 36125:   nsIScriptContext *scx = sgo->GetContext();
106838:   NS_ENSURE_TRUE(scx, nullptr);
 36125: 
 78415:   return scx->GetNativeContext();
 36125: }
 36125: 
 36125: static JSContext *
 36125: GetJSContextFromNPP(NPP npp)
 36125: {
 36125:   nsIDocument *doc = GetDocumentFromNPP(npp);
106838:   NS_ENSURE_TRUE(doc, nullptr);
 36125: 
 36125:   return GetJSContextFromDoc(doc);
 36125: }
 36125: 
 36125: static NPIdentifier
 36125: doGetIdentifier(JSContext *cx, const NPUTF8* name)
 36125: {
 36125:   NS_ConvertUTF8toUTF16 utf16name(name);
 36125: 
 36125:   JSString *str = ::JS_InternUCStringN(cx, (jschar *)utf16name.get(),
 36125:                                        utf16name.Length());
 36125: 
 36125:   if (!str)
 36125:     return NULL;
 36125: 
 70270:   return StringToNPIdentifier(cx, str);
 36125: }
 36125: 
 69691: #if defined(MOZ_MEMORY_WINDOWS)
 36125: BOOL
 36125: InHeap(HANDLE hHeap, LPVOID lpMem)
 36125: {
 36125:   BOOL success = FALSE;
 36125:   PROCESS_HEAP_ENTRY he;
 36125:   he.lpData = NULL;
 36125:   while (HeapWalk(hHeap, &he) != 0) {
 36125:     if (he.lpData == lpMem) {
 36125:       success = TRUE;
 36125:       break;
 36125:     }
 36125:   }
 36125:   HeapUnlock(hHeap);
 36125:   return success;
 36125: }
 36125: #endif
 36125: 
 36125: } /* anonymous namespace */
 36125: 
 36125: NPPExceptionAutoHolder::NPPExceptionAutoHolder()
 36125:   : mOldException(gNPPException)
 36125: {
106838:   gNPPException = nullptr;
 36125: }
 36125: 
 36125: NPPExceptionAutoHolder::~NPPExceptionAutoHolder()
 36125: {
 36125:   NS_ASSERTION(!gNPPException, "NPP exception not properly cleared!");
 36125: 
 36125:   gNPPException = mOldException;
 36125: }
 36125: 
 36125: nsPluginThreadRunnable::nsPluginThreadRunnable(NPP instance,
 36125:                                                PluginThreadCallback func,
 36125:                                                void *userData)
 36125:   : mInstance(instance), mFunc(func), mUserData(userData)
 36125: {
 36125:   if (!sPluginThreadAsyncCallLock) {
 36125:     // Failed to create lock, not much we can do here then...
106838:     mFunc = nullptr;
 36125: 
 36125:     return;
 36125:   }
 36125: 
 36125:   PR_INIT_CLIST(this);
 36125: 
 36125:   {
 64576:     MutexAutoLock lock(*sPluginThreadAsyncCallLock);
 36125: 
 36125:     nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)instance->ndata;
 36355:     if (!inst || !inst->IsRunning()) {
 36125:       // The plugin was stopped, ignore this async call.
106838:       mFunc = nullptr;
 36125: 
 36125:       return;
 36125:     }
 36125: 
 36125:     PR_APPEND_LINK(this, &sPendingAsyncCalls);
 36125:   }
 36125: }
 36125: 
 36125: nsPluginThreadRunnable::~nsPluginThreadRunnable()
 36125: {
 36125:   if (!sPluginThreadAsyncCallLock) {
 36125:     return;
 36125:   }
 36125: 
 36125:   {
 64576:     MutexAutoLock lock(*sPluginThreadAsyncCallLock);
 36125: 
 36125:     PR_REMOVE_LINK(this);
 36125:   }
 36125: }
 36125: 
 36125: NS_IMETHODIMP
 36125: nsPluginThreadRunnable::Run()
 36125: {
 36125:   if (mFunc) {
 36125:     PluginDestructionGuard guard(mInstance);
 36125: 
106838:     NS_TRY_SAFE_CALL_VOID(mFunc(mUserData), nullptr);
 36125:   }
 36125: 
 36125:   return NS_OK;
 36125: }
 36125: 
 36125: void
 36125: OnPluginDestroy(NPP instance)
 36125: {
 36125:   if (!sPluginThreadAsyncCallLock) {
 36125:     return;
 36125:   }
 36125: 
 36125:   {
 64576:     MutexAutoLock lock(*sPluginThreadAsyncCallLock);
 36125: 
 36125:     if (PR_CLIST_IS_EMPTY(&sPendingAsyncCalls)) {
 36125:       return;
 36125:     }
 36125: 
 36125:     nsPluginThreadRunnable *r =
 36125:       (nsPluginThreadRunnable *)PR_LIST_HEAD(&sPendingAsyncCalls);
 36125: 
 36125:     do {
 36125:       if (r->IsForInstance(instance)) {
 36125:         r->Invalidate();
 36125:       }
 36125: 
 36125:       r = (nsPluginThreadRunnable *)PR_NEXT_LINK(r);
 36125:     } while (r != &sPendingAsyncCalls);
 36125:   }
 36125: }
 36125: 
 36125: void
 36125: OnShutdown()
 36125: {
 36125:   NS_ASSERTION(PR_CLIST_IS_EMPTY(&sPendingAsyncCalls),
 36125:                "Pending async plugin call list not cleaned up!");
 36125: 
 36125:   if (sPluginThreadAsyncCallLock) {
 64576:     delete sPluginThreadAsyncCallLock;
 36125: 
106838:     sPluginThreadAsyncCallLock = nullptr;
 36125:   }
 36125: }
 36125: 
 64576: AsyncCallbackAutoLock::AsyncCallbackAutoLock()
 36125: {
 67793:   if (sPluginThreadAsyncCallLock) {
 64576:     sPluginThreadAsyncCallLock->Lock();
 36125:   }
 67793: }
 64576: 
 64576: AsyncCallbackAutoLock::~AsyncCallbackAutoLock()
 64576: {
 67793:   if (sPluginThreadAsyncCallLock) {
 64576:     sPluginThreadAsyncCallLock->Unlock();
 64568:   }
 67793: }
 64568: 
 36125: 
106838: NPP NPPStack::sCurrentNPP = nullptr;
 36125: 
 36125: const char *
 36125: PeekException()
 36125: {
 36125:   return gNPPException;
 36125: }
 36125: 
 36125: void
 36125: PopException()
 36125: {
 36125:   NS_ASSERTION(gNPPException, "Uh, no NPP exception to pop!");
 36125: 
 36125:   if (gNPPException) {
 36125:     free(gNPPException);
 36125: 
106838:     gNPPException = nullptr;
 36125:   }
 36125: }
 36125: 
 19246: //
 19246: // Static callbacks that get routed back through the new C++ API
 19246: //
 19246: 
 36125: namespace mozilla {
 36125: namespace plugins {
 36125: namespace parent {
 36125: 
 19246: NPError NP_CALLBACK
 19246: _geturl(NPP npp, const char* relativeURL, const char* target)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_geturl called from the wrong thread\n"));
 19246:     return NPERR_INVALID_PARAM;
 19246:   }
 19246: 
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
 19246:   ("NPN_GetURL: npp=%p, target=%s, url=%s\n", (void *)npp, target,
 19246:    relativeURL));
 19246: 
 19246:   PluginDestructionGuard guard(npp);
 19246: 
 19246:   // Block Adobe Acrobat from loading URLs that are not http:, https:,
 19246:   // or ftp: URLs if the given target is null.
 21231:   if (!target && relativeURL &&
 19246:       (strncmp(relativeURL, "http:", 5) != 0) &&
 19246:       (strncmp(relativeURL, "https:", 6) != 0) &&
 19246:       (strncmp(relativeURL, "ftp:", 4) != 0)) {
 19246:     nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *) npp->ndata;
 19246: 
 37525:     
106838:     const char *name = nullptr;
 37525:     nsRefPtr<nsPluginHost> host = dont_AddRef(nsPluginHost::GetInst());
 37525:     host->GetPluginName(inst, &name);
 19246: 
 19246:     if (name && strstr(name, "Adobe") && strstr(name, "Acrobat")) {
 19246:       return NPERR_NO_ERROR;
 19246:     }
 19246:   }
 19246: 
 19246:   return MakeNewNPAPIStreamInternal(npp, relativeURL, target,
 19246:                                     eNPPStreamTypeInternal_Get);
 19246: }
 19246: 
 19246: NPError NP_CALLBACK
 19246: _geturlnotify(NPP npp, const char* relativeURL, const char* target,
 19246:               void* notifyData)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_geturlnotify called from the wrong thread\n"));
 19246:     return NPERR_INVALID_PARAM;
 19246:   }
 19246: 
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
 19246:     ("NPN_GetURLNotify: npp=%p, target=%s, notify=%p, url=%s\n", (void*)npp,
 19246:      target, notifyData, relativeURL));
 19246: 
 19246:   PluginDestructionGuard guard(npp);
 19246: 
 19246:   return MakeNewNPAPIStreamInternal(npp, relativeURL, target,
 79533:                                     eNPPStreamTypeInternal_Get, true,
 19246:                                     notifyData);
 19246: }
 19246: 
 19246: NPError NP_CALLBACK
 19246: _posturlnotify(NPP npp, const char *relativeURL, const char *target,
 19246:                uint32_t len, const char *buf, NPBool file, void *notifyData)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_posturlnotify called from the wrong thread\n"));
 19246:     return NPERR_INVALID_PARAM;
 19246:   }
 36110:   if (!buf)
 36110:     return NPERR_INVALID_PARAM;
 36110: 
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
 19246:                  ("NPN_PostURLNotify: npp=%p, target=%s, len=%d, file=%d, "
 19246:                   "notify=%p, url=%s, buf=%s\n",
 19246:                   (void*)npp, target, len, file, notifyData, relativeURL,
 19246:                   buf));
 19246: 
 19246:   PluginDestructionGuard guard(npp);
 19246: 
 19246:   return MakeNewNPAPIStreamInternal(npp, relativeURL, target,
 79533:                                     eNPPStreamTypeInternal_Post, true,
 19246:                                     notifyData, len, buf, file);
 19246: }
 19246: 
 19246: NPError NP_CALLBACK
 19246: _posturl(NPP npp, const char *relativeURL, const char *target,
 19246:          uint32_t len, const char *buf, NPBool file)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_posturl called from the wrong thread\n"));
 19246:     return NPERR_INVALID_PARAM;
 19246:   }
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
 19246:                  ("NPN_PostURL: npp=%p, target=%s, file=%d, len=%d, url=%s, "
 19246:                   "buf=%s\n",
 19246:                   (void*)npp, target, file, len, relativeURL, buf));
 19246: 
 19246:   PluginDestructionGuard guard(npp);
 19246: 
 19246:   return MakeNewNPAPIStreamInternal(npp, relativeURL, target,
106838:                                     eNPPStreamTypeInternal_Post, false, nullptr,
 19246:                                     len, buf, file);
 19246: }
 19246: 
 19246: NPError NP_CALLBACK
 19246: _newstream(NPP npp, NPMIMEType type, const char* target, NPStream* *result)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_newstream called from the wrong thread\n"));
 19246:     return NPERR_INVALID_PARAM;
 19246:   }
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
 19246:   ("NPN_NewStream: npp=%p, type=%s, target=%s\n", (void*)npp,
 19246:    (const char *)type, target));
 19246: 
 19246:   NPError err = NPERR_INVALID_INSTANCE_ERROR;
 19246:   if (npp && npp->ndata) {
 70007:     nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance*)npp->ndata;
 19246: 
 19246:     PluginDestructionGuard guard(inst);
 19246: 
 19246:     nsCOMPtr<nsIOutputStream> stream;
 29834:     if (NS_SUCCEEDED(inst->NewStreamFromPlugin((const char*) type, target,
 19246:                                                getter_AddRefs(stream)))) {
106838:       nsNPAPIStreamWrapper* wrapper = new nsNPAPIStreamWrapper(stream, nullptr);
 19246:       if (wrapper) {
 98780:         (*result) = &wrapper->mNPStream;
 19246:         err = NPERR_NO_ERROR;
 19246:       } else {
 19246:         err = NPERR_OUT_OF_MEMORY_ERROR;
 19246:       }
 19246:     } else {
 19246:       err = NPERR_GENERIC_ERROR;
 19246:     }
 19246:   }
 19246:   return err;
 19246: }
 19246: 
 19246: int32_t NP_CALLBACK
 19246: _write(NPP npp, NPStream *pstream, int32_t len, void *buffer)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_write called from the wrong thread\n"));
 19246:     return 0;
 19246:   }
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
 19246:                  ("NPN_Write: npp=%p, url=%s, len=%d, buffer=%s\n", (void*)npp,
 19246:                   pstream->url, len, (char*)buffer));
 19246: 
 19246:   // negative return indicates failure to the plugin
 19246:   if (!npp)
 19246:     return -1;
 19246: 
 19246:   PluginDestructionGuard guard(npp);
 19246: 
 98780:   nsNPAPIStreamWrapper* wrapper = static_cast<nsNPAPIStreamWrapper*>(pstream->ndata);
 98780:   if (!wrapper) {
 19246:     return -1;
 98780:   }
 98780: 
 98780:   nsIOutputStream* stream = wrapper->GetOutputStream();
 98780:   if (!stream) {
 98780:     return -1;
 98780:   }
 19246: 
108991:   uint32_t count = 0;
 19246:   nsresult rv = stream->Write((char *)buffer, len, &count);
 98780: 
 98780:   if (NS_FAILED(rv)) {
 19246:     return -1;
 98780:   }
 19246: 
 19246:   return (int32_t)count;
 19246: }
 19246: 
 19246: NPError NP_CALLBACK
 19246: _destroystream(NPP npp, NPStream *pstream, NPError reason)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_write called from the wrong thread\n"));
 19246:     return NPERR_INVALID_PARAM;
 19246:   }
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
 19246:                  ("NPN_DestroyStream: npp=%p, url=%s, reason=%d\n", (void*)npp,
 19246:                   pstream->url, (int)reason));
 19246: 
 19246:   if (!npp)
 19246:     return NPERR_INVALID_INSTANCE_ERROR;
 19246: 
 19246:   PluginDestructionGuard guard(npp);
 19246: 
 98780:   nsNPAPIStreamWrapper *streamWrapper = static_cast<nsNPAPIStreamWrapper*>(pstream->ndata);
 98780:   if (!streamWrapper) {
 98780:     return NPERR_INVALID_PARAM;
 98780:   }
 19246: 
 98940:   nsNPAPIPluginStreamListener *listener = streamWrapper->GetStreamListener();
 19246:   if (listener) {
 98940:     // This type of stream is going from the browser to the plugin. It's either the
 98940:     // initial src/data stream or another stream resulting from NPN_GetURL* or
 98940:     // NPN_PostURL*.
 98940:     //
 98940:     // Calling OnStopBinding on the listener may cause it to be deleted due to the
 98940:     // releasing of its last references.
106838:     listener->OnStopBinding(nullptr, NS_BINDING_ABORTED);
 19246:   } else {
 98940:     // This type of stream (NPStream) was created via NPN_NewStream. The plugin holds
 98940:     // the reference until it is to be deleted here. Deleting the wrapper will
 98940:     // release the wrapped nsIOutputStream.
 98940:     // 
 98940:     // The NPStream the plugin references should always be a sub-object of it's own
 98940:     // 'ndata', which is our nsNPAPIStramWrapper. See bug 548441.
 98780:     NS_ASSERTION((char*)streamWrapper <= (char*)pstream && 
 39166:                  ((char*)pstream) + sizeof(*pstream)
 98780:                      <= ((char*)streamWrapper) + sizeof(*streamWrapper),
 39166:                  "pstream is not a subobject of wrapper");
 98780:     delete streamWrapper;
 19246:   }
 19246: 
 98940:   // 'listener' and/or 'streamWrapper' may be invalid (deleted) at this point. Don't
 98940:   // touch them again!
 98940: 
 19246:   return NPERR_NO_ERROR;
 19246: }
 19246: 
 19246: void NP_CALLBACK
 19246: _status(NPP npp, const char *message)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_status called from the wrong thread\n"));
 19246:     return;
 19246:   }
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_Status: npp=%p, message=%s\n",
 19246:                                      (void*)npp, message));
 19246: 
 19246:   if (!npp || !npp->ndata) {
 19246:     NS_WARNING("_status: npp or npp->ndata == 0");
 19246:     return;
 19246:   }
 19246: 
 70007:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance*)npp->ndata;
 19246: 
 19246:   PluginDestructionGuard guard(inst);
 19246: 
 29834:   inst->ShowStatus(message);
 19246: }
 19246: 
 19246: void NP_CALLBACK
 19246: _memfree (void *ptr)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_memfree called from the wrong thread\n"));
 19246:   }
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY, ("NPN_MemFree: ptr=%p\n", ptr));
 19246: 
 19246:   if (ptr)
 19246:     nsMemory::Free(ptr);
 19246: }
 19246: 
 19246: uint32_t NP_CALLBACK
 19246: _memflush(uint32_t size)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_memflush called from the wrong thread\n"));
 19246:   }
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY, ("NPN_MemFlush: size=%d\n", size));
 19246: 
 79533:   nsMemory::HeapMinimize(true);
 19246:   return 0;
 19246: }
 19246: 
 19246: void NP_CALLBACK
 19246: _reloadplugins(NPBool reloadPages)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_reloadplugins called from the wrong thread\n"));
 19246:     return;
 19246:   }
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
 19246:                  ("NPN_ReloadPlugins: reloadPages=%d\n", reloadPages));
 19246: 
 29574:   nsCOMPtr<nsIPluginHost> pluginHost(do_GetService(MOZ_PLUGIN_HOST_CONTRACTID));
 29574:   if (!pluginHost)
 19246:     return;
 19246: 
 29574:   pluginHost->ReloadPlugins(reloadPages);
 19246: }
 19246: 
 19246: void NP_CALLBACK
 19246: _invalidaterect(NPP npp, NPRect *invalidRect)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_invalidaterect called from the wrong thread\n"));
 19246:     return;
 19246:   }
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
 19246:                  ("NPN_InvalidateRect: npp=%p, top=%d, left=%d, bottom=%d, "
 19246:                   "right=%d\n", (void *)npp, invalidRect->top,
 19246:                   invalidRect->left, invalidRect->bottom, invalidRect->right));
 19246: 
 19246:   if (!npp || !npp->ndata) {
 19246:     NS_WARNING("_invalidaterect: npp or npp->ndata == 0");
 19246:     return;
 19246:   }
 19246: 
 70007:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance*)npp->ndata;
 19246: 
 19246:   PluginDestructionGuard guard(inst);
 19246: 
 32799:   inst->InvalidateRect((NPRect *)invalidRect);
 19246: }
 19246: 
 19246: void NP_CALLBACK
 19246: _invalidateregion(NPP npp, NPRegion invalidRegion)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_invalidateregion called from the wrong thread\n"));
 19246:     return;
 19246:   }
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
 19246:                  ("NPN_InvalidateRegion: npp=%p, region=%p\n", (void*)npp,
 19246:                   (void*)invalidRegion));
 19246: 
 19246:   if (!npp || !npp->ndata) {
 19246:     NS_WARNING("_invalidateregion: npp or npp->ndata == 0");
 19246:     return;
 19246:   }
 19246: 
 70007:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance*)npp->ndata;
 19246: 
 19246:   PluginDestructionGuard guard(inst);
 19246: 
 32799:   inst->InvalidateRegion((NPRegion)invalidRegion);
 19246: }
 19246: 
 19246: void NP_CALLBACK
 19246: _forceredraw(NPP npp)
 19246: {
 19246: }
 19246: 
 19246: NPObject* NP_CALLBACK
 19246: _getwindowobject(NPP npp)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getwindowobject called from the wrong thread\n"));
106838:     return nullptr;
 19246:   }
 19246:   JSContext *cx = GetJSContextFromNPP(npp);
106838:   NS_ENSURE_TRUE(cx, nullptr);
 19246: 
 19246:   // Using ::JS_GetGlobalObject(cx) is ok here since the window we
 19246:   // want to return here is the outer window, *not* the inner (since
 19246:   // we don't know what the plugin will do with it).
 19246:   return nsJSObjWrapper::GetNewOrUsed(npp, cx, ::JS_GetGlobalObject(cx));
 19246: }
 19246: 
 19246: NPObject* NP_CALLBACK
 19246: _getpluginelement(NPP npp)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getpluginelement called from the wrong thread\n"));
106838:     return nullptr;
 19246:   }
 32369: 
 32369:   nsNPAPIPluginInstance* inst = static_cast<nsNPAPIPluginInstance*>(npp->ndata);
 32369:   if (!inst)
106838:     return nullptr;
 32369: 
 19246:   nsCOMPtr<nsIDOMElement> element;
 32369:   inst->GetDOMElement(getter_AddRefs(element));
 32369: 
 32369:   if (!element)
106838:     return nullptr;
 19246: 
 19246:   JSContext *cx = GetJSContextFromNPP(npp);
106838:   NS_ENSURE_TRUE(cx, nullptr);
 19246: 
 19246:   nsCOMPtr<nsIXPConnect> xpc(do_GetService(nsIXPConnect::GetCID()));
106838:   NS_ENSURE_TRUE(xpc, nullptr);
 19246: 
 19246:   nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
 19246:   xpc->WrapNative(cx, ::JS_GetGlobalObject(cx), element,
 19246:                   NS_GET_IID(nsIDOMElement),
 19246:                   getter_AddRefs(holder));
106838:   NS_ENSURE_TRUE(holder, nullptr);
106838: 
106838:   JSObject* obj = nullptr;
 19246:   holder->GetJSObject(&obj);
106838:   NS_ENSURE_TRUE(obj, nullptr);
 19246: 
 19246:   return nsJSObjWrapper::GetNewOrUsed(npp, cx, obj);
 19246: }
 19246: 
 19246: NPIdentifier NP_CALLBACK
 19246: _getstringidentifier(const NPUTF8* name)
 19246: {
 19246:   if (!name) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS, ("NPN_getstringidentifier: passed null name"));
 19246:     return NULL;
 19246:   }
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getstringidentifier called from the wrong thread\n"));
 19246:   }
 19246: 
 19246:   nsCOMPtr<nsIThreadJSContextStack> stack =
 19246:     do_GetService("@mozilla.org/js/xpc/ContextStack;1");
 19246:   if (!stack)
 19246:     return NULL;
 19246: 
 97744:   JSContext* cx = stack->GetSafeJSContext();
 97744:   if (!cx) {
 19246:     return NULL;
 97744:   }
 19246: 
 19246:   JSAutoRequest ar(cx);
 19246:   return doGetIdentifier(cx, name);
 19246: }
 19246: 
 19246: void NP_CALLBACK
 19246: _getstringidentifiers(const NPUTF8** names, int32_t nameCount,
 19246:                       NPIdentifier *identifiers)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getstringidentifiers called from the wrong thread\n"));
 19246:   }
 19246:   nsCOMPtr<nsIThreadJSContextStack> stack =
 19246:     do_GetService("@mozilla.org/js/xpc/ContextStack;1");
 19246:   if (!stack)
 19246:     return;
 19246: 
 97744:   JSContext* cx = stack->GetSafeJSContext();
 97744:   if (!cx) {
 19246:     return;
 97744:   }
 19246: 
 19246:   JSAutoRequest ar(cx);
 19246: 
 19246:   for (int32_t i = 0; i < nameCount; ++i) {
 19246:     if (names[i]) {
 19246:       identifiers[i] = doGetIdentifier(cx, names[i]);
 19246:     } else {
 19246:       NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS, ("NPN_getstringidentifiers: passed null name"));
 19246:       identifiers[i] = NULL;
 19246:     }
 19246:   }
 19246: }
 19246: 
 19246: NPIdentifier NP_CALLBACK
 19246: _getintidentifier(int32_t intid)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getstringidentifier called from the wrong thread\n"));
 19246:   }
 48470:   return IntToNPIdentifier(intid);
 19246: }
 19246: 
 19246: NPUTF8* NP_CALLBACK
 48470: _utf8fromidentifier(NPIdentifier id)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_utf8fromidentifier called from the wrong thread\n"));
 19246:   }
 48470:   if (!id)
 19246:     return NULL;
 19246: 
 48470:   if (!NPIdentifierIsString(id)) {
106838:     return nullptr;
 19246:   }
 19246: 
 48470:   JSString *str = NPIdentifierToString(id);
 19246: 
 19246:   return
 59889:     ToNewUTF8String(nsDependentString(::JS_GetInternedStringChars(str),
 19246:                                       ::JS_GetStringLength(str)));
 19246: }
 19246: 
 19246: int32_t NP_CALLBACK
 48470: _intfromidentifier(NPIdentifier id)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_intfromidentifier called from the wrong thread\n"));
 19246:   }
 48470: 
 48470:   if (!NPIdentifierIsInt(id)) {
115367:     return INT32_MIN;
 19246:   }
 19246: 
 48470:   return NPIdentifierToInt(id);
 19246: }
 19246: 
 19246: bool NP_CALLBACK
 48470: _identifierisstring(NPIdentifier id)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_identifierisstring called from the wrong thread\n"));
 19246:   }
 48470: 
 48470:   return NPIdentifierIsString(id);
 19246: }
 19246: 
 19246: NPObject* NP_CALLBACK
 19246: _createobject(NPP npp, NPClass* aClass)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_createobject called from the wrong thread\n"));
106838:     return nullptr;
 19246:   }
 19246:   if (!npp) {
 19246:     NS_ERROR("Null npp passed to _createobject()!");
 19246: 
106838:     return nullptr;
 19246:   }
 19246: 
 19246:   PluginDestructionGuard guard(npp);
 19246: 
 19246:   if (!aClass) {
 19246:     NS_ERROR("Null class passed to _createobject()!");
 19246: 
106838:     return nullptr;
 19246:   }
 19246: 
 19246:   NPPAutoPusher nppPusher(npp);
 19246: 
 19246:   NPObject *npobj;
 19246: 
 19246:   if (aClass->allocate) {
 19246:     npobj = aClass->allocate(npp, aClass);
 19246:   } else {
 19246:     npobj = (NPObject *)PR_Malloc(sizeof(NPObject));
 19246:   }
 19246: 
 19246:   if (npobj) {
 19246:     npobj->_class = aClass;
 19246:     npobj->referenceCount = 1;
 36078:     NS_LOG_ADDREF(npobj, 1, "BrowserNPObject", sizeof(NPObject));
 19246:   }
 19246: 
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
 19246:                  ("Created NPObject %p, NPClass %p\n", npobj, aClass));
 19246: 
 19246:   return npobj;
 19246: }
 19246: 
 19246: NPObject* NP_CALLBACK
 19246: _retainobject(NPObject* npobj)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_retainobject called from the wrong thread\n"));
 19246:   }
 19246:   if (npobj) {
 61997: #ifdef NS_BUILD_REFCNT_LOGGING
 61930:     int32_t refCnt =
 61930: #endif
108991:       PR_ATOMIC_INCREMENT((int32_t*)&npobj->referenceCount);
 36078:     NS_LOG_ADDREF(npobj, refCnt, "BrowserNPObject", sizeof(NPObject));
 19246:   }
 19246: 
 19246:   return npobj;
 19246: }
 19246: 
 19246: void NP_CALLBACK
 19246: _releaseobject(NPObject* npobj)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_releaseobject called from the wrong thread\n"));
 19246:   }
 19246:   if (!npobj)
 19246:     return;
 19246: 
108991:   int32_t refCnt = PR_ATOMIC_DECREMENT((int32_t*)&npobj->referenceCount);
 36078:   NS_LOG_RELEASE(npobj, refCnt, "BrowserNPObject");
 19246: 
 19246:   if (refCnt == 0) {
 19246:     nsNPObjWrapper::OnDestroy(npobj);
 19246: 
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
 19246:                    ("Deleting NPObject %p, refcount hit 0\n", npobj));
 19246: 
 19246:     if (npobj->_class && npobj->_class->deallocate) {
 19246:       npobj->_class->deallocate(npobj);
 19246:     } else {
 19246:       PR_Free(npobj);
 19246:     }
 19246:   }
 19246: }
 19246: 
 19246: bool NP_CALLBACK
 19246: _invoke(NPP npp, NPObject* npobj, NPIdentifier method, const NPVariant *args,
 19246:         uint32_t argCount, NPVariant *result)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_invoke called from the wrong thread\n"));
 19246:     return false;
 19246:   }
 19246:   if (!npp || !npobj || !npobj->_class || !npobj->_class->invoke)
 19246:     return false;
 19246: 
 19246:   PluginDestructionGuard guard(npp);
 19246: 
 19246:   NPPExceptionAutoHolder nppExceptionHolder;
 19246:   NPPAutoPusher nppPusher(npp);
 19246: 
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
 19246:                  ("NPN_Invoke(npp %p, npobj %p, method %p, args %d\n", npp,
 19246:                   npobj, method, argCount));
 19246: 
 19246:   return npobj->_class->invoke(npobj, method, args, argCount, result);
 19246: }
 19246: 
 19246: bool NP_CALLBACK
 19246: _invokeDefault(NPP npp, NPObject* npobj, const NPVariant *args,
 19246:                uint32_t argCount, NPVariant *result)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_invokedefault called from the wrong thread\n"));
 19246:     return false;
 19246:   }
 19246:   if (!npp || !npobj || !npobj->_class || !npobj->_class->invokeDefault)
 19246:     return false;
 19246: 
 19246:   NPPExceptionAutoHolder nppExceptionHolder;
 19246:   NPPAutoPusher nppPusher(npp);
 19246: 
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
 19246:                  ("NPN_InvokeDefault(npp %p, npobj %p, args %d\n", npp,
 19246:                   npobj, argCount));
 19246: 
 19246:   return npobj->_class->invokeDefault(npobj, args, argCount, result);
 19246: }
 19246: 
 19246: bool NP_CALLBACK
 19246: _evaluate(NPP npp, NPObject* npobj, NPString *script, NPVariant *result)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_evaluate called from the wrong thread\n"));
 19246:     return false;
 19246:   }
 19246:   if (!npp)
 19246:     return false;
 19246: 
 19246:   NPPAutoPusher nppPusher(npp);
 19246: 
 19246:   nsIDocument *doc = GetDocumentFromNPP(npp);
 19246:   NS_ENSURE_TRUE(doc, false);
 19246: 
 19246:   JSContext *cx = GetJSContextFromDoc(doc);
 19246:   NS_ENSURE_TRUE(cx, false);
 19246: 
 36570:   nsCOMPtr<nsIScriptContext> scx = GetScriptContextFromJSContext(cx);
 36570:   NS_ENSURE_TRUE(scx, false);
 36570: 
 60783:   JSAutoRequest req(cx);
 60783: 
 19246:   JSObject *obj =
 19246:     nsNPObjWrapper::GetNewOrUsed(npp, cx, npobj);
 19246: 
 19246:   if (!obj) {
 19246:     return false;
 19246:   }
 19246: 
 79734:   obj = JS_ObjectToInnerObject(cx, obj);
 82303:   NS_ABORT_IF_FALSE(obj,
 82303:     "JS_ObjectToInnerObject should never return null with non-null input.");
 50480: 
 19246:   // Root obj and the rval (below).
 19246:   jsval vec[] = { OBJECT_TO_JSVAL(obj), JSVAL_NULL };
 86992:   JS::AutoArrayRooter tvr(cx, ArrayLength(vec), vec);
 19246:   jsval *rval = &vec[1];
 19246: 
 19246:   if (result) {
 19246:     // Initialize the out param to void
 19246:     VOID_TO_NPVARIANT(*result);
 19246:   }
 19246: 
 22867:   if (!script || !script->UTF8Length || !script->UTF8Characters) {
 19246:     // Nothing to evaluate.
 19246: 
 19246:     return true;
 19246:   }
 19246: 
 22867:   NS_ConvertUTF8toUTF16 utf16script(script->UTF8Characters,
 22867:                                     script->UTF8Length);
 19246: 
 19246:   nsIPrincipal *principal = doc->NodePrincipal();
 19246: 
110974:   nsAutoCString specStr;
 19246:   const char *spec;
 19246: 
 19246:   nsCOMPtr<nsIURI> uri;
 19246:   principal->GetURI(getter_AddRefs(uri));
 19246: 
 19246:   if (uri) {
 19246:     uri->GetSpec(specStr);
 19246:     spec = specStr.get();
 19246:   } else {
 19246:     // No URI in a principal means it's the system principal. If the
 19246:     // document URI is a chrome:// URI, pass that in as the URI of the
 19246:     // script, else pass in null for the filename as there's no way to
 19246:     // know where this document really came from. Passing in null here
 19246:     // also means that the script gets treated by XPConnect as if it
 19246:     // needs additional protection, which is what we want for unknown
 19246:     // chrome code anyways.
 19246: 
 19246:     uri = doc->GetDocumentURI();
 79445:     bool isChrome = false;
 19246: 
 19246:     if (uri && NS_SUCCEEDED(uri->SchemeIs("chrome", &isChrome)) && isChrome) {
 19246:       uri->GetSpec(specStr);
 19246:       spec = specStr.get();
 19246:     } else {
106838:       spec = nullptr;
 19246:     }
 19246:   }
 19246: 
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
 19246:                  ("NPN_Evaluate(npp %p, npobj %p, script <<<%s>>>) called\n",
 22867:                   npp, npobj, script->UTF8Characters));
 19246: 
 19246:   nsresult rv = scx->EvaluateStringWithValue(utf16script, obj, principal,
106838:                                              spec, 0, 0, rval, nullptr);
 19246: 
 19246:   return NS_SUCCEEDED(rv) &&
 19246:          (!result || JSValToNPVariant(npp, cx, *rval, result));
 19246: }
 19246: 
 19246: bool NP_CALLBACK
 19246: _getproperty(NPP npp, NPObject* npobj, NPIdentifier property,
 19246:              NPVariant *result)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getproperty called from the wrong thread\n"));
 19246:     return false;
 19246:   }
 19246:   if (!npp || !npobj || !npobj->_class || !npobj->_class->getProperty)
 19246:     return false;
 19246: 
 19246:   NPPExceptionAutoHolder nppExceptionHolder;
 19246:   NPPAutoPusher nppPusher(npp);
 19246: 
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
 19246:                  ("NPN_GetProperty(npp %p, npobj %p, property %p) called\n",
 19246:                   npp, npobj, property));
 19246: 
 57925:   if (!npobj->_class->getProperty(npobj, property, result))
 57925:     return false;
 57925: 
 57925:   // If a Java plugin tries to get the document.URL or document.documentURI
 57925:   // property from us, don't pass back a value that Java won't be able to
 57925:   // understand -- one that will make the URL(String) constructor throw a
 57925:   // MalformedURL exception.  Passing such a value causes Java Plugin2 to
 57925:   // crash (to throw a RuntimeException in Plugin2Manager.getDocumentBase()).
 57925:   // Also don't pass back a value that Java is likely to mishandle.
 57925: 
 57925:   nsNPAPIPluginInstance* inst = (nsNPAPIPluginInstance*) npp->ndata;
 57925:   if (!inst)
 57925:     return false;
 57925:   nsNPAPIPlugin* plugin = inst->GetPlugin();
 57925:   if (!plugin)
 57925:     return false;
 57925:   nsRefPtr<nsPluginHost> host = dont_AddRef(nsPluginHost::GetInst());
 57925:   nsPluginTag* pluginTag = host->TagForPlugin(plugin);
 57925:   if (!pluginTag->mIsJavaPlugin)
 57925:     return true;
 57925: 
 57925:   if (!NPVARIANT_IS_STRING(*result))
 57925:     return true;
 57925: 
 57925:   NPUTF8* propertyName = _utf8fromidentifier(property);
 57925:   if (!propertyName)
 57925:     return true;
 57925:   bool notURL =
 57925:     (PL_strcasecmp(propertyName, "URL") &&
 57925:      PL_strcasecmp(propertyName, "documentURI"));
 57925:   _memfree(propertyName);
 57925:   if (notURL)
 57925:     return true;
 57925: 
 57925:   NPObject* window_obj = _getwindowobject(npp);
 57925:   if (!window_obj)
 57925:     return true;
 57925: 
 57925:   NPVariant doc_v;
106838:   NPObject* document_obj = nullptr;
 57925:   NPIdentifier doc_id = _getstringidentifier("document");
 57925:   bool ok = npobj->_class->getProperty(window_obj, doc_id, &doc_v);
 57925:   _releaseobject(window_obj);
 57925:   if (ok) {
 57925:     if (NPVARIANT_IS_OBJECT(doc_v)) {
 57925:       document_obj = NPVARIANT_TO_OBJECT(doc_v);
 57925:     } else {
 57925:       _releasevariantvalue(&doc_v);
 57925:       return true;
 57925:     }
 57925:   } else {
 57925:     return true;
 57925:   }
 57925:   _releaseobject(document_obj);
 57925:   if (document_obj != npobj)
 57925:     return true;
 57925: 
 57925:   NPString urlnp = NPVARIANT_TO_STRING(*result);
 57925:   nsXPIDLCString url;
 57925:   url.Assign(urlnp.UTF8Characters, urlnp.UTF8Length);
 57925: 
 79445:   bool javaCompatible = false;
 57925:   if (NS_FAILED(NS_CheckIsJavaCompatibleURLString(url, &javaCompatible)))
 79533:     javaCompatible = false;
 57925:   if (javaCompatible)
 57925:     return true;
 57925: 
 57925:   // If Java won't be able to interpret the original value of document.URL or
 57925:   // document.documentURI, or is likely to mishandle it, pass back something
 57925:   // that Java will understand but won't be able to use to access the network,
 57925:   // and for which same-origin checks will always fail.
 57925: 
 57925:   if (inst->mFakeURL.IsVoid()) {
 57925:     // Abort (do an error return) if NS_MakeRandomInvalidURLString() fails.
 57925:     if (NS_FAILED(NS_MakeRandomInvalidURLString(inst->mFakeURL))) {
 57925:       _releasevariantvalue(result);
 57925:       return false;
 57925:     }
 57925:   }
 57925: 
 57925:   _releasevariantvalue(result);
 57925:   char* fakeurl = (char *) _memalloc(inst->mFakeURL.Length() + 1);
 57925:   strcpy(fakeurl, inst->mFakeURL);
 57925:   STRINGZ_TO_NPVARIANT(fakeurl, *result);
 57925: 
 57925:   return true;
 19246: }
 19246: 
 19246: bool NP_CALLBACK
 19246: _setproperty(NPP npp, NPObject* npobj, NPIdentifier property,
 19246:              const NPVariant *value)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_setproperty called from the wrong thread\n"));
 19246:     return false;
 19246:   }
 19246:   if (!npp || !npobj || !npobj->_class || !npobj->_class->setProperty)
 19246:     return false;
 19246: 
 19246:   NPPExceptionAutoHolder nppExceptionHolder;
 19246:   NPPAutoPusher nppPusher(npp);
 19246: 
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
 19246:                  ("NPN_SetProperty(npp %p, npobj %p, property %p) called\n",
 19246:                   npp, npobj, property));
 19246: 
 19246:   return npobj->_class->setProperty(npobj, property, value);
 19246: }
 19246: 
 19246: bool NP_CALLBACK
 19246: _removeproperty(NPP npp, NPObject* npobj, NPIdentifier property)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_removeproperty called from the wrong thread\n"));
 19246:     return false;
 19246:   }
 19246:   if (!npp || !npobj || !npobj->_class || !npobj->_class->removeProperty)
 19246:     return false;
 19246: 
 19246:   NPPExceptionAutoHolder nppExceptionHolder;
 19246:   NPPAutoPusher nppPusher(npp);
 19246: 
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
 19246:                  ("NPN_RemoveProperty(npp %p, npobj %p, property %p) called\n",
 19246:                   npp, npobj, property));
 19246: 
 19246:   return npobj->_class->removeProperty(npobj, property);
 19246: }
 19246: 
 19246: bool NP_CALLBACK
 19246: _hasproperty(NPP npp, NPObject* npobj, NPIdentifier propertyName)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_hasproperty called from the wrong thread\n"));
 19246:     return false;
 19246:   }
 19246:   if (!npp || !npobj || !npobj->_class || !npobj->_class->hasProperty)
 19246:     return false;
 19246: 
 19246:   NPPExceptionAutoHolder nppExceptionHolder;
 19246:   NPPAutoPusher nppPusher(npp);
 19246: 
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
 19246:                  ("NPN_HasProperty(npp %p, npobj %p, property %p) called\n",
 19246:                   npp, npobj, propertyName));
 19246: 
 19246:   return npobj->_class->hasProperty(npobj, propertyName);
 19246: }
 19246: 
 19246: bool NP_CALLBACK
 19246: _hasmethod(NPP npp, NPObject* npobj, NPIdentifier methodName)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_hasmethod called from the wrong thread\n"));
 19246:     return false;
 19246:   }
 19246:   if (!npp || !npobj || !npobj->_class || !npobj->_class->hasMethod)
 19246:     return false;
 19246: 
 19246:   NPPExceptionAutoHolder nppExceptionHolder;
 19246:   NPPAutoPusher nppPusher(npp);
 19246: 
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
 19246:                  ("NPN_HasMethod(npp %p, npobj %p, property %p) called\n",
 19246:                   npp, npobj, methodName));
 19246: 
 23760:   return npobj->_class->hasMethod(npobj, methodName);
 19246: }
 19246: 
 19246: bool NP_CALLBACK
 19246: _enumerate(NPP npp, NPObject *npobj, NPIdentifier **identifier,
 19246:            uint32_t *count)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_enumerate called from the wrong thread\n"));
 19246:     return false;
 19246:   }
 19246:   if (!npp || !npobj || !npobj->_class)
 19246:     return false;
 19246: 
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
 19246:                  ("NPN_Enumerate(npp %p, npobj %p) called\n", npp, npobj));
 19246: 
 19246:   if (!NP_CLASS_STRUCT_VERSION_HAS_ENUM(npobj->_class) ||
 19246:       !npobj->_class->enumerate) {
 19246:     *identifier = 0;
 19246:     *count = 0;
 19246:     return true;
 19246:   }
 19246: 
 19246:   NPPExceptionAutoHolder nppExceptionHolder;
 19246:   NPPAutoPusher nppPusher(npp);
 19246: 
 19246:   return npobj->_class->enumerate(npobj, identifier, count);
 19246: }
 19246: 
 19246: bool NP_CALLBACK
 19246: _construct(NPP npp, NPObject* npobj, const NPVariant *args,
 19246:                uint32_t argCount, NPVariant *result)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_construct called from the wrong thread\n"));
 19246:     return false;
 19246:   }
 19246:   if (!npp || !npobj || !npobj->_class ||
 19246:       !NP_CLASS_STRUCT_VERSION_HAS_CTOR(npobj->_class) ||
 19246:       !npobj->_class->construct) {
 19246:     return false;
 19246:   }
 19246: 
 19246:   NPPExceptionAutoHolder nppExceptionHolder;
 19246:   NPPAutoPusher nppPusher(npp);
 19246: 
 19246:   return npobj->_class->construct(npobj, args, argCount, result);
 19246: }
 19246: 
 19246: void NP_CALLBACK
 19246: _releasevariantvalue(NPVariant* variant)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_releasevariantvalue called from the wrong thread\n"));
 19246:   }
 19246:   switch (variant->type) {
 19246:   case NPVariantType_Void :
 19246:   case NPVariantType_Null :
 19246:   case NPVariantType_Bool :
 19246:   case NPVariantType_Int32 :
 19246:   case NPVariantType_Double :
 19246:     break;
 19246:   case NPVariantType_String :
 19246:     {
 19246:       const NPString *s = &NPVARIANT_TO_STRING(*variant);
 19246: 
 22867:       if (s->UTF8Characters) {
 69691: #if defined(MOZ_MEMORY_WINDOWS)
 22867:         if (malloc_usable_size((void *)s->UTF8Characters) != 0) {
 22867:           PR_Free((void *)s->UTF8Characters);
 19246:         } else {
 22867:           void *p = (void *)s->UTF8Characters;
 19246:           DWORD nheaps = 0;
 19246:           nsAutoTArray<HANDLE, 50> heaps;
 19246:           nheaps = GetProcessHeaps(0, heaps.Elements());
 19246:           heaps.AppendElements(nheaps);
 19246:           GetProcessHeaps(nheaps, heaps.Elements());
 19246:           for (DWORD i = 0; i < nheaps; i++) {
 19246:             if (InHeap(heaps[i], p)) {
 19246:               HeapFree(heaps[i], 0, p);
 19246:               break;
 19246:             }
 19246:           }
 19246:         }
 19246: #else
 42122:         NS_Free((void *)s->UTF8Characters);
 19246: #endif
 19246:       }
 19246:       break;
 19246:     }
 19246:   case NPVariantType_Object:
 19246:     {
 19246:       NPObject *npobj = NPVARIANT_TO_OBJECT(*variant);
 19246: 
 19246:       if (npobj)
 19246:         _releaseobject(npobj);
 19246: 
 19246:       break;
 19246:     }
 19246:   default:
 19246:     NS_ERROR("Unknown NPVariant type!");
 19246:   }
 19246: 
 19246:   VOID_TO_NPVARIANT(*variant);
 19246: }
 19246: 
 19246: void NP_CALLBACK
 19246: _setexception(NPObject* npobj, const NPUTF8 *message)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_setexception called from the wrong thread\n"));
 19246:     return;
 19246:   }
 19246: 
 34415:   if (!message) return;
 34415: 
 19246:   if (gNPPException) {
 19246:     // If a plugin throws multiple exceptions, we'll only report the
 19246:     // last one for now.
 19246:     free(gNPPException);
 19246:   }
 19246: 
 19246:   gNPPException = strdup(message);
 19246: }
 19246: 
 19246: NPError NP_CALLBACK
 19246: _getvalue(NPP npp, NPNVariable variable, void *result)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_getvalue called from the wrong thread\n"));
 19246:     return NPERR_INVALID_PARAM;
 19246:   }
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_GetValue: npp=%p, var=%d\n",
 19246:                                      (void*)npp, (int)variable));
 19246: 
 19246:   nsresult res;
 19246: 
 19246:   PluginDestructionGuard guard(npp);
 19246: 
 19246:   switch(variable) {
 19246: #if defined(XP_UNIX) && !defined(XP_MACOSX)
 19246:   case NPNVxDisplay : {
 77137: #if defined(MOZ_X11)
 19246:     if (npp) {
 19246:       nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *) npp->ndata;
 79445:       bool windowless = false;
 32799:       inst->IsWindowless(&windowless);
 93035:       // The documentation on the types for many variables in NP(N|P)_GetValue
 93035:       // is vague.  Often boolean values are NPBool (1 byte), but
 93035:       // https://developer.mozilla.org/en/XEmbed_Extension_for_Mozilla_Plugins
 93035:       // treats NPPVpluginNeedsXEmbed as PRBool (int), and
 93035:       // on x86/32-bit, flash stores to this using |movl 0x1,&needsXEmbed|.
 93035:       // thus we can't use NPBool for needsXEmbed, or the three bytes above
 93035:       // it on the stack would get clobbered. so protect with the larger bool.
 93035:       int needsXEmbed = 0;
 19246:       if (!windowless) {
 93035:         res = inst->GetValueFromPlugin(NPPVpluginNeedsXEmbed, &needsXEmbed);
 63555:         // If the call returned an error code make sure we still use our default value.
 63555:         if (NS_FAILED(res)) {
 93035:           needsXEmbed = 0;
 63555:         }
 19246:       }
 93035:       if (windowless || needsXEmbed) {
 43912:         (*(Display **)result) = mozilla::DefaultXDisplay();
 19246:         return NPERR_NO_ERROR;
 19246:       }
 19246:     }
 41059: #ifdef MOZ_WIDGET_GTK2
 19246:     // adobe nppdf calls XtGetApplicationNameAndClass(display,
 19246:     // &instance, &class) we have to init Xt toolkit before get
 19246:     // XtDisplay just call gtk_xtbin_new(w,0) once
 19246:     static GtkWidget *gtkXtBinHolder = 0;
 19246:     if (!gtkXtBinHolder) {
 27011:       gtkXtBinHolder = gtk_xtbin_new(gdk_get_default_root_window(),0);
 19246:       // it crashes on destroy, let it leak
 19246:       // gtk_widget_destroy(gtkXtBinHolder);
 19246:     }
 19246:     (*(Display **)result) =  GTK_XTBIN(gtkXtBinHolder)->xtdisplay;
 19246:     return NPERR_NO_ERROR;
 19246: #endif
 41059: #endif
 19246:     return NPERR_GENERIC_ERROR;
 19246:   }
 19246: 
 19246:   case NPNVxtAppContext:
 19246:     return NPERR_GENERIC_ERROR;
 19246: #endif
 19246: 
 41059: #if defined(XP_WIN) || defined(XP_OS2) || defined(MOZ_WIDGET_GTK2) \
 41059:  || defined(MOZ_WIDGET_QT)
 19246:   case NPNVnetscapeWindow: {
 19246:     if (!npp || !npp->ndata)
 19246:       return NPERR_INVALID_INSTANCE_ERROR;
 19246: 
 19246:     nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *) npp->ndata;
 19246: 
115860:     nsRefPtr<nsPluginInstanceOwner> owner = inst->GetOwner();
106118:     NS_ENSURE_TRUE(owner, NPERR_NO_ERROR);
 29834: 
 29834:     if (NS_SUCCEEDED(owner->GetNetscapeWindow(result))) {
 19246:       return NPERR_NO_ERROR;
 19246:     }
 19246:     return NPERR_GENERIC_ERROR;
 19246:   }
 19246: #endif
 19246: 
 19246:   case NPNVjavascriptEnabledBool: {
 79533:     *(NPBool*)result = false;
 94707:     bool js = false;
 94707:     res = Preferences::GetBool("javascript.enabled", &js);
 94707:     if (NS_SUCCEEDED(res)) {
 19246:       *(NPBool*)result = js;
 19246:     }
 19246:     return NPERR_NO_ERROR;
 19246:   }
 19246: 
 19246:   case NPNVasdEnabledBool:
 79533:     *(NPBool*)result = false;
 19246:     return NPERR_NO_ERROR;
 19246: 
 19246:   case NPNVisOfflineBool: {
 79445:     bool offline = false;
 19246:     nsCOMPtr<nsIIOService> ioservice =
 19246:       do_GetService(NS_IOSERVICE_CONTRACTID, &res);
 19246:     if (NS_SUCCEEDED(res))
 19246:       res = ioservice->GetOffline(&offline);
 19246:     if (NS_FAILED(res))
 19246:       return NPERR_GENERIC_ERROR;
 19246: 
 19246:     *(NPBool*)result = offline;
 19246:     return NPERR_NO_ERROR;
 19246:   }
 19246: 
 19246:   case NPNVToolkit: {
103111: #ifdef MOZ_WIDGET_GTK
 19246:     *((NPNToolkitType*)result) = NPNVGtk2;
 19246: #endif
 19246: 
 41059: #ifdef MOZ_WIDGET_QT
 41059:     /* Fake toolkit so flash plugin works */
 41059:     *((NPNToolkitType*)result) = NPNVGtk2;
 41059: #endif
 19246:     if (*(NPNToolkitType*)result)
 19246:         return NPERR_NO_ERROR;
 19246: 
 19246:     return NPERR_GENERIC_ERROR;
 19246:   }
 19246: 
 19246:   case NPNVSupportsXEmbedBool: {
103111: #ifdef MOZ_WIDGET_GTK
 79533:     *(NPBool*)result = true;
 42531: #elif defined(MOZ_WIDGET_QT)
 42531:     // Desktop Flash fail to initialize if browser does not support NPNVSupportsXEmbedBool
 42531:     // even when wmode!=windowed, lets return fake support
 42531:     fprintf(stderr, "Fake support for XEmbed plugins in Qt port\n");
 79533:     *(NPBool*)result = true;
 19246: #else
 79533:     *(NPBool*)result = false;
 19246: #endif
 19246:     return NPERR_NO_ERROR;
 19246:   }
 19246: 
 19246:   case NPNVWindowNPObject: {
 19246:     *(NPObject **)result = _getwindowobject(npp);
 19246: 
 36128:     return *(NPObject **)result ? NPERR_NO_ERROR : NPERR_GENERIC_ERROR;
 19246:   }
 19246: 
 19246:   case NPNVPluginElementNPObject: {
 19246:     *(NPObject **)result = _getpluginelement(npp);
 19246: 
 37830:     return *(NPObject **)result ? NPERR_NO_ERROR : NPERR_GENERIC_ERROR;
 19246:   }
 19246: 
 19246:   case NPNVSupportsWindowless: {
 41059: #if defined(XP_WIN) || defined(XP_MACOSX) || \
103111:     (defined(MOZ_X11) && (defined(MOZ_WIDGET_GTK) || defined(MOZ_WIDGET_QT)))
 79533:     *(NPBool*)result = true;
 19246: #else
 79533:     *(NPBool*)result = false;
 19246: #endif
 19246:     return NPERR_NO_ERROR;
 19246:   }
 19246: 
 24475:   case NPNVprivateModeBool: {
 96781:     nsCOMPtr<nsIDocument> doc = GetDocumentFromNPP(npp);
 97051:     NS_ENSURE_TRUE(doc, NPERR_GENERIC_ERROR);
 97051:     nsCOMPtr<nsPIDOMWindow> domwindow = doc->GetWindow();
 96781:     if (domwindow) {
 96781:       nsCOMPtr<nsIDocShell> docShell = domwindow->GetDocShell();
 96781:       nsCOMPtr<nsILoadContext> loadContext = do_QueryInterface(docShell);
 96781:       *(NPBool*)result = (NPBool)(loadContext && loadContext->UsePrivateBrowsing());
 24475:       return NPERR_NO_ERROR;
 24475:     }
 24475:     return NPERR_GENERIC_ERROR;
 24475:   }
 24475: 
 78254:   case NPNVdocumentOrigin: {
 78254:     nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)npp->ndata;
 78254:     if (!inst) {
 78254:       return NPERR_GENERIC_ERROR;
 78254:     }
 78254: 
 78254:     nsCOMPtr<nsIDOMElement> element;
 78254:     inst->GetDOMElement(getter_AddRefs(element));
 78254:     if (!element) {
 78254:       return NPERR_GENERIC_ERROR;
 78254:     }
 78254: 
 78254:     nsCOMPtr<nsIContent> content(do_QueryInterface(element));
 78254:     if (!content) {
 78254:       return NPERR_GENERIC_ERROR;
 78254:     }
 78254: 
 78254:     nsIPrincipal* principal = content->NodePrincipal();
 78254: 
 78254:     nsAutoString utf16Origin;
 78254:     res = nsContentUtils::GetUTFOrigin(principal, utf16Origin);
 78254:     if (NS_FAILED(res)) {
 78254:       return NPERR_GENERIC_ERROR;
 78254:     }
 78254: 
 78254:     nsCOMPtr<nsIUnicodeNormalizer> normalizer = do_GetService(NS_UNICODE_NORMALIZER_CONTRACTID);
 78254:     if (!normalizer) {
 78254:       return NPERR_GENERIC_ERROR;
 78254:     }
 78254: 
 78254:     nsAutoString normalizedUTF16Origin;
 78254:     res = normalizer->NormalizeUnicodeNFKC(utf16Origin, normalizedUTF16Origin);
 78254:     if (NS_FAILED(res)) {
 78254:       return NPERR_GENERIC_ERROR;
 78254:     }
 78254: 
 78254:     *(char**)result = ToNewUTF8String(normalizedUTF16Origin);
 78254:     return *(char**)result ? NPERR_NO_ERROR : NPERR_GENERIC_ERROR;
 78254:   }
 78254: 
 19246: #ifdef XP_MACOSX
 19246:   case NPNVpluginDrawingModel: {
 19246:     if (npp) {
 19246:       nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance*)npp->ndata;
 19246:       if (inst) {
 32799:         NPDrawingModel drawingModel;
108991:         inst->GetDrawingModel((int32_t*)&drawingModel);
 32799:         *(NPDrawingModel*)result = drawingModel;
 19246:         return NPERR_NO_ERROR;
 19246:       }
 19246:     }
 19246:     else {
 19246:       return NPERR_GENERIC_ERROR;
 19246:     }
 19246:   }
 19246: 
 19246: #ifndef NP_NO_QUICKDRAW
 19246:   case NPNVsupportsQuickDrawBool: {
110791:     *(NPBool*)result = false;
 19246:     
 19246:     return NPERR_NO_ERROR;
 19246:   }
 19246: #endif
 19246: 
 19246:   case NPNVsupportsCoreGraphicsBool: {
 79533:     *(NPBool*)result = true;
 19246:     
 19246:     return NPERR_NO_ERROR;
 19246:   }
 32019: 
 39757:    case NPNVsupportsCoreAnimationBool: {
 86966:      *(NPBool*)result = nsCocoaFeatures::SupportCoreAnimationPlugins();
 39757: 
 39757:      return NPERR_NO_ERROR;
 39757:    }
 39757: 
 43370:    case NPNVsupportsInvalidatingCoreAnimationBool: {
 86966:      *(NPBool*)result = nsCocoaFeatures::SupportCoreAnimationPlugins();
 43370: 
 43370:      return NPERR_NO_ERROR;
 43370:    }
 43370: 
 39757: 
 32019: #ifndef NP_NO_CARBON
 32019:   case NPNVsupportsCarbonBool: {
 79533:     *(NPBool*)result = true;
 32019: 
 32019:     return NPERR_NO_ERROR;
 32019:   }
 32019: #endif
 32019:   case NPNVsupportsCocoaBool: {
 79533:     *(NPBool*)result = true;
 32019: 
 32019:     return NPERR_NO_ERROR;
 32019:   }
 61078: 
 61078:   case NPNVsupportsUpdatedCocoaTextInputBool: {
 61078:     *(NPBool*)result = true;
 61078:     return NPERR_NO_ERROR;
 61078:   }
115799: 
115799:   case NPNVcontentsScaleFactor: {
115799:     nsNPAPIPluginInstance *inst =
115799:       (nsNPAPIPluginInstance *) (npp ? npp->ndata : nullptr);
115799:     double scaleFactor = inst ? inst->GetContentsScaleFactor() : 1.0;
115799:     *(double*)result = scaleFactor;
115799:     return NPERR_NO_ERROR;
115799:   }
 19246: #endif
 19246: 
 82142: #ifdef MOZ_WIDGET_ANDROID
 78424:     case kLogInterfaceV0_ANPGetValue: {
 78424:       LOG("get log interface");
 78424:       ANPLogInterfaceV0 *i = (ANPLogInterfaceV0 *) result;
 78424:       InitLogInterface(i);
 78424:       return NPERR_NO_ERROR;
 78424:     }
 78424: 
 78424:     case kBitmapInterfaceV0_ANPGetValue: {
 78424:       LOG("get bitmap interface");
 78424:       ANPBitmapInterfaceV0 *i = (ANPBitmapInterfaceV0 *) result;
 78424:       InitBitmapInterface(i);
 78424:       return NPERR_NO_ERROR;
 78424:     }
 78424: 
 78424:     case kMatrixInterfaceV0_ANPGetValue: {
 78424:       LOG("get matrix interface");
 78424:       ANPMatrixInterfaceV0 *i = (ANPMatrixInterfaceV0 *) result;
 78424:       InitMatrixInterface(i);
 78424:       return NPERR_NO_ERROR;
 78424:     }
 78424:       
 78424:     case kPathInterfaceV0_ANPGetValue: {
 78424:       LOG("get path interface");
 78424:       ANPPathInterfaceV0 *i = (ANPPathInterfaceV0 *) result;
 78424:       InitPathInterface(i);
 78424:       return NPERR_NO_ERROR;
 78424:     }
 78424:       
 78424:     case kTypefaceInterfaceV0_ANPGetValue: {
 78424:       LOG("get typeface interface");
 78424:       ANPTypefaceInterfaceV0 *i = (ANPTypefaceInterfaceV0 *) result;
 78424:       InitTypeFaceInterface(i);
 78424:       return NPERR_NO_ERROR;
 78424:     }
 78424: 
 78424:     case kPaintInterfaceV0_ANPGetValue: {
 78424:       LOG("get paint interface");
 78424:       ANPPaintInterfaceV0 *i = (ANPPaintInterfaceV0 *) result;
 78424:       InitPaintInterface(i);
 78424:       return NPERR_NO_ERROR;
 78424:     }
 78424: 
 78424:     case kCanvasInterfaceV0_ANPGetValue: {
 78424:       LOG("get canvas interface");
 78424:       ANPCanvasInterfaceV0 *i = (ANPCanvasInterfaceV0 *) result;
 78424:       InitCanvasInterface(i);
 78424:       return NPERR_NO_ERROR;
 78424:     }
 78424: 
 78424:     case kWindowInterfaceV0_ANPGetValue: {
 78424:       LOG("get window interface");
 78424:       ANPWindowInterfaceV0 *i = (ANPWindowInterfaceV0 *) result;
 78424:       InitWindowInterface(i);
 78424:       return NPERR_NO_ERROR;
 78424:     }
 78424: 
 78424:     case kAudioTrackInterfaceV0_ANPGetValue: {
 78424:       LOG("get audio interface");
 78424:       ANPAudioTrackInterfaceV0 *i = (ANPAudioTrackInterfaceV0 *) result;
 89219:       InitAudioTrackInterfaceV0(i);
 78424:       return NPERR_NO_ERROR;
 78424:     }
 78424: 
 78424:     case kEventInterfaceV0_ANPGetValue: {
 78424:       LOG("get event interface");
 78424:       ANPEventInterfaceV0 *i = (ANPEventInterfaceV0 *) result;
 78424:       InitEventInterface(i);
 78424:       return NPERR_NO_ERROR;
 78424:     }
 78424: 
 78424:     case kSystemInterfaceV0_ANPGetValue: {
 78424:       LOG("get system interface");
 78424:       ANPSystemInterfaceV0* i = reinterpret_cast<ANPSystemInterfaceV0*>(result);
 78424:       InitSystemInterface(i);
 78424:       return NPERR_NO_ERROR;
 78424:     }
 78424: 
 78424:     case kSurfaceInterfaceV0_ANPGetValue: {
 78424:       LOG("get surface interface");
 78424:       ANPSurfaceInterfaceV0 *i = (ANPSurfaceInterfaceV0 *) result;
 78424:       InitSurfaceInterface(i);
 78424:       return NPERR_NO_ERROR;
 78424:     }
 78424:       
 78424:     case kSupportedDrawingModel_ANPGetValue: {
 78424:       LOG("get supported drawing model");
 78424:       uint32_t* bits = reinterpret_cast<uint32_t*>(result);
 78424:       *bits = kBitmap_ANPDrawingModel && kSurface_ANPDrawingModel;
 78424:       return NPERR_NO_ERROR;
 78424:     }  
 78424: 
 78424:     case kJavaContext_ANPGetValue: {
 78424:       LOG("get context");
 78424:       JNIEnv* env = GetJNIForThread();
 88506:       if (!env)
 88506:         return NPERR_GENERIC_ERROR;
 88506: 
 78424:       jclass cls     = env->FindClass("org/mozilla/gecko/GeckoApp");
 78424:       jfieldID field = env->GetStaticFieldID(cls, "mAppContext",
 78424:                                              "Lorg/mozilla/gecko/GeckoApp;");
 78424:       jobject ret = env->GetStaticObjectField(cls, field);
115010:       env->DeleteLocalRef(cls);
 78424:       int32_t* i  = reinterpret_cast<int32_t*>(result);
 78424:       *i = reinterpret_cast<int32_t>(ret);
 78424:       return NPERR_NO_ERROR;
 78424:     }
 89219: 
 89219:     case kAudioTrackInterfaceV1_ANPGetValue: {
 89219:       LOG("get audio interface v1");
 89219:       ANPAudioTrackInterfaceV1 *i = (ANPAudioTrackInterfaceV1 *) result;
 89219:       InitAudioTrackInterfaceV1(i);
 89219:       return NPERR_NO_ERROR;
 89219:     }
 89219: 
 89219:     case kNativeWindowInterfaceV0_ANPGetValue: {
 89219:       LOG("get native window interface v0");
 89219:       ANPNativeWindowInterfaceV0* i = (ANPNativeWindowInterfaceV0 *) result;
 89219:       InitNativeWindowInterface(i);
 89219:       return NPERR_NO_ERROR;
 89219:     }
 89219: 
 89219:     case kOpenGLInterfaceV0_ANPGetValue: {
 89219:       LOG("get openGL interface");
 89219:       ANPOpenGLInterfaceV0 *i = (ANPOpenGLInterfaceV0*) result;
 89219:       InitOpenGLInterface(i);
 89219:       return NPERR_NO_ERROR;
 89219:     }
 89219: 
 89219:     case kWindowInterfaceV1_ANPGetValue: {
 89219:       LOG("get Window interface V1");
 89219:       ANPWindowInterfaceV1 *i = (ANPWindowInterfaceV1 *) result;
 89219:       InitWindowInterfaceV1(i);
 89219:       return NPERR_NO_ERROR;
 89219:     }
 89219: 
 89219:     case kWindowInterfaceV2_ANPGetValue: {
 89219:       LOG("get Window interface V2");
 89219:       ANPWindowInterfaceV2 *i = (ANPWindowInterfaceV2 *) result;
 89219:       InitWindowInterfaceV2(i);
 89219:       return NPERR_NO_ERROR;
 89219:     }
 89219: 
 89219:     case kVideoInterfaceV0_ANPGetValue: {
 89219:       LOG("get video interface");
 89219:       ANPVideoInterfaceV0 *i = (ANPVideoInterfaceV0*) result;
 89219:       InitVideoInterfaceV0(i);
 89219:       return NPERR_NO_ERROR;
 89219:     }
 89219: 
 89219:     case kVideoInterfaceV1_ANPGetValue: {
 89219:       LOG("get video interface");
 89219:       ANPVideoInterfaceV1 *i = (ANPVideoInterfaceV1*) result;
 89219:       InitVideoInterfaceV1(i);
 89219:       return NPERR_NO_ERROR;
 89219:     }
 89219: 
 89219: 
 89219:     case kSystemInterfaceV1_ANPGetValue: {
 89219:       LOG("get system interface v1");
 89219:       ANPSystemInterfaceV1* i = reinterpret_cast<ANPSystemInterfaceV1*>(result);
 89219:       InitSystemInterfaceV1(i);
 89219:       return NPERR_NO_ERROR;
 89219:     }
 89219: 
 89219:     case kSystemInterfaceV2_ANPGetValue: {
 89219:       LOG("get system interface v2");
 89219:       ANPSystemInterfaceV2* i = reinterpret_cast<ANPSystemInterfaceV2*>(result);
 89219:       InitSystemInterfaceV2(i);
 89219:       return NPERR_NO_ERROR;
 89219:     }
 89219: 
 78424: #endif
 78424: 
 69691:   // we no longer hand out any XPCOM objects
 35279:   case NPNVDOMElement:
 35279:     // fall through
 35279:   case NPNVDOMWindow:
 35279:     // fall through
 35279:   case NPNVserviceManager:
 35279:     // old XPCOM objects, no longer supported, but null out the out
 35279:     // param to avoid crashing plugins that still try to use this.
106838:     *(nsISupports**)result = nullptr;
 35279:     // fall through
 19246:   default:
 78424:     NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_getvalue unhandled get value: %d\n", variable));
 19246:     return NPERR_GENERIC_ERROR;
 19246:   }
 19246: }
 19246: 
 19246: NPError NP_CALLBACK
 19246: _setvalue(NPP npp, NPPVariable variable, void *result)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_setvalue called from the wrong thread\n"));
 19246:     return NPERR_INVALID_PARAM;
 19246:   }
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_SetValue: npp=%p, var=%d\n",
 19246:                                      (void*)npp, (int)variable));
 19246: 
 19246:   if (!npp)
 19246:     return NPERR_INVALID_INSTANCE_ERROR;
 19246: 
 19246:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *) npp->ndata;
 19246: 
 21231:   NS_ASSERTION(inst, "null instance");
 21231: 
 21231:   if (!inst)
 19246:     return NPERR_INVALID_INSTANCE_ERROR;
 19246: 
 19246:   PluginDestructionGuard guard(inst);
 19246: 
 19246:   switch (variable) {
 19246: 
 19246:     // we should keep backward compatibility with NPAPI where the
 19246:     // actual pointer value is checked rather than its content
 19246:     // when passing booleans
 19246:     case NPPVpluginWindowBool: {
 22548: #ifdef XP_MACOSX
 22548:       // This setting doesn't apply to OS X (only to Windows and Unix/Linux).
 22548:       // See https://developer.mozilla.org/En/NPN_SetValue#section_5.  Return
 22548:       // NPERR_NO_ERROR here to conform to other browsers' behavior on OS X
 22548:       // (e.g. Safari and Opera).
 22548:       return NPERR_NO_ERROR;
 22548: #else
106838:       NPBool bWindowless = (result == nullptr);
 19246:       return inst->SetWindowless(bWindowless);
 22548: #endif
 19246:     }
 19246:     case NPPVpluginTransparentBool: {
106838:       NPBool bTransparent = (result != nullptr);
 19246:       return inst->SetTransparent(bTransparent);
 19246:     }
 19246: 
 19246:     case NPPVjavascriptPushCallerBool:
 19246:       {
 19246:         nsresult rv;
 19246:         nsCOMPtr<nsIJSContextStack> contextStack =
 19246:           do_GetService("@mozilla.org/js/xpc/ContextStack;1", &rv);
 19246:         if (NS_SUCCEEDED(rv)) {
106838:           NPBool bPushCaller = (result != nullptr);
 19246:           if (bPushCaller) {
 19246:             JSContext *cx;
 29808:             rv = inst->GetJSContext(&cx);
 19246:             if (NS_SUCCEEDED(rv))
 19246:               rv = contextStack->Push(cx);
 19246:           } else {
106838:             rv = contextStack->Pop(nullptr);
 19246:           }
 19246:         }
 19246:         return NS_SUCCEEDED(rv) ? NPERR_NO_ERROR : NPERR_GENERIC_ERROR;
 19246:       }
 19246: 
 19246:     case NPPVpluginKeepLibraryInMemory: {
106838:       NPBool bCached = (result != nullptr);
108534:       inst->SetCached(bCached);
108534:       return NPERR_NO_ERROR;
 19246:     }
 19246: 
 67677:     case NPPVpluginUsesDOMForCursorBool: {
106838:       bool useDOMForCursor = (result != nullptr);
 67677:       return inst->SetUsesDOMForCursor(useDOMForCursor);
 67677:     }
 67677: 
 93035: #ifndef MOZ_WIDGET_ANDROID
 93035:     // On android, their 'drawing model' uses the same constant!
 19246:     case NPPVpluginDrawingModel: {
 19246:       if (inst) {
 31406:         inst->SetDrawingModel((NPDrawingModel)NS_PTR_TO_INT32(result));
 19246:         return NPERR_NO_ERROR;
 19246:       }
 19246:       else {
 19246:         return NPERR_GENERIC_ERROR;
 19246:       }
 19246:     }
 93035: #endif
 93035: 
 93035: #ifdef XP_MACOSX
 32019:     case NPPVpluginEventModel: {
 32019:       if (inst) {
 32019:         inst->SetEventModel((NPEventModel)NS_PTR_TO_INT32(result));
 32019:         return NPERR_NO_ERROR;
 32019:       }
 32019:       else {
 32019:         return NPERR_GENERIC_ERROR;
 32019:       }
 32019:     }
 19246: #endif
 82142: #ifdef MOZ_WIDGET_ANDROID
 78424:   case kRequestDrawingModel_ANPSetValue:
 78424:     if (inst)
 87577:       inst->SetANPDrawingModel(NS_PTR_TO_INT32(result));
 78424:     return NPERR_NO_ERROR;
 78424:   case kAcceptEvents_ANPSetValue:
 78424:     return NPERR_NO_ERROR;
 78424: #endif
 19246:     default:
 26261:       return NPERR_GENERIC_ERROR;
 19246:   }
 19246: }
 19246: 
 19246: NPError NP_CALLBACK
 19246: _requestread(NPStream *pstream, NPByteRange *rangeList)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_requestread called from the wrong thread\n"));
 19246:     return NPERR_INVALID_PARAM;
 19246:   }
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_RequestRead: stream=%p\n",
 19246:                                      (void*)pstream));
 19246: 
 19246: #ifdef PLUGIN_LOGGING
106838:   for(NPByteRange * range = rangeList; range != nullptr; range = range->next)
 19246:     PR_LOG(nsPluginLogging::gNPNLog,PLUGIN_LOG_NOISY,
 19246:     ("%i-%i", range->offset, range->offset + range->length - 1));
 19246: 
 19246:   PR_LOG(nsPluginLogging::gNPNLog,PLUGIN_LOG_NOISY, ("\n\n"));
 19246:   PR_LogFlush();
 19246: #endif
 19246: 
 19246:   if (!pstream || !rangeList || !pstream->ndata)
 19246:     return NPERR_INVALID_PARAM;
 19246: 
 98780:   nsNPAPIStreamWrapper* streamWrapper = static_cast<nsNPAPIStreamWrapper*>(pstream->ndata);
 98780:   nsNPAPIPluginStreamListener* streamlistener = streamWrapper->GetStreamListener();
 98780:   if (!streamlistener) {
 98780:     return NPERR_GENERIC_ERROR;
 98780:   }
 19246: 
108991:   int32_t streamtype = NP_NORMAL;
 19246: 
 19246:   streamlistener->GetStreamType(&streamtype);
 19246: 
 32799:   if (streamtype != NP_SEEK)
 19246:     return NPERR_STREAM_NOT_SEEKABLE;
 19246: 
101150:   if (!streamlistener->mStreamListenerPeer)
 39118:     return NPERR_GENERIC_ERROR;
 39118: 
101150:   nsresult rv = streamlistener->mStreamListenerPeer->RequestRead((NPByteRange *)rangeList);
 39118:   if (NS_FAILED(rv))
 39118:     return NPERR_GENERIC_ERROR;
 19246: 
108414:   return NPERR_NO_ERROR;
 19246: }
 19246: 
 19246: // Deprecated, only stubbed out
 19246: void* NP_CALLBACK /* OJI type: JRIEnv* */
 37780: _getJavaEnv()
 19246: {
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_GetJavaEnv\n"));
 19246:   return NULL;
 19246: }
 19246: 
 19246: const char * NP_CALLBACK
 19246: _useragent(NPP npp)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_useragent called from the wrong thread\n"));
106838:     return nullptr;
 19246:   }
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_UserAgent: npp=%p\n", (void*)npp));
 19246: 
 70185:   nsCOMPtr<nsIPluginHost> pluginHostCOM(do_GetService(MOZ_PLUGIN_HOST_CONTRACTID));
 70185:   nsPluginHost *pluginHost = static_cast<nsPluginHost*>(pluginHostCOM.get());
 70185:   if (!pluginHost) {
106838:     return nullptr;
 70185:   }
 19246: 
 19246:   const char *retstr;
 29574:   nsresult rv = pluginHost->UserAgent(&retstr);
 19246:   if (NS_FAILED(rv))
106838:     return nullptr;
 19246: 
 19246:   return retstr;
 19246: }
 19246: 
 19246: void * NP_CALLBACK
 19246: _memalloc (uint32_t size)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,("NPN_memalloc called from the wrong thread\n"));
 19246:   }
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY, ("NPN_MemAlloc: size=%d\n", size));
 19246:   return nsMemory::Alloc(size);
 19246: }
 19246: 
 19246: // Deprecated, only stubbed out
 19246: void* NP_CALLBACK /* OJI type: jref */
 19246: _getJavaPeer(NPP npp)
 19246: {
 19246:   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_GetJavaPeer: npp=%p\n", (void*)npp));
 19246:   return NULL;
 19246: }
 19246: 
 19246: void NP_CALLBACK
 19246: _pushpopupsenabledstate(NPP npp, NPBool enabled)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_pushpopupsenabledstate called from the wrong thread\n"));
 19246:     return;
 19246:   }
 38327:   nsNPAPIPluginInstance *inst = npp ? (nsNPAPIPluginInstance *)npp->ndata : NULL;
 19246:   if (!inst)
 19246:     return;
 19246: 
 19246:   inst->PushPopupsEnabledState(enabled);
 19246: }
 19246: 
 19246: void NP_CALLBACK
 19246: _poppopupsenabledstate(NPP npp)
 19246: {
 19246:   if (!NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("NPN_poppopupsenabledstate called from the wrong thread\n"));
 19246:     return;
 19246:   }
 38327:   nsNPAPIPluginInstance *inst = npp ? (nsNPAPIPluginInstance *)npp->ndata : NULL;
 19246:   if (!inst)
 19246:     return;
 19246: 
 19246:   inst->PopPopupsEnabledState();
 19246: }
 19246: 
 19246: void NP_CALLBACK
 19246: _pluginthreadasynccall(NPP instance, PluginThreadCallback func, void *userData)
 19246: {
 19246:   if (NS_IsMainThread()) {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,("NPN_pluginthreadasynccall called from the main thread\n"));
 19246:   } else {
 19246:     NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,("NPN_pluginthreadasynccall called from a non main thread\n"));
 19246:   }
 19246:   nsRefPtr<nsPluginThreadRunnable> evt =
 19246:     new nsPluginThreadRunnable(instance, func, userData);
 19246: 
 19246:   if (evt && evt->IsValid()) {
 19246:     NS_DispatchToMainThread(evt);
 19246:   }
 19246: }
 19246: 
 23571: NPError NP_CALLBACK
 23571: _getvalueforurl(NPP instance, NPNURLVariable variable, const char *url,
 23571:                 char **value, uint32_t *len)
 23571: {
 23571:   if (!instance) {
 23571:     return NPERR_INVALID_PARAM;
 23571:   }
 23571: 
 23571:   if (!url || !*url || !len) {
 23571:     return NPERR_INVALID_URL;
 23571:   }
 23571: 
 23571:   *len = 0;
 23571: 
 23571:   switch (variable) {
 23571:   case NPNURLVProxy:
 23571:     {
 70185:       nsCOMPtr<nsIPluginHost> pluginHostCOM(do_GetService(MOZ_PLUGIN_HOST_CONTRACTID));
 70185:       nsPluginHost *pluginHost = static_cast<nsPluginHost*>(pluginHostCOM.get());
 29574:       if (pluginHost && NS_SUCCEEDED(pluginHost->FindProxyForURL(url, value))) {
 23571:         *len = *value ? PL_strlen(*value) : 0;
 23571:         return NPERR_NO_ERROR;
 23571:       }
 23571:       break;
 23571:     }
 23571:   case NPNURLVCookie:
 23571:     {
 23571:       nsCOMPtr<nsICookieService> cookieService =
 23571:         do_GetService(NS_COOKIESERVICE_CONTRACTID);
 23571: 
 23571:       if (!cookieService)
 23571:         return NPERR_GENERIC_ERROR;
 23571: 
 23571:       // Make an nsURI from the url argument
 23571:       nsCOMPtr<nsIURI> uri;
 23571:       if (NS_FAILED(NS_NewURI(getter_AddRefs(uri), nsDependentCString(url)))) {
 23571:         return NPERR_GENERIC_ERROR;
 23571:       }
 23571: 
106838:       if (NS_FAILED(cookieService->GetCookieString(uri, nullptr, value)) ||
 42122:           !*value) {
 23571:         return NPERR_GENERIC_ERROR;
 23571:       }
 23571: 
 42122:       *len = PL_strlen(*value);
 23571:       return NPERR_NO_ERROR;
 23571:     }
 23571: 
 23571:     break;
 23571:   default:
 23571:     // Fall through and return an error...
 23571:     ;
 23571:   }
 23571: 
 23571:   return NPERR_GENERIC_ERROR;
 23571: }
 23571: 
 23571: NPError NP_CALLBACK
 23571: _setvalueforurl(NPP instance, NPNURLVariable variable, const char *url,
 23571:                 const char *value, uint32_t len)
 23571: {
 23571:   if (!instance) {
 23571:     return NPERR_INVALID_PARAM;
 23571:   }
 23571: 
 23571:   if (!url || !*url) {
 23571:     return NPERR_INVALID_URL;
 23571:   }
 23571: 
 23571:   switch (variable) {
 23571:   case NPNURLVCookie:
 23571:     {
 29204:       if (!url || !value || (0 >= len))
 29204:         return NPERR_INVALID_PARAM;
 29204: 
 29204:       nsresult rv = NS_ERROR_FAILURE;
 29204:       nsCOMPtr<nsIIOService> ioService(do_GetService(NS_IOSERVICE_CONTRACTID, &rv));
 29204:       if (NS_FAILED(rv))
 29204:         return NPERR_GENERIC_ERROR;
 29204: 
 29204:       nsCOMPtr<nsICookieService> cookieService = do_GetService(NS_COOKIESERVICE_CONTRACTID, &rv);
 29204:       if (NS_FAILED(rv))
 29204:         return NPERR_GENERIC_ERROR;
 29204: 
 29204:       nsCOMPtr<nsIURI> uriIn;
106838:       rv = ioService->NewURI(nsDependentCString(url), nullptr, nullptr, getter_AddRefs(uriIn));
 29204:       if (NS_FAILED(rv))
 29204:         return NPERR_GENERIC_ERROR;
 29204: 
 29204:       nsCOMPtr<nsIPrompt> prompt;
106838:       nsPluginHost::GetPrompt(nullptr, getter_AddRefs(prompt));
 29204: 
 29204:       char *cookie = (char*)value;
 29204:       char c = cookie[len];
 29204:       cookie[len] = '\0';
106838:       rv = cookieService->SetCookieString(uriIn, prompt, cookie, nullptr);
 29204:       cookie[len] = c;
 29204:       if (NS_SUCCEEDED(rv))
 23571:         return NPERR_NO_ERROR;
 23571:     }
 23571: 
 23571:     break;
 23571:   case NPNURLVProxy:
 23571:     // We don't support setting proxy values, fall through...
 23571:   default:
 23571:     // Fall through and return an error...
 23571:     ;
 23571:   }
 23571: 
 23571:   return NPERR_GENERIC_ERROR;
 23571: }
 23571: 
 23571: NPError NP_CALLBACK
 23571: _getauthenticationinfo(NPP instance, const char *protocol, const char *host,
 23571:                        int32_t port, const char *scheme, const char *realm,
 23571:                        char **username, uint32_t *ulen, char **password,
 23571:                        uint32_t *plen)
 23571: {
 23571:   if (!instance || !protocol || !host || !scheme || !realm || !username ||
 23571:       !ulen || !password || !plen)
 23571:     return NPERR_INVALID_PARAM;
 23571: 
106838:   *username = nullptr;
106838:   *password = nullptr;
 23571:   *ulen = 0;
 23571:   *plen = 0;
 23571: 
 23571:   nsDependentCString proto(protocol);
 23571: 
 23571:   if (!proto.LowerCaseEqualsLiteral("http") &&
 23571:       !proto.LowerCaseEqualsLiteral("https"))
 23571:     return NPERR_GENERIC_ERROR;
 23571: 
 23571:   nsCOMPtr<nsIHttpAuthManager> authManager =
 23571:     do_GetService("@mozilla.org/network/http-auth-manager;1");
 23571:   if (!authManager)
 23571:     return NPERR_GENERIC_ERROR;
 23571: 
 23571:   nsAutoString unused, uname16, pwd16;
 23571:   if (NS_FAILED(authManager->GetAuthIdentity(proto, nsDependentCString(host),
 23571:                                              port, nsDependentCString(scheme),
 23571:                                              nsDependentCString(realm),
 23571:                                              EmptyCString(), unused, uname16,
 23571:                                              pwd16))) {
 23571:     return NPERR_GENERIC_ERROR;
 23571:   }
 23571: 
 23571:   NS_ConvertUTF16toUTF8 uname8(uname16);
 23571:   NS_ConvertUTF16toUTF8 pwd8(pwd16);
 23571: 
 23571:   *username = ToNewCString(uname8);
 23571:   *ulen = *username ? uname8.Length() : 0;
 23571: 
 23571:   *password = ToNewCString(pwd8);
 23571:   *plen = *password ? pwd8.Length() : 0;
 23571: 
 23571:   return NPERR_NO_ERROR;
 23571: }
 23571: 
 29937: uint32_t NP_CALLBACK
 36125: _scheduletimer(NPP instance, uint32_t interval, NPBool repeat, PluginTimerFunc timerFunc)
 29937: {
 29937:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)instance->ndata;
 29937:   if (!inst)
 29937:     return 0;
 29937: 
 29937:   return inst->ScheduleTimer(interval, repeat, timerFunc);
 29937: }
 29937: 
 29937: void NP_CALLBACK
 29937: _unscheduletimer(NPP instance, uint32_t timerID)
 29937: {
 29937:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)instance->ndata;
 29937:   if (!inst)
 29937:     return;
 29937: 
 29937:   inst->UnscheduleTimer(timerID);
 29937: }
 29937: 
 32019: NPError NP_CALLBACK
 32019: _popupcontextmenu(NPP instance, NPMenu* menu)
 32019: {
 32019:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)instance->ndata;
 32019:   if (!inst)
 32019:     return NPERR_GENERIC_ERROR;
 32019: 
 32019:   return inst->PopUpContextMenu(menu);
 32019: }
 32019: 
 93035: NPError NP_CALLBACK
 93035: _initasyncsurface(NPP instance, NPSize *size, NPImageFormat format, void *initData, NPAsyncSurface *surface)
 93035: {
 93035:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)instance->ndata;
 93035:   if (!inst)
 93035:     return NPERR_GENERIC_ERROR;
 93035: 
 93035:   return inst->InitAsyncSurface(size, format, initData, surface);
 93035: }
 93035: 
 93035: NPError NP_CALLBACK
 93035: _finalizeasyncsurface(NPP instance, NPAsyncSurface *surface)
 93035: {
 93035:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)instance->ndata;
 93035:   if (!inst)
 93035:     return NPERR_GENERIC_ERROR;
 93035: 
 93035:   return inst->FinalizeAsyncSurface(surface);
 93035: }
 93035: 
 93035: void NP_CALLBACK
 93035: _setcurrentasyncsurface(NPP instance, NPAsyncSurface *surface, NPRect *changed)
 93035: {
 93035:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)instance->ndata;
 93035:   if (!inst)
 93035:     return;
 93035: 
 93035:   inst->SetCurrentAsyncSurface(surface, changed);
 93035: }
 93035: 
 32019: NPBool NP_CALLBACK
 32019: _convertpoint(NPP instance, double sourceX, double sourceY, NPCoordinateSpace sourceSpace, double *destX, double *destY, NPCoordinateSpace destSpace)
 32019: {
 32019:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)instance->ndata;
 32019:   if (!inst)
 79533:     return false;
 32019: 
 32019:   return inst->ConvertPoint(sourceX, sourceY, sourceSpace, destX, destY, destSpace);
 32019: }
 32019: 
 60021: void NP_CALLBACK
 60021: _urlredirectresponse(NPP instance, void* notifyData, NPBool allow)
 60021: {
 60021:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance *)instance->ndata;
 60021:   if (!inst) {
 60021:     return;
 60021:   }
 60021: 
 60021:   inst->URLRedirectResponse(notifyData, allow);
 60021: }
 60021: 
 36125: } /* namespace parent */
 36125: } /* namespace plugins */
 36125: } /* namespace mozilla */
