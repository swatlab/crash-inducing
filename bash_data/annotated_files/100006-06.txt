 29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 18308:  * vim: set ts=8 sw=4 et tw=79:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 80966: #ifndef BytecodeEmitter_h__
 80966: #define BytecodeEmitter_h__
 80506: 
     1: /*
     1:  * JS bytecode generation.
     1:  */
     1: #include "jstypes.h"
     1: #include "jsatom.h"
     1: #include "jsopcode.h"
  1825: #include "jsscript.h"
     1: #include "jsprvtd.h"
     1: #include "jspubtd.h"
     1: 
 80506: #include "frontend/Parser.h"
 72579: #include "frontend/ParseMaps.h"
 98180: #include "frontend/TreeContext.h"
 72579: 
 95355: #include "vm/ScopeObject.h"
 95355: 
 80631: namespace js {
     1: 
     1: /*
 80631:  * To reuse space in StmtInfo, rename breaks and continues for use during
     1:  * try/catch/finally code generation and backpatching. To match most common
     1:  * use cases, the macro argument is a struct, not a struct pointer. Only a
     1:  * loop, switch, or label statement info record can have breaks and continues,
     1:  * and only a for loop has an update backpatch chain, so it's safe to overlay
 80631:  * these for the "trying" StmtTypes.
     1:  */
     1: #define CATCHNOTE(stmt)  ((stmt).update)
     1: #define GOSUBS(stmt)     ((stmt).breaks)
     1: #define GUARDJUMP(stmt)  ((stmt).continues)
     1: 
 80631: struct TryNode {
  3025:     JSTryNote       note;
 80631:     TryNode       *prev;
  3025: };
  3025: 
 80631: struct CGObjectList {
 84755:     uint32_t            length;     /* number of emitted so far objects */
 80631:     ObjectBox           *lastbox;   /* last emitted object */
  3235: 
 80631:     CGObjectList() : length(0), lastbox(NULL) {}
  3235: 
100006:     unsigned index(ObjectBox *objbox);
 97362:     void finish(ObjectArray *array);
 27012: };
     1: 
 80631: class GCConstList {
 80631:     Vector<Value> list;
 48470:   public:
 80631:     GCConstList(JSContext *cx) : list(cx) {}
 97296:     bool append(Value v) { JS_ASSERT_IF(v.isString(), v.toString()->isAtom()); return list.append(v); }
 48470:     size_t length() const { return list.length(); }
 97362:     void finish(ConstArray *array);
 48470: };
 48470: 
 80991: struct GlobalScope {
 98173:     GlobalScope(JSContext *cx, JSObject *globalObj)
 98173:       : globalObj(cx, globalObj)
 80991:     { }
 80991: 
 99421:     RootedObject globalObj;
 80991: };
 80991: 
 98445: struct BytecodeEmitter
 27012: {
 98445:     SharedContext   *sc;            /* context shared between parsing and bytecode generation */
 98445: 
 98445:     BytecodeEmitter *parent;        /* enclosing function or global context */
 98445: 
     1:     struct {
     1:         jsbytecode  *base;          /* base of JS bytecode vector */
     1:         jsbytecode  *limit;         /* one byte beyond end of bytecode */
     1:         jsbytecode  *next;          /* pointer to next free bytecode */
     1:         jssrcnote   *notes;         /* source notes, see below */
 91237:         unsigned    noteCount;      /* number of source notes so far */
 91237:         unsigned    noteLimit;      /* limit number for source notes in notePool */
     1:         ptrdiff_t   lastNoteOffset; /* code offset for last source note */
 91237:         unsigned    currentLine;    /* line number for tree-based srcnote gen */
     1:     } prolog, main, *current;
     1: 
 98181:     Parser          *parser;        /* the parser */
 98181: 
 80631:     OwnedAtomIndexMapPtr atomIndices; /* literals indexed for mapping */
 91237:     unsigned        firstLine;      /* first line, for JSScript::NewScriptFromEmitter */
     1: 
 91237:     int             stackDepth;     /* current stack depth in script frame */
 91237:     unsigned        maxStackDepth;  /* maximum stack depth so far */
     1: 
 91237:     unsigned        ntrynotes;      /* number of allocated so far try notes */
 80631:     TryNode         *lastTryNode;   /* the last allocated try node */
     1: 
 91237:     unsigned        arrayCompDepth; /* stack depth of array in comprehension */
     1: 
 91237:     unsigned        emitLevel;      /* js::frontend::EmitTree recursion level */
 41867: 
 80631:     typedef HashMap<JSAtom *, Value> ConstMap;
 41867:     ConstMap        constMap;       /* compile time constants */
  3235: 
 80631:     GCConstList     constList;      /* constants to be included with the script */
 48470: 
 80631:     CGObjectList    objectList;     /* list of emitted objects */
 80631:     CGObjectList    regexpList;     /* list of emitted regexp that will be
 27012:                                        cloned during execution */
  3235: 
 80990:     GlobalScope     *globalScope;   /* frontend::CompileScript global scope, or null */
 80990: 
 54840:     /* Vectors of pn_cookie slot values. */
 84755:     typedef Vector<uint32_t, 8> SlotVector;
 54840:     SlotVector      closedArgs;
 54840:     SlotVector      closedVars;
 54840: 
 84755:     uint16_t        typesetCount;   /* Number of JOF_TYPESET opcodes generated */
 56217: 
 98463:     /* These two should only be true if sc->inFunction() is false. */
 98463:     const bool      noScriptRval:1;     /* The caller is JS_Compile*Script*. */
 98463:     const bool      needScriptGlobal:1; /* API caller does not want result value
 98463:                                            from global script. */
 98463: 
 98479:     bool            hasSingletons:1;    /* script contains singleton initializer JSOP_OBJECT */
 98479: 
 98463:     BytecodeEmitter(Parser *parser, SharedContext *sc, unsigned lineno,
 98463:                     bool noScriptRval, bool needScriptGlobal);
 98445:     bool init();
 98175: 
 27012:     /*
 80966:      * Note that BytecodeEmitters are magic: they own the arena "top-of-stack"
 80966:      * space above their tempMark points. This means that you cannot alloc from
 80966:      * tempLifoAlloc and save the pointer beyond the next BytecodeEmitter
 80743:      * destructor call.
 27012:      */
 80966:     ~BytecodeEmitter();
 32729: 
 61450:     JSVersion version() const { return parser->versionWithFlags(); }
 54840: 
 95101:     bool isAliasedName(ParseNode *pn);
 80631:     bool shouldNoteClosedName(ParseNode *pn);
 95098:     bool noteClosedVar(ParseNode *pn);
 95098:     bool noteClosedArg(ParseNode *pn);
 59962: 
 72579:     JS_ALWAYS_INLINE
 72579:     bool makeAtomIndex(JSAtom *atom, jsatomid *indexp) {
 80631:         AtomIndexAddPtr p = atomIndices->lookupForAdd(atom);
 72579:         if (p) {
 72579:             *indexp = p.value();
 72579:             return true;
 72579:         }
 72579: 
 72579:         jsatomid index = atomIndices->count();
 72579:         if (!atomIndices->add(p, atom, index))
 72579:             return false;
 72579: 
 72579:         *indexp = index;
 72579:         return true;
 72579:     }
 72579: 
 59962:     bool checkSingletonContext() {
 98476:         if (!parser->compileAndGo || sc->inFunction)
 59962:             return false;
 98445:         for (StmtInfo *stmt = sc->topStmt; stmt; stmt = stmt->down) {
 59962:             if (STMT_IS_LOOP(stmt))
 59962:                 return false;
 59962:         }
 98479:         hasSingletons = true;
 59962:         return true;
 59962:     }
 80966: 
 86855:     bool needsImplicitThis();
 86855: 
 80966:     TokenStream *tokenStream() { return &parser->tokenStream; }
 80966: 
 80966:     jsbytecode *base() const { return current->base; }
 80966:     jsbytecode *limit() const { return current->limit; }
 80966:     jsbytecode *next() const { return current->next; }
 80966:     jsbytecode *code(ptrdiff_t offset) const { return base() + offset; }
 80966:     ptrdiff_t offset() const { return next() - base(); }
 80966:     jsbytecode *prologBase() const { return prolog.base; }
 80966:     ptrdiff_t prologOffset() const { return prolog.next - prolog.base; }
 80966:     void switchToMain() { current = &main; }
 80966:     void switchToProlog() { current = &prolog; }
 80966: 
 80966:     jssrcnote *notes() const { return current->notes; }
 91237:     unsigned noteCount() const { return current->noteCount; }
 91237:     unsigned noteLimit() const { return current->noteLimit; }
 80966:     ptrdiff_t lastNoteOffset() const { return current->lastNoteOffset; }
 91237:     unsigned currentLine() const { return current->currentLine; }
 80966: 
 80966:     inline ptrdiff_t countFinalSourceNotes();
     1: };
     1: 
 80632: namespace frontend {
 80631: 
     1: /*
     1:  * Emit one bytecode.
     1:  */
 80631: ptrdiff_t
 80966: Emit1(JSContext *cx, BytecodeEmitter *bce, JSOp op);
     1: 
     1: /*
     1:  * Emit two bytecodes, an opcode (op) with a byte of immediate operand (op1).
     1:  */
 80631: ptrdiff_t
 80966: Emit2(JSContext *cx, BytecodeEmitter *bce, JSOp op, jsbytecode op1);
     1: 
     1: /*
     1:  * Emit three bytecodes, an opcode with two bytes of immediate operands.
     1:  */
 80631: ptrdiff_t
 80966: Emit3(JSContext *cx, BytecodeEmitter *bce, JSOp op, jsbytecode op1, jsbytecode op2);
     1: 
     1: /*
     1:  * Emit (1 + extra) bytecodes, for N bytes of op and its immediate operand.
     1:  */
 80631: ptrdiff_t
 80966: EmitN(JSContext *cx, BytecodeEmitter *bce, JSOp op, size_t extra);
     1: 
     1: /*
 80966:  * Like PopStatementTC(bce), also patch breaks and continues unless the top
 27012:  * statement info record represents a try-catch-finally suite. May fail if a
 27012:  * jump offset overflows.
     1:  */
 80631: JSBool
 80966: PopStatementBCE(JSContext *cx, BytecodeEmitter *bce);
     1: 
     1: /*
     1:  * Define and lookup a primitive jsval associated with the const named by atom.
 80632:  * DefineCompileTimeConstant analyzes the constant-folded initializer at pn
 80966:  * and saves the const's value in bce->constList, if it can be used at compile
     1:  * time. It returns true unless an error occurred.
     1:  *
 80632:  * If the initializer's value could not be saved, DefineCompileTimeConstant
 80632:  * calls will return the undefined value. DefineCompileTimeConstant tries
     1:  * to find a const value memorized for atom, returning true with *vp set to a
     1:  * value other than undefined if the constant was found, true with *vp set to
     1:  * JSVAL_VOID if not found, and false on error.
     1:  */
 80631: JSBool
 80966: DefineCompileTimeConstant(JSContext *cx, BytecodeEmitter *bce, JSAtom *atom, ParseNode *pn);
     1: 
     1: /*
 80966:  * Emit code into bce for the tree rooted at pn.
     1:  */
 80631: JSBool
 80966: EmitTree(JSContext *cx, BytecodeEmitter *bce, ParseNode *pn);
     1: 
     1: /*
 80966:  * Emit function code using bce for the tree rooted at body.
     1:  */
 80631: JSBool
 80966: EmitFunctionScript(JSContext *cx, BytecodeEmitter *bce, ParseNode *body);
 80631: 
 80632: } /* namespace frontend */
     1: 
     1: /*
     1:  * Source notes generated along with bytecode for decompiling and debugging.
 84755:  * A source note is a uint8_t with 5 bits of type and 3 of offset from the pc
 84755:  * of the previous note. If 3 bits of offset aren't enough, extended delta
 84755:  * notes (SRC_XDELTA) consisting of 2 set high order bits followed by 6 offset
 84755:  * bits are emitted before the next note. Some notes have operand offsets
 84755:  * encoded immediately after them, in note bytes or byte-triples.
     1:  *
     1:  *                 Source Note               Extended Delta
     1:  *              +7-6-5-4-3+2-1-0+           +7-6-5+4-3-2-1-0+
     1:  *              |note-type|delta|           |1 1| ext-delta |
     1:  *              +---------+-----+           +---+-----------+
     1:  *
     1:  * At most one "gettable" note (i.e., a note of type other than SRC_NEWLINE,
     1:  * SRC_SETLINE, and SRC_XDELTA) applies to a given bytecode.
     1:  *
 80966:  * NB: the js_SrcNoteSpec array in BytecodeEmitter.cpp is indexed by this
 80632:  * enum, so its initializers need to match the order here.
     1:  *
     1:  * Note on adding new source notes: every pair of bytecodes (A, B) where A and
     1:  * B have disjoint sets of source notes that could apply to each bytecode may
     1:  * reuse the same note type value for two notes (snA, snB) that have the same
 86877:  * arity in JSSrcNoteSpec. This is why SRC_IF and SRC_INITPROP have the same
 86877:  * value below.
     1:  *
 94006:  * Don't forget to update XDR_BYTECODE_VERSION in vm/Xdr.h for all such
     1:  * incompatible source note or other bytecode changes.
     1:  */
 80631: enum SrcNoteType {
     1:     SRC_NULL        = 0,        /* terminates a note vector */
     1:     SRC_IF          = 1,        /* JSOP_IFEQ bytecode is from an if-then */
 18603:     SRC_BREAK       = 1,        /* JSOP_GOTO is a break */
     1:     SRC_INITPROP    = 1,        /* disjoint meaning applied to JSOP_INITELEM or
     1:                                    to an index label in a regular (structuring)
     1:                                    or a destructuring object initialiser */
 27012:     SRC_GENEXP      = 1,        /* JSOP_LAMBDA from generator expression */
     1:     SRC_IF_ELSE     = 2,        /* JSOP_IFEQ bytecode is from an if-then-else */
 20943:     SRC_FOR_IN      = 2,        /* JSOP_GOTO to for-in loop condition from
 20943:                                    before loop (same arity as SRC_IF_ELSE) */
 20943:     SRC_FOR         = 3,        /* JSOP_NOP or JSOP_POP in for(;;) loop head */
 20943:     SRC_WHILE       = 4,        /* JSOP_GOTO to for or while loop condition
 20943:                                    from before loop, else JSOP_NOP at top of
 20943:                                    do-while loop */
     1:     SRC_CONTINUE    = 5,        /* JSOP_GOTO is a continue, not a break;
 86078:                                    JSOP_ENDINIT needs extra comma at end of
 86078:                                    array literal: [1,2,,];
 86078:                                    JSOP_DUP continuing destructuring pattern;
 86078:                                    JSOP_POP at end of for-in */
     1:     SRC_DECL        = 6,        /* type of a declaration (var, const, let*) */
     1:     SRC_DESTRUCT    = 6,        /* JSOP_DUP starting a destructuring assignment
     1:                                    operation, with SRC_DECL_* offset operand */
     1:     SRC_PCDELTA     = 7,        /* distance forward from comma-operator to
     1:                                    next POP, or from CONDSWITCH to first CASE
     1:                                    opcode, etc. -- always a forward delta */
     1:     SRC_GROUPASSIGN = 7,        /* SRC_DESTRUCT variant for [a, b] = [c, d] */
 86078:     SRC_DESTRUCTLET = 7,        /* JSOP_DUP starting a destructuring let
 86078:                                    operation, with offset to JSOP_ENTERLET0 */
     1:     SRC_ASSIGNOP    = 8,        /* += or another assign-op follows */
     1:     SRC_COND        = 9,        /* JSOP_IFEQ is from conditional ?: operator */
     1:     SRC_BRACE       = 10,       /* mandatory brace, for scope or to avoid
     1:                                    dangling else */
     1:     SRC_HIDDEN      = 11,       /* opcode shouldn't be decompiled */
     1:     SRC_PCBASE      = 12,       /* distance back from annotated getprop or
     1:                                    setprop op to left-most obj.prop.subprop
     1:                                    bytecode -- always a backward delta */
 82079:     SRC_LABEL       = 13,       /* JSOP_LABEL for label: with atomid immediate */
 82079:     SRC_LABELBRACE  = 14,       /* JSOP_LABEL for label: {...} begin brace */
     1:     SRC_ENDBRACE    = 15,       /* JSOP_NOP for label: {...} end brace */
     1:     SRC_BREAK2LABEL = 16,       /* JSOP_GOTO for 'break label' with atomid */
     1:     SRC_CONT2LABEL  = 17,       /* JSOP_GOTO for 'continue label' with atomid */
     1:     SRC_SWITCH      = 18,       /* JSOP_*SWITCH with offset to end of switch,
     1:                                    2nd off to first JSOP_CASE if condswitch */
 73877:     SRC_SWITCHBREAK = 18,       /* JSOP_GOTO is a break in a switch */
     1:     SRC_FUNCDEF     = 19,       /* JSOP_NOP for function f() with atomid */
     1:     SRC_CATCH       = 20,       /* catch block has guard */
 86876:                                 /* 21 is unused */
     1:     SRC_NEWLINE     = 22,       /* bytecode follows a source newline */
     1:     SRC_SETLINE     = 23,       /* a file-absolute source line number note */
     1:     SRC_XDELTA      = 24        /* 24-31 are for extended delta notes */
 80631: };
 80631: 
     1: /*
 86877:  * Constants for the SRC_DECL source note.
     1:  *
     1:  * NB: the var_prefix array in jsopcode.c depends on these dense indexes from
     1:  * SRC_DECL_VAR through SRC_DECL_LET.
     1:  */
     1: #define SRC_DECL_VAR            0
     1: #define SRC_DECL_CONST          1
     1: #define SRC_DECL_LET            2
     1: #define SRC_DECL_NONE           3
     1: 
     1: #define SN_TYPE_BITS            5
     1: #define SN_DELTA_BITS           3
     1: #define SN_XDELTA_BITS          6
     1: #define SN_TYPE_MASK            (JS_BITMASK(SN_TYPE_BITS) << SN_DELTA_BITS)
     1: #define SN_DELTA_MASK           ((ptrdiff_t)JS_BITMASK(SN_DELTA_BITS))
     1: #define SN_XDELTA_MASK          ((ptrdiff_t)JS_BITMASK(SN_XDELTA_BITS))
     1: 
     1: #define SN_MAKE_NOTE(sn,t,d)    (*(sn) = (jssrcnote)                          \
     1:                                           (((t) << SN_DELTA_BITS)             \
     1:                                            | ((d) & SN_DELTA_MASK)))
     1: #define SN_MAKE_XDELTA(sn,d)    (*(sn) = (jssrcnote)                          \
     1:                                           ((SRC_XDELTA << SN_DELTA_BITS)      \
     1:                                            | ((d) & SN_XDELTA_MASK)))
     1: 
     1: #define SN_IS_XDELTA(sn)        ((*(sn) >> SN_DELTA_BITS) >= SRC_XDELTA)
 80631: #define SN_TYPE(sn)             ((js::SrcNoteType)(SN_IS_XDELTA(sn)           \
  3164:                                                    ? SRC_XDELTA               \
  3164:                                                    : *(sn) >> SN_DELTA_BITS))
     1: #define SN_SET_TYPE(sn,type)    SN_MAKE_NOTE(sn, type, SN_DELTA(sn))
     1: #define SN_IS_GETTABLE(sn)      (SN_TYPE(sn) < SRC_NEWLINE)
     1: 
     1: #define SN_DELTA(sn)            ((ptrdiff_t)(SN_IS_XDELTA(sn)                 \
     1:                                              ? *(sn) & SN_XDELTA_MASK         \
     1:                                              : *(sn) & SN_DELTA_MASK))
     1: #define SN_SET_DELTA(sn,delta)  (SN_IS_XDELTA(sn)                             \
     1:                                  ? SN_MAKE_XDELTA(sn, delta)                  \
     1:                                  : SN_MAKE_NOTE(sn, SN_TYPE(sn), delta))
     1: 
     1: #define SN_DELTA_LIMIT          ((ptrdiff_t)JS_BIT(SN_DELTA_BITS))
     1: #define SN_XDELTA_LIMIT         ((ptrdiff_t)JS_BIT(SN_XDELTA_BITS))
     1: 
     1: /*
     1:  * Offset fields follow certain notes and are frequency-encoded: an offset in
     1:  * [0,0x7f] consumes one byte, an offset in [0x80,0x7fffff] takes three, and
     1:  * the high bit of the first byte is set.
     1:  */
     1: #define SN_3BYTE_OFFSET_FLAG    0x80
     1: #define SN_3BYTE_OFFSET_MASK    0x7f
     1: 
 86078: #define SN_MAX_OFFSET ((size_t)((ptrdiff_t)SN_3BYTE_OFFSET_FLAG << 16) - 1)
 86078: 
     1: #define SN_LENGTH(sn)           ((js_SrcNoteSpec[SN_TYPE(sn)].arity == 0) ? 1 \
     1:                                  : js_SrcNoteLength(sn))
     1: #define SN_NEXT(sn)             ((sn) + SN_LENGTH(sn))
     1: 
     1: /* A source note array is terminated by an all-zero element. */
     1: #define SN_MAKE_TERMINATOR(sn)  (*(sn) = SRC_NULL)
     1: #define SN_IS_TERMINATOR(sn)    (*(sn) == SRC_NULL)
     1: 
 80632: namespace frontend {
 80632: 
     1: /*
 80966:  * Append a new source note of the given type (and therefore size) to bce's
 80966:  * notes dynamic array, updating bce->noteCount. Return the new note's index
 80966:  * within the array pointed at by bce->current->notes. Return -1 if out of
     1:  * memory.
     1:  */
 91237: int
 80966: NewSrcNote(JSContext *cx, BytecodeEmitter *bce, SrcNoteType type);
     1: 
 91237: int
 80966: NewSrcNote2(JSContext *cx, BytecodeEmitter *bce, SrcNoteType type, ptrdiff_t offset);
     1: 
 91237: int
 80966: NewSrcNote3(JSContext *cx, BytecodeEmitter *bce, SrcNoteType type, ptrdiff_t offset1,
 80631:                ptrdiff_t offset2);
     1: 
     1: /*
     1:  * NB: this function can add at most one extra extended delta note.
     1:  */
 80631: jssrcnote *
 80966: AddToSrcNoteDelta(JSContext *cx, BytecodeEmitter *bce, jssrcnote *sn, ptrdiff_t delta);
 80966: 
 80966: JSBool
 80966: FinishTakingSrcNotes(JSContext *cx, BytecodeEmitter *bce, jssrcnote *notes);
 80966: 
 80966: void
 97362: FinishTakingTryNotes(BytecodeEmitter *bce, TryNoteArray *array);
 80966: 
 80966: } /* namespace frontend */
     1: 
     1: /*
     1:  * Finish taking source notes in cx's notePool, copying final notes to the new
     1:  * stable store allocated by the caller and passed in via notes. Return false
     1:  * on malloc failure, which means this function reported an error.
     1:  *
 80966:  * Use this to compute the number of jssrcnotes to allocate and pass in via
 80966:  * notes. This method knows a lot about details of FinishTakingSrcNotes, so
 80966:  * DON'T CHANGE js::frontend::FinishTakingSrcNotes WITHOUT CHECKING WHETHER
 80966:  * THIS METHOD NEEDS CORRESPONDING CHANGES!
     1:  */
 80966: inline ptrdiff_t
 80966: BytecodeEmitter::countFinalSourceNotes()
 80966: {
 80966:     ptrdiff_t diff = prologOffset() - prolog.lastNoteOffset;
 80966:     ptrdiff_t cnt = prolog.noteCount + main.noteCount + 1;
 80966:     if (prolog.noteCount && prolog.currentLine != firstLine) {
 80966:         if (diff > SN_DELTA_MASK)
 80966:             cnt += JS_HOWMANY(diff - SN_DELTA_MASK, SN_XDELTA_MASK);
 80966:         cnt += 2 + ((firstLine > SN_3BYTE_OFFSET_MASK) << 1);
 80966:     } else if (diff > 0) {
 80966:         if (main.noteCount) {
 80966:             jssrcnote *sn = main.notes;
 80966:             diff -= SN_IS_XDELTA(sn)
 80966:                     ? SN_XDELTA_MASK - (*sn & SN_XDELTA_MASK)
 80966:                     : SN_DELTA_MASK - (*sn & SN_DELTA_MASK);
 80966:         }
 80966:         if (diff > 0)
 80966:             cnt += JS_HOWMANY(diff, SN_XDELTA_MASK);
 80966:     }
 80966:     return cnt;
 80966: }
     1: 
 86078: /*
 86078:  * To avoid offending js_SrcNoteSpec[SRC_DECL].arity, pack the two data needed
 86078:  * to decompile let into one ptrdiff_t:
 86078:  *   offset: offset to the LEAVEBLOCK(EXPR) op (not including ENTER/LEAVE)
 86078:  *   groupAssign: whether this was an optimized group assign ([x,y] = [a,b])
 86078:  */
 86078: inline ptrdiff_t PackLetData(size_t offset, bool groupAssign)
 86078: {
 86078:     JS_ASSERT(offset <= (size_t(-1) >> 1));
 86078:     return ptrdiff_t(offset << 1) | ptrdiff_t(groupAssign);
 86078: }
 86078: 
 86078: inline size_t LetDataToOffset(ptrdiff_t w)
 86078: {
 86078:     return size_t(w) >> 1;
 86078: }
 86078: 
 86078: inline bool LetDataToGroupAssign(ptrdiff_t w)
 86078: {
 86078:     return size_t(w) & 1;
 86078: }
 86078: 
 80632: } /* namespace js */
 80632: 
 80632: struct JSSrcNoteSpec {
 80632:     const char      *name;      /* name for disassembly/debugging output */
 84755:     int8_t          arity;      /* number of offset operands */
 80632: };
 80632: 
 80632: extern JS_FRIEND_DATA(JSSrcNoteSpec)  js_SrcNoteSpec[];
 91237: extern JS_FRIEND_API(unsigned)         js_SrcNoteLength(jssrcnote *sn);
 80632: 
 80632: /*
 80632:  * Get and set the offset operand identified by which (0 for the first, etc.).
 80632:  */
 80632: extern JS_FRIEND_API(ptrdiff_t)
 91237: js_GetSrcNoteOffset(jssrcnote *sn, unsigned which);
     1: 
 80966: #endif /* BytecodeEmitter_h__ */
