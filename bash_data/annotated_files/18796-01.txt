    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1:  
    1: /**
    1:  * MODULE NOTES:
    1:  * @update  gess7/30/98
    1:  *
    1:  * Much as I hate to do it, we were using string compares wrong.
    1:  * Often, programmers call functions like strcmp(s1,s2), and pass
    1:  * one or more null strings. Rather than blow up on these, I've 
    1:  * added quick checks to ensure that cases like this don't cause
    1:  * us to fail.
    1:  *
    1:  * In general, if you pass a null into any of these string compare
    1:  * routines, we simply return 0.
    1:  */
    1: 
    1: 
    1: #include "nsCRT.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsCharTraits.h"
11667: #include "prbit.h"
    1: 
    1: #define ADD_TO_HASHVAL(hashval, c) \
11667:     hashval = PR_ROTATE_LEFT32(hashval, 4) ^ (c);
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: 
    1: ////////////////////////////////////////////////////////////////////////////////
    1: // My lovely strtok routine
    1: 
    1: #define IS_DELIM(m, c)          ((m)[(c) >> 3] & (1 << ((c) & 7)))
    1: #define SET_DELIM(m, c)         ((m)[(c) >> 3] |= (1 << ((c) & 7)))
    1: #define DELIM_TABLE_SIZE        32
    1: 
    1: char* nsCRT::strtok(char* string, const char* delims, char* *newStr)
    1: {
    1:   NS_ASSERTION(string, "Unlike regular strtok, the first argument cannot be null.");
    1: 
    1:   char delimTable[DELIM_TABLE_SIZE];
    1:   PRUint32 i;
    1:   char* result;
    1:   char* str = string;
    1: 
    1:   for (i = 0; i < DELIM_TABLE_SIZE; i++)
    1:     delimTable[i] = '\0';
    1: 
    1:   for (i = 0; delims[i]; i++) {
 3233:     SET_DELIM(delimTable, static_cast<PRUint8>(delims[i]));
    1:   }
    1:   NS_ASSERTION(delims[i] == '\0', "too many delimiters");
    1: 
    1:   // skip to beginning
 3233:   while (*str && IS_DELIM(delimTable, static_cast<PRUint8>(*str))) {
    1:     str++;
    1:   }
    1:   result = str;
    1: 
    1:   // fix up the end of the token
    1:   while (*str) {
 3233:     if (IS_DELIM(delimTable, static_cast<PRUint8>(*str))) {
    1:       *str++ = '\0';
    1:       break;
    1:     }
    1:     str++;
    1:   }
    1:   *newStr = str;
    1: 
    1:   return str == result ? NULL : result;
    1: }
    1: 
    1: ////////////////////////////////////////////////////////////////////////////////
    1: 
    1: /**
    1:  * Compare unichar string ptrs, stopping at the 1st null 
    1:  * NOTE: If both are null, we return 0.
    1:  * NOTE: We terminate the search upon encountering a NULL
    1:  *
    1:  * @update  gess 11/10/99
    1:  * @param   s1 and s2 both point to unichar strings
    1:  * @return  0 if they match, -1 if s1<s2; 1 if s1>s2
    1:  */
    1: PRInt32 nsCRT::strcmp(const PRUnichar* s1, const PRUnichar* s2) {
    1:   if(s1 && s2) {
    1:     for (;;) {
    1:       PRUnichar c1 = *s1++;
    1:       PRUnichar c2 = *s2++;
    1:       if (c1 != c2) {
    1:         if (c1 < c2) return -1;
    1:         return 1;
    1:       }
    1:       if ((0==c1) || (0==c2)) break;
    1:     }
    1:   }
    1:   else {
    1:     if (s1)                     // s2 must have been null
    1:       return -1;
    1:     if (s2)                     // s1 must have been null
    1:       return 1;
    1:   }
    1:   return 0;
    1: }
    1: 
    1: /**
    1:  * Compare unichar string ptrs, stopping at the 1st null or nth char.
    1:  * NOTE: If either is null, we return 0.
    1:  * NOTE: We DO NOT terminate the search upon encountering NULL's before N
    1:  *
    1:  * @update  gess 11/10/99
    1:  * @param   s1 and s2 both point to unichar strings
    1:  * @return  0 if they match, -1 if s1<s2; 1 if s1>s2
    1:  */
    1: PRInt32 nsCRT::strncmp(const PRUnichar* s1, const PRUnichar* s2, PRUint32 n) {
    1:   if(s1 && s2) { 
    1:     if(n != 0) {
    1:       do {
    1:         PRUnichar c1 = *s1++;
    1:         PRUnichar c2 = *s2++;
    1:         if (c1 != c2) {
    1:           if (c1 < c2) return -1;
    1:           return 1;
    1:         }
    1:       } while (--n != 0);
    1:     }
    1:   }
    1:   return 0;
    1: }
    1: 
    1: PRUnichar* nsCRT::strdup(const PRUnichar* str)
    1: {
    1:   PRUint32 len = nsCRT::strlen(str);
    1:   return strndup(str, len);
    1: }
    1: 
    1: PRUnichar* nsCRT::strndup(const PRUnichar* str, PRUint32 len)
    1: {
    1: 	nsCppSharedAllocator<PRUnichar> shared_allocator;
    1: 	PRUnichar* rslt = shared_allocator.allocate(len + 1); // add one for the null
    1:   // PRUnichar* rslt = new PRUnichar[len + 1];
    1: 
    1:   if (rslt == NULL) return NULL;
    1:   memcpy(rslt, str, len * sizeof(PRUnichar));
    1:   rslt[len] = 0;
    1:   return rslt;
    1: }
    1: 
    1:   /**
    1:    * |nsCRT::HashCode| is identical to |PL_HashString|, which tests
    1:    *  (http://bugzilla.mozilla.org/showattachment.cgi?attach_id=26596)
    1:    *  show to be the best hash among several other choices.
    1:    *
    1:    * We re-implement it here rather than calling it for two reasons:
    1:    *  (1) in this interface, we also calculate the length of the
    1:    *  string being hashed; and (2) the narrow and wide and `buffer' versions here
    1:    *  will hash equivalent strings to the same value, e.g., "Hello" and L"Hello".
    1:    */
    1: PRUint32 nsCRT::HashCode(const char* str, PRUint32* resultingStrLen)
    1: {
    1:   PRUint32 h = 0;
    1:   const char* s = str;
    1: 
    1:   if (!str) return h;
    1: 
    1:   unsigned char c;
    1:   while ( (c = *s++) )
    1:     ADD_TO_HASHVAL(h, c);
    1: 
    1:   if ( resultingStrLen )
    1:     *resultingStrLen = (s-str)-1;
    1:   return h;
    1: }
    1: 
 3351: PRUint32 nsCRT::HashCode(const char* start, PRUint32 length)
 3351: {
 3351:   PRUint32 h = 0;
 3351:   const char* s = start;
 3351:   const char* end = start + length;
 3351: 
 3351:   unsigned char c;
 3351:   while ( s < end ) {
 3351:     c = *s++;
 3351:     ADD_TO_HASHVAL(h, c);
 3351:   }
 3351: 
 3351:   return h;
 3351: }
 3351: 
    1: PRUint32 nsCRT::HashCode(const PRUnichar* str, PRUint32* resultingStrLen)
    1: {
    1:   PRUint32 h = 0;
    1:   const PRUnichar* s = str;
    1: 
    1:   if (!str) return h;
    1: 
    1:   PRUnichar c;
    1:   while ( (c = *s++) )
    1:     ADD_TO_HASHVAL(h, c);
    1: 
    1:   if ( resultingStrLen )
    1:     *resultingStrLen = (s-str)-1;
    1:   return h;
    1: }
    1: 
 3351: PRUint32 nsCRT::HashCodeAsUTF8(const PRUnichar* start, PRUint32 length)
    1: {
    1:   PRUint32 h = 0;
 3351:   const PRUnichar* s = start;
 3351:   const PRUnichar* end = start + length;
    1: 
    1:   PRUint16 W1 = 0;      // the first UTF-16 word in a two word tuple
    1:   PRUint32 U = 0;       // the current char as UCS-4
    1:   int code_length = 0;  // the number of bytes in the UTF-8 sequence for the current char
    1: 
    1:   PRUint16 W;
 3351:   while ( s < end )
    1:     {
 3351:       W = *s++;
    1:         /*
    1:          * On the fly, decoding from UTF-16 (and/or UCS-2) into UTF-8 as per
    1:          *  http://www.ietf.org/rfc/rfc2781.txt
    1:          *  http://www.ietf.org/rfc/rfc3629.txt
    1:          */
    1: 
    1:       if ( !W1 )
    1:         {
    1:           if ( !IS_SURROGATE(W) )
    1:             {
    1:               U = W;
    1:               if ( W <= 0x007F )
    1:                 code_length = 1;
    1:               else if ( W <= 0x07FF )
    1:                 code_length = 2;
    1:               else
    1:                 code_length = 3;
    1:             }
 3351:           else if ( NS_IS_HIGH_SURROGATE(W) && s < end)
 3351:             {
    1:               W1 = W;
 3351: 
 3351:               continue;
 3351:             }
 3351:           else
 3351:             {
 3351:               // Treat broken characters as the Unicode replacement
 3351:               // character 0xFFFD
 3351:               U = 0xFFFD;
 3351: 
 3351:               code_length = 3;
 3351: 
 3351:               NS_WARNING("Got low surrogate but no previous high surrogate");
 3351:             }
    1:         }
    1:       else
    1:         {
    1:           // as required by the standard, this code is careful to
    1:           // throw out illegal sequences
    1: 
    1:           if ( NS_IS_LOW_SURROGATE(W) )
    1:             {
    1:               U = SURROGATE_TO_UCS4(W1, W);
    1:               NS_ASSERTION(IS_VALID_CHAR(U), "How did this happen?");
    1:               code_length = 4;
    1:             }
 3351:           else
 3351:             {
 3351:               // Treat broken characters as the Unicode replacement
 3351:               // character 0xFFFD
 3351:               U = 0xFFFD;
 3351: 
 3351:               code_length = 3;
 3351: 
 3351:               NS_WARNING("High surrogate not followed by low surrogate");
18796: 
18796:               // The pointer to the next character points to the second 16-bit
18796:               // value, not beyond it, as per Unicode 5.0.0 Chapter 3 C10, only
18796:               // the first code unit of an illegal sequence must be treated as
18796:               // an illegally terminated code unit sequence (also Chapter 3
18796:               // D91, "isolated [not paired and ill-formed] UTF-16 code units
18796:               // in the range D800..DFFF are ill-formed").
18796:               --s;
 3351:             }
 3351: 
    1:           W1 = 0;
    1:         }
    1: 
    1: 
    1:       static const PRUint16 sBytePrefix[5]  = { 0x0000, 0x0000, 0x00C0, 0x00E0, 0x00F0  };
    1:       static const PRUint16 sShift[5]       = { 0, 0, 6, 12, 18 };
    1: 
    1:       /*
 3351:        *  Unlike the algorithm in
 3351:        *  http://www.ietf.org/rfc/rfc3629.txt we must calculate the
 3351:        *  bytes in left to right order so that our hash result
 3351:        *  matches what the narrow version would calculate on an
 3351:        *  already UTF-8 string.
    1:        */
    1: 
    1:       // hash the first (and often, only, byte)
 3351:       ADD_TO_HASHVAL(h, (sBytePrefix[code_length] | (U>>sShift[code_length])));
    1: 
 3351:       // an unrolled loop for hashing any remaining bytes in this
 3351:       // sequence
    1:       switch ( code_length )
    1:         {  // falling through in each case
    1:           case 4:   ADD_TO_HASHVAL(h, (0x80 | ((U>>12) & 0x003F)));
    1:           case 3:   ADD_TO_HASHVAL(h, (0x80 | ((U>>6 ) & 0x003F)));
    1:           case 2:   ADD_TO_HASHVAL(h, (0x80 | ( U      & 0x003F)));
    1:           default:  code_length = 0;
    1:             break;
    1:         }
    1:     }
    1: 
    1:   return h;
    1: }
    1: 
    1: PRUint32 nsCRT::BufferHashCode(const PRUnichar* s, PRUint32 len)
    1: {
    1:   PRUint32 h = 0;
    1:   const PRUnichar* done = s + len;
    1: 
    1:   while ( s < done )
11667:     h = PR_ROTATE_LEFT32(h, 4) ^ PRUint16(*s++); // cast to unsigned to prevent possible sign extension
    1:   return h;
    1: }
    1: 
    1: // This should use NSPR but NSPR isn't exporting its PR_strtoll function
    1: // Until then...
    1: PRInt64 nsCRT::atoll(const char *str)
    1: {
    1:     if (!str)
    1:         return LL_Zero();
    1: 
    1:     PRInt64 ll = LL_Zero(), digitll = LL_Zero();
    1: 
    1:     while (*str && *str >= '0' && *str <= '9') {
    1:         LL_MUL(ll, ll, 10);
    1:         LL_UI2L(digitll, (*str - '0'));
    1:         LL_ADD(ll, ll, digitll);
    1:         str++;
    1:     }
    1: 
    1:     return ll;
    1: }
    1: 
