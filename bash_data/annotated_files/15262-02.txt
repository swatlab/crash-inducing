    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2003
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Original Author: Aaron Leventhal (aaronl@netscape.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef _nsDocAccessible_H_
    1: #define _nsDocAccessible_H_
    1: 
  966: #include "nsHyperTextAccessibleWrap.h"
    1: #include "nsIAccessibleDocument.h"
    1: #include "nsPIAccessibleDocument.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDocumentObserver.h"
    1: #include "nsIEditor.h"
    1: #include "nsIObserver.h"
    1: #include "nsIScrollPositionListener.h"
    1: #include "nsITimer.h"
    1: #include "nsIWeakReference.h"
    1: #include "nsCOMArray.h"
    1: #include "nsIDocShellTreeNode.h"
    1: 
    1: class nsIScrollableView;
    1: 
    1: const PRUint32 kDefaultCacheSize = 256;
    1: 
  966: class nsDocAccessible : public nsHyperTextAccessibleWrap,
    1:                         public nsIAccessibleDocument,
    1:                         public nsPIAccessibleDocument,
    1:                         public nsIDocumentObserver,
    1:                         public nsIObserver,
    1:                         public nsIScrollPositionListener,
    1:                         public nsSupportsWeakReference
    1: {  
    1:   NS_DECL_ISUPPORTS_INHERITED
    1:   NS_DECL_NSIACCESSIBLEDOCUMENT
    1:   NS_DECL_NSPIACCESSIBLEDOCUMENT
    1:   NS_DECL_NSIOBSERVER
    1: 
    1:   public:
    1:     nsDocAccessible(nsIDOMNode *aNode, nsIWeakReference* aShell);
    1:     virtual ~nsDocAccessible();
    1: 
    1:     NS_IMETHOD GetRole(PRUint32 *aRole);
13094:     NS_IMETHOD SetRoleMapEntry(nsRoleMapEntry* aRoleMapEntry);
    1:     NS_IMETHOD GetName(nsAString& aName);
 3018:     NS_IMETHOD GetDescription(nsAString& aDescription);
13094:     NS_IMETHOD GetARIAState(PRUint32 *aState);
  262:     NS_IMETHOD GetState(PRUint32 *aState, PRUint32 *aExtraState);
13094:     NS_IMETHOD GetAttributes(nsIPersistentProperties **aAttributes);
    1:     NS_IMETHOD GetFocusedChild(nsIAccessible **aFocusedChild);
    1:     NS_IMETHOD GetParent(nsIAccessible **aParent);
    1:     NS_IMETHOD TakeFocus(void);
    1: 
    1:     // ----- nsIScrollPositionListener ---------------------------
    1:     NS_IMETHOD ScrollPositionWillChange(nsIScrollableView *aView, nscoord aX, nscoord aY);
    1:     NS_IMETHOD ScrollPositionDidChange(nsIScrollableView *aView, nscoord aX, nscoord aY);
    1: 
    1:     // nsIDocumentObserver
    1:     NS_DECL_NSIDOCUMENTOBSERVER
    1: 
    1:     static void FlushEventsCallback(nsITimer *aTimer, void *aClosure);
    1: 
    1:     // nsIAccessNode
    1:     NS_IMETHOD Shutdown();
    1:     NS_IMETHOD Init();
    1: 
    1:     // nsPIAccessNode
    1:     NS_IMETHOD_(nsIFrame *) GetFrame(void);
    1: 
 4625:     // nsIAccessibleText
 4625:     NS_IMETHOD GetAssociatedEditor(nsIEditor **aEditor);
 4625: 
 4516:     /**
 4516:       * Non-virtual method to fire a delayed event after a 0 length timeout
 4516:       *
 5395:       * @param aEvent - the nsIAccessibleEvent event type
 4516:       * @param aDOMNode - DOM node the accesible event should be fired for
 4637:       * @param aAllowDupes - eAllowDupes: more than one event of the same type is allowed. 
 4637:       *                      eCoalesceFromSameSubtree: if two events are in the same subtree,
 4637:       *                                                only the event on ancestor is used
 4637:       *                      eRemoveDupes (default): events of the same type are discarded
 4637:       *                                              (the last one is used)
 4637:       *
11858:       * @param aIsAsynch - set to PR_TRUE if this is not being called from code
 4516:       *                    synchronous with a DOM event
 4516:       */
    1:     nsresult FireDelayedToolkitEvent(PRUint32 aEvent, nsIDOMNode *aDOMNode,
13167:                                      nsAccEvent::EEventRule aAllowDupes = nsAccEvent::eRemoveDupes,
 4516:                                      PRBool aIsAsynch = PR_FALSE);
  577: 
  577:     /**
  577:      * Fire accessible event in timeout.
  577:      *
 4516:      * @param aEvent - the event to fire
  577:      */
13167:     nsresult FireDelayedAccessibleEvent(nsIAccessibleEvent *aEvent);
  577: 
    1:     void ShutdownChildDocuments(nsIDocShellTreeItem *aStart);
    1: 
    1:   protected:
    1:     virtual void GetBoundsRect(nsRect& aRect, nsIFrame** aRelativeFrame);
    1:     virtual nsresult AddEventListeners();
    1:     virtual nsresult RemoveEventListeners();
    1:     void AddScrollListener();
    1:     void RemoveScrollListener();
11165: 
11165:     /**
11165:      * For any accessibles in this subtree, invalidate their knowledge of
11165:      * their children. Only weak refrences are destroyed, not accessibles.
11165:      * @param aStartNode  The root of the subrtee to invalidate accessible child refs in
11165:      */
11165:     void InvalidateChildrenInSubtree(nsIDOMNode *aStartNode);
 4516:     void RefreshNodes(nsIDOMNode *aStartNode);
    1:     static void ScrollTimerCallback(nsITimer *aTimer, void *aClosure);
    1: 
  577:     /**
 6065:      * Fires accessible events when attribute is changed.
 6065:      *
 6065:      * @param aContent - node that attribute is changed for
 6065:      * @param aNameSpaceID - namespace of changed attribute
 6065:      * @param aAttribute - changed attribute
 6065:      */
 6065:     void AttributeChangedImpl(nsIContent* aContent, PRInt32 aNameSpaceID, nsIAtom* aAttribute);
 6065: 
 6065:     /**
 6065:      * Fires accessible events when ARIA attribute is changed.
  577:      *
  577:      * @param aContent - node that attribute is changed for
  577:      * @param aAttribute - changed attribute
  577:      */
  577:     void ARIAAttributeChanged(nsIContent* aContent, nsIAtom* aAttribute);
  577: 
 3950:     /**
 5681:      * Fire text changed event for character data changed. The method is used
 5681:      * from nsIMutationObserver methods.
 5681:      *
 5681:      * @param aContent     the text node holding changed data
 5681:      * @param aInfo        info structure describing how the data was changed
 5681:      * @param aIsInserted  the flag pointed whether removed or inserted
 5681:      *                     characters should be cause of event
 3950:      */
 5681:     void FireTextChangeEventForText(nsIContent *aContent,
 5681:                                     CharacterDataChangeInfo* aInfo,
 5681:                                     PRBool aIsInserted);
 3950: 
 3950:     /**
 5395:      * Create a text change event for a changed node
 5395:      * @param aContainerAccessible, the first accessible in the container
 5395:      * @param aChangeNode, the node that is being inserted or removed, or shown/hidden
 5395:      * @param aAccessibleForChangeNode, the accessible for that node, or nsnull if none exists
 5395:      * @param aIsInserting, is aChangeNode being created or shown (vs. removed or hidden)
 3950:      */
 5395:     already_AddRefed<nsIAccessibleTextChangeEvent>
 5398:     CreateTextChangeEventForNode(nsIAccessible *aContainerAccessible,
 5395:                                  nsIDOMNode *aChangeNode,
 5395:                                  nsIAccessible *aAccessibleForNode,
 5395:                                  PRBool aIsInserting,
 5395:                                  PRBool aIsAsynch);
 3950: 
 6700:     /**
 6700:      * Fire show/hide events for either the current node if it has an accessible,
 6700:      * or the first-line accessible descendants of the given node.
 6700:      *
 6700:      * @param aDOMNode               the given node
 6700:      * @param aEventType             event type to fire an event
11439:      * @param aAvoidOnThisNode       Call with PR_TRUE the first time to prevent event firing on root node for change
 6700:      * @param aDelay                 whether to fire the event on a delay
 6700:      * @param aForceIsFromUserInput  the event is known to be from user input
 6700:      */
11439:     nsresult FireShowHideEvents(nsIDOMNode *aDOMNode, PRBool aAvoidOnThisNode, PRUint32 aEventType,
 6700:                                 PRBool aDelay, PRBool aForceIsFromUserInput);
 6700: 
13353:     /**
13353:      * If the given accessible object is a ROLE_ENTRY, fire a value change event for it
13353:      */
13353:     void FireValueChangeForTextFields(nsIAccessible *aPossibleTextFieldAccessible);
13353: 
 3466:     nsAccessNodeHashtable mAccessNodeCache;
    1:     void *mWnd;
    1:     nsCOMPtr<nsIDocument> mDocument;
    1:     nsCOMPtr<nsITimer> mScrollWatchTimer;
    1:     nsCOMPtr<nsITimer> mFireEventTimer;
    1:     PRUint16 mScrollPositionChangedTicks; // Used for tracking scroll events
    1:     PRPackedBool mIsContentLoaded;
12254:     PRPackedBool mIsLoadCompleteFired;
    1:     nsCOMArray<nsIAccessibleEvent> mEventsToFire;
    1: 
    1: protected:
    1:     PRBool mIsAnchor;
    1:     PRBool mIsAnchorJumped;
15262:     PRBool mInFlushPendingEvents;
 6065:     static PRUint32 gLastFocusedAccessiblesState;
11439:     static nsIAtom *gLastFocusedFrameType;
    1: };
    1: 
    1: #endif  
