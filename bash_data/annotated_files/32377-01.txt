    1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   John Bandhauer <jband@netscape.com> (original author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* Call context. */
    1: 
    1: #include "xpcprivate.h"
    1: 
    1: XPCCallContext::XPCCallContext(XPCContext::LangType callerLanguage,
    1:                                JSContext* cx    /* = nsnull  */,
    1:                                JSObject* obj    /* = nsnull  */,
    1:                                JSObject* funobj /* = nsnull  */,
    1:                                jsval name       /* = 0       */,
    1:                                uintN argc       /* = NO_ARGS */,
    1:                                jsval *argv      /* = nsnull  */,
    1:                                jsval *rval      /* = nsnull  */)
    1:     :   mState(INIT_FAILED),
    1:         mXPC(nsXPConnect::GetXPConnect()),
    1:         mThreadData(nsnull),
    1:         mXPCContext(nsnull),
    1:         mJSContext(cx),
    1:         mContextPopRequired(JS_FALSE),
    1:         mDestroyJSContextInDestructor(JS_FALSE),
    1:         mCallerLanguage(callerLanguage),
    1:         mCallee(nsnull)
    1: {
31395:     Init(callerLanguage, callerLanguage == NATIVE_CALLER, obj, funobj, JS_TRUE,
31395:          name, argc, argv, rval);
31395: }
31395: 
31395: XPCCallContext::XPCCallContext(XPCContext::LangType callerLanguage,
31395:                                JSContext* cx,
31395:                                JSBool callBeginRequest,
31395:                                JSObject* obj,
31395:                                JSObject* currentJSObject,
31395:                                XPCWrappedNative* wrapper,
31395:                                XPCWrappedNativeTearOff* tearOff)
31395:     :   mState(INIT_FAILED),
31395:         mXPC(nsXPConnect::GetXPConnect()),
31395:         mThreadData(nsnull),
31395:         mXPCContext(nsnull),
31395:         mJSContext(cx),
31395:         mContextPopRequired(JS_FALSE),
31395:         mDestroyJSContextInDestructor(JS_FALSE),
31395:         mCallerLanguage(callerLanguage),
31395:         mCurrentJSObject(currentJSObject),
31395:         mWrapper(wrapper),
31395:         mTearOff(tearOff),
31395:         mCallee(nsnull)
31395: {
31395:     Init(callerLanguage, callBeginRequest, obj, nsnull, JS_FALSE, 0, NO_ARGS,
31395:          nsnull, nsnull);
31395: }
31395: 
31395: void
31395: XPCCallContext::Init(XPCContext::LangType callerLanguage,
31395:                      JSBool callBeginRequest,
31395:                      JSObject* obj,
31395:                      JSObject* funobj,
31395:                      JSBool getWrappedNative,
31395:                      jsval name,
31395:                      uintN argc,
31395:                      jsval *argv,
31395:                      jsval *rval)
31395: {
 9363:     // Mark our internal string wrappers as not used. Make sure we do
 9363:     // this before any early returns, as the destructor will assert
 9363:     // based on this.
 9363:     StringWrapperEntry *se =
 9363:         reinterpret_cast<StringWrapperEntry*>(&mStringWrapperData);
 9363: 
 9363:     PRUint32 i;
 9363:     for(i = 0; i < XPCCCX_STRING_CACHE_SIZE; ++i)
 9363:     {
 9363:         se[i].mInUse = PR_FALSE;
 9363:     }
 9363: 
    1:     if(!mXPC)
    1:         return;
    1: 
10490:     mThreadData = XPCPerThreadData::GetData(mJSContext);
10490: 
10490:     if(!mThreadData)
    1:         return;
    1: 
    1:     XPCJSContextStack* stack = mThreadData->GetJSContextStack();
    1:     JSContext* topJSContext;
    1: 
    1:     if(!stack || NS_FAILED(stack->Peek(&topJSContext)))
    1:     {
27029:         // If we don't have a stack we're probably in shutdown.
27029:         NS_ASSERTION(!stack, "Bad, Peek failed!");
    1:         mJSContext = nsnull;
    1:         return;
    1:     }
    1: 
    1:     if(!mJSContext)
    1:     {
    1:         // This is slightly questionable. If called without an explicit
    1:         // JSContext (generally a call to a wrappedJS) we will use the JSContext
    1:         // on the top of the JSContext stack - if there is one - *before*
    1:         // falling back on the safe JSContext.
    1:         // This is good AND bad because it makes calls from JS -> native -> JS
    1:         // have JS stack 'continuity' for purposes of stack traces etc.
    1:         // Note: this *is* what the pre-XPCCallContext xpconnect did too.
    1: 
    1:         if(topJSContext)
    1:             mJSContext = topJSContext;
    1:         else if(NS_FAILED(stack->GetSafeJSContext(&mJSContext)) || !mJSContext)
    1:             return;
    1:     }
    1: 
    1:     // Get into the request as early as we can to avoid problems with scanning
    1:     // callcontexts on other threads from within the gc callbacks.
    1: 
31395:     NS_ASSERTION(!callBeginRequest || mCallerLanguage == NATIVE_CALLER,
31395:                  "Don't call JS_BeginRequest unless the caller is native.");
31395:     if(callBeginRequest)
    1:         JS_BeginRequest(mJSContext);
    1: 
    1:     if(topJSContext != mJSContext)
    1:     {
    1:         if(NS_FAILED(stack->Push(mJSContext)))
    1:         {
    1:             NS_ERROR("bad!");
    1:             return;
    1:         }
    1:         mContextPopRequired = JS_TRUE;
    1:     }
    1: 
20312:     mXPCContext = XPCContext::GetXPCContext(mJSContext);
    1:     mPrevCallerLanguage = mXPCContext->SetCallingLangType(mCallerLanguage);
    1: 
    1:     // hook into call context chain for our thread
    1:     mPrevCallContext = mThreadData->SetCallContext(this);
    1: 
25050:     // We only need to addref xpconnect once so only do it if this is the first
25050:     // context in the chain.
25050:     if(!mPrevCallContext)
25050:         NS_ADDREF(mXPC);
25050: 
    1:     mState = HAVE_CONTEXT;
    1: 
    1:     if(!obj)
    1:         return;
    1: 
    1:     mMethodIndex = 0xDEAD;
    1:     mOperandJSObject = obj;
    1: 
    1:     mState = HAVE_OBJECT;
    1: 
    1:     mTearOff = nsnull;
31395: 
31395:     if(getWrappedNative)
    1:         mWrapper = XPCWrappedNative::GetWrappedNativeOfJSObject(mJSContext, obj,
    1:                                                                 funobj,
    1:                                                                 &mCurrentJSObject,
    1:                                                                 &mTearOff);
30001:     if(mWrapper)
30001:     {
    1:         DEBUG_CheckWrapperThreadSafety(mWrapper);
    1: 
    1:         mFlattenedJSObject = mWrapper->GetFlatJSObject();
    1: 
    1:         if(mTearOff)
    1:             mScriptableInfo = nsnull;
    1:         else
    1:             mScriptableInfo = mWrapper->GetScriptableInfo();
30001:     }
30001:     else
30001:     {
30001:         if(!mCurrentJSObject)
30001:             return;
30001: 
30001:         NS_ASSERTION(IS_SLIM_WRAPPER(mCurrentJSObject),
30001:                      "What kind of wrapper is this?");
30001: 
30001:         mFlattenedJSObject = mCurrentJSObject;
30001:     }
    1: 
    1:     if(name)
    1:         SetName(name);
    1: 
    1:     if(argc != NO_ARGS)
    1:         SetArgsAndResultPtr(argc, argv, rval);
    1: 
    1:     CHECK_STATE(HAVE_OBJECT);
    1: }
    1: 
    1: void
    1: XPCCallContext::SetName(jsval name)
    1: {
    1:     CHECK_STATE(HAVE_OBJECT);
    1: 
    1:     mName = name;
    1: 
    1: #ifdef XPC_IDISPATCH_SUPPORT
    1:     mIDispatchMember = nsnull;
    1: #endif
    1:     if(mTearOff)
    1:     {
    1:         mSet = nsnull;
    1:         mInterface = mTearOff->GetInterface();
    1:         mMember = mInterface->FindMember(name);
    1:         mStaticMemberIsLocal = JS_TRUE;
    1:         if(mMember && !mMember->IsConstant())
    1:             mMethodIndex = mMember->GetIndex();
    1:     }
    1:     else
    1:     {
    1:         mSet = mWrapper ? mWrapper->GetSet() : nsnull;
    1: 
    1:         if(mSet &&
    1:            mSet->FindMember(name, &mMember, &mInterface,
    1:                             mWrapper->HasProto() ?
    1:                                 mWrapper->GetProto()->GetSet() :
    1:                                 nsnull,
    1:                             &mStaticMemberIsLocal))
    1:         {
    1:             if(mMember && !mMember->IsConstant())
    1:                 mMethodIndex = mMember->GetIndex();
    1:         }
    1:         else
    1:         {
    1:             mMember = nsnull;
    1:             mInterface = nsnull;
    1:             mStaticMemberIsLocal = JS_FALSE;
    1:         }
    1:     }
    1: 
    1:     mState = HAVE_NAME;
    1: }
    1: 
    1: void
    1: XPCCallContext::SetCallInfo(XPCNativeInterface* iface, XPCNativeMember* member,
    1:                             JSBool isSetter)
    1: {
27029:     CHECK_STATE(HAVE_CONTEXT);
27029: 
    1:     // We are going straight to the method info and need not do a lookup
    1:     // by id.
    1: 
    1:     // don't be tricked if method is called with wrong 'this'
    1:     if(mTearOff && mTearOff->GetInterface() != iface)
    1:         mTearOff = nsnull;
    1: 
    1:     mSet = nsnull;
    1:     mInterface = iface;
    1:     mMember = member;
    1:     mMethodIndex = mMember->GetIndex() + (isSetter ? 1 : 0);
    1:     mName = mMember->GetName();
    1: 
    1:     if(mState < HAVE_NAME)
    1:         mState = HAVE_NAME;
    1: #ifdef XPC_IDISPATCH_SUPPORT
    1:     mIDispatchMember = nsnull;
    1: #endif
    1: }
    1: 
    1: void
    1: XPCCallContext::SetArgsAndResultPtr(uintN argc,
    1:                                     jsval *argv,
    1:                                     jsval *rval)
    1: {
    1:     CHECK_STATE(HAVE_OBJECT);
    1: 
32377:     if(mState < HAVE_NAME)
32377:     {
32377:         mSet = nsnull;
32377:         mInterface = nsnull;
32377:         mMember = nsnull;
32377: #ifdef XPC_IDISPATCH_SUPPORT
32377:         mIDispatchMember = nsnull;
32377: #endif
32377:         mStaticMemberIsLocal = JS_FALSE;
32377:     }
32377: 
    1:     mArgc   = argc;
    1:     mArgv   = argv;
    1:     mRetVal = rval;
    1: 
18540:     mReturnValueWasSet = JS_FALSE;
    1:     mState = HAVE_ARGS;
    1: }
    1: 
    1: nsresult
    1: XPCCallContext::CanCallNow()
    1: {
    1:     nsresult rv;
    1:     
    1:     if(!HasInterfaceAndMember())
    1:         return NS_ERROR_UNEXPECTED;
    1:     if(mState < HAVE_ARGS)
    1:         return NS_ERROR_UNEXPECTED;
    1: 
    1:     if(!mTearOff)
    1:     {
    1:         mTearOff = mWrapper->FindTearOff(*this, mInterface, JS_FALSE, &rv);
    1:         if(!mTearOff || mTearOff->GetInterface() != mInterface)
    1:         {
    1:             mTearOff = nsnull;    
    1:             return NS_FAILED(rv) ? rv : NS_ERROR_UNEXPECTED;
    1:         }
    1:     }
    1: 
    1:     // Refresh in case FindTearOff extended the set
    1:     mSet = mWrapper->GetSet();
    1: 
    1:     mState = READY_TO_CALL;
    1:     return NS_OK;
    1: }
    1: 
    1: void
    1: XPCCallContext::SystemIsBeingShutDown()
    1: {
    1:     // XXX This is pretty questionable since the per thread cleanup stuff
    1:     // can be making this call on one thread for call contexts on another
    1:     // thread.
    1:     NS_WARNING("Shutting Down XPConnect even through there is a live XPCCallContext");
    1:     mThreadData = nsnull;
    1:     mXPCContext = nsnull;
    1:     mState = SYSTEM_SHUTDOWN;
    1:     if(mPrevCallContext)
    1:         mPrevCallContext->SystemIsBeingShutDown();
    1: }
    1: 
    1: XPCCallContext::~XPCCallContext()
    1: {
    1:     // do cleanup...
    1: 
25050:     PRBool shouldReleaseXPC = PR_FALSE;
25050: 
    1:     if(mXPCContext)
    1:     {
    1:         mXPCContext->SetCallingLangType(mPrevCallerLanguage);
    1: 
    1: #ifdef DEBUG
    1:         XPCCallContext* old = mThreadData->SetCallContext(mPrevCallContext);
    1:         NS_ASSERTION(old == this, "bad pop from per thread data");
    1: #else
    1:         (void) mThreadData->SetCallContext(mPrevCallContext);
    1: #endif
25050: 
25050:         shouldReleaseXPC = mPrevCallContext == nsnull;
    1:     }
    1: 
    1:     if(mContextPopRequired)
    1:     {
    1:         XPCJSContextStack* stack = mThreadData->GetJSContextStack();
    1:         NS_ASSERTION(stack, "bad!");
    1:         if(stack)
    1:         {
    1: #ifdef DEBUG
    1:             JSContext* poppedCX;
    1:             nsresult rv = stack->Pop(&poppedCX);
    1:             NS_ASSERTION(NS_SUCCEEDED(rv) && poppedCX == mJSContext, "bad pop");
    1: #else
    1:             (void) stack->Pop(nsnull);
    1: #endif
    1:         }
    1:     }
    1: 
    1:     if(mJSContext)
    1:     {
    1:         if(mCallerLanguage == NATIVE_CALLER)
    1:             JS_EndRequest(mJSContext);
    1:         
    1:         if(mDestroyJSContextInDestructor)
    1:         {
    1: #ifdef DEBUG_xpc_hacker
28502:             printf("!xpc - doing deferred destruction of JSContext @ %p\n", 
    1:                    mJSContext);
    1: #endif
    1:             NS_ASSERTION(!mThreadData->GetJSContextStack() || 
    1:                          !mThreadData->GetJSContextStack()->
    1:                             DEBUG_StackHasJSContext(mJSContext),
    1:                          "JSContext still in threadjscontextstack!");
    1:         
    1:             JS_DestroyContext(mJSContext);
    1:         }
    1:         else
    1:         {
    1:             // Don't clear newborns if JS frames (compilation or execution)
    1:             // are active!  Doing so violates ancient invariants in the JS
    1:             // engine, and it's not necessary to fix JS component leaks.
22652:             if(!JS_IsRunning(mJSContext))
    1:                 JS_ClearNewbornRoots(mJSContext);
    1:         }
    1:     }
    1: 
 9332: #ifdef DEBUG
 9332:     {
 9332:         StringWrapperEntry *se =
 9332:             reinterpret_cast<StringWrapperEntry*>(&mStringWrapperData);
 9332: 
 9332:         PRUint32 i;
 9332:         for(i = 0; i < XPCCCX_STRING_CACHE_SIZE; ++i)
 9332:         {
 9332:             NS_ASSERTION(!se[i].mInUse, "Uh, string wrapper still in use!");
 9332:         }
 9332:     }
 9334: #endif
 9332: 
25050:     if(shouldReleaseXPC && mXPC)
25050:         NS_RELEASE(mXPC);
    1: }
    1: 
 9332: XPCReadableJSStringWrapper *
 9332: XPCCallContext::NewStringWrapper(PRUnichar *str, PRUint32 len)
 9332: {
 9332:     StringWrapperEntry *se =
 9332:         reinterpret_cast<StringWrapperEntry*>(&mStringWrapperData);
 9332: 
 9332:     PRUint32 i;
 9332:     for(i = 0; i < XPCCCX_STRING_CACHE_SIZE; ++i)
 9332:     {
 9332:         StringWrapperEntry& ent = se[i];
 9332: 
10490:         if(!ent.mInUse)
10490:         {
 9332:             ent.mInUse = PR_TRUE;
 9332: 
 9332:             // Construct the string using placement new.
 9332: 
 9332:             return new (&ent.mString) XPCReadableJSStringWrapper(str, len);
 9332:         }
 9332:     }
 9332: 
 9332:     // All our internal string wrappers are used, allocate a new string.
 9332: 
 9332:     return new XPCReadableJSStringWrapper(str, len);
 9332: }
 9332: 
 9332: void
 9332: XPCCallContext::DeleteString(nsAString *string)
 9332: {
 9332:     StringWrapperEntry *se =
 9332:         reinterpret_cast<StringWrapperEntry*>(&mStringWrapperData);
 9332: 
 9332:     PRUint32 i;
 9332:     for(i = 0; i < XPCCCX_STRING_CACHE_SIZE; ++i)
 9332:     {
 9332:         StringWrapperEntry& ent = se[i];
 9332:         if(string == &ent.mString)
 9332:         {
 9332:             // One of our internal strings is no longer in use, mark
 9332:             // it as such and destroy the string.
 9332: 
 9332:             ent.mInUse = PR_FALSE;
 9332:             ent.mString.~XPCReadableJSStringWrapper();
 9332: 
 9332:             return;
 9332:         }
 9332:     }
 9332: 
 9332:     // We're done with a string that's not one of our internal
 9332:     // strings, delete it.
 9332:     delete string;
 9332: }
 9332: 
    1: /* readonly attribute nsISupports Callee; */
    1: NS_IMETHODIMP
    1: XPCCallContext::GetCallee(nsISupports * *aCallee)
    1: {
    1:     nsISupports* temp = mWrapper ? mWrapper->GetIdentityObject() : nsnull;
    1:     NS_IF_ADDREF(temp);
    1:     *aCallee = temp;
    1:     return NS_OK;
    1: }
    1: 
    1: /* readonly attribute PRUint16 CalleeMethodIndex; */
    1: NS_IMETHODIMP
    1: XPCCallContext::GetCalleeMethodIndex(PRUint16 *aCalleeMethodIndex)
    1: {
    1:     *aCalleeMethodIndex = mMethodIndex;
    1:     return NS_OK;
    1: }
    1: 
    1: /* readonly attribute nsIXPConnectWrappedNative CalleeWrapper; */
    1: NS_IMETHODIMP
    1: XPCCallContext::GetCalleeWrapper(nsIXPConnectWrappedNative * *aCalleeWrapper)
    1: {
    1:     nsIXPConnectWrappedNative* temp = mWrapper;
    1:     NS_IF_ADDREF(temp);
    1:     *aCalleeWrapper = temp;
    1:     return NS_OK;
    1: }
    1: 
    1: /* readonly attribute XPCNativeInterface CalleeInterface; */
    1: NS_IMETHODIMP
    1: XPCCallContext::GetCalleeInterface(nsIInterfaceInfo * *aCalleeInterface)
    1: {
    1:     nsIInterfaceInfo* temp = mInterface->GetInterfaceInfo();
    1:     NS_IF_ADDREF(temp);
    1:     *aCalleeInterface = temp;
    1:     return NS_OK;
    1: }
    1: 
    1: /* readonly attribute nsIClassInfo CalleeClassInfo; */
    1: NS_IMETHODIMP
    1: XPCCallContext::GetCalleeClassInfo(nsIClassInfo * *aCalleeClassInfo)
    1: {
    1:     nsIClassInfo* temp = mWrapper ? mWrapper->GetClassInfo() : nsnull;
    1:     NS_IF_ADDREF(temp);
    1:     *aCalleeClassInfo = temp;
    1:     return NS_OK;
    1: }
    1: 
    1: /* readonly attribute JSContextPtr JSContext; */
    1: NS_IMETHODIMP
    1: XPCCallContext::GetJSContext(JSContext * *aJSContext)
    1: {
    1:     *aJSContext = mJSContext;
    1:     return NS_OK;
    1: }
    1: 
    1: /* readonly attribute PRUint32 Argc; */
    1: NS_IMETHODIMP
    1: XPCCallContext::GetArgc(PRUint32 *aArgc)
    1: {
    1:     *aArgc = (PRUint32) mArgc;
    1:     return NS_OK;
    1: }
    1: 
    1: /* readonly attribute JSValPtr ArgvPtr; */
    1: NS_IMETHODIMP
    1: XPCCallContext::GetArgvPtr(jsval * *aArgvPtr)
    1: {
    1:     *aArgvPtr = mArgv;
    1:     return NS_OK;
    1: }
    1: 
    1: /* readonly attribute JSValPtr RetValPtr; */
    1: NS_IMETHODIMP
    1: XPCCallContext::GetRetValPtr(jsval * *aRetValPtr)
    1: {
    1:     *aRetValPtr = mRetVal;
    1:     return NS_OK;
    1: }
    1: 
    1: /* attribute PRBool ReturnValueWasSet; */
    1: NS_IMETHODIMP
    1: XPCCallContext::GetReturnValueWasSet(PRBool *aReturnValueWasSet)
    1: {
    1:     *aReturnValueWasSet = mReturnValueWasSet;
    1:     return NS_OK;
    1: }
    1: NS_IMETHODIMP
    1: XPCCallContext::SetReturnValueWasSet(PRBool aReturnValueWasSet)
    1: {
    1:     mReturnValueWasSet = aReturnValueWasSet;
    1:     return NS_OK;
    1: }
    1: 
    1: #ifdef XPC_IDISPATCH_SUPPORT
    1: 
    1: void
    1: XPCCallContext::SetIDispatchInfo(XPCNativeInterface* iface, 
    1:                                  void * member)
    1: {
27029:     CHECK_STATE(HAVE_CONTEXT);
27029: 
    1:     // We are going straight to the method info and need not do a lookup
    1:     // by id.
    1: 
    1:     // don't be tricked if method is called with wrong 'this'
    1:     if(mTearOff && mTearOff->GetInterface() != iface)
    1:         mTearOff = nsnull;
    1: 
    1:     mSet = nsnull;
    1:     mInterface = iface;
    1:     mMember = nsnull;
    1:     mIDispatchMember = member;
 3233:     mName = reinterpret_cast<XPCDispInterface::Member*>(member)->GetName();
    1: 
    1:     if(mState < HAVE_NAME)
    1:         mState = HAVE_NAME;
    1: }
    1: 
    1: #endif
20343: 
20343: NS_IMETHODIMP
20343: XPCCallContext::GetPreviousCallContext(nsAXPCNativeCallContext **aResult)
20343: {
20343:   NS_ENSURE_ARG_POINTER(aResult);
20343:   *aResult = GetPrevCallContext();
20343:   return NS_OK;
20343: }
20343: 
20343: NS_IMETHODIMP
20343: XPCCallContext::GetLanguage(PRUint16 *aResult)
20343: {
20343:   NS_ENSURE_ARG_POINTER(aResult);
20343:   *aResult = GetCallerLanguage();
20343:   return NS_OK;
20343: }
31395: 
31395: #ifdef DEBUG
31395: // static
31395: void
31395: XPCLazyCallContext::AssertContextIsTopOfStack(JSContext* cx)
31395: {
31395:     XPCPerThreadData* tls = XPCPerThreadData::GetData(cx);
31395:     XPCJSContextStack* stack = tls->GetJSContextStack();
31395: 
31395:     JSContext* topJSContext;
31395:     nsresult rv = stack->Peek(&topJSContext);
31395:     NS_ASSERTION(NS_SUCCEEDED(rv), "XPCJSContextStack::Peek failed");
31395: 
31395:     NS_ASSERTION(cx == topJSContext, "wrong context on XPCJSContextStack!");
31395: }
31395: #endif
