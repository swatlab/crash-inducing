    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Brian Ryner <bryner@brianryner.com>
    1:  *   Kai Engert <kengert@redhat.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef _NSNSSIOLAYER_H
    1: #define _NSNSSIOLAYER_H
    1: 
    1: #include "prtypes.h"
    1: #include "prio.h"
    1: #include "certt.h"
64576: #include "mozilla/Mutex.h"
    1: #include "nsString.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsITransportSecurityInfo.h"
    1: #include "nsISSLSocketControl.h"
 8463: #include "nsSSLStatus.h"
    1: #include "nsISSLStatusProvider.h"
14244: #include "nsIAssociatedContentSecurity.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsNSSShutDown.h"
28675: #include "nsIClientAuthDialogs.h"
 5220: #include "nsAutoPtr.h"
 5220: #include "nsNSSCertificate.h"
28629: #include "nsDataHashtable.h"
    1: 
83083: namespace mozilla {
    1: 
83083: class MutexAutoLock;
    1: 
83083: namespace psm {
    1: 
83083: enum SSLErrorMessageType {
83083:   OverridableCertErrorMessage  = 1, // for *overridable* certificate errors
83083:   PlainErrorMessage = 2             // all other errors (or "no error")
    1: };
    1: 
83083: } // namespace psm
    1: 
83083: } // namespace mozilla
    1: 
    1: class nsNSSSocketInfo : public nsITransportSecurityInfo,
    1:                         public nsISSLSocketControl,
    1:                         public nsIInterfaceRequestor,
    1:                         public nsISSLStatusProvider,
14244:                         public nsIAssociatedContentSecurity,
 8463:                         public nsISerializable,
 8463:                         public nsIClassInfo,
28675:                         public nsIClientAuthUserDecision,
    1:                         public nsNSSShutDownObject,
    1:                         public nsOnPK11LogoutCancelObject
    1: {
    1: public:
    1:   nsNSSSocketInfo();
    1:   virtual ~nsNSSSocketInfo();
    1:   
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSITRANSPORTSECURITYINFO
    1:   NS_DECL_NSISSLSOCKETCONTROL
    1:   NS_DECL_NSIINTERFACEREQUESTOR
    1:   NS_DECL_NSISSLSTATUSPROVIDER
14244:   NS_DECL_NSIASSOCIATEDCONTENTSECURITY
 8463:   NS_DECL_NSISERIALIZABLE
 8463:   NS_DECL_NSICLASSINFO
28675:   NS_DECL_NSICLIENTAUTHUSERDECISION
    1: 
    1:   nsresult SetSecurityState(PRUint32 aState);
    1:   nsresult SetShortSecurityDescription(const PRUnichar *aText);
    1: 
79445:   nsresult SetForSTARTTLS(bool aForSTARTTLS);
79445:   nsresult GetForSTARTTLS(bool *aForSTARTTLS);
    1: 
    1:   nsresult GetFileDescPtr(PRFileDesc** aFilePtr);
    1:   nsresult SetFileDescPtr(PRFileDesc* aFilePtr);
    1: 
79445:   nsresult GetHandshakePending(bool *aHandshakePending);
79445:   nsresult SetHandshakePending(bool aHandshakePending);
    1: 
83083:   const char * GetHostName() const {
83083:     return mHostName.get();
83083:   }
    1:   nsresult GetHostName(char **aHostName);
    1:   nsresult SetHostName(const char *aHostName);
    1: 
    1:   nsresult GetPort(PRInt32 *aPort);
    1:   nsresult SetPort(PRInt32 aPort);
    1: 
81302:   void GetPreviousCert(nsIX509Cert** _result);
 5220: 
83081:   PRErrorCode GetErrorCode() const;
83083:   void SetCanceled(PRErrorCode errorCode,
83083:                    ::mozilla::psm::SSLErrorMessageType errorMessageType);
    1:   
79445:   void SetHasCleartextPhase(bool aHasCleartextPhase);
79445:   bool GetHasCleartextPhase();
    1:   
79445:   void SetHandshakeInProgress(bool aIsIn);
79445:   bool GetHandshakeInProgress() { return mHandshakeInProgress; }
79445:   bool HandshakeTimeout();
    1: 
79445:   void SetAllowTLSIntoleranceTimeout(bool aAllow);
    1: 
    1:   nsresult RememberCAChain(CERTCertList *aCertList);
    1: 
    1:   /* Set SSL Status values */
 8463:   nsresult SetSSLStatus(nsSSLStatus *aSSLStatus);
 8463:   nsSSLStatus* SSLStatus() { return mSSLStatus; }
83083:   void SetStatusErrorBits(nsIX509Cert & cert, PRUint32 collected_errors);
    1: 
83083:   PRStatus CloseSocketAndDestroy(
83083:                 const nsNSSShutDownPreventionLock & proofOfLock);
    1:   
79445:   bool IsCertIssuerBlacklisted() const {
77514:     return mIsCertIssuerBlacklisted;
77514:   }
77514:   void SetCertIssuerBlacklisted() {
80486:     mIsCertIssuerBlacklisted = true;
77514:   }
83083: 
83083:   // XXX: These are only used on for diagnostic purposes
83083:   enum CertVerificationState {
83083:     before_cert_verification,
83083:     waiting_for_cert_verification,
83083:     after_cert_verification
83083:   };
83083:   void SetCertVerificationWaiting();
83083:   // Use errorCode == 0 to indicate success; in that case, errorMessageType is
83083:   // ignored.
83083:   void SetCertVerificationResult(PRErrorCode errorCode,
83083:               ::mozilla::psm::SSLErrorMessageType errorMessageType);
83083:   
83083:   // for logging only
83083:   PRBool IsWaitingForCertVerification() const
83083:   {
83083:     return mCertVerificationState == waiting_for_cert_verification;
83083:   }
83083:   
83083: 
    1: protected:
83081:   mutable ::mozilla::Mutex mMutex;
83081: 
    1:   nsCOMPtr<nsIInterfaceRequestor> mCallbacks;
    1:   PRFileDesc* mFd;
83083:   CertVerificationState mCertVerificationState;
    1:   PRUint32 mSecurityState;
14244:   PRInt32 mSubRequestsHighSecurity;
14244:   PRInt32 mSubRequestsLowSecurity;
14244:   PRInt32 mSubRequestsBrokenSecurity;
14244:   PRInt32 mSubRequestsNoSecurity;
    1:   nsString mShortDesc;
83081: 
83081:   PRErrorCode mErrorCode;
83083:   ::mozilla::psm::SSLErrorMessageType mErrorMessageType;
83081:   nsString mErrorMessageCached;
83081:   nsresult formatErrorMessage(::mozilla::MutexAutoLock const & proofOfLock);
83081: 
79445:   bool mDocShellDependentStuffKnown;
79445:   bool mExternalErrorReporting; // DocShellDependent
79445:   bool mForSTARTTLS;
79445:   bool mHandshakePending;
79445:   bool mHasCleartextPhase;
79445:   bool mHandshakeInProgress;
79445:   bool mAllowTLSIntoleranceTimeout;
79445:   bool mRememberClientAuthCertificate;
    1:   PRIntervalTime mHandshakeStartTime;
    1:   PRInt32 mPort;
    1:   nsXPIDLCString mHostName;
77514:   PRErrorCode mIsCertIssuerBlacklisted;
    1: 
    1:   /* SSL Status */
 8463:   nsRefPtr<nsSSLStatus> mSSLStatus;
    1: 
    1:   nsresult ActivateSSL();
    1: 
    1: private:
    1:   virtual void virtualDestroyNSSReference();
    1:   void destructorSafeDestroyNSSReference();
    1: };
    1: 
    1: class nsCStringHashSet;
    1: 
28629: class nsSSLStatus;
28629: class nsNSSSocketInfo;
28629: 
28629: class nsPSMRememberCertErrorsTable
28629: {
28629: private:
28629:   struct CertStateBits
28629:   {
79445:     bool mIsDomainMismatch;
79445:     bool mIsNotValidAtThisTime;
79445:     bool mIsUntrusted;
28629:   };
28629:   nsDataHashtableMT<nsCStringHashKey, CertStateBits> mErrorHosts;
28629:   nsresult GetHostPortKey(nsNSSSocketInfo* infoObject, nsCAutoString& result);
28629: 
28629: public:
28629:   friend class nsSSLIOLayerHelpers;
28629:   nsPSMRememberCertErrorsTable();
28629:   void RememberCertHasError(nsNSSSocketInfo* infoObject,
28629:                            nsSSLStatus* status,
28629:                            SECStatus certVerificationResult);
28629:   void LookupCertErrorBits(nsNSSSocketInfo* infoObject,
28629:                            nsSSLStatus* status);
28629: };
28629: 
    1: class nsSSLIOLayerHelpers
    1: {
    1: public:
    1:   static nsresult Init();
    1:   static void Cleanup();
    1: 
79445:   static bool nsSSLIOLayerInitialized;
    1:   static PRDescIdentity nsSSLIOLayerIdentity;
    1:   static PRIOMethods nsSSLIOLayerMethods;
    1: 
64576:   static mozilla::Mutex *mutex;
    1:   static nsCStringHashSet *mTLSIntolerantSites;
30463:   static nsCStringHashSet *mTLSTolerantSites;
28629:   static nsPSMRememberCertErrorsTable* mHostsWithCertErrors;
    1: 
37963:   static nsCStringHashSet *mRenegoUnrestrictedSites;
79445:   static bool mTreatUnsafeNegotiationAsBroken;
41739:   static PRInt32 mWarnLevelMissingRFC5746;
37963: 
79445:   static void setTreatUnsafeNegotiationAsBroken(bool broken);
79445:   static bool treatUnsafeNegotiationAsBroken();
37963: 
41739:   static void setWarnLevelMissingRFC5746(PRInt32 level);
41739:   static PRInt32 getWarnLevelMissingRFC5746();
41739: 
30463:   static void getSiteKey(nsNSSSocketInfo *socketInfo, nsCSubstring &key);
79445:   static bool rememberPossibleTLSProblemSite(PRFileDesc* fd, nsNSSSocketInfo *socketInfo);
30463:   static void rememberTolerantSite(PRFileDesc* ssl_layer_fd, nsNSSSocketInfo *socketInfo);
    1: 
    1:   static void addIntolerantSite(const nsCString &str);
30463:   static void removeIntolerantSite(const nsCString &str);
79445:   static bool isKnownAsIntolerantSite(const nsCString &str);
    1: 
37963:   static void setRenegoUnrestrictedSites(const nsCString &str);
79445:   static bool isRenegoUnrestrictedSite(const nsCString &str);
    1: };
    1: 
    1: nsresult nsSSLIOLayerNewSocket(PRInt32 family,
    1:                                const char *host,
    1:                                PRInt32 port,
    1:                                const char *proxyHost,
    1:                                PRInt32 proxyPort,
    1:                                PRFileDesc **fd,
    1:                                nsISupports **securityInfo,
79445:                                bool forSTARTTLS,
79445:                                bool anonymousLoad);
    1: 
    1: nsresult nsSSLIOLayerAddToSocket(PRInt32 family,
    1:                                  const char *host,
    1:                                  PRInt32 port,
    1:                                  const char *proxyHost,
    1:                                  PRInt32 proxyPort,
    1:                                  PRFileDesc *fd,
    1:                                  nsISupports **securityInfo,
79445:                                  bool forSTARTTLS,
79445:                                  bool anonymousLoad);
    1: 
    1: nsresult nsSSLIOLayerFreeTLSIntolerantSites();
    1: nsresult displayUnknownCertErrorAlert(nsNSSSocketInfo *infoObject, int error);
    1: 
 8463: // 16786594-0296-4471-8096-8f84497ca428
 8463: #define NS_NSSSOCKETINFO_CID \
 8463: { 0x16786594, 0x0296, 0x4471, \
 8463:     { 0x80, 0x96, 0x8f, 0x84, 0x49, 0x7c, 0xa4, 0x28 } }
 8463: 
 8463: 
    1: #endif /* _NSNSSIOLAYER_H */
