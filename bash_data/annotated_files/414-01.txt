  1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
  1: /* ***** BEGIN LICENSE BLOCK *****
  1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  1:  * 
  1:  * The contents of this file are subject to the Mozilla Public License Version
  1:  * 1.1 (the "License"); you may not use this file except in compliance with
  1:  * the License. You may obtain a copy of the License at
  1:  * http://www.mozilla.org/MPL/
  1:  *
  1:  * Software distributed under the License is distributed on an "AS IS" basis,
  1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  1:  * for the specific language governing rights and limitations under the
  1:  * License.
  1:  * 
  1:  * The Original Code is Mozilla MathML Project.
  1:  * 
  1:  * The Initial Developer of the Original Code is
  1:  * The University of Queensland.
  1:  * Portions created by the Initial Developer are Copyright (C) 1999
  1:  * the Initial Developer. All Rights Reserved.
  1:  * 
  1:  * Contributor(s): 
  1:  *   Roger B. Sidje <rbs@maths.uq.edu.au>
  1:  *
  1:  * Alternatively, the contents of this file may be used under the terms of
  1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
  1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  1:  * in which case the provisions of the GPL or the LGPL are applicable instead
  1:  * of those above. If you wish to allow use of your version of this file only
  1:  * under the terms of either the GPL or the LGPL, and not to allow others to
  1:  * use your version of this file under the terms of the MPL, indicate your
  1:  * decision by deleting the provisions above and replace them with the notice
  1:  * and other provisions required by the GPL or the LGPL. If you do not delete
  1:  * the provisions above, a recipient may use your version of this file under
  1:  * the terms of any one of the MPL, the GPL or the LGPL.
  1:  *
  1:  * ***** END LICENSE BLOCK ***** */
  1: 
  1: #include "nsCOMPtr.h"
  1: #include "nsFrame.h"
  1: #include "nsPresContext.h"
  1: #include "nsUnitConversion.h"
  1: #include "nsStyleContext.h"
  1: #include "nsStyleConsts.h"
  1: #include "nsIRenderingContext.h"
  1: #include "nsIFontMetrics.h"
  1: #include "nsContentUtils.h"
414: #include "nsCSSFrameConstructor.h"
  1: #include "nsMathMLTokenFrame.h"
  1: 
  1: nsIFrame*
  1: NS_NewMathMLTokenFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
  1: {
  1:   return new (aPresShell) nsMathMLTokenFrame(aContext);
  1: }
  1: nsMathMLTokenFrame::~nsMathMLTokenFrame()
  1: {
  1: }
  1: 
  1: eMathMLFrameType
  1: nsMathMLTokenFrame::GetMathMLFrameType()
  1: {
  1:   // treat everything other than <mi> as ordinary...
  1:   if (mContent->Tag() != nsGkAtoms::mi_) {
  1:     return eMathMLFrameType_Ordinary;
  1:   }
  1: 
  1:   // for <mi>, distinguish between italic and upright...
  1:   // treat invariant the same as italic to inherit its inter-space properties
  1:   return mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::MOZfontstyle,
  1:                                nsGkAtoms::normal, eCaseMatters)
  1:     ? eMathMLFrameType_UprightIdentifier
  1:     : eMathMLFrameType_ItalicIdentifier;
  1: }
  1: 
  1: static void
  1: CompressWhitespace(nsIContent* aContent)
  1: {
  1:   PRUint32 numKids = aContent->GetChildCount();
  1:   for (PRUint32 kid = 0; kid < numKids; kid++) {
  1:     nsIContent* cont = aContent->GetChildAt(kid);
  1:     if (cont && cont->IsNodeOfType(nsINode::eTEXT)) {
  1:       nsAutoString text;
  1:       cont->AppendTextTo(text);
  1:       text.CompressWhitespace();
  1:       cont->SetText(text, PR_FALSE); // not meant to be used if notify is needed
  1:     }
  1:   }
  1: }
  1: 
  1: NS_IMETHODIMP
  1: nsMathMLTokenFrame::Init(nsIContent*      aContent,
  1:                          nsIFrame*        aParent,
  1:                          nsIFrame*        aPrevInFlow)
  1: {
  1:   // leading and trailing whitespace doesn't count -- bug 15402
  1:   // brute force removal for people who do <mi> a </mi> instead of <mi>a</mi>
  1:   // XXX the best fix is to skip these in nsTextFrame
  1:   CompressWhitespace(aContent);
  1: 
  1:   // let the base class do its Init()
  1:   return nsMathMLContainerFrame::Init(aContent, aParent, aPrevInFlow);
  1: }
  1: 
  1: NS_IMETHODIMP
  1: nsMathMLTokenFrame::SetInitialChildList(nsIAtom*        aListName,
  1:                                         nsIFrame*       aChildList)
  1: {
  1:   // First, let the base class do its work
  1:   nsresult rv = nsMathMLContainerFrame::SetInitialChildList(aListName, aChildList);
  1:   if (NS_FAILED(rv))
  1:     return rv;
  1: 
  1:   SetQuotes();
  1:   ProcessTextData(PR_FALSE);
  1:   return rv;
  1: }
  1: 
  1: nsresult
  1: nsMathMLTokenFrame::Reflow(nsPresContext*          aPresContext,
  1:                            nsHTMLReflowMetrics&     aDesiredSize,
  1:                            const nsHTMLReflowState& aReflowState,
  1:                            nsReflowStatus&          aStatus)
  1: {
  1:   nsresult rv = NS_OK;
  1: 
  1:   // initializations needed for empty markup like <mtag></mtag>
  1:   aDesiredSize.width = aDesiredSize.height = 0;
  1:   aDesiredSize.ascent = 0;
  1:   aDesiredSize.mBoundingMetrics.Clear();
  1: 
  1:   // ask our children to compute their bounding metrics
  1:   nsHTMLReflowMetrics childDesiredSize(
  1:                       aDesiredSize.mFlags | NS_REFLOW_CALC_BOUNDING_METRICS);
  1:   nsSize availSize(aReflowState.ComputedWidth(), aReflowState.mComputedHeight);
  1:   PRInt32 count = 0;
  1:   nsIFrame* childFrame = GetFirstChild(nsnull);
  1:   while (childFrame) {
  1:     nsHTMLReflowState childReflowState(aPresContext, aReflowState,
  1:                                        childFrame, availSize);
  1:     rv = ReflowChild(childFrame, aPresContext, childDesiredSize,
  1:                      childReflowState, aStatus);
  1:     //NS_ASSERTION(NS_FRAME_IS_COMPLETE(aStatus), "bad status");
  1:     if (NS_FAILED(rv)) {
  1:       // Call DidReflow() for the child frames we successfully did reflow.
  1:       DidReflowChildren(GetFirstChild(nsnull), childFrame);
  1:       return rv;
  1:     }
  1: 
  1:     // origins are used as placeholders to store the child's ascent and descent.
  1:     childFrame->SetRect(nsRect(0, childDesiredSize.ascent,
  1:                                childDesiredSize.width, childDesiredSize.height));
  1:     // compute and cache the bounding metrics
  1:     if (0 == count)
  1:       aDesiredSize.mBoundingMetrics  = childDesiredSize.mBoundingMetrics;
  1:     else
  1:       aDesiredSize.mBoundingMetrics += childDesiredSize.mBoundingMetrics;
  1: 
  1:     count++;
  1:     childFrame = childFrame->GetNextSibling();
  1:   }
  1: 
  1:   // cache the frame's mBoundingMetrics
  1:   mBoundingMetrics = aDesiredSize.mBoundingMetrics;
  1: 
  1:   // place and size children
  1:   FinalizeReflow(*aReflowState.rendContext, aDesiredSize);
  1: 
  1:   // XXX set a tentative size for the overflow area. The frame might still be
  1:   // stretched later.
  1:   aDesiredSize.mOverflowArea.SetRect(0, 0, aDesiredSize.width, aDesiredSize.height);
  1:   FinishAndStoreOverflow(&aDesiredSize);
  1: 
  1:   aStatus = NS_FRAME_COMPLETE;
  1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
  1:   return NS_OK;
  1: }
  1: 
  1: // For token elements, mBoundingMetrics is computed at the ReflowToken
  1: // pass, it is not computed here because our children may be text frames
  1: // that do not implement the GetBoundingMetrics() interface.
  1: nsresult
  1: nsMathMLTokenFrame::Place(nsIRenderingContext& aRenderingContext,
  1:                           PRBool               aPlaceOrigin,
  1:                           nsHTMLReflowMetrics& aDesiredSize)
  1: {
  1:   nsCOMPtr<nsIFontMetrics> fm =
238:     PresContext()->GetMetricsFor(GetStyleFont()->mFont);
  1:   nscoord ascent, descent;
  1:   fm->GetMaxAscent(ascent);
  1:   fm->GetMaxDescent(descent);
  1: 
  1:   aDesiredSize.mBoundingMetrics = mBoundingMetrics;
  1:   aDesiredSize.width = mBoundingMetrics.width;
  1:   aDesiredSize.ascent = PR_MAX(mBoundingMetrics.ascent, ascent);
  1:   aDesiredSize.height = aDesiredSize.ascent +
  1:                         PR_MAX(mBoundingMetrics.descent, descent);
  1: 
  1:   if (aPlaceOrigin) {
  1:     nscoord dy, dx = 0;
  1:     nsIFrame* childFrame = GetFirstChild(nsnull);
  1:     while (childFrame) {
  1:       nsRect rect = childFrame->GetRect();
  1:       nsHTMLReflowMetrics childSize;
  1:       childSize.width = rect.width;
  1:       childSize.height = aDesiredSize.height; //rect.height;
  1: 
  1:       // place and size the child; (dx,0) makes the caret happy - bug 188146
  1:       dy = rect.IsEmpty() ? 0 : aDesiredSize.ascent - rect.y;
238:       FinishReflowChild(childFrame, PresContext(), nsnull, childSize, dx, dy, 0);
  1:       dx += rect.width;
  1:       childFrame = childFrame->GetNextSibling();
  1:     }
  1:   }
  1: 
  1:   SetReference(nsPoint(0, aDesiredSize.ascent));
  1: 
  1:   return NS_OK;
  1: }
  1: 
  1: /* virtual */ void
  1: nsMathMLTokenFrame::MarkIntrinsicWidthsDirty()
  1: {
  1:   // this could be called due to changes in the nsTextFrame beneath us
  1:   // when something changed in the text content. So re-process our text
  1:   ProcessTextData(PR_TRUE);
  1: 
  1:   nsMathMLContainerFrame::MarkIntrinsicWidthsDirty();
  1: }
  1: 
  1: NS_IMETHODIMP
  1: nsMathMLTokenFrame::AttributeChanged(PRInt32         aNameSpaceID,
  1:                                      nsIAtom*        aAttribute,
  1:                                      PRInt32         aModType)
  1: {
  1:   if (nsGkAtoms::lquote_ == aAttribute ||
  1:       nsGkAtoms::rquote_ == aAttribute) {
  1:     SetQuotes();
  1:   }
  1: 
  1:   return nsMathMLContainerFrame::
  1:          AttributeChanged(aNameSpaceID, aAttribute, aModType);
  1: }
  1: 
  1: void
  1: nsMathMLTokenFrame::ProcessTextData(PRBool aComputeStyleChange)
  1: {
  1:   // see if the style changes from normal to italic or vice-versa
  1:   if (!SetTextStyle())
  1:     return;
  1: 
  1:   // has changed but it doesn't have to be reflected straightaway
  1:   if (!aComputeStyleChange)
  1:     return;
  1: 
414:   // explicitly request a re-resolve to pick up the change of style
414:   GetPresContext()->PresShell()->FrameConstructor()->
414:     PostRestyleEvent(mContent, eReStyle_Self, NS_STYLE_HINT_NONE);
  1: }
  1: 
  1: ///////////////////////////////////////////////////////////////////////////
  1: // For <mi>, if the content is not a single character, turn the font to
  1: // normal (this function will also query attributes from the mstyle hierarchy)
  1: 
  1: PRBool
  1: nsMathMLTokenFrame::SetTextStyle()
  1: {
  1:   if (mContent->Tag() != nsGkAtoms::mi_)
  1:     return PR_FALSE;
  1: 
  1:   if (!mFrames.FirstChild())
  1:     return PR_FALSE;
  1: 
  1:   // Get the text content that we enclose and its length
  1:   nsAutoString data;
  1:   nsContentUtils::GetNodeTextContent(mContent, PR_FALSE, data);
  1:   PRInt32 length = data.Length();
  1:   if (!length)
  1:     return PR_FALSE;
  1: 
  1:   // attributes may override the default behavior
  1:   nsAutoString fontstyle;
  1:   GetAttribute(mContent, mPresentationData.mstyle, nsGkAtoms::fontstyle_, fontstyle);
  1:   if (1 == length && nsMathMLOperators::LookupInvariantChar(data[0])) {
  1:     // bug 65951 - a non-stylable character has its own intrinsic appearance
  1:     fontstyle.AssignLiteral("invariant");
  1:   }
  1:   if (fontstyle.IsEmpty()) {
  1:     fontstyle.AssignASCII((1 == length) ? "italic" : "normal"); 
  1:   }
  1: 
  1:   // set the -moz-math-font-style attribute without notifying that we want a reflow
  1:   if (!mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::MOZfontstyle,
  1:                              fontstyle, eCaseMatters)) {
  1:     mContent->SetAttr(kNameSpaceID_None, nsGkAtoms::MOZfontstyle, fontstyle, PR_FALSE);
  1:     return PR_TRUE;
  1:   }
  1: 
  1:   return PR_FALSE;
  1: }
  1: 
  1: ///////////////////////////////////////////////////////////////////////////
  1: // For <ms>, it is assumed that the mathml.css file contains two rules:
  1: // ms:before { content: open-quote; }
  1: // ms:after { content: close-quote; }
  1: // With these two rules, the frame construction code will
  1: // create inline frames that contain text frames which themselves
  1: // contain the text content of the quotes.
  1: // So the main idea in this code is to see if there are lquote and 
  1: // rquote attributes. If these are there, we ovewrite the default
  1: // quotes in the text frames.
  1: //
  1: // But what if the mathml.css file wasn't loaded? 
  1: // We also check that we are not relying on null pointers...
  1: 
  1: static void
  1: SetQuote(nsIFrame*       aFrame, 
  1:          nsString&       aValue)
  1: {
  1:   nsIFrame* textFrame;
  1:   do {
  1:     // walk down the hierarchy of first children because they could be wrapped
  1:     textFrame = aFrame->GetFirstChild(nsnull);
  1:     if (textFrame) {
  1:       if (textFrame->GetType() == nsGkAtoms::textFrame)
  1:         break;
  1:     }
  1:     aFrame = textFrame;
  1:   } while (textFrame);
  1:   if (textFrame) {
  1:     nsIContent* quoteContent = textFrame->GetContent();
  1:     if (quoteContent && quoteContent->IsNodeOfType(nsINode::eTEXT)) {
  1:       quoteContent->SetText(aValue, PR_FALSE); // no notify since we don't want a reflow yet
  1:     }
  1:   }
  1: }
  1: 
  1: void
  1: nsMathMLTokenFrame::SetQuotes()
  1: {
  1:   if (mContent->Tag() != nsGkAtoms::ms_)
  1:     return;
  1: 
  1:   nsIFrame* rightFrame = nsnull;
  1:   nsIFrame* baseFrame = nsnull;
  1:   nsIFrame* leftFrame = mFrames.FirstChild();
  1:   if (leftFrame)
  1:     baseFrame = leftFrame->GetNextSibling();
  1:   if (baseFrame)
  1:     rightFrame = baseFrame->GetNextSibling();
  1:   if (!leftFrame || !baseFrame || !rightFrame)
  1:     return;
  1: 
  1:   nsAutoString value;
  1:   // lquote
  1:   if (GetAttribute(mContent, mPresentationData.mstyle,
  1:                    nsGkAtoms::lquote_, value)) {
  1:     SetQuote(leftFrame, value);
  1:   }
  1:   // rquote
  1:   if (GetAttribute(mContent, mPresentationData.mstyle,
  1:                    nsGkAtoms::rquote_, value)) {
  1:     SetQuote(rightFrame, value);
  1:   }
  1: }
