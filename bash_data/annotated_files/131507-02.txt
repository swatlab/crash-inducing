131499: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
131499: /* vim:set ts=2 sw=2 sts=2 et cindent: */
131499: /* This Source Code Form is subject to the terms of the Mozilla Public
131499:  * License, v. 2.0. If a copy of the MPL was not distributed with this
131499:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
131499: #ifndef MOZILLA_AUDIONODEENGINE_H_
131499: #define MOZILLA_AUDIONODEENGINE_H_
131499: 
131499: #include "AudioSegment.h"
131499: 
131499: namespace mozilla {
131499: 
131499: class AudioNodeStream;
131499: 
131499: // We ensure that the graph advances in steps that are multiples of the Web
131499: // Audio block size
131499: const uint32_t WEBAUDIO_BLOCK_SIZE_BITS = 7;
131499: const uint32_t WEBAUDIO_BLOCK_SIZE = 1 << WEBAUDIO_BLOCK_SIZE_BITS;
131499: 
131499: /**
131499:  * This class holds onto a set of immutable channel buffers. The storage
131499:  * for the buffers must be malloced, but the buffer pointers and the malloc
131499:  * pointers can be different (e.g. if the buffers are contained inside
131499:  * some malloced object).
131499:  */
131499: class ThreadSharedFloatArrayBufferList : public ThreadSharedObject {
131499: public:
131499:   /**
131499:    * Construct with null data.
131499:    */
131499:   ThreadSharedFloatArrayBufferList(uint32_t aCount)
131499:   {
131499:     mContents.SetLength(aCount);
131499:   }
131499: 
131499:   struct Storage {
131499:     Storage()
131499:     {
131499:       mDataToFree = nullptr;
131499:       mSampleData = nullptr;
131499:     }
131499:     ~Storage() { free(mDataToFree); }
131499:     void* mDataToFree;
131499:     const float* mSampleData;
131499:   };
131499: 
131499:   /**
131499:    * This can be called on any thread.
131499:    */
131499:   uint32_t GetChannels() const { return mContents.Length(); }
131499:   /**
131499:    * This can be called on any thread.
131499:    */
131499:   const float* GetData(uint32_t aIndex) const { return mContents[aIndex].mSampleData; }
131499: 
131499:   /**
131499:    * Call this only during initialization, before the object is handed to
131499:    * any other thread.
131499:    */
131499:   void SetData(uint32_t aIndex, void* aDataToFree, const float* aData)
131499:   {
131499:     Storage* s = &mContents[aIndex];
131499:     free(s->mDataToFree);
131499:     s->mDataToFree = aDataToFree;
131499:     s->mSampleData = aData;
131499:   }
131499: 
131499:   /**
131499:    * Put this object into an error state where there are no channels.
131499:    */
131499:   void Clear() { mContents.Clear(); }
131499: 
131499: private:
131499:   AutoFallibleTArray<Storage,2> mContents;
131499: };
131499: 
131499: /**
131499:  * Allocates an AudioChunk with fresh buffers of WEBAUDIO_BLOCK_SIZE float samples.
131499:  * AudioChunk::mChannelData's entries can be cast to float* for writing.
131499:  */
131499: void AllocateAudioBlock(uint32_t aChannelCount, AudioChunk* aChunk);
131499: 
131499: /**
131499:  * aChunk must have been allocated by AllocateAudioBlock.
131499:  */
131499: void WriteZeroesToAudioBlock(AudioChunk* aChunk, uint32_t aStart, uint32_t aLength);
131499: 
131499: /**
131499:  * Pointwise multiply-add operation. aScale == 1.0f should be optimized.
131499:  */
131499: void AudioBlockAddChannelWithScale(const float aInput[WEBAUDIO_BLOCK_SIZE],
131499:                                    float aScale,
131499:                                    float aOutput[WEBAUDIO_BLOCK_SIZE]);
131499: 
131499: /**
131499:  * Pointwise copy-scaled operation. aScale == 1.0f should be optimized.
131499:  */
131499: void AudioBlockCopyChannelWithScale(const float aInput[WEBAUDIO_BLOCK_SIZE],
131499:                                     float aScale,
131499:                                     float aOutput[WEBAUDIO_BLOCK_SIZE]);
131499: 
131499: /**
131499:  * All methods of this class and its subclasses are called on the
131499:  * MediaStreamGraph thread.
131499:  */
131499: class AudioNodeEngine {
131499: public:
131499:   AudioNodeEngine() {}
131499:   virtual ~AudioNodeEngine() {}
131499: 
131499:   virtual void SetStreamTimeParameter(uint32_t aIndex, TrackTicks aParam)
131499:   {
131499:     NS_ERROR("Invalid SetStreamTimeParameter index");
131499:   }
131499:   virtual void SetDoubleParameter(uint32_t aIndex, double aParam)
131499:   {
131499:     NS_ERROR("Invalid SetDoubleParameter index");
131499:   }
131499:   virtual void SetInt32Parameter(uint32_t aIndex, int32_t aParam)
131499:   {
131499:     NS_ERROR("Invalid SetInt32Parameter index");
131499:   }
131499:   virtual void SetBuffer(already_AddRefed<ThreadSharedFloatArrayBufferList> aBuffer)
131499:   {
131499:     NS_ERROR("SetBuffer called on engine that doesn't support it");
131499:   }
131499: 
131499:   /**
131499:    * Produce the next block of audio samples, given input samples aInput
131499:    * (the mixed data for input 0).
131499:    * By default, simply returns the mixed input.
131499:    * aInput is guaranteed to have float sample format (if it has samples at all)
131499:    * and to have been resampled to IdealAudioRate(), and to have exactly
131499:    * WEBAUDIO_BLOCK_SIZE samples.
131499:    * *aFinished is set to false by the caller. If the callee sets it to true,
131499:    * we'll finish the stream and not call this again.
131499:    */
131499:   virtual void ProduceAudioBlock(AudioNodeStream* aStream,
131499:                                  const AudioChunk& aInput,
131499:                                  AudioChunk* aOutput,
131499:                                  bool* aFinished)
131499:   {
131499:     *aOutput = aInput;
131499:   }
131499: };
131499: 
131499: }
131499: 
131499: #endif /* MOZILLA_AUDIONODEENGINE_H_ */
