 53573: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 53573:  * vim: set ts=8 sw=4 et tw=78:
 53573:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 53573: 
 53573: #ifndef xpcpublic_h
 53573: #define xpcpublic_h
 53573: 
 53573: #include "jsapi.h"
 86104: #include "js/MemoryMetrics.h"
 79734: #include "jsclass.h"
 77404: #include "jsfriendapi.h"
 62366: #include "jsgc.h"
 74674: #include "jspubtd.h"
 80074: #include "jsproxy.h"
 62366: 
 58714: #include "nsISupports.h"
 57854: #include "nsIPrincipal.h"
 57854: #include "nsWrapperCache.h"
 74674: #include "nsStringGlue.h"
 75066: #include "nsTArray.h"
 97422: #include "mozilla/dom/DOMJSClass.h"
102929: #include "nsMathUtils.h"
 56703: 
 56703: class nsIPrincipal;
 94512: class nsIXPConnectWrappedJS;
 94512: class nsScriptNameSpaceManager;
 53573: 
 86102: #ifndef BAD_TLS_INDEX
 86102: #define BAD_TLS_INDEX ((PRUint32) -1)
 86102: #endif
 86102: 
106125: namespace xpc {
106125: JSObject *
106125: TransplantObject(JSContext *cx, JSObject *origobj, JSObject *target);
106125: 
106125: JSObject *
106125: TransplantObjectWithWrapper(JSContext *cx,
106125:                             JSObject *origobj, JSObject *origwrapper,
106125:                             JSObject *targetobj, JSObject *targetwrapper);
106125: } /* namespace xpc */
106125: 
 53573: nsresult
 53573: xpc_CreateGlobalObject(JSContext *cx, JSClass *clasp,
 56703:                        nsIPrincipal *principal, nsISupports *ptr,
 56473:                        bool wantXrays, JSObject **global,
 55675:                        JSCompartment **compartment);
 53573: 
 56703: nsresult
 56703: xpc_CreateMTGlobalObject(JSContext *cx, JSClass *clasp,
 56703:                          nsISupports *ptr, JSObject **global,
 56703:                          JSCompartment **compartment);
 56703: 
 80070: #define XPCONNECT_GLOBAL_FLAGS                                                \
 94512:     JSCLASS_DOM_GLOBAL | JSCLASS_XPCONNECT_GLOBAL | JSCLASS_HAS_PRIVATE |     \
 90410:     JSCLASS_PRIVATE_IS_NSISUPPORTS | JSCLASS_IMPLEMENTS_BARRIERS |            \
 94512:     JSCLASS_GLOBAL_FLAGS_WITH_SLOTS(3)
 80070: 
 80070: void
 80070: TraceXPCGlobal(JSTracer *trc, JSObject *obj);
 80070: 
 60616: // XXX where should this live?
 60616: NS_EXPORT_(void)
 60616: xpc_LocalizeContext(JSContext *cx);
 60616: 
 58714: nsresult
 58714: xpc_MorphSlimWrapper(JSContext *cx, nsISupports *tomorph);
 58714: 
 86105: static inline bool IS_WRAPPER_CLASS(js::Class* clazz)
 86105: {
 86105:     return clazz->ext.isWrappedNative;
 86105: }
 57854: 
 57854: inline JSBool
 57854: DebugCheckWrapperClass(JSObject* obj)
 57854: {
 79734:     NS_ASSERTION(IS_WRAPPER_CLASS(js::GetObjectClass(obj)),
 57854:                  "Forgot to check if this is a wrapper?");
 82794:     return true;
 57854: }
 57854: 
 57854: // If IS_WRAPPER_CLASS for the JSClass of an object is true, the object can be
 57854: // a slim wrapper, holding a native in its private slot, or a wrappednative
 57854: // wrapper, holding the XPCWrappedNative in its private slot. A slim wrapper
 57854: // also holds a pointer to its XPCWrappedNativeProto in a reserved slot, we can
101164: // check that slot for a private value (i.e. a double) to distinguish between
101164: // the two. This allows us to store a JSObject in that slot for non-slim wrappers
101164: // while still being able to distinguish the two cases.
101164: 
101164: // NB: This slot isn't actually reserved for us on globals, because SpiderMonkey
101164: // uses the first N slots on globals internally. The fact that we use it for
101164: // wrapped global objects is totally broken. But due to a happy coincidence, the
101164: // JS engine never uses that slot. This still needs fixing though. See bug 760095.
101164: #define WRAPPER_MULTISLOT 0
 57854: 
 79734: // Only use these macros if IS_WRAPPER_CLASS(GetObjectClass(obj)) is true.
 57854: #define IS_WN_WRAPPER_OBJECT(obj)                                             \
101164:     (DebugCheckWrapperClass(obj) && !js::GetReservedSlot(obj, WRAPPER_MULTISLOT).isDouble())
 57854: #define IS_SLIM_WRAPPER_OBJECT(obj)                                           \
101164:     (DebugCheckWrapperClass(obj) && js::GetReservedSlot(obj, WRAPPER_MULTISLOT).isDouble())
 57854: 
 79734: // Use these macros if IS_WRAPPER_CLASS(GetObjectClass(obj)) might be false.
 79734: // Avoid calling them if IS_WRAPPER_CLASS(GetObjectClass(obj)) can only be
 57854: // true, as we'd do a redundant call to IS_WRAPPER_CLASS.
 57854: #define IS_WN_WRAPPER(obj)                                                    \
 79734:     (IS_WRAPPER_CLASS(js::GetObjectClass(obj)) && IS_WN_WRAPPER_OBJECT(obj))
 57854: #define IS_SLIM_WRAPPER(obj)                                                  \
 79734:     (IS_WRAPPER_CLASS(js::GetObjectClass(obj)) && IS_SLIM_WRAPPER_OBJECT(obj))
 57854: 
 57854: inline JSObject *
 57854: xpc_GetGlobalForObject(JSObject *obj)
 57854: {
 79734:     while (JSObject *parent = js::GetObjectParent(obj))
 57854:         obj = parent;
 57854:     return obj;
 57854: }
 57854: 
 63538: extern bool
 63538: xpc_OkToHandOutWrapper(nsWrapperCache *cache);
 63538: 
 57854: inline JSObject*
 63538: xpc_FastGetCachedWrapper(nsWrapperCache *cache, JSObject *scope, jsval *vp)
 57854: {
 57854:     if (cache) {
 57854:         JSObject* wrapper = cache->GetWrapper();
 63538:         NS_ASSERTION(!wrapper ||
 93879:                      !cache->IsDOMBinding() ||
 80067:                      !IS_SLIM_WRAPPER(wrapper),
 93879:                      "Should never have a slim wrapper when IsDOMBinding()");
 57854:         if (wrapper &&
 79734:             js::GetObjectCompartment(wrapper) == js::GetObjectCompartment(scope) &&
 80067:             (IS_SLIM_WRAPPER(wrapper) ||
 63538:              xpc_OkToHandOutWrapper(cache))) {
 57854:             *vp = OBJECT_TO_JSVAL(wrapper);
 57854:             return wrapper;
 57854:         }
 57854:     }
 57854: 
 57854:     return nsnull;
 57854: }
 57854: 
 69648: // The JS GC marks objects gray that are held alive directly or
 69648: // indirectly by an XPConnect root. The cycle collector explores only
 89501: // this subset of the JS heap.
 62690: inline JSBool
 62690: xpc_IsGrayGCThing(void *thing)
 62690: {
 89501:     return js::GCThingIsMarkedGray(thing);
 62690: }
 62690: 
 89501: // The cycle collector only cares about some kinds of GCthings that are
 89501: // reachable from an XPConnect root. Implemented in nsXPConnect.cpp.
 69648: extern JSBool
 69648: xpc_GCThingIsGrayCCThing(void *thing);
 69648: 
 62690: // Implemented in nsXPConnect.cpp.
 62690: extern void
 97588: xpc_UnmarkGrayGCThingRecursive(void *thing, JSGCTraceKind kind);
 62690: 
 62690: // Remove the gray color from the given JSObject and any other objects that can
 62690: // be reached through it.
 97588: inline JSObject *
 62690: xpc_UnmarkGrayObject(JSObject *obj)
 62690: {
 90410:     if (obj) {
 90410:         if (xpc_IsGrayGCThing(obj))
 97588:             xpc_UnmarkGrayGCThingRecursive(obj, JSTRACE_OBJECT);
 90410:         else if (js::IsIncrementalBarrierNeededOnObject(obj))
 90410:             js::IncrementalReferenceBarrier(obj);
 90410:     }
 97588:     return obj;
 97588: }
 97588: 
 97588: inline JSScript *
 97588: xpc_UnmarkGrayScript(JSScript *script)
 97588: {
 97588:     if (script) {
 97588:         if (xpc_IsGrayGCThing(script))
 97588:             xpc_UnmarkGrayGCThingRecursive(script, JSTRACE_SCRIPT);
 97588:         else if (js::IsIncrementalBarrierNeededOnScript(script))
 97588:             js::IncrementalReferenceBarrier(script);
 97588:     }
 97588:     return script;
 96864: }
 96864: 
 97592: inline JSContext *
 97592: xpc_UnmarkGrayContext(JSContext *cx)
 97592: {
 97592:     if (cx) {
 97592:         JSObject *global = JS_GetGlobalObject(cx);
 97592:         xpc_UnmarkGrayObject(global);
 98261:         if (global && JS_IsInRequest(JS_GetRuntime(cx))) {
 97592:             JSObject *scope = JS_GetGlobalForScopeChain(cx);
 97592:             if (scope != global)
 97592:                 xpc_UnmarkGrayObject(scope);
 97592:         }
 97592:     }
 97592:     return cx;
 97592: }
 97592: 
 97592: #ifdef __cplusplus
 97592: class XPCAutoRequest : public JSAutoRequest {
 97592: public:
 97592:     XPCAutoRequest(JSContext *cx) : JSAutoRequest(cx) {
 97592:         xpc_UnmarkGrayContext(cx);
 97592:     }
 97592: };
 97592: #endif
 97592: 
 88262: // If aVariant is an XPCVariant, this marks the object to be in aGeneration.
 88262: // This also unmarks the gray JSObject.
 88262: extern void
 88262: xpc_MarkInCCGeneration(nsISupports* aVariant, PRUint32 aGeneration);
 88262: 
 94338: // If aWrappedJS is a JS wrapper, unmark its JSObject.
 88262: extern void
 94338: xpc_TryUnmarkWrappedGrayObject(nsISupports* aWrappedJS);
 88262: 
 89871: extern void
 89871: xpc_UnmarkSkippableJSHolders();
 89871: 
 82537: // No JS can be on the stack when this is called. Probably only useful from
 82537: // xpcshell.
 82537: NS_EXPORT_(void)
 82537: xpc_ActivateDebugMode();
 82537: 
 95445: class nsIMemoryMultiReporterCallback;
 95445: 
 86103: namespace xpc {
 86103: 
102130: bool DeferredRelease(nsISupports *obj);
102130: 
 86226: // If these functions return false, then an exception will be set on cx.
 86226: bool Base64Encode(JSContext *cx, JS::Value val, JS::Value *out);
 86226: bool Base64Decode(JSContext *cx, JS::Value val, JS::Value *out);
 86226: 
 86103: /**
 86103:  * Convert an nsString to jsval, returning true on success.
 86103:  * Note, the ownership of the string buffer may be moved from str to rval.
 86103:  * If that happens, str will point to an empty string after this call.
 86103:  */
 90485: bool StringToJsval(JSContext *cx, nsAString &str, JS::Value *rval);
 90485: bool NonVoidStringToJsval(JSContext *cx, nsAString &str, JS::Value *rval);
 86103: 
 94863: nsIPrincipal *GetCompartmentPrincipal(JSCompartment *compartment);
 94863: 
 89654: void DumpJSHeap(FILE* file);
 95444: 
 99154: void SetLocationForGlobal(JSObject *global, const nsACString& location);
 99154: void SetLocationForGlobal(JSObject *global, nsIURI *locationURI);
 99154: 
 95444: /**
 95444:  * Define quick stubs on the given object, @a proto.
 95444:  *
 95444:  * @param cx
 95444:  *     A context.  Requires request.
 95444:  * @param proto
 95444:  *     The (newly created) prototype object for a DOM class.  The JS half
 95444:  *     of an XPCWrappedNativeProto.
 95444:  * @param flags
 95444:  *     Property flags for the quick stub properties--should be either
 95444:  *     JSPROP_ENUMERATE or 0.
 95444:  * @param interfaceCount
 95444:  *     The number of interfaces the class implements.
 95444:  * @param interfaceArray
 95444:  *     The interfaces the class implements; interfaceArray and
 95444:  *     interfaceCount are like what nsIClassInfo.getInterfaces returns.
 95444:  */
 95444: bool
 95444: DOM_DefineQuickStubs(JSContext *cx, JSObject *proto, PRUint32 flags,
 95444:                      PRUint32 interfaceCount, const nsIID **interfaceArray);
 95444: 
 89498: // This reports all the stats in |rtStats| that belong in the "explicit" tree,
 89498: // (which isn't all of them).
 91899: nsresult
 91899: ReportJSRuntimeExplicitTreeStats(const JS::RuntimeStats &rtStats,
103785:                                  const nsACString &rtPath,
 91899:                                  nsIMemoryMultiReporterCallback *cb,
102944:                                  nsISupports *closure, size_t *rtTotal = NULL);
 74674: 
 95450: /**
 95450:  * Convert a jsval to PRInt64. Return true on success.
 95450:  */
 95450: inline bool
 95450: ValueToInt64(JSContext *cx, JS::Value v, int64_t *result)
 95450: {
 95450:     if (JSVAL_IS_INT(v)) {
 95450:         int32_t intval;
 95450:         if (!JS_ValueToECMAInt32(cx, v, &intval))
 95450:             return false;
 95450:         *result = static_cast<int64_t>(intval);
 95450:     } else {
 95450:         double doubleval;
 95450:         if (!JS_ValueToNumber(cx, v, &doubleval))
 95450:             return false;
102929:         // Be careful with non-finite doubles
102929:         if (NS_finite(doubleval))
102929:             // XXXbz this isn't quite right either; need to do the mod thing
 95450:             *result = static_cast<int64_t>(doubleval);
102929:         else
102929:             *result = 0;
 95450:     }
 95450:     return true;
 95450: }
 95450: 
 95450: /**
 95450:  * Convert a jsval to uint64_t. Return true on success.
 95450:  */
 95450: inline bool
 95450: ValueToUint64(JSContext *cx, JS::Value v, uint64_t *result)
 95450: {
 95450:     if (JSVAL_IS_INT(v)) {
 95450:         uint32_t intval;
 95450:         if (!JS_ValueToECMAUint32(cx, v, &intval))
 95450:             return false;
 95450:         *result = static_cast<uint64_t>(intval);
 95450:     } else {
 95450:         double doubleval;
 95450:         if (!JS_ValueToNumber(cx, v, &doubleval))
 95450:             return false;
102929:         // Be careful with non-finite doubles
102929:         if (NS_finite(doubleval))
102929:             // XXXbz this isn't quite right either; need to do the mod thing
 95450:             *result = static_cast<uint64_t>(doubleval);
102929:         else
102929:             *result = 0;
 95450:     }
 95450:     return true;
 95450: }
 95450: 
 98833: /**
 98833:  * Given an arbitrary object, Unwrap will return the wrapped object if the
 98833:  * passed-in object is a wrapper that Unwrap knows about *and* the
 98833:  * currently running code has permission to access both the wrapper and
 98833:  * wrapped object.
 98833:  *
 98833:  * Since this is meant to be called from functions like
 98833:  * XPCWrappedNative::GetWrappedNativeOfJSObject, it does not set an
 98833:  * exception on |cx|.
 98833:  */
 98833: JSObject *
 98833: Unwrap(JSContext *cx, JSObject *wrapper, bool stopAtOuter = true);
 98833: 
 98833: /**
 98833:  * Throws an exception on cx and returns false.
 98833:  */
 98833: bool
 98833: Throw(JSContext *cx, nsresult rv);
 98833: 
 95445: } // namespace xpc
 95417: 
103075: nsCycleCollectionParticipant *
103075: xpc_JSCompartmentParticipant();
103075: 
 95445: namespace mozilla {
 80074: namespace dom {
 80092: namespace binding {
 80074: 
 80074: extern int HandlerFamily;
 80074: inline void* ProxyFamily() { return &HandlerFamily; }
 80074: inline bool instanceIsProxy(JSObject *obj)
 80074: {
 80074:     return js::IsProxy(obj) &&
 80074:            js::GetProxyHandler(obj)->family() == ProxyFamily();
 80074: }
 80074: 
 94512: typedef bool
 97127: (*DefineInterface)(JSContext *cx, JSObject *global, bool *enabled);
 80079: 
 80086: extern bool
 80086: DefineStaticJSVals(JSContext *cx);
 80079: void
 94512: Register(nsScriptNameSpaceManager* aNameSpaceManager);
 80079: extern bool
 80085: DefineConstructor(JSContext *cx, JSObject *obj, DefineInterface aDefine,
 80085:                   nsresult *aResult);
 80079: 
 80092: } // namespace binding
 80092: } // namespace dom
 80092: } // namespace mozilla
 80074: 
 74674: #endif
