    1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Oracle Corporation code.
    1:  *
    1:  * The Initial Developer of the Original Code is Oracle Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <pavlov@pavlov.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef GFX_IMAGESURFACE_H
    1: #define GFX_IMAGESURFACE_H
    1: 
    1: #include "gfxASurface.h"
    1: #include "gfxPoint.h"
    1: 
    1: // ARGB -- raw buffer.. wont be changed.. good for storing data.
    1: 
53939: class gfxSubimageSurface;
53939: 
96638: namespace mozilla {
96638: namespace gfx {
96638: class SourceSurface;
96638: }
96638: }
96638: 
    1: /**
    1:  * A raw image buffer. The format can be set in the constructor. Its main
    1:  * purpose is for storing read-only images and using it as a source surface,
    1:  * but it can also be drawn to.
    1:  */
    1: class THEBES_API gfxImageSurface : public gfxASurface {
    1: public:
    1:     /**
15751:      * Construct an image surface around an existing buffer of image data.
15751:      * @param aData A buffer containing the image data
15751:      * @param aSize The size of the buffer
15751:      * @param aStride The stride of the buffer
    1:      * @param format Format of the data
    1:      *
    1:      * @see gfxImageFormat
15751:      */
15751:     gfxImageSurface(unsigned char *aData, const gfxIntSize& aSize,
15751:                     long aStride, gfxImageFormat aFormat);
15751: 
15751:     /**
15751:      * Construct an image surface.
15751:      * @param aSize The size of the buffer
15751:      * @param format Format of the data
    1:      *
15751:      * @see gfxImageFormat
    1:      */
95670:     gfxImageSurface(const gfxIntSize& size, gfxImageFormat format, bool aClear = true);
    1:     gfxImageSurface(cairo_surface_t *csurf);
    1: 
    1:     virtual ~gfxImageSurface();
    1: 
    1:     // ImageSurface methods
    1:     gfxImageFormat Format() const { return mFormat; }
    1: 
52185:     virtual const gfxIntSize GetSize() const { return mSize; }
15297:     PRInt32 Width() const { return mSize.width; }
15297:     PRInt32 Height() const { return mSize.height; }
    1: 
    1:     /**
    1:      * Distance in bytes between the start of a line and the start of the
    1:      * next line.
    1:      */
15297:     PRInt32 Stride() const { return mStride; }
    1:     /**
    1:      * Returns a pointer for the image data. Users of this function can
    1:      * write to it, but must not attempt to free the buffer.
    1:      */
15297:     unsigned char* Data() const { return mData; } // delete this data under us and die.
15297:     /**
15297:      * Returns the total size of the image data.
15297:      */
15297:     PRInt32 GetDataSize() const { return mStride*mSize.height; }
    1: 
11244:     /* Fast copy from another image surface; returns TRUE if successful, FALSE otherwise */
79445:     bool CopyFrom (gfxImageSurface *other);
11244: 
96638:     /**
96638:      * Fast copy from a source surface; returns TRUE if successful, FALSE otherwise
96638:      * Assumes that the format of this surface is compatable with aSurface
96638:      */
96638:     bool CopyFrom (mozilla::gfx::SourceSurface *aSurface);
96638: 
53939:     /* return new Subimage with pointing to original image starting from aRect.pos
53939:      * and size of aRect.size. New subimage keeping current image reference
53939:      */
53939:     already_AddRefed<gfxSubimageSurface> GetSubimage(const gfxRect& aRect);
53939: 
57344:     virtual already_AddRefed<gfxImageSurface> GetAsImageSurface();
57344: 
63369:     /** See gfxASurface.h. */
63369:     NS_OVERRIDE
63369:     virtual void MovePixels(const nsIntRect& aSourceRect,
63369:                             const nsIntPoint& aDestTopLeft);
63369: 
42262: protected:
42262:     gfxImageSurface();
57209:     void InitWithData(unsigned char *aData, const gfxIntSize& aSize,
57209:                       long aStride, gfxImageFormat aFormat);
42262:     void InitFromSurface(cairo_surface_t *csurf);
59847:     long ComputeStride() const { return ComputeStride(mSize, mFormat); }
59847: 
59847:     static long ComputeStride(const gfxIntSize&, gfxImageFormat);
    1: 
79633:     void MakeInvalid();
79633: 
    1:     gfxIntSize mSize;
79445:     bool mOwnsData;
    1:     unsigned char *mData;
    1:     gfxImageFormat mFormat;
    1:     long mStride;
    1: };
    1: 
53939: class THEBES_API gfxSubimageSurface : public gfxImageSurface {
53939: protected:
53939:     friend class gfxImageSurface;
53939:     gfxSubimageSurface(gfxImageSurface* aParent,
53939:                        unsigned char* aData,
53939:                        const gfxIntSize& aSize);
53939: private:
53939:     nsRefPtr<gfxImageSurface> mParent;
53939: };
53939: 
    1: #endif /* GFX_IMAGESURFACE_H */
