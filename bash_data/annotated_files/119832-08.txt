     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
     1:  *
 99778:  * This Source Code Form is subject to the terms of the Mozilla Public
 99778:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99778:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 97210: #include "TransportSecurityInfo.h"
     1: #include "nsNSSComponent.h"
     1: #include "nsIWebProgressListener.h"
     1: #include "nsNSSCertificate.h"
  6597: #include "nsIX509CertValidity.h"
     1: #include "nsIDateTimeFormat.h"
     1: #include "nsDateTimeFormatCID.h"
  6597: #include "nsICertOverrideService.h"
  8463: #include "nsIObjectInputStream.h"
  8463: #include "nsIObjectOutputStream.h"
     1: #include "nsNSSCertHelper.h"
     1: #include "nsNSSCleaner.h"
  8463: #include "nsIProgrammingLanguage.h"
 33205: #include "nsIArray.h"
 79873: #include "PSMRunnable.h"
     1: 
     1: #include "secerr.h"
     1: 
     1: //#define DEBUG_SSL_VERBOSE //Enable this define to get minimal 
     1:                             //reports when doing SSL read/write
     1:                             
     1: //#define DUMP_BUFFER  //Enable this define along with
     1:                        //DEBUG_SSL_VERBOSE to dump SSL
     1:                        //read/write buffer to a log.
     1:                        //Uses PR_LOG except on Mac where
     1:                        //we always write out to our own
     1:                        //file.
     1: 
 97210: namespace {
 83083: 
     1: NSSCleanupAutoPtrClass(CERTCertificate, CERT_DestroyCertificate)
     1: 
 69383: static NS_DEFINE_CID(kNSSComponentCID, NS_NSSCOMPONENT_CID);
 69383: 
 97210: } // unnamed namespace
     1: 
 97210: namespace mozilla { namespace psm {
     1: 
 97210: TransportSecurityInfo::TransportSecurityInfo()
 97210:   : mMutex("TransportSecurityInfo::mMutex"),
     1:     mSecurityState(nsIWebProgressListener::STATE_IS_INSECURE),
 14244:     mSubRequestsHighSecurity(0),
 14244:     mSubRequestsLowSecurity(0),
 14244:     mSubRequestsBrokenSecurity(0),
 14244:     mSubRequestsNoSecurity(0),
 83081:     mErrorCode(0),
 83081:     mErrorMessageType(PlainErrorMessage),
 77514:     mPort(0),
 97210:     mIsCertIssuerBlacklisted(false)
     1: {
     1: }
     1: 
 97210: TransportSecurityInfo::~TransportSecurityInfo()
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return;
     1: 
     1:   shutdown(calledFromObject);
     1: }
     1: 
 97210: void
 97210: TransportSecurityInfo::virtualDestroyNSSReference()
     1: {
     1: }
     1: 
 97210: NS_IMPL_THREADSAFE_ISUPPORTS6(TransportSecurityInfo,
     1:                               nsITransportSecurityInfo,
     1:                               nsIInterfaceRequestor,
  5220:                               nsISSLStatusProvider,
 14244:                               nsIAssociatedContentSecurity,
  8463:                               nsISerializable,
 97210:                               nsIClassInfo)
     1: 
     1: nsresult
 97210: TransportSecurityInfo::SetHostName(const char* host)
     1: {
 27356:   mHostName.Adopt(host ? NS_strdup(host) : 0);
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
 97210: TransportSecurityInfo::GetHostName(char **host)
     1: {
106838:   *host = (mHostName) ? NS_strdup(mHostName) : nullptr;
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
108991: TransportSecurityInfo::SetPort(int32_t aPort)
     1: {
     1:   mPort = aPort;
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
108991: TransportSecurityInfo::GetPort(int32_t *aPort)
     1: {
     1:   *aPort = mPort;
     1:   return NS_OK;
     1: }
     1: 
 83081: PRErrorCode
 97210: TransportSecurityInfo::GetErrorCode() const
     1: {
 83081:   MutexAutoLock lock(mMutex);
 83081: 
 83081:   return mErrorCode;
 83081: }
 83081: 
 83081: void
 97210: TransportSecurityInfo::SetCanceled(PRErrorCode errorCode,
 83083:                                    SSLErrorMessageType errorMessageType)
     1: {
 83081:   MutexAutoLock lock(mMutex);
 83081: 
 83081:   mErrorCode = errorCode;
 83081:   mErrorMessageType = errorMessageType;
 83081:   mErrorMessageCached.Truncate();
     1: }
     1: 
     1: NS_IMETHODIMP
108991: TransportSecurityInfo::GetSecurityState(uint32_t* state)
     1: {
     1:   *state = mSecurityState;
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
108991: TransportSecurityInfo::SetSecurityState(uint32_t aState)
     1: {
     1:   mSecurityState = aState;
     1:   return NS_OK;
     1: }
     1: 
 14244: /* attribute unsigned long countSubRequestsHighSecurity; */
 97210: NS_IMETHODIMP
 97210: TransportSecurityInfo::GetCountSubRequestsHighSecurity(
108991:   int32_t *aSubRequestsHighSecurity)
 14244: {
 14244:   *aSubRequestsHighSecurity = mSubRequestsHighSecurity;
 14244:   return NS_OK;
 14244: }
 97210: 
 97210: NS_IMETHODIMP
 97210: TransportSecurityInfo::SetCountSubRequestsHighSecurity(
108991:   int32_t aSubRequestsHighSecurity)
 14244: {
 14244:   mSubRequestsHighSecurity = aSubRequestsHighSecurity;
 14244:   return NS_ERROR_NOT_IMPLEMENTED;
 14244: }
 14244: 
 14244: /* attribute unsigned long countSubRequestsLowSecurity; */
 97210: NS_IMETHODIMP
 97210: TransportSecurityInfo::GetCountSubRequestsLowSecurity(
108991:   int32_t *aSubRequestsLowSecurity)
 14244: {
 14244:   *aSubRequestsLowSecurity = mSubRequestsLowSecurity;
 14244:   return NS_OK;
 14244: }
 97210: 
 97210: NS_IMETHODIMP
 97210: TransportSecurityInfo::SetCountSubRequestsLowSecurity(
108991:   int32_t aSubRequestsLowSecurity)
 14244: {
 14244:   mSubRequestsLowSecurity = aSubRequestsLowSecurity;
 14244:   return NS_OK;
 14244: }
 14244: 
 14244: /* attribute unsigned long countSubRequestsBrokenSecurity; */
 97210: NS_IMETHODIMP
 97210: TransportSecurityInfo::GetCountSubRequestsBrokenSecurity(
108991:   int32_t *aSubRequestsBrokenSecurity)
 14244: {
 14244:   *aSubRequestsBrokenSecurity = mSubRequestsBrokenSecurity;
 14244:   return NS_OK;
 14244: }
 97210: 
 97210: NS_IMETHODIMP
 97210: TransportSecurityInfo::SetCountSubRequestsBrokenSecurity(
108991:   int32_t aSubRequestsBrokenSecurity)
 14244: {
 14244:   mSubRequestsBrokenSecurity = aSubRequestsBrokenSecurity;
 14244:   return NS_OK;
 14244: }
 14244: 
 14244: /* attribute unsigned long countSubRequestsNoSecurity; */
 97210: NS_IMETHODIMP
 97210: TransportSecurityInfo::GetCountSubRequestsNoSecurity(
108991:   int32_t *aSubRequestsNoSecurity)
 14244: {
 14244:   *aSubRequestsNoSecurity = mSubRequestsNoSecurity;
 14244:   return NS_OK;
 14244: }
 97210: 
 97210: NS_IMETHODIMP
 97210: TransportSecurityInfo::SetCountSubRequestsNoSecurity(
108991:   int32_t aSubRequestsNoSecurity)
 14244: {
 14244:   mSubRequestsNoSecurity = aSubRequestsNoSecurity;
 14244:   return NS_OK;
 14244: }
 97210: 
 97210: NS_IMETHODIMP
 97210: TransportSecurityInfo::Flush()
 50566: {
 50566:   return NS_OK;
 50566: }
 14244: 
     1: NS_IMETHODIMP
 97210: TransportSecurityInfo::GetShortSecurityDescription(PRUnichar** aText)
 97210: {
     1:   if (mShortDesc.IsEmpty())
106838:     *aText = nullptr;
     1:   else {
     1:     *aText = ToNewUnicode(mShortDesc);
     1:     NS_ENSURE_TRUE(*aText, NS_ERROR_OUT_OF_MEMORY);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
 97210: TransportSecurityInfo::SetShortSecurityDescription(const PRUnichar* aText)
 97210: {
     1:   mShortDesc.Assign(aText);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
 97210: TransportSecurityInfo::GetErrorMessage(PRUnichar** aText)
 83081: {
 83081:   NS_ENSURE_ARG_POINTER(aText);
106838:   *aText = nullptr;
 83081: 
 83081:   if (!NS_IsMainThread()) {
 83081:     NS_ERROR("nsNSSSocketInfo::GetErrorMessage called off the main thread");
 83081:     return NS_ERROR_NOT_SAME_THREAD;
 83081:   }
 83081: 
 83081:   MutexAutoLock lock(mMutex);
 83081: 
110523:   if (mErrorMessageCached.IsEmpty()) {
110523:     nsresult rv = formatErrorMessage(lock, 
110523:                                      mErrorCode, mErrorMessageType,
110523:                                      true, true, mErrorMessageCached);
 83081:     NS_ENSURE_SUCCESS(rv, rv);
110523:   }
 83081: 
 83081:   *aText = ToNewUnicode(mErrorMessageCached);
119832:   return *aText != nullptr ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
 83081: }
 83081: 
110523: void
110523: TransportSecurityInfo::GetErrorLogMessage(PRErrorCode errorCode,
110523:                                           SSLErrorMessageType errorMessageType,
110523:                                           nsString &result)
110523: {
110523:   if (!NS_IsMainThread()) {
110523:     NS_ERROR("nsNSSSocketInfo::GetErrorLogMessage called off the main thread");
110523:     return;
110523:   }
110523: 
110523:   MutexAutoLock lock(mMutex);
110523:   (void) formatErrorMessage(lock, errorCode, errorMessageType,
110523:                             false, false, result);
110523: }
110523: 
 83081: static nsresult
108991: formatPlainErrorMessage(nsXPIDLCString const & host, int32_t port,
110523:                         PRErrorCode err, 
110523:                         bool suppressPort443,
110523:                         nsString &returnedMessage);
 83081: 
 83081: static nsresult
 83081: formatOverridableCertErrorMessage(nsISSLStatus & sslStatus,
 83081:                                   PRErrorCode errorCodeToReport, 
108991:                                   const nsXPIDLCString & host, int32_t port,
110523:                                   bool suppressPort443,
110523:                                   bool wantsHtml,
 83081:                                   nsString & returnedMessage);
 83081: 
 83081: // XXX: uses nsNSSComponent string bundles off the main thread when called by
110523: //      nsNSSSocketInfo::Write().
 83081: nsresult
110523: TransportSecurityInfo::formatErrorMessage(MutexAutoLock const & proofOfLock, 
110523:                                           PRErrorCode errorCode,
110523:                                           SSLErrorMessageType errorMessageType,
110523:                                           bool wantsHtml, bool suppressPort443, 
110523:                                           nsString &result)
 83081: {
110523:   if (errorCode == 0) {
110523:     result.Truncate();
     1:     return NS_OK;
     1:   }
     1: 
 83081:   nsresult rv;
 83081:   NS_ConvertASCIItoUTF16 hostNameU(mHostName);
110523:   NS_ASSERTION(errorMessageType != OverridableCertErrorMessage || 
 83081:                 (mSSLStatus && mSSLStatus->mServerCert &&
 83081:                  mSSLStatus->mHaveCertErrorBits),
110523:                 "GetErrorLogMessage called for cert error without cert");
110523:   if (errorMessageType == OverridableCertErrorMessage && 
 83081:       mSSLStatus && mSSLStatus->mServerCert) {
110523:     rv = formatOverridableCertErrorMessage(*mSSLStatus, errorCode,
 83081:                                            mHostName, mPort,
110523:                                            suppressPort443,
110523:                                            wantsHtml,
110523:                                            result);
 83081:   } else {
110523:     rv = formatPlainErrorMessage(mHostName, mPort, 
110523:                                  errorCode,
110523:                                  suppressPort443,
110523:                                  result);
 83081:   }
 83081: 
 83081:   if (NS_FAILED(rv)) {
110523:     result.Truncate();
 83081:   }
 83081: 
 83081:   return rv;
     1: }
     1: 
     1: /* void getInterface (in nsIIDRef uuid, [iid_is (uuid), retval] out nsQIResult result); */
 97210: NS_IMETHODIMP
 97210: TransportSecurityInfo::GetInterface(const nsIID & uuid, void * *result)
     1: {
 81303:   if (!NS_IsMainThread()) {
 81303:     NS_ERROR("nsNSSSocketInfo::GetInterface called off the main thread");
 81303:     return NS_ERROR_NOT_SAME_THREAD;
 81303:   }
 81303: 
     1:   nsresult rv;
     1:   if (!mCallbacks) {
     1:     nsCOMPtr<nsIInterfaceRequestor> ir = new PipUIContext();
119832:     if (!ir)
119832:       return NS_ERROR_OUT_OF_MEMORY;
119832: 
     1:     rv = ir->GetInterface(uuid, result);
     1:   } else {
 81303:     rv = mCallbacks->GetInterface(uuid, result);
     1:   }
     1:   return rv;
     1: }
     1: 
 97210: static NS_DEFINE_CID(kNSSCertificateCID, NS_X509CERT_CID);
 97210: #define TRANSPORTSECURITYINFOMAGIC { 0xa9863a23, 0x26b8, 0x4a9c, \
 97210:   { 0x83, 0xf1, 0xe9, 0xda, 0xdb, 0x36, 0xb8, 0x30 } }
 97210: static NS_DEFINE_CID(kTransportSecurityInfoMagic, TRANSPORTSECURITYINFOMAGIC);
     1: 
     1: NS_IMETHODIMP
 97210: TransportSecurityInfo::Write(nsIObjectOutputStream* stream)
     1: {
 97210:   stream->WriteID(kTransportSecurityInfoMagic);
 50565: 
 83081:   MutexAutoLock lock(mMutex);
 83081: 
119832:   nsRefPtr<nsSSLStatus> status = mSSLStatus;
 81084:   nsCOMPtr<nsISerializable> certSerializable;
 81084: 
 81084:   // Write a redundant copy of the certificate for backward compatibility
 81084:   // with previous versions, which also unnecessarily wrote it.
 81084:   //
 50565:   // As we are reading the object our self, not using ReadObject, we have
 50565:   // to store it here 'manually' as well, mimicking our object stream
 50565:   // implementation.
 81084: 
 81084:   if (status) {
 81084:     nsCOMPtr<nsIX509Cert> cert = status->mServerCert;
 81084:     certSerializable = do_QueryInterface(cert);
 81084: 
 81084:     if (!certSerializable) {
 81084:       NS_ERROR("certificate is missing or isn't serializable");
 81084:       return NS_ERROR_UNEXPECTED;
 81084:     }
 81084:   } else {
 81084:     NS_WARNING("Serializing nsNSSSocketInfo without mSSLStatus");
 81084:   }
 81084: 
 81084:   // Store the flag if there is the certificate present
 81084:   stream->WriteBoolean(certSerializable);
 50565:   if (certSerializable) {
 50565:     stream->WriteID(kNSSCertificateCID);
 50565:     stream->WriteID(NS_GET_IID(nsISupports));
 50565:     certSerializable->Write(stream);
 50565:   }
 29655: 
 29655:   // Store the version number of the binary stream data format.
 29655:   // The 0xFFFF0000 mask is included to the version number
 29655:   // to distinguish version number from mSecurityState
 29655:   // field stored in times before versioning has been introduced.
 29655:   // This mask value has been chosen as mSecurityState could
 29655:   // never be assigned such value.
108991:   uint32_t version = 3;
 29655:   stream->Write32(version | 0xFFFF0000);
  8463:   stream->Write32(mSecurityState);
  8463:   stream->WriteWStringZ(mShortDesc.get());
 83081: 
 83081:   // XXX: uses nsNSSComponent string bundles off the main thread
110523:   nsresult rv = formatErrorMessage(lock, 
110523:                                    mErrorCode, mErrorMessageType,
110523:                                    true, true, mErrorMessageCached);
 83081:   NS_ENSURE_SUCCESS(rv, rv);
 83081:   stream->WriteWStringZ(mErrorMessageCached.get());
  8463: 
 81084:   stream->WriteCompoundObject(NS_ISUPPORTS_CAST(nsISSLStatus*, status),
 80486:                               NS_GET_IID(nsISupports), true);
 29655: 
108991:   stream->Write32((uint32_t)mSubRequestsHighSecurity);
108991:   stream->Write32((uint32_t)mSubRequestsLowSecurity);
108991:   stream->Write32((uint32_t)mSubRequestsBrokenSecurity);
108991:   stream->Write32((uint32_t)mSubRequestsNoSecurity);
  8463:   return NS_OK;
  8463: }
  8463: 
108991: static bool CheckUUIDEquals(uint32_t m0,
 50565:                             nsIObjectInputStream* stream,
 50565:                             const nsCID& id)
 50565: {
 50565:   nsID tempID;
 50565:   tempID.m0 = m0;
 50565:   stream->Read16(&tempID.m1);
 50565:   stream->Read16(&tempID.m2);
 50565:   for (int i = 0; i < 8; ++i)
 50565:     stream->Read8(&tempID.m3[i]);
 50565:   return tempID.Equals(id);
 50565: }
 50565: 
  8463: NS_IMETHODIMP
 97210: TransportSecurityInfo::Read(nsIObjectInputStream* stream)
 97210: {
 50565:   nsresult rv;
  8463: 
108991:   uint32_t version;
 79445:   bool certificatePresent;
 50565: 
 50565:   // Check what we have here...
108991:   uint32_t UUID_0;
 50565:   stream->Read32(&UUID_0);
 97210:   if (UUID_0 == kTransportSecurityInfoMagic.m0) {
 50565:     // It seems this stream begins with our magic ID, check it really is there
 97210:     if (!CheckUUIDEquals(UUID_0, stream, kTransportSecurityInfoMagic))
 50565:       return NS_ERROR_FAILURE;
 50565: 
 50565:     // OK, this seems to be our stream, now continue to check there is
 50565:     // the certificate
 50565:     stream->ReadBoolean(&certificatePresent);
 50565:     stream->Read32(&UUID_0);
 50565:   }
 50565:   else {
 50565:     // There is no magic, assume there is a certificate present as in versions
 50565:     // prior to those with the magic didn't store that flag; we check the 
 50565:     // certificate is present by cheking the CID then
 80486:     certificatePresent = true;
 50565:   }
 50565: 
 50565:   if (certificatePresent && UUID_0 == kNSSCertificateCID.m0) {
 50565:     // It seems there is the certificate CID present, check it now; we only
 50565:     // have this single certificate implementation at this time.
 50565:     if (!CheckUUIDEquals(UUID_0, stream, kNSSCertificateCID))
 50565:       return NS_ERROR_FAILURE;
 50565: 
 50565:     // OK, we have read the CID of the certificate, check the interface ID
 50565:     nsID tempID;
 50565:     stream->ReadID(&tempID);
 50565:     if (!tempID.Equals(NS_GET_IID(nsISupports)))
 50565:       return NS_ERROR_FAILURE;
 50565: 
 50565:     nsCOMPtr<nsISerializable> serializable =
 50565:         do_CreateInstance(kNSSCertificateCID, &rv);
 50565:     NS_ENSURE_SUCCESS(rv, rv);
 50565: 
 81084:     // This is the redundant copy of the certificate; just ignore it
 50565:     serializable->Read(stream);
 50565: 
 50565:     // We are done with reading the certificate, now read the version
 50565:     // as we did before.
 29655:     stream->Read32(&version);
 50565:   }
 50565:   else {
 50565:     // There seems not to be the certificate present in the stream.
 50565:     version = UUID_0;
 50565:   }
 50565: 
 83081:   MutexAutoLock lock(mMutex);
 83081: 
 29655:   // If the version field we have just read is not masked with 0xFFFF0000
 29655:   // then it is stored mSecurityState field and this is version 1 of
 29655:   // the binary data stream format.
 29655:   if ((version & 0xFFFF0000) == 0xFFFF0000) {
 29655:     version &= ~0xFFFF0000;
  8463:     stream->Read32(&mSecurityState);
 29655:   }
 29655:   else {
 29655:     mSecurityState = version;
 29655:     version = 1;
 29655:   }
  8463:   stream->ReadString(mShortDesc);
 83081:   stream->ReadString(mErrorMessageCached);
 83081:   mErrorCode = 0;
  8463: 
 50565:   nsCOMPtr<nsISupports> obj;
 80486:   stream->ReadObject(true, getter_AddRefs(obj));
 81084:   
  8463:   mSSLStatus = reinterpret_cast<nsSSLStatus*>(obj.get());
 29655: 
 81084:   if (!mSSLStatus) {
 81084:     NS_WARNING("deserializing nsNSSSocketInfo without mSSLStatus");
 81084:   }
 81084: 
 29655:   if (version >= 2) {
108991:     stream->Read32((uint32_t*)&mSubRequestsHighSecurity);
108991:     stream->Read32((uint32_t*)&mSubRequestsLowSecurity);
108991:     stream->Read32((uint32_t*)&mSubRequestsBrokenSecurity);
108991:     stream->Read32((uint32_t*)&mSubRequestsNoSecurity);
 29655:   }
 29655:   else {
 29655:     mSubRequestsHighSecurity = 0;
 29655:     mSubRequestsLowSecurity = 0;
 29655:     mSubRequestsBrokenSecurity = 0;
 29655:     mSubRequestsNoSecurity = 0;
 29655:   }
  8463:   return NS_OK;
  8463: }
  8463: 
  8463: NS_IMETHODIMP
108991: TransportSecurityInfo::GetInterfaces(uint32_t *count, nsIID * **array)
  8463: {
  8463:   *count = 0;
106838:   *array = nullptr;
  8463:   return NS_OK;
  8463: }
  8463: 
  8463: NS_IMETHODIMP
108991: TransportSecurityInfo::GetHelperForLanguage(uint32_t language,
 97210:                                             nsISupports **_retval)
  8463: {
106838:   *_retval = nullptr;
  8463:   return NS_OK;
  8463: }
  8463: 
  8463: NS_IMETHODIMP
 97210: TransportSecurityInfo::GetContractID(char * *aContractID)
  8463: {
106838:   *aContractID = nullptr;
  8463:   return NS_OK;
  8463: }
  8463: 
  8463: NS_IMETHODIMP
 97210: TransportSecurityInfo::GetClassDescription(char * *aClassDescription)
  8463: {
106838:   *aClassDescription = nullptr;
  8463:   return NS_OK;
  8463: }
  8463: 
  8463: NS_IMETHODIMP
 97210: TransportSecurityInfo::GetClassID(nsCID * *aClassID)
  8463: {
  8463:   *aClassID = (nsCID*) nsMemory::Alloc(sizeof(nsCID));
  8463:   if (!*aClassID)
  8463:     return NS_ERROR_OUT_OF_MEMORY;
  8463:   return GetClassIDNoAlloc(*aClassID);
  8463: }
  8463: 
  8463: NS_IMETHODIMP
 97210: TransportSecurityInfo::GetImplementationLanguage(
108991:   uint32_t *aImplementationLanguage)
  8463: {
  8463:   *aImplementationLanguage = nsIProgrammingLanguage::CPLUSPLUS;
  8463:   return NS_OK;
  8463: }
  8463: 
  8463: NS_IMETHODIMP
108991: TransportSecurityInfo::GetFlags(uint32_t *aFlags)
  8463: {
  8463:   *aFlags = 0;
  8463:   return NS_OK;
  8463: }
  8463: 
 97210: static NS_DEFINE_CID(kNSSSocketInfoCID, TRANSPORTSECURITYINFO_CID);
  8463: 
  8463: NS_IMETHODIMP
 97210: TransportSecurityInfo::GetClassIDNoAlloc(nsCID *aClassIDNoAlloc)
  8463: {
  8463:   *aClassIDNoAlloc = kNSSSocketInfoCID;
  8463:   return NS_OK;
  8463: }
  8463: 
 97210: nsresult
 97210: TransportSecurityInfo::GetSSLStatus(nsISSLStatus** _result)
 10258: {
 10258:   NS_ENSURE_ARG_POINTER(_result);
 10258: 
 81084:   *_result = mSSLStatus;
     1:   NS_IF_ADDREF(*_result);
     1: 
     1:   return NS_OK;
     1: }
     1: 
 97210: nsresult
 97210: TransportSecurityInfo::SetSSLStatus(nsSSLStatus *aSSLStatus)
     1: {
     1:   mSSLStatus = aSSLStatus;
     1: 
     1:   return NS_OK;
     1: }
     1: 
 83081: /* Formats an error message for non-certificate-related SSL errors
 83081:  * and non-overridable certificate errors (both are of type
 83081:  * PlainErrormMessage). Use formatOverridableCertErrorMessage
 83081:  * for overridable cert errors.
 83081:  */
     1: static nsresult
108991: formatPlainErrorMessage(const nsXPIDLCString &host, int32_t port,
110523:                         PRErrorCode err, 
110523:                         bool suppressPort443,
110523:                         nsString &returnedMessage)
     1: {
     1:   const PRUnichar *params[1];
     1:   nsresult rv;
     1: 
 83081:   nsCOMPtr<nsINSSComponent> component = do_GetService(kNSSComponentCID, &rv);
 83081:   NS_ENSURE_SUCCESS(rv, rv);
 83081: 
     1:   if (host.Length())
     1:   {
  7252:     nsString hostWithPort;
  7252: 
 79869:     // For now, hide port when it's 443 and we're reporting the error.
 79869:     // In the future a better mechanism should be used
  7252:     // to make a decision about showing the port number, possibly by requiring
  7252:     // the context object to implement a specific interface.
  7252:     // The motivation is that Mozilla browser would like to hide the port number
  7252:     // in error pages in the common case.
  7252: 
 83081:     hostWithPort.AssignASCII(host);
110523:     if (!suppressPort443 || port != 443) {
  7252:       hostWithPort.AppendLiteral(":");
  7252:       hostWithPort.AppendInt(port);
 83081:     }
  7252:     params[0] = hostWithPort.get();
     1: 
     1:     nsString formattedString;
     1:     rv = component->PIPBundleFormatStringFromName("SSLConnectionErrorPrefix", 
     1:                                                   params, 1, 
     1:                                                   formattedString);
     1:     if (NS_SUCCEEDED(rv))
     1:     {
     1:       returnedMessage.Append(formattedString);
  7252:       returnedMessage.Append(NS_LITERAL_STRING("\n\n"));
     1:     }
     1:   }
     1: 
     1:   nsString explanation;
     1:   rv = nsNSSErrors::getErrorMessageFromCode(err, component, explanation);
     1:   if (NS_SUCCEEDED(rv))
     1:     returnedMessage.Append(explanation);
     1: 
     1:   return NS_OK;
     1: }
     1: 
  7879: static void
  7879: AppendErrorTextUntrusted(PRErrorCode errTrust,
  6597:                          const nsString &host,
  6597:                          nsIX509Cert* ix509,
  6597:                          nsINSSComponent *component,
  6597:                          nsString &returnedMessage)
  6597: {
106838:   const char *errorID = nullptr;
  7252:   nsCOMPtr<nsIX509Cert3> cert3 = do_QueryInterface(ix509);
  7252:   if (cert3) {
 79445:     bool isSelfSigned;
  7252:     if (NS_SUCCEEDED(cert3->GetIsSelfSigned(&isSelfSigned))
  7252:         && isSelfSigned) {
  7252:       errorID = "certErrorTrust_SelfSigned";
  7252:     }
  7252:   }
  7252: 
  7252:   if (!errorID) {
  7252:     switch (errTrust) {
  7252:       case SEC_ERROR_UNKNOWN_ISSUER:
 33205:       {
 33205:         nsCOMPtr<nsIArray> chain;
 33205:         ix509->GetChain(getter_AddRefs(chain));
108991:         uint32_t length = 0;
 33205:         if (chain && NS_FAILED(chain->GetLength(&length)))
 33205:           length = 0;
 33205:         if (length == 1)
 33205:           errorID = "certErrorTrust_MissingChain";
 33205:         else
  7252:           errorID = "certErrorTrust_UnknownIssuer";
  7252:         break;
 33205:       }
 13929:       case SEC_ERROR_INADEQUATE_KEY_USAGE:
 13929:         // Should get an individual string in the future
 13929:         // For now, use the same as CaInvalid
  7252:       case SEC_ERROR_CA_CERT_INVALID:
  7252:         errorID = "certErrorTrust_CaInvalid";
  7252:         break;
  7252:       case SEC_ERROR_UNTRUSTED_ISSUER:
  7252:         errorID = "certErrorTrust_Issuer";
  7252:         break;
104409:       case SEC_ERROR_CERT_SIGNATURE_ALGORITHM_DISABLED:
104409:         errorID = "certErrorTrust_SignatureAlgorithmDisabled";
104409:         break;
  7252:       case SEC_ERROR_EXPIRED_ISSUER_CERTIFICATE:
  7252:         errorID = "certErrorTrust_ExpiredIssuer";
  7252:         break;
  7252:       case SEC_ERROR_UNTRUSTED_CERT:
  7252:       default:
  7252:         errorID = "certErrorTrust_Untrusted";
  7252:         break;
  7252:     }
  7252:   }
  7252: 
  6597:   nsString formattedString;
  7879:   nsresult rv = component->GetPIPNSSBundleString(errorID, 
  6597:                                                  formattedString);
  6597:   if (NS_SUCCEEDED(rv))
  6597:   {
  6597:     returnedMessage.Append(formattedString);
  6597:     returnedMessage.Append(NS_LITERAL_STRING("\n"));
  6597:   }
  6597: }
  6597: 
 31588: // returns TRUE if SAN was used to produce names
 31588: // return FALSE if nothing was produced
  7879: // names => a single name or a list of names
  7879: // multipleNames => whether multiple names were delivered
 79445: static bool
  7879: GetSubjectAltNames(CERTCertificate *nssCert,
  7879:                    nsINSSComponent *component,
  7879:                    nsString &allNames,
108991:                    uint32_t &nameCount)
  6597: {
  7879:   allNames.Truncate();
 10259:   nameCount = 0;
  7252: 
119200:   PLArenaPool *san_arena = nullptr;
119832:   SECItem altNameExtension = {siBuffer, NULL, 0 };
106838:   CERTGeneralName *sanNameList = nullptr;
  7252: 
106860:   SECStatus rv = CERT_FindCertExtension(nssCert, SEC_OID_X509_SUBJECT_ALT_NAME,
  7252:                                         &altNameExtension);
  7252:   if (rv != SECSuccess)
 80486:     return false;
 31588: 
 31588:   san_arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
 31588:   if (!san_arena)
 80486:     return false;
  7879: 
  7252:   sanNameList = CERT_DecodeAltNameExtension(san_arena, &altNameExtension);
 31588:   if (!sanNameList)
 80486:     return false;
 80486: 
 80486:   SECITEM_FreeItem(&altNameExtension, false);
  7252: 
  7252:   CERTGeneralName *current = sanNameList;
  7252:   do {
  7252:     nsAutoString name;
  7252:     switch (current->type) {
  7252:       case certDNSName:
  7252:         name.AssignASCII((char*)current->name.other.data, current->name.other.len);
  7252:         if (!allNames.IsEmpty()) {
 14197:           allNames.Append(NS_LITERAL_STRING(" , "));
 14197:         }
 10259:         ++nameCount;
  7252:         allNames.Append(name);
  7252:         break;
  7252: 
  7252:       case certIPAddress:
  7252:         {
  7252:           char buf[INET6_ADDRSTRLEN];
  7252:           PRNetAddr addr;
  7252:           if (current->name.other.len == 4) {
  7252:             addr.inet.family = PR_AF_INET;
  7252:             memcpy(&addr.inet.ip, current->name.other.data, current->name.other.len);
  7252:             PR_NetAddrToString(&addr, buf, sizeof(buf));
  7252:             name.AssignASCII(buf);
  7252:           } else if (current->name.other.len == 16) {
  7252:             addr.ipv6.family = PR_AF_INET6;
  7252:             memcpy(&addr.ipv6.ip, current->name.other.data, current->name.other.len);
  7252:             PR_NetAddrToString(&addr, buf, sizeof(buf));
  7252:             name.AssignASCII(buf);
  7252:           } else {
  7252:             /* invalid IP address */
  7252:           }
  7252:           if (!name.IsEmpty()) {
  7252:             if (!allNames.IsEmpty()) {
 14197:               allNames.Append(NS_LITERAL_STRING(" , "));
 14197:             }
 10259:             ++nameCount;
  7252:             allNames.Append(name);
  7252:           }
  7252:           break;
  7252:         }
  7252: 
  7252:       default: // all other types of names are ignored
  7252:         break;
  7252:     }
  7252:     current = CERT_GetNextGeneralName(current);
  7252:   } while (current != sanNameList); // double linked
 31588: 
 80486:   PORT_FreeArena(san_arena, false);
 80486:   return true;
  7252: }
  7879: 
  7879: static void
  7879: AppendErrorTextMismatch(const nsString &host,
  7879:                         nsIX509Cert* ix509,
  7879:                         nsINSSComponent *component,
110523:                         bool wantsHtml,
  7879:                         nsString &returnedMessage)
  7879: {
  7879:   const PRUnichar *params[1];
  7879:   nsresult rv;
  7879: 
119832:   CERTCertificate *nssCert = NULL;
  7879:   CERTCertificateCleaner nssCertCleaner(nssCert);
  7879: 
  7879:   nsCOMPtr<nsIX509Cert2> cert2 = do_QueryInterface(ix509, &rv);
  7879:   if (cert2)
  7879:     nssCert = cert2->GetCert();
  7879: 
  7879:   if (!nssCert) {
  7879:     // We are unable to extract the valid names, say "not valid for name".
  7879:     params[0] = host.get();
  7879:     nsString formattedString;
  7879:     rv = component->PIPBundleFormatStringFromName("certErrorMismatch", 
  7879:                                                   params, 1, 
  7879:                                                   formattedString);
  7879:     if (NS_SUCCEEDED(rv)) {
  7879:       returnedMessage.Append(formattedString);
  7879:       returnedMessage.Append(NS_LITERAL_STRING("\n"));
  7879:     }
  7879:     return;
  7879:   }
  7879: 
  7879:   nsString allNames;
108991:   uint32_t nameCount = 0;
 79445:   bool useSAN = false;
  7879: 
  7879:   if (nssCert)
 10259:     useSAN = GetSubjectAltNames(nssCert, component, allNames, nameCount);
  7252: 
  7252:   if (!useSAN) {
106838:     char *certName = nullptr;
  7879:     // currently CERT_FindNSStringExtension is not being exported by NSS.
  7879:     // If it gets exported, enable the following line.
  7252:     //   certName = CERT_FindNSStringExtension(nssCert, SEC_OID_NS_CERT_EXT_SSL_SERVER_NAME);
  7879:     // However, it has been discussed to treat the extension as obsolete and ignore it.
  7879:     if (!certName)
  7252:       certName = CERT_GetCommonName(&nssCert->subject);
  7879:     if (certName) {
 10259:       ++nameCount;
  7252:       allNames.AssignASCII(certName);
  7252:       PORT_Free(certName);
  7252:     }
  7879:   }
  7252: 
 10259:   if (nameCount > 1) {
  7252:     nsString message;
  7252:     rv = component->GetPIPNSSBundleString("certErrorMismatchMultiple", 
  7252:                                           message);
  7252:     if (NS_SUCCEEDED(rv)) {
  7252:       returnedMessage.Append(message);
  7252:       returnedMessage.Append(NS_LITERAL_STRING("\n  "));
  7252:       returnedMessage.Append(allNames);
  7252:       returnedMessage.Append(NS_LITERAL_STRING("  \n"));
  7252:     }
  7252:   }
 10259:   else if (nameCount == 1) {
  7879:     const PRUnichar *params[1];
  7252:     params[0] = allNames.get();
  6597:     
110523:     const char *stringID;
110523:     if (wantsHtml)
110523:       stringID = "certErrorMismatchSingle2";
110523:     else
110523:       stringID = "certErrorMismatchSinglePlain";
110523: 
  6597:     nsString formattedString;
110523:     rv = component->PIPBundleFormatStringFromName(stringID, 
  6597:                                                   params, 1, 
  6597:                                                   formattedString);
  7252:     if (NS_SUCCEEDED(rv)) {
  6597:       returnedMessage.Append(formattedString);
  6597:       returnedMessage.Append(NS_LITERAL_STRING("\n"));
  6597:     }
  6597:   }
 10259:   else { // nameCount == 0
 10259:     nsString message;
 10259:     nsresult rv = component->GetPIPNSSBundleString("certErrorMismatchNoNames",
 10259:                                                    message);
 10259:     if (NS_SUCCEEDED(rv)) {
 10259:       returnedMessage.Append(message);
 10259:       returnedMessage.Append(NS_LITERAL_STRING("\n"));
 10259:     }
 10259:   }
  7252: }
  6597: 
  7879: static void
  7879: GetDateBoundary(nsIX509Cert* ix509,
  7879:                 nsString &formattedDate,
 33222:                 nsString &nowDate,
 79445:                 bool &trueExpired_falseNotYetValid)
  6597: {
 80486:   trueExpired_falseNotYetValid = true;
  7879:   formattedDate.Truncate();
  7879: 
  6597:   PRTime notAfter, notBefore, timeToUse;
  6597:   nsCOMPtr<nsIX509CertValidity> validity;
  7879:   nsresult rv;
  6597: 
  6597:   rv = ix509->GetValidity(getter_AddRefs(validity));
  6597:   if (NS_FAILED(rv))
  7879:     return;
  6597: 
  6597:   rv = validity->GetNotAfter(&notAfter);
  6597:   if (NS_FAILED(rv))
  7879:     return;
  6597: 
  6597:   rv = validity->GetNotBefore(&notBefore);
  6597:   if (NS_FAILED(rv))
  7879:     return;
  7879: 
 33222:   PRTime now = PR_Now();
115938:   if (now > notAfter) {
  6597:     timeToUse = notAfter;
  6597:   } else {
  6597:     timeToUse = notBefore;
 80486:     trueExpired_falseNotYetValid = false;
  6597:   }
  6597: 
 33222:   nsCOMPtr<nsIDateTimeFormat> dateTimeFormat(do_CreateInstance(NS_DATETIMEFORMAT_CONTRACTID, &rv));
  6597:   if (NS_FAILED(rv))
  7879:     return;
  6597: 
106838:   dateTimeFormat->FormatPRTime(nullptr, kDateFormatShort, 
  6597:                                kTimeFormatNoSeconds, timeToUse, 
  6597:                                formattedDate);
106838:   dateTimeFormat->FormatPRTime(nullptr, kDateFormatShort,
 33222:                                kTimeFormatNoSeconds, now,
 33222:                                nowDate);
  7879: }
  7879: 
  7879: static void
  7879: AppendErrorTextTime(nsIX509Cert* ix509,
  7879:                     nsINSSComponent *component,
  7879:                     nsString &returnedMessage)
  7879: {
 33222:   nsAutoString formattedDate, nowDate;
 79445:   bool trueExpired_falseNotYetValid;
 33222:   GetDateBoundary(ix509, formattedDate, nowDate, trueExpired_falseNotYetValid);
 33222: 
 33222:   const PRUnichar *params[2];
  7879:   params[0] = formattedDate.get(); // might be empty, if helper function had a problem 
 33222:   params[1] = nowDate.get();
  7879: 
  7879:   const char *key = trueExpired_falseNotYetValid ? 
 33222:                     "certErrorExpiredNow" : "certErrorNotYetValidNow";
  7879:   nsresult rv;
  6597:   nsString formattedString;
 33222:   rv = component->PIPBundleFormatStringFromName(
 33222:            key,
 33222:            params, 
 80467:            ArrayLength(params),
 33222:            formattedString);
  6597:   if (NS_SUCCEEDED(rv))
  6597:   {
  6597:     returnedMessage.Append(formattedString);
  6597:     returnedMessage.Append(NS_LITERAL_STRING("\n"));
  6597:   }
  6597: }
  6597: 
  7879: static void
  7879: AppendErrorTextCode(PRErrorCode errorCodeToReport,
  7879:                     nsINSSComponent *component,
  7879:                     nsString &returnedMessage)
  7879: {
  6597:   const char *codeName = nsNSSErrors::getDefaultErrorStringName(errorCodeToReport);
  6597:   if (codeName)
  6597:   {
  6597:     nsCString error_id(codeName);
  6597:     ToLowerCase(error_id);
  6597:     NS_ConvertASCIItoUTF16 idU(error_id);
  6597: 
  7879:     const PRUnichar *params[1];
  7252:     params[0] = idU.get();
  7252: 
  7252:     nsString formattedString;
  7879:     nsresult rv;
  7252:     rv = component->PIPBundleFormatStringFromName("certErrorCodePrefix", 
  7252:                                                   params, 1, 
  7252:                                                   formattedString);
  7252:     if (NS_SUCCEEDED(rv)) {
  7252:       returnedMessage.Append(NS_LITERAL_STRING("\n"));
  7252:       returnedMessage.Append(formattedString);
  7252:       returnedMessage.Append(NS_LITERAL_STRING("\n"));
  7252:     }
  7252:     else {
  6597:       returnedMessage.Append(NS_LITERAL_STRING(" ("));
  6597:       returnedMessage.Append(idU);
  6597:       returnedMessage.Append(NS_LITERAL_STRING(")"));
  6597:     }
  7252:   }
  7879: }
  7879: 
 83081: /* Formats an error message for overridable certificate errors (of type
 83081:  * OverridableCertErrorMessage). Use formatPlainErrorMessage to format
 83081:  * non-overridable cert errors and non-cert-related errors.
 83081:  */
 83081: static nsresult
 83081: formatOverridableCertErrorMessage(nsISSLStatus & sslStatus,
  7879:                                   PRErrorCode errorCodeToReport, 
108991:                                   const nsXPIDLCString & host, int32_t port,
110523:                                   bool suppressPort443,
110523:                                   bool wantsHtml,
  7879:                                   nsString & returnedMessage)
  7879: {
  7879:   const PRUnichar *params[1];
  7879:   nsresult rv;
 83081:   nsAutoString hostWithPort;
 83081:   nsAutoString hostWithoutPort;
  7879: 
 79869:   // For now, hide port when it's 443 and we're reporting the error.
 79869:   // In the future a better mechanism should be used
  7879:   // to make a decision about showing the port number, possibly by requiring
  7879:   // the context object to implement a specific interface.
  7879:   // The motivation is that Mozilla browser would like to hide the port number
  7879:   // in error pages in the common case.
  7879:   
 83081:   hostWithoutPort.AppendASCII(host);
110523:   if (suppressPort443 && port == 443) {
 83081:     params[0] = hostWithoutPort.get();
 83081:   } else {
 83081:     hostWithPort.AppendASCII(host);
 83081:     hostWithPort.Append(':');
 83081:     hostWithPort.AppendInt(port);
  7879:     params[0] = hostWithPort.get();
 83081:   }
  7879: 
 79873:   nsCOMPtr<nsINSSComponent> component = do_GetService(kNSSComponentCID, &rv);
 83081:   NS_ENSURE_SUCCESS(rv, rv);
 83081: 
 83081:   returnedMessage.Truncate();
 79873:   rv = component->PIPBundleFormatStringFromName("certErrorIntro", params, 1,
 83081:                                                 returnedMessage);
 83081:   NS_ENSURE_SUCCESS(rv, rv);
 83081: 
  7879:   returnedMessage.Append(NS_LITERAL_STRING("\n\n"));
 83081: 
119832:   nsRefPtr<nsIX509Cert> ix509;
119832:   rv = sslStatus.GetServerCert(getter_AddRefs(ix509));
 83081:   NS_ENSURE_SUCCESS(rv, rv);
 83081: 
 83081:   bool isUntrusted;
 83081:   rv = sslStatus.GetIsUntrusted(&isUntrusted);
 83081:   NS_ENSURE_SUCCESS(rv, rv);
 83081:   if (isUntrusted) {
 83081:     AppendErrorTextUntrusted(errorCodeToReport, hostWithoutPort, ix509, 
  7879:                              component, returnedMessage);
  7879:   }
  7879: 
 83081:   bool isDomainMismatch;
 83081:   rv = sslStatus.GetIsDomainMismatch(&isDomainMismatch);
 83081:   NS_ENSURE_SUCCESS(rv, rv);
 83081:   if (isDomainMismatch) {
110523:     AppendErrorTextMismatch(hostWithoutPort, ix509, component, wantsHtml, returnedMessage);
 83081:   }
 83081: 
 83081:   bool isNotValidAtThisTime;
 83081:   rv = sslStatus.GetIsNotValidAtThisTime(&isNotValidAtThisTime);
 83081:   NS_ENSURE_SUCCESS(rv, rv);
 83081:   if (isNotValidAtThisTime) {
  7879:     AppendErrorTextTime(ix509, component, returnedMessage);
  7879:   }
  7879: 
  7879:   AppendErrorTextCode(errorCodeToReport, component, returnedMessage);
 83081: 
 83081:   return NS_OK;
  6597: }
  6597: 
 97210: // RememberCertErrorsTable
 79873: 
 97210: /*static*/ RememberCertErrorsTable*
106838: RememberCertErrorsTable::sInstance = nullptr;
     1: 
 97210: RememberCertErrorsTable::RememberCertErrorsTable()
 97210:   : mMutex("RememberCertErrorsTable::mMutex")
 28629: {
 28629:   mErrorHosts.Init(16);
 28629: }
 28629: 
 97210: static nsresult
110974: GetHostPortKey(TransportSecurityInfo* infoObject, nsAutoCString &result)
 28629: {
 28629:   nsresult rv;
 28629: 
 28629:   result.Truncate();
 28629: 
 28629:   nsXPIDLCString hostName;
 28629:   rv = infoObject->GetHostName(getter_Copies(hostName));
 28629:   NS_ENSURE_SUCCESS(rv, rv);
 28629: 
108991:   int32_t port;
 28629:   rv = infoObject->GetPort(&port);
 28629:   NS_ENSURE_SUCCESS(rv, rv);
 28629: 
 28629:   result.Assign(hostName);
 28629:   result.Append(':');
 28629:   result.AppendInt(port);
 28629: 
 28629:   return NS_OK;
 28629: }
 28629: 
 28629: void
 97210: RememberCertErrorsTable::RememberCertHasError(TransportSecurityInfo* infoObject,
 28629:                                               nsSSLStatus* status,
 28629:                                               SECStatus certVerificationResult)
 28629: {
 28629:   nsresult rv;
 28629: 
110974:   nsAutoCString hostPortKey;
 28629:   rv = GetHostPortKey(infoObject, hostPortKey);
 28629:   if (NS_FAILED(rv))
 28629:     return;
 28629: 
 28629:   if (certVerificationResult != SECSuccess) {
 28629:     NS_ASSERTION(status,
 28629:         "Must have nsSSLStatus object when remembering flags");
 28629: 
 28629:     if (!status)
 28629:       return;
 28629: 
 28629:     CertStateBits bits;
 28629:     bits.mIsDomainMismatch = status->mIsDomainMismatch;
 28629:     bits.mIsNotValidAtThisTime = status->mIsNotValidAtThisTime;
 28629:     bits.mIsUntrusted = status->mIsUntrusted;
 97210: 
 97210:     MutexAutoLock lock(mMutex);
 28629:     mErrorHosts.Put(hostPortKey, bits);
 28629:   }
 28629:   else {
 97210:     MutexAutoLock lock(mMutex);
 28629:     mErrorHosts.Remove(hostPortKey);
 28629:   }
 28629: }
 28629: 
 28629: void
 97210: RememberCertErrorsTable::LookupCertErrorBits(TransportSecurityInfo* infoObject,
 28629:                                              nsSSLStatus* status)
 28629: {
 28629:   // Get remembered error bits from our cache, because of SSL session caching
 28629:   // the NSS library potentially hasn't notified us for this socket.
 28629:   if (status->mHaveCertErrorBits)
 28629:     // Rather do not modify bits if already set earlier
 28629:     return;
 28629: 
 28629:   nsresult rv;
 28629: 
110974:   nsAutoCString hostPortKey;
 28629:   rv = GetHostPortKey(infoObject, hostPortKey);
 28629:   if (NS_FAILED(rv))
 28629:     return;
 28629: 
 28629:   CertStateBits bits;
 97210:   {
 97210:     MutexAutoLock lock(mMutex);
 28629:     if (!mErrorHosts.Get(hostPortKey, &bits))
 28629:       // No record was found, this host had no cert errors
 28629:       return;
 97210:   }
 28629: 
 28629:   // This host had cert errors, update the bits correctly
 80486:   status->mHaveCertErrorBits = true;
 28629:   status->mIsDomainMismatch = bits.mIsDomainMismatch;
 28629:   status->mIsNotValidAtThisTime = bits.mIsNotValidAtThisTime;
 28629:   status->mIsUntrusted = bits.mIsUntrusted;
 28629: }
 28629: 
 30463: void
 97210: TransportSecurityInfo::SetStatusErrorBits(nsIX509Cert & cert,
108991:                                           uint32_t collected_errors)
 83083: {
 83083:   MutexAutoLock lock(mMutex);
 83083: 
 83083:   if (!mSSLStatus)
 83083:     mSSLStatus = new nsSSLStatus();
 83083: 
 83083:   mSSLStatus->mServerCert = &cert;
 83083: 
 83083:   mSSLStatus->mHaveCertErrorBits = true;
 83083:   mSSLStatus->mIsDomainMismatch = 
 83083:     collected_errors & nsICertOverrideService::ERROR_MISMATCH;
 83083:   mSSLStatus->mIsNotValidAtThisTime = 
 83083:     collected_errors & nsICertOverrideService::ERROR_TIME;
 83083:   mSSLStatus->mIsUntrusted = 
 83083:     collected_errors & nsICertOverrideService::ERROR_UNTRUSTED;
 83083: 
 97210:   RememberCertErrorsTable::GetInstance().RememberCertHasError(this,
 97210:                                                               mSSLStatus,
 97210:                                                               SECFailure);
 83083: }
 83083: 
 97210: } } // namespace mozilla::psm
