 47652: //
 47652: // Copyright (c) 2002-2010 The ANGLE Project Authors. All rights reserved.
 47652: // Use of this source code is governed by a BSD-style license that can be
 47652: // found in the LICENSE file.
 47652: //
 47652: 
 47652: // Texture.cpp: Implements the gl::Texture class and its derived classes
 47652: // Texture2D and TextureCubeMap. Implements GL texture objects and related
 47652: // functionality. [OpenGL ES 2.0.24] section 3.7 page 63.
 47652: 
 47652: #include "libGLESv2/Texture.h"
 47652: 
 58582: #include <d3dx9tex.h>
 58582: 
 47652: #include <algorithm>
 70456: 
 47652: #include "common/debug.h"
 47652: 
 70456: #include "libEGL/Display.h"
 70456: 
 47652: #include "libGLESv2/main.h"
 47652: #include "libGLESv2/mathutil.h"
 47652: #include "libGLESv2/utilities.h"
 47652: #include "libGLESv2/Blit.h"
 61598: #include "libGLESv2/Framebuffer.h"
 47652: 
 47652: namespace gl
 47652: {
 82499: unsigned int TextureStorage::mCurrentTextureSerial = 1;
 82499: 
 84925: static D3DFORMAT ConvertTextureFormatType(GLenum format, GLenum type)
 84925: {
106441:     if (IsDepthTexture(format))
106441:     {
106441:         return D3DFMT_INTZ;
106441:     }
106441:     else if (format == GL_COMPRESSED_RGB_S3TC_DXT1_EXT ||
 84925:              format == GL_COMPRESSED_RGBA_S3TC_DXT1_EXT)
 84925:     {
 84925:         return D3DFMT_DXT1;
 84925:     }
 84925:     else if (format == GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE)
 84925:     {
 84925:         return D3DFMT_DXT3;
 84925:     }
 84925:     else if (format == GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE)
 84925:     {
 84925:         return D3DFMT_DXT5;
 84925:     }
 84925:     else if (type == GL_FLOAT)
 84925:     {
 84925:         return D3DFMT_A32B32G32R32F;
 84925:     }
 84925:     else if (type == GL_HALF_FLOAT_OES)
 84925:     {
 84925:         return D3DFMT_A16B16G16R16F;
 84925:     }
 84925:     else if (type == GL_UNSIGNED_BYTE)
 84925:     {
 84925:         if (format == GL_LUMINANCE && getContext()->supportsLuminanceTextures())
 84925:         {
 84925:             return D3DFMT_L8;
 84925:         }
 84925:         else if (format == GL_LUMINANCE_ALPHA && getContext()->supportsLuminanceAlphaTextures())
 84925:         {
 84925:             return D3DFMT_A8L8;
 84925:         }
 84925:         else if (format == GL_RGB)
 84925:         {
 84925:             return D3DFMT_X8R8G8B8;
 84925:         }
 84925: 
 84925:         return D3DFMT_A8R8G8B8;
 84925:     }
 84925: 
 84925:     return D3DFMT_A8R8G8B8;
 84925: }
 84925: 
 86498: static bool IsTextureFormatRenderable(D3DFORMAT format)
 86498: {
106441:     if (format == D3DFMT_INTZ)
106441:     {
106441:         return true;
106441:     }
 86498:     switch(format)
 58582:     {
 58582:       case D3DFMT_L8:
 58582:       case D3DFMT_A8L8:
 58582:       case D3DFMT_DXT1:
 77552:       case D3DFMT_DXT3:
 77552:       case D3DFMT_DXT5:
 58582:         return false;
 58582:       case D3DFMT_A8R8G8B8:
 58582:       case D3DFMT_X8R8G8B8:
 58582:       case D3DFMT_A16B16G16R16F:
 58582:       case D3DFMT_A32B32G32R32F:
 58582:         return true;
 58582:       default:
 58582:         UNREACHABLE();
 58582:     }
 58582: 
 58582:     return false;
 58582: }
 58582: 
106441: static inline DWORD GetTextureUsage(D3DFORMAT d3dfmt, GLenum glusage, bool forceRenderable)
106441: {
106441:     DWORD d3dusage = 0;
106441: 
106441:     if (d3dfmt == D3DFMT_INTZ)
106441:     {
106441:         d3dusage |= D3DUSAGE_DEPTHSTENCIL;
106441:     }
106441:     else if(forceRenderable || (IsTextureFormatRenderable(d3dfmt) && (glusage == GL_FRAMEBUFFER_ATTACHMENT_ANGLE)))
106441:     {
106441:         d3dusage |= D3DUSAGE_RENDERTARGET;
106441:     }
106441:     return d3dusage;
106441: }
106441: 
106441: static void MakeValidSize(bool isImage, bool isCompressed, GLsizei *requestWidth, GLsizei *requestHeight, int *levelOffset) {
106441:     int upsampleCount = 0;
106441: 
106441:     if (isCompressed)
106441:     {
106441:         // Don't expand the size of full textures that are at least 4x4
106441:         // already.
106441:         if (isImage || *requestWidth < 4 || *requestHeight < 4)
106441:         {
106441:             while (*requestWidth % 4 != 0 || *requestHeight % 4 != 0)
106441:             {
106441:                 *requestWidth <<= 1;
106441:                 *requestHeight <<= 1;
106441:                 upsampleCount++;
106441:             }
106441:         }
106441:     }
106441:     *levelOffset = upsampleCount;
106441: }
106441: 
 86498: Image::Image()
 86498: {
 86498:     mWidth = 0; 
 86498:     mHeight = 0;
 86498:     mFormat = GL_NONE;
 86498:     mType = GL_UNSIGNED_BYTE;
 86498: 
 86498:     mSurface = NULL;
 86498: 
 86498:     mDirty = false;
 86498: 
 86498:     mD3DPool = D3DPOOL_SYSTEMMEM;
 86498:     mD3DFormat = D3DFMT_UNKNOWN;
 86498: }
 86498: 
 86498: Image::~Image()
 86498: {
 86498:     if (mSurface)
 86498:     {
 86498:         mSurface->Release();
 86498:     }
 86498: }
 86498: 
 86498: bool Image::redefine(GLenum format, GLsizei width, GLsizei height, GLenum type, bool forceRelease)
 86498: {
 86498:     if (mWidth != width ||
 86498:         mHeight != height ||
 86498:         mFormat != format ||
 86498:         mType != type ||
 86498:         forceRelease)
 86498:     {
 86498:         mWidth = width;
 86498:         mHeight = height;
 86498:         mFormat = format;
 86498:         mType = type;
 86498:         // compute the d3d format that will be used
 86498:         mD3DFormat = ConvertTextureFormatType(mFormat, mType);
 86498: 
 86498:         if (mSurface)
 86498:         {
 86498:             mSurface->Release();
 86498:             mSurface = NULL;
 86498:         }
 86498: 
 86498:         return true;
 86498:     }
 86498: 
 86498:     return false;
 86498: }
 86498: 
 86498: void Image::createSurface()
 86498: {
 86498:     if(mSurface)
 86498:     {
 86498:         return;
 86498:     }
 86498: 
 86498:     IDirect3DTexture9 *newTexture = NULL;
 86498:     IDirect3DSurface9 *newSurface = NULL;
 86498:     const D3DPOOL poolToUse = D3DPOOL_SYSTEMMEM;
106441:     const D3DFORMAT d3dFormat = getD3DFormat();
106441:     ASSERT(d3dFormat != D3DFMT_INTZ); // We should never get here for depth textures
 86498: 
 86498:     if (mWidth != 0 && mHeight != 0)
 86498:     {
 86498:         int levelToFetch = 0;
 86498:         GLsizei requestWidth = mWidth;
 86498:         GLsizei requestHeight = mHeight;
106441:         MakeValidSize(true, IsCompressed(mFormat), &requestWidth, &requestHeight, &levelToFetch);
106441: 
106441:         HRESULT result = getDevice()->CreateTexture(requestWidth, requestHeight, levelToFetch + 1, NULL, d3dFormat,
 86498:                                                     poolToUse, &newTexture, NULL);
 86498: 
 86498:         if (FAILED(result))
 86498:         {
 86498:             ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
 86498:             ERR("Creating image surface failed.");
 86498:             return error(GL_OUT_OF_MEMORY);
 86498:         }
 86498: 
 86498:         newTexture->GetSurfaceLevel(levelToFetch, &newSurface);
 86498:         newTexture->Release();
 86498:     }
 86498: 
 86498:     mSurface = newSurface;
 86498:     mDirty = false;
 86498:     mD3DPool = poolToUse;
 86498: }
 86498: 
 86498: HRESULT Image::lock(D3DLOCKED_RECT *lockedRect, const RECT *rect)
 86498: {
 86498:     createSurface();
 86498: 
 86498:     HRESULT result = D3DERR_INVALIDCALL;
 86498: 
 86498:     if (mSurface)
 86498:     {
 86498:         result = mSurface->LockRect(lockedRect, rect, 0);
 86498:         ASSERT(SUCCEEDED(result));
 86498: 
 86498:         mDirty = true;
 86498:     }
 86498: 
 86498:     return result;
 86498: }
 86498: 
 86498: void Image::unlock()
 86498: {
 86498:     if (mSurface)
 86498:     {
 86498:         HRESULT result = mSurface->UnlockRect();
 86498:         ASSERT(SUCCEEDED(result));
 86498:     }
 86498: }
 86498: 
 86498: bool Image::isRenderableFormat() const
 86498: {    
 86498:     return IsTextureFormatRenderable(getD3DFormat());
 86498: }
 86498: 
 82499: D3DFORMAT Image::getD3DFormat() const
 82499: {
 84925:     // this should only happen if the image hasn't been redefined first
 84925:     // which would be a bug by the caller
 84925:     ASSERT(mD3DFormat != D3DFMT_UNKNOWN);
 84925: 
 84925:     return mD3DFormat;
 47652: }
 47652: 
 82499: IDirect3DSurface9 *Image::getSurface()
 82499: {
 82499:     createSurface();
 82499: 
 82499:     return mSurface;
 82499: }
 82499: 
 82499: void Image::setManagedSurface(IDirect3DSurface9 *surface)
 82499: {
 82499:     if (mSurface)
 82499:     {
 82499:         D3DXLoadSurfaceFromSurface(surface, NULL, NULL, mSurface, NULL, NULL, D3DX_FILTER_BOX, 0);
 82499:         mSurface->Release();
 82499:     }
 82499: 
 84925:     D3DSURFACE_DESC desc;
 84925:     surface->GetDesc(&desc);
 84925:     ASSERT(desc.Pool == D3DPOOL_MANAGED);
 84925: 
 82499:     mSurface = surface;
 84925:     mD3DPool = desc.Pool;
 82499: }
 82499: 
 82499: void Image::updateSurface(IDirect3DSurface9 *destSurface, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height)
 82499: {
 82499:     IDirect3DSurface9 *sourceSurface = getSurface();
 82499: 
 95464:     if (sourceSurface && sourceSurface != destSurface)
 82499:     {
106441:         RECT rect;
106441:         rect.left = xoffset;
106441:         rect.top = yoffset;
106441:         rect.right = xoffset + width;
106441:         rect.bottom = yoffset + height;
 82499: 
 84925:         if (mD3DPool == D3DPOOL_MANAGED)
 82499:         {
 82499:             HRESULT result = D3DXLoadSurfaceFromSurface(destSurface, NULL, &rect, sourceSurface, NULL, &rect, D3DX_FILTER_BOX, 0);
 82499:             ASSERT(SUCCEEDED(result));
 82499:         }
 82499:         else
 82499:         {
 84925:             // UpdateSurface: source must be SYSTEMMEM, dest must be DEFAULT pools 
 82499:             POINT point = {rect.left, rect.top};
 82499:             HRESULT result = getDevice()->UpdateSurface(sourceSurface, &rect, destSurface, &point);
 82499:             ASSERT(SUCCEEDED(result));
 82499:         }
 82499:     }
 70456: }
 70456: 
 47652: // Store the pixel rectangle designated by xoffset,yoffset,width,height with pixels stored as format/type at input
106441: // into the target pixel rectangle.
 82499: void Image::loadData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum type,
 95464:                      GLint unpackAlignment, const void *input)
 95464: {
106441:     RECT lockRect =
106441:     {
106441:         xoffset, yoffset,
106441:         xoffset + width, yoffset + height
106441:     };
 95464: 
 95464:     D3DLOCKED_RECT locked;
 95464:     HRESULT result = lock(&locked, &lockRect);
 95464:     if (FAILED(result))
 95464:     {
 95464:         return;
 95464:     }
 95464: 
106441:     GLsizei inputPitch = ComputePitch(width, mFormat, type, unpackAlignment);
 47652: 
 55266:     switch (type)
 47652:     {
 55266:       case GL_UNSIGNED_BYTE:
 82499:         switch (mFormat)
 47652:         {
 47652:           case GL_ALPHA:
106441:             if (supportsSSE2())
106441:             {
106441:                 loadAlphaDataSSE2(width, height, inputPitch, input, locked.Pitch, locked.pBits);
106441:             }
106441:             else
106441:             {
 95464:                 loadAlphaData(width, height, inputPitch, input, locked.Pitch, locked.pBits);
106441:             }
 47652:             break;
 47652:           case GL_LUMINANCE:
 95464:             loadLuminanceData(width, height, inputPitch, input, locked.Pitch, locked.pBits, getD3DFormat() == D3DFMT_L8);
 47652:             break;
 47652:           case GL_LUMINANCE_ALPHA:
 95464:             loadLuminanceAlphaData(width, height, inputPitch, input, locked.Pitch, locked.pBits, getD3DFormat() == D3DFMT_A8L8);
 47652:             break;
 47652:           case GL_RGB:
 95464:             loadRGBUByteData(width, height, inputPitch, input, locked.Pitch, locked.pBits);
 47652:             break;
 55266:           case GL_RGBA:
 70456:             if (supportsSSE2())
 70456:             {
 95464:                 loadRGBAUByteDataSSE2(width, height, inputPitch, input, locked.Pitch, locked.pBits);
 70456:             }
 70456:             else
 70456:             {
 95464:                 loadRGBAUByteData(width, height, inputPitch, input, locked.Pitch, locked.pBits);
 70456:             }
 47652:             break;
 55266:           case GL_BGRA_EXT:
 95464:             loadBGRAData(width, height, inputPitch, input, locked.Pitch, locked.pBits);
 55266:             break;
 47652:           default: UNREACHABLE();
 47652:         }
 47652:         break;
 55266:       case GL_UNSIGNED_SHORT_5_6_5:
 82499:         switch (mFormat)
 47652:         {
 55266:           case GL_RGB:
 95464:             loadRGB565Data(width, height, inputPitch, input, locked.Pitch, locked.pBits);
 47652:             break;
 55266:           default: UNREACHABLE();
 47652:         }
 47652:         break;
 55266:       case GL_UNSIGNED_SHORT_4_4_4_4:
 82499:         switch (mFormat)
 47652:         {
 55266:           case GL_RGBA:
 95464:             loadRGBA4444Data(width, height, inputPitch, input, locked.Pitch, locked.pBits);
 55266:             break;
 55266:           default: UNREACHABLE();
 47652:         }
 47652:         break;
 55266:       case GL_UNSIGNED_SHORT_5_5_5_1:
 82499:         switch (mFormat)
 55266:         {
 55266:           case GL_RGBA:
 95464:             loadRGBA5551Data(width, height, inputPitch, input, locked.Pitch, locked.pBits);
 55266:             break;
 55266:           default: UNREACHABLE();
 55266:         }
 55266:         break;
 55266:       case GL_FLOAT:
 82499:         switch (mFormat)
 55266:         {
 55266:           // float textures are converted to RGBA, not BGRA, as they're stored that way in D3D
 55266:           case GL_ALPHA:
 95464:             loadAlphaFloatData(width, height, inputPitch, input, locked.Pitch, locked.pBits);
 55266:             break;
 55266:           case GL_LUMINANCE:
 95464:             loadLuminanceFloatData(width, height, inputPitch, input, locked.Pitch, locked.pBits);
 55266:             break;
 55266:           case GL_LUMINANCE_ALPHA:
 95464:             loadLuminanceAlphaFloatData(width, height, inputPitch, input, locked.Pitch, locked.pBits);
 55266:             break;
 55266:           case GL_RGB:
 95464:             loadRGBFloatData(width, height, inputPitch, input, locked.Pitch, locked.pBits);
 55266:             break;
 55266:           case GL_RGBA:
 95464:             loadRGBAFloatData(width, height, inputPitch, input, locked.Pitch, locked.pBits);
 55266:             break;
 55266:           default: UNREACHABLE();
 55266:         }
 55266:         break;
 55266:       case GL_HALF_FLOAT_OES:
 82499:         switch (mFormat)
 55266:         {
 55266:           // float textures are converted to RGBA, not BGRA, as they're stored that way in D3D
 55266:           case GL_ALPHA:
 95464:             loadAlphaHalfFloatData(width, height, inputPitch, input, locked.Pitch, locked.pBits);
 55266:             break;
 55266:           case GL_LUMINANCE:
 95464:             loadLuminanceHalfFloatData(width, height, inputPitch, input, locked.Pitch, locked.pBits);
 55266:             break;
 55266:           case GL_LUMINANCE_ALPHA:
 95464:             loadLuminanceAlphaHalfFloatData(width, height, inputPitch, input, locked.Pitch, locked.pBits);
 55266:             break;
 55266:           case GL_RGB:
 95464:             loadRGBHalfFloatData(width, height, inputPitch, input, locked.Pitch, locked.pBits);
 55266:             break;
 55266:           case GL_RGBA:
 95464:             loadRGBAHalfFloatData(width, height, inputPitch, input, locked.Pitch, locked.pBits);
 55266:             break;
 47652:           default: UNREACHABLE();
 47652:         }
 47652:         break;
 47652:       default: UNREACHABLE();
 47652:     }
 95464: 
 95464:     unlock();
 95464: }
 95464: 
 95464: void Image::loadAlphaData(GLsizei width, GLsizei height,
 61598:                           int inputPitch, const void *input, size_t outputPitch, void *output) const
 47652: {
 55266:     const unsigned char *source = NULL;
 55266:     unsigned char *dest = NULL;
 55266:     
 55266:     for (int y = 0; y < height; y++)
 55266:     {
 55266:         source = static_cast<const unsigned char*>(input) + y * inputPitch;
 95464:         dest = static_cast<unsigned char*>(output) + y * outputPitch;
 55266:         for (int x = 0; x < width; x++)
 55266:         {
 55266:             dest[4 * x + 0] = 0;
 55266:             dest[4 * x + 1] = 0;
 55266:             dest[4 * x + 2] = 0;
 55266:             dest[4 * x + 3] = source[x];
 55266:         }
 55266:     }
 55266: }
 55266: 
 95464: void Image::loadAlphaFloatData(GLsizei width, GLsizei height,
 61598:                                int inputPitch, const void *input, size_t outputPitch, void *output) const
 55266: {
 55266:     const float *source = NULL;
 55266:     float *dest = NULL;
 55266: 
 55266:     for (int y = 0; y < height; y++)
 55266:     {
 55266:         source = reinterpret_cast<const float*>(static_cast<const unsigned char*>(input) + y * inputPitch);
 95464:         dest = reinterpret_cast<float*>(static_cast<unsigned char*>(output) + y * outputPitch);
 55266:         for (int x = 0; x < width; x++)
 55266:         {
 55266:             dest[4 * x + 0] = 0;
 55266:             dest[4 * x + 1] = 0;
 55266:             dest[4 * x + 2] = 0;
 55266:             dest[4 * x + 3] = source[x];
 55266:         }
 55266:     }
 55266: }
 55266: 
 95464: void Image::loadAlphaHalfFloatData(GLsizei width, GLsizei height,
 61598:                                    int inputPitch, const void *input, size_t outputPitch, void *output) const
 55266: {
 55266:     const unsigned short *source = NULL;
 55266:     unsigned short *dest = NULL;
 55266: 
 55266:     for (int y = 0; y < height; y++)
 55266:     {
 55266:         source = reinterpret_cast<const unsigned short*>(static_cast<const unsigned char*>(input) + y * inputPitch);
 95464:         dest = reinterpret_cast<unsigned short*>(static_cast<unsigned char*>(output) + y * outputPitch);
 55266:         for (int x = 0; x < width; x++)
 55266:         {
 55266:             dest[4 * x + 0] = 0;
 55266:             dest[4 * x + 1] = 0;
 55266:             dest[4 * x + 2] = 0;
 55266:             dest[4 * x + 3] = source[x];
 55266:         }
 55266:     }
 55266: }
 55266: 
 95464: void Image::loadLuminanceData(GLsizei width, GLsizei height,
 61598:                               int inputPitch, const void *input, size_t outputPitch, void *output, bool native) const
 55266: {
 55266:     const unsigned char *source = NULL;
 55266:     unsigned char *dest = NULL;
 55266: 
 55266:     for (int y = 0; y < height; y++)
 55266:     {
 55266:         source = static_cast<const unsigned char*>(input) + y * inputPitch;
 95464:         dest = static_cast<unsigned char*>(output) + y * outputPitch;
 58582: 
 58582:         if (!native)   // BGRA8 destination format
 58582:         {
 55266:             for (int x = 0; x < width; x++)
 55266:             {
 55266:                 dest[4 * x + 0] = source[x];
 55266:                 dest[4 * x + 1] = source[x];
 55266:                 dest[4 * x + 2] = source[x];
 55266:                 dest[4 * x + 3] = 0xFF;
 55266:             }
 55266:         }
 58582:         else   // L8 destination format
 58582:         {
 58582:             memcpy(dest, source, width);
 58582:         }
 58582:     }
 55266: }
 55266: 
 95464: void Image::loadLuminanceFloatData(GLsizei width, GLsizei height,
 61598:                                    int inputPitch, const void *input, size_t outputPitch, void *output) const
 55266: {
 55266:     const float *source = NULL;
 55266:     float *dest = NULL;
 55266: 
 55266:     for (int y = 0; y < height; y++)
 55266:     {
 55266:         source = reinterpret_cast<const float*>(static_cast<const unsigned char*>(input) + y * inputPitch);
 95464:         dest = reinterpret_cast<float*>(static_cast<unsigned char*>(output) + y * outputPitch);
 55266:         for (int x = 0; x < width; x++)
 55266:         {
 55266:             dest[4 * x + 0] = source[x];
 55266:             dest[4 * x + 1] = source[x];
 55266:             dest[4 * x + 2] = source[x];
 55266:             dest[4 * x + 3] = 1.0f;
 55266:         }
 55266:     }
 55266: }
 55266: 
 95464: void Image::loadLuminanceHalfFloatData(GLsizei width, GLsizei height,
 61598:                                        int inputPitch, const void *input, size_t outputPitch, void *output) const
 55266: {
 55266:     const unsigned short *source = NULL;
 55266:     unsigned short *dest = NULL;
 55266: 
 55266:     for (int y = 0; y < height; y++)
 55266:     {
 55266:         source = reinterpret_cast<const unsigned short*>(static_cast<const unsigned char*>(input) + y * inputPitch);
 95464:         dest = reinterpret_cast<unsigned short*>(static_cast<unsigned char*>(output) + y * outputPitch);
 55266:         for (int x = 0; x < width; x++)
 55266:         {
 55266:             dest[4 * x + 0] = source[x];
 55266:             dest[4 * x + 1] = source[x];
 55266:             dest[4 * x + 2] = source[x];
 55266:             dest[4 * x + 3] = 0x3C00; // SEEEEEMMMMMMMMMM, S = 0, E = 15, M = 0: 16bit flpt representation of 1
 55266:         }
 55266:     }
 55266: }
 55266: 
 95464: void Image::loadLuminanceAlphaData(GLsizei width, GLsizei height,
 61598:                                    int inputPitch, const void *input, size_t outputPitch, void *output, bool native) const
 55266: {
 55266:     const unsigned char *source = NULL;
 55266:     unsigned char *dest = NULL;
 55266: 
 55266:     for (int y = 0; y < height; y++)
 55266:     {
 55266:         source = static_cast<const unsigned char*>(input) + y * inputPitch;
 95464:         dest = static_cast<unsigned char*>(output) + y * outputPitch;
 58582:         
 58582:         if (!native)   // BGRA8 destination format
 58582:         {
 55266:             for (int x = 0; x < width; x++)
 55266:             {
 55266:                 dest[4 * x + 0] = source[2*x+0];
 55266:                 dest[4 * x + 1] = source[2*x+0];
 55266:                 dest[4 * x + 2] = source[2*x+0];
 55266:                 dest[4 * x + 3] = source[2*x+1];
 55266:             }
 55266:         }
 58582:         else
 58582:         {
 58582:             memcpy(dest, source, width * 2);
 58582:         }
 58582:     }
 55266: }
 55266: 
 95464: void Image::loadLuminanceAlphaFloatData(GLsizei width, GLsizei height,
 61598:                                         int inputPitch, const void *input, size_t outputPitch, void *output) const
 55266: {
 55266:     const float *source = NULL;
 55266:     float *dest = NULL;
 55266: 
 55266:     for (int y = 0; y < height; y++)
 55266:     {
 55266:         source = reinterpret_cast<const float*>(static_cast<const unsigned char*>(input) + y * inputPitch);
 95464:         dest = reinterpret_cast<float*>(static_cast<unsigned char*>(output) + y * outputPitch);
 55266:         for (int x = 0; x < width; x++)
 55266:         {
 55266:             dest[4 * x + 0] = source[2*x+0];
 55266:             dest[4 * x + 1] = source[2*x+0];
 55266:             dest[4 * x + 2] = source[2*x+0];
 55266:             dest[4 * x + 3] = source[2*x+1];
 55266:         }
 55266:     }
 55266: }
 55266: 
 95464: void Image::loadLuminanceAlphaHalfFloatData(GLsizei width, GLsizei height,
 61598:                                             int inputPitch, const void *input, size_t outputPitch, void *output) const
 55266: {
 55266:     const unsigned short *source = NULL;
 55266:     unsigned short *dest = NULL;
 55266: 
 55266:     for (int y = 0; y < height; y++)
 55266:     {
 55266:         source = reinterpret_cast<const unsigned short*>(static_cast<const unsigned char*>(input) + y * inputPitch);
 95464:         dest = reinterpret_cast<unsigned short*>(static_cast<unsigned char*>(output) + y * outputPitch);
 55266:         for (int x = 0; x < width; x++)
 55266:         {
 55266:             dest[4 * x + 0] = source[2*x+0];
 55266:             dest[4 * x + 1] = source[2*x+0];
 55266:             dest[4 * x + 2] = source[2*x+0];
 55266:             dest[4 * x + 3] = source[2*x+1];
 55266:         }
 55266:     }
 55266: }
 55266: 
 95464: void Image::loadRGBUByteData(GLsizei width, GLsizei height,
 61598:                              int inputPitch, const void *input, size_t outputPitch, void *output) const
 55266: {
 55266:     const unsigned char *source = NULL;
 55266:     unsigned char *dest = NULL;
 55266: 
 55266:     for (int y = 0; y < height; y++)
 55266:     {
 55266:         source = static_cast<const unsigned char*>(input) + y * inputPitch;
 95464:         dest = static_cast<unsigned char*>(output) + y * outputPitch;
 55266:         for (int x = 0; x < width; x++)
 55266:         {
 55266:             dest[4 * x + 0] = source[x * 3 + 2];
 55266:             dest[4 * x + 1] = source[x * 3 + 1];
 55266:             dest[4 * x + 2] = source[x * 3 + 0];
 55266:             dest[4 * x + 3] = 0xFF;
 55266:         }
 55266:     }
 55266: }
 55266: 
 95464: void Image::loadRGB565Data(GLsizei width, GLsizei height,
 61598:                            int inputPitch, const void *input, size_t outputPitch, void *output) const
 55266: {
 55266:     const unsigned short *source = NULL;
 55266:     unsigned char *dest = NULL;
 55266: 
 55266:     for (int y = 0; y < height; y++)
 55266:     {
 55266:         source = reinterpret_cast<const unsigned short*>(static_cast<const unsigned char*>(input) + y * inputPitch);
 95464:         dest = static_cast<unsigned char*>(output) + y * outputPitch;
 55266:         for (int x = 0; x < width; x++)
 55266:         {
 55266:             unsigned short rgba = source[x];
 55266:             dest[4 * x + 0] = ((rgba & 0x001F) << 3) | ((rgba & 0x001F) >> 2);
 55266:             dest[4 * x + 1] = ((rgba & 0x07E0) >> 3) | ((rgba & 0x07E0) >> 9);
 55266:             dest[4 * x + 2] = ((rgba & 0xF800) >> 8) | ((rgba & 0xF800) >> 13);
 55266:             dest[4 * x + 3] = 0xFF;
 55266:         }
 55266:     }
 55266: }
 55266: 
 95464: void Image::loadRGBFloatData(GLsizei width, GLsizei height,
 61598:                              int inputPitch, const void *input, size_t outputPitch, void *output) const
 55266: {
 55266:     const float *source = NULL;
 55266:     float *dest = NULL;
 55266: 
 55266:     for (int y = 0; y < height; y++)
 55266:     {
 55266:         source = reinterpret_cast<const float*>(static_cast<const unsigned char*>(input) + y * inputPitch);
 95464:         dest = reinterpret_cast<float*>(static_cast<unsigned char*>(output) + y * outputPitch);
 55266:         for (int x = 0; x < width; x++)
 55266:         {
 55266:             dest[4 * x + 0] = source[x * 3 + 0];
 55266:             dest[4 * x + 1] = source[x * 3 + 1];
 55266:             dest[4 * x + 2] = source[x * 3 + 2];
 55266:             dest[4 * x + 3] = 1.0f;
 55266:         }
 55266:     }
 55266: }
 55266: 
 95464: void Image::loadRGBHalfFloatData(GLsizei width, GLsizei height,
 61598:                                  int inputPitch, const void *input, size_t outputPitch, void *output) const
 55266: {
 55266:     const unsigned short *source = NULL;
 55266:     unsigned short *dest = NULL;
 55266: 
 55266:     for (int y = 0; y < height; y++)
 55266:     {
 55266:         source = reinterpret_cast<const unsigned short*>(static_cast<const unsigned char*>(input) + y * inputPitch);
 95464:         dest = reinterpret_cast<unsigned short*>(static_cast<unsigned char*>(output) + y * outputPitch);
 55266:         for (int x = 0; x < width; x++)
 55266:         {
 55266:             dest[4 * x + 0] = source[x * 3 + 0];
 55266:             dest[4 * x + 1] = source[x * 3 + 1];
 55266:             dest[4 * x + 2] = source[x * 3 + 2];
 55266:             dest[4 * x + 3] = 0x3C00; // SEEEEEMMMMMMMMMM, S = 0, E = 15, M = 0: 16bit flpt representation of 1
 55266:         }
 55266:     }
 55266: }
 55266: 
 95464: void Image::loadRGBAUByteData(GLsizei width, GLsizei height,
 61598:                               int inputPitch, const void *input, size_t outputPitch, void *output) const
 55266: {
 70456:     const unsigned int *source = NULL;
 70456:     unsigned int *dest = NULL;
 55266:     for (int y = 0; y < height; y++)
 55266:     {
 70456:         source = reinterpret_cast<const unsigned int*>(static_cast<const unsigned char*>(input) + y * inputPitch);
 95464:         dest = reinterpret_cast<unsigned int*>(static_cast<unsigned char*>(output) + y * outputPitch);
 70456: 
 55266:         for (int x = 0; x < width; x++)
 55266:         {
 70456:             unsigned int rgba = source[x];
 70456:             dest[x] = (_rotl(rgba, 16) & 0x00ff00ff) | (rgba & 0xff00ff00);
 55266:         }
 55266:     }
 55266: }
 55266: 
 95464: void Image::loadRGBA4444Data(GLsizei width, GLsizei height,
 61598:                              int inputPitch, const void *input, size_t outputPitch, void *output) const
 55266: {
 55266:     const unsigned short *source = NULL;
 55266:     unsigned char *dest = NULL;
 55266: 
 55266:     for (int y = 0; y < height; y++)
 55266:     {
 55266:         source = reinterpret_cast<const unsigned short*>(static_cast<const unsigned char*>(input) + y * inputPitch);
 95464:         dest = static_cast<unsigned char*>(output) + y * outputPitch;
 55266:         for (int x = 0; x < width; x++)
 55266:         {
 55266:             unsigned short rgba = source[x];
 55266:             dest[4 * x + 0] = ((rgba & 0x00F0) << 0) | ((rgba & 0x00F0) >> 4);
 55266:             dest[4 * x + 1] = ((rgba & 0x0F00) >> 4) | ((rgba & 0x0F00) >> 8);
 55266:             dest[4 * x + 2] = ((rgba & 0xF000) >> 8) | ((rgba & 0xF000) >> 12);
 55266:             dest[4 * x + 3] = ((rgba & 0x000F) << 4) | ((rgba & 0x000F) >> 0);
 55266:         }
 55266:     }
 55266: }
 55266: 
 95464: void Image::loadRGBA5551Data(GLsizei width, GLsizei height,
 61598:                              int inputPitch, const void *input, size_t outputPitch, void *output) const
 55266: {
 55266:     const unsigned short *source = NULL;
 55266:     unsigned char *dest = NULL;
 55266: 
 55266:     for (int y = 0; y < height; y++)
 55266:     {
 55266:         source = reinterpret_cast<const unsigned short*>(static_cast<const unsigned char*>(input) + y * inputPitch);
 95464:         dest = static_cast<unsigned char*>(output) + y * outputPitch;
 55266:         for (int x = 0; x < width; x++)
 55266:         {
 55266:             unsigned short rgba = source[x];
 55266:             dest[4 * x + 0] = ((rgba & 0x003E) << 2) | ((rgba & 0x003E) >> 3);
 55266:             dest[4 * x + 1] = ((rgba & 0x07C0) >> 3) | ((rgba & 0x07C0) >> 8);
 55266:             dest[4 * x + 2] = ((rgba & 0xF800) >> 8) | ((rgba & 0xF800) >> 13);
 55266:             dest[4 * x + 3] = (rgba & 0x0001) ? 0xFF : 0;
 55266:         }
 55266:     }
 55266: }
 55266: 
 95464: void Image::loadRGBAFloatData(GLsizei width, GLsizei height,
 61598:                               int inputPitch, const void *input, size_t outputPitch, void *output) const
 55266: {
 55266:     const float *source = NULL;
 55266:     float *dest = NULL;
 55266: 
 55266:     for (int y = 0; y < height; y++)
 55266:     {
 55266:         source = reinterpret_cast<const float*>(static_cast<const unsigned char*>(input) + y * inputPitch);
 95464:         dest = reinterpret_cast<float*>(static_cast<unsigned char*>(output) + y * outputPitch);
 55266:         memcpy(dest, source, width * 16);
 55266:     }
 55266: }
 55266: 
 95464: void Image::loadRGBAHalfFloatData(GLsizei width, GLsizei height,
 61598:                                   int inputPitch, const void *input, size_t outputPitch, void *output) const
 55266: {
 55266:     const unsigned char *source = NULL;
 55266:     unsigned char *dest = NULL;
 55266: 
 55266:     for (int y = 0; y < height; y++)
 55266:     {
 55266:         source = static_cast<const unsigned char*>(input) + y * inputPitch;
 95464:         dest = static_cast<unsigned char*>(output) + y * outputPitch;
 55266:         memcpy(dest, source, width * 8);
 55266:     }
 55266: }
 55266: 
 95464: void Image::loadBGRAData(GLsizei width, GLsizei height,
 61598:                          int inputPitch, const void *input, size_t outputPitch, void *output) const
 55266: {
 55266:     const unsigned char *source = NULL;
 55266:     unsigned char *dest = NULL;
 55266: 
 55266:     for (int y = 0; y < height; y++)
 55266:     {
 55266:         source = static_cast<const unsigned char*>(input) + y * inputPitch;
 95464:         dest = static_cast<unsigned char*>(output) + y * outputPitch;
 55266:         memcpy(dest, source, width*4);
 55266:     }
 55266: }
 55266: 
 82499: void Image::loadCompressedData(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height,
 95464:                                const void *input) {
 95464:     ASSERT(xoffset % 4 == 0);
 95464:     ASSERT(yoffset % 4 == 0);
 95464: 
106441:     RECT lockRect = {
106441:         xoffset, yoffset,
106441:         xoffset + width, yoffset + height
106441:     };
 95464: 
 95464:     D3DLOCKED_RECT locked;
 95464:     HRESULT result = lock(&locked, &lockRect);
 95464:     if (FAILED(result))
 95464:     {
 95464:         return;
 95464:     }
 95464: 
 95464:     GLsizei inputSize = ComputeCompressedSize(width, height, mFormat);
106441:     GLsizei inputPitch = ComputeCompressedPitch(width, mFormat);
106441:     int rows = inputSize / inputPitch;
106441:     for (int i = 0; i < rows; ++i)
106441:     {
106441:         memcpy((void*)((BYTE*)locked.pBits + i * locked.Pitch), (void*)((BYTE*)input + i * inputPitch), inputPitch);
 77552:     }
 95464: 
 95464:     unlock();
 77552: }
 77552: 
 82499: // This implements glCopyTex[Sub]Image2D for non-renderable internal texture formats and incomplete textures
 82499: void Image::copy(GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height, IDirect3DSurface9 *renderTarget)
 82499: {
 82499:     IDirect3DDevice9 *device = getDevice();
 82499:     IDirect3DSurface9 *renderTargetData = NULL;
 82499:     D3DSURFACE_DESC description;
 82499:     renderTarget->GetDesc(&description);
 82499:     
 82499:     HRESULT result = device->CreateOffscreenPlainSurface(description.Width, description.Height, description.Format, D3DPOOL_SYSTEMMEM, &renderTargetData, NULL);
 47652: 
 47652:     if (FAILED(result))
 47652:     {
 82499:         ERR("Could not create matching destination surface.");
 47652:         return error(GL_OUT_OF_MEMORY);
 47652:     }
 55266: 
 82499:     result = device->GetRenderTargetData(renderTarget, renderTargetData);
 82499: 
 82499:     if (FAILED(result))
 82499:     {
 82499:         ERR("GetRenderTargetData unexpectedly failed.");
 82499:         renderTargetData->Release();
 82499:         return error(GL_OUT_OF_MEMORY);
 82499:     }
 82499: 
106441:     RECT sourceRect = {x, y, x + width, y + height};
106441:     RECT destRect = {xoffset, yoffset, xoffset + width, yoffset + height};
 82499: 
 86498:     if (isRenderableFormat())
 82499:     {
 82499:         result = D3DXLoadSurfaceFromSurface(getSurface(), NULL, &destRect, renderTargetData, NULL, &sourceRect, D3DX_FILTER_BOX, 0);
 82499:         
 82499:         if (FAILED(result))
 82499:         {
 82499:             ERR("Copying surfaces unexpectedly failed.");
 82499:             renderTargetData->Release();
 82499:             return error(GL_OUT_OF_MEMORY);
 82499:         }
 82499:     }
 82499:     else
 82499:     {
 82499:         D3DLOCKED_RECT sourceLock = {0};
 82499:         result = renderTargetData->LockRect(&sourceLock, &sourceRect, 0);
 82499: 
 82499:         if (FAILED(result))
 82499:         {
 82499:             ERR("Failed to lock the source surface (rectangle might be invalid).");
 82499:             renderTargetData->Release();
 82499:             return error(GL_OUT_OF_MEMORY);
 82499:         }
 82499: 
 82499:         D3DLOCKED_RECT destLock = {0};
 82499:         result = lock(&destLock, &destRect);
 82499:         
 82499:         if (FAILED(result))
 82499:         {
 82499:             ERR("Failed to lock the destination surface (rectangle might be invalid).");
 82499:             renderTargetData->UnlockRect();
 82499:             renderTargetData->Release();
 82499:             return error(GL_OUT_OF_MEMORY);
 82499:         }
 82499: 
 82499:         if (destLock.pBits && sourceLock.pBits)
 82499:         {
 82499:             unsigned char *source = (unsigned char*)sourceLock.pBits;
 82499:             unsigned char *dest = (unsigned char*)destLock.pBits;
 82499: 
 82499:             switch (description.Format)
 82499:             {
 82499:               case D3DFMT_X8R8G8B8:
 82499:               case D3DFMT_A8R8G8B8:
 82499:                 switch(getD3DFormat())
 82499:                 {
 82499:                   case D3DFMT_L8:
 82499:                     for(int y = 0; y < height; y++)
 82499:                     {
 82499:                         for(int x = 0; x < width; x++)
 82499:                         {
 82499:                             dest[x] = source[x * 4 + 2];
 82499:                         }
 82499: 
 82499:                         source += sourceLock.Pitch;
 82499:                         dest += destLock.Pitch;
 82499:                     }
 82499:                     break;
 82499:                   case D3DFMT_A8L8:
 82499:                     for(int y = 0; y < height; y++)
 82499:                     {
 82499:                         for(int x = 0; x < width; x++)
 82499:                         {
 82499:                             dest[x * 2 + 0] = source[x * 4 + 2];
 82499:                             dest[x * 2 + 1] = source[x * 4 + 3];
 82499:                         }
 82499: 
 82499:                         source += sourceLock.Pitch;
 82499:                         dest += destLock.Pitch;
 82499:                     }
 82499:                     break;
 82499:                   default:
 82499:                     UNREACHABLE();
 82499:                 }
 82499:                 break;
 82499:               case D3DFMT_R5G6B5:
 82499:                 switch(getD3DFormat())
 82499:                 {
 82499:                   case D3DFMT_L8:
 82499:                     for(int y = 0; y < height; y++)
 82499:                     {
 82499:                         for(int x = 0; x < width; x++)
 82499:                         {
 82499:                             unsigned char red = source[x * 2 + 1] & 0xF8;
 82499:                             dest[x] = red | (red >> 5);
 82499:                         }
 82499: 
 82499:                         source += sourceLock.Pitch;
 82499:                         dest += destLock.Pitch;
 82499:                     }
 82499:                     break;
 82499:                   default:
 82499:                     UNREACHABLE();
 82499:                 }
 82499:                 break;
 82499:               case D3DFMT_A1R5G5B5:
 82499:                 switch(getD3DFormat())
 82499:                 {
 82499:                   case D3DFMT_L8:
 82499:                     for(int y = 0; y < height; y++)
 82499:                     {
 82499:                         for(int x = 0; x < width; x++)
 82499:                         {
 82499:                             unsigned char red = source[x * 2 + 1] & 0x7C;
 82499:                             dest[x] = (red << 1) | (red >> 4);
 82499:                         }
 82499: 
 82499:                         source += sourceLock.Pitch;
 82499:                         dest += destLock.Pitch;
 82499:                     }
 82499:                     break;
 82499:                   case D3DFMT_A8L8:
 82499:                     for(int y = 0; y < height; y++)
 82499:                     {
 82499:                         for(int x = 0; x < width; x++)
 82499:                         {
 82499:                             unsigned char red = source[x * 2 + 1] & 0x7C;
 82499:                             dest[x * 2 + 0] = (red << 1) | (red >> 4);
 82499:                             dest[x * 2 + 1] = (signed char)source[x * 2 + 1] >> 7;
 82499:                         }
 82499: 
 82499:                         source += sourceLock.Pitch;
 82499:                         dest += destLock.Pitch;
 82499:                     }
 82499:                     break;
 82499:                   default:
 82499:                     UNREACHABLE();
 82499:                 }
 82499:                 break;
 82499:               default:
 82499:                 UNREACHABLE();
 82499:             }
 82499:         }
 82499: 
 82499:         unlock();
 82499:         renderTargetData->UnlockRect();
 82499:     }
 82499: 
 82499:     renderTargetData->Release();
 82499: 
 82499:     mDirty = true;
 82499: }
 82499: 
106441: TextureStorage::TextureStorage(DWORD usage)
106441:     : mD3DUsage(usage),
106441:       mD3DPool(getDisplay()->getTexturePool(usage)),
106441:       mTextureSerial(issueTextureSerial()),
106441:       mLodOffset(0)
 82499: {
 82499: }
 82499: 
 82499: TextureStorage::~TextureStorage()
 82499: {
 82499: }
 82499: 
 86498: bool TextureStorage::isRenderTarget() const
 86498: {
106441:     return (mD3DUsage & (D3DUSAGE_RENDERTARGET | D3DUSAGE_DEPTHSTENCIL)) != 0;
 82499: }
 82499: 
 82499: bool TextureStorage::isManaged() const
 82499: {
 84925:     return (mD3DPool == D3DPOOL_MANAGED);
 84925: }
 84925: 
 84925: D3DPOOL TextureStorage::getPool() const
 84925: {
 84925:     return mD3DPool;
 82499: }
 82499: 
106441: DWORD TextureStorage::getUsage() const
106441: {
106441:     return mD3DUsage;
106441: }
106441: 
 82499: unsigned int TextureStorage::getTextureSerial() const
 82499: {
 82499:     return mTextureSerial;
 82499: }
 82499: 
 82499: unsigned int TextureStorage::issueTextureSerial()
 82499: {
 82499:     return mCurrentTextureSerial++;
 82499: }
 82499: 
106441: int TextureStorage::getLodOffset() const
106441: {
106441:     return mLodOffset;
106441: }
106441: 
 82499: Texture::Texture(GLuint id) : RefCountObject(id)
 82499: {
 82499:     mMinFilter = GL_NEAREST_MIPMAP_LINEAR;
 82499:     mMagFilter = GL_LINEAR;
 82499:     mWrapS = GL_REPEAT;
 82499:     mWrapT = GL_REPEAT;
 82499:     mDirtyParameters = true;
 82499:     mUsage = GL_NONE;
106441:     mMaxAnisotropy = 1.0f;
 82499:     
 82499:     mDirtyImages = true;
 82499: 
 82499:     mImmutable = false;
 82499: }
 82499: 
 82499: Texture::~Texture()
 82499: {
 82499: }
 82499: 
 82499: // Returns true on successful filter state update (valid enum parameter)
 82499: bool Texture::setMinFilter(GLenum filter)
 82499: {
 82499:     switch (filter)
 82499:     {
 82499:       case GL_NEAREST:
 82499:       case GL_LINEAR:
 82499:       case GL_NEAREST_MIPMAP_NEAREST:
 82499:       case GL_LINEAR_MIPMAP_NEAREST:
 82499:       case GL_NEAREST_MIPMAP_LINEAR:
 82499:       case GL_LINEAR_MIPMAP_LINEAR:
 82499:         {
 82499:             if (mMinFilter != filter)
 82499:             {
 82499:                 mMinFilter = filter;
 82499:                 mDirtyParameters = true;
 82499:             }
 82499:             return true;
 82499:         }
 82499:       default:
 82499:         return false;
 82499:     }
 82499: }
 82499: 
 82499: // Returns true on successful filter state update (valid enum parameter)
 82499: bool Texture::setMagFilter(GLenum filter)
 82499: {
 82499:     switch (filter)
 82499:     {
 82499:       case GL_NEAREST:
 82499:       case GL_LINEAR:
 82499:         {
 82499:             if (mMagFilter != filter)
 82499:             {
 82499:                 mMagFilter = filter;
 82499:                 mDirtyParameters = true;
 82499:             }
 82499:             return true;
 82499:         }
 82499:       default:
 82499:         return false;
 82499:     }
 82499: }
 82499: 
 82499: // Returns true on successful wrap state update (valid enum parameter)
 82499: bool Texture::setWrapS(GLenum wrap)
 82499: {
 82499:     switch (wrap)
 82499:     {
 82499:       case GL_REPEAT:
 82499:       case GL_CLAMP_TO_EDGE:
 82499:       case GL_MIRRORED_REPEAT:
 82499:         {
 82499:             if (mWrapS != wrap)
 82499:             {
 82499:                 mWrapS = wrap;
 82499:                 mDirtyParameters = true;
 82499:             }
 82499:             return true;
 82499:         }
 82499:       default:
 82499:         return false;
 82499:     }
 82499: }
 82499: 
 82499: // Returns true on successful wrap state update (valid enum parameter)
 82499: bool Texture::setWrapT(GLenum wrap)
 82499: {
 82499:     switch (wrap)
 82499:     {
 82499:       case GL_REPEAT:
 82499:       case GL_CLAMP_TO_EDGE:
 82499:       case GL_MIRRORED_REPEAT:
 82499:         {
 82499:             if (mWrapT != wrap)
 82499:             {
 82499:                 mWrapT = wrap;
 82499:                 mDirtyParameters = true;
 82499:             }
 82499:             return true;
 82499:         }
 82499:       default:
 82499:         return false;
 82499:     }
 82499: }
 82499: 
106441: // Returns true on successful max anisotropy update (valid anisotropy value)
106441: bool Texture::setMaxAnisotropy(float textureMaxAnisotropy, float contextMaxAnisotropy)
106441: {
106441:     textureMaxAnisotropy = std::min(textureMaxAnisotropy, contextMaxAnisotropy);
106441:     if (textureMaxAnisotropy < 1.0f)
106441:     {
106441:         return false;
106441:     }
106441:     if (mMaxAnisotropy != textureMaxAnisotropy)
106441:     {
106441:         mMaxAnisotropy = textureMaxAnisotropy;
106441:         mDirtyParameters = true;
106441:     }
106441:     return true;
106441: }
106441: 
 82499: // Returns true on successful usage state update (valid enum parameter)
 82499: bool Texture::setUsage(GLenum usage)
 82499: {
 82499:     switch (usage)
 82499:     {
 82499:       case GL_NONE:
 82499:       case GL_FRAMEBUFFER_ATTACHMENT_ANGLE:
 82499:         mUsage = usage;
 82499:         return true;
 82499:       default:
 82499:         return false;
 82499:     }
 82499: }
 82499: 
 82499: GLenum Texture::getMinFilter() const
 82499: {
 82499:     return mMinFilter;
 82499: }
 82499: 
 82499: GLenum Texture::getMagFilter() const
 82499: {
 82499:     return mMagFilter;
 82499: }
 82499: 
 82499: GLenum Texture::getWrapS() const
 82499: {
 82499:     return mWrapS;
 82499: }
 82499: 
 82499: GLenum Texture::getWrapT() const
 82499: {
 82499:     return mWrapT;
 82499: }
 82499: 
106441: float Texture::getMaxAnisotropy() const
106441: {
106441:     return mMaxAnisotropy;
106441: }
106441: 
 82499: GLenum Texture::getUsage() const
 82499: {
 82499:     return mUsage;
 70456: }
 70456: 
 70456: void Texture::setImage(GLint unpackAlignment, const void *pixels, Image *image)
 55266: {
 82499:     if (pixels != NULL)
 82499:     {
 95464:         image->loadData(0, 0, image->getWidth(), image->getHeight(), image->getType(), unpackAlignment, pixels);
 82499:         mDirtyImages = true;
 55266:     }
 55266: }
 55266: 
 70456: void Texture::setCompressedImage(GLsizei imageSize, const void *pixels, Image *image)
 55266: {
 82499:     if (pixels != NULL)
 55266:     {
 95464:         image->loadCompressedData(0, 0, image->getWidth(), image->getHeight(), pixels);
 82499:         mDirtyImages = true;
 47652:     }
 47652: }
 47652: 
 70456: bool Texture::subImage(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels, Image *image)
 47652: {
 82499:     if (pixels != NULL)
 82499:     {
 95464:         image->loadData(xoffset, yoffset, width, height, type, unpackAlignment, pixels);
 82499:         mDirtyImages = true;
 55266:     }
 55266: 
 51844:     return true;
 47652: }
 47652: 
 70456: bool Texture::subImageCompressed(GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *pixels, Image *image)
 55266: {
 82499:     if (pixels != NULL)
 55266:     {
 95464:         image->loadCompressedData(xoffset, yoffset, width, height, pixels);
 82499:         mDirtyImages = true;
 55266:     }
 55266: 
 55266:     return true;
 55266: }
 55266: 
 47652: IDirect3DBaseTexture9 *Texture::getTexture()
 47652: {
 82499:     if (!isSamplerComplete())
 47652:     {
 47652:         return NULL;
 47652:     }
 47652: 
 86498:     // ensure the underlying texture is created
 86498:     if (getStorage(false) == NULL)
 86498:     {
 86498:         return NULL;
 47652:     }
 47652: 
 70456:     updateTexture();
 70456: 
 70456:     return getBaseTexture();
 70456: }
 70456: 
 82499: bool Texture::hasDirtyParameters() const
 82499: {
 82499:     return mDirtyParameters;
 82499: }
 82499: 
 82499: bool Texture::hasDirtyImages() const
 82499: {
 82499:     return mDirtyImages;
 47652: }
 47652: 
 70456: void Texture::resetDirty()
 47652: {
 82499:     mDirtyParameters = false;
 82499:     mDirtyImages = false;
 82499: }
 82499: 
 86498: unsigned int Texture::getTextureSerial()
 86498: {
 86498:     TextureStorage *texture = getStorage(false);
 82499:     return texture ? texture->getTextureSerial() : 0;
 82499: }
 82499: 
 86498: unsigned int Texture::getRenderTargetSerial(GLenum target)
 86498: {
 86498:     TextureStorage *texture = getStorage(true);
 82499:     return texture ? texture->getRenderTargetSerial(target) : 0;
 82499: }
 82499: 
 82499: bool Texture::isImmutable() const
 82499: {
 82499:     return mImmutable;
 82499: }
 82499: 
106441: int Texture::getLodOffset()
106441: {
106441:     TextureStorage *texture = getStorage(false);
106441:     return texture ? texture->getLodOffset() : 0;
106441: }
106441: 
 82499: GLint Texture::creationLevels(GLsizei width, GLsizei height) const
 47652: {
 71571:     if ((isPow2(width) && isPow2(height)) || getContext()->supportsNonPower2Texture())
 47652:     {
 82499:         return 0;   // Maximum number of levels
 47652:     }
 47652:     else
 47652:     {
 47652:         // OpenGL ES 2.0 without GL_OES_texture_npot does not permit NPOT mipmaps.
 47652:         return 1;
 47652:     }
 47652: }
 47652: 
 82499: GLint Texture::creationLevels(GLsizei size) const
 82499: {
 82499:     return creationLevels(size, size);
 47652: }
 47652: 
 47652: int Texture::levelCount() const
 47652: {
 70456:     return getBaseTexture() ? getBaseTexture()->GetLevelCount() : 0;
 47652: }
 47652: 
 82499: Blit *Texture::getBlitter()
 82499: {
 82499:     Context *context = getContext();
 82499:     return context->getBlitter();
 82499: }
 82499: 
 82499: bool Texture::copyToRenderTarget(IDirect3DSurface9 *dest, IDirect3DSurface9 *source, bool fromManaged)
 82499: {
 82499:     if (source && dest)
 82499:     {
 82499:         HRESULT result;
 82499: 
 82499:         if (fromManaged)
 82499:         {
 82499:             result = D3DXLoadSurfaceFromSurface(dest, NULL, NULL, source, NULL, NULL, D3DX_FILTER_BOX, 0);
 82499:         }
 82499:         else
 82499:         {
 82499:             egl::Display *display = getDisplay();
 82499:             IDirect3DDevice9 *device = display->getDevice();
 82499: 
 82499:             display->endScene();
 82499:             result = device->StretchRect(source, NULL, dest, NULL, D3DTEXF_NONE);
 82499:         }
 82499: 
 82499:         if (FAILED(result))
 82499:         {
 82499:             ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
 82499:             return false;
 82499:         }
 82499:     }
 82499: 
 82499:     return true;
 82499: }
 82499: 
106441: TextureStorage2D::TextureStorage2D(IDirect3DTexture9 *surfaceTexture) : TextureStorage(D3DUSAGE_RENDERTARGET), mRenderTargetSerial(RenderbufferStorage::issueSerial())
 82499: {
 82499:     mTexture = surfaceTexture;
 82499: }
 82499: 
106441: TextureStorage2D::TextureStorage2D(int levels, D3DFORMAT format, DWORD usage, int width, int height)
106441:     : TextureStorage(usage), mRenderTargetSerial(RenderbufferStorage::issueSerial())
106441: {
106441:     mTexture = NULL;
106441:     // if the width or height is not positive this should be treated as an incomplete texture
106441:     // we handle that here by skipping the d3d texture creation
106441:     if (width > 0 && height > 0)
 82499:     {
 84925:         IDirect3DDevice9 *device = getDevice();
106441:         MakeValidSize(false, dx2es::IsCompressedD3DFormat(format), &width, &height, &mLodOffset);
106441:         HRESULT result = device->CreateTexture(width, height, levels + mLodOffset, getUsage(), format, getPool(), &mTexture, NULL);
 82499: 
 82499:         if (FAILED(result))
 82499:         {
 82499:             ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
 82499:             error(GL_OUT_OF_MEMORY);
 82499:         }
 82499:     }
106441: }
 82499: 
 82499: TextureStorage2D::~TextureStorage2D()
 82499: {
 84925:     if (mTexture)
 84925:     {
 82499:         mTexture->Release();
 82499:     }
 84925: }
 82499: 
106441: // Increments refcount on surface.
106441: // caller must Release() the returned surface
 82499: IDirect3DSurface9 *TextureStorage2D::getSurfaceLevel(int level)
 82499: {
 82499:     IDirect3DSurface9 *surface = NULL;
 82499: 
 82499:     if (mTexture)
 82499:     {
106441:         HRESULT result = mTexture->GetSurfaceLevel(level + mLodOffset, &surface);
 82499:         ASSERT(SUCCEEDED(result));
 82499:     }
 82499: 
 82499:     return surface;
 82499: }
 82499: 
 82499: IDirect3DBaseTexture9 *TextureStorage2D::getBaseTexture() const
 82499: {
 82499:     return mTexture;
 82499: }
 82499: 
 82499: unsigned int TextureStorage2D::getRenderTargetSerial(GLenum target) const
 82499: {
 82499:     return mRenderTargetSerial;
 58582: }
 58582: 
 48434: Texture2D::Texture2D(GLuint id) : Texture(id)
 47652: {
 84925:     mTexStorage = NULL;
 70456:     mSurface = NULL;
 88310:     mColorbufferProxy = NULL;
 88310:     mProxyRefs = 0;
 47652: }
 47652: 
 47652: Texture2D::~Texture2D()
 47652: {
 88310:     mColorbufferProxy = NULL;
 47652: 
 84925:     delete mTexStorage;
 84925:     mTexStorage = NULL;
 70456:     
 70456:     if (mSurface)
 70456:     {
 70456:         mSurface->setBoundTexture(NULL);
 70456:         mSurface = NULL;
 70456:     }
 47652: }
 47652: 
 88310: // We need to maintain a count of references to renderbuffers acting as 
 88310: // proxies for this texture, so that we do not attempt to use a pointer 
 88310: // to a renderbuffer proxy which has been deleted.
 88310: void Texture2D::addProxyRef(const Renderbuffer *proxy)
 88310: {
 88310:     mProxyRefs++;
 88310: }
 88310: 
 88310: void Texture2D::releaseProxy(const Renderbuffer *proxy)
 88310: {
 88310:     if (mProxyRefs > 0)
 88310:         mProxyRefs--;
 88310: 
 88310:     if (mProxyRefs == 0)
 88310:         mColorbufferProxy = NULL;
 88310: }
 88310: 
 47652: GLenum Texture2D::getTarget() const
 47652: {
 47652:     return GL_TEXTURE_2D;
 47652: }
 47652: 
 83408: GLsizei Texture2D::getWidth(GLint level) const
 83408: {
 83408:     if (level < IMPLEMENTATION_MAX_TEXTURE_LEVELS)
 83408:         return mImageArray[level].getWidth();
 83408:     else
 83408:         return 0;
 83408: }
 83408: 
 83408: GLsizei Texture2D::getHeight(GLint level) const
 83408: {
 83408:     if (level < IMPLEMENTATION_MAX_TEXTURE_LEVELS)
 83408:         return mImageArray[level].getHeight();
 83408:     else
 83408:         return 0;
 70456: }
 70456: 
106441: GLenum Texture2D::getInternalFormat(GLint level) const
106441: {
106441:     if (level < IMPLEMENTATION_MAX_TEXTURE_LEVELS)
106441:         return mImageArray[level].getFormat();
106441:     else
106441:         return GL_NONE;
106441: }
106441: 
106441: D3DFORMAT Texture2D::getD3DFormat(GLint level) const
106441: {
106441:     if (level < IMPLEMENTATION_MAX_TEXTURE_LEVELS)
106441:         return mImageArray[level].getD3DFormat();
106441:     else
106441:         return D3DFMT_UNKNOWN;
 70456: }
 70456: 
 82499: void Texture2D::redefineImage(GLint level, GLenum format, GLsizei width, GLsizei height, GLenum type)
 82499: {
 82499:     releaseTexImage();
 82499: 
 82499:     bool redefined = mImageArray[level].redefine(format, width, height, type, false);
 82499: 
 84925:     if (mTexStorage && redefined)
 70456:     {
 58582:         for (int i = 0; i < IMPLEMENTATION_MAX_TEXTURE_LEVELS; i++)
 47652:         {
 82499:             mImageArray[i].markDirty();
 82499:         }
 82499: 
 84925:         delete mTexStorage;
 84925:         mTexStorage = NULL;
 82499:         mDirtyImages = true;
 47652:     }
 70456: }
 70456: 
 70456: void Texture2D::setImage(GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
 47652: {
 82499:     redefineImage(level, format, width, height, type);
 70456: 
 70456:     Texture::setImage(unpackAlignment, pixels, &mImageArray[level]);
 47652: }
 47652: 
 70456: void Texture2D::bindTexImage(egl::Surface *surface)
 55266: {
 82499:     releaseTexImage();
 82499: 
 70456:     GLenum format;
 70456: 
 70456:     switch(surface->getFormat())
 70456:     {
 70456:       case D3DFMT_A8R8G8B8:
 70456:         format = GL_RGBA;
 70456:         break;
 70456:       case D3DFMT_X8R8G8B8:
 70456:         format = GL_RGB;
 70456:         break;
 70456:       default:
 70456:         UNIMPLEMENTED();
 70456:         return;
 70456:     }
 70456: 
 82499:     mImageArray[0].redefine(format, surface->getWidth(), surface->getHeight(), GL_UNSIGNED_BYTE, true);
 82499: 
 84925:     delete mTexStorage;
 84925:     mTexStorage = new TextureStorage2D(surface->getOffscreenTexture());
 82499: 
 82499:     mDirtyImages = true;
 70456:     mSurface = surface;
 70456:     mSurface->setBoundTexture(this);
 70456: }
 70456: 
 70456: void Texture2D::releaseTexImage()
 70456: {
 82499:     if (mSurface)
 82499:     {
 82499:         mSurface->setBoundTexture(NULL);
 82499:         mSurface = NULL;
 82499: 
 84925:         if (mTexStorage)
 84925:         {
 84925:             delete mTexStorage;
 84925:             mTexStorage = NULL;
 82499:         }
 82499: 
 82499:         for (int i = 0; i < IMPLEMENTATION_MAX_TEXTURE_LEVELS; i++)
 82499:         {
 82499:             mImageArray[i].redefine(GL_RGBA, 0, 0, GL_UNSIGNED_BYTE, true);
 82499:         }
 82499:     }
 70456: }
 70456: 
 70456: void Texture2D::setCompressedImage(GLint level, GLenum format, GLsizei width, GLsizei height, GLsizei imageSize, const void *pixels)
 70456: {
 82499:     redefineImage(level, format, width, height, GL_UNSIGNED_BYTE);
 70456: 
 70456:     Texture::setCompressedImage(imageSize, pixels, &mImageArray[level]);
 55266: }
 55266: 
 47652: void Texture2D::commitRect(GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height)
 47652: {
 82499:     ASSERT(mImageArray[level].getSurface() != NULL);
 47652: 
 47652:     if (level < levelCount())
 47652:     {
 84925:         IDirect3DSurface9 *destLevel = mTexStorage->getSurfaceLevel(level);
 82499: 
 82499:         if (destLevel)
 47652:         {
 70456:             Image *image = &mImageArray[level];
 82499:             image->updateSurface(destLevel, xoffset, yoffset, width, height);
 47652: 
 47652:             destLevel->Release();
 82499:             image->markClean();
 47652:         }
 47652:     }
 47652: }
 47652: 
 47652: void Texture2D::subImage(GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
 47652: {
 51844:     if (Texture::subImage(xoffset, yoffset, width, height, format, type, unpackAlignment, pixels, &mImageArray[level]))
 51844:     {
 47652:         commitRect(level, xoffset, yoffset, width, height);
 47652:     }
 51844: }
 47652: 
 55266: void Texture2D::subImageCompressed(GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *pixels)
 55266: {
 55266:     if (Texture::subImageCompressed(xoffset, yoffset, width, height, format, imageSize, pixels, &mImageArray[level]))
 55266:     {
 55266:         commitRect(level, xoffset, yoffset, width, height);
 55266:     }
 55266: }
 55266: 
 70456: void Texture2D::copyImage(GLint level, GLenum format, GLint x, GLint y, GLsizei width, GLsizei height, Framebuffer *source)
 47652: {
 58582:     IDirect3DSurface9 *renderTarget = source->getRenderTarget();
 58582: 
 58582:     if (!renderTarget)
 58582:     {
 58582:         ERR("Failed to retrieve the render target.");
 58582:         return error(GL_OUT_OF_MEMORY);
 58582:     }
 58582: 
 82499:     redefineImage(level, format, width, height, GL_UNSIGNED_BYTE);
 70456:    
 86498:     if (!mImageArray[level].isRenderableFormat())
 58582:     {
 82499:         mImageArray[level].copy(0, 0, x, y, width, height, renderTarget);
 82499:         mDirtyImages = true;
 58582:     }
 58582:     else
 58582:     {
 86498:         if (!mTexStorage || !mTexStorage->isRenderTarget())
 47652:         {
 47652:             convertToRenderTarget();
 47652:         }
 70456:         
 82499:         mImageArray[level].markClean();
 47652: 
 47652:         if (width != 0 && height != 0 && level < levelCount())
 47652:         {
106441:             RECT sourceRect;
106441:             sourceRect.left = x;
106441:             sourceRect.right = x + width;
106441:             sourceRect.top = y;
106441:             sourceRect.bottom = y + height;
 82499:             
 84925:             IDirect3DSurface9 *dest = mTexStorage->getSurfaceLevel(level);
 82499: 
 82499:             if (dest)
 82499:             {
106441:                 getBlitter()->copy(renderTarget, sourceRect, format, 0, 0, dest);
 47652:                 dest->Release();
 47652:             }
 58582:         }
 47652:     }
 47652: 
 82499:     renderTarget->Release();
 82499: }
 82499: 
 61598: void Texture2D::copySubImage(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height, Framebuffer *source)
 47652: {
 82499:     if (xoffset + width > mImageArray[level].getWidth() || yoffset + height > mImageArray[level].getHeight())
 47652:     {
 47652:         return error(GL_INVALID_VALUE);
 47652:     }
 47652: 
 58582:     IDirect3DSurface9 *renderTarget = source->getRenderTarget();
 58582: 
 58582:     if (!renderTarget)
 58582:     {
 58582:         ERR("Failed to retrieve the render target.");
 58582:         return error(GL_OUT_OF_MEMORY);
 58582:     }
 58582: 
 86498:     if (!mImageArray[level].isRenderableFormat() || (!mTexStorage && !isSamplerComplete()))
 82499:     {
 82499:         mImageArray[level].copy(xoffset, yoffset, x, y, width, height, renderTarget);
 82499:         mDirtyImages = true;
 58582:     }
 58582:     else
 58582:     {
 86498:         if (!mTexStorage || !mTexStorage->isRenderTarget())
 47652:         {
 47652:             convertToRenderTarget();
 47652:         }
 70456:         
 70456:         updateTexture();
 47652: 
 47652:         if (level < levelCount())
 47652:         {
106441:             RECT sourceRect;
106441:             sourceRect.left = x;
106441:             sourceRect.right = x + width;
106441:             sourceRect.top = y;
106441:             sourceRect.bottom = y + height;
106441: 
 82499: 
 84925:             IDirect3DSurface9 *dest = mTexStorage->getSurfaceLevel(level);
 82499: 
 82499:             if (dest)
 82499:             {
106441:                 getBlitter()->copy(renderTarget, sourceRect, mImageArray[0].getFormat(), xoffset, yoffset, dest);
 47652:                 dest->Release();
 47652:             }
 47652:         }
 58582:     }
 47652: 
 82499:     renderTarget->Release();
 82499: }
 82499: 
 82499: void Texture2D::storage(GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
 82499: {
 82499:     GLenum format = gl::ExtractFormat(internalformat);
 82499:     GLenum type = gl::ExtractType(internalformat);
 84925:     D3DFORMAT d3dfmt = ConvertTextureFormatType(format, type);
106441:     DWORD d3dusage = GetTextureUsage(d3dfmt, mUsage, false);
 84925: 
 84925:     delete mTexStorage;
106441:     mTexStorage = new TextureStorage2D(levels, d3dfmt, d3dusage, width, height);
 82499:     mImmutable = true;
 82499: 
 82499:     for (int level = 0; level < levels; level++)
 82499:     {
 82499:         mImageArray[level].redefine(format, width, height, type, true);
 82499:         width = std::max(1, width >> 1);
 82499:         height = std::max(1, height >> 1);
 82499:     }
 82499: 
 82499:     for (int level = levels; level < IMPLEMENTATION_MAX_TEXTURE_LEVELS; level++)
 82499:     {
 82499:         mImageArray[level].redefine(GL_NONE, 0, 0, GL_UNSIGNED_BYTE, true);
 82499:     }
 84925: 
 84925:     if (mTexStorage->isManaged())
 84925:     {
 84925:         int levels = levelCount();
 84925: 
 84925:         for (int level = 0; level < levels; level++)
 84925:         {
 84925:             IDirect3DSurface9 *surface = mTexStorage->getSurfaceLevel(level);
 84925:             mImageArray[level].setManagedSurface(surface);
 84925:         }
 84925:     }
 82499: }
 82499: 
 82499: // Tests for 2D texture sampling completeness. [OpenGL ES 2.0.24] section 3.8.2 page 85.
 82499: bool Texture2D::isSamplerComplete() const
 82499: {
 82499:     GLsizei width = mImageArray[0].getWidth();
 82499:     GLsizei height = mImageArray[0].getHeight();
 47652: 
 47652:     if (width <= 0 || height <= 0)
 47652:     {
 47652:         return false;
 47652:     }
 47652: 
 47652:     bool mipmapping = false;
 47652: 
 47652:     switch (mMinFilter)
 47652:     {
 47652:       case GL_NEAREST:
 47652:       case GL_LINEAR:
 47652:         mipmapping = false;
 47652:         break;
 47652:       case GL_NEAREST_MIPMAP_NEAREST:
 47652:       case GL_LINEAR_MIPMAP_NEAREST:
 47652:       case GL_NEAREST_MIPMAP_LINEAR:
 47652:       case GL_LINEAR_MIPMAP_LINEAR:
 47652:         mipmapping = true;
 47652:         break;
 47652:       default: UNREACHABLE();
 47652:     }
 47652: 
106441:     if ((getInternalFormat(0) == GL_FLOAT && !getContext()->supportsFloat32LinearFilter()) ||
106441:         (getInternalFormat(0) == GL_HALF_FLOAT_OES && !getContext()->supportsFloat16LinearFilter()))
 55266:     {
 55266:         if (mMagFilter != GL_NEAREST || (mMinFilter != GL_NEAREST && mMinFilter != GL_NEAREST_MIPMAP_NEAREST))
 55266:         {
 55266:             return false;
 55266:         }
 55266:     }
 55266: 
 82499:     bool npotSupport = getContext()->supportsNonPower2Texture();
 82499: 
 82499:     if (!npotSupport)
 71571:     {
 71571:         if ((getWrapS() != GL_CLAMP_TO_EDGE && !isPow2(width)) ||
 71571:             (getWrapT() != GL_CLAMP_TO_EDGE && !isPow2(height)))
 47652:         {
 47652:             return false;
 47652:         }
 71571:     }
 47652: 
 47652:     if (mipmapping)
 47652:     {
 82499:         if (!npotSupport)
 71571:         {
 47652:             if (!isPow2(width) || !isPow2(height))
 47652:             {
 47652:                 return false;
 47652:             }
 71571:         }
 47652: 
 82499:         if (!isMipmapComplete())
 82499:         {
 82499:             return false;
 82499:         }
 82499:     }
 82499: 
 82499:     return true;
 82499: }
 82499: 
 82499: // Tests for 2D texture (mipmap) completeness. [OpenGL ES 2.0.24] section 3.7.10 page 81.
 82499: bool Texture2D::isMipmapComplete() const
 82499: {
 82499:     if (isImmutable())
 82499:     {
 82499:         return true;
 82499:     }
 82499: 
 82499:     GLsizei width = mImageArray[0].getWidth();
 82499:     GLsizei height = mImageArray[0].getHeight();
 82499: 
 82499:     if (width <= 0 || height <= 0)
 82499:     {
 82499:         return false;
 82499:     }
 82499: 
 47652:     int q = log2(std::max(width, height));
 47652: 
 47652:     for (int level = 1; level <= q; level++)
 47652:     {
 82499:         if (mImageArray[level].getFormat() != mImageArray[0].getFormat())
 47652:         {
 47652:             return false;
 47652:         }
 47652: 
 82499:         if (mImageArray[level].getType() != mImageArray[0].getType())
 70456:         {
 70456:             return false;
 70456:         }
 70456: 
 82499:         if (mImageArray[level].getWidth() != std::max(1, width >> level))
 47652:         {
 47652:             return false;
 47652:         }
 47652: 
 82499:         if (mImageArray[level].getHeight() != std::max(1, height >> level))
 47652:         {
 47652:             return false;
 47652:         }
 47652:     }
 47652: 
 47652:     return true;
 47652: }
 47652: 
106441: bool Texture2D::isCompressed(GLint level) const
106441: {
106441:     return IsCompressed(getInternalFormat(level));
106441: }
106441: 
106441: bool Texture2D::isDepth(GLint level) const
106441: {
106441:     return IsDepthTexture(getInternalFormat(level));
 55266: }
 55266: 
 70456: IDirect3DBaseTexture9 *Texture2D::getBaseTexture() const
 47652: {
 84925:     return mTexStorage ? mTexStorage->getBaseTexture() : NULL;
 70456: }
 70456: 
 70456: // Constructs a Direct3D 9 texture resource from the texture images
 70456: void Texture2D::createTexture()
 70456: {
 82499:     GLsizei width = mImageArray[0].getWidth();
 82499:     GLsizei height = mImageArray[0].getHeight();
119937: 
119937:     if (!(width > 0 && height > 0))
119937:         return; // do not attempt to create d3d textures for nonexistant data
119937: 
 82499:     GLint levels = creationLevels(width, height);
106441:     D3DFORMAT d3dfmt = mImageArray[0].getD3DFormat();
106441:     DWORD d3dusage = GetTextureUsage(d3dfmt, mUsage, false);
 84925: 
 84925:     delete mTexStorage;
106441:     mTexStorage = new TextureStorage2D(levels, d3dfmt, d3dusage, width, height);
 84925:     
 84925:     if (mTexStorage->isManaged())
 82499:     {
 82499:         int levels = levelCount();
 82499: 
 82499:         for (int level = 0; level < levels; level++)
 82499:         {
 84925:             IDirect3DSurface9 *surface = mTexStorage->getSurfaceLevel(level);
 82499:             mImageArray[level].setManagedSurface(surface);
 82499:         }
 82499:     }
 82499: 
 82499:     mDirtyImages = true;
 47652: }
 47652: 
 47652: void Texture2D::updateTexture()
 47652: {
 47652:     int levels = levelCount();
 47652: 
 47652:     for (int level = 0; level < levels; level++)
 47652:     {
 82499:         Image *image = &mImageArray[level];
 82499: 
 82499:         if (image->isDirty())
 82499:         {
 82499:             commitRect(level, 0, 0, mImageArray[level].getWidth(), mImageArray[level].getHeight());
 47652:         }
 47652:     }
 47652: }
 47652: 
 70456: void Texture2D::convertToRenderTarget()
 47652: {
 84925:     TextureStorage2D *newTexStorage = NULL;
 82499: 
 82499:     if (mImageArray[0].getWidth() != 0 && mImageArray[0].getHeight() != 0)
 82499:     {
 82499:         GLsizei width = mImageArray[0].getWidth();
 82499:         GLsizei height = mImageArray[0].getHeight();
 82499:         GLint levels = creationLevels(width, height);
106441:         D3DFORMAT d3dfmt = mImageArray[0].getD3DFormat();
106441:         DWORD d3dusage = GetTextureUsage(d3dfmt, GL_FRAMEBUFFER_ATTACHMENT_ANGLE, true);
106441: 
106441:         newTexStorage = new TextureStorage2D(levels, d3dfmt, d3dusage, width, height);
 84925: 
 84925:         if (mTexStorage != NULL)
 47652:         {
 47652:             int levels = levelCount();
 47652:             for (int i = 0; i < levels; i++)
 47652:             {
 84925:                 IDirect3DSurface9 *source = mTexStorage->getSurfaceLevel(i);
 84925:                 IDirect3DSurface9 *dest = newTexStorage->getSurfaceLevel(i);
 84925: 
 84925:                 if (!copyToRenderTarget(dest, source, mTexStorage->isManaged()))
 84925:                 {   
 84925:                    delete newTexStorage;
106441:                    if (source) source->Release();
106441:                    if (dest) dest->Release();
 70456:                    return error(GL_OUT_OF_MEMORY);
 47652:                 }
 47652: 
 82499:                 if (source) source->Release();
 82499:                 if (dest) dest->Release();
 82499:             }
 82499:         }
 82499:     }
 82499: 
 84925:     delete mTexStorage;
 84925:     mTexStorage = newTexStorage;
 82499: 
 82499:     mDirtyImages = true;
 47652: }
 47652: 
 47652: void Texture2D::generateMipmaps()
 47652: {
 71571:     if (!getContext()->supportsNonPower2Texture())
 71571:     {
 82499:         if (!isPow2(mImageArray[0].getWidth()) || !isPow2(mImageArray[0].getHeight()))
 47652:         {
 47652:             return error(GL_INVALID_OPERATION);
 47652:         }
 71571:     }
 47652: 
 47652:     // Purge array levels 1 through q and reset them to represent the generated mipmap levels.
 82499:     unsigned int q = log2(std::max(mImageArray[0].getWidth(), mImageArray[0].getHeight()));
 47652:     for (unsigned int i = 1; i <= q; i++)
 47652:     {
 82499:         redefineImage(i, mImageArray[0].getFormat(), 
 82499:                          std::max(mImageArray[0].getWidth() >> i, 1),
 82499:                          std::max(mImageArray[0].getHeight() >> i, 1),
 82499:                          mImageArray[0].getType());
 82499:     }
 82499: 
 86498:     if (mTexStorage && mTexStorage->isRenderTarget())
 82499:     {
 47652:         for (unsigned int i = 1; i <= q; i++)
 47652:         {
 84925:             IDirect3DSurface9 *upper = mTexStorage->getSurfaceLevel(i - 1);
 84925:             IDirect3DSurface9 *lower = mTexStorage->getSurfaceLevel(i);
 47652: 
 47652:             if (upper != NULL && lower != NULL)
 47652:             {
 47652:                 getBlitter()->boxFilter(upper, lower);
 47652:             }
 47652: 
 47652:             if (upper != NULL) upper->Release();
 47652:             if (lower != NULL) lower->Release();
 70456: 
 82499:             mImageArray[i].markClean();
 47652:         }
 47652:     }
 58582:     else
 58582:     {
 58582:         for (unsigned int i = 1; i <= q; i++)
 58582:         {
 82499:             if (mImageArray[i].getSurface() == NULL)
 58582:             {
 58582:                 return error(GL_OUT_OF_MEMORY);
 58582:             }
 58582: 
 82499:             if (FAILED(D3DXLoadSurfaceFromSurface(mImageArray[i].getSurface(), NULL, NULL, mImageArray[i - 1].getSurface(), NULL, NULL, D3DX_FILTER_BOX, 0)))
 58582:             {
 58582:                 ERR(" failed to load filter %d to %d.", i - 1, i);
 58582:             }
 58582: 
 82499:             mImageArray[i].markDirty();
 58582:         }
 58582:     }
 58582: }
 47652: 
 70456: Renderbuffer *Texture2D::getRenderbuffer(GLenum target)
 47652: {
 47652:     if (target != GL_TEXTURE_2D)
 47652:     {
 48434:         return error(GL_INVALID_OPERATION, (Renderbuffer *)NULL);
 47652:     }
 47652: 
 88310:     if (mColorbufferProxy == NULL)
 88310:     {
106441:         mColorbufferProxy = new Renderbuffer(id(), new RenderbufferTexture2D(this, target));
 88310:     }
 88310: 
 88310:     return mColorbufferProxy;
 47652: }
 47652: 
106441: // Increments refcount on surface.
106441: // caller must Release() the returned surface
 47652: IDirect3DSurface9 *Texture2D::getRenderTarget(GLenum target)
 47652: {
 47652:     ASSERT(target == GL_TEXTURE_2D);
 47652: 
 86498:     // ensure the underlying texture is created
 86498:     if (getStorage(true) == NULL)
 86498:     {
 86498:         return NULL;
 86498:     }
 86498: 
 86498:     updateTexture();
 86498:     
106441:     // ensure this is NOT a depth texture
106441:     if (isDepth(0))
106441:     {
106441:         return NULL;
106441:     }
 86498:     return mTexStorage->getSurfaceLevel(0);
 86498: }
 86498: 
106441: // Increments refcount on surface.
106441: // caller must Release() the returned surface
106441: IDirect3DSurface9 *Texture2D::getDepthStencil(GLenum target)
106441: {
106441:     ASSERT(target == GL_TEXTURE_2D);
106441: 
106441:     // ensure the underlying texture is created
106441:     if (getStorage(true) == NULL)
106441:     {
106441:         return NULL;
106441:     }
106441: 
106441:     updateTexture();
106441: 
106441:     // ensure this is actually a depth texture
106441:     if (!isDepth(0))
106441:     {
106441:         return NULL;
106441:     }
106441:     return mTexStorage->getSurfaceLevel(0);
106441: }
106441: 
 86498: TextureStorage *Texture2D::getStorage(bool renderTarget)
 86498: {
 86498:     if (!mTexStorage || (renderTarget && !mTexStorage->isRenderTarget()))
 86498:     {
 86498:         if (renderTarget)
 70456:         {
 70456:             convertToRenderTarget();
 70456:         }
 86498:         else
 86498:         {
 86498:             createTexture();
 86498:         }
 86498:     }
 86498: 
 84925:     return mTexStorage;
 82499: }
 82499: 
106441: TextureStorageCubeMap::TextureStorageCubeMap(int levels, D3DFORMAT format, DWORD usage, int size)
106441:     : TextureStorage(usage), mFirstRenderTargetSerial(RenderbufferStorage::issueCubeSerials())
106441: {
106441:     mTexture = NULL;
106441:     // if the size is not positive this should be treated as an incomplete texture
106441:     // we handle that here by skipping the d3d texture creation
106441:     if (size > 0)
 82499:     {
 84925:         IDirect3DDevice9 *device = getDevice();
106441:         int height = size;
106441:         MakeValidSize(false, dx2es::IsCompressedD3DFormat(format), &size, &height, &mLodOffset);
106441:         HRESULT result = device->CreateCubeTexture(size, levels + mLodOffset, getUsage(), format, getPool(), &mTexture, NULL);
 82499: 
 82499:         if (FAILED(result))
 82499:         {
 82499:             ASSERT(result == D3DERR_OUTOFVIDEOMEMORY || result == E_OUTOFMEMORY);
 82499:             error(GL_OUT_OF_MEMORY);
 82499:         }
 82499:     }
106441: }
 82499: 
 82499: TextureStorageCubeMap::~TextureStorageCubeMap()
 82499: {
 84925:     if (mTexture)
 84925:     {
 82499:         mTexture->Release();
 82499:     }
 84925: }
 82499: 
106441: // Increments refcount on surface.
106441: // caller must Release() the returned surface
 82499: IDirect3DSurface9 *TextureStorageCubeMap::getCubeMapSurface(GLenum faceTarget, int level)
 82499: {
 82499:     IDirect3DSurface9 *surface = NULL;
 82499: 
 82499:     if (mTexture)
 82499:     {
106441:         HRESULT result = mTexture->GetCubeMapSurface(es2dx::ConvertCubeFace(faceTarget), level + mLodOffset, &surface);
 82499:         ASSERT(SUCCEEDED(result));
 82499:     }
 82499: 
 82499:     return surface;
 82499: }
 82499: 
 82499: IDirect3DBaseTexture9 *TextureStorageCubeMap::getBaseTexture() const
 82499: {
 82499:     return mTexture;
 82499: }
 82499: 
 82499: unsigned int TextureStorageCubeMap::getRenderTargetSerial(GLenum target) const
 82499: {
 82499:     return mFirstRenderTargetSerial + TextureCubeMap::faceIndex(target);
 47652: }
 47652: 
 48434: TextureCubeMap::TextureCubeMap(GLuint id) : Texture(id)
 47652: {
 84925:     mTexStorage = NULL;
 88310:     for (int i = 0; i < 6; i++)
 88310:     {
 88310:         mFaceProxies[i] = NULL;
 88310:         mFaceProxyRefs[i] = 0;
 88310:     }
 47652: }
 47652: 
 47652: TextureCubeMap::~TextureCubeMap()
 47652: {
 47652:     for (int i = 0; i < 6; i++)
 47652:     {
 88310:         mFaceProxies[i] = NULL;
 47652:     }
 47652: 
 84925:     delete mTexStorage;
 84925:     mTexStorage = NULL;
 47652: }
 47652: 
 88310: // We need to maintain a count of references to renderbuffers acting as 
 88310: // proxies for this texture, so that the texture is not deleted while 
 88310: // proxy references still exist. If the reference count drops to zero,
 88310: // we set our proxy pointer NULL, so that a new attempt at referencing
 88310: // will cause recreation.
 88310: void TextureCubeMap::addProxyRef(const Renderbuffer *proxy)
 88310: {
 88310:     for (int i = 0; i < 6; i++)
 88310:     {
 88310:         if (mFaceProxies[i] == proxy)
 88310:             mFaceProxyRefs[i]++;
 88310:     }
 88310: }
 88310: 
 88310: void TextureCubeMap::releaseProxy(const Renderbuffer *proxy)
 88310: {
 88310:     for (int i = 0; i < 6; i++)
 88310:     {
 88310:         if (mFaceProxies[i] == proxy)
 88310:         {
 88310:             if (mFaceProxyRefs[i] > 0)
 88310:                 mFaceProxyRefs[i]--;
 88310: 
 88310:             if (mFaceProxyRefs[i] == 0)
 88310:                 mFaceProxies[i] = NULL;
 88310:         }
 88310:     }
 88310: }
 88310: 
 47652: GLenum TextureCubeMap::getTarget() const
 47652: {
 47652:     return GL_TEXTURE_CUBE_MAP;
 47652: }
 47652: 
106441: GLsizei TextureCubeMap::getWidth(GLenum target, GLint level) const
 83408: {
 83408:     if (level < IMPLEMENTATION_MAX_TEXTURE_LEVELS)
106441:         return mImageArray[faceIndex(target)][level].getWidth();
 83408:     else
 83408:         return 0;
 83408: }
 83408: 
106441: GLsizei TextureCubeMap::getHeight(GLenum target, GLint level) const
 83408: {
 83408:     if (level < IMPLEMENTATION_MAX_TEXTURE_LEVELS)
106441:         return mImageArray[faceIndex(target)][level].getHeight();
 83408:     else
 83408:         return 0;
 70456: }
 70456: 
106441: GLenum TextureCubeMap::getInternalFormat(GLenum target, GLint level) const
106441: {
106441:     if (level < IMPLEMENTATION_MAX_TEXTURE_LEVELS)
106441:         return mImageArray[faceIndex(target)][level].getFormat();
106441:     else
106441:         return GL_NONE;
106441: }
106441: 
106441: D3DFORMAT TextureCubeMap::getD3DFormat(GLenum target, GLint level) const
106441: {
106441:     if (level < IMPLEMENTATION_MAX_TEXTURE_LEVELS)
106441:         return mImageArray[faceIndex(target)][level].getD3DFormat();
106441:     else
106441:         return D3DFMT_UNKNOWN;
 47652: }
 47652: 
 70456: void TextureCubeMap::setImagePosX(GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
 47652: {
 70456:     setImage(0, level, width, height, format, type, unpackAlignment, pixels);
 47652: }
 47652: 
 70456: void TextureCubeMap::setImageNegX(GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
 47652: {
 70456:     setImage(1, level, width, height, format, type, unpackAlignment, pixels);
 47652: }
 47652: 
 70456: void TextureCubeMap::setImagePosY(GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
 47652: {
 70456:     setImage(2, level, width, height, format, type, unpackAlignment, pixels);
 47652: }
 47652: 
 70456: void TextureCubeMap::setImageNegY(GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
 47652: {
 70456:     setImage(3, level, width, height, format, type, unpackAlignment, pixels);
 47652: }
 47652: 
 70456: void TextureCubeMap::setImagePosZ(GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
 55266: {
 70456:     setImage(4, level, width, height, format, type, unpackAlignment, pixels);
 70456: }
 70456: 
 70456: void TextureCubeMap::setImageNegZ(GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
 70456: {
 70456:     setImage(5, level, width, height, format, type, unpackAlignment, pixels);
 70456: }
 70456: 
 70456: void TextureCubeMap::setCompressedImage(GLenum face, GLint level, GLenum format, GLsizei width, GLsizei height, GLsizei imageSize, const void *pixels)
 70456: {
 82499:     redefineImage(faceIndex(face), level, format, width, height, GL_UNSIGNED_BYTE);
 70456: 
 70456:     Texture::setCompressedImage(imageSize, pixels, &mImageArray[faceIndex(face)][level]);
 55266: }
 55266: 
 82499: void TextureCubeMap::commitRect(int face, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height)
 82499: {
 82499:     ASSERT(mImageArray[face][level].getSurface() != NULL);
 47652: 
 47652:     if (level < levelCount())
 47652:     {
 84925:         IDirect3DSurface9 *destLevel = mTexStorage->getCubeMapSurface(GL_TEXTURE_CUBE_MAP_POSITIVE_X + face, level);
 47652:         ASSERT(destLevel != NULL);
 47652: 
 47652:         if (destLevel != NULL)
 47652:         {
 70456:             Image *image = &mImageArray[face][level];
 82499:             image->updateSurface(destLevel, xoffset, yoffset, width, height);
 47652: 
 47652:             destLevel->Release();
 82499:             image->markClean();
 47652:         }
 47652:     }
 47652: }
 47652: 
 58582: void TextureCubeMap::subImage(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
 47652: {
 58582:     if (Texture::subImage(xoffset, yoffset, width, height, format, type, unpackAlignment, pixels, &mImageArray[faceIndex(target)][level]))
 51844:     {
 82499:         commitRect(faceIndex(target), level, xoffset, yoffset, width, height);
 47652:     }
 51844: }
 47652: 
 58582: void TextureCubeMap::subImageCompressed(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *pixels)
 55266: {
 58582:     if (Texture::subImageCompressed(xoffset, yoffset, width, height, format, imageSize, pixels, &mImageArray[faceIndex(target)][level]))
 55266:     {
 82499:         commitRect(faceIndex(target), level, xoffset, yoffset, width, height);
 82499:     }
 82499: }
 82499: 
 82499: // Tests for cube map sampling completeness. [OpenGL ES 2.0.24] section 3.8.2 page 86.
 82499: bool TextureCubeMap::isSamplerComplete() const
 82499: {
 82499:     int size = mImageArray[0][0].getWidth();
 47652: 
 47652:     bool mipmapping;
 47652: 
 47652:     switch (mMinFilter)
 47652:     {
 47652:       case GL_NEAREST:
 47652:       case GL_LINEAR:
 47652:         mipmapping = false;
 47652:         break;
 47652:       case GL_NEAREST_MIPMAP_NEAREST:
 47652:       case GL_LINEAR_MIPMAP_NEAREST:
 47652:       case GL_NEAREST_MIPMAP_LINEAR:
 47652:       case GL_LINEAR_MIPMAP_LINEAR:
 47652:         mipmapping = true;
 47652:         break;
 95464:       default:
 95464:         UNREACHABLE();
 95464:         return false;
 47652:     }
 47652: 
106441:     if ((getInternalFormat(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0) == GL_FLOAT && !getContext()->supportsFloat32LinearFilter()) ||
106441:         (getInternalFormat(GL_TEXTURE_CUBE_MAP_POSITIVE_X, 0) == GL_HALF_FLOAT_OES && !getContext()->supportsFloat16LinearFilter()))
 82499:     {
 82499:         if (mMagFilter != GL_NEAREST || (mMinFilter != GL_NEAREST && mMinFilter != GL_NEAREST_MIPMAP_NEAREST))
 82499:         {
 82499:             return false;
 82499:         }
 82499:     }
 82499: 
 82499:     if (!isPow2(size) && !getContext()->supportsNonPower2Texture())
 82499:     {
 82499:         if (getWrapS() != GL_CLAMP_TO_EDGE || getWrapT() != GL_CLAMP_TO_EDGE || mipmapping)
 82499:         {
 82499:             return false;
 82499:         }
 82499:     }
 82499: 
 82499:     if (!mipmapping)
 82499:     {
 82499:         if (!isCubeComplete())
 82499:         {
 82499:             return false;
 82499:         }
 82499:     }
 82499:     else
 82499:     {
 82499:         if (!isMipmapCubeComplete())   // Also tests for isCubeComplete()
 82499:         {
 82499:             return false;
 82499:         }
 82499:     }
 82499: 
 82499:     return true;
 82499: }
 82499: 
 82499: // Tests for cube texture completeness. [OpenGL ES 2.0.24] section 3.7.10 page 81.
 82499: bool TextureCubeMap::isCubeComplete() const
 82499: {
 82499:     if (mImageArray[0][0].getWidth() <= 0 || mImageArray[0][0].getHeight() != mImageArray[0][0].getWidth())
 82499:     {
 82499:         return false;
 82499:     }
 82499: 
 82499:     for (unsigned int face = 1; face < 6; face++)
 82499:     {
 82499:         if (mImageArray[face][0].getWidth() != mImageArray[0][0].getWidth() ||
 82499:             mImageArray[face][0].getWidth() != mImageArray[0][0].getHeight() ||
 82499:             mImageArray[face][0].getFormat() != mImageArray[0][0].getFormat() ||
 82499:             mImageArray[face][0].getType() != mImageArray[0][0].getType())
 82499:         {
 82499:             return false;
 82499:         }
 82499:     }
 82499: 
 82499:     return true;
 82499: }
 82499: 
 82499: bool TextureCubeMap::isMipmapCubeComplete() const
 82499: {
 82499:     if (isImmutable())
 82499:     {
 82499:         return true;
 82499:     }
 82499: 
 82499:     if (!isCubeComplete())
 82499:     {
 82499:         return false;
 82499:     }
 82499: 
 82499:     GLsizei size = mImageArray[0][0].getWidth();
 82499: 
 82499:     int q = log2(size);
 82499: 
 47652:     for (int face = 0; face < 6; face++)
 47652:     {
 82499:         for (int level = 1; level <= q; level++)
 82499:         {
 82499:             if (mImageArray[face][level].getFormat() != mImageArray[0][0].getFormat())
 47652:             {
 47652:                 return false;
 47652:             }
 82499: 
 82499:             if (mImageArray[face][level].getType() != mImageArray[0][0].getType())
 55266:             {
 55266:                 return false;
 55266:             }
 82499: 
 82499:             if (mImageArray[face][level].getWidth() != std::max(1, size >> level))
 71571:             {
 71571:                 return false;
 71571:             }
 71571:         }
 47652:     }
 47652: 
 47652:     return true;
 47652: }
 47652: 
106441: bool TextureCubeMap::isCompressed(GLenum target, GLint level) const
106441: {
106441:     return IsCompressed(getInternalFormat(target, level));
 55266: }
 55266: 
 70456: IDirect3DBaseTexture9 *TextureCubeMap::getBaseTexture() const
 70456: {
 84925:     return mTexStorage ? mTexStorage->getBaseTexture() : NULL;
 70456: }
 70456: 
 47652: // Constructs a Direct3D 9 texture resource from the texture images, or returns an existing one
 70456: void TextureCubeMap::createTexture()
 47652: {
 82499:     GLsizei size = mImageArray[0][0].getWidth();
119937: 
119937:     if (!(size > 0))
119937:         return; // do not attempt to create d3d textures for nonexistant data
119937: 
 82499:     GLint levels = creationLevels(size, 0);
106441:     D3DFORMAT d3dfmt = mImageArray[0][0].getD3DFormat();
106441:     DWORD d3dusage = GetTextureUsage(d3dfmt, mUsage, false);
 84925: 
 84925:     delete mTexStorage;
106441:     mTexStorage = new TextureStorageCubeMap(levels, d3dfmt, d3dusage, size);
 84925: 
 84925:     if (mTexStorage->isManaged())
 82499:     {
 82499:         int levels = levelCount();
 82499: 
 82499:         for (int face = 0; face < 6; face++)
 82499:         {
 82499:             for (int level = 0; level < levels; level++)
 82499:             {
 84925:                 IDirect3DSurface9 *surface = mTexStorage->getCubeMapSurface(GL_TEXTURE_CUBE_MAP_POSITIVE_X + face, level);
 82499:                 mImageArray[face][level].setManagedSurface(surface);
 82499:             }
 82499:         }
 82499:     }
 82499: 
 82499:     mDirtyImages = true;
 47652: }
 47652: 
 47652: void TextureCubeMap::updateTexture()
 47652: {
 47652:     for (int face = 0; face < 6; face++)
 47652:     {
 47652:         int levels = levelCount();
 47652:         for (int level = 0; level < levels; level++)
 47652:         {
 70456:             Image *image = &mImageArray[face][level];
 70456: 
 82499:             if (image->isDirty())
 82499:             {
 82499:                 commitRect(face, level, 0, 0, image->getWidth(), image->getHeight());
 47652:             }
 47652:         }
 47652:     }
 47652: }
 47652: 
 70456: void TextureCubeMap::convertToRenderTarget()
 47652: {
 84925:     TextureStorageCubeMap *newTexStorage = NULL;
 82499: 
 82499:     if (mImageArray[0][0].getWidth() != 0)
 82499:     {
 82499:         GLsizei size = mImageArray[0][0].getWidth();
 82499:         GLint levels = creationLevels(size, 0);
106441:         D3DFORMAT d3dfmt = mImageArray[0][0].getD3DFormat();
106441:         DWORD d3dusage = GetTextureUsage(d3dfmt, GL_FRAMEBUFFER_ATTACHMENT_ANGLE, true);
106441: 
106441:         newTexStorage = new TextureStorageCubeMap(levels, d3dfmt, d3dusage, size);
 84925: 
 84925:         if (mTexStorage != NULL)
 47652:         {
 47652:             int levels = levelCount();
 47652:             for (int f = 0; f < 6; f++)
 47652:             {
 47652:                 for (int i = 0; i < levels; i++)
 47652:                 {
 84925:                     IDirect3DSurface9 *source = mTexStorage->getCubeMapSurface(GL_TEXTURE_CUBE_MAP_POSITIVE_X + f, i);
 84925:                     IDirect3DSurface9 *dest = newTexStorage->getCubeMapSurface(GL_TEXTURE_CUBE_MAP_POSITIVE_X + f, i);
 84925: 
 84925:                     if (!copyToRenderTarget(dest, source, mTexStorage->isManaged()))
 84925:                     {
 84925:                        delete newTexStorage;
106441:                        if (source) source->Release();
106441:                        if (dest) dest->Release();
 70456:                        return error(GL_OUT_OF_MEMORY);
 47652:                     }
 77552: 
 82499:                     if (source) source->Release();
 82499:                     if (dest) dest->Release();
 82499:                 }
 82499:             }
 82499:         }
 82499:     }
 82499: 
 84925:     delete mTexStorage;
 84925:     mTexStorage = newTexStorage;
 82499: 
 82499:     mDirtyImages = true;
 47652: }
 47652: 
 70456: void TextureCubeMap::setImage(int faceIndex, GLint level, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint unpackAlignment, const void *pixels)
 47652: {
 82499:     redefineImage(faceIndex, level, format, width, height, type);
 70456: 
 70456:     Texture::setImage(unpackAlignment, pixels, &mImageArray[faceIndex][level]);
 47652: }
 47652: 
 47652: unsigned int TextureCubeMap::faceIndex(GLenum face)
 47652: {
 47652:     META_ASSERT(GL_TEXTURE_CUBE_MAP_NEGATIVE_X - GL_TEXTURE_CUBE_MAP_POSITIVE_X == 1);
 47652:     META_ASSERT(GL_TEXTURE_CUBE_MAP_POSITIVE_Y - GL_TEXTURE_CUBE_MAP_POSITIVE_X == 2);
 47652:     META_ASSERT(GL_TEXTURE_CUBE_MAP_NEGATIVE_Y - GL_TEXTURE_CUBE_MAP_POSITIVE_X == 3);
 47652:     META_ASSERT(GL_TEXTURE_CUBE_MAP_POSITIVE_Z - GL_TEXTURE_CUBE_MAP_POSITIVE_X == 4);
 47652:     META_ASSERT(GL_TEXTURE_CUBE_MAP_NEGATIVE_Z - GL_TEXTURE_CUBE_MAP_POSITIVE_X == 5);
 47652: 
 47652:     return face - GL_TEXTURE_CUBE_MAP_POSITIVE_X;
 47652: }
 47652: 
 82499: void TextureCubeMap::redefineImage(int face, GLint level, GLenum format, GLsizei width, GLsizei height, GLenum type)
 82499: {
 82499:     bool redefined = mImageArray[face][level].redefine(format, width, height, type, false);
 82499: 
 84925:     if (mTexStorage && redefined)
 47652:     {
 58582:         for (int i = 0; i < IMPLEMENTATION_MAX_TEXTURE_LEVELS; i++)
 47652:         {
 47652:             for (int f = 0; f < 6; f++)
 47652:             {
 82499:                 mImageArray[f][i].markDirty();
 82499:             }
 82499:         }
 82499: 
 84925:         delete mTexStorage;
 84925:         mTexStorage = NULL;
 82499: 
 82499:         mDirtyImages = true;
 47652:     }
 47652: }
 47652: 
 70456: void TextureCubeMap::copyImage(GLenum target, GLint level, GLenum format, GLint x, GLint y, GLsizei width, GLsizei height, Framebuffer *source)
 47652: {
 58582:     IDirect3DSurface9 *renderTarget = source->getRenderTarget();
 47652: 
 58582:     if (!renderTarget)
 58582:     {
 58582:         ERR("Failed to retrieve the render target.");
 58582:         return error(GL_OUT_OF_MEMORY);
 58582:     }
 58582: 
 58582:     unsigned int faceindex = faceIndex(target);
 82499:     redefineImage(faceindex, level, format, width, height, GL_UNSIGNED_BYTE);
 70456: 
 86498:     if (!mImageArray[faceindex][level].isRenderableFormat())
 58582:     {
 82499:         mImageArray[faceindex][level].copy(0, 0, x, y, width, height, renderTarget);
 82499:         mDirtyImages = true;
 58582:     }
 58582:     else
 58582:     {
 86498:         if (!mTexStorage || !mTexStorage->isRenderTarget())
 47652:         {
 47652:             convertToRenderTarget();
 47652:         }
 70456:         
 82499:         mImageArray[faceindex][level].markClean();
 47652: 
 47652:         ASSERT(width == height);
 47652: 
 47652:         if (width > 0 && level < levelCount())
 47652:         {
106441:             RECT sourceRect;
106441:             sourceRect.left = x;
106441:             sourceRect.right = x + width;
106441:             sourceRect.top = y;
106441:             sourceRect.bottom = y + height;
 82499: 
 84925:             IDirect3DSurface9 *dest = mTexStorage->getCubeMapSurface(target, level);
 82499: 
 82499:             if (dest)
 82499:             {
106441:                 getBlitter()->copy(renderTarget, sourceRect, format, 0, 0, dest);
 47652:                 dest->Release();
 47652:             }
 58582:         }
 47652:     }
 47652: 
 82499:     renderTarget->Release();
 47652: }
 47652: 
 61598: void TextureCubeMap::copySubImage(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height, Framebuffer *source)
 47652: {
 82499:     GLsizei size = mImageArray[faceIndex(target)][level].getWidth();
 47652: 
 47652:     if (xoffset + width > size || yoffset + height > size)
 47652:     {
 47652:         return error(GL_INVALID_VALUE);
 47652:     }
 47652: 
 58582:     IDirect3DSurface9 *renderTarget = source->getRenderTarget();
 58582: 
 58582:     if (!renderTarget)
 58582:     {
 58582:         ERR("Failed to retrieve the render target.");
 58582:         return error(GL_OUT_OF_MEMORY);
 58582:     }
 58582: 
 58582:     unsigned int faceindex = faceIndex(target);
 82499: 
 86498:     if (!mImageArray[faceindex][level].isRenderableFormat() || (!mTexStorage && !isSamplerComplete()))
 82499:     {
 82499:         mImageArray[faceindex][level].copy(0, 0, x, y, width, height, renderTarget);
 82499:         mDirtyImages = true;
 58582:     }
 58582:     else
 58582:     {
 86498:         if (!mTexStorage || !mTexStorage->isRenderTarget())
 47652:         {
 47652:             convertToRenderTarget();
 47652:         }
 70456:         
 70456:         updateTexture();
 47652: 
 47652:         if (level < levelCount())
 47652:         {
106441:             RECT sourceRect;
106441:             sourceRect.left = x;
106441:             sourceRect.right = x + width;
106441:             sourceRect.top = y;
106441:             sourceRect.bottom = y + height;
 82499: 
 84925:             IDirect3DSurface9 *dest = mTexStorage->getCubeMapSurface(target, level);
 82499: 
 82499:             if (dest)
 82499:             {
106441:                 getBlitter()->copy(renderTarget, sourceRect, mImageArray[0][0].getFormat(), xoffset, yoffset, dest);
 47652:                 dest->Release();
 47652:             }
 47652:         }
 58582:     }
 47652: 
 82499:     renderTarget->Release();
 82499: }
 82499: 
 82499: void TextureCubeMap::storage(GLsizei levels, GLenum internalformat, GLsizei size)
 82499: {
 82499:     GLenum format = gl::ExtractFormat(internalformat);
 82499:     GLenum type = gl::ExtractType(internalformat);
 84925:     D3DFORMAT d3dfmt = ConvertTextureFormatType(format, type);
106441:     DWORD d3dusage = GetTextureUsage(d3dfmt, mUsage, false);
 84925: 
 84925:     delete mTexStorage;
106441:     mTexStorage = new TextureStorageCubeMap(levels, d3dfmt, d3dusage, size);
 82499:     mImmutable = true;
 82499: 
 84925:     for (int level = 0; level < levels; level++)
 82499:     {
 82499:         for (int face = 0; face < 6; face++)
 82499:         {
 82499:             mImageArray[face][level].redefine(format, size, size, type, true);
 82499:             size = std::max(1, size >> 1);
 82499:         }
 82499:     }
 82499: 
 82499:     for (int level = levels; level < IMPLEMENTATION_MAX_TEXTURE_LEVELS; level++)
 82499:     {
 82499:         for (int face = 0; face < 6; face++)
 82499:         {
 82499:             mImageArray[face][level].redefine(GL_NONE, 0, 0, GL_UNSIGNED_BYTE, true);
 82499:         }
 82499:     }
 84925: 
 84925:     if (mTexStorage->isManaged())
 84925:     {
 84925:         int levels = levelCount();
 84925: 
 84925:         for (int face = 0; face < 6; face++)
 84925:         {
 84925:             for (int level = 0; level < levels; level++)
 84925:             {
 84925:                 IDirect3DSurface9 *surface = mTexStorage->getCubeMapSurface(GL_TEXTURE_CUBE_MAP_POSITIVE_X + face, level);
 84925:                 mImageArray[face][level].setManagedSurface(surface);
 84925:             }
 84925:         }
 84925:     }
 47652: }
 47652: 
 47652: void TextureCubeMap::generateMipmaps()
 47652: {
 71571:     if (!isCubeComplete())
 47652:     {
 47652:         return error(GL_INVALID_OPERATION);
 47652:     }
 47652: 
 71571:     if (!getContext()->supportsNonPower2Texture())
 71571:     {
 82499:         if (!isPow2(mImageArray[0][0].getWidth()))
 71571:         {
 71571:             return error(GL_INVALID_OPERATION);
 71571:         }
 71571:     }
 71571: 
 47652:     // Purge array levels 1 through q and reset them to represent the generated mipmap levels.
 82499:     unsigned int q = log2(mImageArray[0][0].getWidth());
 47652:     for (unsigned int f = 0; f < 6; f++)
 47652:     {
 47652:         for (unsigned int i = 1; i <= q; i++)
 47652:         {
 82499:             redefineImage(f, i, mImageArray[f][0].getFormat(),
 82499:                                 std::max(mImageArray[f][0].getWidth() >> i, 1),
 82499:                                 std::max(mImageArray[f][0].getWidth() >> i, 1),
 82499:                                 mImageArray[f][0].getType());
 82499:         }
 82499:     }
 82499: 
 86498:     if (mTexStorage && mTexStorage->isRenderTarget())
 82499:     {
 47652:         for (unsigned int f = 0; f < 6; f++)
 47652:         {
 47652:             for (unsigned int i = 1; i <= q; i++)
 47652:             {
 84925:                 IDirect3DSurface9 *upper = mTexStorage->getCubeMapSurface(GL_TEXTURE_CUBE_MAP_POSITIVE_X + f, i-1);
 84925:                 IDirect3DSurface9 *lower = mTexStorage->getCubeMapSurface(GL_TEXTURE_CUBE_MAP_POSITIVE_X + f, i);
 47652: 
 47652:                 if (upper != NULL && lower != NULL)
 47652:                 {
 47652:                     getBlitter()->boxFilter(upper, lower);
 47652:                 }
 47652: 
 47652:                 if (upper != NULL) upper->Release();
 47652:                 if (lower != NULL) lower->Release();
 70456: 
 82499:                 mImageArray[f][i].markClean();
 47652:             }
 47652:         }
 47652:     }
 58582:     else
 58582:     {
 58582:         for (unsigned int f = 0; f < 6; f++)
 58582:         {
 58582:             for (unsigned int i = 1; i <= q; i++)
 58582:             {
 82499:                 if (mImageArray[f][i].getSurface() == NULL)
 58582:                 {
 58582:                     return error(GL_OUT_OF_MEMORY);
 58582:                 }
 58582: 
 82499:                 if (FAILED(D3DXLoadSurfaceFromSurface(mImageArray[f][i].getSurface(), NULL, NULL, mImageArray[f][i - 1].getSurface(), NULL, NULL, D3DX_FILTER_BOX, 0)))
 58582:                 {
 58582:                     ERR(" failed to load filter %d to %d.", i - 1, i);
 58582:                 }
 58582: 
 82499:                 mImageArray[f][i].markDirty();
 58582:             }
 58582:         }
 58582:     }
 58582: }
 47652: 
 70456: Renderbuffer *TextureCubeMap::getRenderbuffer(GLenum target)
 47652: {
 47652:     if (!IsCubemapTextureTarget(target))
 47652:     {
 48434:         return error(GL_INVALID_OPERATION, (Renderbuffer *)NULL);
 47652:     }
 47652: 
 47652:     unsigned int face = faceIndex(target);
 47652: 
 88310:     if (mFaceProxies[face] == NULL)
 88310:     {
106441:         mFaceProxies[face] = new Renderbuffer(id(), new RenderbufferTextureCubeMap(this, target));
 88310:     }
 88310: 
 88310:     return mFaceProxies[face];
 47652: }
 47652: 
106441: // Increments refcount on surface.
106441: // caller must Release() the returned surface
 47652: IDirect3DSurface9 *TextureCubeMap::getRenderTarget(GLenum target)
 47652: {
 47652:     ASSERT(IsCubemapTextureTarget(target));
 47652: 
 86498:     // ensure the underlying texture is created
 86498:     if (getStorage(true) == NULL)
 86498:     {
 86498:         return NULL;
 86498:     }
 86498: 
 86498:     updateTexture();
 86498:     
 86498:     return mTexStorage->getCubeMapSurface(target, 0);
 86498: }
 86498: 
 86498: TextureStorage *TextureCubeMap::getStorage(bool renderTarget)
 86498: {
 86498:     if (!mTexStorage || (renderTarget && !mTexStorage->isRenderTarget()))
 86498:     {
 86498:         if (renderTarget)
 70456:         {
 70456:             convertToRenderTarget();
 70456:         }
 86498:         else
 86498:         {
 86498:             createTexture();
 86498:         }
 86498:     }
 86498: 
 84925:     return mTexStorage;
 82499: }
 82499: 
106441: }
