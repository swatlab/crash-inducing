    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is TransforMiiX XSLT processor code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Jonas Sicking.
    1:  * Portions created by the Initial Developer are Copyright (C) 2002
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Jonas Sicking <sicking@bigfoot.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "txXSLTNumber.h"
    1: #include "nsReadableUtils.h"
    1: #include "txCore.h"
    1: 
    1: class txDecimalCounter : public txFormattedCounter {
    1: public:
    1:     txDecimalCounter() : mMinLength(1), mGroupSize(50)
    1:     {
    1:     }
    1:     
    1:     txDecimalCounter(PRInt32 aMinLength, PRInt32 aGroupSize,
    1:                      const nsAString& mGroupSeparator);
    1:     
    1:     virtual void appendNumber(PRInt32 aNumber, nsAString& aDest);
    1: 
    1: private:
    1:     PRInt32 mMinLength;
    1:     PRInt32 mGroupSize;
    1:     nsString mGroupSeparator;
    1: };
    1: 
    1: class txAlphaCounter : public txFormattedCounter {
    1: public:
    1:     txAlphaCounter(PRUnichar aOffset) : mOffset(aOffset)
    1:     {
    1:     }
    1: 
    1:     virtual void appendNumber(PRInt32 aNumber, nsAString& aDest);
    1:     
    1: private:
    1:     PRUnichar mOffset;
    1: };
    1: 
    1: class txRomanCounter : public txFormattedCounter {
    1: public:
    1:     txRomanCounter(MBool aUpper) : mTableOffset(aUpper ? 30 : 0)
    1:     {
    1:     }
    1: 
    1:     void appendNumber(PRInt32 aNumber, nsAString& aDest);
    1: 
    1: private:
    1:     PRInt32 mTableOffset;
    1: };
    1: 
    1: 
    1: nsresult
    1: txFormattedCounter::getCounterFor(const nsAFlatString& aToken,
    1:                                   PRInt32 aGroupSize,
    1:                                   const nsAString& aGroupSeparator,
    1:                                   txFormattedCounter*& aCounter)
    1: {
    1:     PRInt32 length = aToken.Length();
    1:     NS_ASSERTION(length, "getting counter for empty token");
    1:     aCounter = 0;
    1:     
    1:     if (length == 1) {
    1:         PRUnichar ch = aToken.CharAt(0);
    1:         switch (ch) {
    1: 
    1:             case 'i':
    1:             case 'I':
    1:                 aCounter = new txRomanCounter(ch == 'I');
    1:                 break;
    1:             
    1:             case 'a':
    1:             case 'A':
    1:                 aCounter = new txAlphaCounter(ch);
    1:                 break;
    1:             
    1:             case '1':
    1:             default:
    1:                 // if we don't recognize the token then use "1"
    1:                 aCounter = new txDecimalCounter(1, aGroupSize,
    1:                                                 aGroupSeparator);
    1:                 break;
    1:         }
    1:         return aCounter ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:     
    1:     // for now, the only multi-char token we support are decimals
    1:     PRInt32 i;
    1:     for (i = 0; i < length-1; ++i) {
    1:         if (aToken.CharAt(i) != '0')
    1:             break;
    1:     }
    1:     if (i == length-1 && aToken.CharAt(i) == '1') {
    1:         aCounter = new txDecimalCounter(length, aGroupSize, aGroupSeparator);
    1:     }
    1:     else {
    1:         // if we don't recognize the token then use '1'
    1:         aCounter = new txDecimalCounter(1, aGroupSize, aGroupSeparator);
    1:     }
    1: 
    1:     return aCounter ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
    1: }
    1: 
    1: 
    1: txDecimalCounter::txDecimalCounter(PRInt32 aMinLength, PRInt32 aGroupSize,
    1:                                    const nsAString& aGroupSeparator)
    1:     : mMinLength(aMinLength), mGroupSize(aGroupSize),
    1:       mGroupSeparator(aGroupSeparator)
    1: {
    1:     if (mGroupSize <= 0) {
    1:         mGroupSize = aMinLength + 10;
    1:     }
    1: }
    1: 
    1: void txDecimalCounter::appendNumber(PRInt32 aNumber, nsAString& aDest)
    1: {
    1:     const PRInt32 bufsize = 10; //must be able to fit an PRInt32
    1:     PRUnichar buf[bufsize];
    1:     PRInt32 pos = bufsize;
    1:     while (aNumber > 0) {
    1:         PRInt32 ch = aNumber % 10;
    1:         aNumber /= 10;
    1:         buf[--pos] = ch + '0';
    1:     }
    1: 
    1:     // in case we didn't get a long enough string
    1:     PRInt32 end  = (bufsize > mMinLength) ? bufsize - mMinLength : 0;
    1:     while (pos > end) {
    1:         buf[--pos] = '0';
    1:     }
    1:     
    1:     // in case we *still* didn't get a long enough string.
    1:     // this should be very rare since it only happens if mMinLength is bigger
    1:     // then the length of any PRInt32.
    1:     // pos will always be zero 
    1:     PRInt32 extraPos = mMinLength;
    1:     while (extraPos > bufsize) {
    1:         aDest.Append(PRUnichar('0'));
    1:         --extraPos;
    1:         if (extraPos % mGroupSize == 0) {
    1:             aDest.Append(mGroupSeparator);
    1:         }
    1:     }
    1: 
    1:     // copy string to buffer
    1:     if (mGroupSize >= bufsize - pos) {
    1:         // no grouping will occur
    1:         aDest.Append(buf + pos, (PRUint32)(bufsize - pos));
    1:     }
    1:     else {
    1:         // append chars up to first grouping separator
    1:         PRInt32 len = ((bufsize - pos - 1) % mGroupSize) + 1;
    1:         aDest.Append(buf + pos, len);
    1:         pos += len;
    1:         while (bufsize - pos > 0) {
    1:             aDest.Append(mGroupSeparator);
    1:             aDest.Append(buf + pos, mGroupSize);
    1:             pos += mGroupSize;
    1:         }
    1:         NS_ASSERTION(bufsize == pos, "error while grouping");
    1:     }
    1: }
    1: 
    1: 
    1: void txAlphaCounter::appendNumber(PRInt32 aNumber, nsAString& aDest)
    1: {
    1:     PRUnichar buf[12];
    1:     buf[11] = 0;
    1:     PRInt32 pos = 11;
    1:     while (aNumber > 0) {
    1:         --aNumber;
    1:         PRInt32 ch = aNumber % 26;
    1:         aNumber /= 26;
    1:         buf[--pos] = ch + mOffset;
    1:     }
    1:     
    1:     aDest.Append(buf + pos, (PRUint32)(11 - pos));
    1: }
    1: 
    1: 
    1: const char* const kTxRomanNumbers[] =
    1:     {"", "c", "cc", "ccc", "cd", "d", "dc", "dcc", "dccc", "cm",
    1:      "", "x", "xx", "xxx", "xl", "l", "lx", "lxx", "lxxx", "xc",
    1:      "", "i", "ii", "iii", "iv", "v", "vi", "vii", "viii", "ix",
    1:      "", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM",
    1:      "", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC",
    1:      "", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"};
    1: 
    1: void txRomanCounter::appendNumber(PRInt32 aNumber, nsAString& aDest)
    1: {
38311:     // Numbers bigger then 3999 and negative numbers can't be done in roman
38311:     if (PRUint32(aNumber) >= 4000) {
    1:         txDecimalCounter().appendNumber(aNumber, aDest);
    1:         return;
    1:     }
    1: 
    1:     while (aNumber >= 1000) {
    1:         aDest.Append(!mTableOffset ? PRUnichar('m') : PRUnichar('M'));
    1:         aNumber -= 1000;
    1:     }
    1: 
    1:     PRInt32 posValue;
    1:     
    1:     // Hundreds
    1:     posValue = aNumber / 100;
    1:     aNumber %= 100;
    1:     AppendASCIItoUTF16(kTxRomanNumbers[posValue + mTableOffset], aDest);
    1:     // Tens
    1:     posValue = aNumber / 10;
    1:     aNumber %= 10;
    1:     AppendASCIItoUTF16(kTxRomanNumbers[10 + posValue + mTableOffset], aDest);
    1:     // Ones
    1:     AppendASCIItoUTF16(kTxRomanNumbers[20 + aNumber + mTableOffset], aDest);
    1: }
