    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
27664: /* vim: set ts=2 sw=2 et tw=79: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * Base class for all element classes; this provides an implementation
    1:  * of DOM Core's nsIDOMElement, implements nsIContent, provides
    1:  * utility methods for subclasses, and so forth.
    1:  */
    1: 
    1: #include "nsGenericElement.h"
    1: 
    1: #include "nsDOMAttribute.h"
    1: #include "nsDOMAttributeMap.h"
    1: #include "nsIAtom.h"
    1: #include "nsINodeInfo.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMText.h"
    1: #include "nsIContentIterator.h"
    1: #include "nsIEventListenerManager.h"
29018: #include "nsFocusManager.h"
    1: #include "nsILinkHandler.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIURL.h"
    1: #include "nsNetUtil.h"
    1: #include "nsIFrame.h"
38069: #include "nsIAnonymousContentCreator.h"
    1: #include "nsIPresShell.h"
    1: #include "nsPresContext.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsString.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsIEventStateManager.h"
    1: #include "nsIDOMEvent.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "nsDOMCID.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIDOMCSSStyleDeclaration.h"
32193: #include "nsCSSDeclaration.h"
    1: #include "nsDOMCSSDeclaration.h"
32193: #include "nsDOMCSSAttrDeclaration.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsContentList.h"
31383: #include "nsDOMTokenList.h"
    1: #include "nsDOMError.h"
    1: #include "nsDOMString.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsIDOMMutationEvent.h"
    1: #include "nsMutationEvent.h"
    1: #include "nsNodeUtils.h"
    1: #include "nsDocument.h"
 3244: #ifdef MOZ_XUL
 1498: #include "nsXULElement.h"
 3244: #endif /* MOZ_XUL */
 6186: #include "nsFrameManager.h"
11914: #include "nsFrameSelection.h"
    1: 
    1: #include "nsBindingManager.h"
    1: #include "nsXBLBinding.h"
    1: #include "nsIDOMCSSStyleDeclaration.h"
    1: #include "nsIDOMViewCSS.h"
    1: #include "nsIXBLService.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIBoxObject.h"
    1: #include "nsPIBoxObject.h"
    1: #include "nsIDOMNSDocument.h"
    1: #include "nsIDOMNSElement.h"
12913: #include "nsClientRect.h"
 2014: #ifdef MOZ_SVG
 2014: #include "nsSVGUtils.h"
 2014: #endif
 2014: #include "nsLayoutUtils.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsContentUtils.h"
    1: #include "nsIJSContextStack.h"
    1: 
    1: #include "nsIServiceManager.h"
    1: #include "nsIDOMEventListener.h"
    1: 
    1: #include "nsIWebNavigation.h"
    1: #include "nsIBaseWindow.h"
    1: 
    1: #include "jsapi.h"
    1: 
    1: #include "nsNodeInfoManager.h"
    1: #include "nsICategoryManager.h"
    1: #include "nsIDOMNSFeatureFactory.h"
    1: #include "nsIDOMDocumentType.h"
    1: #include "nsIDOMUserDataHandler.h"
24836: #include "nsGenericHTMLElement.h"
11914: #include "nsIEditor.h"
41886: #include "nsIEditorIMESupport.h"
11914: #include "nsIEditorDocShell.h"
    1: #include "nsEventDispatcher.h"
    1: #include "nsContentCreatorFunctions.h"
    1: #include "nsIControllers.h"
16722: #include "nsLayoutUtils.h"
16722: #include "nsIView.h"
16722: #include "nsIViewManager.h"
16722: #include "nsIScrollableFrame.h"
 1685: #include "nsXBLInsertionPoint.h"
16106: #include "nsICSSStyleRule.h" /* For nsCSSSelectorList */
16106: #include "nsCSSRuleProcessor.h"
30988: #include "nsRuleProcessorData.h"
16106: 
 3244: #ifdef MOZ_XUL
 1839: #include "nsIXULDocument.h"
 3244: #endif /* MOZ_XUL */
    1: 
 5395: #ifdef ACCESSIBILITY
 5395: #include "nsIAccessibilityService.h"
 5395: #include "nsIAccessibleEvent.h"
 5395: #endif /* ACCESSIBILITY */
 5395: 
    1: #include "nsCycleCollectionParticipant.h"
 1353: #include "nsCCUncollectableMarker.h"
    1: 
14228: #include "mozAutoDocUpdate.h"
14228: 
38849: #include "nsCSSParser.h"
41901: #include "nsTPtrArray.h"
18845: 
    1: #ifdef MOZ_SVG
28081: #include "nsSVGFeatures.h"
    1: #endif /* MOZ_SVG */
    1: 
41634: using namespace mozilla::dom;
    1: 
21218: NS_DEFINE_IID(kThisPtrOffsetsSID, NS_THISPTROFFSETS_SID);
21218: 
    1: PRInt32 nsIContent::sTabFocusModel = eTabFocus_any;
    1: PRBool nsIContent::sTabFocusModelAppliesToXUL = PR_FALSE;
27150: PRUint32 nsMutationGuard::sMutationCount = 0;
27150: 
    1: nsresult NS_NewContentIterator(nsIContentIterator** aInstancePtrResult);
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsINode::nsSlots::~nsSlots()
    1: {
    1:   if (mChildNodes) {
    1:     mChildNodes->DropReference();
    1:     NS_RELEASE(mChildNodes);
    1:   }
    1: 
    1:   if (mWeakReference) {
    1:     mWeakReference->NoticeNodeDestruction();
    1:   }
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsINode::~nsINode()
    1: {
    1:   NS_ASSERTION(!HasSlots(), "nsNodeUtils::LastRelease was not called?");
    1: }
    1: 
    1: void*
    1: nsINode::GetProperty(PRUint16 aCategory, nsIAtom *aPropertyName,
    1:                      nsresult *aStatus) const
    1: {
    1:   nsIDocument *doc = GetOwnerDoc();
    1:   if (!doc)
    1:     return nsnull;
    1: 
41182:   return doc->PropertyTable(aCategory)->GetProperty(this, aPropertyName,
    1:                                                     aStatus);
    1: }
    1: 
    1: nsresult
    1: nsINode::SetProperty(PRUint16 aCategory, nsIAtom *aPropertyName, void *aValue,
    1:                      NSPropertyDtorFunc aDtor, PRBool aTransfer,
    1:                      void **aOldValue)
    1: {
    1:   nsIDocument *doc = GetOwnerDoc();
    1:   if (!doc)
    1:     return NS_ERROR_FAILURE;
    1: 
41182:   nsresult rv = doc->PropertyTable(aCategory)->SetProperty(this,
    1:                                                            aPropertyName, aValue, aDtor,
    1:                                                            nsnull, aTransfer, aOldValue);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     SetFlags(NODE_HAS_PROPERTIES);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsINode::DeleteProperty(PRUint16 aCategory, nsIAtom *aPropertyName)
    1: {
    1:   nsIDocument *doc = GetOwnerDoc();
    1:   if (!doc)
    1:     return nsnull;
    1: 
41182:   return doc->PropertyTable(aCategory)->DeleteProperty(this, aPropertyName);
    1: }
    1: 
    1: void*
    1: nsINode::UnsetProperty(PRUint16 aCategory, nsIAtom *aPropertyName,
    1:                        nsresult *aStatus)
    1: {
    1:   nsIDocument *doc = GetOwnerDoc();
    1:   if (!doc)
    1:     return nsnull;
    1: 
41182:   return doc->PropertyTable(aCategory)->UnsetProperty(this, aPropertyName,
    1:                                                       aStatus);
    1: }
    1: 
29474: nsIEventListenerManager*
29474: nsGenericElement::GetListenerManager(PRBool aCreateIfNotFound)
29474: {
29474:   return nsContentUtils::GetListenerManager(this, aCreateIfNotFound);
    1: }
    1: 
 1418: nsresult
 1418: nsGenericElement::AddEventListenerByIID(nsIDOMEventListener *aListener,
 1418:                                        const nsIID& aIID)
 1418: {
29474:   nsIEventListenerManager* elm = GetListenerManager(PR_TRUE);
29474:   NS_ENSURE_STATE(elm);
 1418:   return elm->AddEventListenerByIID(aListener, aIID, NS_EVENT_FLAG_BUBBLE);
 1418: }
 1418: 
 1418: nsresult
 1418: nsGenericElement::RemoveEventListenerByIID(nsIDOMEventListener *aListener,
 1418:                                            const nsIID& aIID)
 1418: {
29474:   nsIEventListenerManager* elm = GetListenerManager(PR_FALSE);
29474:   return elm ?
29474:     elm->RemoveEventListenerByIID(aListener, aIID, NS_EVENT_FLAG_BUBBLE) :
29474:     NS_OK;
 1418: }
 1418: 
 1418: nsresult
 1418: nsGenericElement::GetSystemEventGroup(nsIDOMEventGroup** aGroup)
 1418: {
29474:   nsIEventListenerManager* elm = GetListenerManager(PR_TRUE);
29474:   NS_ENSURE_STATE(elm);
 1418:   return elm->GetSystemEventGroupLM(aGroup);
 1418: }
 1418: 
    1: nsINode::nsSlots*
    1: nsINode::CreateSlots()
    1: {
11169:   return new nsSlots(mFlagsOrSlots);
    1: }
    1: 
 3333: PRBool
 3333: nsINode::IsEditableInternal() const
 3333: {
 3333:   if (HasFlag(NODE_IS_EDITABLE)) {
 3333:     // The node is in an editable contentEditable subtree.
 3333:     return PR_TRUE;
 3333:   }
 3333: 
 3333:   nsIDocument *doc = GetCurrentDoc();
 3333: 
 3333:   // Check if the node is in a document and the document is in designMode.
 3333:   return doc && doc->HasFlag(NODE_IS_EDITABLE);
 3333: }
 3333: 
11914: static nsIContent* GetEditorRootContent(nsIEditor* aEditor)
11914: {
11914:   nsCOMPtr<nsIDOMElement> rootElement;
11914:   aEditor->GetRootElement(getter_AddRefs(rootElement));
11914:   nsCOMPtr<nsIContent> rootContent(do_QueryInterface(rootElement));
11914:   return rootContent;
11914: }
11914: 
11914: nsIContent*
11914: nsINode::GetTextEditorRootContent(nsIEditor** aEditor)
11914: {
11914:   if (aEditor)
11914:     *aEditor = nsnull;
11914:   for (nsINode* node = this; node; node = node->GetNodeParent()) {
41636:     if (!node->IsElement() ||
41636:         !node->AsElement()->IsHTML())
11914:       continue;
11914: 
11914:     nsCOMPtr<nsIEditor> editor;
24836:     static_cast<nsGenericHTMLElement*>(node)->
24836:         GetEditorInternal(getter_AddRefs(editor));
24836:     if (!editor)
24836:       continue;
24836: 
11914:     nsIContent* rootContent = GetEditorRootContent(editor);
11914:     if (aEditor)
11914:       editor.swap(*aEditor);
11914:     return rootContent;
11914:   }
11914:   return nsnull;
11914: }
11914: 
11914: static nsIEditor* GetHTMLEditor(nsPresContext* aPresContext)
11914: {
11914:   nsCOMPtr<nsISupports> container = aPresContext->GetContainer();
11914:   nsCOMPtr<nsIEditorDocShell> editorDocShell(do_QueryInterface(container));
11914:   PRBool isEditable;
11914:   if (!editorDocShell ||
11914:       NS_FAILED(editorDocShell->GetEditable(&isEditable)) || !isEditable)
11914:     return nsnull;
11914: 
11914:   nsCOMPtr<nsIEditor> editor;
11914:   editorDocShell->GetEditor(getter_AddRefs(editor));
11914:   return editor;
11914: }
11914: 
35608: static nsIContent* GetRootForContentSubtree(nsIContent* aContent)
35608: {
35608:   NS_ENSURE_TRUE(aContent, nsnull);
35608:   nsIContent* stop = aContent->GetBindingParent();
35608:   while (aContent) {
35608:     nsIContent* parent = aContent->GetParent();
35608:     if (parent == stop) {
35608:       break;
35608:     }
35608:     aContent = parent;
35608:   }
35608:   return aContent;
35608: }
35608: 
11914: nsIContent*
11914: nsINode::GetSelectionRootContent(nsIPresShell* aPresShell)
11914: {
11914:   NS_ENSURE_TRUE(aPresShell, nsnull);
11914: 
11914:   if (IsNodeOfType(eDOCUMENT))
41634:     return static_cast<nsIDocument*>(this)->GetRootElement();
11914:   if (!IsNodeOfType(eCONTENT))
11914:     return nsnull;
11914: 
37336:   if (GetCurrentDoc() != aPresShell->GetDocument()) {
37336:     return nsnull;
37336:   }
36945: 
36655:   nsIFrame* frame = static_cast<nsIContent*>(this)->GetPrimaryFrame();
11914:   if (frame && frame->GetStateBits() & NS_FRAME_INDEPENDENT_SELECTION) {
11914:     // This node should be a descendant of input/textarea editor.
11914:     nsIContent* content = GetTextEditorRootContent();
11914:     if (content)
11914:       return content;
11914:   }
11914: 
11914:   nsPresContext* presContext = aPresShell->GetPresContext();
11914:   if (presContext) {
11914:     nsIEditor* editor = GetHTMLEditor(presContext);
11914:     if (editor) {
11914:       // This node is in HTML editor.
11914:       nsIDocument* doc = GetCurrentDoc();
35608:       if (!doc || doc->HasFlag(NODE_IS_EDITABLE) ||
35608:           !HasFlag(NODE_IS_EDITABLE)) {
35608:         nsIContent* editorRoot = GetEditorRootContent(editor);
36323:         NS_ENSURE_TRUE(editorRoot, nsnull);
35608:         return nsContentUtils::IsInSameAnonymousTree(this, editorRoot) ?
35608:                  editorRoot :
35608:                  GetRootForContentSubtree(static_cast<nsIContent*>(this));
35608:       }
11914:       // If the current document is not editable, but current content is
11914:       // editable, we should assume that the child of the nearest non-editable
11914:       // ancestor is selection root.
11914:       nsIContent* content = static_cast<nsIContent*>(this);
11914:       for (nsIContent* parent = GetParent();
11914:            parent && parent->HasFlag(NODE_IS_EDITABLE);
11914:            parent = content->GetParent())
11914:         content = parent;
11914:       return content;
11914:     }
11914:   }
11914: 
11914:   nsCOMPtr<nsFrameSelection> fs = aPresShell->FrameSelection();
11914:   nsIContent* content = fs->GetLimiter();
35608:   if (!content) {
11914:     content = fs->GetAncestorLimiter();
35608:     if (!content) {
11914:       nsIDocument* doc = aPresShell->GetDocument();
11914:       NS_ENSURE_TRUE(doc, nsnull);
41634:       content = doc->GetRootElement();
35608:       if (!content)
35608:         return nsnull;
35608:     }
35608:   }
35608: 
35608:   // This node might be in another subtree, if so, we should find this subtree's
35608:   // root.  Otherwise, we can return the content simply.
36323:   NS_ENSURE_TRUE(content, nsnull);
35608:   return nsContentUtils::IsInSameAnonymousTree(this, content) ?
35608:            content : GetRootForContentSubtree(static_cast<nsIContent*>(this));
11914: }
11914: 
24403: nsINodeList*
23258: nsINode::GetChildNodesList()
23258: {
23258:   nsSlots *slots = GetSlots();
23258:   if (!slots) {
23258:     return nsnull;
23258:   }
23258: 
23258:   if (!slots->mChildNodes) {
23258:     slots->mChildNodes = new nsChildContentList(this);
23258:     if (slots->mChildNodes) {
23258:       NS_ADDREF(slots->mChildNodes);
23258:     }
23258:   }
23258: 
23258:   return slots->mChildNodes;
23258: }
23258: 
27664: #ifdef DEBUG
27664: void
27664: nsINode::CheckNotNativeAnonymous() const
27664: {
27664:   if (!IsNodeOfType(eCONTENT))
27664:     return;
27664:   nsIContent* content = static_cast<const nsIContent *>(this)->GetBindingParent();
27664:   while (content) {
27664:     if (content->IsRootOfNativeAnonymousSubtree()) {
27664:       NS_ERROR("Element not marked to be in native anonymous subtree!");
27664:       break;
27664:     }
27664:     content = content->GetBindingParent();
27664:   }
27664: }
27664: #endif
27664: 
23258: nsresult
23258: nsINode::GetParentNode(nsIDOMNode** aParentNode)
23258: {
23258:   *aParentNode = nsnull;
23258: 
23258:   nsINode *parent = GetNodeParent();
23258: 
23258:   return parent ? CallQueryInterface(parent, aParentNode) : NS_OK;
23258: }
23258: 
23258: nsresult
23258: nsINode::GetChildNodes(nsIDOMNodeList** aChildNodes)
23258: {
23258:   *aChildNodes = GetChildNodesList();
23258:   if (!*aChildNodes) {
23258:     return NS_ERROR_OUT_OF_MEMORY;
23258:   }
23258: 
23258:   NS_ADDREF(*aChildNodes);
23258: 
23258:   return NS_OK;
23258: }
23258: 
23258: nsresult
23258: nsINode::GetFirstChild(nsIDOMNode** aNode)
23258: {
23258:   nsIContent* child = GetChildAt(0);
23258:   if (child) {
23258:     return CallQueryInterface(child, aNode);
23258:   }
23258: 
23258:   *aNode = nsnull;
23258: 
23258:   return NS_OK;
23258: }
23258: 
23258: nsresult
23258: nsINode::GetLastChild(nsIDOMNode** aNode)
23258: {
23258:   nsIContent* child = GetLastChild();
23258:   if (child) {
23258:     return CallQueryInterface(child, aNode);
23258:   }
23258: 
23258:   *aNode = nsnull;
23258: 
23258:   return NS_OK;
23258: }
23258: 
23258: nsresult
23258: nsINode::GetPreviousSibling(nsIDOMNode** aPrevSibling)
23258: {
23258:   *aPrevSibling = nsnull;
23258: 
23258:   nsIContent *sibling = GetSibling(-1);
23258: 
23258:   return sibling ? CallQueryInterface(sibling, aPrevSibling) : NS_OK;
23258: }
23258: 
23258: nsresult
23258: nsINode::GetNextSibling(nsIDOMNode** aNextSibling)
23258: {
23258:   *aNextSibling = nsnull;
23258: 
23258:   nsIContent *sibling = GetSibling(1);
23258: 
23258:   return sibling ? CallQueryInterface(sibling, aNextSibling) : NS_OK;
23258: }
23258: 
23258: nsresult
23258: nsINode::GetOwnerDocument(nsIDOMDocument** aOwnerDocument)
23258: {
23258:   *aOwnerDocument = nsnull;
23258: 
23258:   nsIDocument *ownerDoc = GetOwnerDocument();
23258: 
23258:   return ownerDoc ? CallQueryInterface(ownerDoc, aOwnerDocument) : NS_OK;
23258: }
23258: 
39585: nsresult
39585: nsINode::ReplaceOrInsertBefore(PRBool aReplace, nsIDOMNode* aNewChild,
39585:                                nsIDOMNode* aRefChild, nsIDOMNode** aReturn)
39585: {
39585:   nsCOMPtr<nsINode> newChild = do_QueryInterface(aNewChild);
39585: 
39585:   nsresult rv;
39585:   nsCOMPtr<nsINode> refChild;
39585:   if (aRefChild) {
39585:       refChild = do_QueryInterface(aRefChild, &rv);
39585:       NS_ENSURE_SUCCESS(rv, rv);
39585:   }
39585: 
39585:   rv = ReplaceOrInsertBefore(aReplace, newChild, refChild);
39585:   if (NS_SUCCEEDED(rv)) {
39585:     NS_ADDREF(*aReturn = aReplace ? aRefChild : aNewChild);
39585:   }
39585: 
39585:   return rv;
39585: }
39585: 
39585: nsresult
39585: nsINode::RemoveChild(nsIDOMNode* aOldChild, nsIDOMNode** aReturn)
39585: {
39585:   nsCOMPtr<nsIContent> oldChild = do_QueryInterface(aOldChild);
39585:   nsresult rv = RemoveChild(oldChild);
39585:   if (NS_SUCCEEDED(rv)) {
39585:     NS_ADDREF(*aReturn = aOldChild);
39585:   }
39585:   return rv;
39585: }
39585: 
41900: void
41900: nsINode::GetBaseURI(nsAString &aURI) const
41900: {
41900:   nsCOMPtr<nsIURI> baseURI = GetBaseURI();
41900: 
41900:   nsCAutoString spec;
41900:   if (baseURI) {
41900:     baseURI->GetSpec(spec);
41900:   }
41900: 
41900:   CopyUTF8toUTF16(spec, aURI);
41900: }
41900: 
41904: void
41904: nsINode::LookupPrefix(const nsAString& aNamespaceURI, nsAString& aPrefix)
41904: {
41904:   Element *element = GetNameSpaceElement();
41904:   nsIAtom *prefix = element ? element->LookupPrefix(aNamespaceURI) : nsnull;
41904:   if (prefix) {
41904:     prefix->ToString(aPrefix);
41904:   }
41904:   else {
41904:     SetDOMStringToNull(aPrefix);
41904:   }
41904: }
41904: 
41901: static nsresult
41901: SetUserDataProperty(PRUint16 aCategory, nsINode *aNode, nsIAtom *aKey,
41901:                     nsISupports* aValue, void** aOldValue)
41901: {
41901:   nsresult rv = aNode->SetProperty(aCategory, aKey, aValue,
41901:                                    nsPropertyTable::SupportsDtorFunc, PR_TRUE,
41901:                                    aOldValue);
41901:   NS_ENSURE_SUCCESS(rv, rv);
41901: 
41901:   // Property table owns it now.
41901:   NS_ADDREF(aValue);
41901: 
41901:   return NS_OK;
41901: }
41901: 
41901: nsresult
41902: nsINode::SetUserData(const nsAString &aKey, nsIVariant *aData,
41902:                      nsIDOMUserDataHandler *aHandler, nsIVariant **aResult)
41901: {
41901:   *aResult = nsnull;
41901: 
41901:   nsCOMPtr<nsIAtom> key = do_GetAtom(aKey);
41901:   if (!key) {
41901:     return NS_ERROR_OUT_OF_MEMORY;
41901:   }
41901: 
41901:   nsresult rv;
41901:   void *data;
41901:   if (aData) {
41902:     rv = SetUserDataProperty(DOM_USER_DATA, this, key, aData, &data);
41901:     NS_ENSURE_SUCCESS(rv, rv);
41901:   }
41901:   else {
41902:     data = UnsetProperty(DOM_USER_DATA, key);
41901:   }
41901: 
41901:   // Take over ownership of the old data from the property table.
41901:   nsCOMPtr<nsIVariant> oldData = dont_AddRef(static_cast<nsIVariant*>(data));
41901: 
41901:   if (aData && aHandler) {
41901:     nsCOMPtr<nsIDOMUserDataHandler> oldHandler;
41902:     rv = SetUserDataProperty(DOM_USER_DATA_HANDLER, this, key, aHandler,
41901:                              getter_AddRefs(oldHandler));
41901:     if (NS_FAILED(rv)) {
41901:       // We failed to set the handler, remove the data.
41902:       DeleteProperty(DOM_USER_DATA, key);
41901: 
41901:       return rv;
41901:     }
41901:   }
41901:   else {
41902:     DeleteProperty(DOM_USER_DATA_HANDLER, key);
41901:   }
41901: 
41901:   oldData.swap(*aResult);
41901: 
41901:   return NS_OK;
41901: }
41901: 
41901: PRUint16
41906: nsINode::CompareDocumentPosition(nsINode* aOtherNode)
41906: {
41906:   NS_PRECONDITION(aOtherNode, "don't pass null");
41906: 
41906:   if (this == aOtherNode) {
41901:     return 0;
41901:   }
41901: 
41901:   nsAutoTPtrArray<nsINode, 32> parents1, parents2;
41901: 
41906:   nsINode *node1 = aOtherNode, *node2 = this;
41906: 
41901:   // Check if either node is an attribute
41901:   nsIAttribute* attr1 = nsnull;
41906:   if (node1->IsNodeOfType(nsINode::eATTRIBUTE)) {
41906:     attr1 = static_cast<nsIAttribute*>(node1);
41901:     nsIContent* elem = attr1->GetContent();
41901:     // If there is an owner element add the attribute
41901:     // to the chain and walk up to the element
41901:     if (elem) {
41906:       node1 = elem;
41901:       parents1.AppendElement(static_cast<nsINode*>(attr1));
41901:     }
41901:   }
41906:   if (node2->IsNodeOfType(nsINode::eATTRIBUTE)) {
41906:     nsIAttribute* attr2 = static_cast<nsIAttribute*>(node2);
41901:     nsIContent* elem = attr2->GetContent();
41906:     if (elem == node1 && attr1) {
41901:       // Both nodes are attributes on the same element.
41901:       // Compare position between the attributes.
41901: 
41901:       PRUint32 i;
41901:       const nsAttrName* attrName;
41901:       for (i = 0; (attrName = elem->GetAttrNameAt(i)); ++i) {
41901:         if (attrName->Equals(attr1->NodeInfo())) {
41901:           NS_ASSERTION(!attrName->Equals(attr2->NodeInfo()),
41901:                        "Different attrs at same position");
41901:           return nsIDOM3Node::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |
41901:             nsIDOM3Node::DOCUMENT_POSITION_PRECEDING;
41901:         }
41901:         if (attrName->Equals(attr2->NodeInfo())) {
41901:           return nsIDOM3Node::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |
41901:             nsIDOM3Node::DOCUMENT_POSITION_FOLLOWING;
41901:         }
41901:       }
41901:       NS_NOTREACHED("neither attribute in the element");
41901:       return nsIDOM3Node::DOCUMENT_POSITION_DISCONNECTED;
41901:     }
41901: 
41901:     if (elem) {
41906:       node2 = elem;
41901:       parents2.AppendElement(static_cast<nsINode*>(attr2));
41901:     }
41901:   }
41901: 
41901:   // We now know that both nodes are either nsIContents or nsIDocuments.
41901:   // If either node started out as an attribute, that attribute will have
41901:   // the same relative position as its ownerElement, except if the
41901:   // ownerElement ends up being the container for the other node
41901: 
41901:   // Build the chain of parents
41901:   do {
41906:     parents1.AppendElement(node1);
41906:     node1 = node1->GetNodeParent();
41906:   } while (node1);
41901:   do {
41906:     parents2.AppendElement(node2);
41906:     node2 = node2->GetNodeParent();
41906:   } while (node2);
41901: 
41901:   // Check if the nodes are disconnected.
41901:   PRUint32 pos1 = parents1.Length();
41901:   PRUint32 pos2 = parents2.Length();
41901:   nsINode* top1 = parents1.ElementAt(--pos1);
41901:   nsINode* top2 = parents2.ElementAt(--pos2);
41901:   if (top1 != top2) {
41901:     return top1 < top2 ?
41901:       (nsIDOM3Node::DOCUMENT_POSITION_PRECEDING |
41901:        nsIDOM3Node::DOCUMENT_POSITION_DISCONNECTED |
41901:        nsIDOM3Node::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC) :
41901:       (nsIDOM3Node::DOCUMENT_POSITION_FOLLOWING |
41901:        nsIDOM3Node::DOCUMENT_POSITION_DISCONNECTED |
41901:        nsIDOM3Node::DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC);
41901:   }
41901: 
41901:   // Find where the parent chain differs and check indices in the parent.
41901:   nsINode* parent = top1;
41901:   PRUint32 len;
41901:   for (len = NS_MIN(pos1, pos2); len > 0; --len) {
41901:     nsINode* child1 = parents1.ElementAt(--pos1);
41901:     nsINode* child2 = parents2.ElementAt(--pos2);
41901:     if (child1 != child2) {
41901:       // child1 or child2 can be an attribute here. This will work fine since
41901:       // IndexOf will return -1 for the attribute making the attribute be
41901:       // considered before any child.
41901:       return parent->IndexOf(child1) < parent->IndexOf(child2) ?
41901:         static_cast<PRUint16>(nsIDOM3Node::DOCUMENT_POSITION_PRECEDING) :
41901:         static_cast<PRUint16>(nsIDOM3Node::DOCUMENT_POSITION_FOLLOWING);
41901:     }
41901:     parent = child1;
41901:   }
41901: 
41901:   // We hit the end of one of the parent chains without finding a difference
41901:   // between the chains. That must mean that one node is an ancestor of the
41901:   // other. The one with the shortest chain must be the ancestor.
41901:   return pos1 < pos2 ?
41901:     (nsIDOM3Node::DOCUMENT_POSITION_PRECEDING |
41901:      nsIDOM3Node::DOCUMENT_POSITION_CONTAINS) :
41901:     (nsIDOM3Node::DOCUMENT_POSITION_FOLLOWING |
41901:      nsIDOM3Node::DOCUMENT_POSITION_CONTAINED_BY);    
41901: }
41901: 
41904: void
41904: nsINode::LookupNamespaceURI(const nsAString& aNamespacePrefix,
41904:                             nsAString& aNamespaceURI)
41904: {
41904:   Element *element = GetNameSpaceElement();
41904:   if (!element || NS_FAILED(element->LookupNamespaceURI(aNamespacePrefix,
41904:                                                         aNamespaceURI))) {
41904:     SetDOMStringToNull(aNamespaceURI);
41904:   }
41904: }
41904: 
    1: //----------------------------------------------------------------------
    1: 
 2896: PRInt32
 2896: nsIContent::IntrinsicState() const
 2896: {
 3333:   return IsEditable() ? NS_EVENT_STATE_MOZ_READWRITE :
 3333:                         NS_EVENT_STATE_MOZ_READONLY;
 2896: }
 2896: 
 2896: void
 2896: nsIContent::UpdateEditableState()
 2896: {
 2896:   nsIContent *parent = GetParent();
 2896: 
 2896:   SetEditableFlag(parent && parent->HasFlag(NODE_IS_EDITABLE));
 2896: }
 2896: 
12250: nsIContent*
12250: nsIContent::FindFirstNonNativeAnonymous() const
12250: {
12250:   // This handles also nested native anonymous content.
16126:   for (const nsIContent *content = this; content;
16126:        content = content->GetBindingParent()) {
16126:     if (!content->IsInNativeAnonymousSubtree()) {
16126:       // Oops, this function signature allows casting const to
16126:       // non-const.  (Then again, so does GetChildAt(0)->GetParent().)
16126:       return const_cast<nsIContent*>(content);
16126:     }
16126:   }
16126:   return nsnull;
12250: }
12250: 
40937: nsIContent*
40937: nsIContent::GetFlattenedTreeParent() const
40937: {
40937:   nsIContent *parent = GetParent();
40937:   if (parent && parent->HasFlag(NODE_MAY_BE_IN_BINDING_MNGR)) {
40937:     nsIDocument *doc = parent->GetOwnerDoc();
40937:     if (doc) {
40937:       nsIContent* insertionElement =
40937:         doc->BindingManager()->GetNestedInsertionPoint(parent, this);
40937:       if (insertionElement) {
40937:         parent = insertionElement;
40937:       }
40937:     }
40937:   }
40937:   return parent;
40937: }
40937: 
41886: PRUint32
41886: nsIContent::GetDesiredIMEState()
41886: {
41886:   if (!IsEditableInternal()) {
41886:     return IME_STATUS_DISABLE;
41886:   }
41886:   nsIContent *editableAncestor = nsnull;
41886:   for (nsIContent* parent = GetParent();
41886:        parent && parent->HasFlag(NODE_IS_EDITABLE);
41886:        parent = parent->GetParent()) {
41886:     editableAncestor = parent;
41886:   }
41886:   // This is in another editable content, use the result of it.
41886:   if (editableAncestor) {
41886:     return editableAncestor->GetDesiredIMEState();
41886:   }
41886:   nsIDocument* doc = GetCurrentDoc();
41886:   if (!doc) {
41886:     return IME_STATUS_DISABLE;
41886:   }
41886:   nsIPresShell* ps = doc->GetPrimaryShell();
41886:   if (!ps) {
41886:     return IME_STATUS_DISABLE;
41886:   }
41886:   nsPresContext* pc = ps->GetPresContext();
41886:   if (!pc) {
41886:     return IME_STATUS_DISABLE;
41886:   }
41886:   nsIEditor* editor = GetHTMLEditor(pc);
41886:   nsCOMPtr<nsIEditorIMESupport> imeEditor = do_QueryInterface(editor);
41886:   if (!imeEditor) {
41886:     return IME_STATUS_DISABLE;
41886:   }
41886:   // Use "enable" for the default value because IME is disabled unexpectedly,
41886:   // it makes serious a11y problem.
41886:   PRUint32 state = IME_STATUS_ENABLE;
41886:   nsresult rv = imeEditor->GetPreferredIMEState(&state);
41886:   NS_ENSURE_SUCCESS(rv, IME_STATUS_ENABLE);
41886:   return state;
41886: }
41886: 
41901: nsresult
41904: nsIContent::LookupNamespaceURI(const nsAString& aNamespacePrefix,
41904:                                nsAString& aNamespaceURI) const
41901: {
41901:   if (aNamespacePrefix.EqualsLiteral("xml")) {
41901:     // Special-case for xml prefix
41901:     aNamespaceURI.AssignLiteral("http://www.w3.org/XML/1998/namespace");
41901:     return NS_OK;
41901:   }
41901: 
41901:   if (aNamespacePrefix.EqualsLiteral("xmlns")) {
41901:     // Special-case for xmlns prefix
41901:     aNamespaceURI.AssignLiteral("http://www.w3.org/2000/xmlns/");
41901:     return NS_OK;
41901:   }
41901: 
41901:   nsCOMPtr<nsIAtom> name;
41901:   if (!aNamespacePrefix.IsEmpty()) {
41901:     name = do_GetAtom(aNamespacePrefix);
41901:     NS_ENSURE_TRUE(name, NS_ERROR_OUT_OF_MEMORY);
41901:   }
41901:   else {
41901:     name = nsGkAtoms::xmlns;
41901:   }
41901:   // Trace up the content parent chain looking for the namespace
41901:   // declaration that declares aNamespacePrefix.
41904:   const nsIContent* content = this;
41904:   do {
41901:     if (content->GetAttr(kNameSpaceID_XMLNS, name, aNamespaceURI))
41901:       return NS_OK;
41904:   } while ((content = content->GetParent()));
41901:   return NS_ERROR_FAILURE;
41901: }
41901: 
    1: //----------------------------------------------------------------------
    1: 
20752: NS_IMPL_ADDREF(nsChildContentList)
20752: NS_IMPL_RELEASE(nsChildContentList)
20752: 
21218: NS_INTERFACE_TABLE_HEAD(nsChildContentList)
21618:   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
21218:   NS_NODELIST_OFFSET_AND_INTERFACE_TABLE_BEGIN(nsChildContentList)
21218:     NS_INTERFACE_TABLE_ENTRY(nsChildContentList, nsINodeList)
21218:     NS_INTERFACE_TABLE_ENTRY(nsChildContentList, nsIDOMNodeList)
21218:   NS_OFFSET_AND_INTERFACE_TABLE_END
21218:   NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(NodeList)
20752: NS_INTERFACE_MAP_END
    1: 
    1: NS_IMETHODIMP
    1: nsChildContentList::GetLength(PRUint32* aLength)
    1: {
    1:   *aLength = mNode ? mNode->GetChildCount() : 0;
    1: 
    1:   return NS_OK;
    1: }
    1: 
20752: NS_IMETHODIMP
20752: nsChildContentList::Item(PRUint32 aIndex, nsIDOMNode** aReturn)
20752: {
20752:   nsINode* node = GetNodeAt(aIndex);
20752:   if (!node) {
20752:     *aReturn = nsnull;
20752: 
20752:     return NS_OK;
20752:   }
20752: 
20752:   return CallQueryInterface(node, aReturn);
20752: }
20752: 
24403: nsIContent*
19130: nsChildContentList::GetNodeAt(PRUint32 aIndex)
    1: {
    1:   if (mNode) {
19130:     return mNode->GetChildAt(aIndex);
19130:   }
19130: 
19130:   return nsnull;
    1: }
    1: 
24403: PRInt32
24403: nsChildContentList::IndexOf(nsIContent* aContent)
24403: {
24403:   if (mNode) {
24403:     return mNode->IndexOf(aContent);
24403:   }
24403: 
24403:   return -1;
24403: }
24403: 
    1: //----------------------------------------------------------------------
    1: 
41908: NS_IMPL_CYCLE_COLLECTION_1(nsNode3Tearoff, mNode)
    1: 
  791: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsNode3Tearoff)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOM3Node)
29215:   NS_INTERFACE_MAP_ENTRY(nsIDOMXPathNSResolver)
41908: NS_INTERFACE_MAP_END_AGGREGATED(mNode)
    1: 
    1: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsNode3Tearoff)
    1: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsNode3Tearoff)
    1: 
    1: NS_IMETHODIMP
    1: nsNode3Tearoff::GetBaseURI(nsAString& aURI)
    1: {
41908:   mNode->GetBaseURI(aURI);
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNode3Tearoff::GetTextContent(nsAString &aTextContent)
    1: {
41907:   mNode->GetTextContent(aTextContent);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNode3Tearoff::SetTextContent(const nsAString &aTextContent)
    1: {
41907:   return mNode->SetTextContent(aTextContent);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNode3Tearoff::CompareDocumentPosition(nsIDOMNode* aOther,
    1:                                         PRUint16* aReturn)
    1: {
    1:   nsCOMPtr<nsINode> other = do_QueryInterface(aOther);
42132: 
42132:   return mNode->CompareDocumentPosition(other, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNode3Tearoff::IsSameNode(nsIDOMNode* aOther,
    1:                            PRBool* aReturn)
    1: {
41906:   nsCOMPtr<nsINode> other = do_QueryInterface(aOther);
41908:   *aReturn = mNode->IsSameNode(other);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool
41906: nsIContent::IsEqual(nsIContent* aOther)
    1: {
    1:   // We use nsIContent instead of nsINode for the attributes of elements.
    1: 
41906:   NS_PRECONDITION(aOther, "Who called IsEqual?");
    1: 
    1:   nsAutoString string1, string2;
    1: 
    1:   // Prefix, namespace URI, local name, node name check.
41906:   if (!NodeInfo()->Equals(aOther->NodeInfo())) {
    1:     return PR_FALSE;
    1:   }
    1: 
41906:   if (Tag() == nsGkAtoms::documentTypeNodeName) {
41906:     nsCOMPtr<nsIDOMDocumentType> docType1 = do_QueryInterface(this);
41906:     nsCOMPtr<nsIDOMDocumentType> docType2 = do_QueryInterface(aOther);
    1: 
    1:     NS_ASSERTION(docType1 && docType2, "Why don't we have a document type node?");
    1: 
    1:     // Public ID
    1:     docType1->GetPublicId(string1);
    1:     docType2->GetPublicId(string2);
    1: 
    1:     if (!string1.Equals(string2)) {
    1:       return PR_FALSE;
    1:     }
    1: 
    1:     // System ID
    1:     docType1->GetSystemId(string1);
    1:     docType2->GetSystemId(string2);
    1: 
    1:     if (!string1.Equals(string2)) {
    1:       return PR_FALSE;
    1:     }
    1: 
    1:     // Internal subset
    1:     docType1->GetInternalSubset(string1);
    1:     docType2->GetInternalSubset(string2);
    1: 
    1:     if (!string1.Equals(string2)) {
    1:       return PR_FALSE;
    1:     }
    1:   }
    1: 
41906:   if (IsElement()) {
41906:     // Both are elements (we checked that their nodeinfos are equal). Do the
41906:     // check on attributes.
41906:     Element* element2 = aOther->AsElement();
41906:     PRUint32 attrCount = GetAttrCount();
41636:     if (attrCount != element2->GetAttrCount()) {
    1:       return PR_FALSE;
    1:     }
    1: 
    1:     // Iterate over attributes.
    1:     for (PRUint32 i = 0; i < attrCount; ++i) {
41906:       const nsAttrName* attrName1 = GetAttrNameAt(i);
    1: #ifdef DEBUG
    1:       PRBool hasAttr =
    1: #endif
41906:       GetAttr(attrName1->NamespaceID(), attrName1->LocalName(), string1);
    1:       NS_ASSERTION(hasAttr, "Why don't we have an attr?");
    1: 
41636:       if (!element2->AttrValueIs(attrName1->NamespaceID(),
    1:                                  attrName1->LocalName(),
    1:                                  string1,
    1:                                  eCaseMatters)) {
    1:         return PR_FALSE;
    1:       }
    1:     }
41636: 
41636:     // Child nodes count.
41906:     PRUint32 childCount = GetChildCount();
41636:     if (childCount != element2->GetChildCount()) {
41636:       return PR_FALSE;
41636:     }
41636: 
41636:     // Iterate over child nodes.
41636:     for (PRUint32 i = 0; i < childCount; ++i) {
41906:       if (!GetChildAt(i)->IsEqual(element2->GetChildAt(i))) {
41636:         return PR_FALSE;
41636:       }
41636:     }
    1:   } else {
41906:     // Node value check.
41906:     nsCOMPtr<nsIDOMNode> domNode1 = do_QueryInterface(this);
41906:     nsCOMPtr<nsIDOMNode> domNode2 = do_QueryInterface(aOther);
    1:     NS_ASSERTION(domNode1 && domNode2, "How'd we get nsIContent without nsIDOMNode?");
    1:     domNode1->GetNodeValue(string1);
    1:     domNode2->GetNodeValue(string2);
    1:     if (!string1.Equals(string2)) {
    1:       return PR_FALSE;
    1:     }
    1:   }
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
41906: PRBool
41906: nsIContent::IsEqualNode(nsINode* aOther)
41906: {
41906:   if (!aOther || !aOther->IsNodeOfType(eCONTENT))
41906:     return PR_FALSE;
41906: 
41906:   return IsEqual(static_cast<nsIContent*>(aOther));
41906: }
41906: 
    1: NS_IMETHODIMP
    1: nsNode3Tearoff::IsEqualNode(nsIDOMNode* aOther, PRBool* aReturn)
    1: {
41906:   // Since we implement nsINode, aOther must as well.
41906:   nsCOMPtr<nsINode> other = do_QueryInterface(aOther);
41906: 
41908:   *aReturn = other && mNode->IsEqualNode(other);
41906: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNode3Tearoff::GetFeature(const nsAString& aFeature,
    1:                            const nsAString& aVersion,
    1:                            nsISupports** aReturn)
    1: {
41908:   return mNode->GetFeature(aFeature, aVersion, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNode3Tearoff::SetUserData(const nsAString& aKey,
    1:                             nsIVariant* aData,
    1:                             nsIDOMUserDataHandler* aHandler,
    1:                             nsIVariant** aResult)
    1: {
41908:   return mNode->SetUserData(aKey, aData, aHandler, aResult);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNode3Tearoff::GetUserData(const nsAString& aKey,
    1:                             nsIVariant** aResult)
    1: {
41908:   NS_IF_ADDREF(*aResult = mNode->GetUserData(aKey));
41902: 
41902:   return NS_OK;
    1: }
    1: 
41904: nsIAtom*
41904: nsIContent::LookupPrefix(const nsAString& aNamespaceURI)
41904: {
    1:   // XXX Waiting for DOM spec to list error codes.
    1: 
    1:   // Trace up the content parent chain looking for the namespace
    1:   // declaration that defines the aNamespaceURI namespace. Once found,
    1:   // return the prefix (i.e. the attribute localName).
41904:   for (nsIContent* content = this; content;
    1:        content = content->GetParent()) {
    1:     PRUint32 attrCount = content->GetAttrCount();
    1: 
    1:     for (PRUint32 i = 0; i < attrCount; ++i) {
    1:       const nsAttrName* name = content->GetAttrNameAt(i);
    1: 
    1:       if (name->NamespaceEquals(kNameSpaceID_XMLNS) &&
    1:           content->AttrValueIs(kNameSpaceID_XMLNS, name->LocalName(),
    1:                                aNamespaceURI, eCaseMatters)) {
    1:         // If the localName is "xmlns", the prefix we output should be
    1:         // null.
41904:         nsIAtom *localName = name->LocalName();
41904: 
41904:         return localName == nsGkAtoms::xmlns ? nsnull : localName;
41904:       }
41904:     }
41904:   }
41904: 
41904:   return nsnull;
41904: }
41904: 
41904: NS_IMETHODIMP
41904: nsNode3Tearoff::LookupPrefix(const nsAString& aNamespaceURI,
41904:                              nsAString& aPrefix)
41904: {
41908:   mNode->LookupPrefix(aNamespaceURI, aPrefix);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNode3Tearoff::LookupNamespaceURI(const nsAString& aNamespacePrefix,
    1:                                    nsAString& aNamespaceURI)
    1: {
41908:   mNode->LookupNamespaceURI(aNamespacePrefix, aNamespaceURI);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNode3Tearoff::IsDefaultNamespace(const nsAString& aNamespaceURI,
    1:                                    PRBool* aReturn)
    1: {
41908:   *aReturn = mNode->IsDefaultNamespace(aNamespaceURI);
    1:   return NS_OK;
    1: }
    1: 
41910: nsIContent*
41910: nsGenericElement::GetFirstElementChild()
41910: {
41910:   nsAttrAndChildArray& children = mAttrsAndChildren;
17074:   PRUint32 i, count = children.ChildCount();
17074:   for (i = 0; i < count; ++i) {
17074:     nsIContent* child = children.ChildAt(i);
41636:     if (child->IsElement()) {
41910:       return child;
41910:     }
41910:   }
41910:   
41910:   return nsnull;
41910: }
41910: 
41910: nsIContent*
41910: nsGenericElement::GetLastElementChild()
41910: {
41910:   nsAttrAndChildArray& children = mAttrsAndChildren;
17074:   PRUint32 i = children.ChildCount();
17074:   while (i > 0) {
17074:     nsIContent* child = children.ChildAt(--i);
41636:     if (child->IsElement()) {
41910:       return child;
41910:     }
41910:   }
41910:   
41910:   return nsnull;
41910: }
41910: 
41910: nsIContent*
41910: nsGenericElement::GetPreviousElementSibling()
41910: {
41910:   nsIContent* parent = GetParent();
17074:   if (!parent) {
41910:     return nsnull;
17074:   }
17074: 
41636:   NS_ASSERTION(parent->IsElement() ||
17074:                parent->IsNodeOfType(nsINode::eDOCUMENT_FRAGMENT),
17074:                "Parent content must be an element or a doc fragment");
17074: 
17074:   nsAttrAndChildArray& children =
17074:     static_cast<nsGenericElement*>(parent)->mAttrsAndChildren;
41910:   PRInt32 index = children.IndexOfChild(this);
17074:   if (index < 0) {
41910:     return nsnull;
17074:   }
17074: 
17074:   PRUint32 i = index;
17074:   while (i > 0) {
17074:     nsIContent* child = children.ChildAt((PRUint32)--i);
41636:     if (child->IsElement()) {
41910:       return child;
41910:     }
41910:   }
41910:   
41910:   return nsnull;
41910: }
41910: 
41910: nsIContent*
41910: nsGenericElement::GetNextElementSibling()
41910: {
41910:   nsIContent* parent = GetParent();
17074:   if (!parent) {
41910:     return nsnull;
17074:   }
17074: 
41636:   NS_ASSERTION(parent->IsElement() ||
17074:                parent->IsNodeOfType(nsINode::eDOCUMENT_FRAGMENT),
17074:                "Parent content must be an element or a doc fragment");
17074: 
17074:   nsAttrAndChildArray& children =
17074:     static_cast<nsGenericElement*>(parent)->mAttrsAndChildren;
41910:   PRInt32 index = children.IndexOfChild(this);
17074:   if (index < 0) {
41910:     return nsnull;
17074:   }
17074: 
17074:   PRUint32 i, count = children.ChildCount();
17074:   for (i = (PRUint32)index + 1; i < count; ++i) {
17074:     nsIContent* child = children.ChildAt(i);
41636:     if (child->IsElement()) {
41910:       return child;
41910:     }
41910:   }
41910:   
41910:   return nsnull;
41910: }
41910: 
41910: NS_IMETHODIMP
41910: nsNSElementTearoff::GetFirstElementChild(nsIDOMElement** aResult)
41910: {
41910:   *aResult = nsnull;
41910: 
41910:   nsIContent *result = mContent->GetFirstElementChild();
41910: 
41910:   return result ? CallQueryInterface(result, aResult) : NS_OK;
41910: }
41910: 
41910: NS_IMETHODIMP
41910: nsNSElementTearoff::GetLastElementChild(nsIDOMElement** aResult)
41910: {
41910:   *aResult = nsnull;
41910: 
41910:   nsIContent *result = mContent->GetLastElementChild();
41910: 
41910:   return result ? CallQueryInterface(result, aResult) : NS_OK;
41910: }
41910: 
41910: NS_IMETHODIMP
41910: nsNSElementTearoff::GetPreviousElementSibling(nsIDOMElement** aResult)
41910: {
41910:   *aResult = nsnull;
41910: 
41910:   nsIContent *result = mContent->GetPreviousElementSibling();
41910: 
41910:   return result ? CallQueryInterface(result, aResult) : NS_OK;
41910: }
41910: 
41910: NS_IMETHODIMP
41910: nsNSElementTearoff::GetNextElementSibling(nsIDOMElement** aResult)
41910: {
41910:   *aResult = nsnull;
41910: 
41910:   nsIContent *result = mContent->GetNextElementSibling();
41910: 
41910:   return result ? CallQueryInterface(result, aResult) : NS_OK;
17074: }
17074: 
17074: nsContentList*
41910: nsGenericElement::GetChildrenList()
41910: {
41910:   nsGenericElement::nsDOMSlots *slots = GetDOMSlots();
17074:   NS_ENSURE_TRUE(slots, nsnull);
17074: 
17074:   if (!slots->mChildrenList) {
41910:     slots->mChildrenList = new nsContentList(this, nsGkAtoms::_asterix,
17074:                                              kNameSpaceID_Wildcard, PR_FALSE);
17074:   }
17074: 
17074:   return slots->mChildrenList;
17074: }
17074: 
17074: NS_IMETHODIMP
17074: nsNSElementTearoff::GetChildElementCount(PRUint32* aResult)
17074: {
41910:   return mContent->GetChildElementCount(aResult);
17074: }
17074: 
17074: NS_IMETHODIMP
17074: nsNSElementTearoff::GetChildren(nsIDOMNodeList** aResult)
17074: {
41910:   return mContent->GetChildren(aResult);
41910: }
41910: 
41910: nsIDOMDOMTokenList*
41910: nsGenericElement::GetClassList(nsresult *aResult)
41910: {
41910:   *aResult = NS_ERROR_OUT_OF_MEMORY;
41910: 
41910:   nsGenericElement::nsDOMSlots *slots = GetDOMSlots();
41910:   NS_ENSURE_TRUE(slots, nsnull);
41910: 
41910:   if (!slots->mClassList) {
41910:     nsCOMPtr<nsIAtom> classAttr = GetClassAttributeName();
41910:     if (!classAttr) {
41910:       *aResult = NS_OK;
41910: 
41910:       return nsnull;
41910:     }
41910: 
41910:     slots->mClassList = new nsDOMTokenList(this, classAttr);
41910:     NS_ENSURE_TRUE(slots->mClassList, nsnull);
41910:   }
41910: 
41910:   *aResult = NS_OK;
41910: 
41910:   return slots->mClassList;
17074: }
17074: 
31383: NS_IMETHODIMP
31383: nsNSElementTearoff::GetClassList(nsIDOMDOMTokenList** aResult)
31383: {
41910:   *aResult = nsnull;
41910: 
41910:   nsresult rv;
41910:   nsIDOMDOMTokenList* list = mContent->GetClassList(&rv);
41910:   NS_ENSURE_TRUE(list, rv);
41910: 
41910:   NS_ADDREF(*aResult = list);
31383: 
31383:   return NS_OK;
31383: }
31383: 
32435: NS_IMETHODIMP
32435: nsNSElementTearoff::SetCapture(PRBool aRetargetToElement)
32435: {
32435:   // If there is already an active capture, ignore this request. This would
32435:   // occur if a splitter, frame resizer, etc had already captured and we don't
32435:   // want to override those.
32435:   nsCOMPtr<nsIDOMNode> node = do_QueryInterface(nsIPresShell::GetCapturingContent());
32435:   if (node)
32435:     return NS_OK;
32435: 
37876:   nsIPresShell::SetCapturingContent(mContent, CAPTURE_PREVENTDRAG |
37876:     (aRetargetToElement ? CAPTURE_RETARGETTOELEMENT : 0));
32435:   return NS_OK;
32435: }
32435: 
32435: NS_IMETHODIMP
32435: nsNSElementTearoff::ReleaseCapture()
32435: {
32435:   if (nsIPresShell::GetCapturingContent() == mContent) {
32435:     nsIPresShell::SetCapturingContent(nsnull, 0);
32435:   }
32435:   return NS_OK;
32435: }
32435: 
    1: //----------------------------------------------------------------------
    1: 
    1: 
 5545: NS_IMPL_CYCLE_COLLECTION_1(nsNSElementTearoff, mContent)
 5545: 
    1: NS_INTERFACE_MAP_BEGIN(nsNSElementTearoff)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMNSElement)
 5545:   NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsNSElementTearoff)
    1: NS_INTERFACE_MAP_END_AGGREGATED(mContent)
    1: 
 5545: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsNSElementTearoff)
 5545: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsNSElementTearoff)
    1: 
    1: NS_IMETHODIMP
    1: nsNSElementTearoff::GetElementsByClassName(const nsAString& aClasses,
    1:                                            nsIDOMNodeList** aReturn)
    1: {
41910:   return mContent->GetElementsByClassName(aClasses, aReturn);
    1: }
    1: 
16722: nsIFrame*
16722: nsGenericElement::GetStyledFrame()
16722: {
16722:   nsIFrame *frame = GetPrimaryFrame(Flush_Layout);
35300:   return frame ? nsLayoutUtils::GetStyleFrame(frame) : nsnull;
16722: }
16722: 
16722: void
16722: nsGenericElement::GetOffsetRect(nsRect& aRect, nsIContent** aOffsetParent)
16722: {
16722:   *aOffsetParent = nsnull;
16722:   aRect = nsRect();
16722: 
16722:   nsIFrame* frame = GetStyledFrame();
16722:   if (!frame) {
16722:     return;
16722:   }
16722: 
16722:   nsPoint origin = frame->GetPosition();
16722:   aRect.x = nsPresContext::AppUnitsToIntCSSPixels(origin.x);
16722:   aRect.y = nsPresContext::AppUnitsToIntCSSPixels(origin.y);
16722: 
16722:   // Get the union of all rectangles in this and continuation frames.
16722:   // It doesn't really matter what we use as aRelativeTo here, since
16722:   // we only care about the size. Using 'parent' might make things
16722:   // a bit faster by speeding up the internal GetOffsetTo operations.
18884:   nsIFrame* parent = frame->GetParent() ? frame->GetParent() : frame;
18884:   nsRect rcFrame = nsLayoutUtils::GetAllInFlowRectsUnion(frame, parent);
16722:   aRect.width = nsPresContext::AppUnitsToIntCSSPixels(rcFrame.width);
16722:   aRect.height = nsPresContext::AppUnitsToIntCSSPixels(rcFrame.height);
16722: }
16722: 
37060: nsIScrollableFrame*
41910: nsGenericElement::GetScrollFrame(nsIFrame **aStyledFrame)
37060: {
16722:   // it isn't clear what to return for SVG nodes, so just return nothing
41910:   if (IsSVG()) {
37060:     if (aStyledFrame) {
37060:       *aStyledFrame = nsnull;
37060:     }
37060:     return nsnull;
16722:   }
16722: 
41910:   nsIFrame* frame = GetStyledFrame();
16722: 
37060:   if (aStyledFrame) {
37060:     *aStyledFrame = frame;
16722:   }
16722:   if (!frame) {
37060:     return nsnull;
37060:   }
37060: 
37060:   // menu frames implement GetScrollTargetFrame but we don't want
16722:   // to use it here.
37060:   if (frame->GetType() != nsGkAtoms::menuFrame) {
37060:     nsIScrollableFrame *scrollFrame = frame->GetScrollTargetFrame();
37060:     if (scrollFrame)
37060:       return scrollFrame;
37060:   }
37060: 
41910:   nsIDocument* doc = GetOwnerDoc();
37060:   PRBool quirksMode = doc->GetCompatibilityMode() == eCompatibility_NavQuirks;
41634:   Element* elementWithRootScrollInfo =
41634:     quirksMode ? doc->GetBodyElement() : doc->GetRootElement();
41910:   if (this == elementWithRootScrollInfo) {
16722:     // In quirks mode, the scroll info for the body element should map to the
37060:     // root scrollable frame.
37060:     // In strict mode, the scroll info for the root element should map to the
16722:     // the root scrollable frame.
37060:     return frame->PresContext()->PresShell()->GetRootScrollFrameAsScrollable();
37060:   }
37060: 
37060:   return nsnull;
16722: }
16722: 
41910: PRInt32
41910: nsGenericElement::GetScrollTop()
41910: {
41910:   nsIScrollableFrame* sf = GetScrollFrame();
41910: 
41910:   return sf ?
41910:          nsPresContext::AppUnitsToIntCSSPixels(sf->GetScrollPosition().y) :
41910:          0;
41910: }
41910: 
41910: NS_IMETHODIMP
16722: nsNSElementTearoff::GetScrollTop(PRInt32* aScrollTop)
16722: {
41910:   *aScrollTop = mContent->GetScrollTop();
37060: 
37060:   return NS_OK;
16722: }
16722: 
41910: void
41910: nsGenericElement::SetScrollTop(PRInt32 aScrollTop)
16722: {
37060:   nsIScrollableFrame* sf = GetScrollFrame();
37060:   if (sf) {
37060:     nsPoint pt = sf->GetScrollPosition();
37060:     pt.y = nsPresContext::CSSPixelsToAppUnits(aScrollTop);
37060:     sf->ScrollTo(pt, nsIScrollableFrame::INSTANT);
37060:   }
41910: }
41910: 
41910: NS_IMETHODIMP
41910: nsNSElementTearoff::SetScrollTop(PRInt32 aScrollTop)
41910: {
41910:   mContent->SetScrollTop(aScrollTop);
37060: 
37060:   return NS_OK;
16722: }
16722: 
41910: PRInt32
41910: nsGenericElement::GetScrollLeft()
41910: {
41910:   nsIScrollableFrame* sf = GetScrollFrame();
41910: 
41910:   return sf ?
41910:          nsPresContext::AppUnitsToIntCSSPixels(sf->GetScrollPosition().x) :
41910:          0;
41910: }
41910: 
41910: NS_IMETHODIMP
16722: nsNSElementTearoff::GetScrollLeft(PRInt32* aScrollLeft)
16722: {
41910:   *aScrollLeft = mContent->GetScrollLeft();
37060: 
37060:   return NS_OK;
16722: }
16722: 
41910: void
41910: nsGenericElement::SetScrollLeft(PRInt32 aScrollLeft)
16722: {
37060:   nsIScrollableFrame* sf = GetScrollFrame();
37060:   if (sf) {
37060:     nsPoint pt = sf->GetScrollPosition();
37060:     pt.x = nsPresContext::CSSPixelsToAppUnits(aScrollLeft);
37060:     sf->ScrollTo(pt, nsIScrollableFrame::INSTANT);
37060:   }
41910: }
41910: 
41910: NS_IMETHODIMP
41910: nsNSElementTearoff::SetScrollLeft(PRInt32 aScrollLeft)
41910: {
41910:   mContent->SetScrollLeft(aScrollLeft);
37060: 
37060:   return NS_OK;
16722: }
16722: 
41910: PRInt32
41910: nsGenericElement::GetScrollHeight()
41910: {
41910:   if (IsSVG())
41910:     return 0;
16722: 
37060:   nsIScrollableFrame* sf = GetScrollFrame();
37060:   if (!sf) {
16722:     nsRect rcFrame;
16722:     nsCOMPtr<nsIContent> parent;
41910:     GetOffsetRect(rcFrame, getter_AddRefs(parent));
41910:     return rcFrame.height;
41910:   }
41910: 
41910:   nscoord height = sf->GetScrollRange().height + sf->GetScrollPortRect().height;
41910:   return nsPresContext::AppUnitsToIntCSSPixels(height);
41910: }
41910: 
41910: NS_IMETHODIMP
41910: nsNSElementTearoff::GetScrollHeight(PRInt32* aScrollHeight)
41910: {
41910:   *aScrollHeight = mContent->GetScrollHeight();
41910: 
16722:   return NS_OK;
16722: }
16722: 
41910: PRInt32
41910: nsGenericElement::GetScrollWidth()
41910: {
41910:   if (IsSVG())
41910:     return 0;
16722: 
37060:   nsIScrollableFrame* sf = GetScrollFrame();
37060:   if (!sf) {
16722:     nsRect rcFrame;
16722:     nsCOMPtr<nsIContent> parent;
41910:     GetOffsetRect(rcFrame, getter_AddRefs(parent));
41910:     return rcFrame.width;
41910:   }
41910: 
41910:   nscoord width = sf->GetScrollRange().width + sf->GetScrollPortRect().width;
41910:   return nsPresContext::AppUnitsToIntCSSPixels(width);
41910: }
41910: 
41910: NS_IMETHODIMP
41910: nsNSElementTearoff::GetScrollWidth(PRInt32 *aScrollWidth)
41910: {
41910:   *aScrollWidth = mContent->GetScrollWidth();
41910: 
16722:   return NS_OK;
16722: }
16722: 
16722: nsRect
41910: nsGenericElement::GetClientAreaRect()
16722: {
37060:   nsIFrame* styledFrame;
37060:   nsIScrollableFrame* sf = GetScrollFrame(&styledFrame);
37060: 
37060:   if (sf) {
37060:     return sf->GetScrollPortRect();
37060:   }
37060: 
37060:   if (styledFrame &&
37060:       (styledFrame->GetStyleDisplay()->mDisplay != NS_STYLE_DISPLAY_INLINE ||
37060:        styledFrame->IsFrameOfType(nsIFrame::eReplaced))) {
16722:     // Special case code to make client area work even when there isn't
16722:     // a scroll view, see bug 180552, bug 227567.
37060:     return styledFrame->GetPaddingRect() - styledFrame->GetPositionIgnoringScrolling();
37060:   }
37060: 
37060:   // SVG nodes reach here and just return 0
16722:   return nsRect(0, 0, 0, 0);
16722: }
16722: 
41910: NS_IMETHODIMP
41910: nsNSElementTearoff::GetClientTop(PRInt32 *aClientTop)
41910: {
41910:   *aClientTop = mContent->GetClientTop();
41910:   return NS_OK;
41910: }
41910: 
41910: NS_IMETHODIMP
41910: nsNSElementTearoff::GetClientLeft(PRInt32 *aClientLeft)
41910: {
41910:   *aClientLeft = mContent->GetClientLeft();
41910:   return NS_OK;
41910: }
41910: 
41910: NS_IMETHODIMP
41910: nsNSElementTearoff::GetClientHeight(PRInt32 *aClientHeight)
41910: {
41910:   *aClientHeight = mContent->GetClientHeight();
41910:   return NS_OK;
41910: }
41910: 
41910: NS_IMETHODIMP
41910: nsNSElementTearoff::GetClientWidth(PRInt32 *aClientWidth)
41910: {
41910:   *aClientWidth = mContent->GetClientWidth();
41910:   return NS_OK;
41910: }
41910: 
16722: nsresult
41910: nsGenericElement::GetBoundingClientRect(nsIDOMClientRect** aResult)
 2014: {
 2014:   // Weak ref, since we addref it below
12913:   nsClientRect* rect = new nsClientRect();
 2014:   if (!rect)
 2014:     return NS_ERROR_OUT_OF_MEMORY;
 2014: 
 2014:   NS_ADDREF(*aResult = rect);
 2014:   
41910:   nsIFrame* frame = GetPrimaryFrame(Flush_Layout);
 2014:   if (!frame) {
 2014:     // display:none, perhaps? Return the empty rect
 2014:     return NS_OK;
 2014:   }
12349: 
12349:   nsRect r = nsLayoutUtils::GetAllInFlowRectsUnion(frame,
33027:           nsLayoutUtils::GetContainingBlockForClientRect(frame));
32894:   rect->SetLayoutRect(r);
 2014:   return NS_OK;
 2014: }
 2014: 
10833: NS_IMETHODIMP
41910: nsNSElementTearoff::GetBoundingClientRect(nsIDOMClientRect** aResult)
41910: {
41910:   return mContent->GetBoundingClientRect(aResult);
41910: }
41910: 
41910: nsresult
41910: nsGenericElement::GetClientRects(nsIDOMClientRectList** aResult)
10833: {
10833:   *aResult = nsnull;
10833: 
12913:   nsRefPtr<nsClientRectList> rectList = new nsClientRectList();
10833:   if (!rectList)
10833:     return NS_ERROR_OUT_OF_MEMORY;
10833: 
41910:   nsIFrame* frame = GetPrimaryFrame(Flush_Layout);
10833:   if (!frame) {
10833:     // display:none, perhaps? Return an empty list
10833:     *aResult = rectList.forget().get();
10833:     return NS_OK;
10833:   }
10833: 
33027:   nsLayoutUtils::RectListBuilder builder(rectList);
12349:   nsLayoutUtils::GetAllInFlowRects(frame,
33027:           nsLayoutUtils::GetContainingBlockForClientRect(frame), &builder);
12349:   if (NS_FAILED(builder.mRV))
12349:     return builder.mRV;
10833:   *aResult = rectList.forget().get();
 2014:   return NS_OK;
 2014: }
 2014: 
41910: NS_IMETHODIMP
41910: nsNSElementTearoff::GetClientRects(nsIDOMClientRectList** aResult)
41910: {
41910:   return mContent->GetClientRects(aResult);
41910: }
41910: 
    1: //----------------------------------------------------------------------
    1: 
    1: 
    1: NS_IMPL_ISUPPORTS1(nsNodeWeakReference,
    1:                    nsIWeakReference)
    1: 
    1: nsNodeWeakReference::~nsNodeWeakReference()
    1: {
    1:   if (mNode) {
    1:     NS_ASSERTION(mNode->GetSlots() &&
    1:                  mNode->GetSlots()->mWeakReference == this,
    1:                  "Weak reference has wrong value");
    1:     mNode->GetSlots()->mWeakReference = nsnull;
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNodeWeakReference::QueryReferent(const nsIID& aIID, void** aInstancePtr)
    1: {
    1:   return mNode ? mNode->QueryInterface(aIID, aInstancePtr) :
    1:                  NS_ERROR_NULL_POINTER;
    1: }
    1: 
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_1(nsNodeSupportsWeakRefTearoff, mNode)
    1: 
  791: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsNodeSupportsWeakRefTearoff)
    1:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
    1: NS_INTERFACE_MAP_END_AGGREGATED(mNode)
    1: 
    1: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsNodeSupportsWeakRefTearoff)
    1: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsNodeSupportsWeakRefTearoff)
    1: 
    1: NS_IMETHODIMP
    1: nsNodeSupportsWeakRefTearoff::GetWeakReference(nsIWeakReference** aInstancePtr)
    1: {
    1:   nsINode::nsSlots* slots = mNode->GetSlots();
    1:   NS_ENSURE_TRUE(slots, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   if (!slots->mWeakReference) {
    1:     slots->mWeakReference = new nsNodeWeakReference(mNode);
    1:     NS_ENSURE_TRUE(slots->mWeakReference, NS_ERROR_OUT_OF_MEMORY);
    1:   }
    1: 
    1:   NS_ADDREF(*aInstancePtr = slots->mWeakReference);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsDOMEventRTTearoff *
    1: nsDOMEventRTTearoff::mCachedEventTearoff[NS_EVENT_TEAROFF_CACHE_SIZE];
    1: 
    1: PRUint32 nsDOMEventRTTearoff::mCachedEventTearoffCount = 0;
    1: 
    1: 
28073: nsDOMEventRTTearoff::nsDOMEventRTTearoff(nsINode *aNode)
28073:   : mNode(aNode)
    1: {
    1: }
    1: 
    1: nsDOMEventRTTearoff::~nsDOMEventRTTearoff()
    1: {
    1: }
    1: 
28073: NS_IMPL_CYCLE_COLLECTION_1(nsDOMEventRTTearoff, mNode)
    1: 
  791: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsDOMEventRTTearoff)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMEventTarget)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOM3EventTarget)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMNSEventTarget)
28073: NS_INTERFACE_MAP_END_AGGREGATED(mNode)
    1: 
    1: NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS(nsDOMEventRTTearoff,
    1:                                           nsIDOMEventTarget)
    1: NS_IMPL_CYCLE_COLLECTING_RELEASE_AMBIGUOUS_WITH_DESTROY(nsDOMEventRTTearoff,
    1:                                                         nsIDOMEventTarget,
    1:                                                         LastRelease())
    1: 
    1: nsDOMEventRTTearoff *
28073: nsDOMEventRTTearoff::Create(nsINode *aNode)
    1: {
    1:   if (mCachedEventTearoffCount) {
    1:     // We have cached unused instances of this class, return a cached
    1:     // instance in stead of always creating a new one.
    1:     nsDOMEventRTTearoff *tearoff =
    1:       mCachedEventTearoff[--mCachedEventTearoffCount];
    1: 
    1:     // Set the back pointer to the content object
28073:     tearoff->mNode = aNode;
    1: 
    1:     return tearoff;
    1:   }
    1: 
    1:   // The cache is empty, this means we haveto create a new instance.
28073:   return new nsDOMEventRTTearoff(aNode);
    1: }
    1: 
    1: // static
    1: void
    1: nsDOMEventRTTearoff::Shutdown()
    1: {
    1:   // Clear our cache.
    1:   while (mCachedEventTearoffCount) {
    1:     delete mCachedEventTearoff[--mCachedEventTearoffCount];
    1:   }
    1: }
    1: 
    1: void
    1: nsDOMEventRTTearoff::LastRelease()
    1: {
    1:   if (mCachedEventTearoffCount < NS_EVENT_TEAROFF_CACHE_SIZE) {
    1:     // There's still space in the cache for one more instance, put
    1:     // this instance in the cache in stead of deleting it.
    1:     mCachedEventTearoff[mCachedEventTearoffCount++] = this;
    1: 
    1:     // Don't set mContent to null directly since setting mContent to null
    1:     // could result in code that grabs a tearoff from the cache and we don't
    1:     // want to get reused while still being torn down.
    1:     // See bug 330526.
28073:     nsCOMPtr<nsINode> kungFuDeathGrip;
28073:     kungFuDeathGrip.swap(mNode);
    1: 
    1:     // The refcount balancing and destructor re-entrancy protection
    1:     // code in Release() sets mRefCnt to 1 so we have to set it to 0
    1:     // here to prevent leaks
    1:     mRefCnt = 0;
    1: 
    1:     return;
    1:   }
    1: 
    1:   delete this;
    1: }
    1: 
    1: nsresult
    1: nsDOMEventRTTearoff::GetDOM3EventTarget(nsIDOM3EventTarget **aTarget)
    1: {
29474:   nsIEventListenerManager* listener_manager =
29474:     mNode->GetListenerManager(PR_TRUE);
29474:   NS_ENSURE_STATE(listener_manager);
    1:   return CallQueryInterface(listener_manager, aTarget);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMEventRTTearoff::GetScriptTypeID(PRUint32 *aLang)
    1: {
28073:   *aLang = mNode->GetScriptTypeID();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMEventRTTearoff::SetScriptTypeID(PRUint32 aLang)
    1: {
28073:   return mNode->SetScriptTypeID(aLang);
    1: }
    1: 
    1: 
    1: // nsIDOMEventTarget
    1: NS_IMETHODIMP
    1: nsDOMEventRTTearoff::AddEventListener(const nsAString& aType,
    1:                                       nsIDOMEventListener *aListener,
    1:                                       PRBool useCapture)
    1: {
37183:   return AddEventListener(aType, aListener, useCapture, PR_FALSE, 0);
    1: }
    1: 
    1: NS_IMETHODIMP
 1418: nsDOMEventRTTearoff::RemoveEventListener(const nsAString& aType,
 1418:                                          nsIDOMEventListener* aListener,
 1418:                                          PRBool aUseCapture)
    1: {
 1418:   return RemoveGroupedEventListener(aType, aListener, aUseCapture, nsnull);
 1418: }
 1418: 
 1418: NS_IMETHODIMP
 1418: nsDOMEventRTTearoff::DispatchEvent(nsIDOMEvent *aEvt, PRBool* _retval)
 1418: {
29474:   nsCOMPtr<nsIDOMEventTarget> target =
29474:     do_QueryInterface(mNode->GetListenerManager(PR_TRUE));
 1418:   NS_ENSURE_STATE(target);
 1418:   return target->DispatchEvent(aEvt, _retval);
    1: }
    1: 
    1: // nsIDOM3EventTarget
    1: NS_IMETHODIMP
    1: nsDOMEventRTTearoff::AddGroupedEventListener(const nsAString& aType,
    1:                                              nsIDOMEventListener *aListener,
    1:                                              PRBool aUseCapture,
    1:                                              nsIDOMEventGroup *aEvtGrp)
    1: {
    1:   nsCOMPtr<nsIDOM3EventTarget> event_target;
    1:   nsresult rv = GetDOM3EventTarget(getter_AddRefs(event_target));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return event_target->AddGroupedEventListener(aType, aListener, aUseCapture,
    1:                                                aEvtGrp);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMEventRTTearoff::RemoveGroupedEventListener(const nsAString& aType,
    1:                                                 nsIDOMEventListener *aListener,
    1:                                                 PRBool aUseCapture,
    1:                                                 nsIDOMEventGroup *aEvtGrp)
    1: {
    1:   nsCOMPtr<nsIDOM3EventTarget> event_target;
    1:   nsresult rv = GetDOM3EventTarget(getter_AddRefs(event_target));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return event_target->RemoveGroupedEventListener(aType, aListener,
    1:                                                   aUseCapture, aEvtGrp);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMEventRTTearoff::CanTrigger(const nsAString & type, PRBool *_retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMEventRTTearoff::IsRegisteredHere(const nsAString & type, PRBool *_retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: // nsIDOMNSEventTarget
    1: NS_IMETHODIMP
    1: nsDOMEventRTTearoff::AddEventListener(const nsAString& aType,
    1:                                       nsIDOMEventListener *aListener,
    1:                                       PRBool aUseCapture,
37183:                                       PRBool aWantsUntrusted,
37183:                                       PRUint8 optional_argc)
37183: {
37183:   NS_ASSERTION(!aWantsUntrusted || optional_argc > 0,
37183:                "Won't check if this is chrome, you want to set "
37183:                "aWantsUntrusted to PR_FALSE or make the aWantsUntrusted "
37183:                "explicit by making optional_argc non-zero.");
37183: 
29474:   nsIEventListenerManager* listener_manager =
29474:     mNode->GetListenerManager(PR_TRUE);
29474:   NS_ENSURE_STATE(listener_manager);
    1: 
    1:   PRInt32 flags = aUseCapture ? NS_EVENT_FLAG_CAPTURE : NS_EVENT_FLAG_BUBBLE;
    1: 
37183:   if (aWantsUntrusted ||
37183:       (optional_argc == 0 &&
37183:        !nsContentUtils::IsChromeDoc(mNode->GetOwnerDoc()))) {
    1:     flags |= NS_PRIV_EVENT_UNTRUSTED_PERMITTED;
    1:   }
    1: 
    1:   return listener_manager->AddEventListenerByType(aListener, aType, flags,
    1:                                                   nsnull);
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
41909: NS_IMPL_CYCLE_COLLECTION_1(nsNodeSelectorTearoff, mNode)
16106: 
16106: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsNodeSelectorTearoff)
16106:   NS_INTERFACE_MAP_ENTRY(nsIDOMNodeSelector)
41909: NS_INTERFACE_MAP_END_AGGREGATED(mNode)
16106: 
16106: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsNodeSelectorTearoff)
16106: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsNodeSelectorTearoff)
16106: 
16106: NS_IMETHODIMP
16106: nsNodeSelectorTearoff::QuerySelector(const nsAString& aSelector,
16106:                                      nsIDOMElement **aReturn)
16106: {
41909:   nsresult rv;
41909:   nsIContent* result = nsGenericElement::doQuerySelector(mNode, aSelector, &rv);
41909:   return result ? CallQueryInterface(result, aReturn) : rv;
16106: }
16106: 
16106: NS_IMETHODIMP
16106: nsNodeSelectorTearoff::QuerySelectorAll(const nsAString& aSelector,
16106:                                         nsIDOMNodeList **aReturn)
16106: {
41909:   return nsGenericElement::doQuerySelectorAll(mNode, aSelector, aReturn);
16106: }
16106: 
16106: //----------------------------------------------------------------------
    1: nsGenericElement::nsDOMSlots::nsDOMSlots(PtrBits aFlags)
    1:   : nsINode::nsSlots(aFlags),
    1:     mBindingParent(nsnull)
    1: {
    1: }
    1: 
    1: nsGenericElement::nsDOMSlots::~nsDOMSlots()
    1: {
    1:   if (mAttributeMap) {
    1:     mAttributeMap->DropReference();
    1:   }
31383: 
31383:   if (mClassList) {
31383:     mClassList->DropReference();
31383:   }
    1: }
    1: 
    1: nsGenericElement::nsGenericElement(nsINodeInfo *aNodeInfo)
41632:   : Element(aNodeInfo)
    1: {
    1:   // Set the default scriptID to JS - but skip SetScriptTypeID as it
    1:   // does extra work we know isn't necessary here...
41631:   SetFlags(NODE_IS_ELEMENT |
41631:            (nsIProgrammingLanguage::JAVASCRIPT << NODE_SCRIPT_TYPE_OFFSET));
    1: }
    1: 
    1: nsGenericElement::~nsGenericElement()
    1: {
    1:   NS_PRECONDITION(!IsInDoc(),
    1:                   "Please remove this from the document properly");
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::GetNodeName(nsAString& aNodeName)
    1: {
    1:   mNodeInfo->GetQualifiedName(aNodeName);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::GetLocalName(nsAString& aLocalName)
    1: {
    1:   mNodeInfo->GetLocalName(aLocalName);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::GetNodeValue(nsAString& aNodeValue)
    1: {
    1:   SetDOMStringToNull(aNodeValue);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::SetNodeValue(const nsAString& aNodeValue)
    1: {
    1:   // The DOM spec says that when nodeValue is defined to be null "setting it
    1:   // has no effect", so we don't throw an exception.
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::GetNodeType(PRUint16* aNodeType)
    1: {
    1:   *aNodeType = (PRUint16)nsIDOMNode::ELEMENT_NODE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::GetNamespaceURI(nsAString& aNamespaceURI)
    1: {
    1:   return mNodeInfo->GetNamespaceURI(aNamespaceURI);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::GetPrefix(nsAString& aPrefix)
    1: {
    1:   mNodeInfo->GetPrefix(aPrefix);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::SetPrefix(const nsAString& aPrefix)
    1: {
    1:   // XXX: Validate the prefix string!
    1: 
    1:   nsCOMPtr<nsIAtom> prefix;
    1: 
    1:   if (!aPrefix.IsEmpty()) {
    1:     prefix = do_GetAtom(aPrefix);
    1:     NS_ENSURE_TRUE(prefix, NS_ERROR_OUT_OF_MEMORY);
    1:   }
    1: 
    1:   if (!nsContentUtils::IsValidNodeName(mNodeInfo->NameAtom(), prefix,
    1:                                        mNodeInfo->NamespaceID())) {
    1:     return NS_ERROR_DOM_NAMESPACE_ERR;
    1:   }
    1: 
    1:   nsCOMPtr<nsINodeInfo> newNodeInfo;
    1:   nsresult rv = nsContentUtils::PrefixChanged(mNodeInfo, prefix,
    1:                                               getter_AddRefs(newNodeInfo));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   mNodeInfo = newNodeInfo;
    1: 
    1:   return NS_OK;
    1: }
    1: 
41905: static already_AddRefed<nsIDOMNSFeatureFactory>
41905: GetDOMFeatureFactory(const nsAString& aFeature, const nsAString& aVersion)
41901: {
41901:   nsIDOMNSFeatureFactory *factory = nsnull;
41901:   nsCOMPtr<nsICategoryManager> categoryManager =
41901:     do_GetService(NS_CATEGORYMANAGER_CONTRACTID);
41901:   if (categoryManager) {
41901:     nsCAutoString featureCategory(NS_DOMNS_FEATURE_PREFIX);
41901:     AppendUTF16toUTF8(aFeature, featureCategory);
41901:     nsXPIDLCString contractID;
41901:     nsresult rv = categoryManager->GetCategoryEntry(featureCategory.get(),
41901:                                                     NS_ConvertUTF16toUTF8(aVersion).get(),
41901:                                                     getter_Copies(contractID));
41901:     if (NS_SUCCEEDED(rv)) {
41901:       CallGetService(contractID.get(), &factory);  // addrefs
41901:     }
41901:   }
41901:   return factory;
41901: }
41901: 
    1: nsresult
    1: nsGenericElement::InternalIsSupported(nsISupports* aObject,
    1:                                       const nsAString& aFeature,
    1:                                       const nsAString& aVersion,
    1:                                       PRBool* aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aReturn);
    1:   *aReturn = PR_FALSE;
    1: 
    1:   // Convert the incoming UTF16 strings to raw char*'s to save us some
    1:   // code when doing all those string compares.
    1:   NS_ConvertUTF16toUTF8 feature(aFeature);
    1:   NS_ConvertUTF16toUTF8 version(aVersion);
    1: 
    1:   const char *f = feature.get();
    1:   const char *v = version.get();
    1: 
    1:   if (PL_strcasecmp(f, "XML") == 0 ||
    1:       PL_strcasecmp(f, "HTML") == 0) {
    1:     if (aVersion.IsEmpty() ||
    1:         PL_strcmp(v, "1.0") == 0 ||
    1:         PL_strcmp(v, "2.0") == 0) {
    1:       *aReturn = PR_TRUE;
    1:     }
    1:   } else if (PL_strcasecmp(f, "Views") == 0 ||
    1:              PL_strcasecmp(f, "StyleSheets") == 0 ||
    1:              PL_strcasecmp(f, "Core") == 0 ||
    1:              PL_strcasecmp(f, "CSS") == 0 ||
    1:              PL_strcasecmp(f, "CSS2") == 0 ||
    1:              PL_strcasecmp(f, "Events") == 0 ||
    1:              PL_strcasecmp(f, "UIEvents") == 0 ||
    1:              PL_strcasecmp(f, "MouseEvents") == 0 ||
    1:              // Non-standard!
    1:              PL_strcasecmp(f, "MouseScrollEvents") == 0 ||
    1:              PL_strcasecmp(f, "HTMLEvents") == 0 ||
    1:              PL_strcasecmp(f, "Range") == 0 ||
    1:              PL_strcasecmp(f, "XHTML") == 0) {
    1:     if (aVersion.IsEmpty() ||
    1:         PL_strcmp(v, "2.0") == 0) {
    1:       *aReturn = PR_TRUE;
    1:     }
    1:   } else if (PL_strcasecmp(f, "XPath") == 0) {
    1:     if (aVersion.IsEmpty() ||
    1:         PL_strcmp(v, "3.0") == 0) {
    1:       *aReturn = PR_TRUE;
    1:     }
    1:   }
    1: #ifdef MOZ_SVG
    1:   else if (PL_strcasecmp(f, "SVGEvents") == 0 ||
    1:            PL_strcasecmp(f, "SVGZoomEvents") == 0 ||
28081:            nsSVGFeatures::HaveFeature(aFeature)) {
    1:     if (aVersion.IsEmpty() ||
    1:         PL_strcmp(v, "1.0") == 0 ||
    1:         PL_strcmp(v, "1.1") == 0) {
    1:       *aReturn = PR_TRUE;
    1:     }
    1:   }
    1: #endif /* MOZ_SVG */
23697: #ifdef MOZ_SMIL
25961:   else if (NS_SMILEnabled() && PL_strcasecmp(f, "TimeControl") == 0) {
23697:     if (aVersion.IsEmpty() || PL_strcmp(v, "1.0") == 0) {
23697:       *aReturn = PR_TRUE;
23697:     }
23697:   }
23697: #endif /* MOZ_SMIL */
    1:   else {
    1:     nsCOMPtr<nsIDOMNSFeatureFactory> factory =
    1:       GetDOMFeatureFactory(aFeature, aVersion);
    1: 
    1:     if (factory) {
    1:       factory->HasFeature(aObject, aFeature, aVersion, aReturn);
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
41905: nsINode::GetFeature(const nsAString& aFeature,
    1:                     const nsAString& aVersion,
    1:                     nsISupports** aReturn)
    1: {
    1:   *aReturn = nsnull;
    1:   nsCOMPtr<nsIDOMNSFeatureFactory> factory =
    1:     GetDOMFeatureFactory(aFeature, aVersion);
    1: 
    1:   if (factory) {
41905:     factory->GetFeature(this, aFeature, aVersion, aReturn);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::IsSupported(const nsAString& aFeature,
    1:                               const nsAString& aVersion,
    1:                               PRBool* aReturn)
    1: {
    1:   return InternalIsSupported(this, aFeature, aVersion, aReturn);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::HasAttributes(PRBool* aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aReturn);
    1: 
    1:   *aReturn = GetAttrCount() > 0;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::GetAttributes(nsIDOMNamedNodeMap** aAttributes)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aAttributes);
    1:   nsDOMSlots *slots = GetDOMSlots();
    1: 
    1:   if (!slots) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   if (!slots->mAttributeMap) {
    1:     slots->mAttributeMap = new nsDOMAttributeMap(this);
    1:     if (!slots->mAttributeMap) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:     if (!slots->mAttributeMap->Init()) {
    1:       slots->mAttributeMap = nsnull;
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:   }
    1: 
    1:   NS_ADDREF(*aAttributes = slots->mAttributeMap);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::HasChildNodes(PRBool* aReturn)
    1: {
    1:   *aReturn = mAttrsAndChildren.ChildCount() > 0;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::GetTagName(nsAString& aTagName)
    1: {
    1:   mNodeInfo->GetQualifiedName(aTagName);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::GetAttribute(const nsAString& aName,
    1:                                nsAString& aReturn)
    1: {
    1:   const nsAttrName* name = InternalGetExistingAttrNameFromQName(aName);
    1: 
    1:   if (!name) {
    1:     if (mNodeInfo->NamespaceID() == kNameSpaceID_XUL) {
    1:       // XXX should be SetDOMStringToNull(aReturn);
    1:       // See bug 232598
    1:       aReturn.Truncate();
    1:     }
    1:     else {
    1:       SetDOMStringToNull(aReturn);
    1:     }
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   GetAttr(name->NamespaceID(), name->LocalName(), aReturn);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::SetAttribute(const nsAString& aName,
    1:                                const nsAString& aValue)
    1: {
    1:   const nsAttrName* name = InternalGetExistingAttrNameFromQName(aName);
    1: 
    1:   if (!name) {
    1:     nsresult rv = nsContentUtils::CheckQName(aName, PR_FALSE);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     nsCOMPtr<nsIAtom> nameAtom = do_GetAtom(aName);
    1:     NS_ENSURE_TRUE(nameAtom, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     return SetAttr(kNameSpaceID_None, nameAtom, aValue, PR_TRUE);
    1:   }
    1: 
    1:   return SetAttr(name->NamespaceID(), name->LocalName(), name->GetPrefix(),
    1:                  aValue, PR_TRUE);
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::RemoveAttribute(const nsAString& aName)
    1: {
    1:   const nsAttrName* name = InternalGetExistingAttrNameFromQName(aName);
    1: 
    1:   if (!name) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Hold a strong reference here so that the atom or nodeinfo doesn't go
    1:   // away during UnsetAttr. If it did UnsetAttr would be left with a
    1:   // dangling pointer as argument without knowing it.
    1:   nsAttrName tmp(*name);
    1: 
    1:   return UnsetAttr(name->NamespaceID(), name->LocalName(), PR_TRUE);
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::GetAttributeNode(const nsAString& aName,
    1:                                    nsIDOMAttr** aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aReturn);
    1:   *aReturn = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMNamedNodeMap> map;
    1:   nsresult rv = GetAttributes(getter_AddRefs(map));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   rv = map->GetNamedItem(aName, getter_AddRefs(node));
    1: 
    1:   if (NS_SUCCEEDED(rv) && node) {
    1:     rv = CallQueryInterface(node, aReturn);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::SetAttributeNode(nsIDOMAttr* aAttribute,
    1:                                    nsIDOMAttr** aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aReturn);
    1:   NS_ENSURE_ARG_POINTER(aAttribute);
    1: 
    1:   *aReturn = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMNamedNodeMap> map;
    1:   nsresult rv = GetAttributes(getter_AddRefs(map));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIDOMNode> returnNode;
    1:   rv = map->SetNamedItem(aAttribute, getter_AddRefs(returnNode));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (returnNode) {
    1:     rv = CallQueryInterface(returnNode, aReturn);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::RemoveAttributeNode(nsIDOMAttr* aAttribute,
    1:                                       nsIDOMAttr** aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aReturn);
    1:   NS_ENSURE_ARG_POINTER(aAttribute);
    1: 
    1:   *aReturn = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMNamedNodeMap> map;
    1:   nsresult rv = GetAttributes(getter_AddRefs(map));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsAutoString name;
    1: 
    1:   rv = aAttribute->GetName(name);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     nsCOMPtr<nsIDOMNode> node;
    1:     rv = map->RemoveNamedItem(name, getter_AddRefs(node));
    1: 
    1:     if (NS_SUCCEEDED(rv) && node) {
    1:       rv = CallQueryInterface(node, aReturn);
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::GetElementsByTagName(const nsAString& aTagname,
    1:                                        nsIDOMNodeList** aReturn)
    1: {
    1:   nsCOMPtr<nsIAtom> nameAtom = do_GetAtom(aTagname);
    1:   NS_ENSURE_TRUE(nameAtom, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   nsContentList *list = NS_GetContentList(this, nameAtom,
    1:                                           kNameSpaceID_Unknown).get();
    1:   NS_ENSURE_TRUE(list, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // transfer ref to aReturn
    1:   *aReturn = list;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::GetAttributeNS(const nsAString& aNamespaceURI,
    1:                                  const nsAString& aLocalName,
    1:                                  nsAString& aReturn)
    1: {
    1:   PRInt32 nsid =
    1:     nsContentUtils::NameSpaceManager()->GetNameSpaceID(aNamespaceURI);
    1: 
    1:   if (nsid == kNameSpaceID_Unknown) {
    1:     // Unknown namespace means no attr...
    1: 
    1:     aReturn.Truncate();
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIAtom> name = do_GetAtom(aLocalName);
    1:   GetAttr(nsid, name, aReturn);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::SetAttributeNS(const nsAString& aNamespaceURI,
    1:                                  const nsAString& aQualifiedName,
    1:                                  const nsAString& aValue)
    1: {
    1:   nsCOMPtr<nsINodeInfo> ni;
    1:   nsresult rv =
    1:     nsContentUtils::GetNodeInfoFromQName(aNamespaceURI, aQualifiedName,
    1:                                          mNodeInfo->NodeInfoManager(),
    1:                                          getter_AddRefs(ni));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return SetAttr(ni->NamespaceID(), ni->NameAtom(), ni->GetPrefixAtom(),
    1:                  aValue, PR_TRUE);
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::RemoveAttributeNS(const nsAString& aNamespaceURI,
    1:                                     const nsAString& aLocalName)
    1: {
    1:   nsCOMPtr<nsIAtom> name = do_GetAtom(aLocalName);
    1:   PRInt32 nsid =
    1:     nsContentUtils::NameSpaceManager()->GetNameSpaceID(aNamespaceURI);
    1: 
    1:   if (nsid == kNameSpaceID_Unknown) {
    1:     // Unknown namespace means no attr...
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsAutoString tmp;
    1:   UnsetAttr(nsid, name, PR_TRUE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::GetAttributeNodeNS(const nsAString& aNamespaceURI,
    1:                                      const nsAString& aLocalName,
    1:                                      nsIDOMAttr** aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aReturn);
    1: 
    1:   *aReturn = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMNamedNodeMap> map;
    1:   nsresult rv = GetAttributes(getter_AddRefs(map));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   rv = map->GetNamedItemNS(aNamespaceURI, aLocalName, getter_AddRefs(node));
    1: 
    1:   if (NS_SUCCEEDED(rv) && node) {
    1:     rv = CallQueryInterface(node, aReturn);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::SetAttributeNodeNS(nsIDOMAttr* aNewAttr,
    1:                                      nsIDOMAttr** aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aReturn);
    1:   NS_ENSURE_ARG_POINTER(aNewAttr);
    1: 
    1:   *aReturn = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMNamedNodeMap> map;
    1:   nsresult rv = GetAttributes(getter_AddRefs(map));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIDOMNode> returnNode;
    1:   rv = map->SetNamedItemNS(aNewAttr, getter_AddRefs(returnNode));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (returnNode) {
    1:     rv = CallQueryInterface(returnNode, aReturn);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::GetElementsByTagNameNS(const nsAString& aNamespaceURI,
    1:                                          const nsAString& aLocalName,
    1:                                          nsIDOMNodeList** aReturn)
    1: {
    1:   PRInt32 nameSpaceId = kNameSpaceID_Wildcard;
    1: 
    1:   if (!aNamespaceURI.EqualsLiteral("*")) {
    1:     nsresult rv =
    1:       nsContentUtils::NameSpaceManager()->RegisterNameSpace(aNamespaceURI,
    1:                                                             nameSpaceId);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   nsCOMPtr<nsIAtom> nameAtom = do_GetAtom(aLocalName);
    1:   NS_ENSURE_TRUE(nameAtom, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   nsContentList *list = NS_GetContentList(this, nameAtom, nameSpaceId).get();
    1:   NS_ENSURE_TRUE(list, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // transfer ref to aReturn
    1:   *aReturn = list;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::HasAttribute(const nsAString& aName, PRBool* aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aReturn);
    1: 
    1:   const nsAttrName* name = InternalGetExistingAttrNameFromQName(aName);
    1:   *aReturn = (name != nsnull);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::HasAttributeNS(const nsAString& aNamespaceURI,
    1:                                  const nsAString& aLocalName,
    1:                                  PRBool* aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aReturn);
    1: 
    1:   PRInt32 nsid =
    1:     nsContentUtils::NameSpaceManager()->GetNameSpaceID(aNamespaceURI);
    1: 
    1:   if (nsid == kNameSpaceID_Unknown) {
    1:     // Unknown namespace means no attr...
    1: 
    1:     *aReturn = PR_FALSE;
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIAtom> name = do_GetAtom(aLocalName);
    1:   *aReturn = HasAttr(nsid, name);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::JoinTextNodes(nsIContent* aFirst,
    1:                                 nsIContent* aSecond)
    1: {
    1:   nsresult rv = NS_OK;
    1:   nsCOMPtr<nsIDOMText> firstText(do_QueryInterface(aFirst, &rv));
    1: 
    1:   if (NS_SUCCEEDED(rv)) {
    1:     nsCOMPtr<nsIDOMText> secondText(do_QueryInterface(aSecond, &rv));
    1: 
    1:     if (NS_SUCCEEDED(rv)) {
    1:       nsAutoString str;
    1: 
    1:       rv = secondText->GetData(str);
    1:       if (NS_SUCCEEDED(rv)) {
    1:         rv = firstText->AppendData(str);
    1:       }
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::Normalize()
    1: {
   62:   // Batch possible DOMSubtreeModified events.
   62:   mozAutoSubtreeModified subtree(GetOwnerDoc(), nsnull);
   62: 
    1:   nsresult result = NS_OK;
    1:   PRUint32 index, count = GetChildCount();
    1: 
    1:   for (index = 0; (index < count) && (NS_OK == result); index++) {
    1:     nsIContent *child = GetChildAt(index);
    1: 
    1:     nsCOMPtr<nsIDOMNode> node = do_QueryInterface(child);
    1:     if (node) {
    1:       PRUint16 nodeType;
    1:       node->GetNodeType(&nodeType);
    1: 
    1:       switch (nodeType) {
    1:         case nsIDOMNode::TEXT_NODE:
    1: 
    1:           // ensure that if the text node is empty, it is removed
    1:           if (0 == child->TextLength()) {
    1:             result = RemoveChildAt(index, PR_TRUE);
    1:             if (NS_FAILED(result)) {
    1:               return result;
    1:             }
    1: 
    1:             count--;
    1:             index--;
    1:             break;
    1:           }
    1:  
    1:           if (index+1 < count) {
    1:             // Get the sibling. If it's also a text node, then
    1:             // remove it from the tree and join the two text
    1:             // nodes.
    1:             nsIContent *sibling = GetChildAt(index + 1);
    1: 
    1:             nsCOMPtr<nsIDOMNode> siblingNode = do_QueryInterface(sibling);
    1: 
    1:             if (siblingNode) {
    1:               PRUint16 siblingNodeType;
    1:               siblingNode->GetNodeType(&siblingNodeType);
    1: 
    1:               if (siblingNodeType == nsIDOMNode::TEXT_NODE) {
    1:                 result = RemoveChildAt(index+1, PR_TRUE);
    1:                 if (NS_FAILED(result)) {
    1:                   return result;
    1:                 }
    1: 
    1:                 result = JoinTextNodes(child, sibling);
    1:                 if (NS_FAILED(result)) {
    1:                   return result;
    1:                 }
    1:                 count--;
    1:                 index--;
    1:               }
    1:             }
    1:           }
    1:           break;
    1: 
    1:         case nsIDOMNode::ELEMENT_NODE:
    1:           nsCOMPtr<nsIDOMElement> element = do_QueryInterface(child);
    1: 
    1:           if (element) {
    1:             result = element->Normalize();
    1:           }
    1:           break;
    1:       }
    1:     }
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
 1685: static nsXBLBinding*
 1685: GetFirstBindingWithContent(nsBindingManager* aBmgr, nsIContent* aBoundElem)
 1685: {
 1685:   nsXBLBinding* binding = aBmgr->GetBinding(aBoundElem);
 1685:   while (binding) {
 1685:     if (binding->GetAnonymousContent()) {
 1685:       return binding;
 1685:     }
 1685:     binding = binding->GetBaseBinding();
 1685:   }
 1685:   
 1685:   return nsnull;
 1685: }
 1685: 
 1728: static nsresult
 1728: BindNodesInInsertPoints(nsXBLBinding* aBinding, nsIContent* aInsertParent,
 1728:                         nsIDocument* aDocument)
 1728: {
 1728:   NS_PRECONDITION(aBinding && aInsertParent, "Missing arguments");
 1728: 
 1728:   nsresult rv;
 1728:   // These should be refcounted or otherwise protectable.
 1728:   nsInsertionPointList* inserts =
 1728:     aBinding->GetExistingInsertionPointsFor(aInsertParent);
 1728:   if (inserts) {
 1728:     PRBool allowScripts = aBinding->AllowScripts();
 3244: #ifdef MOZ_XUL
 1839:     nsCOMPtr<nsIXULDocument> xulDoc = do_QueryInterface(aDocument);
 3244: #endif
 1728:     PRUint32 i;
 1728:     for (i = 0; i < inserts->Length(); ++i) {
 1728:       nsCOMPtr<nsIContent> insertRoot =
 1728:         inserts->ElementAt(i)->GetDefaultContent();
 1728:       if (insertRoot) {
 1728:         PRUint32 j;
 1728:         for (j = 0; j < insertRoot->GetChildCount(); ++j) {
 1728:           nsCOMPtr<nsIContent> child = insertRoot->GetChildAt(j);
 1728:           rv = child->BindToTree(aDocument, aInsertParent,
 1728:                                  aBinding->GetBoundElement(), allowScripts);
 1728:           NS_ENSURE_SUCCESS(rv, rv);
 1839: 
 3244: #ifdef MOZ_XUL
 1839:           if (xulDoc) {
 1839:             xulDoc->AddSubtreeToDocument(child);
 1839:           }
 3244: #endif
 1728:         }
 1728:       }
 1728:     }
 1728:   }
 1728: 
 1728:   return NS_OK;
 1728: }
 1728: 
    1: nsresult
    1: nsGenericElement::BindToTree(nsIDocument* aDocument, nsIContent* aParent,
    1:                              nsIContent* aBindingParent,
    1:                              PRBool aCompileEventHandlers)
    1: {
    1:   NS_PRECONDITION(aParent || aDocument, "Must have document if no parent!");
    1:   NS_PRECONDITION(HasSameOwnerDoc(NODE_FROM(aParent, aDocument)),
    1:                   "Must have the same owner document");
 1498:   NS_PRECONDITION(!aParent || aDocument == aParent->GetCurrentDoc(),
    1:                   "aDocument must be current doc of aParent");
    1:   NS_PRECONDITION(!GetCurrentDoc(), "Already have a document.  Unbind first!");
    1:   // Note that as we recurse into the kids, they'll have a non-null parent.  So
    1:   // only assert if our parent is _changing_ while we have a parent.
    1:   NS_PRECONDITION(!GetParent() || aParent == GetParent(),
    1:                   "Already have a parent.  Unbind first!");
    1:   NS_PRECONDITION(!GetBindingParent() ||
    1:                   aBindingParent == GetBindingParent() ||
    1:                   (!aBindingParent && aParent &&
    1:                    aParent->GetBindingParent() == GetBindingParent()),
    1:                   "Already have a binding parent.  Unbind first!");
 1685:   NS_PRECONDITION(!aParent || !aDocument ||
 1685:                   !aParent->HasFlag(NODE_FORCE_XBL_BINDINGS),
 1685:                   "Parent in document but flagged as forcing XBL");
16126:   NS_PRECONDITION(aBindingParent != this,
16126:                   "Content must not be its own binding parent");
16126:   NS_PRECONDITION(!IsRootOfNativeAnonymousSubtree() ||
16126:                   aBindingParent == aParent,
16126:                   "Native anonymous content must have its parent as its "
12250:                   "own binding parent");
    1: 
    1:   if (!aBindingParent && aParent) {
    1:     aBindingParent = aParent->GetBindingParent();
    1:   }
    1: 
 3244: #ifdef MOZ_XUL
    1:   // First set the binding parent
 1498:   nsXULElement* xulElem = nsXULElement::FromContent(this);
 1498:   if (xulElem) {
 1498:     xulElem->SetXULBindingParent(aBindingParent);
 1498:   }
 3244:   else 
 3244: #endif
 3244:   {
    1:     if (aBindingParent) {
    1:       nsDOMSlots *slots = GetDOMSlots();
    1: 
    1:       if (!slots) {
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:       }
    1: 
    1:       slots->mBindingParent = aBindingParent; // Weak, so no addref happens.
    1:     }
 1498:   }
16126:   NS_ASSERTION(!aBindingParent || IsRootOfNativeAnonymousSubtree() ||
14239:                !HasFlag(NODE_IS_IN_ANONYMOUS_SUBTREE) ||
22217:                (aParent && aParent->IsInNativeAnonymousSubtree()),
14239:                "Trying to re-bind content from native anonymous subtree to "
14239:                "non-native anonymous parent!");
25511:   if (aParent && aParent->IsInNativeAnonymousSubtree()) {
14239:     SetFlags(NODE_IS_IN_ANONYMOUS_SUBTREE);
14239:   }
 1498: 
 1685:   PRBool hadForceXBL = HasFlag(NODE_FORCE_XBL_BINDINGS);
 1685: 
 1498:   // Now set the parent and set the "Force attach xbl" flag if needed.
    1:   if (aParent) {
 3233:     mParentPtrBits = reinterpret_cast<PtrBits>(aParent) | PARENT_BIT_PARENT_IS_CONTENT;
 1498: 
 1498:     if (aParent->HasFlag(NODE_FORCE_XBL_BINDINGS)) {
 1498:       SetFlags(NODE_FORCE_XBL_BINDINGS);
 1498:     }
    1:   }
    1:   else {
 3233:     mParentPtrBits = reinterpret_cast<PtrBits>(aDocument);
    1:   }
    1: 
    1:   // XXXbz sXBL/XBL2 issue!
    1: 
    1:   // Finally, set the document
    1:   if (aDocument) {
    1:     // Notify XBL- & nsIAnonymousContentCreator-generated
    1:     // anonymous content that the document is changing.
    1:     // XXXbz ordering issues here?  Probably not, since ChangeDocumentFor is
    1:     // just pretty broken anyway....  Need to get it working.
    1:     // XXXbz XBL doesn't handle this (asserts), and we don't really want
    1:     // to be doing this during parsing anyway... sort this out.    
    1:     //    aDocument->BindingManager()->ChangeDocumentFor(this, nsnull,
    1:     //                                                   aDocument);
    1: 
    1:     // Being added to a document.
    1:     mParentPtrBits |= PARENT_BIT_INDOCUMENT;
 1498: 
 1498:     // Unset this flag since we now really are in a document.
40938:     UnsetFlags(NODE_FORCE_XBL_BINDINGS |
40938:                // And clear the lazy frame construction bits.
40938:                NODE_NEEDS_FRAME | NODE_DESCENDANTS_NEED_FRAMES);
    1:   }
    1: 
 1685:   // If NODE_FORCE_XBL_BINDINGS was set we might have anonymous children
 1685:   // that also need to be told that they are moving.
 1685:   nsresult rv;
 1685:   if (hadForceXBL) {
 1685:     nsIDocument* ownerDoc = GetOwnerDoc();
 1685:     if (ownerDoc) {
 1685:       nsBindingManager* bmgr = ownerDoc->BindingManager();
 1685: 
 1685:       // First check if we have a binding...
 1685:       nsXBLBinding* contBinding =
 1685:         GetFirstBindingWithContent(bmgr, this);
 1685:       if (contBinding) {
 1685:         nsCOMPtr<nsIContent> anonRoot = contBinding->GetAnonymousContent();
 1685:         PRBool allowScripts = contBinding->AllowScripts();
 1685:         PRUint32 i;
 1685:         for (i = 0; i < anonRoot->GetChildCount(); ++i) {
 1685:           nsCOMPtr<nsIContent> child = anonRoot->GetChildAt(i);
 1685:           rv = child->BindToTree(aDocument, this, this, allowScripts);
 1685:           NS_ENSURE_SUCCESS(rv, rv);
 1685:         }
 1728: 
 1728:         // ...then check if we have content in insertion points that are
 1728:         // direct children of the <content>
 1728:         rv = BindNodesInInsertPoints(contBinding, this, aDocument);
 1728:         NS_ENSURE_SUCCESS(rv, rv);
 1728:       }
 1728: 
 1728:       // ...and finally check if we're in a binding where we have content in
 1728:       // insertion points.
 1685:       if (aBindingParent) {
 1685:         nsXBLBinding* binding = bmgr->GetBinding(aBindingParent);
 1685:         if (binding) {
 1728:           rv = BindNodesInInsertPoints(binding, this, aDocument);
 1685:           NS_ENSURE_SUCCESS(rv, rv);
 1685:         }
 1685:       }
 1685:     }
 1685:   }
 1685: 
 2896:   UpdateEditableState();
 2896: 
    1:   // Now recurse into our kids
    1:   PRUint32 i;
 1498:   // Don't call GetChildCount() here since that'll make XUL generate
 1498:   // template children, which we're not in a consistent enough state for.
 1498:   // Additionally, there's not really a need to generate the children here.
 1498:   for (i = 0; i < mAttrsAndChildren.ChildCount(); ++i) {
    1:     // The child can remove itself from the parent in BindToTree.
    1:     nsCOMPtr<nsIContent> child = mAttrsAndChildren.ChildAt(i);
    1:     rv = child->BindToTree(aDocument, this, aBindingParent,
    1:                            aCompileEventHandlers);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   nsNodeUtils::ParentChainChanged(this);
    1: 
    1:   // XXXbz script execution during binding can trigger some of these
    1:   // postcondition asserts....  But we do want that, since things will
    1:   // generally be quite broken when that happens.
    1:   NS_POSTCONDITION(aDocument == GetCurrentDoc(), "Bound to wrong document");
    1:   NS_POSTCONDITION(aParent == GetParent(), "Bound to wrong parent");
    1:   NS_POSTCONDITION(aBindingParent == GetBindingParent(),
    1:                    "Bound to wrong binding parent");
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsGenericElement::UnbindFromTree(PRBool aDeep, PRBool aNullParent)
    1: {
    1:   NS_PRECONDITION(aDeep || (!GetCurrentDoc() && !GetBindingParent()),
    1:                   "Shallow unbind won't clear document and binding parent on "
    1:                   "kids!");
    1:   // Make sure to unbind this node before doing the kids
 6167:   nsIDocument *document =
 6167:     HasFlag(NODE_FORCE_XBL_BINDINGS) ? GetOwnerDoc() : GetCurrentDoc();
24671: 
24671:   mParentPtrBits = aNullParent ? 0 : mParentPtrBits & ~PARENT_BIT_INDOCUMENT;
24671: 
    1:   if (document) {
    1:     // Notify XBL- & nsIAnonymousContentCreator-generated
    1:     // anonymous content that the document is changing.
    1:     document->BindingManager()->ChangeDocumentFor(this, document, nsnull);
    1: 
11838:     document->ClearBoxObjectFor(this);
    1:   }
    1: 
33649:   // Ensure that CSS transitions don't continue on an element at a
33649:   // different place in the tree (even if reinserted before next
33649:   // animation refresh).
33896:   // FIXME (Bug 522599): Need a test for this.
33649:   if (HasFlag(NODE_HAS_PROPERTIES)) {
33649:     DeleteProperty(nsGkAtoms::transitionsOfBeforeProperty);
33649:     DeleteProperty(nsGkAtoms::transitionsOfAfterProperty);
33649:     DeleteProperty(nsGkAtoms::transitionsProperty);
33649:   }
33649: 
 1498:   // Unset this since that's what the old code effectively did.
 1498:   UnsetFlags(NODE_FORCE_XBL_BINDINGS);
 1498:   
 3244: #ifdef MOZ_XUL
 1498:   nsXULElement* xulElem = nsXULElement::FromContent(this);
 1498:   if (xulElem) {
 1498:     xulElem->SetXULBindingParent(nsnull);
 1498:   }
 3244:   else
 3244: #endif
 3244:   {
    1:     nsDOMSlots *slots = GetExistingDOMSlots();
    1:     if (slots) {
    1:       slots->mBindingParent = nsnull;
    1:     }
 1498:   }
    1: 
    1:   if (aDeep) {
 1498:     // Do the kids. Don't call GetChildCount() here since that'll force
 1498:     // XUL to generate template children, which there is no need for since
 1498:     // all we're going to do is unbind them anyway.
 1498:     PRUint32 i, n = mAttrsAndChildren.ChildCount();
    1: 
    1:     for (i = 0; i < n; ++i) {
    1:       // Note that we pass PR_FALSE for aNullParent here, since we don't want
    1:       // the kids to forget us.  We _do_ want them to forget their binding
    1:       // parent, though, since this only walks non-anonymous kids.
    1:       mAttrsAndChildren.ChildAt(i)->UnbindFromTree(PR_TRUE, PR_FALSE);
    1:     }
    1:   }
    1: 
    1:   nsNodeUtils::ParentChainChanged(this);
    1: }
    1: 
38069: already_AddRefed<nsINodeList>
38069: nsGenericElement::GetChildren(PRInt32 aChildType)
38069: {
38069:   nsRefPtr<nsBaseContentList> list = new nsBaseContentList();
38069:   if (!list) {
38069:     return nsnull;
38069:   }
38069: 
38069:   nsIFrame *frame = GetPrimaryFrame();
38069: 
38069:   // Append :before generated content.
38069:   if (frame) {
38069:     nsIFrame *beforeFrame = nsLayoutUtils::GetBeforeFrame(frame);
38069:     if (beforeFrame) {
38357:       list->AppendElement(beforeFrame->GetContent());
38069:     }
38069:   }
38069: 
38069:   // If XBL is bound to this node then append XBL anonymous content including
38069:   // explict content altered by insertion point if we were requested for XBL
38069:   // anonymous content, otherwise append explicit content with respect to
38069:   // insertion point if any.
38069:   nsINodeList *childList = nsnull;
38069: 
38069:   nsIDocument* document = GetOwnerDoc();
38069:   if (document) {
38069:     if (aChildType != eAllButXBL) {
38069:       childList = document->BindingManager()->GetXBLChildNodesFor(this);
38069:       if (!childList) {
38069:         childList = GetChildNodesList();
38069:       }
38069: 
38069:     } else {
38069:       childList = document->BindingManager()->GetContentListFor(this);
38069:     }
38069:   } else {
38069:     childList = GetChildNodesList();
38069:   }
38069: 
38069:   if (childList) {
38069:     PRUint32 length = 0;
38069:     childList->GetLength(&length);
38069:     for (PRUint32 idx = 0; idx < length; idx++) {
38069:       nsIContent* child = childList->GetNodeAt(idx);
38069:       list->AppendElement(child);
38069:     }
38069:   }
38069: 
38069:   if (frame) {
38069:     // Append native anonymous content to the end.
38069:     nsIAnonymousContentCreator* creator = do_QueryFrame(frame);
38069:     if (creator) {
38357:       creator->AppendAnonymousContentTo(*list);
38069:     }
38069: 
38069:     // Append :after generated content.
38069:     nsIFrame *afterFrame = nsLayoutUtils::GetAfterFrame(frame);
38069:     if (afterFrame) {
38357:       list->AppendElement(afterFrame->GetContent());
38069:     }
38069:   }
38069: 
38069:   nsINodeList* returnList = nsnull;
38069:   list.forget(&returnList);
38069:   return returnList;
38069: }
38069: 
38069: 
    1: nsresult
    1: nsGenericElement::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
    1: {
    1:   return nsGenericElement::doPreHandleEvent(this, aVisitor);
    1: }
    1: 
12925: static nsIContent*
15478: FindNativeAnonymousSubtreeOwner(nsIContent* aContent)
12925: {
15478:   if (aContent->IsInNativeAnonymousSubtree()) {
15478:     PRBool isNativeAnon = PR_FALSE;
15478:     while (aContent && !isNativeAnon) {
16126:       isNativeAnon = aContent->IsRootOfNativeAnonymousSubtree();
12925:       aContent = aContent->GetParent();
12925:     }
15478:   }
12925:   return aContent;
12925: }
12925: 
    1: nsresult
    1: nsGenericElement::doPreHandleEvent(nsIContent* aContent,
    1:                                    nsEventChainPreVisitor& aVisitor)
    1: {
    1:   //FIXME! Document how this event retargeting works, Bug 329124.
    1:   aVisitor.mCanHandle = PR_TRUE;
36461:   aVisitor.mMayHaveListenerManager =
36461:     aContent->HasFlag(NODE_HAS_LISTENERMANAGER);
 1401: 
 1401:   // Don't propagate mouseover and mouseout events when mouse is moving
 1401:   // inside native anonymous content.
16126:   PRBool isAnonForEvents = aContent->IsRootOfNativeAnonymousSubtree();
15478:   if ((aVisitor.mEvent->message == NS_MOUSE_ENTER_SYNTH ||
15478:        aVisitor.mEvent->message == NS_MOUSE_EXIT_SYNTH) &&
18444:       // Check if we should stop event propagation when event has just been
18444:       // dispatched or when we're about to propagate from
18444:       // native anonymous subtree.
18444:       ((static_cast<nsISupports*>(aContent) == aVisitor.mEvent->originalTarget &&
18444:         !aContent->IsInNativeAnonymousSubtree()) || isAnonForEvents)) {
 1401:      nsCOMPtr<nsIContent> relatedTarget =
 3233:        do_QueryInterface(static_cast<nsMouseEvent*>
 3233:                                     (aVisitor.mEvent)->relatedTarget);
 1401:     if (relatedTarget &&
 1401:         relatedTarget->GetOwnerDoc() == aContent->GetOwnerDoc()) {
 1401: 
 1401:       // If current target is anonymous for events or we know that related
 1401:       // target is descendant of an element which is anonymous for events,
 1401:       // we may want to stop event propagation.
 1401:       // If aContent is the original target, aVisitor.mRelatedTargetIsInAnon
 1401:       // must be updated.
 1401:       if (isAnonForEvents || aVisitor.mRelatedTargetIsInAnon ||
 1401:           (aVisitor.mEvent->originalTarget == aContent &&
12250:            (aVisitor.mRelatedTargetIsInAnon =
12250:             relatedTarget->IsInNativeAnonymousSubtree()))) {
15478:         nsIContent* anonOwner = FindNativeAnonymousSubtreeOwner(aContent);
15478:         if (anonOwner) {
15478:           nsIContent* anonOwnerRelated =
15478:             FindNativeAnonymousSubtreeOwner(relatedTarget);
15478:           if (anonOwnerRelated) {
15478:             // Note, anonOwnerRelated may still be inside some other
15478:             // native anonymous subtree. The case where anonOwner is still
15478:             // inside native anonymous subtree will be handled when event
15478:             // propagates up in the DOM tree.
15478:             while (anonOwner != anonOwnerRelated &&
15478:                    anonOwnerRelated->IsInNativeAnonymousSubtree()) {
15478:               anonOwnerRelated = FindNativeAnonymousSubtreeOwner(anonOwnerRelated);
15478:             }
15478:             if (anonOwner == anonOwnerRelated) {
18444: #ifdef DEBUG_smaug
18444:               nsCOMPtr<nsIContent> originalTarget =
15478:                 do_QueryInterface(aVisitor.mEvent->originalTarget);
18444:               nsAutoString ot, ct, rt;
18444:               if (originalTarget) {
18444:                 originalTarget->Tag()->ToString(ot);
18444:               }
18444:               aContent->Tag()->ToString(ct);
18444:               relatedTarget->Tag()->ToString(rt);
18444:               printf("Stopping %s propagation:"
18444:                      "\n\toriginalTarget=%s \n\tcurrentTarget=%s %s"
18444:                      "\n\trelatedTarget=%s %s \n%s",
18444:                      (aVisitor.mEvent->message == NS_MOUSE_ENTER_SYNTH)
18444:                        ? "mouseover" : "mouseout",
18444:                      NS_ConvertUTF16toUTF8(ot).get(),
18444:                      NS_ConvertUTF16toUTF8(ct).get(),
18444:                      isAnonForEvents
18444:                        ? "(is native anonymous)"
18444:                        : (aContent->IsInNativeAnonymousSubtree()
18444:                            ? "(is in native anonymous subtree)" : ""),
18444:                      NS_ConvertUTF16toUTF8(rt).get(),
18444:                      relatedTarget->IsInNativeAnonymousSubtree()
18444:                        ? "(is in native anonymous subtree)" : "",
18444:                      (originalTarget && relatedTarget->FindFirstNonNativeAnonymous() ==
18444:                        originalTarget->FindFirstNonNativeAnonymous())
18444:                        ? "" : "Wrong event propagation!?!\n");
18444: #endif
 1401:               aVisitor.mParentTarget = nsnull;
 1401:               // Event should not propagate to non-anon content.
 1401:               aVisitor.mCanHandle = isAnonForEvents;
 1401:               return NS_OK;
 1401:             }
 1401:           }
 1401:         }
 1401:       }
 1593:     }
 1593:   }
 1401: 
22211:   nsIContent* parent = aContent->GetParent();
22211:   // Event may need to be retargeted if aContent is the root of a native
22211:   // anonymous content subtree or event is dispatched somewhere inside XBL.
 1401:   if (isAnonForEvents) {
14239:     // If a DOM event is explicitly dispatched using node.dispatchEvent(), then
14239:     // all the events are allowed even in the native anonymous content..
14239:     NS_ASSERTION(aVisitor.mEvent->eventStructType != NS_MUTATION_EVENT ||
14239:                  aVisitor.mDOMEvent,
14239:                  "Mutation event dispatched in native anonymous content!?!");
    1:     aVisitor.mEventTargetAtParent = parent;
22211:   } else if (parent && aVisitor.mOriginalTargetIsInAnon) {
    1:     nsCOMPtr<nsIContent> content(do_QueryInterface(aVisitor.mEvent->target));
    1:     if (content && content->GetBindingParent() == parent) {
    1:       aVisitor.mEventTargetAtParent = parent;
    1:     }
    1:   }
    1: 
    1:   // check for an anonymous parent
    1:   // XXX XBL2/sXBL issue
40043:   if (aContent->HasFlag(NODE_MAY_BE_IN_BINDING_MNGR)) {
    1:     nsIDocument* ownerDoc = aContent->GetOwnerDoc();
    1:     if (ownerDoc) {
    1:       nsIContent* insertionParent = ownerDoc->BindingManager()->
    1:         GetInsertionParent(aContent);
    1:       NS_ASSERTION(!(aVisitor.mEventTargetAtParent && insertionParent &&
    1:                      aVisitor.mEventTargetAtParent != insertionParent),
    1:                    "Retargeting and having insertion parent!");
    1:       if (insertionParent) {
    1:         parent = insertionParent;
    1:       }
    1:     }
40043:   }
    1: 
    1:   if (parent) {
    1:     aVisitor.mParentTarget = parent;
    1:   } else {
    1:     aVisitor.mParentTarget = aContent->GetCurrentDoc();
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::PostHandleEvent(nsEventChainPostVisitor& /*aVisitor*/)
    1: {
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::DispatchDOMEvent(nsEvent* aEvent,
    1:                                    nsIDOMEvent* aDOMEvent,
    1:                                    nsPresContext* aPresContext,
    1:                                    nsEventStatus* aEventStatus)
    1: {
 3233:   return nsEventDispatcher::DispatchDOMEvent(static_cast<nsIContent*>(this),
    1:                                              aEvent, aDOMEvent,
    1:                                              aPresContext, aEventStatus);
    1: }
    1: 
    1: nsIAtom*
    1: nsGenericElement::GetID() const
    1: {
 6041:   if (!HasFlag(NODE_MAY_HAVE_ID)) {
 6041:     return nsnull;
 6041:   }
 6041: 
 4036:   nsIAtom* IDName = GetIDAttributeName();
    1:   if (IDName) {
 4036:     const nsAttrValue* attrVal = mAttrsAndChildren.GetAttr(IDName);
    1:     if (attrVal){
    1:       if (attrVal->Type() == nsAttrValue::eAtom) {
    1:         return attrVal->GetAtomValue();
    1:       }
    1:       if(attrVal->IsEmptyString()){
    1:         return nsnull;
    1:       }
    1:       // Check if the ID has been stored as a string.
    1:       // This would occur if the ID attribute name changed after 
    1:       // the ID was parsed. 
    1:       if (attrVal->Type() == nsAttrValue::eString) {
    1:         nsAutoString idVal(attrVal->GetStringValue());
    1: 
    1:         // Create an atom from the value and set it into the attribute list. 
 3233:         const_cast<nsAttrValue*>(attrVal)->ParseAtom(idVal);
    1:         return attrVal->GetAtomValue();
    1:       }
    1:     }
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: const nsAttrValue*
19132: nsGenericElement::DoGetClasses() const
19132: {
19132:   NS_NOTREACHED("Shouldn't ever be called");
    1:   return nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::WalkContentStyleRules(nsRuleWalker* aRuleWalker)
    1: {
    1:   return NS_OK;
    1: }
    1: 
32193: #ifdef MOZ_SMIL
32193: nsresult
32193: nsGenericElement::GetSMILOverrideStyle(nsIDOMCSSStyleDeclaration** aStyle)
32193: {
32193:   nsGenericElement::nsDOMSlots *slots = GetDOMSlots();
32193:   NS_ENSURE_TRUE(slots, NS_ERROR_OUT_OF_MEMORY);
32193: 
32193:   if (!slots->mSMILOverrideStyle) {
32193:     slots->mSMILOverrideStyle = new nsDOMCSSAttributeDeclaration(this, PR_TRUE);
32193:     NS_ENSURE_TRUE(slots->mSMILOverrideStyle, NS_ERROR_OUT_OF_MEMORY);
32193:   }
32193: 
32193:   // Why bother with QI?
32193:   NS_ADDREF(*aStyle = slots->mSMILOverrideStyle);
32193:   return NS_OK;
32193: }
32193: 
32193: nsICSSStyleRule*
32193: nsGenericElement::GetSMILOverrideStyleRule()
32193: {
32193:   nsGenericElement::nsDOMSlots *slots = GetExistingDOMSlots();
33018:   return slots ? slots->mSMILOverrideStyleRule.get() : nsnull;
32193: }
32193: 
32193: nsresult
32193: nsGenericElement::SetSMILOverrideStyleRule(nsICSSStyleRule* aStyleRule,
32193:                                            PRBool aNotify)
32193: {
32193:   nsGenericElement::nsDOMSlots *slots = GetDOMSlots();
32193:   NS_ENSURE_TRUE(slots, NS_ERROR_OUT_OF_MEMORY);
32193: 
32193:   slots->mSMILOverrideStyleRule = aStyleRule;
32193: 
32193:   if (aNotify) {
32193:     nsIDocument* doc = GetCurrentDoc();
39316:     // Only need to request a restyle if we're in a document.  (We might not
34033:     // be in a document, if we're clearing animation effects on a target node
34033:     // that's been detached since the previous animation sample.)
34033:     if (doc) {
36917:       nsCOMPtr<nsIPresShell> shell = doc->GetPrimaryShell();
36917:       if (shell) {
39316:         shell->RestyleForAnimation(this);
32193:       }
32193:     }
34033:   }
32193: 
32193:   return NS_OK;
32193: }
32193: #endif // MOZ_SMIL
32193: 
    1: nsICSSStyleRule*
    1: nsGenericElement::GetInlineStyleRule()
    1: {
    1:   return nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGenericElement::SetInlineStyleRule(nsICSSStyleRule* aStyleRule,
    1:                                      PRBool aNotify)
    1: {
    1:   NS_NOTYETIMPLEMENTED("nsGenericElement::SetInlineStyleRule");
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP_(PRBool)
    1: nsGenericElement::IsAttributeMapped(const nsIAtom* aAttribute) const
    1: {
    1:   return PR_FALSE;
    1: }
    1: 
    1: nsChangeHint
    1: nsGenericElement::GetAttributeChangeHint(const nsIAtom* aAttribute,
    1:                                          PRInt32 aModType) const
    1: {
    1:   return nsChangeHint(0);
    1: }
    1: 
    1: nsIAtom *
 4036: nsGenericElement::GetIDAttributeName() const
    1: {
 4036:   return mNodeInfo->GetIDAttributeAtom();
    1: }
    1: 
    1: nsIAtom *
    1: nsGenericElement::GetClassAttributeName() const
    1: {
    1:   return nsnull;
    1: }
    1: 
    1: PRBool
    1: nsGenericElement::FindAttributeDependence(const nsIAtom* aAttribute,
    1:                                           const MappedAttributeEntry* const aMaps[],
    1:                                           PRUint32 aMapCount)
    1: {
    1:   for (PRUint32 mapindex = 0; mapindex < aMapCount; ++mapindex) {
    1:     for (const MappedAttributeEntry* map = aMaps[mapindex];
    1:          map->attribute; ++map) {
    1:       if (aAttribute == *map->attribute) {
    1:         return PR_TRUE;
    1:       }
    1:     }
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: already_AddRefed<nsINodeInfo>
    1: nsGenericElement::GetExistingAttrNameFromQName(const nsAString& aStr) const
    1: {
    1:   const nsAttrName* name = InternalGetExistingAttrNameFromQName(aStr);
    1:   if (!name) {
    1:     return nsnull;
    1:   }
    1: 
    1:   nsINodeInfo* nodeInfo;
    1:   if (name->IsAtom()) {
19197:     nodeInfo = mNodeInfo->NodeInfoManager()->GetNodeInfo(name->Atom(), nsnull,
19197:                                                          kNameSpaceID_None).get();
    1:   }
    1:   else {
    1:     NS_ADDREF(nodeInfo = name->NodeInfo());
    1:   }
    1: 
    1:   return nodeInfo;
    1: }
    1: 
    1: already_AddRefed<nsIURI>
    1: nsGenericElement::GetBaseURI() const
    1: {
    1:   nsIDocument* doc = GetOwnerDoc();
    1:   if (!doc) {
    1:     // We won't be able to do security checks, etc.  So don't go any
    1:     // further.  That said, this really shouldn't happen...
    1:     NS_ERROR("Element without owner document");
    1:     return nsnull;
    1:   }
    1: 
    1:   // Our base URL depends on whether we have an xml:base attribute, as
    1:   // well as on whether any of our ancestors do.
    1:   nsCOMPtr<nsIURI> parentBase;
    1: 
    1:   nsIContent *parent = GetParent();
    1:   if (parent) {
    1:     parentBase = parent->GetBaseURI();
    1:   } else {
    1:     // No parent, so just use the document (we must be the root or not in the
    1:     // tree).
    1:     parentBase = doc->GetBaseURI();
    1:   }
    1:   
    1:   // Now check for an xml:base attr 
    1:   nsAutoString value;
    1:   GetAttr(kNameSpaceID_XML, nsGkAtoms::base, value);
    1:   if (value.IsEmpty()) {
    1:     // No xml:base, so we just use the parent's base URL
41900:     return parentBase.forget();
    1:   }
    1: 
    1:   nsCOMPtr<nsIURI> ourBase;
    1:   nsresult rv = NS_NewURI(getter_AddRefs(ourBase), value,
    1:                           doc->GetDocumentCharacterSet().get(), parentBase);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     // do a security check, almost the same as nsDocument::SetBaseURL()
    1:     rv = nsContentUtils::GetSecurityManager()->
    1:       CheckLoadURIWithPrincipal(NodePrincipal(), ourBase,
    1:                                 nsIScriptSecurityManager::STANDARD);
    1:   }
    1: 
41900:   return NS_SUCCEEDED(rv) ? ourBase.forget() : parentBase.forget();
    1: }
    1: 
    1: PRBool
    1: nsGenericElement::IsLink(nsIURI** aURI) const
    1: {
    1:   *aURI = nsnull;
    1:   return PR_FALSE;
    1: }
    1: 
    1: // static
    1: PRBool
    1: nsGenericElement::ShouldBlur(nsIContent *aContent)
    1: {
    1:   // Determine if the current element is focused, if it is not focused
    1:   // then we should not try to blur
    1:   nsIDocument *document = aContent->GetDocument();
29018:   if (!document)
29018:     return PR_FALSE;
29018: 
29018:   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(document->GetWindow());
29018:   if (!window)
29018:     return PR_FALSE;
29018: 
29018:   nsCOMPtr<nsPIDOMWindow> focusedFrame;
29018:   nsIContent* contentToBlur =
29018:     nsFocusManager::GetFocusedDescendant(window, PR_FALSE, getter_AddRefs(focusedFrame));
29018:   if (contentToBlur == aContent)
29018:     return PR_TRUE;
29018: 
29018:   // if focus on this element would get redirected, then check the redirected
29018:   // content as well when blurring.
29018:   return (contentToBlur && nsFocusManager::GetRedirectedFocus(aContent) == contentToBlur);
    1: }
    1: 
    1: nsIContent*
    1: nsGenericElement::GetBindingParent() const
    1: {
    1:   nsDOMSlots *slots = GetExistingDOMSlots();
    1: 
    1:   if (slots) {
    1:     return slots->mBindingParent;
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: PRBool
    1: nsGenericElement::IsNodeOfType(PRUint32 aFlags) const
    1: {
41646:   return !(aFlags & ~eCONTENT);
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: PRUint32
    1: nsGenericElement::GetScriptTypeID() const
    1: {
    1:     PtrBits flags = GetFlags();
    1: 
    1:     /* 4 bits reserved for script-type ID. */
    1:     return (flags >> NODE_SCRIPT_TYPE_OFFSET) & 0x000F;
    1: }
    1: 
28073: NS_IMETHODIMP
    1: nsGenericElement::SetScriptTypeID(PRUint32 aLang)
    1: {
    1:     if ((aLang & 0x000F) != aLang) {
    1:         NS_ERROR("script ID too large!");
    1:         return NS_ERROR_FAILURE;
    1:     }
    1:     /* SetFlags will just mask in the specific flags set, leaving existing
    1:        ones alone.  So we must clear all the bits first */
    1:     UnsetFlags(0x000FU << NODE_SCRIPT_TYPE_OFFSET);
    1:     SetFlags(aLang << NODE_SCRIPT_TYPE_OFFSET);
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::InsertChildAt(nsIContent* aKid,
    1:                                 PRUint32 aIndex,
    1:                                 PRBool aNotify)
    1: {
    1:   NS_PRECONDITION(aKid, "null ptr");
    1: 
42105:   return doInsertChildAt(aKid, aIndex, aNotify, mAttrsAndChildren);
42105: }
42105: 
42105: 
    1: nsresult
42105: nsINode::doInsertChildAt(nsIContent* aKid, PRUint32 aIndex,
42105:                          PRBool aNotify, nsAttrAndChildArray& aChildArray)
42105: {
    1:   nsresult rv;
42105: 
42105:   if (!HasSameOwnerDoc(aKid)) {
    1:     nsCOMPtr<nsIDOMNode> kid = do_QueryInterface(aKid, &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:  
    1:     PRUint16 nodeType = 0;
    1:     rv = kid->GetNodeType(&nodeType);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
42105:     nsCOMPtr<nsIDOM3Document> domDoc = do_QueryInterface(GetOwnerDoc());
12068: 
12068:     // DocumentType nodes are the only nodes that can have a null
12068:     // ownerDocument according to the DOM spec, and we need to allow
12068:     // inserting them w/o calling AdoptNode().
12068: 
12068:     if (domDoc && (nodeType != nsIDOMNode::DOCUMENT_TYPE_NODE ||
12068:                    aKid->GetOwnerDoc())) {
12068:       nsCOMPtr<nsIDOMNode> adoptedKid;
12068:       rv = domDoc->AdoptNode(kid, getter_AddRefs(adoptedKid));
12068:       NS_ENSURE_SUCCESS(rv, rv);
12068: 
12068:       NS_ASSERTION(adoptedKid == kid, "Uh, adopt node changed nodes?");
    1:     }
    1:   }
    1: 
    1:   PRUint32 childCount = aChildArray.ChildCount();
    1:   NS_ENSURE_TRUE(aIndex <= childCount, NS_ERROR_ILLEGAL_VALUE);
    1: 
    1:   nsMutationGuard::DidMutate();
    1: 
    1:   PRBool isAppend = (aIndex == childCount);
    1: 
42105:   nsIDocument* doc = GetCurrentDoc();
42105:   mozAutoDocUpdate updateBatch(doc, UPDATE_CONTENT_MODEL, aNotify);
    1: 
    1:   rv = aChildArray.InsertChildAt(aKid, aIndex);
    1:   NS_ENSURE_SUCCESS(rv, rv);
42105:   if (aIndex == 0) {
42105:     mFirstChild = aKid;
42105:   }
42105: 
42105:   nsIContent* parent =
42105:     IsNodeOfType(eDOCUMENT) ? nsnull : static_cast<nsIContent*>(this);
42105: 
42105:   rv = aKid->BindToTree(doc, parent, nsnull, PR_TRUE);
    1:   if (NS_FAILED(rv)) {
42105:     if (GetFirstChild() == aKid) {
42105:       mFirstChild = aKid->GetNextSibling();
42105:     }
    1:     aChildArray.RemoveChildAt(aIndex);
    1:     aKid->UnbindFromTree();
    1:     return rv;
    1:   }
    1: 
42105:   NS_ASSERTION(aKid->GetNodeParent() == this,
30896:                "Did we run script inappropriately?");
30896: 
30896:   if (aNotify) {
    1:     // Note that we always want to call ContentInserted when things are added
    1:     // as kids to documents
42105:     if (parent && isAppend) {
42107:       nsNodeUtils::ContentAppended(parent, aKid, aIndex);
    1:     } else {
42105:       nsNodeUtils::ContentInserted(this, aKid, aIndex);
    1:     }
    1: 
    1:     if (nsContentUtils::HasMutationListeners(aKid,
42105:           NS_EVENT_BITS_MUTATION_NODEINSERTED, this)) {
42105:       mozAutoRemovableBlockerRemover blockerRemover(GetOwnerDoc());
14319:       
    1:       nsMutationEvent mutation(PR_TRUE, NS_MUTATION_NODEINSERTED);
42105:       mutation.mRelatedNode = do_QueryInterface(this);
42105: 
42105:       mozAutoSubtreeModified subtree(GetOwnerDoc(), this);
    1:       nsEventDispatcher::Dispatch(aKid, nsnull, &mutation);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
29805: nsGenericElement::RemoveChildAt(PRUint32 aIndex, PRBool aNotify, PRBool aMutationEvent)
    1: {
    1:   nsCOMPtr<nsIContent> oldKid = mAttrsAndChildren.GetSafeChildAt(aIndex);
    1:   NS_ASSERTION(oldKid == GetChildAt(aIndex), "Unexpected child in RemoveChildAt");
    1: 
    1:   if (oldKid) {
42105:     return doRemoveChildAt(aIndex, aNotify, oldKid, mAttrsAndChildren,
42105:                            aMutationEvent);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
42105: nsINode::doRemoveChildAt(PRUint32 aIndex, PRBool aNotify,
42105:                          nsIContent* aKid, nsAttrAndChildArray& aChildArray,
29805:                          PRBool aMutationEvent)
    1: {
42105:   nsIDocument* doc = GetCurrentDoc();
 5395: #ifdef ACCESSIBILITY
 5395:   // A11y needs to be notified of content removals first, so accessibility
 5395:   // events can be fired before any changes occur
42105:   if (aNotify && doc) {
42105:     nsIPresShell *presShell = doc->GetPrimaryShell();
 5395:     if (presShell && presShell->IsAccessibilityActive()) {
 5395:       nsCOMPtr<nsIAccessibilityService> accService = 
 5395:         do_GetService("@mozilla.org/accessibilityService;1");
 5395:       if (accService) {
 5395:         accService->InvalidateSubtreeFor(presShell, aKid,
32336:                                          nsIAccessibilityService::NODE_REMOVE);
 5395:       }
 5395:     }
 5395:   }
 5395: #endif
 5395: 
    1:   nsMutationGuard::DidMutate();
    1: 
42105:   NS_PRECONDITION(aKid && aKid->GetNodeParent() == this &&
42105:                   aKid == GetChildAt(aIndex) &&
42105:                   IndexOf(aKid) == (PRInt32)aIndex, "Bogus aKid");
42105: 
42105:   mozAutoDocUpdate updateBatch(doc, UPDATE_CONTENT_MODEL, aNotify);
    1: 
    1:   nsMutationGuard guard;
    1: 
   62:   mozAutoSubtreeModified subtree(nsnull, nsnull);
    1:   if (aNotify &&
29805:       aMutationEvent &&
    1:       nsContentUtils::HasMutationListeners(aKid,
42105:         NS_EVENT_BITS_MUTATION_NODEREMOVED, this)) {
42105:     mozAutoRemovableBlockerRemover blockerRemover(GetOwnerDoc());
14319: 
    1:     nsMutationEvent mutation(PR_TRUE, NS_MUTATION_NODEREMOVED);
42105:     mutation.mRelatedNode = do_QueryInterface(this);
42105: 
42105:     subtree.UpdateTarget(GetOwnerDoc(), this);
    1:     nsEventDispatcher::Dispatch(aKid, nsnull, &mutation);
    1:   }
    1: 
    1:   // Someone may have removed the kid or any of its siblings while that event
    1:   // was processing.
    1:   if (guard.Mutated(0)) {
42105:     aIndex = IndexOf(aKid);
 3233:     if (static_cast<PRInt32>(aIndex) < 0) {
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
42105:   if (GetFirstChild() == aKid) {
42105:     mFirstChild = aKid->GetNextSibling();
42105:   }
42105: 
    1:   aChildArray.RemoveChildAt(aIndex);
    1: 
    1:   if (aNotify) {
42105:     nsNodeUtils::ContentRemoved(this, aKid, aIndex);
    1:   }
    1: 
    1:   aKid->UnbindFromTree();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* static */
    1: nsresult
    1: nsGenericElement::DispatchEvent(nsPresContext* aPresContext,
    1:                                 nsEvent* aEvent,
    1:                                 nsIContent* aTarget,
    1:                                 PRBool aFullDispatch,
    1:                                 nsEventStatus* aStatus)
    1: {
    1:   NS_PRECONDITION(aTarget, "Must have target");
    1:   NS_PRECONDITION(aEvent, "Must have source event");
    1:   NS_PRECONDITION(aStatus, "Null out param?");
    1: 
    1:   if (!aPresContext) {
    1:     return NS_OK;
    1:   }
    1: 
   95:   nsCOMPtr<nsIPresShell> shell = aPresContext->GetPresShell();
    1:   if (!shell) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (aFullDispatch) {
    1:     return shell->HandleEventWithTarget(aEvent, nsnull, aTarget, aStatus);
    1:   }
    1: 
    1:   return shell->HandleDOMEventWithTarget(aTarget, aEvent, aStatus);
    1: }
    1: 
    1: /* static */
    1: nsresult
    1: nsGenericElement::DispatchClickEvent(nsPresContext* aPresContext,
    1:                                      nsInputEvent* aSourceEvent,
    1:                                      nsIContent* aTarget,
    1:                                      PRBool aFullDispatch,
    1:                                      nsEventStatus* aStatus)
    1: {
    1:   NS_PRECONDITION(aTarget, "Must have target");
    1:   NS_PRECONDITION(aSourceEvent, "Must have source event");
    1:   NS_PRECONDITION(aStatus, "Null out param?");
    1: 
    1:   nsMouseEvent event(NS_IS_TRUSTED_EVENT(aSourceEvent), NS_MOUSE_CLICK,
    1:                      aSourceEvent->widget, nsMouseEvent::eReal);
    1:   event.refPoint = aSourceEvent->refPoint;
    1:   PRUint32 clickCount = 1;
22684:   float pressure = 0;
40485:   PRUint16 inputSource = 0;
    1:   if (aSourceEvent->eventStructType == NS_MOUSE_EVENT) {
 3233:     clickCount = static_cast<nsMouseEvent*>(aSourceEvent)->clickCount;
22684:     pressure = static_cast<nsMouseEvent*>(aSourceEvent)->pressure;
40485:     inputSource = static_cast<nsMouseEvent*>(aSourceEvent)->inputSource;
40485:   } else if (aSourceEvent->eventStructType == NS_KEY_EVENT) {
40485:     inputSource = nsIDOMNSMouseEvent::MOZ_SOURCE_KEYBOARD;
22684:   }
22684:   event.pressure = pressure;
    1:   event.clickCount = clickCount;
40485:   event.inputSource = inputSource;
    1:   event.isShift = aSourceEvent->isShift;
    1:   event.isControl = aSourceEvent->isControl;
    1:   event.isAlt = aSourceEvent->isAlt;
    1:   event.isMeta = aSourceEvent->isMeta;
    1: 
    1:   return DispatchEvent(aPresContext, &event, aTarget, aFullDispatch, aStatus);
    1: }
    1: 
    1: nsIFrame*
36655: nsGenericElement::GetPrimaryFrame(mozFlushType aType)
    1: {
    1:   nsIDocument* doc = GetCurrentDoc();
    1:   if (!doc) {
    1:     return nsnull;
    1:   }
    1: 
    1:   // Cause a flush, so we get up-to-date frame
    1:   // information
    1:   doc->FlushPendingNotifications(aType);
    1: 
36655:   return GetPrimaryFrame();
    1: }
    1: 
 8462: void
 8462: nsGenericElement::DestroyContent()
 8462: {
 8462:   nsIDocument *document = GetOwnerDoc();
 8462:   if (document) {
 8462:     document->BindingManager()->ChangeDocumentFor(this, document, nsnull);
11838:     document->ClearBoxObjectFor(this);
 8462:   }
 8462: 
21618:   // XXX We really should let cycle collection do this, but that currently still
21618:   //     leaks (see https://bugzilla.mozilla.org/show_bug.cgi?id=406684).
30001:   nsContentUtils::ReleaseWrapper(this, this);
21618: 
 8462:   PRUint32 i, count = mAttrsAndChildren.ChildCount();
 8462:   for (i = 0; i < count; ++i) {
 8462:     // The child can remove itself from the parent in BindToTree.
 8462:     mAttrsAndChildren.ChildAt(i)->DestroyContent();
 8462:   }
 8462: }
 8462: 
14188: void
14188: nsGenericElement::SaveSubtreeState()
14188: {
14188:   PRUint32 i, count = mAttrsAndChildren.ChildCount();
14188:   for (i = 0; i < count; ++i) {
14188:     mAttrsAndChildren.ChildAt(i)->SaveSubtreeState();
14188:   }
14188: }
14188: 
    1: //----------------------------------------------------------------------
    1: 
    1: // Generic DOMNode implementations
    1: 
    1: // When replacing, aRefContent is the content being replaced; when
    1: // inserting it's the content before which we're inserting.  In the
    1: // latter case it may be null.
    1: static
    1: PRBool IsAllowedAsChild(nsIContent* aNewChild, PRUint16 aNewNodeType,
39585:                         nsINode* aParent, PRBool aIsReplace,
39585:                         nsIContent* aRefContent)
    1: {
    1:   NS_PRECONDITION(aNewChild, "Must have new child");
    1:   NS_PRECONDITION(!aIsReplace || aRefContent,
    1:                   "Must have ref content for replace");
39585:   NS_PRECONDITION(aParent->IsNodeOfType(nsINode::eDOCUMENT) ||
39585:                   aParent->IsNodeOfType(nsINode::eDOCUMENT_FRAGMENT) ||
41636:                   aParent->IsElement(),
39585:                   "Nodes that are not documents, document fragments or "
39585:                   "elements can't be parents!");
    1: #ifdef DEBUG
    1:   PRUint16 debugNodeType = 0;
    1:   nsCOMPtr<nsIDOMNode> debugNode(do_QueryInterface(aNewChild));
    1:   nsresult debugRv = debugNode->GetNodeType(&debugNodeType);
    1: 
    1:   NS_PRECONDITION(NS_SUCCEEDED(debugRv) && debugNodeType == aNewNodeType,
    1:                   "Bogus node type passed");
    1: #endif
    1: 
    1:   if (aParent && nsContentUtils::ContentIsDescendantOf(aParent, aNewChild)) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   // The allowed child nodes differ for documents and elements
    1:   switch (aNewNodeType) {
    1:   case nsIDOMNode::COMMENT_NODE :
    1:   case nsIDOMNode::PROCESSING_INSTRUCTION_NODE :
    1:     // OK in both cases
    1:     return PR_TRUE;
    1:   case nsIDOMNode::TEXT_NODE :
    1:   case nsIDOMNode::CDATA_SECTION_NODE :
    1:   case nsIDOMNode::ENTITY_REFERENCE_NODE :
    1:     // Only allowed under elements
    1:     return aParent != nsnull;
    1:   case nsIDOMNode::ELEMENT_NODE :
    1:     {
39585:       if (!aParent->IsNodeOfType(nsINode::eDOCUMENT)) {
39585:         // Always ok to have elements under other elements or document fragments
    1:         return PR_TRUE;
    1:       }
    1: 
41634:       Element* rootElement =
41634:         static_cast<nsIDocument*>(aParent)->GetRootElement();
41634:       if (rootElement) {
    1:         // Already have a documentElement, so this is only OK if we're
    1:         // replacing it.
41634:         return aIsReplace && rootElement == aRefContent;
    1:       }
    1: 
    1:       // We don't have a documentElement yet.  Our one remaining constraint is
    1:       // that the documentElement must come after the doctype.
    1:       if (!aRefContent) {
    1:         // Appending is just fine.
    1:         return PR_TRUE;
    1:       }
    1: 
    1:       // Now grovel for a doctype
39585:       nsCOMPtr<nsIDOMDocument> doc = do_QueryInterface(aParent);
    1:       NS_ASSERTION(doc, "Shouldn't happen");
    1:       nsCOMPtr<nsIDOMDocumentType> docType;
    1:       doc->GetDoctype(getter_AddRefs(docType));
    1:       nsCOMPtr<nsIContent> docTypeContent = do_QueryInterface(docType);
    1:       
    1:       if (!docTypeContent) {
    1:         // It's all good.
    1:         return PR_TRUE;
    1:       }
    1: 
39585:       PRInt32 doctypeIndex = aParent->IndexOf(docTypeContent);
39585:       PRInt32 insertIndex = aParent->IndexOf(aRefContent);
    1: 
    1:       // Now we're OK in the following two cases only:
    1:       // 1) We're replacing something that's not before the doctype
    1:       // 2) We're inserting before something that comes after the doctype 
    1:       return aIsReplace ? (insertIndex >= doctypeIndex) :
    1:         insertIndex > doctypeIndex;
    1:     }
    1:   case nsIDOMNode::DOCUMENT_TYPE_NODE :
    1:     {
39585:       if (!aParent->IsNodeOfType(nsINode::eDOCUMENT)) {
39585:         // doctypes only allowed under documents
    1:         return PR_FALSE;
    1:       }
    1: 
39585:       nsCOMPtr<nsIDOMDocument> doc = do_QueryInterface(aParent);
    1:       NS_ASSERTION(doc, "Shouldn't happen");
    1:       nsCOMPtr<nsIDOMDocumentType> docType;
    1:       doc->GetDoctype(getter_AddRefs(docType));
    1:       nsCOMPtr<nsIContent> docTypeContent = do_QueryInterface(docType);
    1:       if (docTypeContent) {
    1:         // Already have a doctype, so this is only OK if we're replacing it
    1:         return aIsReplace && docTypeContent == aRefContent;
    1:       }
    1: 
    1:       // We don't have a doctype yet.  Our one remaining constraint is
    1:       // that the doctype must come before the documentElement.
41634:       Element* rootElement =
41634:         static_cast<nsIDocument*>(aParent)->GetRootElement();
41634:       if (!rootElement) {
    1:         // It's all good
    1:         return PR_TRUE;
    1:       }
    1: 
    1:       if (!aRefContent) {
    1:         // Trying to append a doctype, but have a documentElement
    1:         return PR_FALSE;
    1:       }
    1: 
41634:       PRInt32 rootIndex = aParent->IndexOf(rootElement);
39585:       PRInt32 insertIndex = aParent->IndexOf(aRefContent);
    1: 
    1:       // Now we're OK if and only if insertIndex <= rootIndex.  Indeed, either
    1:       // we end up replacing aRefContent or we end up before it.  Either one is
41634:       // ok as long as aRefContent is not after rootElement.
    1:       return insertIndex <= rootIndex;
    1:     }
    1:   case nsIDOMNode::DOCUMENT_FRAGMENT_NODE :
    1:     {
    1:       // Note that for now we only allow nodes inside document fragments if
    1:       // they're allowed inside elements.  If we ever change this to allow
    1:       // doctype nodes in document fragments, we'll need to update this code
39585:       if (!aParent->IsNodeOfType(nsINode::eDOCUMENT)) {
    1:         // All good here
    1:         return PR_TRUE;
    1:       }
    1: 
    1:       PRBool sawElement = PR_FALSE;
    1:       PRUint32 count = aNewChild->GetChildCount();
    1:       for (PRUint32 index = 0; index < count; ++index) {
    1:         nsIContent* childContent = aNewChild->GetChildAt(index);
    1:         NS_ASSERTION(childContent, "Something went wrong");
41636:         if (childContent->IsElement()) {
    1:           if (sawElement) {
    1:             // Can't put two elements into a document
    1:             return PR_FALSE;
    1:           }
    1:           sawElement = PR_TRUE;
    1:         }
    1:         // If we can put this content at the the right place, we might be ok;
    1:         // if not, we bail out.
    1:         nsCOMPtr<nsIDOMNode> childNode(do_QueryInterface(childContent));
    1:         PRUint16 type;
    1:         childNode->GetNodeType(&type);
39585:         if (!IsAllowedAsChild(childContent, type, aParent, aIsReplace,
39585:                               aRefContent)) {
    1:           return PR_FALSE;
    1:         }
    1:       }
    1: 
    1:       // Everything in the fragment checked out ok, so we can stick it in here
    1:       return PR_TRUE;
    1:     }
    1:   default:
    1:     /*
    1:      * aNewChild is of invalid type.
    1:      */
    1:     break;
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
41627: void
41627: nsGenericElement::FireNodeInserted(nsIDocument* aDoc,
41627:                                    nsINode* aParent,
41627:                                    nsCOMArray<nsIContent>& aNodes)
41627: {
41627:   PRInt32 count = aNodes.Count();
41627:   for (PRInt32 i = 0; i < count; ++i) {
41627:     nsIContent* childContent = aNodes[i];
41627: 
41627:     if (nsContentUtils::HasMutationListeners(childContent,
41627:           NS_EVENT_BITS_MUTATION_NODEINSERTED, aParent)) {
41627:       mozAutoRemovableBlockerRemover blockerRemover(aDoc);
41627: 
41627:       nsMutationEvent mutation(PR_TRUE, NS_MUTATION_NODEINSERTED);
41627:       mutation.mRelatedNode = do_QueryInterface(aParent);
41627: 
41627:       mozAutoSubtreeModified subtree(aDoc, aParent);
41627:       nsEventDispatcher::Dispatch(childContent, nsnull, &mutation);
41627:     }
41627:   }
41627: }
41627: 
    1: nsresult
39585: nsINode::ReplaceOrInsertBefore(PRBool aReplace, nsINode* aNewChild,
39585:                                nsINode* aRefChild)
39585: {
    1:   if (!aNewChild || (aReplace && !aRefChild)) {
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1: 
41527:   if (IsNodeOfType(eDATA_NODE)) {
41527:     return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
41527:   }
41527: 
41527:   if (IsNodeOfType(eATTRIBUTE)) {
41527:     return NS_ERROR_NOT_IMPLEMENTED;
41527:   }
41527: 
39585:   nsIContent* refContent;
    1:   nsresult res = NS_OK;
    1:   PRInt32 insPos;
    1: 
    1:   // Figure out which index to insert at
    1:   if (aRefChild) {
39585:     insPos = IndexOf(aRefChild);
    1:     if (insPos < 0) {
    1:       return NS_ERROR_DOM_NOT_FOUND_ERR;
    1:     }
    1: 
    1:     if (aRefChild == aNewChild) {
    1:       return NS_OK;
    1:     }
39585: 
39585:     NS_ASSERTION(aRefChild->IsNodeOfType(eCONTENT),
39585:                  "A child node must be nsIContent!");
39585: 
39585:     refContent = static_cast<nsIContent*>(aRefChild);
39585:   }
39585:   else {
39585:     insPos = GetChildCount();
39585:     refContent = nsnull;
39585:   }
39585: 
39585:   if (!aNewChild->IsNodeOfType(eCONTENT)) {
    1:     return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
    1:   }
    1: 
39585:   nsIContent* newContent = static_cast<nsIContent*>(aNewChild);
39585: 
    1:   PRUint16 nodeType = 0;
    1:   res = aNewChild->GetNodeType(&nodeType);
    1:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // Make sure that the inserted node is allowed as a child of its new parent.
39585:   if (!IsAllowedAsChild(newContent, nodeType, this, aReplace, refContent)) {
    1:     return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
    1:   }
    1: 
39585:   nsIDocument *doc = GetOwnerDoc();
39584: 
12068:   // DocumentType nodes are the only nodes that can have a null
12068:   // ownerDocument according to the DOM spec, and we need to allow
12068:   // inserting them w/o calling AdoptNode().
39585:   if (!HasSameOwnerDoc(newContent) &&
12068:       (nodeType != nsIDOMNode::DOCUMENT_TYPE_NODE ||
12068:        newContent->GetOwnerDoc())) {
39584:     nsCOMPtr<nsIDOM3Document> domDoc = do_QueryInterface(doc);
12068: 
12068:     if (domDoc) {
39585:       nsresult rv;
39585:       nsCOMPtr<nsIDOMNode> newChild = do_QueryInterface(aNewChild, &rv);
39585:       NS_ENSURE_SUCCESS(rv, rv);
39585: 
12068:       nsCOMPtr<nsIDOMNode> adoptedKid;
39585:       rv = domDoc->AdoptNode(newChild, getter_AddRefs(adoptedKid));
12068:       NS_ENSURE_SUCCESS(rv, rv);
12068: 
39585:       NS_ASSERTION(adoptedKid == newChild, "Uh, adopt node changed nodes?");
39585:       NS_ASSERTION(HasSameOwnerDoc(newContent) && doc == GetOwnerDoc(),
39584:                    "ownerDocument changed again after adopting!");
    1:     }
    1:   }
    1: 
    1:   // We want an update batch when we expect several mutations to be performed,
    1:   // which is when we're replacing a node, or when we're inserting a fragment.
39585:   mozAutoDocConditionalContentUpdateBatch batch(GetCurrentDoc(),
    1:     aReplace || nodeType == nsIDOMNode::DOCUMENT_FRAGMENT_NODE);
    1: 
    1:   // If we're replacing
    1:   if (aReplace) {
39585:     refContent = GetChildAt(insPos + 1);
    1: 
    1:     nsMutationGuard guard;
    1: 
39585:     res = RemoveChildAt(insPos, PR_TRUE);
    1:     NS_ENSURE_SUCCESS(res, res);
    1: 
    1:     if (guard.Mutated(1)) {
39585:       insPos = refContent ? IndexOf(refContent) : GetChildCount();
    1:       if (insPos < 0) {
    1:         return NS_ERROR_DOM_NOT_FOUND_ERR;
    1:       }
    1: 
    1:       // Passing PR_FALSE for aIsReplace since we now have removed the node
    1:       // to be replaced.
39585:       if (!IsAllowedAsChild(newContent, nodeType, this, PR_FALSE, refContent)) {
    1:         return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
    1:       }
    1:     }
    1:   }
    1: 
    1:   /*
    1:    * Check if we're inserting a document fragment. If we are, we need
    1:    * to remove the children of the document fragment and add them
    1:    * individually (i.e. we don't add the actual document fragment).
    1:    */
    1:   if (nodeType == nsIDOMNode::DOCUMENT_FRAGMENT_NODE) {
    1:     PRUint32 count = newContent->GetChildCount();
    1: 
30896:     if (!count) {
30896:       return NS_OK;
30896:     }
30896: 
    1:     // Copy the children into a separate array to avoid having to deal with
    1:     // mutations to the fragment while we're inserting.
    1:     nsCOMArray<nsIContent> fragChildren;
    1:     if (!fragChildren.SetCapacity(count)) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:     PRUint32 i;
    1:     for (i = 0; i < count; i++) {
    1:       nsIContent* child = newContent->GetChildAt(i);
    1:       NS_ASSERTION(child->GetCurrentDoc() == nsnull,
    1:                    "How did we get a child with a current doc?");
    1:       fragChildren.AppendObject(child);
    1:     }
    1: 
    1:     // Remove the children from the fragment and flag for possible mutations.
    1:     PRBool mutated = PR_FALSE;
    1:     for (i = count; i > 0;) {
    1:       // We don't need to update i if someone mutates the DOM. The only thing
    1:       // that'd happen is that the resulting child list might be unexpected,
    1:       // but we should never crash since RemoveChildAt is out-of-bounds safe.
    1:       nsMutationGuard guard;
    1:       newContent->RemoveChildAt(--i, PR_TRUE);
    1:       mutated = mutated || guard.Mutated(1);
    1:     }
    1: 
39584:     // If we've had any unexpected mutations so far we need to recheck that
30896:     // the child can still be inserted.
30896:     if (mutated) {
    1:       for (i = 0; i < count; ++i) {
    1:         // Get the n:th child from the array.
    1:         nsIContent* childContent = fragChildren[i];
39585:         if (!HasSameOwnerDoc(childContent) ||
39584:             doc != childContent->GetOwnerDoc()) {
39584:           return NS_ERROR_DOM_WRONG_DOCUMENT_ERR;
39584:         }
    1: 
30896:         nsCOMPtr<nsIDOMNode> tmpNode = do_QueryInterface(childContent);
30896:         PRUint16 tmpType = 0;
30896:         tmpNode->GetNodeType(&tmpType);
30896: 
30896:         if (childContent->GetNodeParent() ||
39585:             !IsAllowedAsChild(childContent, tmpType, this, PR_FALSE,
30896:                               refContent)) {
30896:           return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
30896:         }
30896:       }
30896: 
39585:       insPos = refContent ? IndexOf(refContent) : GetChildCount();
    1:       if (insPos < 0) {
    1:         // Someone seriously messed up the childlist. We have no idea
    1:         // where to insert the remaining children, so just bail.
    1:         return NS_ERROR_DOM_NOT_FOUND_ERR;
    1:       }
30896:     }
30896: 
41636:     PRBool appending =
41636:       !IsNodeOfType(eDOCUMENT) && PRUint32(insPos) == GetChildCount();
30896:     PRBool firstInsPos = insPos;
42107:     nsIContent* firstInsertedContent = fragChildren[0];
30896: 
30896:     // Iterate through the fragment's children, and insert them in the new
30896:     // parent
30896:     for (i = 0; i < count; ++i, ++insPos) {
30896:       nsIContent* childContent = fragChildren[i];
    1: 
    1:       // XXXbz how come no reparenting here?  That seems odd...
    1:       // Insert the child.
39585:       res = InsertChildAt(childContent, insPos, PR_FALSE);
30896:       if (NS_FAILED(res)) {
30896:         // Make sure to notify on any children that we did succeed to insert
30896:         if (appending && i != 0) {
39585:           nsNodeUtils::ContentAppended(static_cast<nsIContent*>(this),
42107:                                        firstInsertedContent,
39585:                                        firstInsPos);
30896:         }
30896:         return res;
30896:       }
30896: 
30896:       if (!appending) {
39585:         nsNodeUtils::ContentInserted(this, childContent, insPos);
30896:       }
30896:     }
30896: 
30896:     // Notify
30896:     if (appending) {
42107:       nsNodeUtils::ContentAppended(static_cast<nsIContent*>(this),
42107:                                    firstInsertedContent, firstInsPos);
30896:     }
30896: 
30896:     // Fire mutation events. Optimize for the case when there are no listeners
30896:     nsPIDOMWindow* window = nsnull;
41627:     if (doc &&
41627:         (((window = doc->GetInnerWindow()) &&
41627:           window->HasMutationListeners(NS_EVENT_BITS_MUTATION_NODEINSERTED)) ||
41627:          !window)) {
41627:       nsGenericElement::FireNodeInserted(doc, this, fragChildren);
    1:     }
    1:   }
    1:   else {
    1:     // Not inserting a fragment but rather a single node.
    1: 
25511:     if (newContent->IsRootOfAnonymousSubtree()) {
25511:       // This is anonymous content.  Don't allow its insertion
25511:       // anywhere, since it might have UnbindFromTree calls coming
25511:       // its way.
25511:       return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
25511:     }
25511: 
    1:     // Remove the element from the old parent if one exists
    1:     nsINode* oldParent = newContent->GetNodeParent();
    1: 
    1:     if (oldParent) {
    1:       PRInt32 removeIndex = oldParent->IndexOf(newContent);
    1: 
 4232:       if (removeIndex < 0) {
 4232:         // newContent is anonymous.  We can't deal with this, so just bail
25511:         NS_ERROR("How come our flags didn't catch this?");
    1:         return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
    1:       }
    1:       
39585:       NS_ASSERTION(!(oldParent == this && removeIndex == insPos),
    1:                    "invalid removeIndex");
    1: 
    1:       nsMutationGuard guard;
    1: 
    1:       res = oldParent->RemoveChildAt(removeIndex, PR_TRUE);
    1:       NS_ENSURE_SUCCESS(res, res);
    1: 
    1:       // Adjust insert index if the node we ripped out was a sibling
    1:       // of the node we're inserting before
39585:       if (oldParent == this && removeIndex < insPos) {
    1:         --insPos;
    1:       }
    1: 
    1:       if (guard.Mutated(1)) {
39584:         if (doc != newContent->GetOwnerDoc()) {
39584:           return NS_ERROR_DOM_WRONG_DOCUMENT_ERR;
39584:         }
39584: 
39585:         insPos = refContent ? IndexOf(refContent) : GetChildCount();
    1:         if (insPos < 0) {
    1:           // Someone seriously messed up the childlist. We have no idea
    1:           // where to insert the new child, so just bail.
    1:           return NS_ERROR_DOM_NOT_FOUND_ERR;
    1:         }
    1: 
    1:         if (newContent->GetNodeParent() ||
39585:             !IsAllowedAsChild(newContent, nodeType, this, PR_FALSE,
39585:                               refContent)) {
    1:           return NS_ERROR_DOM_HIERARCHY_REQUEST_ERR;
    1:         }
    1:       }
    1:     }
    1: 
37946:     // FIXME https://bugzilla.mozilla.org/show_bug.cgi?id=544654
37946:     //       We need to reparent here for nodes for which the parent of their
37946:     //       wrapper is not the wrapper for their ownerDocument (XUL elements,
37946:     //       form controls, ...).
    1: 
39585:     res = InsertChildAt(newContent, insPos, PR_TRUE);
    1:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1: 
    1:   return res;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: // nsISupports implementation
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsGenericElement)
    1: 
30001: NS_IMPL_CYCLE_COLLECTION_ROOT_BEGIN(nsGenericElement)
30001:   NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
30001: NS_IMPL_CYCLE_COLLECTION_ROOT_END
30001: 
    1: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsGenericElement)
    1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_LISTENERMANAGER
 1391:   NS_IMPL_CYCLE_COLLECTION_UNLINK_USERDATA
    1: 
33329:   if (tmp->HasProperties() && tmp->IsXUL()) {
 9153:     tmp->DeleteProperty(nsGkAtoms::contextmenulistener);
 9153:     tmp->DeleteProperty(nsGkAtoms::popuplistener);
 9153:   }
 9153: 
    1:   // Unlink child content (and unbind our subtree).
    1:   {
14228:     PRUint32 childCount = tmp->mAttrsAndChildren.ChildCount();
14228:     if (childCount) {
14228:       // Don't allow script to run while we're unbinding everything.
14228:       nsAutoScriptBlocker scriptBlocker;
14228:       while (childCount-- > 0) {
14228:         // Once we have XPCOMGC we shouldn't need to call UnbindFromTree.
 8462:         // We could probably do a non-deep unbind here when IsInDoc is false
 8462:         // for better performance.
14228:         tmp->mAttrsAndChildren.ChildAt(childCount)->UnbindFromTree();
14228:         tmp->mAttrsAndChildren.RemoveChildAt(childCount);
14228:       }
42105:       tmp->mFirstChild = nsnull;
    1:     }
    1:   }  
    1: 
    1:   // Unlink any DOM slots of interest.
    1:   {
    1:     nsDOMSlots *slots = tmp->GetExistingDOMSlots();
 8462:     if (slots) {
31394:       slots->mStyle = nsnull;
32193: #ifdef MOZ_SMIL
32193:       slots->mSMILOverrideStyle = nsnull;
32193: #endif // MOZ_SMIL
11538:       if (slots->mAttributeMap) {
11538:         slots->mAttributeMap->DropReference();
    1:         slots->mAttributeMap = nsnull;
11538:       }
33329:       if (tmp->IsXUL())
 8462:         NS_IF_RELEASE(slots->mControllers);
17074:       slots->mChildrenList = nsnull;
 8462:     }
    1:   }
30000: 
30000:   {
30000:     nsIDocument *doc;
30000:     if (!tmp->GetNodeParent() && (doc = tmp->GetOwnerDoc()) &&
30000:         tmp->HasFlag(NODE_MAY_BE_IN_BINDING_MNGR)) {
30000:       doc->BindingManager()->ChangeDocumentFor(tmp, doc, nsnull);
30000:     }
30000:   }
    1: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
    1: 
30001: NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN(nsGenericElement)
30001:   NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER
30001: NS_IMPL_CYCLE_COLLECTION_TRACE_END
30001: 
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsGenericElement)
30001:   // Always need to traverse script objects, so do that before we check
30001:   // if we're uncollectable.
30001:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
30001: 
 1353:   nsIDocument* currentDoc = tmp->GetCurrentDoc();
 1498:   if (currentDoc && nsCCUncollectableMarker::InGeneration(
30096:                       cb, currentDoc->GetMarkedCCGeneration())) {
25691:     return NS_SUCCESS_INTERRUPTED_TRAVERSE;
 1353:   }
 1353: 
    1:   nsIDocument* ownerDoc = tmp->GetOwnerDoc();
    1:   if (ownerDoc) {
    1:     ownerDoc->BindingManager()->Traverse(tmp, cb);
    1:   }
    1: 
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_LISTENERMANAGER
 1391:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_USERDATA
    1: 
33329:   if (tmp->HasProperties() && tmp->IsXUL()) {
    1:     nsISupports* property =
 3233:       static_cast<nsISupports*>
 3233:                  (tmp->GetProperty(nsGkAtoms::contextmenulistener));
    1:     cb.NoteXPCOMChild(property);
 3233:     property = static_cast<nsISupports*>
 3233:                           (tmp->GetProperty(nsGkAtoms::popuplistener));
    1:     cb.NoteXPCOMChild(property);
    1:   }
    1: 
13669:   // Traverse attribute names and child content.
    1:   {
    1:     PRUint32 i;
13669:     PRUint32 attrs = tmp->mAttrsAndChildren.AttrCount();
13669:     for (i = 0; i < attrs; i++) {
13669:       const nsAttrName* name = tmp->mAttrsAndChildren.AttrNameAt(i);
22064:       if (!name->IsAtom()) {
22064:         NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb,
22064:                                            "mAttrsAndChildren[i]->NodeInfo()");
13669:         cb.NoteXPCOMChild(name->NodeInfo());
13669:       }
22064:     }
13669: 
    1:     PRUint32 kids = tmp->mAttrsAndChildren.ChildCount();
13202:     for (i = 0; i < kids; i++) {
13202:       NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mAttrsAndChildren[i]");
    1:       cb.NoteXPCOMChild(tmp->mAttrsAndChildren.GetSafeChildAt(i));
    1:     }
13202:   }
    1: 
13669:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mNodeInfo)
13669: 
    1:   // Traverse any DOM slots of interest.
    1:   {
    1:     nsDOMSlots *slots = tmp->GetExistingDOMSlots();
    1:     if (slots) {
30385:       NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "slots mStyle");
30385:       cb.NoteXPCOMChild(slots->mStyle.get());
30385: 
32193: #ifdef MOZ_SMIL
32193:       NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "slots mSMILOverrideStyle");
32193:       cb.NoteXPCOMChild(slots->mSMILOverrideStyle.get());
32193: #endif // MOZ_SMIL
32193: 
30385:       NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "slots mAttributeMap");
    1:       cb.NoteXPCOMChild(slots->mAttributeMap.get());
30385: 
33329:       if (tmp->IsXUL())
    1:         cb.NoteXPCOMChild(slots->mControllers);
17074:       cb.NoteXPCOMChild(
17074:         static_cast<nsIDOMNodeList*>(slots->mChildrenList.get()));
    1:     }
    1:   }
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
12033: 
21618: NS_INTERFACE_MAP_BEGIN(nsGenericElement)
21618:   NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
21618:   NS_INTERFACE_MAP_ENTRIES_CYCLE_COLLECTION(nsGenericElement)
12033:   NS_INTERFACE_MAP_ENTRY(nsIContent)
12033:   NS_INTERFACE_MAP_ENTRY(nsINode)
12033:   NS_INTERFACE_MAP_ENTRY(nsPIDOMEventTarget)
12033:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOM3Node, new nsNode3Tearoff(this))
12033:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMNSElement, new nsNSElementTearoff(this))
12033:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMEventTarget,
12033:                                  nsDOMEventRTTearoff::Create(this))
12033:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOM3EventTarget,
12033:                                  nsDOMEventRTTearoff::Create(this))
12033:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMNSEventTarget,
12033:                                  nsDOMEventRTTearoff::Create(this))
12033:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsISupportsWeakReference,
12033:                                  new nsNodeSupportsWeakRefTearoff(this))
16106:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMNodeSelector,
16106:                                  new nsNodeSelectorTearoff(this))
29215:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMXPathNSResolver,
29215:                                  new nsNode3Tearoff(this))
12033:   // nsNodeSH::PreCreate() depends on the identity pointer being the
12033:   // same as nsINode (which nsIContent inherits), so if you change the
12033:   // below line, make sure nsNodeSH::PreCreate() still does the right
12033:   // thing!
12033:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIContent)
12033: NS_INTERFACE_MAP_END
12033: 
    1: NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS(nsGenericElement, nsIContent)
    1: NS_IMPL_CYCLE_COLLECTING_RELEASE_AMBIGUOUS_WITH_DESTROY(nsGenericElement,
    1:                                                         nsIContent,
 1391:                                                         nsNodeUtils::LastRelease(this))
    1: 
    1: nsresult
    1: nsGenericElement::PostQueryInterface(REFNSIID aIID, void** aInstancePtr)
    1: {
    1:   nsIDocument *document = GetOwnerDoc();
    1:   if (document) {
    1:     return document->BindingManager()->GetBindingImplementation(this, aIID,
    1:                                                                 aInstancePtr);
    1:   }
    1: 
 3114:   *aInstancePtr = nsnull;
 3114:   return NS_ERROR_NO_INTERFACE;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: nsresult
    1: nsGenericElement::LeaveLink(nsPresContext* aPresContext)
    1: {
    1:   nsILinkHandler *handler = aPresContext->GetLinkHandler();
    1:   if (!handler) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   return handler->OnLeaveLink();
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::AddScriptEventListener(nsIAtom* aEventName,
    1:                                          const nsAString& aValue,
    1:                                          PRBool aDefer)
    1: {
 4064:   nsIDocument *ownerDoc = GetOwnerDoc();
 4064:   if (!ownerDoc || ownerDoc->IsLoadedAsData()) {
 4064:     // Make this a no-op rather than throwing an error to avoid
 4064:     // the error causing problems setting the attribute.
 4064:     return NS_OK;
 4064:   }
 4064: 
    1:   NS_PRECONDITION(aEventName, "Must have event name!");
    1:   nsCOMPtr<nsISupports> target;
    1:   PRBool defer = PR_TRUE;
    1:   nsCOMPtr<nsIEventListenerManager> manager;
    1: 
29474:   GetEventListenerManagerForAttr(getter_AddRefs(manager),
    1:                                  getter_AddRefs(target),
    1:                                  &defer);
32526:   if (!manager) {
32526:     return NS_OK;
32526:   }
29474: 
    1:   defer = defer && aDefer; // only defer if everyone agrees...
    1:   PRUint32 lang = GetScriptTypeID();
29474:   return
    1:     manager->AddScriptEventListener(target, aEventName, aValue, lang, defer,
    1:                                     !nsContentUtils::IsChromeDoc(ownerDoc));
    1: }
    1: 
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: const nsAttrName*
    1: nsGenericElement::InternalGetExistingAttrNameFromQName(const nsAString& aStr) const
    1: {
39101:   return mAttrsAndChildren.GetExistingAttrNameFromQName(aStr);
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::CopyInnerTo(nsGenericElement* aDst) const
    1: {
    1:   PRUint32 i, count = mAttrsAndChildren.AttrCount();
    1:   for (i = 0; i < count; ++i) {
    1:     const nsAttrName* name = mAttrsAndChildren.AttrNameAt(i);
    1:     const nsAttrValue* value = mAttrsAndChildren.AttrAt(i);
    1:     nsAutoString valStr;
    1:     value->ToString(valStr);
    1:     nsresult rv = aDst->SetAttr(name->NamespaceID(), name->LocalName(),
    1:                                 name->GetPrefix(), valStr, PR_FALSE);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::SetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
    1:                           nsIAtom* aPrefix, const nsAString& aValue,
    1:                           PRBool aNotify)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aName);
    1:   NS_ASSERTION(aNamespaceID != kNameSpaceID_Unknown,
    1:                "Don't call SetAttr with unknown namespace");
    1: 
    1:   nsAutoString oldValue;
    1:   PRBool modification = PR_FALSE;
    1:   PRBool hasListeners = aNotify &&
    1:     nsContentUtils::HasMutationListeners(this,
 3137:                                          NS_EVENT_BITS_MUTATION_ATTRMODIFIED,
 3137:                                          this);
    1:   
    1:   // If we have no listeners and aNotify is false, we are almost certainly
    1:   // coming from the content sink and will almost certainly have no previous
    1:   // value.  Even if we do, setting the value is cheap when we have no
    1:   // listeners and don't plan to notify.  The check for aNotify here is an
    1:   // optimization, the check for haveListeners is a correctness issue.
    1:   if (hasListeners || aNotify) {
    1:     nsAttrInfo info(GetAttrInfo(aNamespaceID, aName));
    1:     if (info.mValue) {
    1:       // Check whether the old value is the same as the new one.  Note that we
    1:       // only need to actually _get_ the old value if we have listeners.
    1:       PRBool valueMatches;
    1:       if (hasListeners) {
    1:         // Need to store the old value
    1:         info.mValue->ToString(oldValue);
    1:         valueMatches = aValue.Equals(oldValue);
    1:       } else if (aNotify) {
    1:         valueMatches = info.mValue->Equals(aValue, eCaseMatters);
    1:       }
    1:       if (valueMatches && aPrefix == info.mName->GetPrefix()) {
    1:         return NS_OK;
    1:       }
    1:       modification = PR_TRUE;
    1:     }
    1:   }
    1: 
38453: 
    1:   nsresult rv = BeforeSetAttr(aNamespaceID, aName, &aValue, aNotify);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
38453:   PRUint8 modType = modification ?
38453:     static_cast<PRUint8>(nsIDOMMutationEvent::MODIFICATION) :
38453:     static_cast<PRUint8>(nsIDOMMutationEvent::ADDITION);
38453:   if (aNotify) {
38453:     nsNodeUtils::AttributeWillChange(this, aNamespaceID, aName, modType);
38453:   }
38453: 
    1:   nsAttrValue attrValue;
    1:   if (!ParseAttribute(aNamespaceID, aName, aValue, attrValue)) {
    1:     attrValue.SetTo(aValue);
    1:   }
    1: 
22222:   return SetAttrAndNotify(aNamespaceID, aName, aPrefix, oldValue,
38453:                           attrValue, modType, hasListeners, aNotify,
22222:                           &aValue);
    1: }
    1:   
    1: nsresult
    1: nsGenericElement::SetAttrAndNotify(PRInt32 aNamespaceID,
    1:                                    nsIAtom* aName,
    1:                                    nsIAtom* aPrefix,
    1:                                    const nsAString& aOldValue,
    1:                                    nsAttrValue& aParsedValue,
38453:                                    PRUint8 aModType,
    1:                                    PRBool aFireMutation,
22222:                                    PRBool aNotify,
22222:                                    const nsAString* aValueForAfterSetAttr)
    1: {
    1:   nsresult rv;
    1: 
    1:   nsIDocument* document = GetCurrentDoc();
    1:   mozAutoDocUpdate updateBatch(document, UPDATE_CONTENT_MODEL, aNotify);
 3410: 
 3410:   // When notifying, make sure to keep track of states whose value
 3410:   // depends solely on the value of an attribute.
 3410:   PRUint32 stateMask;
 3410:   if (aNotify) {
 3410:     stateMask = PRUint32(IntrinsicState());
 3410:   }
    1: 
    1:   if (aNamespaceID == kNameSpaceID_None) {
    1:     // XXXbz Perhaps we should push up the attribute mapping function
    1:     // stuff to nsGenericElement?
    1:     if (!IsAttributeMapped(aName) ||
    1:         !SetMappedAttribute(document, aName, aParsedValue, &rv)) {
    1:       rv = mAttrsAndChildren.SetAndTakeAttr(aName, aParsedValue);
    1:     }
    1:   }
    1:   else {
    1:     nsCOMPtr<nsINodeInfo> ni;
19197:     ni = mNodeInfo->NodeInfoManager()->GetNodeInfo(aName, aPrefix,
19197:                                                    aNamespaceID);
19747:     NS_ENSURE_TRUE(ni, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     rv = mAttrsAndChildren.SetAndTakeAttr(ni, aParsedValue);
    1:   }
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
12522:   if (document || HasFlag(NODE_FORCE_XBL_BINDINGS)) {
12522:     nsIDocument* ownerDoc = GetOwnerDoc();
12522:     if (ownerDoc) {
 2528:       nsRefPtr<nsXBLBinding> binding =
12522:         ownerDoc->BindingManager()->GetBinding(this);
    1:       if (binding) {
    1:         binding->AttributeChanged(aName, aNamespaceID, PR_FALSE, aNotify);
    1:       }
    1:     }
12522:   }
    1: 
 3311:   if (aNotify) {
 3410:     stateMask = stateMask ^ PRUint32(IntrinsicState());
 3410:     if (stateMask && document) {
 3410:       MOZ_AUTO_DOC_UPDATE(document, UPDATE_CONTENT_STATE, aNotify);
 3410:       document->ContentStatesChanged(this, nsnull, stateMask);
 3410:     }
38453:     nsNodeUtils::AttributeChanged(this, aNamespaceID, aName, aModType);
 3311:   }
 3311: 
22222:   if (aNamespaceID == kNameSpaceID_XMLEvents && 
22222:       aName == nsGkAtoms::event && mNodeInfo->GetDocument()) {
22222:     mNodeInfo->GetDocument()->AddXMLEventsContent(this);
22222:   }
22222:   if (aValueForAfterSetAttr) {
22222:     rv = AfterSetAttr(aNamespaceID, aName, aValueForAfterSetAttr, aNotify);
22222:     NS_ENSURE_SUCCESS(rv, rv);
22222:   }
22222: 
    1:   if (aFireMutation) {
34394:     mozAutoRemovableBlockerRemover blockerRemover(GetOwnerDoc());
14319:     
    1:     nsMutationEvent mutation(PR_TRUE, NS_MUTATION_ATTRMODIFIED);
    1: 
    1:     nsCOMPtr<nsIDOMAttr> attrNode;
    1:     nsAutoString ns;
    1:     nsContentUtils::NameSpaceManager()->GetNameSpaceURI(aNamespaceID, ns);
39101:     GetAttributeNodeNS(ns, nsDependentAtomString(aName),
39101:                        getter_AddRefs(attrNode));
    1:     mutation.mRelatedNode = attrNode;
    1: 
    1:     mutation.mAttrName = aName;
    1:     nsAutoString newValue;
    1:     GetAttr(aNamespaceID, aName, newValue);
    1:     if (!newValue.IsEmpty()) {
    1:       mutation.mNewAttrValue = do_GetAtom(newValue);
    1:     }
    1:     if (!aOldValue.IsEmpty()) {
    1:       mutation.mPrevAttrValue = do_GetAtom(aOldValue);
    1:     }
38453:     mutation.mAttrChange = aModType;
13098: 
   62:     mozAutoSubtreeModified subtree(GetOwnerDoc(), this);
    1:     nsEventDispatcher::Dispatch(this, nsnull, &mutation);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsGenericElement::ParseAttribute(PRInt32 aNamespaceID,
    1:                                  nsIAtom* aAttribute,
    1:                                  const nsAString& aValue,
    1:                                  nsAttrValue& aResult)
    1: {
 4036:   if (aNamespaceID == kNameSpaceID_None &&
 4036:       aAttribute == GetIDAttributeName() && !aValue.IsEmpty()) {
 6041:     SetFlags(NODE_MAY_HAVE_ID);
    1:     // Store id as an atom.  id="" means that the element has no id,
    1:     // not that it has an emptystring as the id.
    1:     aResult.ParseAtom(aValue);
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRBool
    1: nsGenericElement::SetMappedAttribute(nsIDocument* aDocument,
    1:                                      nsIAtom* aName,
    1:                                      nsAttrValue& aValue,
    1:                                      nsresult* aRetval)
    1: {
    1:   *aRetval = NS_OK;
    1:   return PR_FALSE;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::GetEventListenerManagerForAttr(nsIEventListenerManager** aManager,
    1:                                                  nsISupports** aTarget,
    1:                                                  PRBool* aDefer)
    1: {
29474:   *aManager = GetListenerManager(PR_TRUE);
29474:   *aDefer = PR_TRUE;
29474:   NS_ENSURE_STATE(*aManager);
29474:   NS_ADDREF(*aManager);
 3233:   NS_ADDREF(*aTarget = static_cast<nsIContent*>(this));
29474:   return NS_OK;
    1: }
    1: 
    1: nsGenericElement::nsAttrInfo
    1: nsGenericElement::GetAttrInfo(PRInt32 aNamespaceID, nsIAtom* aName) const
    1: {
    1:   NS_ASSERTION(nsnull != aName, "must have attribute name");
    1:   NS_ASSERTION(aNamespaceID != kNameSpaceID_Unknown,
    1:                "must have a real namespace ID!");
    1: 
    1:   PRInt32 index = mAttrsAndChildren.IndexOfAttr(aName, aNamespaceID);
    1:   if (index >= 0) {
    1:     return nsAttrInfo(mAttrsAndChildren.AttrNameAt(index),
    1:                       mAttrsAndChildren.AttrAt(index));
    1:   }
    1: 
    1:   return nsAttrInfo(nsnull, nsnull);
    1: }
    1:   
    1: 
    1: PRBool
    1: nsGenericElement::GetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                           nsAString& aResult) const
    1: {
    1:   NS_ASSERTION(nsnull != aName, "must have attribute name");
    1:   NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown,
    1:                "must have a real namespace ID!");
    1: 
    1:   const nsAttrValue* val = mAttrsAndChildren.GetAttr(aName, aNameSpaceID);
    1:   if (!val) {
    1:     // Since we are returning a success code we'd better do
    1:     // something about the out parameters (someone may have
    1:     // given us a non-empty string).
    1:     aResult.Truncate();
    1:     
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   val->ToString(aResult);
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: PRBool
    1: nsGenericElement::HasAttr(PRInt32 aNameSpaceID, nsIAtom* aName) const
    1: {
    1:   NS_ASSERTION(nsnull != aName, "must have attribute name");
    1:   NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown,
    1:                "must have a real namespace ID!");
    1: 
    1:   return mAttrsAndChildren.IndexOfAttr(aName, aNameSpaceID) >= 0;
    1: }
    1: 
    1: PRBool
    1: nsGenericElement::AttrValueIs(PRInt32 aNameSpaceID,
    1:                               nsIAtom* aName,
    1:                               const nsAString& aValue,
    1:                               nsCaseTreatment aCaseSensitive) const
    1: {
    1:   NS_ASSERTION(aName, "Must have attr name");
    1:   NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown, "Must have namespace");
    1: 
    1:   const nsAttrValue* val = mAttrsAndChildren.GetAttr(aName, aNameSpaceID);
    1:   return val && val->Equals(aValue, aCaseSensitive);
    1: }
    1: 
    1: PRBool
    1: nsGenericElement::AttrValueIs(PRInt32 aNameSpaceID,
    1:                               nsIAtom* aName,
    1:                               nsIAtom* aValue,
    1:                               nsCaseTreatment aCaseSensitive) const
    1: {
    1:   NS_ASSERTION(aName, "Must have attr name");
    1:   NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown, "Must have namespace");
    1:   NS_ASSERTION(aValue, "Null value atom");
    1: 
    1:   const nsAttrValue* val = mAttrsAndChildren.GetAttr(aName, aNameSpaceID);
    1:   return val && val->Equals(aValue, aCaseSensitive);
    1: }
    1: 
    1: PRInt32
    1: nsGenericElement::FindAttrValueIn(PRInt32 aNameSpaceID,
    1:                                   nsIAtom* aName,
    1:                                   AttrValuesArray* aValues,
    1:                                   nsCaseTreatment aCaseSensitive) const
    1: {
    1:   NS_ASSERTION(aName, "Must have attr name");
    1:   NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown, "Must have namespace");
    1:   NS_ASSERTION(aValues, "Null value array");
    1:   
    1:   const nsAttrValue* val = mAttrsAndChildren.GetAttr(aName, aNameSpaceID);
    1:   if (val) {
    1:     for (PRInt32 i = 0; aValues[i]; ++i) {
    1:       if (val->Equals(*aValues[i], aCaseSensitive)) {
    1:         return i;
    1:       }
    1:     }
    1:     return ATTR_VALUE_NO_MATCH;
    1:   }
    1:   return ATTR_MISSING;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                             PRBool aNotify)
    1: {
    1:   NS_ASSERTION(nsnull != aName, "must have attribute name");
    1: 
    1:   PRInt32 index = mAttrsAndChildren.IndexOfAttr(aName, aNameSpaceID);
    1:   if (index < 0) {
    1:     return NS_OK;
    1:   }
    1: 
 8668:   nsresult rv = BeforeSetAttr(aNameSpaceID, aName, nsnull, aNotify);
 8668:   NS_ENSURE_SUCCESS(rv, rv);
 8668:   
    1:   nsIDocument *document = GetCurrentDoc();    
    1:   mozAutoDocUpdate updateBatch(document, UPDATE_CONTENT_MODEL, aNotify);
29833: 
29833:   if (aNotify) {
29833:     nsNodeUtils::AttributeWillChange(this, aNameSpaceID, aName,
29833:                                      nsIDOMMutationEvent::REMOVAL);
29833:   }
29833: 
 3410:   // When notifying, make sure to keep track of states whose value
 3410:   // depends solely on the value of an attribute.
 3410:   PRUint32 stateMask;
 3410:   if (aNotify) {
 3410:     stateMask = PRUint32(IntrinsicState());
 3410:   }    
 3410: 
    1:   PRBool hasMutationListeners = aNotify &&
    1:     nsContentUtils::HasMutationListeners(this,
 3137:                                          NS_EVENT_BITS_MUTATION_ATTRMODIFIED,
 3137:                                          this);
    1: 
    1:   // Grab the attr node if needed before we remove it from the attr map
    1:   nsCOMPtr<nsIDOMAttr> attrNode;
    1:   if (hasMutationListeners) {
    1:     nsAutoString ns;
    1:     nsContentUtils::NameSpaceManager()->GetNameSpaceURI(aNameSpaceID, ns);
39101:     GetAttributeNodeNS(ns, nsDependentAtomString(aName),
39101:                        getter_AddRefs(attrNode));
    1:   }
    1: 
    1:   // Clear binding to nsIDOMNamedNodeMap
    1:   nsDOMSlots *slots = GetExistingDOMSlots();
    1:   if (slots && slots->mAttributeMap) {
    1:     slots->mAttributeMap->DropAttribute(aNameSpaceID, aName);
    1:   }
    1: 
    1:   nsAttrValue oldValue;
 8668:   rv = mAttrsAndChildren.RemoveAttrAt(index, oldValue);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
12522:   if (document || HasFlag(NODE_FORCE_XBL_BINDINGS)) {
12522:     nsIDocument* ownerDoc = GetOwnerDoc();
12522:     if (ownerDoc) {
 6674:       nsRefPtr<nsXBLBinding> binding =
12522:         ownerDoc->BindingManager()->GetBinding(this);
12522:       if (binding) {
    1:         binding->AttributeChanged(aName, aNameSpaceID, PR_TRUE, aNotify);
    1:       }
12522:     }
12522:   }
    1: 
    1:   if (aNotify) {
 3410:     stateMask = stateMask ^ PRUint32(IntrinsicState());
 3410:     if (stateMask && document) {
 3410:       MOZ_AUTO_DOC_UPDATE(document, UPDATE_CONTENT_STATE, aNotify);
 3410:       document->ContentStatesChanged(this, nsnull, stateMask);
 3410:     }
    1:     nsNodeUtils::AttributeChanged(this, aNameSpaceID, aName,
35535:                                   nsIDOMMutationEvent::REMOVAL);
    1:   }
    1: 
22222:   rv = AfterSetAttr(aNameSpaceID, aName, nsnull, aNotify);
22222:   NS_ENSURE_SUCCESS(rv, rv);
22222: 
    1:   if (hasMutationListeners) {
34394:     mozAutoRemovableBlockerRemover blockerRemover(GetOwnerDoc());
14319: 
    1:     nsCOMPtr<nsIDOMEventTarget> node =
 3233:       do_QueryInterface(static_cast<nsIContent *>(this));
    1:     nsMutationEvent mutation(PR_TRUE, NS_MUTATION_ATTRMODIFIED);
    1: 
    1:     mutation.mRelatedNode = attrNode;
    1:     mutation.mAttrName = aName;
    1: 
    1:     nsAutoString value;
    1:     oldValue.ToString(value);
    1:     if (!value.IsEmpty())
    1:       mutation.mPrevAttrValue = do_GetAtom(value);
    1:     mutation.mAttrChange = nsIDOMMutationEvent::REMOVAL;
    1: 
   62:     mozAutoSubtreeModified subtree(GetOwnerDoc(), this);
    1:     nsEventDispatcher::Dispatch(this, nsnull, &mutation);
    1:   }
    1: 
22222:   return NS_OK;
    1: }
    1: 
    1: const nsAttrName*
    1: nsGenericElement::GetAttrNameAt(PRUint32 aIndex) const
    1: {
    1:   return mAttrsAndChildren.GetSafeAttrNameAt(aIndex);
    1: }
    1: 
    1: PRUint32
    1: nsGenericElement::GetAttrCount() const
    1: {
    1:   return mAttrsAndChildren.AttrCount();
    1: }
    1: 
    1: const nsTextFragment*
    1: nsGenericElement::GetText()
    1: {
    1:   return nsnull;
    1: }
    1: 
    1: PRUint32
    1: nsGenericElement::TextLength()
    1: {
    1:   // We can remove this assertion if it turns out to be useful to be able
    1:   // to depend on this returning 0
    1:   NS_NOTREACHED("called nsGenericElement::TextLength");
    1: 
    1:   return 0;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::SetText(const PRUnichar* aBuffer, PRUint32 aLength,
    1:                           PRBool aNotify)
    1: {
    1:   NS_ERROR("called nsGenericElement::SetText");
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: nsresult
    1: nsGenericElement::AppendText(const PRUnichar* aBuffer, PRUint32 aLength,
    1:                              PRBool aNotify)
    1: {
    1:   NS_ERROR("called nsGenericElement::AppendText");
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: PRBool
    1: nsGenericElement::TextIsOnlyWhitespace()
    1: {
    1:   return PR_FALSE;
    1: }
    1: 
    1: void
    1: nsGenericElement::AppendTextTo(nsAString& aResult)
    1: {
    1:   // We can remove this assertion if it turns out to be useful to be able
    1:   // to depend on this appending nothing.
    1:   NS_NOTREACHED("called nsGenericElement::TextLength");
    1: }
    1: 
    1: #ifdef DEBUG
    1: void
    1: nsGenericElement::ListAttributes(FILE* out) const
    1: {
    1:   PRUint32 index, count = mAttrsAndChildren.AttrCount();
    1:   for (index = 0; index < count; index++) {
    1:     nsAutoString buffer;
    1: 
    1:     // name
    1:     mAttrsAndChildren.AttrNameAt(index)->GetQualifiedName(buffer);
    1: 
    1:     // value
    1:     buffer.AppendLiteral("=\"");
    1:     nsAutoString value;
    1:     mAttrsAndChildren.AttrAt(index)->ToString(value);
    1:     for (int i = value.Length(); i >= 0; --i) {
    1:       if (value[i] == PRUnichar('"'))
    1:         value.Insert(PRUnichar('\\'), PRUint32(i));
    1:     }
    1:     buffer.Append(value);
    1:     buffer.AppendLiteral("\"");
    1: 
    1:     fputs(" ", out);
    1:     fputs(NS_LossyConvertUTF16toASCII(buffer).get(), out);
    1:   }
    1: }
    1: 
    1: void
    1: nsGenericElement::List(FILE* out, PRInt32 aIndent,
    1:                        const nsCString& aPrefix) const
    1: {
    1:   PRInt32 indent;
    1:   for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
    1: 
    1:   fputs(aPrefix.get(), out);
    1: 
    1:   nsAutoString buf;
    1:   mNodeInfo->GetQualifiedName(buf);
    1:   fputs(NS_LossyConvertUTF16toASCII(buf).get(), out);
    1: 
    1:   fprintf(out, "@%p", (void *)this);
    1: 
    1:   ListAttributes(out);
    1: 
    1:   fprintf(out, " intrinsicstate=[%08x]", IntrinsicState());
41676:   fprintf(out, " flags=[%08x]", GetFlags());
41676:   fprintf(out, " primaryframe=%p", static_cast<void*>(GetPrimaryFrame()));
    1:   fprintf(out, " refcount=%d<", mRefCnt.get());
    1: 
    1:   PRUint32 i, length = GetChildCount();
    1:   if (length > 0) {
    1:     fputs("\n", out);
    1: 
    1:     for (i = 0; i < length; ++i) {
    1:       nsIContent *kid = GetChildAt(i);
    1:       kid->List(out, aIndent + 1);
    1:     }
    1: 
    1:     for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
    1:   }
    1: 
    1:   fputs(">\n", out);
    1:   
 3233:   nsGenericElement* nonConstThis = const_cast<nsGenericElement*>(this);
    1: 
    1:   // XXX sXBL/XBL2 issue! Owner or current document?
    1:   nsIDocument *document = GetOwnerDoc();
    1:   if (document) {
    1:     // Note: not listing nsIAnonymousContentCreator-created content...
    1: 
    1:     nsBindingManager* bindingManager = document->BindingManager();
    1:     nsCOMPtr<nsIDOMNodeList> anonymousChildren;
    1:     bindingManager->GetAnonymousNodesFor(nonConstThis,
    1:                                          getter_AddRefs(anonymousChildren));
    1: 
    1:     if (anonymousChildren) {
    1:       anonymousChildren->GetLength(&length);
    1:       if (length > 0) {
    1:         for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
    1:         fputs("anonymous-children<\n", out);
    1: 
    1:         for (i = 0; i < length; ++i) {
    1:           nsCOMPtr<nsIDOMNode> node;
    1:           anonymousChildren->Item(i, getter_AddRefs(node));
    1:           nsCOMPtr<nsIContent> child = do_QueryInterface(node);
    1:           child->List(out, aIndent + 1);
    1:         }
    1: 
    1:         for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
    1:         fputs(">\n", out);
    1:       }
    1:     }
    1: 
    1:     if (bindingManager->HasContentListFor(nonConstThis)) {
    1:       nsCOMPtr<nsIDOMNodeList> contentList;
    1:       bindingManager->GetContentListFor(nonConstThis,
    1:                                         getter_AddRefs(contentList));
    1: 
    1:       NS_ASSERTION(contentList != nsnull, "oops, binding manager lied");
    1: 
    1:       contentList->GetLength(&length);
    1:       if (length > 0) {
    1:         for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
    1:         fputs("content-list<\n", out);
    1: 
    1:         for (i = 0; i < length; ++i) {
    1:           nsCOMPtr<nsIDOMNode> node;
    1:           contentList->Item(i, getter_AddRefs(node));
    1:           nsCOMPtr<nsIContent> child = do_QueryInterface(node);
    1:           child->List(out, aIndent + 1);
    1:         }
    1: 
    1:         for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
    1:         fputs(">\n", out);
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsGenericElement::DumpContent(FILE* out, PRInt32 aIndent,
    1:                               PRBool aDumpAll) const
    1: {
    1:   PRInt32 indent;
    1:   for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
    1: 
    1:   nsAutoString buf;
    1:   mNodeInfo->GetQualifiedName(buf);
    1:   fputs("<", out);
    1:   fputs(NS_LossyConvertUTF16toASCII(buf).get(), out);
    1: 
    1:   if(aDumpAll) ListAttributes(out);
    1: 
    1:   fputs(">", out);
    1: 
    1:   if(aIndent) fputs("\n", out);
    1: 
    1:   PRInt32 index, kids = GetChildCount();
    1:   for (index = 0; index < kids; index++) {
    1:     nsIContent *kid = GetChildAt(index);
    1:     PRInt32 indent = aIndent ? aIndent + 1 : 0;
    1:     kid->DumpContent(out, indent, aDumpAll);
    1:   }
    1:   for (indent = aIndent; --indent >= 0; ) fputs("  ", out);
    1:   fputs("</", out);
    1:   fputs(NS_LossyConvertUTF16toASCII(buf).get(), out);
    1:   fputs(">", out);
    1: 
    1:   if(aIndent) fputs("\n", out);
    1: }
    1: #endif
    1: 
    1: PRUint32
    1: nsGenericElement::GetChildCount() const
    1: {
    1:   return mAttrsAndChildren.ChildCount();
    1: }
    1: 
    1: nsIContent *
    1: nsGenericElement::GetChildAt(PRUint32 aIndex) const
    1: {
    1:   return mAttrsAndChildren.GetSafeChildAt(aIndex);
    1: }
    1: 
15810: nsIContent * const *
22251: nsGenericElement::GetChildArray(PRUint32* aChildCount) const
22251: {
22251:   return mAttrsAndChildren.GetChildArray(aChildCount);
15810: }
15810: 
    1: PRInt32
    1: nsGenericElement::IndexOf(nsINode* aPossibleChild) const
    1: {
    1:   return mAttrsAndChildren.IndexOfChild(aPossibleChild);
    1: }
    1: 
    1: nsINode::nsSlots*
    1: nsGenericElement::CreateSlots()
    1: {
11169:   return new nsDOMSlots(mFlagsOrSlots);
    1: }
    1: 
  723: PRBool
  723: nsGenericElement::CheckHandleEventForLinksPrecondition(nsEventChainVisitor& aVisitor,
  723:                                                        nsIURI** aURI) const
  723: {
  723:   if (aVisitor.mEventStatus == nsEventStatus_eConsumeNoDefault ||
  723:       !NS_IS_TRUSTED_EVENT(aVisitor.mEvent) ||
  723:       !aVisitor.mPresContext) {
  723:     return PR_FALSE;
  723:   }
  723: 
  723:   // Make sure we actually are a link
  723:   return IsLink(aURI);
  723: }
  723: 
  723: nsresult
  723: nsGenericElement::PreHandleEventForLinks(nsEventChainPreVisitor& aVisitor)
  723: {
  723:   // Optimisation: return early if this event doesn't interest us.
  723:   // IMPORTANT: this switch and the switch below it must be kept in sync!
  723:   switch (aVisitor.mEvent->message) {
  723:   case NS_MOUSE_ENTER_SYNTH:
  723:   case NS_FOCUS_CONTENT:
  723:   case NS_MOUSE_EXIT_SYNTH:
  723:   case NS_BLUR_CONTENT:
  723:     break;
  723:   default:
  723:     return NS_OK;
  723:   }
  723: 
  723:   // Make sure we meet the preconditions before continuing
  723:   nsCOMPtr<nsIURI> absURI;
  723:   if (!CheckHandleEventForLinksPrecondition(aVisitor, getter_AddRefs(absURI))) {
  723:     return NS_OK;
  723:   }
  723: 
  723:   nsresult rv = NS_OK;
  723: 
  723:   // We do the status bar updates in PreHandleEvent so that the status bar gets
  723:   // updated even if the event is consumed before we have a chance to set it.
  723:   switch (aVisitor.mEvent->message) {
  723:   // Set the status bar the same for focus and mouseover
  723:   case NS_MOUSE_ENTER_SYNTH:
  723:     aVisitor.mEventStatus = nsEventStatus_eConsumeNoDefault;
  723:     // FALL THROUGH
  723:   case NS_FOCUS_CONTENT:
  723:     {
  723:       nsAutoString target;
  723:       GetLinkTarget(target);
 3333:       nsContentUtils::TriggerLink(this, aVisitor.mPresContext, absURI, target,
 3333:                                   PR_FALSE, PR_TRUE);
  723:     }
  723:     break;
  723: 
  723:   case NS_MOUSE_EXIT_SYNTH:
  723:     aVisitor.mEventStatus = nsEventStatus_eConsumeNoDefault;
  723:     // FALL THROUGH
  723:   case NS_BLUR_CONTENT:
  723:     rv = LeaveLink(aVisitor.mPresContext);
  723:     break;
  723: 
  723:   default:
  723:     // switch not in sync with the optimization switch earlier in this function
  723:     NS_NOTREACHED("switch statements not in sync");
  723:     return NS_ERROR_UNEXPECTED;
  723:   }
  723: 
  723:   return rv;
  723: }
  723: 
    1: nsresult
    1: nsGenericElement::PostHandleEventForLinks(nsEventChainPostVisitor& aVisitor)
    1: {
    1:   // Optimisation: return early if this event doesn't interest us.
    1:   // IMPORTANT: this switch and the switch below it must be kept in sync!
    1:   switch (aVisitor.mEvent->message) {
    1:   case NS_MOUSE_BUTTON_DOWN:
    1:   case NS_MOUSE_CLICK:
    1:   case NS_UI_ACTIVATE:
    1:   case NS_KEY_PRESS:
    1:     break;
    1:   default:
    1:     return NS_OK;
    1:   }
    1: 
  723:   // Make sure we meet the preconditions before continuing
    1:   nsCOMPtr<nsIURI> absURI;
  723:   if (!CheckHandleEventForLinksPrecondition(aVisitor, getter_AddRefs(absURI))) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   switch (aVisitor.mEvent->message) {
    1:   case NS_MOUSE_BUTTON_DOWN:
    1:     {
    1:       if (aVisitor.mEvent->eventStructType == NS_MOUSE_EVENT &&
 3233:           static_cast<nsMouseEvent*>(aVisitor.mEvent)->button ==
    1:           nsMouseEvent::eLeftButton) {
    1:         // don't make the link grab the focus if there is no link handler
    1:         nsILinkHandler *handler = aVisitor.mPresContext->GetLinkHandler();
    1:         nsIDocument *document = GetCurrentDoc();
29018:         if (handler && document) {
29018:           nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:           if (fm) {
29018:             nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(this);
32919:             fm->SetFocus(elem, nsIFocusManager::FLAG_BYMOUSE |
32919:                                nsIFocusManager::FLAG_NOSCROLL);
    1:           }
    1: 
    1:           aVisitor.mPresContext->EventStateManager()->
29018:             SetContentState(this, NS_EVENT_STATE_ACTIVE);
    1:         }
    1:       }
    1:     }
    1:     break;
    1: 
    1:   case NS_MOUSE_CLICK:
    1:     if (NS_IS_MOUSE_LEFT_CLICK(aVisitor.mEvent)) {
33800:       nsInputEvent* inputEvent = static_cast<nsInputEvent*>(aVisitor.mEvent);
33800:       if (inputEvent->isControl || inputEvent->isMeta ||
33800:           inputEvent->isAlt ||inputEvent->isShift) {
33800:         break;
33800:       }
33800: 
    1:       // The default action is simply to dispatch DOMActivate
   95:       nsCOMPtr<nsIPresShell> shell = aVisitor.mPresContext->GetPresShell();
    1:       if (shell) {
    1:         // single-click
    1:         nsEventStatus status = nsEventStatus_eIgnore;
    1:         nsUIEvent actEvent(NS_IS_TRUSTED_EVENT(aVisitor.mEvent),
    1:                            NS_UI_ACTIVATE, 1);
    1: 
    1:         rv = shell->HandleDOMEventWithTarget(this, &actEvent, &status);
    1:       }
    1:     }
    1:     break;
    1: 
    1:   case NS_UI_ACTIVATE:
    1:     {
    1:       nsAutoString target;
    1:       GetLinkTarget(target);
 3333:       nsContentUtils::TriggerLink(this, aVisitor.mPresContext, absURI, target,
 3333:                                   PR_TRUE, PR_TRUE);
    1:     }
    1:     break;
    1: 
    1:   case NS_KEY_PRESS:
    1:     {
    1:       if (aVisitor.mEvent->eventStructType == NS_KEY_EVENT) {
 3233:         nsKeyEvent* keyEvent = static_cast<nsKeyEvent*>(aVisitor.mEvent);
    1:         if (keyEvent->keyCode == NS_VK_RETURN) {
    1:           nsEventStatus status = nsEventStatus_eIgnore;
    1:           rv = DispatchClickEvent(aVisitor.mPresContext, keyEvent, this,
    1:                                   PR_FALSE, &status);
    1:           if (NS_SUCCEEDED(rv)) {
    1:             aVisitor.mEventStatus = nsEventStatus_eConsumeNoDefault;
    1:           }
    1:         }
    1:       }
    1:     }
    1:     break;
    1: 
    1:   default:
    1:     // switch not in sync with the optimization switch earlier in this function
    1:     NS_NOTREACHED("switch statements not in sync");
    1:     return NS_ERROR_UNEXPECTED;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsGenericElement::GetLinkTarget(nsAString& aTarget)
    1: {
    1:   aTarget.Truncate();
    1: }
    1: 
16106: // NOTE: The aPresContext pointer is NOT addrefed.
35560: // *aSelectorList might be null even if NS_OK is returned; this
35560: // happens when all the selectors were pseudo-element selectors.
16106: static nsresult
16106: ParseSelectorList(nsINode* aNode,
16106:                   const nsAString& aSelectorString,
16106:                   nsCSSSelectorList** aSelectorList,
16106:                   nsPresContext** aPresContext)
16106: {
16106:   NS_ENSURE_ARG(aNode);
16106: 
16106:   nsIDocument* doc = aNode->GetOwnerDoc();
16106:   NS_ENSURE_STATE(doc);
16106: 
38849:   nsCSSParser parser(doc->CSSLoader());
38849:   NS_ENSURE_TRUE(parser, NS_ERROR_OUT_OF_MEMORY);
16106: 
35560:   nsCSSSelectorList* selectorList;
38849:   nsresult rv = parser.ParseSelectorString(aSelectorString,
16106:                                            doc->GetDocumentURI(),
38849:                                            0, // XXXbz get the line number!
35560:                                            &selectorList);
16106:   NS_ENSURE_SUCCESS(rv, rv);
16106: 
35560:   // Filter out pseudo-element selectors from selectorList
35560:   nsCSSSelectorList** slot = &selectorList;
35560:   do {
35560:     nsCSSSelectorList* cur = *slot;
35560:     if (cur->mSelectors->IsPseudoElement()) {
35560:       *slot = cur->mNext;
35560:       cur->mNext = nsnull;
35560:       delete cur;
35560:     } else {
35560:       slot = &cur->mNext;
35560:     }
35560:   } while (*slot);
35560:   *aSelectorList = selectorList;
35560: 
16106:   // It's not strictly necessary to have a prescontext here, but it's
16106:   // a bit of an optimization for various stuff.
16106:   *aPresContext = nsnull;
16106:   nsIPresShell* shell = doc->GetPrimaryShell();
16106:   if (shell) {
16106:     *aPresContext = shell->GetPresContext();
16106:   }
16106: 
16106:   return NS_OK;
16106: }
16106: 
16106: /*
16106:  * Callback to be called as we iterate over the tree and match elements.  If
16106:  * the callbacks returns false, the iteration should be stopped.
16106:  */
16106: typedef PRBool
20261: (* ElementMatchedCallback)(nsIContent* aMatchingElement, void* aClosure);
16106: 
16106: // returning false means stop iteration
16106: static PRBool
16106: TryMatchingElementsInSubtree(nsINode* aRoot,
16106:                              RuleProcessorData* aParentData,
16106:                              nsPresContext* aPresContext,
16106:                              nsCSSSelectorList* aSelectorList,
16106:                              ElementMatchedCallback aCallback,
16106:                              void* aClosure)
16106: {
16106:   /* To improve the performance of '+' and '~' combinators and the :nth-*
16106:    * selectors, we keep track of the immediately previous sibling data.  That's
16106:    * cheaper than heap-allocating all the datas and keeping track of them all,
16106:    * and helps a good bit in the common cases.  We also keep track of the whole
16106:    * parent data chain, since we have those Around anyway */
39128:   union { char c[2 * sizeof(RuleProcessorData)]; void *p; } databuf;
16106:   RuleProcessorData* prevSibling = nsnull;
39133:   RuleProcessorData* data = reinterpret_cast<RuleProcessorData*>(databuf.c);
18854: 
16106:   PRBool continueIteration = PR_TRUE;
27150:   for (nsINode::ChildIterator iter(aRoot); !iter.IsDone(); iter.Next()) {
27150:     nsIContent* kid = iter;
41636:     if (!kid->IsElement()) {
16106:       continue;
16106:     }
16106:     /* See whether we match */
41646:     new (data) RuleProcessorData(aPresContext, kid->AsElement(), nsnull);
16106:     NS_ASSERTION(!data->mParentData, "Shouldn't happen");
16106:     NS_ASSERTION(!data->mPreviousSiblingData, "Shouldn't happen");
16106:     data->mParentData = aParentData;
16106:     data->mPreviousSiblingData = prevSibling;
16106: 
16106:     if (nsCSSRuleProcessor::SelectorListMatches(*data, aSelectorList)) {
16106:       continueIteration = (*aCallback)(kid, aClosure);
16106:     }
16106: 
16106:     if (continueIteration) {
16106:       continueIteration =
16106:         TryMatchingElementsInSubtree(kid, data, aPresContext, aSelectorList,
16106:                                      aCallback, aClosure);
16106:     }
16106:     
16106:     /* Clear out the parent and previous sibling data if we set them, so that
16106:      * ~RuleProcessorData won't try to delete a placement-new'd object. Make
16106:      * sure this happens before our possible early break.  Note that we can
16106:      * have null aParentData but non-null data->mParentData if we're scoped to
16106:      * an element.  However, prevSibling and data->mPreviousSiblingData must
16106:      * always match.
16106:      */
16106:     NS_ASSERTION(!aParentData || data->mParentData == aParentData,
16106:                  "Unexpected parent");
16106:     NS_ASSERTION(data->mPreviousSiblingData == prevSibling,
16106:                  "Unexpected prev sibling");
16106:     data->mPreviousSiblingData = nsnull;
16106:     if (prevSibling) {
16106:       if (aParentData) {
16106:         prevSibling->mParentData = nsnull;
16106:       }
16106:       prevSibling->~RuleProcessorData();
16106:     } else {
16106:       /* This is the first time through, so point |prevSibling| to the location
16106:          we want to have |data| end up pointing to. */
16106:       prevSibling = data + 1;
16106:     }
16106: 
16106:     /* Now swap |prevSibling| and |data|.  Again, before the early break */
16106:     RuleProcessorData* temp = prevSibling;
16106:     prevSibling = data;
16106:     data = temp;
16106:     if (!continueIteration) {
16106:       break;
16106:     }
16106:   }
16106:   if (prevSibling) {
16106:     if (aParentData) {
16106:       prevSibling->mParentData = nsnull;
16106:     }
16106:     /* Make sure to clean this up */
16106:     prevSibling->~RuleProcessorData();
16106:   }
18854: 
16106:   return continueIteration;
16106: }
16106: 
20261: static PRBool
16106: FindFirstMatchingElement(nsIContent* aMatchingElement,
16106:                          void* aClosure)
16106: {
16106:   NS_PRECONDITION(aMatchingElement && aClosure, "How did that happen?");
16106:   nsIContent** slot = static_cast<nsIContent**>(aClosure);
16106:   *slot = aMatchingElement;
16106:   return PR_FALSE;
16106: }
16106: 
16106: /* static */
41909: nsIContent*
41909: nsGenericElement::doQuerySelector(nsINode* aRoot, const nsAString& aSelector,
41909:                                   nsresult *aResult)
41909: {
41909:   NS_PRECONDITION(aResult, "Null out param?");
41909: 
41909:   nsAutoPtr<nsCSSSelectorList> selectorList;
41909:   nsPresContext* presContext;
41909:   *aResult = ParseSelectorList(aRoot, aSelector,
41909:                                getter_Transfers(selectorList),
41909:                                &presContext);
41909:   NS_ENSURE_SUCCESS(*aResult, nsnull);
41909: 
41909:   nsIContent* foundElement = nsnull;
41909:   TryMatchingElementsInSubtree(aRoot, nsnull, presContext, selectorList,
41909:                                FindFirstMatchingElement, &foundElement);
41909: 
41909:   return foundElement;
41909: }
41909: 
41909: static PRBool
41909: AppendAllMatchingElements(nsIContent* aMatchingElement,
41909:                           void* aClosure)
41909: {
41909:   NS_PRECONDITION(aMatchingElement && aClosure, "How did that happen?");
41909:   static_cast<nsBaseContentList*>(aClosure)->AppendElement(aMatchingElement);
41909:   return PR_TRUE;
41909: }
41909: 
41909: /* static */
16106: nsresult
41909: nsGenericElement::doQuerySelectorAll(nsINode* aRoot,
41909:                                      const nsAString& aSelector,
41909:                                      nsIDOMNodeList **aReturn)
16106: {
16106:   NS_PRECONDITION(aReturn, "Null out param?");
16106: 
41909:   nsBaseContentList* contentList = new nsBaseContentList();
41909:   NS_ENSURE_TRUE(contentList, NS_ERROR_OUT_OF_MEMORY);
41909:   NS_ADDREF(*aReturn = contentList);
41909:   
16106:   nsAutoPtr<nsCSSSelectorList> selectorList;
16106:   nsPresContext* presContext;
16106:   nsresult rv = ParseSelectorList(aRoot, aSelector,
16106:                                   getter_Transfers(selectorList),
16106:                                   &presContext);
16106:   NS_ENSURE_SUCCESS(rv, rv);
16106: 
16106:   TryMatchingElementsInSubtree(aRoot, nsnull, presContext, selectorList,
16106:                                AppendAllMatchingElements, contentList);
16106:   return NS_OK;
16106: }
33351: 
41910: 
33351: PRBool
41910: nsGenericElement::MozMatchesSelector(const nsAString& aSelector)
33351: {
33351:   nsAutoPtr<nsCSSSelectorList> selectorList;
33351:   nsPresContext* presContext;
33351:   PRBool matches = PR_FALSE;
33351: 
41910:   if (NS_SUCCEEDED(ParseSelectorList(this, aSelector,
33351:                                      getter_Transfers(selectorList),
33351:                                      &presContext)))
33351:   {
41910:     RuleProcessorData data(presContext, this, nsnull);
33351:     matches = nsCSSRuleProcessor::SelectorListMatches(data, selectorList);
33351:   }
33351: 
33351:   return matches;
33351: }
41910: 
41910: NS_IMETHODIMP
41910: nsNSElementTearoff::MozMatchesSelector(const nsAString& aSelector, PRBool* aReturn)
41910: {
41910:   NS_PRECONDITION(aReturn, "Null out param?");
41910:   *aReturn = mContent->MozMatchesSelector(aSelector);
41910:   return NS_OK;
41910: }
