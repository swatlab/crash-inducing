 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 79384: 
 79384: #include "FocusManager.h"
 79384: 
 95352: #include "Accessible-inl.h"
100057: #include "DocAccessible-inl.h"
 79384: #include "nsAccessibilityService.h"
 79384: #include "nsAccUtils.h"
106800: #include "nsEventShell.h"
 87094: #include "Role.h"
 97643: #include "RootAccessible.h"
 79384: 
 80881: #include "nsEventStateManager.h"
 79384: #include "nsFocusManager.h"
 79384: 
 79384: namespace dom = mozilla::dom;
 79384: using namespace mozilla::a11y;
 79384: 
 79384: FocusManager::FocusManager()
 79384: {
 79384: }
 79384: 
 79384: FocusManager::~FocusManager()
 79384: {
 79384: }
 79384: 
 99648: Accessible*
 79384: FocusManager::FocusedAccessible() const
 79384: {
 79384:   if (mActiveItem)
 79384:     return mActiveItem;
 79384: 
 79384:   nsINode* focusedNode = FocusedDOMNode();
 89799:   if (focusedNode) {
 99568:     DocAccessible* doc = 
 89799:       GetAccService()->GetDocAccessible(focusedNode->OwnerDoc());
 89799:     return doc ? doc->GetAccessibleOrContainer(focusedNode) : nsnull;
 89799:   }
 79384: 
 79384:   return nsnull;
 79384: }
 79384: 
 79384: bool
 99648: FocusManager::IsFocused(const Accessible* aAccessible) const
 79384: {
 79384:   if (mActiveItem)
 79384:     return mActiveItem == aAccessible;
 79384: 
 79384:   nsINode* focusedNode = FocusedDOMNode();
 79384:   if (focusedNode) {
 79384:     // XXX: Before getting an accessible for node having a DOM focus make sure
 79384:     // they belong to the same document because it can trigger unwanted document
 79384:     // accessible creation for temporary about:blank document. Without this
 79384:     // peculiarity we would end up with plain implementation based on
 79384:     // FocusedAccessible() method call. Make sure this issue is fixed in
 79384:     // bug 638465.
 80526:     if (focusedNode->OwnerDoc() == aAccessible->GetNode()->OwnerDoc()) {
 99568:       DocAccessible* doc = 
 89799:         GetAccService()->GetDocAccessible(focusedNode->OwnerDoc());
 79384:       return aAccessible ==
 89799: 	(doc ? doc->GetAccessibleOrContainer(focusedNode) : nsnull);
 79384:     }
 79384:   }
 79384:   return false;
 79384: }
 79384: 
 79384: bool
 99648: FocusManager::IsFocusWithin(const Accessible* aContainer) const
 79384: {
 99648:   Accessible* child = FocusedAccessible();
 79384:   while (child) {
 79384:     if (child == aContainer)
 79384:       return true;
 79384: 
 79384:     child = child->Parent();
 79384:   }
 79384:   return false;
 79384: }
 79384: 
 79384: FocusManager::FocusDisposition
 99648: FocusManager::IsInOrContainsFocus(const Accessible* aAccessible) const
 79384: {
 99648:   Accessible* focus = FocusedAccessible();
 79384:   if (!focus)
 79384:     return eNone;
 79384: 
 79384:   // If focused.
 79384:   if (focus == aAccessible)
 79384:     return eFocused;
 79384: 
 79384:   // If contains the focus.
 99648:   Accessible* child = focus->Parent();
 79384:   while (child) {
 79384:     if (child == aAccessible)
 79384:       return eContainsFocus;
 79384: 
 79384:     child = child->Parent();
 79384:   }
 79384: 
 79384:   // If contained by focus.
 79384:   child = aAccessible->Parent();
 79384:   while (child) {
 79384:     if (child == focus)
 79384:       return eContainedByFocus;
 79384: 
 79384:     child = child->Parent();
 79384:   }
 79384: 
 79384:   return eNone;
 79384: }
 79384: 
 79384: void
 79384: FocusManager::NotifyOfDOMFocus(nsISupports* aTarget)
 79384: {
 79384:   A11YDEBUG_FOCUS_NOTIFICATION_SUPPORTSTARGET("DOM focus", "DOM focus target",
 79384:                                               aTarget)
 79384: 
 79384:   mActiveItem = nsnull;
 79384: 
 79384:   nsCOMPtr<nsINode> targetNode(do_QueryInterface(aTarget));
 79384:   if (targetNode) {
 99568:     DocAccessible* document =
 80526:       GetAccService()->GetDocAccessible(targetNode->OwnerDoc());
 79384:     if (document) {
 79384:       // Set selection listener for focused element.
 79384:       if (targetNode->IsElement()) {
 97643:         RootAccessible* root = document->RootAccessible();
 79384:         nsCaretAccessible* caretAcc = root->GetCaretAccessible();
 79384:         caretAcc->SetControlSelectionListener(targetNode->AsElement());
 79384:       }
 79384: 
 79384:       document->HandleNotification<FocusManager, nsINode>
 79384:         (this, &FocusManager::ProcessDOMFocus, targetNode);
 79384:     }
 79384:   }
 79384: }
 79384: 
 79384: void
 79384: FocusManager::NotifyOfDOMBlur(nsISupports* aTarget)
 79384: {
 79384:   A11YDEBUG_FOCUS_NOTIFICATION_SUPPORTSTARGET("DOM blur", "DOM blur target",
 79384:                                               aTarget)
 79384: 
 79384:   mActiveItem = nsnull;
 79384: 
 79384:   // If DOM document stays focused then fire accessible focus event to process
 79384:   // the case when no element within this DOM document will be focused.
 79384:   nsCOMPtr<nsINode> targetNode(do_QueryInterface(aTarget));
 80526:   if (targetNode && targetNode->OwnerDoc() == FocusedDOMDocument()) {
 80526:     nsIDocument* DOMDoc = targetNode->OwnerDoc();
 99568:     DocAccessible* document =
 79384:       GetAccService()->GetDocAccessible(DOMDoc);
 79384:     if (document) {
 79384:       document->HandleNotification<FocusManager, nsINode>
 79384:         (this, &FocusManager::ProcessDOMFocus, DOMDoc);
 79384:     }
 79384:   }
 79384: }
 79384: 
 79384: void
 99648: FocusManager::ActiveItemChanged(Accessible* aItem, bool aCheckIfActive)
 79384: {
 79384:   A11YDEBUG_FOCUS_NOTIFICATION_ACCTARGET("active item changed",
 79384:                                          "Active item", aItem)
 79384: 
 79384:   // Nothing changed, happens for XUL trees and HTML selects.
 79384:   if (aItem && aItem == mActiveItem)
 79384:     return;
 79384: 
 79384:   mActiveItem = nsnull;
 79384: 
 79384:   if (aItem && aCheckIfActive) {
 99648:     Accessible* widget = aItem->ContainerWidget();
 79384:     A11YDEBUG_FOCUS_LOG_WIDGET("Active item widget", widget)
 79384:     if (!widget || !widget->IsActiveWidget() || !widget->AreItemsOperable())
 79384:       return;
 79384:   }
 79384:   mActiveItem = aItem;
 79384: 
 79384:   // If active item is changed then fire accessible focus event on it, otherwise
 79384:   // if there's no an active item then fire focus event to accessible having
 79384:   // DOM focus.
 99648:   Accessible* target = FocusedAccessible();
 79384:   if (target)
 89800:     DispatchFocusEvent(target->Document(), target);
 79384: }
 79384: 
 79384: void
 79384: FocusManager::ForceFocusEvent()
 79384: {
 79384:   nsINode* focusedNode = FocusedDOMNode();
 79384:   if (focusedNode) {
 99568:     DocAccessible* document =
 80526:       GetAccService()->GetDocAccessible(focusedNode->OwnerDoc());
 79384:     if (document) {
 79384:       document->HandleNotification<FocusManager, nsINode>
 79384:         (this, &FocusManager::ProcessDOMFocus, focusedNode);
 79384:     }
 79384:   }
 79384: }
 79384: 
 79384: void
 99568: FocusManager::DispatchFocusEvent(DocAccessible* aDocument,
 99648:                                  Accessible* aTarget)
 79384: {
 79384:   NS_PRECONDITION(aDocument, "No document for focused accessible!");
 79384:   if (aDocument) {
 79384:     nsRefPtr<AccEvent> event =
 79384:       new AccEvent(nsIAccessibleEvent::EVENT_FOCUS, aTarget,
 79384:                    eAutoDetect, AccEvent::eCoalesceOfSameType);
 79384:     aDocument->FireDelayedAccessibleEvent(event);
 79384: 
 79384:     A11YDEBUG_FOCUS_LOG_ACCTARGET("Focus notification", aTarget)
 79384:   }
 79384: }
 79384: 
 79384: void
 79384: FocusManager::ProcessDOMFocus(nsINode* aTarget)
 79384: {
 79384:   A11YDEBUG_FOCUS_NOTIFICATION_DOMTARGET("Process DOM focus",
 79384:                                          "Notification target", aTarget)
 79384: 
 99568:   DocAccessible* document =
 80526:     GetAccService()->GetDocAccessible(aTarget->OwnerDoc());
 79384: 
 99648:   Accessible* target = document->GetAccessibleOrContainer(aTarget);
 89799:   if (target && document) {
 79384:     // Check if still focused. Otherwise we can end up with storing the active
 79384:     // item for control that isn't focused anymore.
 99648:     Accessible* DOMFocus =
 89799:       document->GetAccessibleOrContainer(FocusedDOMNode());
 79384:     if (target != DOMFocus)
 79384:       return;
 79384: 
 99648:     Accessible* activeItem = target->CurrentItem();
 79384:     if (activeItem) {
 79384:       mActiveItem = activeItem;
 79384:       target = activeItem;
 79384:     }
 79384: 
 79384:     DispatchFocusEvent(document, target);
 79384:   }
 79384: }
 79384: 
 79384: void
 79384: FocusManager::ProcessFocusEvent(AccEvent* aEvent)
 79384: {
 79384:   NS_PRECONDITION(aEvent->GetEventType() == nsIAccessibleEvent::EVENT_FOCUS,
 79384:                   "Focus event is expected!");
 79384: 
 79384:   EIsFromUserInput fromUserInputFlag = aEvent->IsFromUserInput() ?
 79384:     eFromUserInput : eNoUserInput;
 79384: 
 79384:   // Emit focus event if event target is the active item. Otherwise then check
 79384:   // if it's still focused and then update active item and emit focus event.
 99648:   Accessible* target = aEvent->GetAccessible();
 79384:   if (target != mActiveItem) {
 89949: 
 79384:     // Check if still focused. Otherwise we can end up with storing the active
 79384:     // item for control that isn't focused anymore.
 99568:     DocAccessible* document = aEvent->GetDocAccessible();
 99648:     Accessible* DOMFocus = document->GetAccessibleOrContainer(FocusedDOMNode());
 89949: 
 79384:     if (target != DOMFocus)
 79384:       return;
 79384: 
 99648:     Accessible* activeItem = target->CurrentItem();
 79384:     if (activeItem) {
 79384:       mActiveItem = activeItem;
 79384:       target = activeItem;
 79384:     }
 79384:   }
 79384: 
 79384:   // Fire menu start/end events for ARIA menus.
 87094:   if (target->ARIARole() == roles::MENUITEM) {
 79384:     // The focus was moved into menu.
 99648:     Accessible* ARIAMenubar =
 87094:       nsAccUtils::GetAncestorWithRole(target, roles::MENUBAR);
 79384: 
 79384:     if (ARIAMenubar != mActiveARIAMenubar) {
 79384:       // Leaving ARIA menu. Fire menu_end event on current menubar.
 79384:       if (mActiveARIAMenubar) {
 79384:         nsRefPtr<AccEvent> menuEndEvent =
 79384:           new AccEvent(nsIAccessibleEvent::EVENT_MENU_END, mActiveARIAMenubar,
 79384:                        fromUserInputFlag);
 79384:         nsEventShell::FireEvent(menuEndEvent);
 79384:       }
 79384: 
 79384:       mActiveARIAMenubar = ARIAMenubar;
 79384: 
 79384:       // Entering ARIA menu. Fire menu_start event.
 79384:       if (mActiveARIAMenubar) {
 79384:         nsRefPtr<AccEvent> menuStartEvent =
 79384:           new AccEvent(nsIAccessibleEvent::EVENT_MENU_START,
 79384:                        mActiveARIAMenubar, fromUserInputFlag);
 79384:         nsEventShell::FireEvent(menuStartEvent);
 79384:       }
 79384:     }
 79384:   } else if (mActiveARIAMenubar) {
 79384:     // Focus left a menu. Fire menu_end event.
 79384:     nsRefPtr<AccEvent> menuEndEvent =
 79384:       new AccEvent(nsIAccessibleEvent::EVENT_MENU_END, mActiveARIAMenubar,
 79384:                    fromUserInputFlag);
 79384:     nsEventShell::FireEvent(menuEndEvent);
 79384: 
 79384:     mActiveARIAMenubar = nsnull;
 79384:   }
 79384: 
 79384:   A11YDEBUG_FOCUS_NOTIFICATION_ACCTARGET("FIRE FOCUS EVENT", "Focus target",
 79384:                                          target)
 79384: 
 79384:   nsRefPtr<AccEvent> focusEvent =
 79384:     new AccEvent(nsIAccessibleEvent::EVENT_FOCUS, target, fromUserInputFlag);
 79384:   nsEventShell::FireEvent(focusEvent);
 80036: 
 80036:   // Fire scrolling_start event when the document receives the focus if it has
 80036:   // an anchor jump. If an accessible within the document receive the focus
 80036:   // then null out the anchor jump because it no longer applies.
 99568:   DocAccessible* targetDocument = target->Document();
 99648:   Accessible* anchorJump = targetDocument->AnchorJump();
 80036:   if (anchorJump) {
 80036:     if (target == targetDocument) {
 80036:       // XXX: bug 625699, note in some cases the node could go away before we
 80036:       // we receive focus event, for example if the node is removed from DOM.
 80036:       nsEventShell::FireEvent(nsIAccessibleEvent::EVENT_SCROLLING_START,
 80036:                               anchorJump, fromUserInputFlag);
 80036:     }
 80036:     targetDocument->SetAnchorJump(nsnull);
 80036:   }
 79384: }
 79384: 
 80881: nsINode*
 80881: FocusManager::FocusedDOMNode() const
 79384: {
 79384:   nsFocusManager* DOMFocusManager = nsFocusManager::GetFocusManager();
 80881:   nsIContent* focusedElm = DOMFocusManager->GetFocusedContent();
 80881: 
 80881:   // No focus on remote target elements like xul:browser having DOM focus and
 80881:   // residing in chrome process because it means an element in content process
 80881:   // keeps the focus.
 80881:   if (focusedElm) {
 80881:     if (nsEventStateManager::IsRemoteTarget(focusedElm))
 80881:       return nsnull;
 80881:     return focusedElm;
 79384:   }
 79384: 
 80881:   // Otherwise the focus can be on DOM document.
 99095:   nsPIDOMWindow* focusedWnd = DOMFocusManager->GetFocusedWindow();
 99095:   return focusedWnd ? focusedWnd->GetExtantDoc() : nsnull;
 79384: }
 80881: 
 80881: nsIDocument*
 80881: FocusManager::FocusedDOMDocument() const
 80881: {
 80881:   nsINode* focusedNode = FocusedDOMNode();
 80881:   return focusedNode ? focusedNode->OwnerDoc() : nsnull;
 80881: }
