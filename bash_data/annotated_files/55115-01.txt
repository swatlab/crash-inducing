33620: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
33620: /* ***** BEGIN LICENSE BLOCK *****
33620:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
33620:  *
33620:  * The contents of this file are subject to the Mozilla Public License Version
33620:  * 1.1 (the "License"); you may not use this file except in compliance with
33620:  * the License. You may obtain a copy of the License at
33620:  * http://www.mozilla.org/MPL/
33620:  *
33620:  * Software distributed under the License is distributed on an "AS IS" basis,
33620:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
33620:  * for the specific language governing rights and limitations under the
33620:  * License.
33620:  *
33620:  * The Original Code is mozila.org code.
33620:  *
33620:  * The Initial Developer of the Original Code is
52042:  * Mozilla Foundation
33620:  * Portions created by the Initial Developer are Copyright (C) 2007
33620:  * the Initial Developer. All Rights Reserved.
33620:  *
33620:  * Contributor(s):
33620:  *
33620:  * Alternatively, the contents of this file may be used under the terms of
33620:  * either the GNU General Public License Version 2 or later (the "GPL"), or
33620:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
33620:  * in which case the provisions of the GPL or the LGPL are applicable instead
33620:  * of those above. If you wish to allow use of your version of this file only
33620:  * under the terms of either the GPL or the LGPL, and not to allow others to
33620:  * use your version of this file under the terms of the MPL, indicate your
33620:  * decision by deleting the provisions above and replace them with the notice
33620:  * and other provisions required by the GPL or the LGPL. If you do not delete
33620:  * the provisions above, a recipient may use your version of this file under
33620:  * the terms of any one of the MPL, the GPL or the LGPL.
33620:  *
33620:  * ***** END LICENSE BLOCK ***** */
33620: 
34695: #include "nsDOMFileReader.h"
33620: 
33620: #include "nsContentCID.h"
33620: #include "nsContentUtils.h"
33620: #include "nsDOMClassInfo.h"
33620: #include "nsDOMFile.h"
33620: #include "nsDOMError.h"
33620: #include "nsICharsetAlias.h"
33620: #include "nsICharsetDetector.h"
33620: #include "nsICharsetConverterManager.h"
33620: #include "nsIConverterInputStream.h"
33620: #include "nsIFile.h"
33620: #include "nsIFileStreams.h"
33620: #include "nsIInputStream.h"
33620: #include "nsIMIMEService.h"
33620: #include "nsIPlatformCharset.h"
33620: #include "nsIUnicharInputStream.h"
33620: #include "nsIUnicodeDecoder.h"
33620: #include "nsNetCID.h"
33620: #include "nsNetUtil.h"
33620: 
33620: #include "plbase64.h"
33620: #include "prmem.h"
33620: 
33620: #include "nsLayoutCID.h"
33620: #include "nsXPIDLString.h"
33620: #include "nsReadableUtils.h"
33620: #include "nsIURI.h"
33620: #include "nsStreamUtils.h"
33620: #include "nsXPCOM.h"
33620: #include "nsIPrivateDOMEvent.h"
33620: #include "nsIDOMEventListener.h"
33620: #include "nsIJSContextStack.h"
33620: #include "nsJSEnvironment.h"
33620: #include "nsIScriptGlobalObject.h"
33620: #include "nsIDOMClassInfo.h"
33620: #include "nsCExternalHandlerService.h"
33620: #include "nsIStreamConverterService.h"
33620: #include "nsEventDispatcher.h"
33620: #include "nsCycleCollectionParticipant.h"
33620: #include "nsLayoutStatics.h"
33620: #include "nsIScriptObjectPrincipal.h"
52042: #include "nsFileDataProtocolHandler.h"
33620: 
33620: #define LOAD_STR "load"
33620: #define ERROR_STR "error"
33620: #define ABORT_STR "abort"
33620: #define LOADSTART_STR "loadstart"
33620: #define PROGRESS_STR "progress"
33620: #define UPLOADPROGRESS_STR "uploadprogress"
33620: #define LOADEND_STR "loadend"
33620: 
33620: #define NS_PROGRESS_EVENT_INTERVAL 50
33620: 
34695: NS_IMPL_CYCLE_COLLECTION_CLASS(nsDOMFileReader)
33620: 
34695: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsDOMFileReader,
33620:                                                   nsXHREventTarget)
33620:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnLoadEndListener)
33620:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFile)
33620:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mProgressNotifier)
33620:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mPrincipal)
33620:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mChannel)
33620: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
33620: 
34695: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsDOMFileReader,
33620:                                                 nsXHREventTarget)
33620:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOnLoadEndListener)
33620:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mFile)
33620:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mProgressNotifier)
33620:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mPrincipal)
33620:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mChannel)
33620: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
33620: 
40490: DOMCI_DATA(FileReader, nsDOMFileReader)
40490: 
34695: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsDOMFileReader)
34695:   NS_INTERFACE_MAP_ENTRY(nsIDOMFileReader)
33620:   NS_INTERFACE_MAP_ENTRY(nsIStreamListener)
33620:   NS_INTERFACE_MAP_ENTRY(nsIInterfaceRequestor)
33620:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
33620:   NS_INTERFACE_MAP_ENTRY(nsIJSNativeInitializer)
33620:   NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
33620:   NS_INTERFACE_MAP_ENTRY(nsICharsetDetectionObserver)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(FileReader)
33620: NS_INTERFACE_MAP_END_INHERITING(nsXHREventTarget)
33620: 
34695: NS_IMPL_ADDREF_INHERITED(nsDOMFileReader, nsXHREventTarget)
34695: NS_IMPL_RELEASE_INHERITED(nsDOMFileReader, nsXHREventTarget)
33620: 
33620: NS_IMETHODIMP
34695: nsDOMFileReader::GetOnloadend(nsIDOMEventListener** aOnloadend)
33620: {
33620:   return GetInnerEventListener(mOnLoadEndListener, aOnloadend);
33620: }
33620: 
33620: NS_IMETHODIMP
34695: nsDOMFileReader::SetOnloadend(nsIDOMEventListener* aOnloadend)
33620: {
33620:   return RemoveAddEventListener(NS_LITERAL_STRING(LOADEND_STR),
33620:                                 mOnLoadEndListener, aOnloadend);
33620: }
33620: 
33620: //nsICharsetDetectionObserver
33620: 
33620: NS_IMETHODIMP
34695: nsDOMFileReader::Notify(const char *aCharset, nsDetectionConfident aConf)
33620: {
55115:   mCharset = aCharset;
33620:   return NS_OK;
33620: }
33620: 
34695: //nsDOMFileReader constructors/initializers
33620: 
34695: nsDOMFileReader::nsDOMFileReader()
35194:   : mFileData(nsnull),
35227:     mDataLen(0), mDataFormat(FILE_AS_BINARY),
34929:     mReadyState(nsIDOMFileReader::EMPTY),
33620:     mProgressEventWasDelayed(PR_FALSE),
33620:     mTimerIsActive(PR_FALSE),
35194:     mReadTotal(0), mReadTransferred(0)
33620: {
33620:   nsLayoutStatics::AddRef();
33620: }
33620: 
34695: nsDOMFileReader::~nsDOMFileReader()
33620: {
33620:   if (mListenerManager) 
33620:     mListenerManager->Disconnect();
33620: 
35198:   FreeFileData();
35198: 
33620:   nsLayoutStatics::Release();
33620: }
33620: 
33620: nsresult
34695: nsDOMFileReader::Init()
33620: {
33620:   // Set the original mScriptContext and mPrincipal, if available.
33620:   // Get JSContext from stack.
33620:   nsCOMPtr<nsIJSContextStack> stack =
33620:     do_GetService("@mozilla.org/js/xpc/ContextStack;1");
33620: 
33620:   if (!stack) {
33620:     return NS_OK;
33620:   }
33620: 
33620:   JSContext *cx;
33620: 
33620:   if (NS_FAILED(stack->Peek(&cx)) || !cx) {
33620:     return NS_OK;
33620:   }
33620: 
33620:   nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
33620:   nsCOMPtr<nsIPrincipal> subjectPrincipal;
33620:   if (secMan) {
33620:     secMan->GetSubjectPrincipal(getter_AddRefs(subjectPrincipal));
33620:   }
33620:   NS_ENSURE_STATE(subjectPrincipal);
33620:   mPrincipal = subjectPrincipal;
33620: 
33620:   nsIScriptContext* context = GetScriptContextFromJSContext(cx);
33620:   if (context) {
33620:     mScriptContext = context;
33620:     nsCOMPtr<nsPIDOMWindow> window =
33620:       do_QueryInterface(context->GetGlobalObject());
33620:     if (window) {
33620:       mOwner = window->GetCurrentInnerWindow();
33620:     }
33620:   }
33620: 
33620:   return NS_OK;
33620: }
33620: 
33620: NS_IMETHODIMP
34695: nsDOMFileReader::Initialize(nsISupports* aOwner, JSContext* cx, JSObject* obj,
33620:                             PRUint32 argc, jsval *argv)
33620: {
33620:   mOwner = do_QueryInterface(aOwner);
33620:   if (!mOwner) {
33620:     NS_WARNING("Unexpected nsIJSNativeInitializer owner");
33620:     return NS_OK;
33620:   }
33620: 
33620:   // This object is bound to a |window|,
33620:   // so reset the principal and script context.
33620:   nsCOMPtr<nsIScriptObjectPrincipal> scriptPrincipal = do_QueryInterface(aOwner);
33620:   NS_ENSURE_STATE(scriptPrincipal);
33620:   mPrincipal = scriptPrincipal->GetPrincipal();
33620:   nsCOMPtr<nsIScriptGlobalObject> sgo = do_QueryInterface(aOwner);
33620:   NS_ENSURE_STATE(sgo);
33620:   mScriptContext = sgo->GetContext();
33620:   NS_ENSURE_STATE(mScriptContext);
33620: 
33620:   return NS_OK; 
33620: }
33620: 
33620: // nsIInterfaceRequestor
33620: 
33620: NS_IMETHODIMP
34695: nsDOMFileReader::GetInterface(const nsIID & aIID, void **aResult)
33620: {
33620:   return QueryInterface(aIID, aResult);
33620: }
33620: 
34695: // nsIDOMFileReader
33620: 
33620: NS_IMETHODIMP
34695: nsDOMFileReader::GetReadyState(PRUint16 *aReadyState)
33620: {
33620:   *aReadyState = mReadyState;
33620:   return NS_OK;
33620: }
33620: 
33620: NS_IMETHODIMP
34695: nsDOMFileReader::GetResult(nsAString& aResult)
33620: {
34695:   aResult = mResult;
33620:   return NS_OK;
33620: }
33620: 
33620: NS_IMETHODIMP
34695: nsDOMFileReader::GetError(nsIDOMFileError** aError)
33620: {
33620:   NS_IF_ADDREF(*aError = mError);
33620:   return NS_OK;
33620: }
33620: 
33620: NS_IMETHODIMP
34695: nsDOMFileReader::ReadAsBinaryString(nsIDOMFile* aFile)
33620: {
33620:   return ReadFileContent(aFile, EmptyString(), FILE_AS_BINARY);
33620: }
33620: 
33620: NS_IMETHODIMP
34695: nsDOMFileReader::ReadAsText(nsIDOMFile* aFile,
33620:                             const nsAString &aCharset)
33620: {
33620:   return ReadFileContent(aFile, aCharset, FILE_AS_TEXT);
33620: }
33620: 
33620: NS_IMETHODIMP
34695: nsDOMFileReader::ReadAsDataURL(nsIDOMFile* aFile)
33620: {
33620:   return ReadFileContent(aFile, EmptyString(), FILE_AS_DATAURL);
33620: }
33620: 
33620: NS_IMETHODIMP
34695: nsDOMFileReader::Abort()
33620: {
34695:   if (mReadyState != nsIDOMFileReader::LOADING)
33620:     return NS_OK;
33620: 
33620:   //Clear progress and file data
33620:   mProgressEventWasDelayed = PR_FALSE;
33620:   mTimerIsActive = PR_FALSE;
33620:   if (mProgressNotifier) {
33620:     mProgressNotifier->Cancel();
33620:   }
33620: 
34695:   //Revert status, result and readystate attributes
34695:   SetDOMStringToNull(mResult);
34695:   mReadyState = nsIDOMFileReader::DONE;
33620:   mError = new nsDOMFileError(nsIDOMFileError::ABORT_ERR);
33620:     
33620:   //Non-null channel indicates a read is currently active
33620:   if (mChannel) {
33620:     //Cancel request requires an error status
33620:     mChannel->Cancel(NS_ERROR_FAILURE);
33620:     mChannel = nsnull;
33620:   }
33620:   mFile = nsnull;
33620: 
33620:   //Clean up memory buffer
35198:   FreeFileData();
33620: 
33620:   //Dispatch the abort event
33620:   DispatchProgressEvent(NS_LITERAL_STRING(ABORT_STR));
33620:   DispatchProgressEvent(NS_LITERAL_STRING(LOADEND_STR));
33620: 
34929:   mReadyState = nsIDOMFileReader::EMPTY;
33620: 
33620:   return NS_OK;
33620: }
33620: 
33620: // nsITimerCallback
33620: NS_IMETHODIMP
34695: nsDOMFileReader::Notify(nsITimer* aTimer)
33620: {
33620:   mTimerIsActive = PR_FALSE;
33620:   if (mProgressEventWasDelayed) {
33620:     DispatchProgressEvent(NS_LITERAL_STRING(PROGRESS_STR));
33620:     StartProgressEventTimer();
33620:   }
33620: 
33620:   return NS_OK;
33620: }
33620: 
33620: void
34695: nsDOMFileReader::StartProgressEventTimer()
33620: {
33620:   if (!mProgressNotifier) {
33620:     mProgressNotifier = do_CreateInstance(NS_TIMER_CONTRACTID);
33620:   }
33620:   if (mProgressNotifier) {
33620:     mProgressEventWasDelayed = PR_FALSE;
33620:     mTimerIsActive = PR_TRUE;
33620:     mProgressNotifier->Cancel();
33620:     mProgressNotifier->InitWithCallback(this, NS_PROGRESS_EVENT_INTERVAL,
33620:                                               nsITimer::TYPE_ONE_SHOT);
33620:   }
33620: }
33620: 
33620: // nsIStreamListener
33620: 
33620: NS_IMETHODIMP
34695: nsDOMFileReader::OnStartRequest(nsIRequest *request, nsISupports *ctxt)
33620: {
33620:   return NS_OK;
33620: }
33620: 
35194: static
35194: NS_METHOD
35194: ReadFuncBinaryString(nsIInputStream* in,
35194:                      void* closure,
35194:                      const char* fromRawSegment,
35194:                      PRUint32 toOffset,
35194:                      PRUint32 count,
35194:                      PRUint32 *writeCount)
35194: {
35194:   PRUnichar* dest = static_cast<PRUnichar*>(closure) + toOffset;
35194:   PRUnichar* end = dest + count;
35194:   const unsigned char* source = (const unsigned char*)fromRawSegment;
35194:   while (dest != end) {
35194:     *dest = *source;
35194:     ++dest;
35194:     ++source;
35194:   }
35194:   *writeCount = count;
35194: 
35194:   return NS_OK;
35194: }
35194: 
33620: NS_IMETHODIMP
34695: nsDOMFileReader::OnDataAvailable(nsIRequest *aRequest,
33620:                                  nsISupports *aContext,
33620:                                  nsIInputStream *aInputStream,
33620:                                  PRUint32 aOffset,
33620:                                  PRUint32 aCount)
33620: {
35194:   if (mDataFormat == FILE_AS_BINARY) {
35194:     //Continuously update our binary string as data comes in
35194:     NS_ASSERTION(mResult.Length() == aOffset,
35194:                  "unexpected mResult length");
35194:     PRUint32 oldLen = mResult.Length();
35194:     PRUnichar *buf = nsnull;
35194:     mResult.GetMutableData(&buf, oldLen + aCount);
35194:     NS_ENSURE_TRUE(buf, NS_ERROR_OUT_OF_MEMORY);
35194: 
35194:     PRUint32 bytesRead = 0;
35194:     aInputStream->ReadSegments(ReadFuncBinaryString, buf + oldLen, aCount,
35194:                                &bytesRead);
35194:     NS_ASSERTION(bytesRead == aCount, "failed to read data");
35194:   }
35194:   else {
33620:     //Update memory buffer to reflect the contents of the file
33620:     mFileData = (char *)PR_Realloc(mFileData, aOffset + aCount);
33620:     NS_ENSURE_TRUE(mFileData, NS_ERROR_OUT_OF_MEMORY);
33620: 
35194:     PRUint32 bytesRead = 0;
35194:     aInputStream->Read(mFileData + aOffset, aCount, &bytesRead);
35194:     NS_ASSERTION(bytesRead == aCount, "failed to read data");
35194: 
33620:     mDataLen += aCount;
35187:   }
35187: 
35194:   mReadTransferred += aCount;
35187: 
33620:   //Notify the timer is the appropriate timeframe has passed
33620:   if (mTimerIsActive) {
33620:     mProgressEventWasDelayed = PR_TRUE;
33620:   }
33620:   else {
33620:     DispatchProgressEvent(NS_LITERAL_STRING(PROGRESS_STR));
33620:     StartProgressEventTimer();
33620:   }
33620: 
33620:   return NS_OK;
33620: }
33620: 
33620: NS_IMETHODIMP
34695: nsDOMFileReader::OnStopRequest(nsIRequest *aRequest,
33620:                                nsISupports *aContext,
33620:                                nsresult aStatus)
33620: {
33620:   //If we're here as a result of a call from Abort(),
33620:   //simply ignore the request.
33620:   if (aRequest != mChannel)
33620:     return NS_OK;
33620: 
33620:   //Cancel the progress event timer
33620:   mProgressEventWasDelayed = PR_FALSE;
33620:   mTimerIsActive = PR_FALSE;
33620:   if (mProgressNotifier) {
33620:     mProgressNotifier->Cancel();
33620:   }
33620: 
34695:   //FileReader must be in DONE stage after a load
34695:   mReadyState = nsIDOMFileReader::DONE;
33620: 
33620:   //Set the status field as appropriate
33620:   if (NS_FAILED(aStatus)) {
35198:     FreeFileData();
33620:     DispatchError(aStatus);
33620:     return NS_OK;
33620:   }
33620: 
35227:   nsresult rv = NS_OK;
33620:   switch (mDataFormat) {
33620:     case FILE_AS_BINARY:
34695:       break; //Already accumulated mResult
33620:     case FILE_AS_TEXT:
34695:       rv = GetAsText(mCharset, mFileData, mDataLen, mResult);
33620:       break;
33620:     case FILE_AS_DATAURL:
34695:       rv = GetAsDataURL(mFile, mFileData, mDataLen, mResult);
33620:       break;
33620:   }
33620:   
55115:   mResult.SetIsVoid(PR_FALSE);
55115: 
35198:   FreeFileData();
35198: 
35227:   if (NS_FAILED(rv)) {
35227:     DispatchError(rv);
35227:     return NS_OK;
35227:   }
35227: 
33620:   //Dispatch load event to signify end of a successful load
33620:   DispatchProgressEvent(NS_LITERAL_STRING(LOAD_STR));
33620:   DispatchProgressEvent(NS_LITERAL_STRING(LOADEND_STR));
33620: 
35227:   return NS_OK;
33620: }
33620: 
33620: // Helper methods
33620: 
33620: nsresult
34695: nsDOMFileReader::ReadFileContent(nsIDOMFile* aFile,
33620:                                  const nsAString &aCharset,
35227:                                  eDataFormat aDataFormat)
33620: {
52042:   nsresult rv;
33620:   NS_ENSURE_TRUE(aFile, NS_ERROR_NULL_POINTER);
33620: 
33620:   //Implicit abort to clear any other activity going on
33620:   Abort();
33620:   mError = nsnull;
35195:   SetDOMStringToNull(mResult);
35196:   mReadTransferred = 0;
35198:   mReadTotal = 0;
35198:   mReadyState = nsIDOMFileReader::EMPTY;
35198:   FreeFileData();
35198: 
52042:   mFile = aFile;
35198:   mDataFormat = aDataFormat;
55115:   CopyUTF16toUTF8(aCharset, mCharset);
33620: 
52042:   //Establish a channel with our file
52042:   {
52042:     // Hold the internal URL alive only as long as necessary
52042:     // After the channel is created it will own whatever is backing
52042:     // the DOMFile.
54295:     nsDOMFileInternalUrlHolder urlHolder(mFile, mPrincipal);
33620: 
33620:     nsCOMPtr<nsIURI> uri;
52042:     rv = NS_NewURI(getter_AddRefs(uri), urlHolder.mUrl);
33620:     NS_ENSURE_SUCCESS(rv, rv);
33620: 
33620:     rv = NS_NewChannel(getter_AddRefs(mChannel), uri);
33620:     NS_ENSURE_SUCCESS(rv, rv);
52042:   }
33620: 
33620:   //Obtain the total size of the file before reading
35194:   mReadTotal = -1;
52042:   mFile->GetSize(&mReadTotal);
33620: 
33620:   rv = mChannel->AsyncOpen(this, nsnull);
33620:   NS_ENSURE_SUCCESS(rv, rv);
33620: 
34695:   //FileReader should be in loading state here
34695:   mReadyState = nsIDOMFileReader::LOADING;
33620:   DispatchProgressEvent(NS_LITERAL_STRING(LOADSTART_STR));
33620:  
33620:   return NS_OK;
33620: }
33620: 
33620: void
34695: nsDOMFileReader::DispatchError(nsresult rv)
33620: {
33620:   //Set the status attribute, and dispatch the error event
33620:   switch (rv) {
33620:     case NS_ERROR_FILE_NOT_FOUND:
33620:       mError = new nsDOMFileError(nsIDOMFileError::NOT_FOUND_ERR);
33620:       break;
33620:     case NS_ERROR_FILE_ACCESS_DENIED:
33620:       mError = new nsDOMFileError(nsIDOMFileError::SECURITY_ERR);
33620:       break;
33620:     default:
33620:       mError = new nsDOMFileError(nsIDOMFileError::NOT_READABLE_ERR);
33620:       break;
33620:   }
33620: 
33620:   //Dispatch error event to signify load failure
33620:   DispatchProgressEvent(NS_LITERAL_STRING(ERROR_STR));
33620:   DispatchProgressEvent(NS_LITERAL_STRING(LOADEND_STR));
33620: }
33620: 
33620: void
34695: nsDOMFileReader::DispatchProgressEvent(const nsAString& aType)
33620: {
33620:   nsCOMPtr<nsIDOMEvent> event;
33620:   nsresult rv = nsEventDispatcher::CreateEvent(nsnull, nsnull,
33620:                                                NS_LITERAL_STRING("ProgressEvent"),
33620:                                                getter_AddRefs(event));
33620:   if (NS_FAILED(rv))
33620:     return;
33620: 
33620:   nsCOMPtr<nsIPrivateDOMEvent> privevent(do_QueryInterface(event));
33620: 
33620:   if (!privevent)
33620:     return;
33620: 
33620:   privevent->SetTrusted(PR_TRUE);
33620: 
33620:   nsCOMPtr<nsIDOMProgressEvent> progress = do_QueryInterface(event);
33620: 
33620:   if (!progress)
33620:     return;
33620: 
35194:   progress->InitProgressEvent(aType, PR_FALSE, PR_FALSE, mReadTotal >= 0,
35194:                               mReadTransferred, PR_MAX(mReadTotal, 0));
33620: 
33620:   this->DispatchDOMEvent(nsnull, event, nsnull, nsnull);
33620: }
33620: 
33620: nsresult
55115: nsDOMFileReader::GetAsText(const nsACString &aCharset,
33620:                            const char *aFileData,
33620:                            PRUint32 aDataLen,
33620:                            nsAString& aResult)
33620: {
33620:   nsresult rv;
33620:   nsCAutoString charsetGuess;
33620:   if (!aCharset.IsEmpty()) {
55115:     charsetGuess = aCharset;
33620:   } else {
33620:     rv = GuessCharset(aFileData, aDataLen, charsetGuess);
33620:     NS_ENSURE_SUCCESS(rv, rv);
33620:   }
33620: 
33620:   nsCAutoString charset;
33620:   nsCOMPtr<nsICharsetAlias> alias = do_GetService(NS_CHARSETALIAS_CONTRACTID, &rv);
33620:   NS_ENSURE_SUCCESS(rv, rv);
33620: 
33620:   rv = alias->GetPreferred(charsetGuess, charset);
33620:   NS_ENSURE_SUCCESS(rv, rv);
33620: 
33620:   rv = ConvertStream(aFileData, aDataLen, charset.get(), aResult);
33620: 
33620:   return NS_OK;
33620: }
33620: 
33620: nsresult
52042: nsDOMFileReader::GetAsDataURL(nsIDOMFile *aFile,
33620:                               const char *aFileData,
33620:                               PRUint32 aDataLen,
33620:                               nsAString& aResult)
33620: {
33620:   aResult.AssignLiteral("data:");
33620: 
33620:   nsresult rv;
52042:   nsString contentType;
52042:   rv = aFile->GetType(contentType);
52042:   if (NS_SUCCEEDED(rv) && !contentType.IsEmpty()) {
52042:     aResult.Append(contentType);
33620:   } else {
33620:     aResult.AppendLiteral("application/octet-stream");
33620:   }
33620:   aResult.AppendLiteral(";base64,");
33620: 
33620:   PRUint32 totalRead = 0;
55115:   while (aDataLen > totalRead) {
33620:     PRUint32 numEncode = 4096;
33620:     PRUint32 amtRemaining = aDataLen - totalRead;
33620:     if (numEncode > amtRemaining)
33620:       numEncode = amtRemaining;
33620: 
33620:     //Unless this is the end of the file, encode in multiples of 3
33620:     if (numEncode > 3) {
33620:       PRUint32 leftOver = numEncode % 3;
33620:       numEncode -= leftOver;
33620:     }
33620: 
33620:     //Out buffer should be at least 4/3rds the read buf, plus a terminator
33620:     char *base64 = PL_Base64Encode(aFileData + totalRead, numEncode, nsnull);
33620:     AppendASCIItoUTF16(nsDependentCString(base64), aResult);
33620:     PR_Free(base64);
33620: 
33620:     totalRead += numEncode;
55115:   }
33620: 
33620:   return NS_OK;
33620: }
33620: 
33620: nsresult
34695: nsDOMFileReader::ConvertStream(const char *aFileData,
33620:                                PRUint32 aDataLen,
33620:                                const char *aCharset,
33620:                                nsAString &aResult)
33620: {
33620:   nsresult rv;
33620:   nsCOMPtr<nsICharsetConverterManager> charsetConverter = 
33620:     do_GetService(NS_CHARSETCONVERTERMANAGER_CONTRACTID, &rv);
33620:   NS_ENSURE_SUCCESS(rv, rv);
33620: 
33620:   nsCOMPtr<nsIUnicodeDecoder> unicodeDecoder;
33620:   rv = charsetConverter->GetUnicodeDecoder(aCharset, getter_AddRefs(unicodeDecoder));
33620:   NS_ENSURE_SUCCESS(rv, rv);
33620: 
33620:   PRInt32 destLength;
33620:   rv = unicodeDecoder->GetMaxLength(aFileData, aDataLen, &destLength);
33620:   NS_ENSURE_SUCCESS(rv, rv);
33620: 
33620:   aResult.SetLength(destLength);  //Make sure we have enough space for the conversion
33620:   destLength = aResult.Length();
33620: 
33620:   PRInt32 srcLength = aDataLen;
33620:   rv = unicodeDecoder->Convert(aFileData, &srcLength, aResult.BeginWriting(), &destLength);
33620:   aResult.SetLength(destLength); //Trim down to the correct size
33620: 
33620:   return rv;
33620: }
33620: 
33620: nsresult
34695: nsDOMFileReader::GuessCharset(const char *aFileData,
33620:                               PRUint32 aDataLen,
33620:                               nsACString &aCharset)
33620: {
33620:   // First try the universal charset detector
33620:   nsCOMPtr<nsICharsetDetector> detector
33620:     = do_CreateInstance(NS_CHARSET_DETECTOR_CONTRACTID_BASE
33620:                         "universal_charset_detector");
33620:   if (!detector) {
33620:     // No universal charset detector, try the default charset detector
33620:     const nsAdoptingString& detectorName =
33620:       nsContentUtils::GetLocalizedStringPref("intl.charset.detector");
33620:     if (!detectorName.IsEmpty()) {
33620:       nsCAutoString detectorContractID;
33620:       detectorContractID.AssignLiteral(NS_CHARSET_DETECTOR_CONTRACTID_BASE);
33620:       AppendUTF16toUTF8(detectorName, detectorContractID);
33620:       detector = do_CreateInstance(detectorContractID.get());
33620:     }
33620:   }
33620: 
33620:   nsresult rv;
55115:   // The charset detector doesn't work for empty (null) aFileData. Testing
55115:   // aDataLen instead of aFileData so that we catch potential errors.
55115:   if (detector && aDataLen != 0) {
33620:     mCharset.Truncate();
33620:     detector->Init(this);
33620: 
33620:     PRBool done;
33620: 
33620:     rv = detector->DoIt(aFileData, aDataLen, &done);
33620:     NS_ENSURE_SUCCESS(rv, rv);
33620: 
33620:     rv = detector->Done();
33620:     NS_ENSURE_SUCCESS(rv, rv);
33620: 
55115:     aCharset = mCharset;
33620:   } else {
33620:     // no charset detector available, check the BOM
33620:     unsigned char sniffBuf[4];
33620:     PRUint32 numRead = (aDataLen >= sizeof(sniffBuf) ? sizeof(sniffBuf) : aDataLen);
33620:     memcpy(sniffBuf, aFileData, numRead);
33620: 
33620:     if (numRead >= 4 &&
33620:         sniffBuf[0] == 0x00 &&
33620:         sniffBuf[1] == 0x00 &&
33620:         sniffBuf[2] == 0xfe &&
33620:         sniffBuf[3] == 0xff) {
33620:       aCharset = "UTF-32BE";
33620:     } else if (numRead >= 4 &&
33620:                sniffBuf[0] == 0xff &&
33620:                sniffBuf[1] == 0xfe &&
33620:                sniffBuf[2] == 0x00 &&
33620:                sniffBuf[3] == 0x00) {
33620:       aCharset = "UTF-32LE";
33620:     } else if (numRead >= 2 &&
33620:                sniffBuf[0] == 0xfe &&
33620:                sniffBuf[1] == 0xff) {
33620:       aCharset = "UTF-16BE";
33620:     } else if (numRead >= 2 &&
33620:                sniffBuf[0] == 0xff &&
33620:                sniffBuf[1] == 0xfe) {
33620:       aCharset = "UTF-16LE";
33620:     } else if (numRead >= 3 &&
33620:                sniffBuf[0] == 0xef &&
33620:                sniffBuf[1] == 0xbb &&
33620:                sniffBuf[2] == 0xbf) {
33620:       aCharset = "UTF-8";
33620:     }
33620:   }
33620: 
33620:   if (aCharset.IsEmpty()) {
33620:     // no charset detected, default to the system charset
33620:     nsCOMPtr<nsIPlatformCharset> platformCharset =
33620:       do_GetService(NS_PLATFORMCHARSET_CONTRACTID, &rv);
33620:     if (NS_SUCCEEDED(rv)) {
33620:       rv = platformCharset->GetCharset(kPlatformCharsetSel_PlainTextInFile,
33620:                                        aCharset);
33620:     }
33620:   }
33620: 
33620:   if (aCharset.IsEmpty()) {
33620:     // no sniffed or default charset, try UTF-8
33620:     aCharset.AssignLiteral("UTF-8");
33620:   }
33620: 
33620:   return NS_OK;
33620: }
