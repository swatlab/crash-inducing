    1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   John Bandhauer <jband@netscape.com> (original author)
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Nate Nielsen <nielsen@memberwebs.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* High level class and public functions implementation. */
    1: 
    1: #include "xpcprivate.h"
25050: #include "XPCWrapper.h"
    1: #include "nsBaseHashtable.h"
    1: #include "nsHashKeys.h"
   33: #include "jsatom.h"
43286: #include "jsobj.h"
   33: #include "jsfun.h"
62690: #include "jsgc.h"
   33: #include "jsscript.h"
 3310: #include "nsThreadUtilsInternal.h"
18543: #include "dom_quickstubs.h"
55669: #include "nsNullPrincipal.h"
55669: #include "nsIURI.h"
57074: #include "nsJSEnvironment.h"
57556: #include "plbase64.h"
37415: #include "jstypedarray.h"
37415: 
47578: #include "XrayWrapper.h"
55659: #include "WrapperFactory.h"
55669: #include "AccessCheck.h"
47574: 
56783: #include "jsdIDebuggerService.h"
56783: 
59217: #include "xpcquickstubs.h"
59217: 
20462: NS_IMPL_THREADSAFE_ISUPPORTS6(nsXPConnect,
 3310:                               nsIXPConnect,
 3310:                               nsISupportsWeakReference,
20312:                               nsIThreadObserver,
20462:                               nsIJSRuntimeService,
20462:                               nsIJSContextStack,
20462:                               nsIThreadJSContextStack)
    1: 
    1: nsXPConnect* nsXPConnect::gSelf = nsnull;
    1: JSBool       nsXPConnect::gOnceAliveNowDead = JS_FALSE;
14170: PRUint32     nsXPConnect::gReportAllJSExceptions = 0;
56783: JSBool       nsXPConnect::gDebugMode = JS_FALSE;
56783: JSBool       nsXPConnect::gDesiredDebugMode = JS_FALSE;
    1: 
 8870: // Global cache of the default script security manager (QI'd to
 8870: // nsIScriptSecurityManager)
56703: nsIScriptSecurityManager *nsXPConnect::gScriptSecurityManager = nsnull;
 8870: 
    1: const char XPC_CONTEXT_STACK_CONTRACTID[] = "@mozilla.org/js/xpc/ContextStack;1";
    1: const char XPC_RUNTIME_CONTRACTID[]       = "@mozilla.org/js/xpc/RuntimeService;1";
    1: const char XPC_EXCEPTION_CONTRACTID[]     = "@mozilla.org/js/xpc/Exception;1";
    1: const char XPC_CONSOLE_CONTRACTID[]       = "@mozilla.org/consoleservice;1";
    1: const char XPC_SCRIPT_ERROR_CONTRACTID[]  = "@mozilla.org/scripterror;1";
    1: const char XPC_ID_CONTRACTID[]            = "@mozilla.org/js/xpc/ID;1";
    1: const char XPC_XPCONNECT_CONTRACTID[]     = "@mozilla.org/js/xpc/XPConnect;1";
    1: 
    1: /***************************************************************************/
    1: 
    1: nsXPConnect::nsXPConnect()
    1:     :   mRuntime(nsnull),
    1:         mInterfaceInfoManager(do_GetService(NS_INTERFACEINFOMANAGER_SERVICE_CONTRACTID)),
    1:         mDefaultSecurityManager(nsnull),
    1:         mDefaultSecurityManagerFlags(0),
    1:         mShuttingDown(JS_FALSE),
48507:         mCycleCollectionContext(nsnull)
    1: {
20312:     mRuntime = XPCJSRuntime::newXPCJSRuntime(this);
    1: 
    1:     nsCycleCollector_registerRuntime(nsIProgrammingLanguage::JAVASCRIPT, this);
 7286: #ifdef DEBUG_CC
 7286:     mJSRoots.ops = nsnull;
 7286: #endif
    1: 
14170:     char* reportableEnv = PR_GetEnv("MOZ_REPORT_ALL_JS_EXCEPTIONS");
14170:     if(reportableEnv && *reportableEnv)
14170:         gReportAllJSExceptions = 1;
    1: }
    1: 
    1: nsXPConnect::~nsXPConnect()
    1: {
    1:     nsCycleCollector_forgetRuntime(nsIProgrammingLanguage::JAVASCRIPT);
    1: 
 2991:     JSContext *cx = nsnull;
 2991:     if (mRuntime) {
 3100:         // Create our own JSContext rather than an XPCCallContext, since
 3100:         // otherwise we will create a new safe JS context and attach a
 3100:         // components object that won't get GCed.
 3100:         // And do this before calling CleanupAllThreads, so that we
 3100:         // don't create an extra xpcPerThreadData.
31897:         cx = JS_NewContext(mRuntime->GetJSRuntime(), 8192);
 2991:     }
 2991: 
 2991:     XPCPerThreadData::CleanupAllThreads();
    1:     mShuttingDown = JS_TRUE;
 2991:     if (cx) {
 2991:         JS_BeginRequest(cx);
    1: 
 2991:         // XXX Call even if |mRuntime| null?
 2991:         XPCWrappedNativeScope::SystemIsBeingShutDown(cx);
 2991: 
 2991:         mRuntime->SystemIsBeingShutDown(cx);
 2991: 
 2991:         JS_EndRequest(cx);
 2991:         JS_DestroyContext(cx);
    1:     }
    1: 
    1:     NS_IF_RELEASE(mDefaultSecurityManager);
    1: 
 8870:     gScriptSecurityManager = nsnull;
 8870: 
    1:     // shutdown the logging system
    1:     XPC_LOG_FINISH();
    1: 
    1:     delete mRuntime;
    1: 
    1:     gSelf = nsnull;
    1:     gOnceAliveNowDead = JS_TRUE;
    1: }
    1: 
    1: // static
    1: nsXPConnect*
    1: nsXPConnect::GetXPConnect()
    1: {
    1:     if(!gSelf)
    1:     {
    1:         if(gOnceAliveNowDead)
    1:             return nsnull;
    1:         gSelf = new nsXPConnect();
    1:         if(!gSelf)
    1:             return nsnull;
    1: 
62680:         if (!gSelf->mRuntime) {
62680:             NS_RUNTIMEABORT("Couldn't create XPCJSRuntime.");
    1:         }
62680:         if (!gSelf->mInterfaceInfoManager) {
62680:             NS_RUNTIMEABORT("Couldn't get global interface info manager.");
62680:         }
62680: 
    1:         // Initial extra ref to keep the singleton alive
    1:         // balanced by explicit call to ReleaseXPConnectSingleton()
    1:         NS_ADDREF(gSelf);
 3310:         if (NS_FAILED(NS_SetGlobalThreadObserver(gSelf))) {
 3310:             NS_RELEASE(gSelf);
 3310:             // Fall through to returning null
 3310:         }
    1:     }
    1:     return gSelf;
    1: }
    1: 
    1: // static
    1: nsXPConnect*
    1: nsXPConnect::GetSingleton()
    1: {
    1:     nsXPConnect* xpc = nsXPConnect::GetXPConnect();
    1:     NS_IF_ADDREF(xpc);
    1:     return xpc;
    1: }
    1: 
    1: // static
    1: void
    1: nsXPConnect::ReleaseXPConnectSingleton()
    1: {
    1:     nsXPConnect* xpc = gSelf;
    1:     if(xpc)
    1:     {
 3310:         NS_SetGlobalThreadObserver(nsnull);
    1: 
  858: #ifdef DEBUG
    1:         // force a dump of the JavaScript gc heap if JS is still alive
  858:         // if requested through XPC_SHUTDOWN_HEAP_DUMP environment variable
20462:         {
20462:             // autoscope
    1:             XPCCallContext ccx(NATIVE_CALLER);
    1:             if(ccx.IsValid())
    1:             {
  858:                 const char* dumpName = getenv("XPC_SHUTDOWN_HEAP_DUMP");
  858:                 if(dumpName)
  858:                 {
  858:                     FILE* dumpFile = (*dumpName == '\0' ||
  858:                                       strcmp(dumpName, "stdout") == 0)
  858:                                      ? stdout
  858:                                      : fopen(dumpName, "w");
  858:                     if(dumpFile)
  858:                     {
  917:                         JS_DumpHeap(ccx, dumpFile, nsnull, 0, nsnull,
 3233:                                     static_cast<size_t>(-1), nsnull);
  858:                         if(dumpFile != stdout)
  858:                             fclose(dumpFile);
  858:                     }
  858:                 }
    1:             }
20462:         }
    1: #endif
    1: #ifdef XPC_DUMP_AT_SHUTDOWN
    1:         // NOTE: to see really interesting stuff turn on the prlog stuff.
    1:         // See the comment at the top of xpclog.h to see how to do that.
    1:         xpc->DebugDump(7);
    1: #endif
    1:         nsrefcnt cnt;
    1:         NS_RELEASE2(xpc, cnt);
    1: #ifdef XPC_DUMP_AT_SHUTDOWN
    1:         if(0 != cnt)
    1:             printf("*** dangling reference to nsXPConnect: refcnt=%d\n", cnt);
    1:         else
    1:             printf("+++ XPConnect had no dangling references.\n");
    1: #endif
    1:     }
    1: }
    1: 
    1: // static
    1: nsresult
    1: nsXPConnect::GetInterfaceInfoManager(nsIInterfaceInfoSuperManager** iim,
    1:                                      nsXPConnect* xpc /*= nsnull*/)
    1: {
    1:     if(!xpc && !(xpc = GetXPConnect()))
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     *iim = xpc->mInterfaceInfoManager;
    1:     NS_IF_ADDREF(*iim);
    1:     return NS_OK;
    1: }
    1: 
    1: // static
    1: XPCJSRuntime*
20312: nsXPConnect::GetRuntimeInstance()
    1: {
20312:     nsXPConnect* xpc = GetXPConnect();
20312:     NS_ASSERTION(xpc, "Must not be called if XPC failed to initialize");
20312:     return xpc->GetRuntime();
    1: }
    1: 
    1: // static
    1: JSBool
    1: nsXPConnect::IsISupportsDescendant(nsIInterfaceInfo* info)
    1: {
    1:     PRBool found = PR_FALSE;
    1:     if(info)
    1:         info->HasAncestor(&NS_GET_IID(nsISupports), &found);
    1:     return found;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: typedef PRBool (*InfoTester)(nsIInterfaceInfoManager* manager, const void* data,
    1:                              nsIInterfaceInfo** info);
    1: 
    1: static PRBool IIDTester(nsIInterfaceInfoManager* manager, const void* data,
    1:                         nsIInterfaceInfo** info)
    1: {
    1:     return NS_SUCCEEDED(manager->GetInfoForIID((const nsIID *) data, info)) &&
    1:            *info;
    1: }
    1: 
    1: static PRBool NameTester(nsIInterfaceInfoManager* manager, const void* data,
    1:                       nsIInterfaceInfo** info)
    1: {
    1:     return NS_SUCCEEDED(manager->GetInfoForName((const char *) data, info)) &&
    1:            *info;
    1: }
    1: 
    1: static nsresult FindInfo(InfoTester tester, const void* data, 
    1:                          nsIInterfaceInfoSuperManager* iism,
    1:                          nsIInterfaceInfo** info)
    1: {
    1:     if(tester(iism, data, info))
    1:         return NS_OK;
    1:     
    1:     // If not found, then let's ask additional managers.
    1: 
    1:     PRBool yes;
    1:     nsCOMPtr<nsISimpleEnumerator> list;
    1: 
    1:     if(NS_SUCCEEDED(iism->HasAdditionalManagers(&yes)) && yes &&
    1:        NS_SUCCEEDED(iism->EnumerateAdditionalManagers(getter_AddRefs(list))) &&
    1:        list)
    1:     {
    1:         PRBool more;
    1:         nsCOMPtr<nsIInterfaceInfoManager> current;
    1: 
    1:         while(NS_SUCCEEDED(list->HasMoreElements(&more)) && more &&
    1:               NS_SUCCEEDED(list->GetNext(getter_AddRefs(current))) && current)
    1:         {
    1:             if(tester(current, data, info))
    1:                 return NS_OK;
    1:         }
    1:     }
    1:     
    1:     return NS_ERROR_NO_INTERFACE;
    1: }    
    1: 
    1: nsresult
    1: nsXPConnect::GetInfoForIID(const nsIID * aIID, nsIInterfaceInfo** info)
    1: {
    1:     return FindInfo(IIDTester, aIID, mInterfaceInfoManager, info);
    1: }
    1: 
    1: nsresult
    1: nsXPConnect::GetInfoForName(const char * name, nsIInterfaceInfo** info)
    1: {
    1:     return FindInfo(NameTester, name, mInterfaceInfoManager, info);
    1: }
    1: 
48507: void
 7286: nsXPConnect::Collect()
    1: {
 7286:     // We're dividing JS objects into 2 categories:
 7286:     //
 7286:     // 1. "real" roots, held by the JS engine itself or rooted through the root
 7286:     //    and lock JS APIs. Roots from this category are considered black in the
 7286:     //    cycle collector, any cycle they participate in is uncollectable.
 7286:     //
 7286:     // 2. roots held by C++ objects that participate in cycle collection,
 7286:     //    held by XPConnect (see XPCJSRuntime::TraceXPConnectRoots). Roots from
 7286:     //    this category are considered grey in the cycle collector, their final
48479:     //    color depends on the objects that hold them.
 7286:     //
 7286:     // Note that if a root is in both categories it is the fact that it is in
 7286:     // category 1 that takes precedence, so it will be considered black.
 7286:     //
48479:     // During garbage collection we switch to an additional mark color (gray)
48479:     // when tracing inside TraceXPConnectRoots. This allows us to walk those
48479:     // roots later on and add all objects reachable only from them to the
48479:     // cycle collector.
 7286:     //
48479:     // Phases:
 7286:     //
 7286:     // 1. marking of the roots in category 1 by having the JS GC do its marking
48479:     // 2. marking of the roots in category 2 by XPCJSRuntime::TraceXPConnectRoots
48479:     //    using an additional color (gray).
48479:     // 3. end of GC, GC can sweep its heap
 7286:     //
48507:     // At some later point, when the cycle collector runs:
48507:     //
48479:     // 4. walk gray objects and add them to the cycle collector, cycle collect
47580:     //
48479:     // JS objects that are part of cycles the cycle collector breaks will be
48479:     // collected by the next JS.
 7286:     //
 7286:     // If DEBUG_CC is not defined the cycle collector will not traverse roots
 7286:     // from category 1 or any JS objects held by them. Any JS objects they hold
 7286:     // will already be marked by the JS GC and will thus be colored black
 7286:     // themselves. Any C++ objects they hold will have a missing (untraversed)
 7286:     // edge from the JS object to the C++ object and so it will be marked black
 7286:     // too. This decreases the number of objects that the cycle collector has to
 7286:     // deal with.
 7286:     // To improve debugging, if DEBUG_CC is defined all JS objects are
 7286:     // traversed.
    1: 
48507:     XPCCallContext ccx(NATIVE_CALLER);
48507:     if(!ccx.IsValid())
48507:         return;
48499: 
48499:     nsXPConnect::GetRuntimeInstance()->ClearWeakRoots();
47580: 
48507:     JSContext *cx = ccx.GetJSContext();
47439: 
47439:     // We want to scan the current thread for GC roots only if it was in a
47439:     // request prior to the Collect call to avoid false positives during the
47439:     // cycle collection. So to compensate for JS_BeginRequest in
47439:     // XPCCallContext::Init we disable the conservative scanner if that call
48481:     // has started the request on this thread.
69223:     js::ThreadData &threadData = cx->thread()->data;
69223:     JS_ASSERT(threadData.requestDepth >= 1);
69223:     JS_ASSERT(!threadData.conservativeGC.requestThreshold);
69223:     if(threadData.requestDepth == 1)
69223:         threadData.conservativeGC.requestThreshold = 1;
    1:     JS_GC(cx);
69223:     if(threadData.requestDepth == 1)
69223:         threadData.conservativeGC.requestThreshold = 0;
48507: }
48507: 
48507: NS_IMETHODIMP
48507: nsXPConnect::GarbageCollect()
48507: {
48507:     Collect();
48507:     return NS_OK;
 7286: }
 7286: 
 8146: // JSTRACE_XML can recursively hold on to more JSTRACE_XML objects, adding it to
 8146: // the cycle collector avoids stack overflow.
13824: #define ADD_TO_CC(_kind)    ((_kind) == JSTRACE_OBJECT || (_kind) == JSTRACE_XML)
 8146: 
 7286: #ifdef DEBUG_CC
 7286: struct NoteJSRootTracer : public JSTracer
 7286: {
 7286:     NoteJSRootTracer(PLDHashTable *aObjects,
 7286:                      nsCycleCollectionTraversalCallback& cb)
 7286:       : mObjects(aObjects),
 7286:         mCb(cb)
 7286:     {
 7286:     }
 7286:     PLDHashTable* mObjects;
 7286:     nsCycleCollectionTraversalCallback& mCb;
 7286: };
 7286: 
18907: static void
 7286: NoteJSRoot(JSTracer *trc, void *thing, uint32 kind)
 7286: {
 8146:     if(ADD_TO_CC(kind))
 7286:     {
 7286:         NoteJSRootTracer *tracer = static_cast<NoteJSRootTracer*>(trc);
 7286:         PLDHashEntryHdr *entry = PL_DHashTableOperate(tracer->mObjects, thing,
 7286:                                                       PL_DHASH_ADD);
 7286:         if(entry && !reinterpret_cast<PLDHashEntryStub*>(entry)->key)
 7286:         {
 7286:             reinterpret_cast<PLDHashEntryStub*>(entry)->key = thing;
 7286:             tracer->mCb.NoteRoot(nsIProgrammingLanguage::JAVASCRIPT, thing,
 7286:                                  nsXPConnect::GetXPConnect());
 7286:         }
 7286:     }
48492:     else if(kind != JSTRACE_STRING)
 8146:     {
 8146:         JS_TraceChildren(trc, thing, kind);
 8146:     }
 7286: }
 7286: #endif
 7286: 
 7286: nsresult 
48507: nsXPConnect::BeginCycleCollection(nsCycleCollectionTraversalCallback &cb,
48507:                                   bool explainLiveExpectedGarbage)
 7286: {
57794:     NS_ASSERTION(!mCycleCollectionContext, "Didn't call FinishTraverse?");
48507:     mCycleCollectionContext = new XPCCallContext(NATIVE_CALLER);
48507:     if (!mCycleCollectionContext->IsValid()) {
48507:         mCycleCollectionContext = nsnull;
57794:         return NS_ERROR_FAILURE;
48507:     }
48507: 
63073:     static bool gcHasRun = false;
63073:     if(!gcHasRun)
63073:     {
63073:         JSRuntime* rt = JS_GetRuntime(mCycleCollectionContext->GetJSContext());
63073:         if(!rt)
63073:             NS_RUNTIMEABORT("Failed to get JS runtime!");
63073:         uint32 gcNumber = JS_GetGCParameter(rt, JSGC_NUMBER);
63073:         if(!gcNumber)
63073:             NS_RUNTIMEABORT("Cannot cycle collect if GC has not run first!");
63073:         gcHasRun = true;
63073:     }
63073: 
 7286: #ifdef DEBUG_CC
57794:     NS_ASSERTION(!mJSRoots.ops, "Didn't call FinishCycleCollection?");
 7286: 
48507:     if(explainLiveExpectedGarbage)
 7286:     {
 7286:         // Being called from nsCycleCollector::ExplainLiveExpectedGarbage.
 7286: 
 7286:         // Record all objects held by the JS runtime. This avoids doing a
 7286:         // complete GC if we're just tracing to explain (from
 7286:         // ExplainLiveExpectedGarbage), which makes the results of cycle
 7286:         // collection identical for DEBUG_CC and non-DEBUG_CC builds.
 7286:         if(!PL_DHashTableInit(&mJSRoots, PL_DHashGetStubOps(), nsnull,
 7286:                               sizeof(PLDHashEntryStub), PL_DHASH_MIN_SIZE)) {
 7286:             mJSRoots.ops = nsnull;
 7286: 
 7286:             return NS_ERROR_OUT_OF_MEMORY;
 7286:         }
 7286: 
 7286:         NoteJSRootTracer trc(&mJSRoots, cb);
48507:         JS_TRACER_INIT(&trc, mCycleCollectionContext->GetJSContext(), NoteJSRoot);
 7286:         JS_TraceRuntime(&trc);
 7286:     }
 7286: #else
48507:     NS_ASSERTION(!explainLiveExpectedGarbage, "Didn't call nsXPConnect::Collect()?");
 7286: #endif
 7286: 
48507:     GetRuntime()->AddXPConnectRoots(mCycleCollectionContext->GetJSContext(), cb);
 2954: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult 
57794: nsXPConnect::FinishTraverse()
    1: {
48507:     if (mCycleCollectionContext)
 1084:         mCycleCollectionContext = nsnull;
57794:     return NS_OK;
57794: }
57794: 
57794: nsresult 
57794: nsXPConnect::FinishCycleCollection()
57794: {
 7286: #ifdef DEBUG_CC
 7286:     if(mJSRoots.ops)
 7286:     {
 7286:         PL_DHashTableFinish(&mJSRoots);
 7286:         mJSRoots.ops = nsnull;
 7286:     }
 7286: #endif
 7286: 
    1:     return NS_OK;
    1: }
    1: 
 3669: nsCycleCollectionParticipant *
 3669: nsXPConnect::ToParticipant(void *p)
 3669: {
48479:     if (!ADD_TO_CC(js_GetGCThingTraceKind(p)))
48479:         return NULL;
 3669:     return this;
 3669: }
 3669: 
 1829: NS_IMETHODIMP
67681: nsXPConnect::Root(void *p)
 1829: {
 1829:     return NS_OK;
 1829: }
 1829: 
 5183: #ifdef DEBUG_CC
 5183: void
 5183: nsXPConnect::PrintAllReferencesTo(void *p)
 5183: {
 5183: #ifdef DEBUG
48507:     XPCCallContext ccx(NATIVE_CALLER);
48507:     if(ccx.IsValid())
48507:         JS_DumpHeap(ccx.GetJSContext(), stdout, nsnull, 0, p,
 5183:                     0x7fffffff, nsnull);
 5183: #endif
 5183: }
 5183: #endif
 5183: 
 1829: NS_IMETHODIMP
 1829: nsXPConnect::Unlink(void *p)
    1: {
    1:     return NS_OK;
    1: }
    1: 
 1829: NS_IMETHODIMP
 1829: nsXPConnect::Unroot(void *p)
    1: {
    1:     return NS_OK;
    1: }
    1: 
69648: JSBool
69648: xpc_GCThingIsGrayCCThing(void *thing)
69648: {
69648:     uint32 kind = js_GetGCThingTraceKind(thing);
69648:     return ADD_TO_CC(kind) && xpc_IsGrayGCThing(thing);
69648: }
69648: 
62690: static void
62690: UnmarkGrayChildren(JSTracer *trc, void *thing, uint32 kind)
62690: {
62690:     // If this thing is not a CC-kind or already non-gray then we're done.
62690:     if(!ADD_TO_CC(kind) || !xpc_IsGrayGCThing(thing))
62690:         return;
62690: 
62690:     // Unmark.
62690:     static_cast<js::gc::Cell *>(thing)->unmark(XPC_GC_COLOR_GRAY);
62690: 
62690:     // Trace children.
62690:     JS_TraceChildren(trc, thing, kind);
62690: }
62690: 
62690: void
62690: xpc_UnmarkGrayObjectRecursive(JSObject *obj)
62690: {
62690:     NS_ASSERTION(obj, "Don't pass me null!");
62690: 
62690:     // Unmark.
62690:     obj->unmark(XPC_GC_COLOR_GRAY);
62690: 
62690:     // Tracing requires a JSContext...
62690:     JSContext *cx;
62690:     nsXPConnect* xpc = nsXPConnect::GetXPConnect();
62690:     if(!xpc || NS_FAILED(xpc->GetSafeJSContext(&cx)) || !cx)
62690:     {
62690:         NS_ERROR("Failed to get safe JSContext!");
62690:         return;
62690:     }
62690: 
62690:     // Trace children.
62690:     JSTracer trc;
62690:     JS_TRACER_INIT(&trc, cx, UnmarkGrayChildren);
62690:     JS_TraceChildren(&trc, obj, JSTRACE_OBJECT);
62690: }
62690: 
 7286: struct TraversalTracer : public JSTracer
   33: {
 7286:     TraversalTracer(nsCycleCollectionTraversalCallback &aCb) : cb(aCb)
 7286:     {
 7286:     }
 7286:     nsCycleCollectionTraversalCallback &cb;
 1846: };
   33: 
18907: static void
 1846: NoteJSChild(JSTracer *trc, void *thing, uint32 kind)
   33: {
 8146:     if(ADD_TO_CC(kind))
 1846:     {
 7286:         TraversalTracer *tracer = static_cast<TraversalTracer*>(trc);
62690: 
62690:         // There's no point in further traversing a non-gray object here unless
62690:         // we explicitly want to see all traces.
62690:         if(!xpc_IsGrayGCThing(thing) && !tracer->cb.WantAllTraces())
62690:             return;
62690: 
30096: #if defined(DEBUG)
30096:         if (NS_UNLIKELY(tracer->cb.WantDebugInfo())) {
13202:             // based on DumpNotify in jsapi.c
13202:             if (tracer->debugPrinter) {
13202:                 char buffer[200];
13202:                 tracer->debugPrinter(trc, buffer, sizeof(buffer));
13202:                 tracer->cb.NoteNextEdgeName(buffer);
13202:             } else if (tracer->debugPrintIndex != (size_t)-1) {
13202:                 char buffer[200];
13202:                 JS_snprintf(buffer, sizeof(buffer), "%s[%lu]",
13202:                             static_cast<const char *>(tracer->debugPrintArg),
13202:                             tracer->debugPrintIndex);
13202:                 tracer->cb.NoteNextEdgeName(buffer);
13202:             } else {
13202:                 tracer->cb.NoteNextEdgeName(
13202:                   static_cast<const char*>(tracer->debugPrintArg));
13202:             }
30096:         }
13202: #endif
 7286:         tracer->cb.NoteScriptChild(nsIProgrammingLanguage::JAVASCRIPT, thing);
 1846:     }
48470:     else if(kind != JSTRACE_STRING)
 8146:     {
 8146:         JS_TraceChildren(trc, thing, kind);
 8146:     }
 1846: }
 1846: 
24212: static JSBool
24212: WrapperIsNotMainThreadOnly(XPCWrappedNative *wrapper)
24212: {
24212:     XPCWrappedNativeProto *proto = wrapper->GetProto();
24212:     if(proto && proto->ClassIsMainThreadOnly())
24212:         return PR_FALSE;
24212: 
24212:     // If the native participates in cycle collection then we know it can only
24212:     // be used on the main thread, in that case we assume the wrapped native
24212:     // can only be used on the main thread too.
24212:     nsXPCOMCycleCollectionParticipant* participant;
24212:     return NS_FAILED(CallQueryInterface(wrapper->Native(), &participant));
24212: }
24212: 
 1829: NS_IMETHODIMP
 1846: nsXPConnect::Traverse(void *p, nsCycleCollectionTraversalCallback &cb)
    1: {
 1084:     JSContext *cx = mCycleCollectionContext->GetJSContext();
    1: 
 8005:     uint32 traceKind = js_GetGCThingTraceKind(p);
24212:     JSObject *obj;
48622:     js::Class *clazz;
24212: 
24212:     // We do not want to add wrappers to the cycle collector if they're not
24212:     // explicitly marked as main thread only, because the cycle collector isn't
24212:     // able to deal with objects that might be used off of the main thread. We
24212:     // do want to explicitly mark them for cycle collection if the wrapper has
24212:     // an external reference, because the wrapper would mark the JS object if
24212:     // we did add the wrapper to the cycle collector.
24212:     JSBool dontTraverse = PR_FALSE;
24212:     JSBool markJSObject = PR_FALSE;
24212:     if(traceKind == JSTRACE_OBJECT)
24212:     {
24212:         obj = static_cast<JSObject*>(p);
48622:         clazz = obj->getClass();
24212: 
24212:         if(clazz == &XPC_WN_Tearoff_JSClass)
24212:         {
24212:             XPCWrappedNative *wrapper =
39930:                 (XPCWrappedNative*)xpc_GetJSPrivate(obj->getParent());
24212:             dontTraverse = WrapperIsNotMainThreadOnly(wrapper);
24212:         }
33785:         else if(IS_WRAPPER_CLASS(clazz) && IS_WN_WRAPPER_OBJECT(obj))
24212:         {
24212:             XPCWrappedNative *wrapper = (XPCWrappedNative*)xpc_GetJSPrivate(obj);
24212:             dontTraverse = WrapperIsNotMainThreadOnly(wrapper);
24212:             markJSObject = dontTraverse && wrapper->HasExternalReference();
24212:         }
24212:     }
 7286: 
 7286:     CCNodeType type;
    1: 
 1846: #ifdef DEBUG_CC
11406:     // Note that the conditions under which we specify GCMarked vs.
11406:     // GCUnmarked are different between ExplainLiveExpectedGarbage and
11406:     // the normal case.  In the normal case, we're saying that anything
11406:     // reachable from a JS runtime root is itself such a root.  This
11406:     // doesn't actually break anything; it really just does some of the
11406:     // cycle collector's work for it.  However, when debugging, we
11406:     // (1) actually need to know what the root is and (2) don't want to
11406:     // do an extra GC, so we use mJSRoots, built from JS_TraceRuntime,
11406:     // which produces a different result because we didn't call
11406:     // JS_TraceChildren to trace everything that was reachable.
 7286:     if(mJSRoots.ops)
 7286:     {
11406:         // ExplainLiveExpectedGarbage codepath
 7286:         PLDHashEntryHdr* entry =
 7286:             PL_DHashTableOperate(&mJSRoots, p, PL_DHASH_LOOKUP);
24212:         type = markJSObject || PL_DHASH_ENTRY_IS_BUSY(entry) ? GCMarked :
24212:                                                                GCUnmarked;
 7286:     }
 7286:     else
30096: #endif
 7286:     {
11406:         // Normal codepath (matches non-DEBUG_CC codepath).
64387:         NS_ASSERTION(xpc_IsGrayGCThing(p), "Tried to traverse a non-gray object.");
64387:         type = markJSObject ? GCMarked : GCUnmarked;
 7286:     }
 7286: 
30096:     if (cb.WantDebugInfo()) {
11407:         char name[72];
 8005:         if(traceKind == JSTRACE_OBJECT)
 1846:         {
 3233:             JSObject *obj = static_cast<JSObject*>(p);
48622:             js::Class *clazz = obj->getClass();
    1:             XPCNativeScriptableInfo* si = nsnull;
    1:             if(IS_PROTO_CLASS(clazz))
    1:             {
    1:                 XPCWrappedNativeProto* p =
10858:                     (XPCWrappedNativeProto*) xpc_GetJSPrivate(obj);
    1:                 si = p->GetScriptableInfo();
    1:             }
    1:             if(si)
   33:             {
 1846:                 JS_snprintf(name, sizeof(name), "JS Object (%s - %s)",
 1846:                             clazz->name, si->GetJSClass()->name);
   33:             }
48622:             else if(clazz == &js_ScriptClass)
   33:             {
10858:                 JSScript* script = (JSScript*) xpc_GetJSPrivate(obj);
   33:                 if(script->filename)
   33:                 {
30096:                     JS_snprintf(name, sizeof(name),
30096:                                 "JS Object (Script - %s)",
   33:                                 script->filename);
    1:                 }
    1:                 else
    1:                 {
   33:                     JS_snprintf(name, sizeof(name), "JS Object (Script)");
    1:                 }
   33:             }
48622:             else if(clazz == &js_FunctionClass)
   33:             {
10858:                 JSFunction* fun = (JSFunction*) xpc_GetJSPrivate(obj);
12529:                 JSString* str = JS_GetFunctionId(fun);
12529:                 if(str)
   33:                 {
59889:                     NS_ConvertUTF16toUTF8 fname(JS_GetInternedStringChars(str));
30096:                     JS_snprintf(name, sizeof(name),
30096:                                 "JS Object (Function - %s)", fname.get());
   33:                 }
   33:                 else
   33:                 {
   33:                     JS_snprintf(name, sizeof(name), "JS Object (Function)");
   33:                 }
   33:             }
   33:             else
   33:             {
30096:                 JS_snprintf(name, sizeof(name), "JS Object (%s)",
30096:                             clazz->name);
   33:             }
   33:         }
 1846:         else
 1846:         {
18520:             static const char trace_types[JSTRACE_LIMIT][7] = {
11407:                 "Object",
11407:                 "String",
11407:                 "Xml"
11407:             };
11407:             JS_snprintf(name, sizeof(name), "JS %s", trace_types[traceKind]);
11407:         }
11407: 
18520:         if(traceKind == JSTRACE_OBJECT) {
11407:             JSObject *global = static_cast<JSObject*>(p), *parent;
56451:             while((parent = global->getParent()))
11407:                 global = parent;
11407:             char fullname[100];
30096:             JS_snprintf(fullname, sizeof(fullname),
30096:                         "%s (global=%p)", name, global);
11407:             cb.DescribeNode(type, 0, sizeof(JSObject), fullname);
11407:         } else {
11407:             cb.DescribeNode(type, 0, sizeof(JSObject), name);
11407:         }
30096:     } else {
30096:         cb.DescribeNode(type, 0, sizeof(JSObject), "JS Object");
 1846:     }
 1846: 
 7286:     // There's no need to trace objects that have already been marked by the JS
 7286:     // GC. Any JS objects hanging from them will already be marked. Only do this
 7286:     // if DEBUG_CC is not defined, else we do want to know about all JS objects
 7286:     // to get better graphs and explanations.
30096:     if(!cb.WantAllTraces() && type == GCMarked)
 7286:         return NS_OK;
 7286: 
 7286:     TraversalTracer trc(cb);
 1846: 
 1846:     JS_TRACER_INIT(&trc, cx, NoteJSChild);
 8005:     JS_TraceChildren(&trc, p, traceKind);
 1846: 
24212:     if(traceKind != JSTRACE_OBJECT || dontTraverse)
    1:         return NS_OK;
    1: 
 1846:     if(clazz == &XPC_WN_Tearoff_JSClass)
    1:     {
    1:         // A tearoff holds a strong reference to its native object
    1:         // (see XPCWrappedNative::FlatJSObjectFinalized). Its XPCWrappedNative
    1:         // will be held alive through the parent of the JSObject of the tearoff.
    1:         XPCWrappedNativeTearOff *to =
10858:             (XPCWrappedNativeTearOff*) xpc_GetJSPrivate(obj);
18993:         NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "xpc_GetJSPrivate(obj)->mNative");
    1:         cb.NoteXPCOMChild(to->GetNative());
    1:     }
55659:     // XXX This test does seem fragile, we should probably whitelist classes
55659:     //     that do hold a strong reference, but that might not be possible.
    1:     else if(clazz->flags & JSCLASS_HAS_PRIVATE &&
55659:             clazz->flags & JSCLASS_PRIVATE_IS_NSISUPPORTS)
    1:     {
18993:         NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "xpc_GetJSPrivate(obj)");
10858:         cb.NoteXPCOMChild(static_cast<nsISupports*>(xpc_GetJSPrivate(obj)));
    1:     }
   33: 
    1:     return NS_OK;
    1: }
    1: 
53548: unsigned
53548: nsXPConnect::GetOutstandingRequests(JSContext* cx)
 7286: {
53548:     unsigned n = cx->outstandingRequests;
48507:     XPCCallContext* context = mCycleCollectionContext;
53548:     // Ignore the contribution from the XPCCallContext we created for cycle
 7286:     // collection.
48507:     if(context && cx == context->GetJSContext())
53548:     {
53548:         JS_ASSERT(n);
53548:         --n;
53548:     }
53548:     return n;
 7286: }
 7286: 
 7286: class JSContextParticipant : public nsCycleCollectionParticipant
 7286: {
 7286: public:
67681:     NS_IMETHOD Root(void *n)
 7286:     {
 7286:         return NS_OK;
 7286:     }
 7286:     NS_IMETHOD Unlink(void *n)
 7286:     {
67680:         JSContext *cx = static_cast<JSContext*>(n);
67680:         NS_ASSERTION(cx->globalObject, "global object NULL before unlinking");
67680:         cx->globalObject = nsnull;
 7286:         return NS_OK;
 7286:     }
 7286:     NS_IMETHOD Unroot(void *n)
 7286:     {
 7286:         return NS_OK;
 7286:     }
 7286:     NS_IMETHODIMP Traverse(void *n, nsCycleCollectionTraversalCallback &cb)
 7286:     {
 7286:         JSContext *cx = static_cast<JSContext*>(n);
 7286: 
53548:         // Add outstandingRequests to the count, if there are outstanding
 7286:         // requests the context needs to be kept alive and adding unknown
 7286:         // edges will ensure that any cycles this context is in won't be
 7286:         // collected.
53548:         unsigned refCount = nsXPConnect::GetXPConnect()->GetOutstandingRequests(cx) + 1;
53548: 
53548:         cb.DescribeNode(RefCounted, refCount, sizeof(JSContext), "JSContext");
30096:         NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "[global object]");
48479:         if (cx->globalObject) {
22795:             cb.NoteScriptChild(nsIProgrammingLanguage::JAVASCRIPT,
22795:                                cx->globalObject);
48479:         }
 7286: 
 7286:         return NS_OK;
 7286:     }
 7286: };
 7286: 
 7286: static JSContextParticipant JSContext_cycleCollectorGlobal;
 7286: 
 7286: // static
 7286: nsCycleCollectionParticipant*
 7286: nsXPConnect::JSContextParticipant()
 7286: {
 7286:     return &JSContext_cycleCollectorGlobal;
 7286: }
 7286: 
 7286: NS_IMETHODIMP_(void)
 7286: nsXPConnect::NoteJSContext(JSContext *aJSContext,
 7286:                            nsCycleCollectionTraversalCallback &aCb)
 7286: {
 7286:     aCb.NoteNativeChild(aJSContext, &JSContext_cycleCollectorGlobal);
 7286: }
 7286: 
    1: 
    1: /***************************************************************************/
    1: /***************************************************************************/
    1: // nsIXPConnect interface methods...
    1: 
    1: inline nsresult UnexpectedFailure(nsresult rv)
    1: {
    1:     NS_ERROR("This is not supposed to fail!");
    1:     return rv;
    1: }
    1: 
 3162: class SaveFrame
 3162: {
 3162: public:
 3162:     SaveFrame(JSContext *cx)
 3162:         : mJSContext(cx) {
 3162:         mFrame = JS_SaveFrameChain(mJSContext);
 3162:     }
 3162: 
 3162:     ~SaveFrame() {
 3162:         JS_RestoreFrameChain(mJSContext, mFrame);
 3162:     }
 3162: 
 3162: private:
 3162:     JSContext *mJSContext;
 3162:     JSStackFrame *mFrame;
 3162: };
 3162: 
    1: /* void initClasses (in JSContextPtr aJSContext, in JSObjectPtr aGlobalJSObj); */
    1: NS_IMETHODIMP
    1: nsXPConnect::InitClasses(JSContext * aJSContext, JSObject * aGlobalJSObj)
    1: {
    1:     NS_ASSERTION(aJSContext, "bad param");
    1:     NS_ASSERTION(aGlobalJSObj, "bad param");
    1: 
37912:     // Nest frame chain save/restore in request created by XPCCallContext.
    1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
54733:     JSAutoEnterCompartment ac;
54733:     if(!ac.enter(ccx, aGlobalJSObj))
54733:         return UnexpectedFailure(NS_ERROR_FAILURE);
52495: 
46997:     xpc_InitJSxIDClassObjects();
    1: 
    1:     XPCWrappedNativeScope* scope =
    1:         XPCWrappedNativeScope::GetNewOrUsed(ccx, aGlobalJSObj);
    1: 
    1:     if(!scope)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     scope->RemoveWrappedNativeProtos();
    1: 
    1:     if(!nsXPCComponents::AttachNewComponentsObject(ccx, scope, aGlobalJSObj))
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
35417:     if(XPCPerThreadData::IsMainThread(ccx))
35417:     {
    1:         if (!XPCNativeWrapper::AttachNewConstructorObject(ccx, aGlobalJSObj))
    1:             return UnexpectedFailure(NS_ERROR_FAILURE);
35417:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
18907: static JSBool
48470: TempGlobalResolve(JSContext *aJSContext, JSObject *obj, jsid id)
    1: {
    1:     JSBool resolved;
    1:     return JS_ResolveStandardClass(aJSContext, obj, id, &resolved);
    1: }
    1: 
    1: static JSClass xpcTempGlobalClass = {
20823:     "xpcTempGlobalClass", JSCLASS_GLOBAL_FLAGS,
62397:     JS_PropertyStub,  JS_PropertyStub,  JS_PropertyStub,  JS_StrictPropertyStub,
30654:     JS_EnumerateStub, TempGlobalResolve, JS_ConvertStub,   nsnull,
    1:     JSCLASS_NO_OPTIONAL_MEMBERS
    1: };
    1: 
56703: static bool
56703: CreateNewCompartment(JSContext *cx, JSClass *clasp, nsIPrincipal *principal,
56703:                      xpc::CompartmentPrivate *priv, JSObject **global,
55675:                      JSCompartment **compartment)
48503: {
56703:     // We take ownership of |priv|. Ensure that either we free it in the case
56703:     // of failure or give ownership to the compartment in case of success (in
56703:     // that case it will be free'd in CompartmentCallback during GC).
56703:     nsAutoPtr<xpc::CompartmentPrivate> priv_holder(priv);
48503:     JSPrincipals *principals = nsnull;
48503:     if(principal)
48503:         principal->GetJSPrincipals(cx, &principals);
56703:     JSObject *tempGlobal = JS_NewCompartmentAndGlobalObject(cx, clasp, principals);
48503:     if(principals)
48503:         JSPRINCIPALS_DROP(cx, principals);
48503: 
48503:     if(!tempGlobal)
56703:         return false;
48503: 
54427:     *global = tempGlobal;
61451:     *compartment = tempGlobal->compartment();
48503: 
54737:     js::SwitchToCompartment sc(cx, *compartment);
56703:     JS_SetCompartmentPrivate(cx, *compartment, priv_holder.forget());
56703:     return true;
56703: }
48503: 
56703: nsresult
56703: xpc_CreateGlobalObject(JSContext *cx, JSClass *clasp,
56703:                        nsIPrincipal *principal, nsISupports *ptr,
56703:                        bool wantXrays, JSObject **global,
56703:                        JSCompartment **compartment)
56703: {
56703:     NS_ABORT_IF_FALSE(NS_IsMainThread(), "using a principal off the main thread?");
56703:     NS_ABORT_IF_FALSE(principal, "bad key");
56703: 
56703:     nsCOMPtr<nsIURI> uri;
56703:     nsresult rv = principal->GetURI(getter_AddRefs(uri));
56703:     if(NS_FAILED(rv))
56703:         return UnexpectedFailure(rv);
56703: 
56703:     XPCCompartmentMap& map = nsXPConnect::GetRuntimeInstance()->GetCompartmentMap();
56703:     xpc::PtrAndPrincipalHashKey key(ptr, uri);
56703:     if(!map.Get(&key, compartment))
56703:     {
56703:         xpc::PtrAndPrincipalHashKey *priv_key =
56703:             new xpc::PtrAndPrincipalHashKey(ptr, uri);
55675:         xpc::CompartmentPrivate *priv =
56709:             new xpc::CompartmentPrivate(priv_key, wantXrays, NS_IsMainThread());
56703:         if(!CreateNewCompartment(cx, clasp, principal, priv,
56703:                                  global, compartment))
56703:         {
56703:             return UnexpectedFailure(NS_ERROR_FAILURE);
56703:         }
56703: 
56703:         map.Put(&key, *compartment);
48503:     }
48503:     else
48503:     {
54737:         js::SwitchToCompartment sc(cx, *compartment);
54427: 
56703:         JSObject *tempGlobal = JS_NewGlobalObject(cx, clasp);
48503:         if(!tempGlobal)
48503:             return UnexpectedFailure(NS_ERROR_FAILURE);
48503:         *global = tempGlobal;
48503:     }
48503: 
48503:     return NS_OK;
48503: }
48503: 
56703: nsresult
56703: xpc_CreateMTGlobalObject(JSContext *cx, JSClass *clasp,
56703:                          nsISupports *ptr, JSObject **global,
56703:                          JSCompartment **compartment)
56703: {
56703:     // NB: We can be either on or off the main thread here.
56703:     XPCMTCompartmentMap& map = nsXPConnect::GetRuntimeInstance()->GetMTCompartmentMap();
56703:     if(!map.Get(ptr, compartment))
56703:     {
56703:         // We allow the pointer to be a principal, in which case it becomes
56703:         // the principal for the newly created compartment. The caller is
56703:         // responsible for ensuring that doing this doesn't violate
56703:         // threadsafety assumptions.
56703:         nsCOMPtr<nsIPrincipal> principal(do_QueryInterface(ptr));
56703:         xpc::CompartmentPrivate *priv =
56709:             new xpc::CompartmentPrivate(ptr, false, NS_IsMainThread());
56703:         if(!CreateNewCompartment(cx, clasp, principal, priv, global,
56703:                                  compartment))
56703:         {
56703:             return UnexpectedFailure(NS_ERROR_UNEXPECTED);
56703:         }
56703: 
56703:         map.Put(ptr, *compartment);
56703:     }
56703:     else
56703:     {
56703:         js::SwitchToCompartment sc(cx, *compartment);
56703: 
56703:         JSObject *tempGlobal = JS_NewGlobalObject(cx, clasp);
56703:         if(!tempGlobal)
56703:             return UnexpectedFailure(NS_ERROR_FAILURE);
56703:         *global = tempGlobal;
56703:     }
56703: 
56703:     return NS_OK;
56703: }
56703: 
    1: NS_IMETHODIMP
    1: nsXPConnect::InitClassesWithNewWrappedGlobal(JSContext * aJSContext,
    1:                                              nsISupports *aCOMObj,
    1:                                              const nsIID & aIID,
48503:                                              nsIPrincipal * aPrincipal,
56703:                                              nsISupports * aExtraPtr,
    1:                                              PRUint32 aFlags,
    1:                                              nsIXPConnectJSObjectHolder **_retval)
    1: {
    1:     NS_ASSERTION(aJSContext, "bad param");
    1:     NS_ASSERTION(aCOMObj, "bad param");
    1:     NS_ASSERTION(_retval, "bad param");
56703:     NS_ASSERTION(aExtraPtr || aPrincipal, "must be able to find a compartment");
    1: 
    1:     // XXX This is not pretty. We make a temporary global object and
    1:     // init it with all the Components object junk just so we have a
    1:     // parent with an xpc scope to use when wrapping the object that will
    1:     // become the 'real' global.
    1: 
    1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
    1: 
48503:     JSCompartment* compartment;
48503:     JSObject* tempGlobal;
48503: 
56703:     nsresult rv = aPrincipal
56703:                   ? xpc_CreateGlobalObject(ccx, &xpcTempGlobalClass, aPrincipal,
56703:                                            aExtraPtr, false, &tempGlobal,
56703:                                            &compartment)
56703:                   : xpc_CreateMTGlobalObject(ccx, &xpcTempGlobalClass,
56703:                                              aExtraPtr, &tempGlobal,
55675:                                              &compartment);
48503:     NS_ENSURE_SUCCESS(rv, rv);
48503: 
54733:     JSAutoEnterCompartment ac;
54733:     if(!ac.enter(ccx, tempGlobal))
54733:         return UnexpectedFailure(NS_ERROR_FAILURE);
62405:     ccx.SetScopeForNewJSObjects(tempGlobal);
48503: 
 7987:     PRBool system = (aFlags & nsIXPConnect::FLAG_SYSTEM_GLOBAL_OBJECT) != 0;
48503:     if(system && !JS_MakeSystemObject(aJSContext, tempGlobal))
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
22841:     jsval v;
    1:     nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
    1:     {
    1:         // Scope for our auto-marker; it just needs to keep tempGlobal alive
    1:         // long enough for InitClasses and WrapNative to do their work
    1:         AUTO_MARK_JSVAL(ccx, OBJECT_TO_JSVAL(tempGlobal));
    1: 
    1:         if(NS_FAILED(InitClasses(aJSContext, tempGlobal)))
    1:             return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
51515:         nsresult rv;
51515:         xpcObjectHelper helper(aCOMObj);
22841:         if(!XPCConvert::NativeInterface2JSObject(ccx, &v,
22841:                                                  getter_AddRefs(holder),
51515:                                                  helper, &aIID, nsnull,
62405:                                                  PR_FALSE, OBJ_IS_GLOBAL, &rv))
    1:             return UnexpectedFailure(rv);
    1: 
    1:         NS_ASSERTION(NS_SUCCEEDED(rv) && holder, "Didn't wrap properly");
    1:     }
    1: 
22841:     JSObject* globalJSObj = JSVAL_TO_OBJECT(v);
22841:     if(!globalJSObj)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     if(aFlags & nsIXPConnect::FLAG_SYSTEM_GLOBAL_OBJECT)
    1:         NS_ASSERTION(JS_IsSystemObject(aJSContext, globalJSObj), "huh?!");
    1: 
    1:     // voodoo to fixup scoping and parenting...
    1: 
43286:     JS_ASSERT(!globalJSObj->getParent());
    1: 
    1:     JSObject* oldGlobal = JS_GetGlobalObject(aJSContext);
    1:     if(!oldGlobal || oldGlobal == tempGlobal)
    1:         JS_SetGlobalObject(aJSContext, globalJSObj);
    1: 
    1:     if((aFlags & nsIXPConnect::INIT_JS_STANDARD_CLASSES) &&
    1:        !JS_InitStandardClasses(aJSContext, globalJSObj))
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     XPCWrappedNative* wrapper =
 3233:         reinterpret_cast<XPCWrappedNative*>(holder.get());
    1:     XPCWrappedNativeScope* scope = wrapper->GetScope();
    1: 
    1:     if(!scope)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
55586:     // Note: This call cooperates with a call to wrapper->RefreshPrototype()
59622:     // in nsJSEnvironment::SetOuterObject in order to ensure that the
55586:     // prototype defines its constructor on the right global object.
55586:     if(wrapper->GetProto()->GetScriptableInfo())
55586:         scope->RemoveWrappedNativeProtos();
55586: 
    1:     NS_ASSERTION(scope->GetGlobalJSObject() == tempGlobal, "stealing scope!");
    1: 
    1:     scope->SetGlobal(ccx, globalJSObj);
    1: 
    1:     JSObject* protoJSObject = wrapper->HasProto() ?
    1:                                     wrapper->GetProto()->GetJSProtoObject() :
    1:                                     globalJSObj;
    1:     if(protoJSObject)
    1:     {
    1:         if(protoJSObject != globalJSObj)
    1:             JS_SetParent(aJSContext, protoJSObject, globalJSObj);
    1:         JS_SetPrototype(aJSContext, protoJSObject, scope->GetPrototypeJSObject());
    1:     }
    1: 
22479:     if(!(aFlags & nsIXPConnect::OMIT_COMPONENTS_OBJECT)) {
37912:         // XPCCallContext gives us an active request needed to save/restore.
    1:         if(!nsXPCComponents::AttachNewComponentsObject(ccx, scope, globalJSObj))
    1:             return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
35417:         if(XPCPerThreadData::IsMainThread(ccx))
35417:         {
    1:             if(!XPCNativeWrapper::AttachNewConstructorObject(ccx, globalJSObj))
    1:                 return UnexpectedFailure(NS_ERROR_FAILURE);
22479:         }
35417:     }
    1: 
    1:     NS_ADDREF(*_retval = holder);
    1: 
    1:     return NS_OK;
    1: }
    1: 
58714: nsresult
58714: xpc_MorphSlimWrapper(JSContext *cx, nsISupports *tomorph)
58714: {
58714:     nsWrapperCache *cache;
58714:     CallQueryInterface(tomorph, &cache);
58714:     if(!cache)
58714:         return NS_OK;
58714: 
58714:     JSObject *obj = cache->GetWrapper();
58714:     if(!obj || !IS_SLIM_WRAPPER(obj))
58714:         return NS_OK;
58714:     return MorphSlimWrapper(cx, obj);
58714: }
58714: 
31981: static nsresult
31981: NativeInterface2JSObject(XPCLazyCallContext & lccx,
31981:                          JSObject * aScope,
31981:                          nsISupports *aCOMObj,
48171:                          nsWrapperCache *aCache,
31981:                          const nsIID * aIID,
31981:                          PRBool aAllowWrapping,
31981:                          jsval *aVal,
31981:                          nsIXPConnectJSObjectHolder **aHolder)
31981: {
62405:     JSAutoEnterCompartment ac;
62405:     if (!ac.enter(lccx.GetJSContext(), aScope))
62405:         return NS_ERROR_OUT_OF_MEMORY;
62405: 
62405:     lccx.SetScopeForNewJSObjects(aScope);
62405: 
31981:     nsresult rv;
51515:     xpcObjectHelper helper(aCOMObj, aCache);
51515:     if(!XPCConvert::NativeInterface2JSObject(lccx, aVal, aHolder, helper, aIID,
62405:                                              nsnull, aAllowWrapping,
51515:                                              OBJ_IS_NOT_GLOBAL, &rv))
31981:         return rv;
31981: 
31981: #ifdef DEBUG
55659:     NS_ASSERTION(aAllowWrapping ||
55659:                  !xpc::WrapperFactory::IsXrayWrapper(JSVAL_TO_OBJECT(*aVal)),
55659:                  "Shouldn't be returning a xray wrapper here");
31981: #endif
31981:     
31981:     return NS_OK;
31981: }
31981: 
    1: /* nsIXPConnectJSObjectHolder wrapNative (in JSContextPtr aJSContext, in JSObjectPtr aScope, in nsISupports aCOMObj, in nsIIDRef aIID); */
    1: NS_IMETHODIMP
    1: nsXPConnect::WrapNative(JSContext * aJSContext,
    1:                         JSObject * aScope,
    1:                         nsISupports *aCOMObj,
    1:                         const nsIID & aIID,
22841:                         nsIXPConnectJSObjectHolder **aHolder)
22841: {
22841:     NS_ASSERTION(aHolder, "bad param");
31981:     NS_ASSERTION(aJSContext, "bad param");
31981:     NS_ASSERTION(aScope, "bad param");
31981:     NS_ASSERTION(aCOMObj, "bad param");
31981: 
31981:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
31981:     if(!ccx.IsValid())
31981:         return UnexpectedFailure(NS_ERROR_FAILURE);
31981:     XPCLazyCallContext lccx(ccx);
22841: 
22841:     jsval v;
48171:     return NativeInterface2JSObject(lccx, aScope, aCOMObj, nsnull, &aIID,
48171:                                     PR_FALSE, &v, aHolder);
22841: }
22841: 
42675: /* void wrapNativeToJSVal (in JSContextPtr aJSContext, in JSObjectPtr aScope, in nsISupports aCOMObj, in nsIIDPtr aIID, out jsval aVal, out nsIXPConnectJSObjectHolder aHolder); */
22841: NS_IMETHODIMP
22841: nsXPConnect::WrapNativeToJSVal(JSContext * aJSContext,
22841:                                JSObject * aScope,
22841:                                nsISupports *aCOMObj,
48171:                                nsWrapperCache *aCache,
22842:                                const nsIID * aIID,
30625:                                PRBool aAllowWrapping,
22841:                                jsval *aVal,
22841:                                nsIXPConnectJSObjectHolder **aHolder)
    1: {
    1:     NS_ASSERTION(aJSContext, "bad param");
    1:     NS_ASSERTION(aScope, "bad param");
    1:     NS_ASSERTION(aCOMObj, "bad param");
    1: 
22841:     if(aHolder)
22841:         *aHolder = nsnull;
    1: 
31981:     XPCLazyCallContext lccx(NATIVE_CALLER, aJSContext);
31981: 
48171:     return NativeInterface2JSObject(lccx, aScope, aCOMObj, aCache, aIID,
48171:                                     aAllowWrapping, aVal, aHolder);
    1: }
    1: 
    1: /* void wrapJS (in JSContextPtr aJSContext, in JSObjectPtr aJSObj, in nsIIDRef aIID, [iid_is (aIID), retval] out nsQIResult result); */
    1: NS_IMETHODIMP
    1: nsXPConnect::WrapJS(JSContext * aJSContext,
    1:                     JSObject * aJSObj,
    1:                     const nsIID & aIID,
    1:                     void * *result)
    1: {
    1:     NS_ASSERTION(aJSContext, "bad param");
    1:     NS_ASSERTION(aJSObj, "bad param");
    1:     NS_ASSERTION(result, "bad param");
    1: 
    1:     *result = nsnull;
    1: 
    1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
55601:     JSAutoEnterCompartment aec;
55601: 
55601:     nsresult rv = NS_ERROR_UNEXPECTED;
55601:     if(!aec.enter(ccx, aJSObj) ||
55601:        !XPCConvert::JSObject2NativeInterface(ccx, result, aJSObj,
 5491:                                              &aIID, nsnull, &rv))
    1:         return rv;
    1:     return NS_OK;
    1: }
    1: 
37802: NS_IMETHODIMP
37802: nsXPConnect::JSValToVariant(JSContext *cx,
37802:                             jsval *aJSVal,
37802:                             nsIVariant ** aResult)
37802: {
37802:     NS_PRECONDITION(aJSVal, "bad param");
37802:     NS_PRECONDITION(aResult, "bad param");
37802:     *aResult = nsnull;
37802: 
37802:     XPCCallContext ccx(NATIVE_CALLER, cx);
37802:     if(!ccx.IsValid())
37802:       return NS_ERROR_FAILURE;
37802: 
37802:     *aResult = XPCVariant::newVariant(ccx, *aJSVal);
37802:     NS_ENSURE_TRUE(*aResult, NS_ERROR_OUT_OF_MEMORY);
37802: 
37802:     return NS_OK;
37802: }
37802: 
    1: /* void wrapJSAggregatedToNative (in nsISupports aOuter, in JSContextPtr aJSContext, in JSObjectPtr aJSObj, in nsIIDRef aIID, [iid_is (aIID), retval] out nsQIResult result); */
    1: NS_IMETHODIMP
    1: nsXPConnect::WrapJSAggregatedToNative(nsISupports *aOuter,
    1:                                       JSContext * aJSContext,
    1:                                       JSObject * aJSObj,
    1:                                       const nsIID & aIID,
    1:                                       void * *result)
    1: {
    1:     NS_ASSERTION(aOuter, "bad param");
    1:     NS_ASSERTION(aJSContext, "bad param");
    1:     NS_ASSERTION(aJSObj, "bad param");
    1:     NS_ASSERTION(result, "bad param");
    1: 
    1:     *result = nsnull;
    1: 
    1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     nsresult rv;
    1:     if(!XPCConvert::JSObject2NativeInterface(ccx, result, aJSObj,
 5491:                                              &aIID, aOuter, &rv))
    1:         return rv;
    1:     return NS_OK;
    1: }
    1: 
    1: /* nsIXPConnectWrappedNative getWrappedNativeOfJSObject (in JSContextPtr aJSContext, in JSObjectPtr aJSObj); */
    1: NS_IMETHODIMP
    1: nsXPConnect::GetWrappedNativeOfJSObject(JSContext * aJSContext,
    1:                                         JSObject * aJSObj,
    1:                                         nsIXPConnectWrappedNative **_retval)
    1: {
    1:     NS_ASSERTION(aJSContext, "bad param");
    1:     NS_ASSERTION(aJSObj, "bad param");
    1:     NS_ASSERTION(_retval, "bad param");
    1: 
    1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
30001:     SLIM_LOG_WILL_MORPH(aJSContext, aJSObj);
    1:     nsIXPConnectWrappedNative* wrapper =
33785:         XPCWrappedNative::GetAndMorphWrappedNativeOfJSObject(aJSContext, aJSObj);
    1:     if(wrapper)
    1:     {
    1:         NS_ADDREF(wrapper);
    1:         *_retval = wrapper;
    1:         return NS_OK;
    1:     }
30001: 
30001:     // else...
30001:     *_retval = nsnull;
30001:     return NS_ERROR_FAILURE;
30001: }
30001: 
30001: /* nsISupports getNativeOfWrapper(in JSContextPtr aJSContext, in JSObjectPtr  aJSObj); */
30001: NS_IMETHODIMP_(nsISupports*)
30001: nsXPConnect::GetNativeOfWrapper(JSContext * aJSContext,
30001:                                 JSObject * aJSObj)
30001: {
30001:     NS_ASSERTION(aJSContext, "bad param");
30001:     NS_ASSERTION(aJSObj, "bad param");
30001: 
30001:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
30001:     if(!ccx.IsValid())
30001:     {
30001:         UnexpectedFailure(NS_ERROR_FAILURE);
30001:         return nsnull;
30001:     }
30001: 
30001:     JSObject* obj2 = nsnull;
30001:     nsIXPConnectWrappedNative* wrapper =
30001:         XPCWrappedNative::GetWrappedNativeOfJSObject(aJSContext, aJSObj, nsnull,
30001:                                                      &obj2);
30001: 
30001:     return wrapper ? wrapper->Native() :
30001:                      (obj2 ? (nsISupports*)xpc_GetJSPrivate(obj2) : nsnull);
30001: }
30001: 
30001: /* JSObjectPtr getJSObjectOfWrapper (in JSContextPtr aJSContext, in JSObjectPtr aJSObj); */
30001: NS_IMETHODIMP
30001: nsXPConnect::GetJSObjectOfWrapper(JSContext * aJSContext,
30001:                                   JSObject * aJSObj,
30001:                                   JSObject **_retval)
30001: {
30001:     NS_ASSERTION(aJSContext, "bad param");
30001:     NS_ASSERTION(aJSObj, "bad param");
30001:     NS_ASSERTION(_retval, "bad param");
30001: 
30001:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
30001:     if(!ccx.IsValid())
30001:         return UnexpectedFailure(NS_ERROR_FAILURE);
30001: 
30001:     JSObject* obj2 = nsnull;
30001:     nsIXPConnectWrappedNative* wrapper =
30001:         XPCWrappedNative::GetWrappedNativeOfJSObject(aJSContext, aJSObj, nsnull,
30001:                                                      &obj2);
30001:     if(wrapper)
30001:     {
30001:         wrapper->GetJSObject(_retval);
30001:         return NS_OK;
30001:     }
30001:     if(obj2)
30001:     {
30001:         *_retval = obj2;
30001:         return NS_OK;
30001:     }
    1:     // else...
    1:     *_retval = nsnull;
    1:     return NS_ERROR_FAILURE;
    1: }
    1: 
    1: /* nsIXPConnectWrappedNative getWrappedNativeOfNativeObject (in JSContextPtr aJSContext, in JSObjectPtr aScope, in nsISupports aCOMObj, in nsIIDRef aIID); */
    1: NS_IMETHODIMP
    1: nsXPConnect::GetWrappedNativeOfNativeObject(JSContext * aJSContext,
    1:                                             JSObject * aScope,
    1:                                             nsISupports *aCOMObj,
    1:                                             const nsIID & aIID,
    1:                                             nsIXPConnectWrappedNative **_retval)
    1: {
    1:     NS_ASSERTION(aJSContext, "bad param");
    1:     NS_ASSERTION(aScope, "bad param");
    1:     NS_ASSERTION(aCOMObj, "bad param");
    1:     NS_ASSERTION(_retval, "bad param");
    1: 
    1:     *_retval = nsnull;
    1: 
    1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     XPCWrappedNativeScope* scope =
    1:         XPCWrappedNativeScope::FindInJSObjectScope(ccx, aScope);
    1:     if(!scope)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     AutoMarkingNativeInterfacePtr iface(ccx);
    1:     iface = XPCNativeInterface::GetNewOrUsed(ccx, &aIID);
    1:     if(!iface)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     XPCWrappedNative* wrapper;
    1: 
    1:     nsresult rv = XPCWrappedNative::GetUsedOnly(ccx, aCOMObj, scope, iface,
    1:                                                 &wrapper);
    1:     if(NS_FAILED(rv))
    1:         return NS_ERROR_FAILURE;
 3233:     *_retval = static_cast<nsIXPConnectWrappedNative*>(wrapper);
    1:     return NS_OK;
    1: }
    1: 
    1: /* nsIXPConnectJSObjectHolder reparentWrappedNativeIfFound (in JSContextPtr aJSContext, in JSObjectPtr aScope, in JSObjectPtr aNewParent, in nsISupports aCOMObj); */
    1: NS_IMETHODIMP
    1: nsXPConnect::ReparentWrappedNativeIfFound(JSContext * aJSContext,
    1:                                           JSObject * aScope,
    1:                                           JSObject * aNewParent,
    1:                                           nsISupports *aCOMObj,
    1:                                           nsIXPConnectJSObjectHolder **_retval)
    1: {
    1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     XPCWrappedNativeScope* scope =
    1:         XPCWrappedNativeScope::FindInJSObjectScope(ccx, aScope);
    1:     if(!scope)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     XPCWrappedNativeScope* scope2 =
    1:         XPCWrappedNativeScope::FindInJSObjectScope(ccx, aNewParent);
    1:     if(!scope2)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     return XPCWrappedNative::
    1:         ReparentWrapperIfFound(ccx, scope, scope2, aNewParent, aCOMObj,
    1:                                (XPCWrappedNative**) _retval);
    1: }
    1: 
18907: static JSDHashOperator
    1: MoveableWrapperFinder(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                       uint32 number, void *arg)
    1: {
29161:     nsTArray<nsRefPtr<XPCWrappedNative> > *array =
29161:         static_cast<nsTArray<nsRefPtr<XPCWrappedNative> > *>(arg);
58714:     XPCWrappedNative *wn = ((Native2WrappedNativeMap::Entry*)hdr)->value;
58714: 
58714:     // If a wrapper is expired, then there are no references to it from JS, so
58714:     // we don't have to move it.
58714:     if(!wn->IsWrapperExpired())
58714:         array->AppendElement(wn);
    1:     return JS_DHASH_NEXT;
    1: }
    1: 
61142: static nsresult
61142: MoveWrapper(XPCCallContext& ccx, XPCWrappedNative *wrapper,
61142:             XPCWrappedNativeScope *newScope, XPCWrappedNativeScope *oldScope)
61142: {
61142:     // First, check to see if this wrapper really needs to be
61142:     // reparented.
61142: 
61142:     if (wrapper->GetScope() == newScope)
61142:     {
61142:         // The wrapper already got moved, nothing to do here.
61142:         return NS_OK;
61142:     }
61142: 
61142:     nsISupports *identity = wrapper->GetIdentityObject();
61142:     nsCOMPtr<nsIClassInfo> info(do_QueryInterface(identity));
61142: 
61142:     // ClassInfo is implemented as singleton objects. If the identity
61142:     // object here is the same object as returned by the QI, then it
61142:     // is the singleton classinfo, so we don't need to reparent it.
61142:     if(SameCOMIdentity(identity, info))
61142:         info = nsnull;
61142: 
61142:     if(!info)
61142:         return NS_OK;
61142: 
61142:     XPCNativeScriptableCreateInfo sciProto;
61142:     XPCNativeScriptableCreateInfo sci;
61142:     const XPCNativeScriptableCreateInfo& sciWrapper =
61142:         XPCWrappedNative::GatherScriptableCreateInfo(identity, info,
61142:                                                      sciProto, sci);
61142: 
61142:     // If the wrapper doesn't want precreate, then we don't need to
61142:     // worry about reparenting it.
61142:     if(!sciWrapper.GetFlags().WantPreCreate())
61142:         return NS_OK;
61142: 
61142:     JSObject *newParent = oldScope->GetGlobalJSObject();
61142:     nsresult rv = sciWrapper.GetCallback()->PreCreate(identity, ccx,
61142:                                                       newParent,
61142:                                                       &newParent);
61142:     if(NS_FAILED(rv))
61142:         return rv;
61142: 
61142:     if(newParent == oldScope->GetGlobalJSObject())
61142:     {
61142:         // The old scope still works for this wrapper. We have to
61142:         // assume that the wrapper will continue to return the old
61142:         // scope from PreCreate, so don't move it.
61142:         return NS_OK;
61142:     }
61142: 
61142:     // The wrapper returned a new parent. If the new parent is in a
61142:     // different scope, then we need to reparent it, otherwise, the
61142:     // old scope is fine.
61142: 
61142:     XPCWrappedNativeScope *betterScope =
61142:         XPCWrappedNativeScope::FindInJSObjectScope(ccx, newParent);
61142:     if(betterScope == oldScope)
61142:     {
61142:         // The wrapper asked for a different object, but that object
61142:         // was in the same scope. This means that the new parent
61142:         // simply hasn't been reparented yet, so reparent it first,
61142:         // and then continue reparenting the wrapper itself.
61142: 
61142:         if (!IS_WN_WRAPPER_OBJECT(newParent)) {
61142:             // The parent of wrapper is a slim wrapper, in this case
61142:             // we need to morph the parent so that we can reparent it.
61142: 
61142:             rv = MorphSlimWrapper(ccx, newParent);
61142:             NS_ENSURE_SUCCESS(rv, rv);
61142:         }
61142: 
61142:         XPCWrappedNative *parentWrapper =
61142:             XPCWrappedNative::GetWrappedNativeOfJSObject(ccx, newParent);
61142: 
61142:         rv = MoveWrapper(ccx, parentWrapper, newScope, oldScope);
61142: 
61142:         NS_ENSURE_SUCCESS(rv, rv);
61142: 
62690:         newParent = parentWrapper->GetFlatJSObject();
61142:     }
61142:     else
61142:         NS_ASSERTION(betterScope == newScope, "Weird scope returned");
61142: 
61142:     // Now, reparent the wrapper, since we know that it wants to be
61142:     // reparented.
61142: 
61142:     nsRefPtr<XPCWrappedNative> junk;
61142:     rv = XPCWrappedNative::ReparentWrapperIfFound(ccx, oldScope,
61142:                                                   newScope, newParent,
61142:                                                   wrapper->GetIdentityObject(),
61142:                                                   getter_AddRefs(junk));
61142:     return rv;
61142: }
61142: 
40041: /* void moveWrappers(in JSContextPtr aJSContext, in JSObjectPtr  aOldScope, in JSObjectPtr  aNewScope); */
    1: NS_IMETHODIMP
40041: nsXPConnect::MoveWrappers(JSContext *aJSContext,
    1:                           JSObject *aOldScope,
    1:                           JSObject *aNewScope)
    1: {
    1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     XPCWrappedNativeScope *oldScope =
    1:         XPCWrappedNativeScope::FindInJSObjectScope(ccx, aOldScope);
    1:     if(!oldScope)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     XPCWrappedNativeScope *newScope =
    1:         XPCWrappedNativeScope::FindInJSObjectScope(ccx, aNewScope);
    1:     if(!newScope)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
 4187:     // First, look through the old scope and find all of the wrappers that
 4187:     // we're going to move.
29161:     nsTArray<nsRefPtr<XPCWrappedNative> > wrappersToMove;
 4187: 
    1:     {   // scoped lock
20312:         XPCAutoLock lock(GetRuntime()->GetMapLock());
    1:         Native2WrappedNativeMap *map = oldScope->GetWrappedNativeMap();
26582:         wrappersToMove.SetCapacity(map->Count());
    1:         map->Enumerate(MoveableWrapperFinder, &wrappersToMove);
 4187:     }
    1: 
    1:     // Now that we have the wrappers, reparent them to the new scope.
26582:     for(PRUint32 i = 0, stop = wrappersToMove.Length(); i < stop; ++i)
    1:     {
61142:         nsresult rv = MoveWrapper(ccx, wrappersToMove[i], newScope, oldScope);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: /* void setSecurityManagerForJSContext (in JSContextPtr aJSContext, in nsIXPCSecurityManager aManager, in PRUint16 flags); */
    1: NS_IMETHODIMP
    1: nsXPConnect::SetSecurityManagerForJSContext(JSContext * aJSContext,
    1:                                             nsIXPCSecurityManager *aManager,
    1:                                             PRUint16 flags)
    1: {
    1:     NS_ASSERTION(aJSContext, "bad param");
    1: 
    1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     XPCContext* xpcc = ccx.GetXPCContext();
    1: 
    1:     NS_IF_ADDREF(aManager);
    1:     nsIXPCSecurityManager* oldManager = xpcc->GetSecurityManager();
    1:     NS_IF_RELEASE(oldManager);
    1: 
    1:     xpcc->SetSecurityManager(aManager);
    1:     xpcc->SetSecurityManagerFlags(flags);
    1:     return NS_OK;
    1: }
    1: 
    1: /* void getSecurityManagerForJSContext (in JSContextPtr aJSContext, out nsIXPCSecurityManager aManager, out PRUint16 flags); */
    1: NS_IMETHODIMP
    1: nsXPConnect::GetSecurityManagerForJSContext(JSContext * aJSContext,
    1:                                             nsIXPCSecurityManager **aManager,
    1:                                             PRUint16 *flags)
    1: {
    1:     NS_ASSERTION(aJSContext, "bad param");
    1:     NS_ASSERTION(aManager, "bad param");
    1:     NS_ASSERTION(flags, "bad param");
    1: 
    1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     XPCContext* xpcc = ccx.GetXPCContext();
    1: 
    1:     nsIXPCSecurityManager* manager = xpcc->GetSecurityManager();
    1:     NS_IF_ADDREF(manager);
    1:     *aManager = manager;
    1:     *flags = xpcc->GetSecurityManagerFlags();
    1:     return NS_OK;
    1: }
    1: 
    1: /* void setDefaultSecurityManager (in nsIXPCSecurityManager aManager, in PRUint16 flags); */
    1: NS_IMETHODIMP
    1: nsXPConnect::SetDefaultSecurityManager(nsIXPCSecurityManager *aManager,
    1:                                        PRUint16 flags)
    1: {
    1:     NS_IF_ADDREF(aManager);
    1:     NS_IF_RELEASE(mDefaultSecurityManager);
    1:     mDefaultSecurityManager = aManager;
    1:     mDefaultSecurityManagerFlags = flags;
 8870: 
 8870:     nsCOMPtr<nsIScriptSecurityManager> ssm =
 8870:         do_QueryInterface(mDefaultSecurityManager);
 8870: 
 8870:     // Remember the result of the above QI for fast access to the
 8870:     // script securityt manager.
 8870:     gScriptSecurityManager = ssm;
 8870: 
    1:     return NS_OK;
    1: }
    1: 
    1: /* void getDefaultSecurityManager (out nsIXPCSecurityManager aManager, out PRUint16 flags); */
    1: NS_IMETHODIMP
    1: nsXPConnect::GetDefaultSecurityManager(nsIXPCSecurityManager **aManager,
    1:                                        PRUint16 *flags)
    1: {
    1:     NS_ASSERTION(aManager, "bad param");
    1:     NS_ASSERTION(flags, "bad param");
    1: 
    1:     NS_IF_ADDREF(mDefaultSecurityManager);
    1:     *aManager = mDefaultSecurityManager;
    1:     *flags = mDefaultSecurityManagerFlags;
    1:     return NS_OK;
    1: }
    1: 
    1: /* nsIStackFrame createStackFrameLocation (in PRUint32 aLanguage, in string aFilename, in string aFunctionName, in PRInt32 aLineNumber, in nsIStackFrame aCaller); */
    1: NS_IMETHODIMP
    1: nsXPConnect::CreateStackFrameLocation(PRUint32 aLanguage,
    1:                                       const char *aFilename,
    1:                                       const char *aFunctionName,
    1:                                       PRInt32 aLineNumber,
    1:                                       nsIStackFrame *aCaller,
    1:                                       nsIStackFrame **_retval)
    1: {
    1:     NS_ASSERTION(_retval, "bad param");
    1: 
    1:     return XPCJSStack::CreateStackFrameLocation(aLanguage,
    1:                                                 aFilename,
    1:                                                 aFunctionName,
    1:                                                 aLineNumber,
    1:                                                 aCaller,
    1:                                                 _retval);
    1: }
    1: 
    1: /* readonly attribute nsIStackFrame CurrentJSStack; */
    1: NS_IMETHODIMP
    1: nsXPConnect::GetCurrentJSStack(nsIStackFrame * *aCurrentJSStack)
    1: {
    1:     NS_ASSERTION(aCurrentJSStack, "bad param");
    1:     *aCurrentJSStack = nsnull;
    1: 
    1:     JSContext* cx;
    1:     // is there a current context available?
20462:     if(NS_SUCCEEDED(Peek(&cx)) && cx)
    1:     {
    1:         nsCOMPtr<nsIStackFrame> stack;
    1:         XPCJSStack::CreateStack(cx, getter_AddRefs(stack));
    1:         if(stack)
    1:         {
    1:             // peel off native frames...
    1:             PRUint32 language;
    1:             nsCOMPtr<nsIStackFrame> caller;
    1:             while(stack &&
    1:                   NS_SUCCEEDED(stack->GetLanguage(&language)) &&
    1:                   language != nsIProgrammingLanguage::JAVASCRIPT &&
    1:                   NS_SUCCEEDED(stack->GetCaller(getter_AddRefs(caller))) &&
    1:                   caller)
    1:             {
    1:                 stack = caller;
    1:             }
    1:             NS_IF_ADDREF(*aCurrentJSStack = stack);
    1:         }
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: /* readonly attribute nsIXPCNativeCallContext CurrentNativeCallContext; */
    1: NS_IMETHODIMP
10286: nsXPConnect::GetCurrentNativeCallContext(nsAXPCNativeCallContext * *aCurrentNativeCallContext)
    1: {
    1:     NS_ASSERTION(aCurrentNativeCallContext, "bad param");
    1: 
10490:     XPCPerThreadData* data = XPCPerThreadData::GetData(nsnull);
    1:     if(data)
    1:     {
10286:         *aCurrentNativeCallContext = data->GetCallContext();
    1:         return NS_OK;
    1:     }
    1:     //else...
    1:     *aCurrentNativeCallContext = nsnull;
    1:     return UnexpectedFailure(NS_ERROR_FAILURE);
    1: }
    1: 
    1: /* attribute nsIException PendingException; */
    1: NS_IMETHODIMP
    1: nsXPConnect::GetPendingException(nsIException * *aPendingException)
    1: {
    1:     NS_ASSERTION(aPendingException, "bad param");
    1: 
10490:     XPCPerThreadData* data = XPCPerThreadData::GetData(nsnull);
    1:     if(!data)
    1:     {
    1:         *aPendingException = nsnull;
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1:     }
    1: 
    1:     return data->GetException(aPendingException);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXPConnect::SetPendingException(nsIException * aPendingException)
    1: {
10490:     XPCPerThreadData* data = XPCPerThreadData::GetData(nsnull);
    1:     if(!data)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     data->SetException(aPendingException);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXPConnect::SyncJSContexts(void)
    1: {
20312:     // Do-nothing compatibility function
    1:     return NS_OK;
    1: }
    1: 
    1: /* nsIXPCFunctionThisTranslator setFunctionThisTranslator (in nsIIDRef aIID, in nsIXPCFunctionThisTranslator aTranslator); */
    1: NS_IMETHODIMP
    1: nsXPConnect::SetFunctionThisTranslator(const nsIID & aIID,
    1:                                        nsIXPCFunctionThisTranslator *aTranslator,
    1:                                        nsIXPCFunctionThisTranslator **_retval)
    1: {
20312:     XPCJSRuntime* rt = GetRuntime();
    1:     nsIXPCFunctionThisTranslator* old;
    1:     IID2ThisTranslatorMap* map = rt->GetThisTranslatorMap();
    1: 
    1:     {
    1:         XPCAutoLock lock(rt->GetMapLock()); // scoped lock
    1:         if(_retval)
    1:         {
    1:             old = map->Find(aIID);
    1:             NS_IF_ADDREF(old);
    1:             *_retval = old;
    1:         }
    1:         map->Add(aIID, aTranslator);
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: /* nsIXPCFunctionThisTranslator getFunctionThisTranslator (in nsIIDRef aIID); */
    1: NS_IMETHODIMP
    1: nsXPConnect::GetFunctionThisTranslator(const nsIID & aIID,
    1:                                        nsIXPCFunctionThisTranslator **_retval)
    1: {
20312:     XPCJSRuntime* rt = GetRuntime();
    1:     nsIXPCFunctionThisTranslator* old;
    1:     IID2ThisTranslatorMap* map = rt->GetThisTranslatorMap();
    1: 
    1:     {
    1:         XPCAutoLock lock(rt->GetMapLock()); // scoped lock
    1:         old = map->Find(aIID);
    1:         NS_IF_ADDREF(old);
    1:         *_retval = old;
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: /* void setSafeJSContextForCurrentThread (in JSContextPtr cx); */
    1: NS_IMETHODIMP 
    1: nsXPConnect::SetSafeJSContextForCurrentThread(JSContext * cx)
    1: {
    1:     XPCCallContext ccx(NATIVE_CALLER);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1:     return ccx.GetThreadData()->GetJSContextStack()->SetSafeJSContext(cx);
    1: }
    1: 
    1: /* void clearAllWrappedNativeSecurityPolicies (); */
    1: NS_IMETHODIMP
    1: nsXPConnect::ClearAllWrappedNativeSecurityPolicies()
    1: {
    1:     XPCCallContext ccx(NATIVE_CALLER);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     return XPCWrappedNativeScope::ClearAllWrappedNativeSecurityPolicies(ccx);
    1: }
    1: 
    1: /* void restoreWrappedNativePrototype (in JSContextPtr aJSContext, in JSObjectPtr aScope, in nsIClassInfo aClassInfo, in nsIXPConnectJSObjectHolder aPrototype); */
    1: NS_IMETHODIMP 
    1: nsXPConnect::RestoreWrappedNativePrototype(JSContext * aJSContext, 
    1:                                            JSObject * aScope, 
    1:                                            nsIClassInfo * aClassInfo, 
    1:                                            nsIXPConnectJSObjectHolder * aPrototype)
    1: {
    1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     if(!aClassInfo || !aPrototype)
    1:         return UnexpectedFailure(NS_ERROR_INVALID_ARG);
    1: 
    1:     JSObject *protoJSObject;
    1:     nsresult rv = aPrototype->GetJSObject(&protoJSObject);
    1:     if(NS_FAILED(rv))
    1:         return UnexpectedFailure(rv);
    1: 
48622:     if(!IS_PROTO_CLASS(protoJSObject->getClass()))
    1:         return UnexpectedFailure(NS_ERROR_INVALID_ARG);
    1: 
    1:     XPCWrappedNativeScope* scope =
    1:         XPCWrappedNativeScope::FindInJSObjectScope(ccx, aScope);
    1:     if(!scope)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     XPCWrappedNativeProto *proto =
10858:         (XPCWrappedNativeProto*)xpc_GetJSPrivate(protoJSObject);
    1:     if(!proto)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     if(scope != proto->GetScope())
    1:     {
    1:         NS_ERROR("Attempt to reset prototype to a prototype from a"
    1:                  "different scope!");
    1: 
    1:         return UnexpectedFailure(NS_ERROR_INVALID_ARG);
    1:     }
    1: 
    1:     XPCNativeScriptableInfo *si = proto->GetScriptableInfo();
    1: 
    1:     if(si && si->GetFlags().DontSharePrototype())
    1:         return UnexpectedFailure(NS_ERROR_INVALID_ARG);
    1: 
29424:     ClassInfo2WrappedNativeProtoMap* map =
29424:         scope->GetWrappedNativeProtoMap(proto->ClassIsMainThreadOnly());
20312:     XPCLock* lock = GetRuntime()->GetMapLock();
    1: 
    1:     {   // scoped lock
    1:         XPCAutoLock al(lock);
    1: 
    1:         XPCWrappedNativeProtoMap* detachedMap =
    1:             GetRuntime()->GetDetachedWrappedNativeProtoMap();
    1: 
    1:         // If we're replacing an old proto, make sure to put it on the
    1:         // map of detached wrapped native protos so that the old proto
    1:         // gets properly cleaned up, especially during shutdown.
    1:         XPCWrappedNativeProto *oldProto = map->Find(aClassInfo);
    1:         if(oldProto)
    1:         {
    1:             detachedMap->Add(oldProto);
    1: 
    1:             // ClassInfo2WrappedNativeProtoMap doesn't ever replace
    1:             // entries in the map, so now since we know there's an
    1:             // entry for aClassInfo in the map we have to remove it to
    1:             // be able to add the new one.
    1:             map->Remove(aClassInfo);
    1: 
    1:             // This code should do the right thing even if we're
    1:             // restoring the current proto, but warn in that case
    1:             // since doing that is pointless.
    1:             NS_ASSERTION(proto != oldProto,
    1:                          "Restoring current prototype, fix caller!");
    1:         }
    1: 
    1:         map->Add(aClassInfo, proto);
    1: 
    1:         // Remove the prototype from the map of detached wrapped
    1:         // native prototypes now that the prototype is part of a scope
    1:         // again.
    1:         detachedMap->Remove(proto);
    1:     }
    1: 
    1:     // The global in this scope didn't change, but a prototype did
    1:     // (most likely the global object's prototype), which means the
    1:     // scope needs to get a chance to update its cached
    1:     // Object.prototype pointers etc.
    1:     scope->SetGlobal(ccx, aScope);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXPConnect::CreateSandbox(JSContext *cx, nsIPrincipal *principal,
    1:                            nsIXPConnectJSObjectHolder **_retval)
    1: {
    1:     XPCCallContext ccx(NATIVE_CALLER, cx);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     *_retval = nsnull;
    1: 
    1:     jsval rval = JSVAL_VOID;
    1:     AUTO_MARK_JSVAL(ccx, &rval);
    1: 
55675:     nsresult rv = xpc_CreateSandboxObject(cx, &rval, principal, NULL, false);
    1:     NS_ASSERTION(NS_FAILED(rv) || !JSVAL_IS_PRIMITIVE(rval),
    1:                  "Bad return value from xpc_CreateSandboxObject()!");
    1: 
    1:     if (NS_SUCCEEDED(rv) && !JSVAL_IS_PRIMITIVE(rval)) {
 2072:         *_retval = XPCJSObjectHolder::newHolder(ccx, JSVAL_TO_OBJECT(rval));
    1:         NS_ENSURE_TRUE(*_retval, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:         NS_ADDREF(*_retval);
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXPConnect::EvalInSandboxObject(const nsAString& source, JSContext *cx,
    1:                                  nsIXPConnectJSObjectHolder *sandbox,
 3573:                                  PRBool returnStringOnly, jsval *rval)
    1: {
    1:     if (!sandbox)
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     JSObject *obj;
    1:     nsresult rv = sandbox->GetJSObject(&obj);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     return xpc_EvalInSandbox(cx, obj, source,
 3573:                              NS_ConvertUTF16toUTF8(source).get(), 1,
24474:                              JSVERSION_DEFAULT, returnStringOnly, rval);
    1: }
    1: 
33785: /* void GetXPCWrappedNativeJSClassInfo(out JSEqualityOp equality); */
 8990: NS_IMETHODIMP
33785: nsXPConnect::GetXPCWrappedNativeJSClassInfo(JSEqualityOp *equality)
 8990: {
30001:     // Expose the equality pointer used by IS_WRAPPER_CLASS(). If that macro
30001:     // ever changes, this function needs to stay in sync.
30001: 
33785:     *equality = &XPC_WN_Equality;
 8990: 
 8990:     return NS_OK;
 8990: }
 8990: 
    1: /* nsIXPConnectJSObjectHolder getWrappedNativePrototype (in JSContextPtr aJSContext, in JSObjectPtr aScope, in nsIClassInfo aClassInfo); */
    1: NS_IMETHODIMP 
    1: nsXPConnect::GetWrappedNativePrototype(JSContext * aJSContext, 
    1:                                        JSObject * aScope, 
    1:                                        nsIClassInfo *aClassInfo, 
    1:                                        nsIXPConnectJSObjectHolder **_retval)
    1: {
    1:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
    1:     if(!ccx.IsValid())
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
55816:     JSAutoEnterCompartment ac;
55816:     if(!ac.enter(aJSContext, aScope))
55816:         return UnexpectedFailure(NS_ERROR_FAILURE);
55816: 
    1:     XPCWrappedNativeScope* scope =
    1:         XPCWrappedNativeScope::FindInJSObjectScope(ccx, aScope);
    1:     if(!scope)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     XPCNativeScriptableCreateInfo sciProto;
40489:     XPCWrappedNative::GatherProtoScriptableCreateInfo(aClassInfo, sciProto);
    1: 
    1:     AutoMarkingWrappedNativeProtoPtr proto(ccx);
    1:     proto = XPCWrappedNativeProto::GetNewOrUsed(ccx, scope, aClassInfo, 
    1:                                                 &sciProto, JS_FALSE,
    1:                                                 OBJ_IS_NOT_GLOBAL);
    1:     if(!proto)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     nsIXPConnectJSObjectHolder* holder;
    1:     *_retval = holder = XPCJSObjectHolder::newHolder(ccx, 
    1:                                                      proto->GetJSProtoObject());
    1:     if(!holder)
    1:         return UnexpectedFailure(NS_ERROR_FAILURE);
    1: 
    1:     NS_ADDREF(holder);
    1:     return NS_OK;
    1: }
    1: 
    1: /* void releaseJSContext (in JSContextPtr aJSContext, in PRBool noGC); */
    1: NS_IMETHODIMP 
    1: nsXPConnect::ReleaseJSContext(JSContext * aJSContext, PRBool noGC)
    1: {
    1:     NS_ASSERTION(aJSContext, "bad param");
10490:     XPCPerThreadData* tls = XPCPerThreadData::GetData(aJSContext);
    1:     if(tls)
    1:     {
    1:         XPCCallContext* ccx = nsnull;
    1:         for(XPCCallContext* cur = tls->GetCallContext(); 
    1:             cur; 
    1:             cur = cur->GetPrevCallContext())
    1:         {
    1:             if(cur->GetJSContext() == aJSContext)
    1:             {
    1:                 ccx = cur;
    1:                 // Keep looping to find the deepest matching call context.
    1:             }
    1:         }
    1:     
    1:         if(ccx)
    1:         {
    1: #ifdef DEBUG_xpc_hacker
18543:             printf("!xpc - deferring destruction of JSContext @ %p\n", 
18543:                    (void *)aJSContext);
    1: #endif
    1:             ccx->SetDestroyJSContextInDestructor(JS_TRUE);
    1:             JS_ClearNewbornRoots(aJSContext);
    1:             return NS_OK;
    1:         }
    1:         // else continue on and synchronously destroy the JSContext ...
    1: 
    1:         NS_ASSERTION(!tls->GetJSContextStack() || 
    1:                      !tls->GetJSContextStack()->
    1:                         DEBUG_StackHasJSContext(aJSContext),
    1:                      "JSContext still in threadjscontextstack!");
    1:     }
    1:     
    1:     if(noGC)
    1:         JS_DestroyContextNoGC(aJSContext);
    1:     else
    1:         JS_DestroyContext(aJSContext);
    1:     return NS_OK;
    1: }
    1: 
    1: /* void debugDump (in short depth); */
    1: NS_IMETHODIMP
    1: nsXPConnect::DebugDump(PRInt16 depth)
    1: {
    1: #ifdef DEBUG
    1:     depth-- ;
    1:     XPC_LOG_ALWAYS(("nsXPConnect @ %x with mRefCnt = %d", this, mRefCnt.get()));
    1:     XPC_LOG_INDENT();
    1:         XPC_LOG_ALWAYS(("gSelf @ %x", gSelf));
    1:         XPC_LOG_ALWAYS(("gOnceAliveNowDead is %d", (int)gOnceAliveNowDead));
    1:         XPC_LOG_ALWAYS(("mDefaultSecurityManager @ %x", mDefaultSecurityManager));
    1:         XPC_LOG_ALWAYS(("mDefaultSecurityManagerFlags of %x", mDefaultSecurityManagerFlags));
    1:         XPC_LOG_ALWAYS(("mInterfaceInfoManager @ %x", mInterfaceInfoManager.get()));
    1:         if(mRuntime)
    1:         {
    1:             if(depth)
    1:                 mRuntime->DebugDump(depth);
    1:             else
    1:                 XPC_LOG_ALWAYS(("XPCJSRuntime @ %x", mRuntime));
    1:         }
    1:         else
    1:             XPC_LOG_ALWAYS(("mRuntime is null"));
    1:         XPCWrappedNativeScope::DebugDumpAllScopes(depth);
    1:     XPC_LOG_OUTDENT();
    1: #endif
    1:     return NS_OK;
    1: }
    1: 
    1: /* void debugDumpObject (in nsISupports aCOMObj, in short depth); */
    1: NS_IMETHODIMP
    1: nsXPConnect::DebugDumpObject(nsISupports *p, PRInt16 depth)
    1: {
    1: #ifdef DEBUG
    1:     if(!depth)
    1:         return NS_OK;
    1:     if(!p)
    1:     {
    1:         XPC_LOG_ALWAYS(("*** Cound not dump object with NULL address"));
    1:         return NS_OK;
    1:     }
    1: 
    1:     nsIXPConnect* xpc;
    1:     nsIXPCWrappedJSClass* wjsc;
    1:     nsIXPConnectWrappedNative* wn;
    1:     nsIXPConnectWrappedJS* wjs;
    1: 
    1:     if(NS_SUCCEEDED(p->QueryInterface(NS_GET_IID(nsIXPConnect),
    1:                         (void**)&xpc)))
    1:     {
    1:         XPC_LOG_ALWAYS(("Dumping a nsIXPConnect..."));
    1:         xpc->DebugDump(depth);
    1:         NS_RELEASE(xpc);
    1:     }
    1:     else if(NS_SUCCEEDED(p->QueryInterface(NS_GET_IID(nsIXPCWrappedJSClass),
    1:                         (void**)&wjsc)))
    1:     {
    1:         XPC_LOG_ALWAYS(("Dumping a nsIXPCWrappedJSClass..."));
    1:         wjsc->DebugDump(depth);
    1:         NS_RELEASE(wjsc);
    1:     }
    1:     else if(NS_SUCCEEDED(p->QueryInterface(NS_GET_IID(nsIXPConnectWrappedNative),
    1:                         (void**)&wn)))
    1:     {
    1:         XPC_LOG_ALWAYS(("Dumping a nsIXPConnectWrappedNative..."));
    1:         wn->DebugDump(depth);
    1:         NS_RELEASE(wn);
    1:     }
    1:     else if(NS_SUCCEEDED(p->QueryInterface(NS_GET_IID(nsIXPConnectWrappedJS),
    1:                         (void**)&wjs)))
    1:     {
    1:         XPC_LOG_ALWAYS(("Dumping a nsIXPConnectWrappedJS..."));
    1:         wjs->DebugDump(depth);
    1:         NS_RELEASE(wjs);
    1:     }
    1:     else
    1:         XPC_LOG_ALWAYS(("*** Could not dump the nsISupports @ %x", p));
    1: #endif
    1:     return NS_OK;
    1: }
    1: 
 5905: /* void debugDumpJSStack (in PRBool showArgs, in PRBool showLocals, in PRBool showThisProps); */
    1: NS_IMETHODIMP
 5905: nsXPConnect::DebugDumpJSStack(PRBool showArgs,
    1:                               PRBool showLocals,
    1:                               PRBool showThisProps)
    1: {
    1:     JSContext* cx;
20462:     if(NS_FAILED(Peek(&cx)))
 5905:         printf("failed to peek into nsIThreadJSContextStack service!\n");
    1:     else if(!cx)
 5905:         printf("there is no JSContext on the nsIThreadJSContextStack!\n");
    1:     else
 5905:         xpc_DumpJSStack(cx, showArgs, showLocals, showThisProps);
18403: 
    1:     return NS_OK;
    1: }
    1: 
55472: char*
55472: nsXPConnect::DebugPrintJSStack(PRBool showArgs,
55472:                                PRBool showLocals,
55472:                                PRBool showThisProps)
55472: {
55472:     JSContext* cx;
55472:     if(NS_FAILED(Peek(&cx)))
55472:         printf("failed to peek into nsIThreadJSContextStack service!\n");
55472:     else if(!cx)
55472:         printf("there is no JSContext on the nsIThreadJSContextStack!\n");
55472:     else
55472:         return xpc_PrintJSStack(cx, showArgs, showLocals, showThisProps);
55472: 
55472:     return nsnull;
55472: }
55472: 
    1: /* void debugDumpEvalInJSStackFrame (in PRUint32 aFrameNumber, in string aSourceText); */
    1: NS_IMETHODIMP
    1: nsXPConnect::DebugDumpEvalInJSStackFrame(PRUint32 aFrameNumber, const char *aSourceText)
    1: {
    1:     JSContext* cx;
20462:     if(NS_FAILED(Peek(&cx)))
    1:         printf("failed to peek into nsIThreadJSContextStack service!\n");
    1:     else if(!cx)
    1:         printf("there is no JSContext on the nsIThreadJSContextStack!\n");
    1:     else
    1:         xpc_DumpEvalInJSStackFrame(cx, aFrameNumber, aSourceText);
18403: 
    1:     return NS_OK;
    1: }
    1: 
42675: /* jsval variantToJS (in JSContextPtr ctx, in JSObjectPtr scope, in nsIVariant value); */
    1: NS_IMETHODIMP 
    1: nsXPConnect::VariantToJS(JSContext* ctx, JSObject* scope, nsIVariant* value, jsval* _retval)
    1: {
    1:     NS_PRECONDITION(ctx, "bad param");
    1:     NS_PRECONDITION(scope, "bad param");
    1:     NS_PRECONDITION(value, "bad param");
    1:     NS_PRECONDITION(_retval, "bad param");
    1: 
    1:     XPCCallContext ccx(NATIVE_CALLER, ctx);
    1:     if(!ccx.IsValid())
    1:         return NS_ERROR_FAILURE;
31395:     XPCLazyCallContext lccx(ccx);
    1: 
62405:     ccx.SetScopeForNewJSObjects(scope);
62405: 
    1:     nsresult rv = NS_OK;
62405:     if(!XPCVariant::VariantDataToJS(lccx, value, &rv, _retval))
    1:     {
    1:         if(NS_FAILED(rv)) 
    1:             return rv;
    1: 
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
42675: /* nsIVariant JSToVariant (in JSContextPtr ctx, in jsval value); */
    1: NS_IMETHODIMP 
48470: nsXPConnect::JSToVariant(JSContext* ctx, const jsval &value, nsIVariant** _retval)
    1: {
    1:     NS_PRECONDITION(ctx, "bad param");
48470:     NS_PRECONDITION(value != JSVAL_NULL, "bad param");
    1:     NS_PRECONDITION(_retval, "bad param");
    1: 
    1:     XPCCallContext ccx(NATIVE_CALLER, ctx);
    1:     if(!ccx.IsValid())
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     *_retval = XPCVariant::newVariant(ccx, value);
    1:     if(!(*_retval)) 
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     return NS_OK;
    1: }
    1: 
 3310: NS_IMETHODIMP
 3310: nsXPConnect::OnProcessNextEvent(nsIThreadInternal *aThread, PRBool aMayWait,
 3310:                                 PRUint32 aRecursionDepth)
 3310: {
 3310:     // Push a null JSContext so that we don't see any script during
 3310:     // event processing.
20462:     return Push(nsnull);
 3310: }
 3310: 
 3310: NS_IMETHODIMP
 3310: nsXPConnect::AfterProcessNextEvent(nsIThreadInternal *aThread,
 3310:                                    PRUint32 aRecursionDepth)
 3310: {
57074:     // Call cycle collector occasionally.
57074:     if (NS_IsMainThread()) {
62725:         nsJSContext::MaybePokeCC();
57074:     }
57074: 
20462:     return Pop(nsnull);
 3310: }
 3310: 
 3310: NS_IMETHODIMP
 3310: nsXPConnect::OnDispatchedEvent(nsIThreadInternal* aThread)
 3310: {
 3310:     NS_NOTREACHED("Why tell us?");
 3310:     return NS_ERROR_UNEXPECTED;
 3310: }
 3310: 
 7230: NS_IMETHODIMP
 7230: nsXPConnect::AddJSHolder(void* aHolder, nsScriptObjectTracer* aTracer)
 7230: {
 7230:     return mRuntime->AddJSHolder(aHolder, aTracer);
 7230: }
 7230: 
 7230: NS_IMETHODIMP
 7230: nsXPConnect::RemoveJSHolder(void* aHolder)
 7230: {
 7230:     return mRuntime->RemoveJSHolder(aHolder);
 7230: }
 7230: 
14170: NS_IMETHODIMP
14170: nsXPConnect::SetReportAllJSExceptions(PRBool newval)
14170: {
14170:     // Ignore if the environment variable was set.
14170:     if (gReportAllJSExceptions != 1)
14170:         gReportAllJSExceptions = newval ? 2 : 0;
14170: 
14170:     return NS_OK;
14170: }
14170: 
18543: /* [noscript, notxpcom] PRBool defineDOMQuickStubs (in JSContextPtr cx, in JSObjectPtr proto, in PRUint32 flags, in PRUint32 interfaceCount, [array, size_is (interfaceCount)] in nsIIDPtr interfaceArray); */
18543: NS_IMETHODIMP_(PRBool)
18543: nsXPConnect::DefineDOMQuickStubs(JSContext * cx,
18543:                                  JSObject * proto,
18543:                                  PRUint32 flags,
18543:                                  PRUint32 interfaceCount,
18543:                                  const nsIID * *interfaceArray)
18543: {
18543:     return DOM_DefineQuickStubs(cx, proto, flags,
18543:                                 interfaceCount, interfaceArray);
18543: }
18543: 
20312: /* attribute JSRuntime runtime; */
20312: NS_IMETHODIMP
20312: nsXPConnect::GetRuntime(JSRuntime **runtime)
20312: {
20312:     if(!runtime)
20312:         return NS_ERROR_NULL_POINTER;
20312: 
20312:     *runtime = GetRuntime()->GetJSRuntime();
20312:     return NS_OK;
20312: }
20312: 
20312: /* attribute nsIXPCScriptable backstagePass; */
20312: NS_IMETHODIMP
20312: nsXPConnect::GetBackstagePass(nsIXPCScriptable **bsp)
20312: {
20312:     if(!mBackstagePass) {
20312:         nsCOMPtr<nsIPrincipal> sysprin;
20312:         nsCOMPtr<nsIScriptSecurityManager> secman =
20312:             do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID);
20312:         if(!secman)
20312:             return NS_ERROR_NOT_AVAILABLE;
20312:         if(NS_FAILED(secman->GetSystemPrincipal(getter_AddRefs(sysprin))))
20312:             return NS_ERROR_NOT_AVAILABLE;
20312: 
20312:         mBackstagePass = new BackstagePass(sysprin);
20312:         if(!mBackstagePass)
20312:             return NS_ERROR_OUT_OF_MEMORY;
20312:     }
20312:     NS_ADDREF(*bsp = mBackstagePass);
20312:     return NS_OK;
20312: }
20312: 
36094: /* [noscript, notxpcom] void registerGCCallback(in JSGCCallback func); */
36094: NS_IMETHODIMP_(void)
36094: nsXPConnect::RegisterGCCallback(JSGCCallback func)
36094: {
36094:     mRuntime->AddGCCallback(func);
36094: }
36094: 
36094: /* [noscript, notxpcom] void unregisterGCCallback(in JSGCCallback func); */
36094: NS_IMETHODIMP_(void)
36094: nsXPConnect::UnregisterGCCallback(JSGCCallback func)
36094: {
36094:     mRuntime->RemoveGCCallback(func);
36094: }
36094: 
20462: //  nsIJSContextStack and nsIThreadJSContextStack implementations
20462: 
20462: /* readonly attribute PRInt32 Count; */
20462: NS_IMETHODIMP
20462: nsXPConnect::GetCount(PRInt32 *aCount)
20462: {
20462:     if(!aCount)
20462:         return NS_ERROR_NULL_POINTER;
20462: 
20462:     XPCPerThreadData* data = XPCPerThreadData::GetData(nsnull);
20462: 
20462:     if(!data)
20462:     {
20462:         *aCount = 0;
20462:         return NS_ERROR_FAILURE;
20462:     }
20462: 
20462:     return data->GetJSContextStack()->GetCount(aCount);
20462: }
20462: 
20462: /* JSContext Peek (); */
20462: NS_IMETHODIMP
20462: nsXPConnect::Peek(JSContext * *_retval)
20462: {
20462:     if(!_retval)
20462:         return NS_ERROR_NULL_POINTER;
20462: 
20462:     XPCPerThreadData* data = XPCPerThreadData::GetData(nsnull);
20462: 
20462:     if(!data)
20462:     {
20462:         *_retval = nsnull;
20462:         return NS_ERROR_FAILURE;
20462:     }
20462: 
20462:     return data->GetJSContextStack()->Peek(_retval);
20462: }
20462: 
56783: void 
56783: nsXPConnect::CheckForDebugMode(JSRuntime *rt) {
62057:     JSContext *cx = NULL;
62057: 
62057:     if (gDebugMode == gDesiredDebugMode) {
62057:         return;
62057:     }
62057:         
62057:     // This can happen if a Worker is running, but we don't have the ability to
62057:     // debug workers right now, so just return.
56784:     if (!NS_IsMainThread()) {
56784:         return;
56784:     }
56784: 
56853:     JS_SetRuntimeDebugMode(rt, gDesiredDebugMode);
56853: 
56783:     nsresult rv;
56783:     const char jsdServiceCtrID[] = "@mozilla.org/js/jsd/debugger-service;1";
56783:     nsCOMPtr<jsdIDebuggerService> jsds = do_GetService(jsdServiceCtrID, &rv);
62779:     if (NS_FAILED(rv)) {
62057:         goto fail;
62057:     }
62057: 
62057:     if (!(cx = JS_NewContext(rt, 256))) {
62057:         goto fail;
62057:     }
62057: 
62057:     {
62779:         struct AutoDestroyContext {
62779:             JSContext *cx;
62779:             AutoDestroyContext(JSContext *cx) : cx(cx) {}
62779:             ~AutoDestroyContext() { JS_DestroyContext(cx); }
62779:         } adc(cx);
62779:         JSAutoRequest ar(cx);
62779: 
64258:         js::CompartmentVector &vector = rt->compartments;
62057:         for (JSCompartment **p = vector.begin(); p != vector.end(); ++p) {
62057:             JSCompartment *comp = *p;
62057:             if (!comp->principals) {
62057:                 /* Ignore special compartments (atoms, JSD compartments) */
62057:                 continue;
62057:             }
62057: 
62057:             /* ParticipatesInCycleCollection means "on the main thread" */
62057:             if (xpc::CompartmentParticipatesInCycleCollection(cx, comp)) {
62779:                 if (gDesiredDebugMode) {
62779:                     if (!JS_SetDebugModeForCompartment(cx, comp, JS_TRUE))
62057:                         goto fail;
62779:                 } else {
62779:                     /*
62779:                      * Debugging may be turned off with live scripts, so just
62779:                      * mark future scripts to be compiled into non-debug mode.
62779:                      * Existing scripts will continue to call JSD callbacks,
62779:                      * which will have no effect.
62779:                      */
62779:                     comp->debugMode = JS_FALSE;
62057:                 }
62057:             }
62057:         }
62057:     }
62057: 
62057:     if (gDesiredDebugMode) {
56783:         rv = jsds->ActivateDebugger(rt);
56783:     }
62057: 
56783:     gDebugMode = gDesiredDebugMode;
62057:     return;
62057: 
62057: fail:
62057:     if (jsds)
62057:         jsds->DeactivateDebugger();
62057: 
62779:     /*
62779:      * If an attempt to turn debug mode on fails, cancel the request. It's
62779:      * always safe to turn debug mode off, since DeactivateDebugger prevents
62779:      * debugger callbacks from having any effect.
62779:      */
62779:     if (gDesiredDebugMode)
62779:         JS_SetRuntimeDebugMode(rt, JS_FALSE);
62779:     gDesiredDebugMode = gDebugMode = JS_FALSE;
56783: }
56783: 
20462: /* JSContext Pop (); */
20462: NS_IMETHODIMP
20462: nsXPConnect::Pop(JSContext * *_retval)
20462: {
20462:     XPCPerThreadData* data = XPCPerThreadData::GetData(nsnull);
20462: 
20462:     if(!data)
20462:     {
20462:         if(_retval)
20462:             *_retval = nsnull;
20462:         return NS_ERROR_FAILURE;
20462:     }
20462: 
20462:     return data->GetJSContextStack()->Pop(_retval);
20462: }
20462: 
20462: /* void Push (in JSContext cx); */
20462: NS_IMETHODIMP
20462: nsXPConnect::Push(JSContext * cx)
20462: {
20462:     XPCPerThreadData* data = XPCPerThreadData::GetData(cx);
20462: 
20462:     if(!data)
20462:         return NS_ERROR_FAILURE;
20462: 
62069:      if (gDebugMode != gDesiredDebugMode && NS_IsMainThread()) {
62069:          const nsTArray<XPCJSContextInfo>* stack = data->GetJSContextStack()->GetStack();
62779:          if (!gDesiredDebugMode) {
62779:              /* Turn off debug mode immediately, even if JS code is currently running */
62779:              CheckForDebugMode(mRuntime->GetJSRuntime());
62779:          } else {
62069:              bool runningJS = false;
62069:              for (PRUint32 i = 0; i < stack->Length(); ++i) {
62069:                  JSContext *cx = (*stack)[i].cx;
69223:                  if (cx && !cx->stack.empty()) {
62069:                      runningJS = true;
62069:                      break;
62069:                  }
62069:              }
62779:              if (!runningJS)
56783:                  CheckForDebugMode(mRuntime->GetJSRuntime());
62069:          }
62779:      }
56783:  
20462:      return data->GetJSContextStack()->Push(cx);
20462: }
20462: 
20462: /* attribute JSContext SafeJSContext; */
20462: NS_IMETHODIMP
20462: nsXPConnect::GetSafeJSContext(JSContext * *aSafeJSContext)
20462: {
20462:     NS_ASSERTION(aSafeJSContext, "loser!");
20462: 
20462:     XPCPerThreadData* data = XPCPerThreadData::GetData(nsnull);
20462: 
20462:     if(!data)
20462:     {
20462:         *aSafeJSContext = nsnull;
20462:         return NS_ERROR_FAILURE;
20462:     }
20462: 
20462:     return data->GetJSContextStack()->GetSafeJSContext(aSafeJSContext);
20462: }
20462: 
20462: /* attribute JSContext SafeJSContext; */
20462: NS_IMETHODIMP
20462: nsXPConnect::SetSafeJSContext(JSContext * aSafeJSContext)
20462: {
20462:     XPCPerThreadData* data = XPCPerThreadData::GetData(aSafeJSContext);
20462: 
20462:     if(!data)
20462:         return NS_ERROR_FAILURE;
20462: 
20462:     return data->GetJSContextStack()->SetSafeJSContext(aSafeJSContext);
20462: }
20462: 
30001: nsIPrincipal*
30001: nsXPConnect::GetPrincipal(JSObject* obj, PRBool allowShortCircuit) const
30001: {
40410:     NS_ASSERTION(IS_WRAPPER_CLASS(obj->getClass()),
30001:                  "What kind of wrapper is this?");
30001: 
33785:     if(IS_WN_WRAPPER_OBJECT(obj))
30001:     {
30001:         XPCWrappedNative *xpcWrapper =
30001:             (XPCWrappedNative *)xpc_GetJSPrivate(obj);
30001:         if (xpcWrapper) {
30001:             if (allowShortCircuit) {
30001:                 nsIPrincipal *result = xpcWrapper->GetObjectPrincipal();
30001:                 if (result) {
30001:                     return result;
30001:                 }
30001:             }
30001: 
30001:             // If not, check if it points to an nsIScriptObjectPrincipal
30001:             nsCOMPtr<nsIScriptObjectPrincipal> objPrin =
30001:                 do_QueryInterface(xpcWrapper->Native());
30001:             if (objPrin) {
30001:                 nsIPrincipal *result = objPrin->GetPrincipal();
30001:                 if (result) {
30001:                     return result;
30001:                 }
30001:             }
30001:         }
30001:     }
30001:     else
30001:     {
30001:         if (allowShortCircuit) {
30001:             nsIPrincipal *result =
30001:                 GetSlimWrapperProto(obj)->GetScope()->GetPrincipal();
30001:             if (result) {
30001:                 return result;
30001:             }
30001:         }
30001: 
30001:         nsCOMPtr<nsIScriptObjectPrincipal> objPrin =
30001:             do_QueryInterface((nsISupports*)xpc_GetJSPrivate(obj));
30001:         if (objPrin) {
30001:             nsIPrincipal *result = objPrin->GetPrincipal();
30001:             if (result) {
30001:                 return result;
30001:             }
30001:         }
30001:     }
30001: 
30001:     return nsnull;
30001: }
30001: 
51082: NS_IMETHODIMP
51082: nsXPConnect::HoldObject(JSContext *aJSContext, JSObject *aObject,
51082:                         nsIXPConnectJSObjectHolder **aHolder)
51082: {
51082:     XPCCallContext ccx(NATIVE_CALLER, aJSContext);
51082:     XPCJSObjectHolder* objHolder = XPCJSObjectHolder::newHolder(ccx, aObject);
51082:     if(!objHolder)
51082:         return NS_ERROR_OUT_OF_MEMORY;
51082: 
51082:     NS_ADDREF(*aHolder = objHolder);
51082:     return NS_OK;
51082: }
51082: 
53556: NS_IMETHODIMP_(void)
53556: nsXPConnect::GetCaller(JSContext **aJSContext, JSObject **aObj)
53556: {
53556:     XPCCallContext *ccx = XPCPerThreadData::GetData(nsnull)->GetCallContext();
53556:     *aJSContext = ccx->GetJSContext();
53556: 
53556:     // Set to the caller in XPC_WN_Helper_{Call,Construct}
53556:     *aObj = ccx->GetFlattenedJSObject();
53556: }
53556: 
57556: // static
57556: nsresult
59217: nsXPConnect::Base64Encode(const nsACString &aBinaryData, nsACString &aString)
57556: {
57556:   // Check for overflow.
57556:   if(aBinaryData.Length() > (PR_UINT32_MAX / 4) * 3)
57556:       return NS_ERROR_FAILURE;
57556: 
57556:   PRUint32 stringLen = ((aBinaryData.Length() + 2) / 3) * 4;
57556: 
57556:   char *buffer;
57556: 
57556:   // Add one byte for null termination.
57556:   if(aString.SetCapacity(stringLen + 1) &&
57556:      (buffer = aString.BeginWriting()) &&
57556:      PL_Base64Encode(aBinaryData.BeginReading(), aBinaryData.Length(), buffer))
57556:   {
57556:       // PL_Base64Encode doesn't null terminate the buffer for us when we pass
57556:       // the buffer in. Do that manually.
57556:       buffer[stringLen] = '\0';
57556: 
57556:       aString.SetLength(stringLen);
57556:       return NS_OK;
57556:   }
57556: 
57556:   aString.Truncate();
57556:   return NS_ERROR_INVALID_ARG;
57556: }
57556: 
57556: // static
57556: nsresult
59217: nsXPConnect::Base64Encode(const nsAString &aString, nsAString &aBinaryData)
57556: {
57556:     NS_LossyConvertUTF16toASCII string(aString);
57556:     nsCAutoString binaryData;
57556: 
57556:     nsresult rv = Base64Encode(string, binaryData);
57556:     if(NS_SUCCEEDED(rv))
57556:         CopyASCIItoUTF16(binaryData, aBinaryData);
57556:     else
57556:         aBinaryData.Truncate();
57556: 
57556:     return rv;
57556: }
57556: 
57556: // static
59217: JSBool
59217: nsXPConnect::Base64Encode(JSContext *cx, jsval val, jsval *out)
59217: {
59217:     NS_ASSERTION(cx, "Null context!");
59217:     NS_ASSERTION(out, "Null jsval pointer!");
59217: 
59217:     jsval root = val;
59217:     xpc_qsACString encodedString(cx, root, &root, xpc_qsACString::eNull,
59217:                                  xpc_qsACString::eStringify);
59217:     if(!encodedString.IsValid())
59217:         return JS_FALSE;
59217: 
59217:     nsCAutoString result;
59217:     if(NS_FAILED(nsXPConnect::Base64Encode(encodedString, result)))
59217:     {
59217:         JS_ReportError(cx, "Failed to encode base64 data!");
59217:         return JS_FALSE;
59217:     }
59217: 
59217:     JSString *str = JS_NewStringCopyN(cx, result.get(), result.Length());
59217:     if (!str)
59217:         return JS_FALSE;
59217: 
59217:     *out = STRING_TO_JSVAL(str);
59217:     return JS_TRUE;
59217: }
59217: 
59217: // static
57556: nsresult
59217: nsXPConnect::Base64Decode(const nsACString &aString, nsACString &aBinaryData)
57556: {
57556:   // Check for overflow.
57556:   if(aString.Length() > PR_UINT32_MAX / 3)
57556:       return NS_ERROR_FAILURE;
57556: 
57556:   PRUint32 binaryDataLen = ((aString.Length() * 3) / 4);
57556: 
57556:   char *buffer;
57556: 
57556:   // Add one byte for null termination.
57556:   if(aBinaryData.SetCapacity(binaryDataLen + 1) &&
57556:      (buffer = aBinaryData.BeginWriting()) &&
57556:      PL_Base64Decode(aString.BeginReading(), aString.Length(), buffer))
57556:   {
57556:       // PL_Base64Decode doesn't null terminate the buffer for us when we pass
57556:       // the buffer in. Do that manually, taking into account the number of '='
57556:       // characters we were passed.
57556:       if(!aString.IsEmpty() && aString[aString.Length() - 1] == '=')
57556:       {
57556:           if(aString.Length() > 1 && aString[aString.Length() - 2] == '=')
57556:               binaryDataLen -= 2;
57556:           else
57556:               binaryDataLen -= 1;
57556:       }
57556:       buffer[binaryDataLen] = '\0';
57556: 
57556:       aBinaryData.SetLength(binaryDataLen);
57556:       return NS_OK;
57556:   }
57556: 
57556:   aBinaryData.Truncate();
57556:   return NS_ERROR_INVALID_ARG;
57556: }
57556: 
57556: // static
57556: nsresult
59217: nsXPConnect::Base64Decode(const nsAString &aBinaryData, nsAString &aString)
57556: {
57556:     NS_LossyConvertUTF16toASCII binaryData(aBinaryData);
57556:     nsCAutoString string;
57556: 
57556:     nsresult rv = Base64Decode(binaryData, string);
57556:     if(NS_SUCCEEDED(rv))
57556:         CopyASCIItoUTF16(string, aString);
57556:     else
57556:         aString.Truncate();
57556: 
57556:     return rv;
57556: }
57556: 
59217: // static
59217: JSBool
59217: nsXPConnect::Base64Decode(JSContext *cx, jsval val, jsval *out)
59217: {
59217:     NS_ASSERTION(cx, "Null context!");
59217:     NS_ASSERTION(out, "Null jsval pointer!");
59217: 
59217:     jsval root = val;
59217:     xpc_qsACString encodedString(cx, root, &root, xpc_qsACString::eNull,
59217:                                  xpc_qsACString::eNull);
59217:     if(!encodedString.IsValid())
59217:         return JS_FALSE;
59217: 
59217:     nsCAutoString result;
59217:     if(NS_FAILED(nsXPConnect::Base64Decode(encodedString, result)))
59217:     {
59217:         JS_ReportError(cx, "Failed to decode base64 string!");
59217:         return JS_FALSE;
59217:     }
59217: 
59217:     JSString *str = JS_NewStringCopyN(cx, result.get(), result.Length());
59217:     if(!str)
59217:         return JS_FALSE;
59217: 
59217:     *out = STRING_TO_JSVAL(str);
59217:     return JS_TRUE;
59217: }
59217: 
56783: NS_IMETHODIMP
56783: nsXPConnect::SetDebugModeWhenPossible(PRBool mode)
56783: {
56783:     gDesiredDebugMode = mode;
62070:     if (!mode)
62070:         CheckForDebugMode(mRuntime->GetJSRuntime());
56783:     return NS_OK;
56783: }
56783: 
    1: /* These are here to be callable from a debugger */
    1: JS_BEGIN_EXTERN_C
18403: JS_EXPORT_API(void) DumpJSStack()
    1: {
    1:     nsresult rv;
    1:     nsCOMPtr<nsIXPConnect> xpc(do_GetService(nsIXPConnect::GetCID(), &rv));
    1:     if(NS_SUCCEEDED(rv) && xpc)
 5905:         xpc->DebugDumpJSStack(PR_TRUE, PR_TRUE, PR_FALSE);
    1:     else
    1:         printf("failed to get XPConnect service!\n");
    1: }
    1: 
55472: JS_EXPORT_API(char*) PrintJSStack()
55472: {
55472:     nsresult rv;
55472:     nsCOMPtr<nsIXPConnect> xpc(do_GetService(nsIXPConnect::GetCID(), &rv));
55472:     return (NS_SUCCEEDED(rv) && xpc) ? 
55472:         xpc->DebugPrintJSStack(PR_TRUE, PR_TRUE, PR_FALSE) :
55472:         nsnull;
55472: }
55472: 
18403: JS_EXPORT_API(void) DumpJSEval(PRUint32 frameno, const char* text)
    1: {
    1:     nsresult rv;
    1:     nsCOMPtr<nsIXPConnect> xpc(do_GetService(nsIXPConnect::GetCID(), &rv));
    1:     if(NS_SUCCEEDED(rv) && xpc)
    1:         xpc->DebugDumpEvalInJSStackFrame(frameno, text);
    1:     else
    1:         printf("failed to get XPConnect service!\n");
    1: }
    1: 
18403: JS_EXPORT_API(void) DumpJSObject(JSObject* obj)
    1: {
    1:     xpc_DumpJSObject(obj);
    1: }
    1: 
18403: JS_EXPORT_API(void) DumpJSValue(jsval val)
    1: {
48470:     printf("Dumping 0x%llu.\n", (long long) JSVAL_BITS(val));
    1:     if(JSVAL_IS_NULL(val)) {
    1:         printf("Value is null\n");
    1:     }
48470:     else if(JSVAL_IS_OBJECT(val) || JSVAL_IS_NULL(val)) {
    1:         printf("Value is an object\n");
    1:         JSObject* obj = JSVAL_TO_OBJECT(val);
    1:         DumpJSObject(obj);
    1:     }
    1:     else if(JSVAL_IS_NUMBER(val)) {
    1:         printf("Value is a number: ");
    1:         if(JSVAL_IS_INT(val))
    1:           printf("Integer %i\n", JSVAL_TO_INT(val));
    1:         else if(JSVAL_IS_DOUBLE(val))
48470:           printf("Floating-point value %f\n", JSVAL_TO_DOUBLE(val));
    1:     }
    1:     else if(JSVAL_IS_STRING(val)) {
    1:         printf("Value is a string: ");
57721:         putc('<', stdout);
57721:         JS_FileEscapedString(stdout, JSVAL_TO_STRING(val), 0);
57721:         fputs(">\n", stdout);
    1:     }
    1:     else if(JSVAL_IS_BOOLEAN(val)) {
    1:         printf("Value is boolean: ");
    1:         printf(JSVAL_TO_BOOLEAN(val) ? "true" : "false");
    1:     }
    1:     else if(JSVAL_IS_VOID(val)) {
    1:         printf("Value is undefined\n");
    1:     }
    1:     else {
    1:         printf("No idea what this value is.\n");
    1:     }
    1: }
    1: JS_END_EXTERN_C
18403: 
