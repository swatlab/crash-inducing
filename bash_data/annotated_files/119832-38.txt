     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
     1:  *
 99778:  * This Source Code Form is subject to the terms of the Mozilla Public
 99778:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99778:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: #include "nsISupports.h"
     1: #include "nsIPK11TokenDB.h"
     1: #include "prerror.h"
     1: #include "secerr.h"
     1: #include "nsReadableUtils.h"
     1: #include "nsNSSComponent.h"
     1: 
     1: #include "nsPK11TokenDB.h"
     1: 
     1: #ifdef PR_LOGGING
     1: extern PRLogModuleInfo* gPIPNSSLog;
     1: #endif
     1: 
     1: static NS_DEFINE_CID(kNSSComponentCID, NS_NSSCOMPONENT_CID);
     1: 
     1: NS_IMPL_ISUPPORTS1(nsPK11Token, nsIPK11Token)
     1: 
     1: nsPK11Token::nsPK11Token(PK11SlotInfo *slot)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return;
     1: 
     1:   PK11_ReferenceSlot(slot);
     1:   mSlot = slot;
     1:   mSeries = PK11_GetSlotSeries(slot);
     1: 
     1:   refreshTokenInfo();
     1:   mUIContext = new PipUIContext();
     1: }
     1: 
     1: void  
     1: nsPK11Token::refreshTokenInfo()
     1: {
     1:   mTokenName = NS_ConvertUTF8toUTF16(PK11_GetTokenName(mSlot));
     1: 
     1:   SECStatus srv;
     1: 
     1:   CK_TOKEN_INFO tok_info;
     1:   srv = PK11_GetTokenInfo(mSlot, &tok_info);
     1:   if (srv == SECSuccess) {
     1:     // Set the Label field
     1: 
     1:     const char *ccLabel = (const char*)tok_info.label;
     1:     const nsACString &cLabel = Substring(
     1:       ccLabel, 
     1:       ccLabel+PL_strnlen(ccLabel, sizeof(tok_info.label)));
     1:     mTokenLabel = NS_ConvertUTF8toUTF16(cLabel);
 80486:     mTokenLabel.Trim(" ", false, true);
     1: 
     1:     // Set the Manufacturer field
     1:     const char *ccManID = (const char*)tok_info.manufacturerID;
     1:     const nsACString &cManID = Substring(
     1:       ccManID, 
     1:       ccManID+PL_strnlen(ccManID, sizeof(tok_info.manufacturerID)));
     1:     mTokenManID = NS_ConvertUTF8toUTF16(cManID);
 80486:     mTokenManID.Trim(" ", false, true);
     1: 
     1:     // Set the Hardware Version field
     1:     mTokenHWVersion.AppendInt(tok_info.hardwareVersion.major);
     1:     mTokenHWVersion.AppendLiteral(".");
     1:     mTokenHWVersion.AppendInt(tok_info.hardwareVersion.minor);
     1:     // Set the Firmware Version field
     1:     mTokenFWVersion.AppendInt(tok_info.firmwareVersion.major);
     1:     mTokenFWVersion.AppendLiteral(".");
     1:     mTokenFWVersion.AppendInt(tok_info.firmwareVersion.minor);
     1:     // Set the Serial Number field
     1:     const char *ccSerial = (const char*)tok_info.serialNumber;
     1:     const nsACString &cSerial = Substring(
     1:       ccSerial, 
     1:       ccSerial+PL_strnlen(ccSerial, sizeof(tok_info.serialNumber)));
     1:     mTokenSerialNum = NS_ConvertUTF8toUTF16(cSerial);
 80486:     mTokenSerialNum.Trim(" ", false, true);
     1:   }
     1: 
     1: }
     1: 
     1: nsPK11Token::~nsPK11Token()
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return;
     1: 
     1:   destructorSafeDestroyNSSReference();
     1:   shutdown(calledFromObject);
     1: }
     1: 
     1: void nsPK11Token::virtualDestroyNSSReference()
     1: {
     1:   destructorSafeDestroyNSSReference();
     1: }
     1: 
     1: void nsPK11Token::destructorSafeDestroyNSSReference()
     1: {
     1:   if (isAlreadyShutDown())
     1:     return;
     1: 
     1:   if (mSlot) {
     1:     PK11_FreeSlot(mSlot);
106838:     mSlot = nullptr;
     1:   }
     1: }
     1: 
     1: /* readonly attribute wstring tokenName; */
     1: NS_IMETHODIMP nsPK11Token::GetTokenName(PRUnichar * *aTokenName)
     1: {
     1:   // handle removals/insertions
     1:   if (mSeries != PK11_GetSlotSeries(mSlot)) {
     1:     refreshTokenInfo();
     1:   }
     1:   *aTokenName = ToNewUnicode(mTokenName);
     1:   if (!*aTokenName) return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute wstring tokenDesc; */
     1: NS_IMETHODIMP nsPK11Token::GetTokenLabel(PRUnichar **aTokLabel)
     1: {
     1:   // handle removals/insertions
     1:   if (mSeries != PK11_GetSlotSeries(mSlot)) {
     1:     refreshTokenInfo();
     1:   }
     1:   *aTokLabel = ToNewUnicode(mTokenLabel);
     1:   if (!*aTokLabel) return NS_ERROR_OUT_OF_MEMORY;
     1:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute wstring tokenManID; */
     1: NS_IMETHODIMP nsPK11Token::GetTokenManID(PRUnichar **aTokManID)
     1: {
     1:   // handle removals/insertions
     1:   if (mSeries != PK11_GetSlotSeries(mSlot)) {
     1:     refreshTokenInfo();
     1:   }
     1:   *aTokManID = ToNewUnicode(mTokenManID);
     1:   if (!*aTokManID) return NS_ERROR_OUT_OF_MEMORY;
     1:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute wstring tokenHWVersion; */
     1: NS_IMETHODIMP nsPK11Token::GetTokenHWVersion(PRUnichar **aTokHWVersion)
     1: {
     1:   // handle removals/insertions
     1:   if (mSeries != PK11_GetSlotSeries(mSlot)) {
     1:     refreshTokenInfo();
     1:   }
     1:   *aTokHWVersion = ToNewUnicode(mTokenHWVersion);
     1:   if (!*aTokHWVersion) return NS_ERROR_OUT_OF_MEMORY;
     1:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute wstring tokenFWVersion; */
     1: NS_IMETHODIMP nsPK11Token::GetTokenFWVersion(PRUnichar **aTokFWVersion)
     1: {
     1:   // handle removals/insertions
     1:   if (mSeries != PK11_GetSlotSeries(mSlot)) {
     1:     refreshTokenInfo();
     1:   }
     1:   *aTokFWVersion = ToNewUnicode(mTokenFWVersion);
     1:   if (!*aTokFWVersion) return NS_ERROR_OUT_OF_MEMORY;
     1:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute wstring tokenSerialNumber; */
     1: NS_IMETHODIMP nsPK11Token::GetTokenSerialNumber(PRUnichar **aTokSerialNum)
     1: {
     1:   // handle removals/insertions
     1:   if (mSeries != PK11_GetSlotSeries(mSlot)) {
     1:     refreshTokenInfo();
     1:   }
     1:   *aTokSerialNum = ToNewUnicode(mTokenSerialNum);
     1:   if (!*aTokSerialNum) return NS_ERROR_OUT_OF_MEMORY;
     1:   return NS_OK;
     1: }
     1: 
     1: /* boolean isLoggedIn (); */
 79445: NS_IMETHODIMP nsPK11Token::IsLoggedIn(bool *_retval)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   nsresult rv = NS_OK;
     1: 
     1:   *_retval = PK11_IsLoggedIn(mSlot, 0);
     1: 
     1:   return rv;
     1: }
     1: 
     1: /* void logout (in boolean force); */
     1: NS_IMETHODIMP 
 79445: nsPK11Token::Login(bool force)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   nsresult rv;
     1:   SECStatus srv;
 79445:   bool test;
     1:   rv = this->NeedsLogin(&test);
     1:   if (NS_FAILED(rv)) return rv;
     1:   if (test && force) {
     1:     rv = this->LogoutSimple();
     1:     if (NS_FAILED(rv)) return rv;
     1:   }
     1:   rv = setPassword(mSlot, mUIContext);
     1:   if (NS_FAILED(rv)) return rv;
 80486:   srv = PK11_Authenticate(mSlot, true, mUIContext);
     1:   return (srv == SECSuccess) ? NS_OK : NS_ERROR_FAILURE;
     1: }
     1: 
     1: NS_IMETHODIMP nsPK11Token::LogoutSimple()
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   // PK11_MapError sets CKR_USER_NOT_LOGGED_IN to SEC_ERROR_LIBRARY_FAILURE,
     1:   // so not going to learn anything here by a failure.  Treat it like void.
     1:   PK11_Logout(mSlot);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP nsPK11Token::LogoutAndDropAuthenticatedResources()
     1: {
     1:   nsresult rv = LogoutSimple();
     1: 
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   return nssComponent->LogoutAuthenticatedPK11();
     1: }
     1: 
     1: /* void reset (); */
     1: NS_IMETHODIMP nsPK11Token::Reset()
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   PK11_ResetToken(mSlot, 0);
     1:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute long minimumPasswordLength; */
108991: NS_IMETHODIMP nsPK11Token::GetMinimumPasswordLength(int32_t *aMinimumPasswordLength)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   *aMinimumPasswordLength = PK11_GetMinimumPwdLength(mSlot);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute boolean needsUserInit; */
 79445: NS_IMETHODIMP nsPK11Token::GetNeedsUserInit(bool *aNeedsUserInit)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   *aNeedsUserInit = PK11_NeedUserInit(mSlot);
     1:   return NS_OK;
     1: }
     1: 
     1: /* boolean checkPassword (in wstring password); */
 79445: NS_IMETHODIMP nsPK11Token::CheckPassword(const PRUnichar *password, bool *_retval)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   SECStatus srv;
108991:   int32_t prerr;
     1:   NS_ConvertUTF16toUTF8 aUtf8Password(password);
     1:   srv = PK11_CheckUserPassword(mSlot, 
  3233:                   const_cast<char *>(aUtf8Password.get()));
     1:   if (srv != SECSuccess) {
 80486:     *_retval =  false;
     1:     prerr = PR_GetError();
     1:     if (prerr != SEC_ERROR_BAD_PASSWORD) {
     1:       /* something really bad happened - throw an exception */
     1:       return NS_ERROR_FAILURE;
     1:     }
     1:   } else {
 80486:     *_retval =  true;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: /* void initPassword (in wstring initialPassword); */
     1: NS_IMETHODIMP nsPK11Token::InitPassword(const PRUnichar *initialPassword)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:     nsresult rv = NS_OK;
     1:     SECStatus status;
     1: 
     1:     NS_ConvertUTF16toUTF8 aUtf8InitialPassword(initialPassword);
  3233:     status = PK11_InitPin(mSlot, "", const_cast<char*>(aUtf8InitialPassword.get()));
     1:     if (status == SECFailure) { rv = NS_ERROR_FAILURE; goto done; }
     1: 
     1: done:
     1:     return rv;
     1: }
     1: 
     1: /* long getAskPasswordTimes(); */
     1: NS_IMETHODIMP 
108991: nsPK11Token::GetAskPasswordTimes(int32_t *rvAskTimes)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:     int askTimes, askTimeout;
     1:     PK11_GetSlotPWValues(mSlot, &askTimes, &askTimeout);
     1:     *rvAskTimes = askTimes;
     1:     return NS_OK;
     1: }
     1: 
     1: /* long getAskPasswordTimeout(); */
     1: NS_IMETHODIMP 
108991: nsPK11Token::GetAskPasswordTimeout(int32_t *rvAskTimeout)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:     int askTimes, askTimeout;
     1:     PK11_GetSlotPWValues(mSlot, &askTimes, &askTimeout);
     1:     *rvAskTimeout = askTimeout;
     1:     return NS_OK;
     1: }
     1: 
     1: /* void setAskPasswordDefaults(in unsigned long askTimes,
     1:  *                             in unsigned long timeout);
     1:  */
     1: NS_IMETHODIMP 
108991: nsPK11Token::SetAskPasswordDefaults(const int32_t askTimes,
108991:                                     const int32_t askTimeout)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:     PK11_SetSlotPWValues(mSlot, askTimes, askTimeout);
     1:     return NS_OK;
     1: }
     1: 
     1: /* void changePassword (in wstring oldPassword, in wstring newPassword); */
     1: NS_IMETHODIMP nsPK11Token::ChangePassword(const PRUnichar *oldPassword, const PRUnichar *newPassword)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   SECStatus rv;
     1:   NS_ConvertUTF16toUTF8 aUtf8OldPassword(oldPassword);
     1:   NS_ConvertUTF16toUTF8 aUtf8NewPassword(newPassword);
 33219: 
     1:   rv = PK11_ChangePW(mSlot, 
119832:          (oldPassword != NULL ? const_cast<char *>(aUtf8OldPassword.get()) : NULL), 
119832:          (newPassword != NULL ? const_cast<char *>(aUtf8NewPassword.get()) : NULL));
     1:   return (rv == SECSuccess) ? NS_OK : NS_ERROR_FAILURE;
     1: }
     1: 
     1: /* boolean isHardwareToken (); */
 79445: NS_IMETHODIMP nsPK11Token::IsHardwareToken(bool *_retval)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   nsresult rv = NS_OK;
     1: 
     1:   *_retval = PK11_IsHW(mSlot);
     1: 
     1:   return rv;
     1: }
     1: 
     1: /* boolean needsLogin (); */
 79445: NS_IMETHODIMP nsPK11Token::NeedsLogin(bool *_retval)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   nsresult rv = NS_OK;
     1: 
     1:   *_retval = PK11_NeedLogin(mSlot);
     1: 
     1:   return rv;
     1: }
     1: 
     1: /* boolean isFriendly (); */
 79445: NS_IMETHODIMP nsPK11Token::IsFriendly(bool *_retval)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   nsresult rv = NS_OK;
     1: 
     1:   *_retval = PK11_IsFriendly(mSlot);
     1: 
     1:   return rv;
     1: }
     1: 
     1: /*=========================================================*/
     1: 
     1: NS_IMPL_ISUPPORTS1(nsPK11TokenDB, nsIPK11TokenDB)
     1: 
     1: nsPK11TokenDB::nsPK11TokenDB()
     1: {
     1:   /* member initializers and constructor code */
     1: }
     1: 
     1: nsPK11TokenDB::~nsPK11TokenDB()
     1: {
     1:   /* destructor code */
     1: }
     1: 
     1: /* nsIPK11Token getInternalKeyToken (); */
     1: NS_IMETHODIMP nsPK11TokenDB::GetInternalKeyToken(nsIPK11Token **_retval)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   nsresult rv = NS_OK;
     1:   PK11SlotInfo *slot = 0;
     1:   nsCOMPtr<nsIPK11Token> token;
     1: 
     1:   slot = PK11_GetInternalKeySlot();
     1:   if (!slot) { rv = NS_ERROR_FAILURE; goto done; }
     1: 
     1:   token = new nsPK11Token(slot);
119832:   if (!token) { rv = NS_ERROR_OUT_OF_MEMORY; goto done; }
119832: 
     1:   *_retval = token;
     1:   NS_ADDREF(*_retval);
     1: 
     1: done:
     1:   if (slot) PK11_FreeSlot(slot);
     1:   return rv;
     1: }
     1: 
     1: /* nsIPK11Token findTokenByName (in wchar tokenName); */
     1: NS_IMETHODIMP nsPK11TokenDB::
     1: FindTokenByName(const PRUnichar* tokenName, nsIPK11Token **_retval)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   nsresult rv = NS_OK;
     1:   PK11SlotInfo *slot = 0;
     1:   NS_ConvertUTF16toUTF8 aUtf8TokenName(tokenName);
  3233:   slot = PK11_FindSlotByName(const_cast<char*>(aUtf8TokenName.get()));
     1:   if (!slot) { rv = NS_ERROR_FAILURE; goto done; }
     1: 
     1:   *_retval = new nsPK11Token(slot);
119832:   if (!*_retval) { rv = NS_ERROR_OUT_OF_MEMORY; goto done; }
119832: 
     1:   NS_ADDREF(*_retval);
     1: 
     1: done:
     1:   if (slot) PK11_FreeSlot(slot);
     1:   return rv;
     1: }
     1: 
     1: /* nsIEnumerator listTokens (); */
     1: NS_IMETHODIMP nsPK11TokenDB::ListTokens(nsIEnumerator* *_retval)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   nsCOMPtr<nsISupportsArray> array;
     1:   PK11SlotList *list = 0;
     1:   PK11SlotListElement *le;
     1: 
106838:   *_retval = nullptr;
 39329:   nsresult rv = NS_NewISupportsArray(getter_AddRefs(array));
     1:   if (NS_FAILED(rv)) { goto done; }
     1: 
     1:   /* List all tokens, creating PK11Token objects and putting them
     1:    * into the array.
     1:    */
 80486:   list = PK11_GetAllTokens(CKM_INVALID_MECHANISM, false, false, 0);
     1:   if (!list) { rv = NS_ERROR_FAILURE; goto done; }
     1: 
 80486:   for (le = PK11_GetFirstSafe(list); le; le = PK11_GetNextSafe(list, le, false)) {
     1:     nsCOMPtr<nsIPK11Token> token = new nsPK11Token(le->slot);
119832:     rv = token
119832:       ? array->AppendElement(token)
119832:       : NS_ERROR_OUT_OF_MEMORY;
119832: 
 39329:     if (NS_FAILED(rv)) {
 39329:       PK11_FreeSlotListElement(list, le);
 39329:       rv = NS_ERROR_OUT_OF_MEMORY;
 39329:       goto done;
 39329:     }
     1:   }
     1: 
     1:   rv = array->Enumerate(_retval);
     1: 
     1: done:
     1:   if (list) PK11_FreeSlotList(list);
     1:   return rv;
     1: }
     1: 
