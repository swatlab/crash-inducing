    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   John Gaunt (jgaunt@netscape.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
80467: #include "mozilla/Util.h"
80467: 
    1: // NOTE: alphabetically ordered
    1: #include "nsAccessibilityService.h"
89309: #include "nsAccessiblePivot.h"
20521: #include "nsCoreUtils.h"
20536: #include "nsAccUtils.h"
31732: #include "nsApplicationAccessibleWrap.h"
29269: #include "nsARIAGridAccessibleWrap.h"
 7830: #include "nsARIAMap.h"
79384: #include "FocusManager.h"
79384: 
12240: #include "nsIContentViewer.h"
    1: #include "nsCURILoader.h"
    1: #include "nsDocAccessible.h"
82770: #include "nsHTMLCanvasAccessible.h"
40461: #include "nsHTMLImageMapAccessible.h"
    1: #include "nsHTMLLinkAccessible.h"
    1: #include "nsHTMLSelectAccessible.h"
 1133: #include "nsHTMLTableAccessibleWrap.h"
    1: #include "nsHTMLTextAccessible.h"
  966: #include "nsHyperTextAccessibleWrap.h"
    1: #include "nsIAccessibilityService.h"
    1: #include "nsIAccessibleProvider.h"
87094: #include "Role.h"
67790: #include "States.h"
76374: #include "Statistics.h"
40461: 
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMHTMLAreaElement.h"
    1: #include "nsIDOMHTMLLegendElement.h"
    1: #include "nsIDOMHTMLObjectElement.h"
    1: #include "nsIDOMHTMLOptGroupElement.h"
    1: #include "nsIDOMHTMLOptionElement.h"
    1: #include "nsIDOMXULElement.h"
40461: #include "nsIHTMLDocument.h"
69187: #include "nsImageFrame.h"
    1: #include "nsILink.h"
    1: #include "nsIObserverService.h"
79788: #include "nsLayoutUtils.h"
70007: #include "nsNPAPIPluginInstance.h"
    1: #include "nsISupportsUtils.h"
    1: #include "nsObjectFrame.h"
    1: #include "nsOuterDocAccessible.h"
    1: #include "nsRootAccessibleWrap.h"
    1: #include "nsTextFragment.h"
41540: #include "mozilla/Services.h"
68780: #include "nsEventStates.h"
    1: 
    1: #ifdef MOZ_XUL
    1: #include "nsXULAlertAccessible.h"
    1: #include "nsXULColorPickerAccessible.h"
32381: #include "nsXULComboboxAccessible.h"
    1: #include "nsXULFormControlAccessible.h"
32381: #include "nsXULListboxAccessibleWrap.h"
    1: #include "nsXULMenuAccessibleWrap.h"
 4274: #include "nsXULSliderAccessible.h"
    1: #include "nsXULTabAccessible.h"
    1: #include "nsXULTextAccessible.h"
32381: #include "nsXULTreeGridAccessibleWrap.h"
    1: #endif
    1: 
    1: // For native window support for object/embed/applet tags
    1: #ifdef XP_WIN
    1: #include "nsHTMLWin32ObjectAccessible.h"
    1: #endif
    1: 
69027: // For embedding plugin accessibles
69027: #ifdef MOZ_ACCESSIBILITY_ATK
69027: #include "AtkSocketAccessible.h"
69027: #endif
69027: 
    1: #include "nsXFormsFormControlsAccessible.h"
    1: #include "nsXFormsWidgetsAccessible.h"
    1: 
42480: #include "mozilla/FunctionTimer.h"
64096: #include "mozilla/dom/Element.h"
42480: 
80467: using namespace mozilla;
74618: using namespace mozilla::a11y;
74618: 
38359: ////////////////////////////////////////////////////////////////////////////////
38359: // nsAccessibilityService
38359: ////////////////////////////////////////////////////////////////////////////////
38359: 
    1: nsAccessibilityService *nsAccessibilityService::gAccessibilityService = nsnull;
79445: bool nsAccessibilityService::gIsShutdown = true;
    1: 
79384: nsAccessibilityService::nsAccessibilityService() :
79384:   nsAccDocManager(), FocusManager()
    1: {
42480:   NS_TIME_FUNCTION;
    1: }
    1: 
    1: nsAccessibilityService::~nsAccessibilityService()
    1: {
30820:   NS_ASSERTION(gIsShutdown, "Accessibility wasn't shutdown!");
30820:   gAccessibilityService = nsnull;
    1: }
    1: 
43310: ////////////////////////////////////////////////////////////////////////////////
43310: // nsISupports
    1: 
43310: NS_IMPL_ISUPPORTS_INHERITED3(nsAccessibilityService,
43310:                              nsAccDocManager,
43310:                              nsIAccessibilityService,
43310:                              nsIAccessibleRetrieval,
43310:                              nsIObserver)
38359: 
38359: ////////////////////////////////////////////////////////////////////////////////
    1: // nsIObserver
    1: 
    1: NS_IMETHODIMP
    1: nsAccessibilityService::Observe(nsISupports *aSubject, const char *aTopic,
    1:                          const PRUnichar *aData)
    1: {
43310:   if (!nsCRT::strcmp(aTopic, NS_XPCOM_SHUTDOWN_OBSERVER_ID))
43310:     Shutdown();
30820: 
    1:   return NS_OK;
    1: }
    1: 
38359: // nsIAccessibilityService
41476: void
61201: nsAccessibilityService::NotifyOfAnchorJumpTo(nsIContent* aTargetNode)
34455: {
61201:   nsIDocument* documentNode = aTargetNode->GetCurrentDoc();
61201:   if (documentNode) {
61201:     nsDocAccessible* document = GetDocAccessible(documentNode);
61201:     if (document)
80036:       document->SetAnchorJump(aTargetNode);
61201:   }
34455: }
34455: 
38359: // nsIAccessibilityService
54519: void
21255: nsAccessibilityService::FireAccessibleEvent(PRUint32 aEvent,
54519:                                             nsAccessible* aTarget)
21255: {
54519:   nsEventShell::FireEvent(aEvent, aTarget);
21255: }
21255: 
38359: ////////////////////////////////////////////////////////////////////////////////
38359: // nsIAccessibilityService
    1: 
54519: nsAccessible*
54519: nsAccessibilityService::GetRootDocumentAccessible(nsIPresShell* aPresShell,
79445:                                                   bool aCanCreate)
54519: {
54519:   nsIDocument* documentNode = aPresShell->GetDocument();
54519:   if (documentNode) {
54519:     nsCOMPtr<nsISupports> container = documentNode->GetContainer();
54519:     nsCOMPtr<nsIDocShellTreeItem> treeItem(do_QueryInterface(container));
54519:     if (treeItem) {
54519:       nsCOMPtr<nsIDocShellTreeItem> rootTreeItem;
54519:       treeItem->GetRootTreeItem(getter_AddRefs(rootTreeItem));
54519:       if (treeItem != rootTreeItem) {
54519:         nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(rootTreeItem));
54519:         nsCOMPtr<nsIPresShell> presShell;
54519:         docShell->GetPresShell(getter_AddRefs(presShell));
54519:         documentNode = presShell->GetDocument();
54519:       }
54519: 
54519:       return aCanCreate ?
54519:         GetDocAccessible(documentNode) : GetDocAccessibleFromCache(documentNode);
54519:     }
54519:   }
54519:   return nsnull;
54519: }
54519:  
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateOuterDocAccessible(nsIContent* aContent,
46338:                                                  nsIPresShell* aPresShell)
    1: {
89799:   nsAccessible* accessible = 
89799:     new nsOuterDocAccessible(aContent, 
89799:                              nsAccUtils::GetDocAccessibleFor(aPresShell));
89799:   NS_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLButtonAccessible(nsIContent* aContent,
46338:                                                    nsIPresShell* aPresShell)
    1: {
89799:   nsAccessible* accessible = 
89799:     new nsHTMLButtonAccessible(aContent, 
89799:                                nsAccUtils::GetDocAccessibleFor(aPresShell));
89799:   NS_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
38359: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLLIAccessible(nsIContent* aContent,
55763:                                                nsIPresShell* aPresShell)
    1: {
89799:   nsAccessible* accessible = 
89799:     new nsHTMLLIAccessible(aContent, 
89799:                            nsAccUtils::GetDocAccessibleFor(aPresShell));
89799:   NS_ADDREF(accessible);
46338:   return accessible;
28316: }
28316: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHyperTextAccessible(nsIContent* aContent,
46338:                                                   nsIPresShell* aPresShell)
46338: {
89799:   nsAccessible* accessible = 
89799:     new nsHyperTextAccessibleWrap(aContent, 
89799:                                   nsAccUtils::GetDocAccessibleFor(aPresShell));
89799:   NS_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLCheckboxAccessible(nsIContent* aContent,
46338:                                                      nsIPresShell* aPresShell)
    1: {
89799:   nsAccessible* accessible = 
89799:     new nsHTMLCheckboxAccessible(aContent, 
89799:                                  nsAccUtils::GetDocAccessibleFor(aPresShell));
89799:   NS_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLComboboxAccessible(nsIContent* aContent,
46338:                                                      nsIPresShell* aPresShell)
    1: {
89799:   nsAccessible* accessible = 
89799:     new nsHTMLComboboxAccessible(aContent, 
89799:                                  nsAccUtils::GetDocAccessibleFor(aPresShell));
89799:   NS_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
82770: nsAccessibilityService::CreateHTMLCanvasAccessible(nsIContent* aContent,
82770:                                                    nsIPresShell* aPresShell)
82770: {
89799:   nsAccessible* accessible = 
89799:     new nsHTMLCanvasAccessible(aContent, 
89799:                                nsAccUtils::GetDocAccessibleFor(aPresShell));
89799:   NS_ADDREF(accessible);
82770:   return accessible;
82770: }
82770: 
82770: already_AddRefed<nsAccessible>
83000: nsAccessibilityService::CreateHTMLFileInputAccessible(nsIContent* aContent,
83000:                                                       nsIPresShell* aPresShell)
83000: {
89799:   nsAccessible* accessible = 
89799:     new nsHTMLFileInputAccessible(aContent, 
89799:                                   nsAccUtils::GetDocAccessibleFor(aPresShell));
89799:   NS_ADDREF(accessible);
83000:   return accessible;
83000: }
83000: 
83000: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLImageAccessible(nsIContent* aContent,
46338:                                                   nsIPresShell* aPresShell)
    1: {
93267:   nsAccessible* accessible =
93267:     new nsHTMLImageAccessibleWrap(aContent,
93267:                                   nsAccUtils::GetDocAccessibleFor(aPresShell));
93267:   NS_ADDREF(accessible);
93267:   return accessible;
71031: }
    1: 
93267: already_AddRefed<nsAccessible>
93267: nsAccessibilityService::CreateHTMLImageMapAccessible(nsIContent* aContent,
93267:                                                      nsIPresShell* aPresShell)
93267: {
93267:   nsAccessible* accessible =
89799:     new nsHTMLImageMapAccessible(aContent,
89799:                                  nsAccUtils::GetDocAccessibleFor(aPresShell));
89799:   NS_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLGroupboxAccessible(nsIContent* aContent,
46338:                                                      nsIPresShell* aPresShell)
    1: {
89799:   nsAccessible* accessible = 
89799:     new nsHTMLGroupboxAccessible(aContent, 
89799:                                  nsAccUtils::GetDocAccessibleFor(aPresShell));
89799:   NS_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLListboxAccessible(nsIContent* aContent,
46338:                                                     nsIPresShell* aPresShell)
    1: {
89799:   nsAccessible* accessible = 
89799:     new nsHTMLSelectListAccessible(aContent, 
89799:                                    nsAccUtils::GetDocAccessibleFor(aPresShell));
89799:   NS_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLMediaAccessible(nsIContent* aContent,
46338:                                                   nsIPresShell* aPresShell)
    1: {
89799:   nsAccessible* accessible = 
89799:     new nsEnumRoleAccessible(aContent, 
89799:                              nsAccUtils::GetDocAccessibleFor(aPresShell),
87094:                              roles::GROUPING);
89799:   NS_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLObjectFrameAccessible(nsObjectFrame* aFrame,
46338:                                                         nsIContent* aContent,
46338:                                                         nsIPresShell* aPresShell)
27515: {
46338:   // We can have several cases here:
46338:   // 1) a text or html embedded document where the contentDocument variable in
46338:   //    the object element holds the content;
46338:   // 2) web content that uses a plugin, which means we will have to go to
46338:   //    the plugin to get the accessible content;
46338:   // 3) an image or imagemap, where the image frame points back to the object
46338:   //    element DOMNode.
27515: 
46338:   if (aFrame->GetRect().IsEmpty())
46338:     return nsnull;
27515: 
27515: 
    1:   // 1) for object elements containing either HTML or TXT documents
46338:   nsCOMPtr<nsIDOMHTMLObjectElement> obj(do_QueryInterface(aContent));
43504:   if (obj) {
    1:     nsCOMPtr<nsIDOMDocument> domDoc;
    1:     obj->GetContentDocument(getter_AddRefs(domDoc));
46338:     if (domDoc)
46338:       return CreateOuterDocAccessible(aContent, aPresShell);
43504:   }
    1: 
69027: #if defined(XP_WIN) || defined(MOZ_ACCESSIBILITY_ATK)
    1:   // 2) for plugins
70007:   nsRefPtr<nsNPAPIPluginInstance> pluginInstance;
70007:   if (NS_SUCCEEDED(aFrame->GetPluginInstance(getter_AddRefs(pluginInstance))) &&
69027:       pluginInstance) {
69027: #ifdef XP_WIN
33872:     // Note: pluginPort will be null if windowless.
    1:     HWND pluginPort = nsnull;
    1:     aFrame->GetPluginPort(&pluginPort);
33872: 
89799:     nsAccessible* accessible = 
89799:       new nsHTMLWin32ObjectOwnerAccessible(aContent,
89799:                                            nsAccUtils::GetDocAccessibleFor(aPresShell),
46338:                                            pluginPort);
89799:     NS_ADDREF(accessible);
46338:     return accessible;
69027: 
69027: #elif MOZ_ACCESSIBILITY_ATK
69027:     if (!AtkSocketAccessible::gCanEmbed)
69027:       return nsnull;
69027: 
69027:     nsCString plugId;
69027:     nsresult rv = pluginInstance->GetValueFromPlugin(
69027:       NPPVpluginNativeAccessibleAtkPlugId, &plugId);
88338:     if (NS_SUCCEEDED(rv) && !plugId.IsEmpty()) {
69027:       AtkSocketAccessible* socketAccessible =
89799:         new AtkSocketAccessible(aContent, 
89799:                                 nsAccUtils::GetDocAccessibleFor(aPresShell), 
89799:                                 plugId);
69027: 
89799:       NS_ADDREF(socketAccessible);
69027:       return socketAccessible;
69027:     }
69027: #endif
    1:   }
    1: #endif
    1: 
    1:   // 3) for images and imagemaps, or anything else with a child frame
    1:   // we have the object frame, get the image frame
77154:   nsIFrame* frame = aFrame->GetFirstPrincipalChild();
46338:   return frame ? frame->CreateAccessible() : nsnull;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLRadioButtonAccessible(nsIContent* aContent,
46338:                                                         nsIPresShell* aPresShell)
    1: {
89799:   nsAccessible* accessible = 
89799:     new nsHTMLRadioButtonAccessible(aContent, 
89799:                                     nsAccUtils::GetDocAccessibleFor(aPresShell));
89799:   NS_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLTableAccessible(nsIContent* aContent,
46338:                                                   nsIPresShell* aPresShell)
    1: {
89799:   nsAccessible* accessible = 
89799:     new nsHTMLTableAccessibleWrap(aContent, 
89799:                                   nsAccUtils::GetDocAccessibleFor(aPresShell));
89799:   NS_ADDREF(accessible);
46338:   return accessible;
43504: }
43504: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLTableCellAccessible(nsIContent* aContent,
46338:                                                       nsIPresShell* aPresShell)
43504: {
89799:   nsAccessible* accessible = 
89799:     new nsHTMLTableCellAccessibleWrap(aContent,
89799:                                       nsAccUtils::GetDocAccessibleFor(aPresShell));
89799:   NS_ADDREF(accessible);
46338:   return accessible;
43504: }
43504: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLTextAccessible(nsIContent* aContent,
46338:                                                  nsIPresShell* aPresShell)
43504: {
89799:   nsAccessible* accessible = 
89799:     new nsHTMLTextAccessible(aContent, 
89799:                              nsAccUtils::GetDocAccessibleFor(aPresShell));
89799:   NS_ADDREF(accessible);
46338:   return accessible;
43504: }
43504: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLTextFieldAccessible(nsIContent* aContent,
46338:                                                       nsIPresShell* aPresShell)
43504: {
89799:   nsAccessible* accessible = 
89799:     new nsHTMLTextFieldAccessible(aContent, 
89799:                                   nsAccUtils::GetDocAccessibleFor(aPresShell));
89799:   NS_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLLabelAccessible(nsIContent* aContent,
46338:                                                   nsIPresShell* aPresShell)
    1: {
89799:   nsAccessible* accessible = 
89799:     new nsHTMLLabelAccessible(aContent, 
89799:                               nsAccUtils::GetDocAccessibleFor(aPresShell));
89799:   NS_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLHRAccessible(nsIContent* aContent,
46338:                                                nsIPresShell* aPresShell)
    1: {
89799:   nsAccessible* accessible = 
89799:     new nsHTMLHRAccessible(aContent, 
89799:                            nsAccUtils::GetDocAccessibleFor(aPresShell));
89799:   NS_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLBRAccessible(nsIContent* aContent,
46338:                                                nsIPresShell* aPresShell)
    1: {
89799:   nsAccessible* accessible = 
89799:     new nsHTMLBRAccessible(aContent, 
89799:                            nsAccUtils::GetDocAccessibleFor(aPresShell));
89799:   NS_ADDREF(accessible);
46338:   return accessible;
    1: }
    1: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLCaptionAccessible(nsIContent* aContent,
46338:                                                     nsIPresShell* aPresShell)
    1: {
89799:   nsAccessible* accessible = 
89799:     new nsHTMLCaptionAccessible(aContent, 
89799:                                 nsAccUtils::GetDocAccessibleFor(aPresShell));
89799:   NS_ADDREF(accessible);
46338:   return accessible;
 3151: }
 3151: 
43765: void
56292: nsAccessibilityService::ContentRangeInserted(nsIPresShell* aPresShell,
56292:                                              nsIContent* aContainer,
56292:                                              nsIContent* aStartChild,
56292:                                              nsIContent* aEndChild)
56292: {
56987: #ifdef DEBUG_CONTENTMUTATION
56292:   nsAutoString tag;
56292:   aStartChild->Tag()->ToString(tag);
56987: 
56987:   nsIAtom* atomid = aStartChild->GetID();
56987:   nsCAutoString id;
56987:   if (atomid)
56987:     atomid->ToUTF8String(id);
56987: 
56292:   nsAutoString ctag;
56987:   nsCAutoString cid;
56987:   nsIAtom* catomid = nsnull;
56987:   if (aContainer) {
56292:     aContainer->Tag()->ToString(ctag);
56987:     catomid = aContainer->GetID();
56987:     if (catomid)
56987:       catomid->ToUTF8String(cid);
56987:   }
56987: 
56292:   printf("\ncontent inserted: %s@id='%s', container: %s@id='%s', end node: %p\n\n",
56987:          NS_ConvertUTF16toUTF8(tag).get(), id.get(),
56987:          NS_ConvertUTF16toUTF8(ctag).get(), cid.get(), aEndChild);
56292: #endif
56292: 
56292:   nsDocAccessible* docAccessible = GetDocAccessible(aPresShell->GetDocument());
56292:   if (docAccessible)
60746:     docAccessible->ContentInserted(aContainer, aStartChild, aEndChild);
56292: }
56292: 
56292: void
56292: nsAccessibilityService::ContentRemoved(nsIPresShell* aPresShell,
56292:                                        nsIContent* aContainer,
56292:                                        nsIContent* aChild)
56292: {
56987: #ifdef DEBUG_CONTENTMUTATION
56987:   nsAutoString tag;
56987:   aChild->Tag()->ToString(tag);
56987: 
56987:   nsIAtom* atomid = aChild->GetID();
56987:   nsCAutoString id;
56987:   if (atomid)
56987:     atomid->ToUTF8String(id);
56987: 
56987:   nsAutoString ctag;
56987:   nsCAutoString cid;
56987:   nsIAtom* catomid = nsnull;
56987:   if (aContainer) {
56987:     aContainer->Tag()->ToString(ctag);
56987:     catomid = aContainer->GetID();
56987:     if (catomid)
56987:       catomid->ToUTF8String(cid);
56987:   }
56987: 
56987:   printf("\ncontent removed: %s@id='%s', container: %s@id='%s'\n\n",
56987:            NS_ConvertUTF16toUTF8(tag).get(), id.get(),
56987:            NS_ConvertUTF16toUTF8(ctag).get(), cid.get());
56292: #endif
56292: 
56292:   nsDocAccessible* docAccessible = GetDocAccessible(aPresShell->GetDocument());
56292:   if (docAccessible)
60746:     docAccessible->ContentRemoved(aContainer, aChild);
56292: }
56292: 
56292: void
61516: nsAccessibilityService::UpdateText(nsIPresShell* aPresShell,
61516:                                    nsIContent* aContent)
61516: {
61516:   nsDocAccessible* document = GetDocAccessible(aPresShell->GetDocument());
61516:   if (document)
61516:     document->UpdateText(aContent);
61516: }
61516: 
61516: void
64006: nsAccessibilityService::UpdateListBullet(nsIPresShell* aPresShell,
64006:                                          nsIContent* aHTMLListItemContent,
64006:                                          bool aHasBullet)
64006: {
64006:   nsDocAccessible* document = GetDocAccessible(aPresShell->GetDocument());
64006:   if (document) {
64006:     nsAccessible* accessible = document->GetAccessible(aHTMLListItemContent);
64006:     if (accessible) {
64006:       nsHTMLLIAccessible* listItem = accessible->AsHTMLListItem();
64006:       if (listItem)
64006:         listItem->UpdateBullet(aHasBullet);
64006:     }
64006:   }
64006: }
64006: 
64006: void
93267: nsAccessibilityService::UpdateImageMap(nsImageFrame* aImageFrame)
93267: {
93267:   nsIPresShell* presShell = aImageFrame->PresContext()->PresShell();
93267:   nsDocAccessible* document = GetDocAccessible(presShell->GetDocument());
93267:   if (document) {
93267:     nsAccessible* accessible =
93267:       document->GetAccessible(aImageFrame->GetContent());
93267:     if (accessible) {
93267:       nsHTMLImageMapAccessible* imageMap = accessible->AsImageMap();
93267:       if (imageMap) {
93267:         imageMap->UpdateChildAreas();
93267:         return;
93267:       }
93267: 
93267:       // If image map was initialized after we created an accessible (that'll
93267:       // be an image accessible) then recreate it.
93267:       RecreateAccessible(presShell, aImageFrame->GetContent());
93267:     }
93267:   }
93267: }
93267: 
93267: void
43765: nsAccessibilityService::PresShellDestroyed(nsIPresShell *aPresShell)
43765: {
43765:   // Presshell destruction will automatically destroy shells for descendant
43765:   // documents, so no need to worry about those. Just shut down the accessible
43765:   // for this one document. That keeps us from having bad behavior in case of
43765:   // deep bushy subtrees.
43765:   // When document subtree containing iframe is hidden then we don't get
43765:   // pagehide event for the iframe's underlying document and its presshell is
43765:   // destroyed before we're notified styles were changed. Shutdown the document
43765:   // accessible early.
43765:   nsIDocument* doc = aPresShell->GetDocument();
43765:   if (!doc)
43765:     return;
43765: 
43765:   NS_LOG_ACCDOCDESTROY("presshell destroyed", doc)
56639: 
56639:   nsDocAccessible* docAccessible = GetDocAccessibleFromCache(doc);
56639:   if (docAccessible)
56639:     docAccessible->Shutdown();
43765: }
43765: 
56292: void
63261: nsAccessibilityService::PresShellActivated(nsIPresShell* aPresShell)
63261: {
63261:   nsIDocument* DOMDoc = aPresShell->GetDocument();
63261:   if (DOMDoc) {
63261:     nsDocAccessible* document = GetDocAccessibleFromCache(DOMDoc);
63261:     if (document) {
63261:       nsRootAccessible* rootDocument = document->RootAccessible();
63261:       NS_ASSERTION(rootDocument, "Entirely broken tree: no root document!");
63261:       if (rootDocument)
63261:         rootDocument->DocumentActivated(document);
63261:     }
63261:   }
63261: }
63261: 
63261: void
56292: nsAccessibilityService::RecreateAccessible(nsIPresShell* aPresShell,
56292:                                            nsIContent* aContent)
56292: {
56292:   nsDocAccessible* document = GetDocAccessible(aPresShell->GetDocument());
93850:   if (document)
93850:     document->RecreateAccessible(aContent);
56292: }
56292: 
38359: ////////////////////////////////////////////////////////////////////////////////
38359: // nsIAccessibleRetrieval
38359: 
 2064: NS_IMETHODIMP
39600: nsAccessibilityService::GetApplicationAccessible(nsIAccessible **aAccessibleApplication)
39567: {
39600:   NS_ENSURE_ARG_POINTER(aAccessibleApplication);
39567: 
39600:   NS_IF_ADDREF(*aAccessibleApplication = nsAccessNode::GetApplicationAccessible());
39600:   return NS_OK;
39567: }
39567: 
39567: NS_IMETHODIMP
43504: nsAccessibilityService::GetAccessibleFor(nsIDOMNode *aNode,
43504:                                          nsIAccessible **aAccessible)
43504: {
43504:   NS_ENSURE_ARG_POINTER(aAccessible);
72710:   *aAccessible = nsnull;
72710:   if (!aNode)
72710:     return NS_OK;
43504: 
43504:   nsCOMPtr<nsINode> node(do_QueryInterface(aNode));
77682:   if (!node)
77682:     return NS_ERROR_INVALID_ARG;
77682: 
89801:   NS_IF_ADDREF(*aAccessible = GetAccessible(node, nsnull));
43504:   return NS_OK;
43504: }
43504: 
43504: NS_IMETHODIMP
 2064: nsAccessibilityService::GetStringRole(PRUint32 aRole, nsAString& aString)
 2064: {
80467:   if ( aRole >= ArrayLength(kRoleNames)) {
 2064:     aString.AssignLiteral("unknown");
 2064:     return NS_OK;
 2064:   }
 2064: 
 2064:   CopyUTF8toUTF16(kRoleNames[aRole], aString);
 2064:   return NS_OK;
 2064: }
 2064: 
 2064: NS_IMETHODIMP
67790: nsAccessibilityService::GetStringStates(PRUint32 aState, PRUint32 aExtraState,
 2064:                                         nsIDOMDOMStringList **aStringStates)
 2064: {
 2064:   nsAccessibleDOMStringList *stringStates = new nsAccessibleDOMStringList();
 2064:   NS_ENSURE_TRUE(stringStates, NS_ERROR_OUT_OF_MEMORY);
 2064: 
67790:   PRUint64 state = nsAccUtils::To64State(aState, aExtraState);
67790: 
 2064:   // states
67790:   if (state & states::UNAVAILABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("unavailable"));
67790:   if (state & states::SELECTED)
 2064:     stringStates->Add(NS_LITERAL_STRING("selected"));
67790:   if (state & states::FOCUSED)
 2064:     stringStates->Add(NS_LITERAL_STRING("focused"));
67790:   if (state & states::PRESSED)
 2064:     stringStates->Add(NS_LITERAL_STRING("pressed"));
67790:   if (state & states::CHECKED)
 2064:     stringStates->Add(NS_LITERAL_STRING("checked"));
67790:   if (state & states::MIXED)
 2064:     stringStates->Add(NS_LITERAL_STRING("mixed"));
67790:   if (state & states::READONLY)
 2064:     stringStates->Add(NS_LITERAL_STRING("readonly"));
67790:   if (state & states::HOTTRACKED)
 2064:     stringStates->Add(NS_LITERAL_STRING("hottracked"));
67790:   if (state & states::DEFAULT)
 2064:     stringStates->Add(NS_LITERAL_STRING("default"));
67790:   if (state & states::EXPANDED)
 2064:     stringStates->Add(NS_LITERAL_STRING("expanded"));
67790:   if (state & states::COLLAPSED)
 2064:     stringStates->Add(NS_LITERAL_STRING("collapsed"));
67790:   if (state & states::BUSY)
 2064:     stringStates->Add(NS_LITERAL_STRING("busy"));
67790:   if (state & states::FLOATING)
 2064:     stringStates->Add(NS_LITERAL_STRING("floating"));
67790:   if (state & states::ANIMATED)
 2064:     stringStates->Add(NS_LITERAL_STRING("animated"));
67790:   if (state & states::INVISIBLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("invisible"));
67790:   if (state & states::OFFSCREEN)
 2064:     stringStates->Add(NS_LITERAL_STRING("offscreen"));
67790:   if (state & states::SIZEABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("sizeable"));
67790:   if (state & states::MOVEABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("moveable"));
67790:   if (state & states::SELFVOICING)
 2064:     stringStates->Add(NS_LITERAL_STRING("selfvoicing"));
67790:   if (state & states::FOCUSABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("focusable"));
67790:   if (state & states::SELECTABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("selectable"));
67790:   if (state & states::LINKED)
 2064:     stringStates->Add(NS_LITERAL_STRING("linked"));
67790:   if (state & states::TRAVERSED)
 2064:     stringStates->Add(NS_LITERAL_STRING("traversed"));
67790:   if (state & states::MULTISELECTABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("multiselectable"));
67790:   if (state & states::EXTSELECTABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("extselectable"));
67790:   if (state & states::PROTECTED)
 2064:     stringStates->Add(NS_LITERAL_STRING("protected"));
67790:   if (state & states::HASPOPUP)
 2064:     stringStates->Add(NS_LITERAL_STRING("haspopup"));
67790:   if (state & states::REQUIRED)
 2064:     stringStates->Add(NS_LITERAL_STRING("required"));
67790:   if (state & states::ALERT)
67790:     stringStates->Add(NS_LITERAL_STRING("alert"));
67790:   if (state & states::INVALID)
 2064:     stringStates->Add(NS_LITERAL_STRING("invalid"));
67790:   if (state & states::CHECKABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("checkable"));
 2064: 
 2064:   // extraStates
67790:   if (state & states::SUPPORTS_AUTOCOMPLETION)
 3513:     stringStates->Add(NS_LITERAL_STRING("autocompletion"));
67790:   if (state & states::DEFUNCT)
 3513:     stringStates->Add(NS_LITERAL_STRING("defunct"));
67790:   if (state & states::SELECTABLE_TEXT)
 2064:     stringStates->Add(NS_LITERAL_STRING("selectable text"));
67790:   if (state & states::EDITABLE)
 2064:     stringStates->Add(NS_LITERAL_STRING("editable"));
67790:   if (state & states::ACTIVE)
 2064:     stringStates->Add(NS_LITERAL_STRING("active"));
67790:   if (state & states::MODAL)
 2064:     stringStates->Add(NS_LITERAL_STRING("modal"));
67790:   if (state & states::MULTI_LINE)
 2064:     stringStates->Add(NS_LITERAL_STRING("multi line"));
67790:   if (state & states::HORIZONTAL)
 3513:     stringStates->Add(NS_LITERAL_STRING("horizontal"));
67790:   if (state & states::OPAQUE1)
 3513:     stringStates->Add(NS_LITERAL_STRING("opaque"));
67790:   if (state & states::SINGLE_LINE)
 2064:     stringStates->Add(NS_LITERAL_STRING("single line"));
67790:   if (state & states::TRANSIENT)
 2064:     stringStates->Add(NS_LITERAL_STRING("transient"));
67790:   if (state & states::VERTICAL)
 2064:     stringStates->Add(NS_LITERAL_STRING("vertical"));
67790:   if (state & states::STALE)
 3513:     stringStates->Add(NS_LITERAL_STRING("stale"));
67790:   if (state & states::ENABLED)
 3513:     stringStates->Add(NS_LITERAL_STRING("enabled"));
67790:   if (state & states::SENSITIVE)
 3513:     stringStates->Add(NS_LITERAL_STRING("sensitive"));
67790:   if (state & states::EXPANDABLE)
 3513:     stringStates->Add(NS_LITERAL_STRING("expandable"));
 2064: 
 2064:   //unknown states
 2064:   PRUint32 stringStatesLength = 0;
 2064:   stringStates->GetLength(&stringStatesLength);
 2064:   if (!stringStatesLength)
 2064:     stringStates->Add(NS_LITERAL_STRING("unknown"));
 2064: 
 2064:   NS_ADDREF(*aStringStates = stringStates);
 2064:   return NS_OK;
 2064: }
 2064: 
 5188: // nsIAccessibleRetrieval::getStringEventType()
 5188: NS_IMETHODIMP
 5188: nsAccessibilityService::GetStringEventType(PRUint32 aEventType,
 5188:                                            nsAString& aString)
 5188: {
80467:   NS_ASSERTION(nsIAccessibleEvent::EVENT_LAST_ENTRY == ArrayLength(kEventTypeNames),
 6284:                "nsIAccessibleEvent constants are out of sync to kEventTypeNames");
 6284: 
80467:   if (aEventType >= ArrayLength(kEventTypeNames)) {
 5188:     aString.AssignLiteral("unknown");
 5188:     return NS_OK;
 5188:   }
 5188: 
 5188:   CopyUTF8toUTF16(kEventTypeNames[aEventType], aString);
 5188:   return NS_OK;
 5188: }
 5188: 
 6812: // nsIAccessibleRetrieval::getStringRelationType()
 6812: NS_IMETHODIMP
 6812: nsAccessibilityService::GetStringRelationType(PRUint32 aRelationType,
 6812:                                               nsAString& aString)
 6812: {
80467:   if (aRelationType >= ArrayLength(kRelationTypeNames)) {
 6812:     aString.AssignLiteral("unknown");
 6812:     return NS_OK;
 6812:   }
 6812: 
 6812:   CopyUTF8toUTF16(kRelationTypeNames[aRelationType], aString);
 6812:   return NS_OK;
 6812: }
 6812: 
43764: NS_IMETHODIMP
43764: nsAccessibilityService::GetAccessibleFromCache(nsIDOMNode* aNode,
43764:                                                nsIAccessible** aAccessible)
43764: {
43764:   NS_ENSURE_ARG_POINTER(aAccessible);
77682:   *aAccessible = nsnull;
77682:   if (!aNode)
77682:     return NS_OK;
77682: 
77682:   nsCOMPtr<nsINode> node(do_QueryInterface(aNode));
77682:   if (!node)
77682:     return NS_ERROR_INVALID_ARG;
43764: 
43764:   // Search for an accessible in each of our per document accessible object
43764:   // caches. If we don't find it, and the given node is itself a document, check
43764:   // our cache of document accessibles (document cache). Note usually shutdown
43764:   // document accessibles are not stored in the document cache, however an
43764:   // "unofficially" shutdown document (i.e. not from nsAccDocManager) can still
43764:   // exist in the document cache.
56292:   nsAccessible* accessible = FindAccessibleInCache(node);
43764:   if (!accessible) {
43764:     nsCOMPtr<nsIDocument> document(do_QueryInterface(node));
43764:     if (document)
43764:       accessible = GetDocAccessibleFromCache(document);
43764:   }
43764: 
43764:   NS_IF_ADDREF(*aAccessible = accessible);
43764:   return NS_OK;
43764: }
43764: 
89309: NS_IMETHODIMP
89309: nsAccessibilityService::CreateAccessiblePivot(nsIAccessible* aRoot,
89309:                                               nsIAccessiblePivot** aPivot)
89309: {
89309:   NS_ENSURE_ARG_POINTER(aPivot);
89309:   NS_ENSURE_ARG(aRoot);
89309:   *aPivot = nsnull;
89309: 
89309:   nsRefPtr<nsAccessible> accessibleRoot(do_QueryObject(aRoot));
89309:   NS_ENSURE_TRUE(accessibleRoot, NS_ERROR_INVALID_ARG);
89309: 
89309:   nsAccessiblePivot* pivot = new nsAccessiblePivot(accessibleRoot);
89309:   NS_ADDREF(*aPivot = pivot);
89309: 
89309:   return NS_OK;
89309: }
89309: 
38359: ////////////////////////////////////////////////////////////////////////////////
38359: // nsAccessibilityService public
38359: 
42795: nsAccessible*
89801: nsAccessibilityService::GetAccessible(nsINode* aNode, nsIPresShell* aPresShell)
42795: {
70181:   NS_PRECONDITION(aNode, "Getting an accessible for null node! Crash.");
70181: 
89801:   // XXX handle the presshell
80526:   nsDocAccessible* document = GetDocAccessible(aNode->OwnerDoc());
61461:   return document ? document->GetAccessible(aNode) : nsnull;
42795: }
42795: 
79445: static bool HasRelatedContent(nsIContent *aContent)
10515: {
10515:   nsAutoString id;
20521:   if (!aContent || !nsCoreUtils::GetID(aContent, id) || id.IsEmpty()) {
80486:     return false;
10515:   }
10515: 
57890:   // If the given ID is referred by relation attribute then create an accessible
57890:   // for it. Take care of HTML elements only for now.
87821:   return aContent->IsHTML() &&
87821:     nsAccUtils::GetDocAccessibleFor(aContent)->IsDependentID(id);
10515: }
10515: 
64506: nsAccessible*
46469: nsAccessibilityService::GetOrCreateAccessible(nsINode* aNode,
89801:                                               nsDocAccessible* aDoc,
57448:                                               bool* aIsSubtreeHidden)
    1: {
89801:   if (!aDoc || !aNode || gIsShutdown)
38359:     return nsnull;
    1: 
57448:   if (aIsSubtreeHidden)
57448:     *aIsSubtreeHidden = false;
    1: 
38062:   // Check to see if we already have an accessible for this node in the cache.
89801:   nsAccessible* cachedAccessible = aDoc->GetAccessible(aNode);
64506:   if (cachedAccessible)
43538:     return cachedAccessible;
    1: 
38359:   // No cache entry, so we must create the accessible.
38359: 
43504:   if (aNode->IsNodeOfType(nsINode::eDOCUMENT)) {
43310:     // If it's document node then ask accessible document loader for
43310:     // document accessible, otherwise return null.
43310:     nsCOMPtr<nsIDocument> document(do_QueryInterface(aNode));
64506:     return GetDocAccessible(document);
43310:   }
    1: 
38359:   // We have a content node.
43504:   if (!aNode->IsInDoc()) {
43310:     NS_WARNING("Creating accessible for node with no document");
38359:     return nsnull;
    1:   }
    1: 
89801:   if (aNode->OwnerDoc() != aDoc->GetDocumentNode()) {
89801:     NS_ERROR("Creating accessible for wrong document");
38359:     return nsnull;
38359:   }
34904: 
43504:   nsCOMPtr<nsIContent> content(do_QueryInterface(aNode));
43504:   if (!content)
43504:     return nsnull;
43504: 
38359:   // Frames can be deallocated when we flush layout, or when we call into code
38359:   // that can flush layout, either directly, or via DOM manipulation, or some
38359:   // CSS styles like :hover. We use the weak frame checks to avoid calling
38359:   // methods on a dead frame pointer.
38359:   nsWeakFrame weakFrame = content->GetPrimaryFrame();
38359: 
57448:   // Check frame and its visibility. Note, hidden frame allows visible
57448:   // elements in subtree.
57448:   if (!weakFrame.GetFrame() || !weakFrame->GetStyleVisibility()->IsVisible()) {
57448:     if (aIsSubtreeHidden && !weakFrame.GetFrame())
57448:       *aIsSubtreeHidden = true;
38359: 
38359:     return nsnull;
    1:   }
38359: 
34904:   if (weakFrame.GetFrame()->GetContent() != content) {
40575:     // Not the main content for this frame. This happens because <area>
40575:     // elements return the image frame as their primary frame. The main content
40575:     // for the image frame is the image content. If the frame is not an image
40575:     // frame or the node is not an area element then null is returned.
79733:     // This setup will change when bug 135040 is fixed. Make sure we don't
79733:     // create area accessible here. Hopefully assertion below will handle that.
79733: 
79733: #ifdef DEBUG
79733:   nsImageFrame* imageFrame = do_QueryFrame(weakFrame.GetFrame());
79733:   NS_ASSERTION(imageFrame && content->IsHTML() && content->Tag() == nsGkAtoms::area,
79733:                "Unknown case of not main content for the frame!");
79733: #endif
79733:     return nsnull;
    1:   }
    1: 
79733: #ifdef DEBUG
79733:   nsImageFrame* imageFrame = do_QueryFrame(weakFrame.GetFrame());
79733:   NS_ASSERTION(!imageFrame || !content->IsHTML() || content->Tag() != nsGkAtoms::area,
79733:                "Image map manages the area accessible creation!");
79733: #endif
79733: 
57413:   nsDocAccessible* docAcc =
80526:     GetAccService()->GetDocAccessible(aNode->OwnerDoc());
57413:   if (!docAcc) {
64506:     NS_NOTREACHED("Node has no host document accessible!");
57413:     return nsnull;
57413:   }
57413: 
38359:   // Attempt to create an accessible based on what we know.
43310:   nsRefPtr<nsAccessible> newAcc;
61649: 
61649:   // Create accessible for visible text frames.
    1:   if (content->IsNodeOfType(nsINode::eTEXT)) {
61649:     nsAutoString text;
61649:     weakFrame->GetRenderedText(&text, nsnull, nsnull, 0, PR_UINT32_MAX);
61649:     if (text.IsEmpty()) {
57448:       if (aIsSubtreeHidden)
57448:         *aIsSubtreeHidden = true;
38359: 
38359:       return nsnull;
    1:     }
61649: 
61649:     newAcc = weakFrame->CreateAccessible();
61649:     if (docAcc->BindToDocument(newAcc, nsnull)) {
61649:       newAcc->AsTextLeaf()->SetText(text);
64506:       return newAcc;
38359:     }
35026: 
38359:     return nsnull;
    1:   }
    1: 
79445:   bool isHTML = content->IsHTML();
78350:   if (isHTML && content->Tag() == nsGkAtoms::map) {
15308:     // Create hyper text accessible for HTML map if it is used to group links
15308:     // (see http://www.w3.org/TR/WCAG10-HTML-TECHS/#group-bypass). If the HTML
79788:     // map rect is empty then it is used for links grouping. Otherwise it should
79788:     // be used in conjunction with HTML image element and in this case we don't
79788:     // create any accessible for it and don't walk into it. The accessibles for
79788:     // HTML area (nsHTMLAreaAccessible) the map contains are attached as
79788:     // children of the appropriate accessible for HTML image
79788:     // (nsHTMLImageAccessible).
79788:     if (nsLayoutUtils::GetAllInFlowRectsUnion(weakFrame,
79788:                                               weakFrame->GetParent()).IsEmpty()) {
57448:       if (aIsSubtreeHidden)
57448:         *aIsSubtreeHidden = true;
38359: 
38359:       return nsnull;
15308:     }
15308: 
89799:     newAcc = new nsHyperTextAccessibleWrap(content, docAcc);
57413:     if (docAcc->BindToDocument(newAcc, nsAccUtils::GetRoleMapEntry(aNode)))
64506:       return newAcc;
38359:     return nsnull;
15308:   }
15308: 
20536:   nsRoleMapEntry *roleMapEntry = nsAccUtils::GetRoleMapEntry(aNode);
72715:   if (roleMapEntry && !nsCRT::strcmp(roleMapEntry->roleString, "presentation")) {
72715:     // Ignore presentation role if element is focusable (focus event shouldn't
72715:     // be ever lost and should be sensible).
72715:     if (content->IsFocusable())
72715:       roleMapEntry = nsnull;
72715:     else
38359:       return nsnull;
    1:   }
    1: 
34904:   if (weakFrame.IsAlive() && !newAcc && isHTML) {  // HTML accessibles
79445:     bool tryTagNameOrFrame = true;
13731: 
34904:     nsIAtom *frameType = weakFrame.GetFrame()->GetType();
28493: 
79445:     bool partOfHTMLTable =
78350:       frameType == nsGkAtoms::tableCaptionFrame ||
78350:       frameType == nsGkAtoms::tableCellFrame ||
78350:       frameType == nsGkAtoms::tableRowGroupFrame ||
78350:       frameType == nsGkAtoms::tableRowFrame;
28493: 
32474:     if (partOfHTMLTable) {
10869:       // Table-related frames don't get table-related roles
10869:       // unless they are inside a table, but they may still get generic
10869:       // accessibles
    1:       nsIContent *tableContent = content;
    1:       while ((tableContent = tableContent->GetParent()) != nsnull) {
36654:         nsIFrame *tableFrame = tableContent->GetPrimaryFrame();
10869:         if (!tableFrame)
10869:           continue;
32474: 
78350:         if (tableFrame->GetType() == nsGkAtoms::tableOuterFrame) {
89801:           nsAccessible* tableAccessible = aDoc->GetAccessible(tableContent);
32474: 
32474:           if (tableAccessible) {
32479:             if (!roleMapEntry) {
87094:               roles::Role role = tableAccessible->Role();
32479:               // No ARIA role and not in table: override role. For example,
32479:               // <table role="label"><td>content</td></table>
87094:               if (role != roles::TABLE && role != roles::TREE_TABLE)
32474:                 roleMapEntry = &nsARIAMap::gEmptyRoleMap;
32474:             }
32474: 
32474:             break;
32474:           }
32474: 
10869: #ifdef DEBUG
20521:           nsRoleMapEntry *tableRoleMapEntry =
43504:             nsAccUtils::GetRoleMapEntry(tableContent);
11383:           NS_ASSERTION(tableRoleMapEntry &&
11383:                        !nsCRT::strcmp(tableRoleMapEntry->roleString, "presentation"),
10869:                        "No accessible for parent table and it didn't have role of presentation");
10869: #endif
32474: 
32474:           if (!roleMapEntry && !content->IsFocusable()) {
32474:             // Table-related descendants of presentation table are also
32474:             // presentation if they aren't focusable and have not explicit ARIA
32474:             // role (don't create accessibles for them unless they need to fire
32474:             // focus events).
38359:             return nsnull;
10869:           }
32474: 
32474:           // otherwise create ARIA based accessible.
80486:           tryTagNameOrFrame = false;
 6090:           break;
 6090:         }
32474: 
78350:         if (tableContent->Tag() == nsGkAtoms::table) {
10869:           // Stop before we are fooled by any additional table ancestors
10869:           // This table cell frameis part of a separate ancestor table.
80486:           tryTagNameOrFrame = false;
10421:           break;
 6090:         }
 6090:       }
13731: 
13731:       if (!tableContent)
80486:         tryTagNameOrFrame = false;
    1:     }
    1: 
29271:     if (roleMapEntry) {
29271:       // Create ARIA grid/treegrid accessibles if node is not of a child or
29271:       // valid child of HTML table and is not a HTML table.
29271:       if ((!partOfHTMLTable || !tryTagNameOrFrame) &&
78350:           frameType != nsGkAtoms::tableOuterFrame) {
29271: 
87094:         if (roleMapEntry->role == roles::TABLE ||
87094:             roleMapEntry->role == roles::TREE_TABLE) {
89799:           newAcc = new nsARIAGridAccessibleWrap(content, docAcc);
29271: 
87094:         } else if (roleMapEntry->role == roles::GRID_CELL ||
87094:             roleMapEntry->role == roles::ROWHEADER ||
87094:             roleMapEntry->role == roles::COLUMNHEADER) {
89799:           newAcc = new nsARIAGridCellAccessibleWrap(content, docAcc);
28493:         }
28493:       }
29271:     }
28493: 
28493:     if (!newAcc && tryTagNameOrFrame) {
 6090:       // Prefer to use markup (mostly tag name, perhaps attributes) to
 6090:       // decide if and what kind of accessible to create.
 6090:       // The method creates accessibles for table related content too therefore
 6090:       // we do not call it if accessibles for table related content are
 6090:       // prevented above.
46338:       newAcc = CreateHTMLAccessibleByMarkup(weakFrame.GetFrame(), content,
89799:                                             docAcc);
    1: 
 6090:       if (!newAcc) {
 6090:         // Do not create accessible object subtrees for non-rendered table
 6090:         // captions. This could not be done in
 6090:         // nsTableCaptionFrame::GetAccessible() because the descendants of
 6090:         // the table caption would still be created. By setting
57448:         // *aIsSubtreeHidden = true we ensure that no descendant accessibles
57448:         // are created.
34904:         nsIFrame* f = weakFrame.GetFrame();
34904:         if (!f) {
89801:           f = aDoc->PresShell()->GetRealPrimaryFrameFor(content);
34904:         }
78350:         if (f->GetType() == nsGkAtoms::tableCaptionFrame &&
34904:            f->GetRect().IsEmpty()) {
 6090:           // XXX This is not the ideal place for this code, but right now there
 6090:           // is no better place:
57448:           if (aIsSubtreeHidden)
57448:             *aIsSubtreeHidden = true;
38359: 
38359:           return nsnull;
 3151:         }
38359: 
38359:         // Try using frame to do it.
46338:         newAcc = f->CreateAccessible();
    1:       }
    1:     }
13731:   }
    1: 
 1477:   if (!newAcc) {
28493:     // Elements may implement nsIAccessibleProvider via XBL. This allows them to
28493:     // say what kind of accessible to create.
89799:     newAcc = CreateAccessibleByType(content, docAcc);
28493:   }
28493: 
28493:   if (!newAcc) {
28493:     // Create generic accessibles for SVG and MathML nodes.
84637:     if (content->IsSVG(nsGkAtoms::svg)) {
89799:       newAcc = new nsEnumRoleAccessible(content, docAcc,
87094:                                         roles::DIAGRAM);
28493:     }
84637:     else if (content->IsMathML(nsGkAtoms::math)) {
89799:       newAcc = new nsEnumRoleAccessible(content, docAcc,
87094:                                         roles::EQUATION);
28493:     }
28493:   }
28493: 
28493:   if (!newAcc) {
43504:     newAcc = CreateAccessibleForDeckChild(weakFrame.GetFrame(), content,
89799:                                           docAcc);
 1477:   }
 1477: 
    1:   // If no accessible, see if we need to create a generic accessible because
    1:   // of some property that makes this object interesting
    1:   // We don't do this for <body>, <html>, <window>, <dialog> etc. which 
    1:   // correspond to the doc accessible and will be created in any case
78350:   if (!newAcc && content->Tag() != nsGkAtoms::body && content->GetParent() && 
34904:       ((weakFrame.GetFrame() && weakFrame.GetFrame()->IsFocusable()) ||
37859:        (isHTML && nsCoreUtils::HasClickListener(content)) ||
39578:        HasUniversalAriaProperty(content) || roleMapEntry ||
20521:        HasRelatedContent(content) || nsCoreUtils::IsXLink(content))) {
    1:     // This content is focusable or has an interesting dynamic content accessibility property.
    1:     // If it's interesting we need it in the accessibility hierarchy so that events or
    1:     // other accessibles can point to it, or so that it can hold a state, etc.
 1672:     if (isHTML) {
    1:       // Interesting HTML container which may have selectable text and/or embedded objects
89799:       newAcc = new nsHyperTextAccessibleWrap(content, docAcc);
    1:     }
    1:     else {  // XUL, SVG, MathML etc.
    1:       // Interesting generic non-HTML container
89799:       newAcc = new nsAccessibleWrap(content, docAcc);
    1:     }
    1:   }
    1: 
64506:   return docAcc->BindToDocument(newAcc, roleMapEntry) ? newAcc : nsnull;
    1: }
    1: 
43310: ////////////////////////////////////////////////////////////////////////////////
43310: // nsAccessibilityService private
43310: 
79445: bool
43310: nsAccessibilityService::Init()
43310: {
43310:   // Initialize accessible document manager.
43310:   if (!nsAccDocManager::Init())
80486:     return false;
43310: 
43310:   // Add observers.
43310:   nsCOMPtr<nsIObserverService> observerService =
43310:     mozilla::services::GetObserverService();
43310:   if (!observerService)
80486:     return false;
43310: 
80486:   observerService->AddObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID, false);
43310: 
43310:   // Initialize accessibility.
43310:   nsAccessNodeWrap::InitAccessibility();
43310: 
80486:   gIsShutdown = false;
80486:   return true;
43310: }
43310: 
43310: void
43310: nsAccessibilityService::Shutdown()
43310: {
43310:   // Remove observers.
43310:   nsCOMPtr<nsIObserverService> observerService =
43310:       mozilla::services::GetObserverService();
43310:   if (observerService)
43310:     observerService->RemoveObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID);
43310: 
43310:   // Stop accessible document loader.
43310:   nsAccDocManager::Shutdown();
43310: 
43310:   // Application is going to be closed, shutdown accessibility and mark
43310:   // accessibility service as shutdown to prevent calls of its methods.
43310:   // Don't null accessibility service static member at this point to be safe
43310:   // if someone will try to operate with it.
43310: 
43310:   NS_ASSERTION(!gIsShutdown, "Accessibility was shutdown already");
43310: 
80486:   gIsShutdown = true;
43310: 
43310:   nsAccessNodeWrap::ShutdownAccessibility();
43310: }
43310: 
79445: bool
39578: nsAccessibilityService::HasUniversalAriaProperty(nsIContent *aContent)
 6279: {
39578:   // ARIA attributes that take token values (NMTOKEN, bool) are special cased
39578:   // because of special value "undefined" (see HasDefinedARIAToken).
78350:   return nsAccUtils::HasDefinedARIAToken(aContent, nsGkAtoms::aria_atomic) ||
78350:          nsAccUtils::HasDefinedARIAToken(aContent, nsGkAtoms::aria_busy) ||
78350:          aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::aria_controls) ||
78350:          aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::aria_describedby) ||
78350:          aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::aria_disabled) ||
78350:          nsAccUtils::HasDefinedARIAToken(aContent, nsGkAtoms::aria_dropeffect) ||
78350:          aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::aria_flowto) ||
78350:          nsAccUtils::HasDefinedARIAToken(aContent, nsGkAtoms::aria_grabbed) ||
78350:          nsAccUtils::HasDefinedARIAToken(aContent, nsGkAtoms::aria_haspopup) ||
78350:          aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::aria_hidden) ||
78350:          nsAccUtils::HasDefinedARIAToken(aContent, nsGkAtoms::aria_invalid) ||
78350:          aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::aria_label) ||
78350:          aContent->HasAttr(kNameSpaceID_None, nsGkAtoms::aria_labelledby) ||
78350:          nsAccUtils::HasDefinedARIAToken(aContent, nsGkAtoms::aria_live) ||
78350:          nsAccUtils::HasDefinedARIAToken(aContent, nsGkAtoms::aria_owns) ||
78350:          nsAccUtils::HasDefinedARIAToken(aContent, nsGkAtoms::aria_relevant);
 6279: }
 6279: 
40575: already_AddRefed<nsAccessible>
43504: nsAccessibilityService::CreateAccessibleByType(nsIContent* aContent,
89799:                                                nsDocAccessible* aDoc)
    1: {
43504:   nsCOMPtr<nsIAccessibleProvider> accessibleProvider(do_QueryInterface(aContent));
 1477:   if (!accessibleProvider)
38359:     return nsnull;
    1: 
    1:   PRInt32 type;
 1477:   nsresult rv = accessibleProvider->GetAccessibleType(&type);
38359:   if (NS_FAILED(rv))
38359:     return nsnull;
    1: 
38359:   if (type == nsIAccessibleProvider::OuterDoc) {
89799:     nsAccessible* accessible = new nsOuterDocAccessible(aContent, aDoc);
46338:     NS_IF_ADDREF(accessible);
46338:     return accessible;
38359:   }
    1: 
46338:   nsAccessible* accessible = nsnull;
    1:   switch (type)
    1:   {
    1: #ifdef MOZ_XUL
10594:     case nsIAccessibleProvider::NoAccessible:
38359:       return nsnull;
38359: 
    1:     // XUL controls
    1:     case nsIAccessibleProvider::XULAlert:
89799:       accessible = new nsXULAlertAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULButton:
89799:       accessible = new nsXULButtonAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULCheckbox:
89799:       accessible = new nsXULCheckboxAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULColorPicker:
89799:       accessible = new nsXULColorPickerAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULColorPickerTile:
89799:       accessible = new nsXULColorPickerTileAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULCombobox:
89799:       accessible = new nsXULComboboxAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULDropmarker:
89799:       accessible = new nsXULDropmarkerAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULGroupbox:
89799:       accessible = new nsXULGroupboxAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULImage:
    1:     {
43504:       // Don't include nameless images in accessible tree.
43504:       if (!aContent->HasAttr(kNameSpaceID_None,
78350:                              nsGkAtoms::tooltiptext))
38359:         return nsnull;
    1: 
89799:       accessible = new nsHTMLImageAccessibleWrap(aContent, aDoc);
    1:       break;
46338: 
    1:     }
    1:     case nsIAccessibleProvider::XULLink:
89799:       accessible = new nsXULLinkAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULListbox:
89799:       accessible = new nsXULListboxAccessibleWrap(aContent, aDoc);
    1:       break;
46338: 
11854:     case nsIAccessibleProvider::XULListCell:
89799:       accessible = new nsXULListCellAccessibleWrap(aContent, aDoc);
11854:       break;
46338: 
 6094:     case nsIAccessibleProvider::XULListHead:
89799:       accessible = new nsXULColumnsAccessible(aContent, aDoc);
 6094:       break;
46338: 
 6094:     case nsIAccessibleProvider::XULListHeader:
89799:       accessible = new nsXULColumnItemAccessible(aContent, aDoc);
 6094:       break;
46338: 
    1:     case nsIAccessibleProvider::XULListitem:
89799:       accessible = new nsXULListitemAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULMenubar:
89799:       accessible = new nsXULMenubarAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULMenuitem:
89799:       accessible = new nsXULMenuitemAccessibleWrap(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULMenupopup:
    1:     {
    1: #ifdef MOZ_ACCESSIBILITY_ATK
    1:       // ATK considers this node to be redundant when within menubars, and it makes menu
    1:       // navigation with assistive technologies more difficult
    1:       // XXX In the future we will should this for consistency across the nsIAccessible
    1:       // implementations on each platform for a consistent scripting environment, but
    1:       // then strip out redundant accessibles in the nsAccessibleWrap class for each platform.
43504:       nsIContent *parent = aContent->GetParent();
78350:       if (parent && parent->NodeInfo()->Equals(nsGkAtoms::menu,
43504:                                                kNameSpaceID_XUL))
38359:         return nsnull;
    1: #endif
89799:       accessible = new nsXULMenupopupAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     }
    1:     case nsIAccessibleProvider::XULMenuSeparator:
89799:       accessible = new nsXULMenuSeparatorAccessible(aContent, aDoc);
    1:       break;
46338: 
10594:     case nsIAccessibleProvider::XULPane:
89799:       accessible = new nsEnumRoleAccessible(aContent, aDoc,
87094:                                             roles::PANE);
10594:       break;
46338: 
    1:     case nsIAccessibleProvider::XULProgressMeter:
89799:       accessible = new XULProgressMeterAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULStatusBar:
89799:       accessible = new nsXULStatusBarAccessible(aContent, aDoc);
    1:       break;
46338: 
 4274:     case nsIAccessibleProvider::XULScale:
89799:       accessible = new nsXULSliderAccessible(aContent, aDoc);
 4274:       break;
46338: 
    1:     case nsIAccessibleProvider::XULRadioButton:
89799:       accessible = new nsXULRadioButtonAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULRadioGroup:
89799:       accessible = new nsXULRadioGroupAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULTab:
89799:       accessible = new nsXULTabAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULTabs:
89799:       accessible = new nsXULTabsAccessible(aContent, aDoc);
    1:       break;
46338: 
42315:     case nsIAccessibleProvider::XULTabpanels:
89799:       accessible = new nsXULTabpanelsAccessible(aContent, aDoc);
42315:       break;
46338: 
    1:     case nsIAccessibleProvider::XULText:
89799:       accessible = new nsXULTextAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULTextBox:
89799:       accessible = new nsXULTextFieldAccessible(aContent, aDoc);
    1:       break;
46338: 
 4274:     case nsIAccessibleProvider::XULThumb:
89799:       accessible = new nsXULThumbAccessible(aContent, aDoc);
 4274:       break;
46338: 
    1:     case nsIAccessibleProvider::XULTree:
89799:       return CreateAccessibleForXULTree(aContent, aDoc);
38359: 
    1:     case nsIAccessibleProvider::XULTreeColumns:
89799:       accessible = new nsXULTreeColumnsAccessible(aContent, aDoc);
    1:       break;
46338: 
 6094:     case nsIAccessibleProvider::XULTreeColumnItem:
89799:       accessible = new nsXULColumnItemAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULToolbar:
89799:       accessible = new nsXULToolbarAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULToolbarSeparator:
89799:       accessible = new nsXULToolbarSeparatorAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XULTooltip:
89799:       accessible = new nsXULTooltipAccessible(aContent, aDoc);
    1:       break;
46338: 
 3325:     case nsIAccessibleProvider::XULToolbarButton:
89799:       accessible = new nsXULToolbarButtonAccessible(aContent, aDoc);
 3325:       break;
46338: 
    1: #endif // MOZ_XUL
    1: 
    1:     // XForms elements
    1:     case nsIAccessibleProvider::XFormsContainer:
89799:       accessible = new nsXFormsContainerAccessible(aContent, aDoc);
    1:       break;
    1: 
    1:     case nsIAccessibleProvider::XFormsLabel:
89799:       accessible = new nsXFormsLabelAccessible(aContent, aDoc);
    1:       break;
46338: 
42263:     case nsIAccessibleProvider::XFormsOutput:
89799:       accessible = new nsXFormsOutputAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsTrigger:
89799:       accessible = new nsXFormsTriggerAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsInput:
89799:       accessible = new nsXFormsInputAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsInputBoolean:
89799:       accessible = new nsXFormsInputBooleanAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsInputDate:
89799:       accessible = new nsXFormsInputDateAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsSecret:
89799:       accessible = new nsXFormsSecretAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsSliderRange:
89799:       accessible = new nsXFormsRangeAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsSelect:
89799:       accessible = new nsXFormsSelectAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsChoices:
89799:       accessible = new nsXFormsChoicesAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsSelectFull:
89799:       accessible = new nsXFormsSelectFullAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsItemCheckgroup:
89799:       accessible = new nsXFormsItemCheckgroupAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsItemRadiogroup:
89799:       accessible = new nsXFormsItemRadiogroupAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsSelectCombobox:
89799:       accessible = new nsXFormsSelectComboboxAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsItemCombobox:
89799:       accessible = new nsXFormsItemComboboxAccessible(aContent, aDoc);
    1:       break;
    1: 
    1:     case nsIAccessibleProvider::XFormsDropmarkerWidget:
89799:       accessible = new nsXFormsDropmarkerWidgetAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsCalendarWidget:
89799:       accessible = new nsXFormsCalendarWidgetAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     case nsIAccessibleProvider::XFormsComboboxPopupWidget:
89799:       accessible = new nsXFormsComboboxPopupWidgetAccessible(aContent, aDoc);
    1:       break;
46338: 
    1:     default:
38359:       return nsnull;
    1:   }
    1: 
46338:   NS_IF_ADDREF(accessible);
46338:   return accessible;
46338: }
46338: 
46338: already_AddRefed<nsAccessible>
46338: nsAccessibilityService::CreateHTMLAccessibleByMarkup(nsIFrame* aFrame,
46338:                                                      nsIContent* aContent,
89799:                                                      nsDocAccessible* aDoc)
46338: {
46338:   // This method assumes we're in an HTML namespace.
46338:   nsIAtom* tag = aContent->Tag();
83419:   if (tag == nsGkAtoms::figcaption) {
83419:     nsAccessible* accessible =
89799:       new nsHTMLFigcaptionAccessible(aContent, aDoc);
83419:     NS_IF_ADDREF(accessible);
83419:     return accessible;
83419:   }
83419: 
83419:   if (tag == nsGkAtoms::figure) {
89799:     nsAccessible* accessible = new nsHTMLFigureAccessible(aContent, aDoc);
83419:     NS_IF_ADDREF(accessible);
83419:     return accessible;
83419:   }
83419: 
78350:   if (tag == nsGkAtoms::legend) {
89799:     nsAccessible* accessible = new nsHTMLLegendAccessible(aContent, aDoc);
46338:     NS_IF_ADDREF(accessible);
46338:     return accessible;
46338:   }
46338: 
78350:   if (tag == nsGkAtoms::option) {
89799:     nsAccessible* accessible = new nsHTMLSelectOptionAccessible(aContent, aDoc);
46338:     NS_IF_ADDREF(accessible);
46338:     return accessible;
46338:   }
46338: 
78350:   if (tag == nsGkAtoms::optgroup) {
46338:     nsAccessible* accessible = new nsHTMLSelectOptGroupAccessible(aContent,
89799:                                                                   aDoc);
46338:     NS_IF_ADDREF(accessible);
46338:     return accessible;
46338:   }
46338: 
78350:   if (tag == nsGkAtoms::ul || tag == nsGkAtoms::ol ||
78350:       tag == nsGkAtoms::dl) {
89799:     nsAccessible* accessible = new nsHTMLListAccessible(aContent, aDoc);
46338:     NS_IF_ADDREF(accessible);
46338:     return accessible;
46338:   }
46338: 
78350:   if (tag == nsGkAtoms::a) {
46338:     // Only some roles truly enjoy life as nsHTMLLinkAccessibles, for details
46338:     // see closed bug 494807.
46338:     nsRoleMapEntry *roleMapEntry = nsAccUtils::GetRoleMapEntry(aContent);
87094:     if (roleMapEntry && roleMapEntry->role != roles::NOTHING &&
87094:         roleMapEntry->role != roles::LINK) {
89799:       nsAccessible* accessible = new nsHyperTextAccessibleWrap(aContent, aDoc);
46338:       NS_IF_ADDREF(accessible);
46338:       return accessible;
46338:     }
46338: 
89799:     nsAccessible* accessible = new nsHTMLLinkAccessible(aContent, aDoc);
46338:     NS_IF_ADDREF(accessible);
46338:     return accessible;
46338:   }
46338: 
78350:   if (tag == nsGkAtoms::dt ||
78350:       (tag == nsGkAtoms::li &&
78350:        aFrame->GetType() != nsGkAtoms::blockFrame)) {
46338:     // Normally for li, it is created by the list item frame (in nsBlockFrame)
46338:     // which knows about the bullet frame; however, in this case the list item
46338:     // must have been styled using display: foo
89799:     nsAccessible* accessible = new nsHTMLLIAccessible(aContent, aDoc);
46338:     NS_IF_ADDREF(accessible);
46338:     return accessible;
46338:   }
46338: 
78350:   if (tag == nsGkAtoms::abbr ||
78350:       tag == nsGkAtoms::acronym ||
78350:       tag == nsGkAtoms::blockquote ||
78350:       tag == nsGkAtoms::dd ||
78350:       tag == nsGkAtoms::form ||
78350:       tag == nsGkAtoms::h1 ||
78350:       tag == nsGkAtoms::h2 ||
78350:       tag == nsGkAtoms::h3 ||
78350:       tag == nsGkAtoms::h4 ||
78350:       tag == nsGkAtoms::h5 ||
78350:       tag == nsGkAtoms::h6 ||
78350:       tag == nsGkAtoms::q) {
89799:     nsAccessible* accessible = new nsHyperTextAccessibleWrap(aContent, aDoc);
46338:     NS_IF_ADDREF(accessible);
46338:     return accessible;
46338:   }
46338: 
78350:   if (tag == nsGkAtoms::tr) {
89799:     nsAccessible* accessible = new nsEnumRoleAccessible(aContent, aDoc,
87094:                                                         roles::ROW);
46338:     NS_IF_ADDREF(accessible);
46338:     return accessible;
46338:   }
46338: 
46338:   if (nsCoreUtils::IsHTMLTableHeader(aContent)) {
46338:     nsAccessible* accessible = new nsHTMLTableHeaderCellAccessibleWrap(aContent,
89799:                                                                        aDoc);
46338:     NS_IF_ADDREF(accessible);
46338:     return accessible;
46338:   }
46338: 
78350:   if (tag == nsGkAtoms::output) {
89799:     nsAccessible* accessible = new nsHTMLOutputAccessible(aContent, aDoc);
54466:     NS_IF_ADDREF(accessible);
54466:     return accessible;
54466:   }
54466: 
78350:   if (tag == nsGkAtoms::progress) {
69737:     nsAccessible* accessible =
89799:       new HTMLProgressMeterAccessible(aContent, aDoc);
69737:     NS_IF_ADDREF(accessible);
69737:     return accessible;
69737:   }
69737: 
46338:   return nsnull;
38359:  }
    1: 
38359: ////////////////////////////////////////////////////////////////////////////////
38359: // nsIAccessibilityService (DON'T put methods here)
    1: 
46207: nsAccessible*
46207: nsAccessibilityService::AddNativeRootAccessible(void* aAtkAccessible)
    1:  {
    1: #ifdef MOZ_ACCESSIBILITY_ATK
39600:   nsApplicationAccessible* applicationAcc =
 2063:     nsAccessNode::GetApplicationAccessible();
46207:   if (!applicationAcc)
46207:     return nsnull;
 2063: 
57413:   nsRefPtr<nsNativeRootAccessibleWrap> nativeRootAcc =
46207:      new nsNativeRootAccessibleWrap((AtkObject*)aAtkAccessible);
46207:   if (!nativeRootAcc)
46207:     return nsnull;
    1: 
46207:   if (applicationAcc->AppendChild(nativeRootAcc))
46207:     return nativeRootAcc;
    1: #endif
46207: 
46207:   return nsnull;
    1:  }
    1: 
46207: void
46207: nsAccessibilityService::RemoveNativeRootAccessible(nsAccessible* aAccessible)
    1: {
    1: #ifdef MOZ_ACCESSIBILITY_ATK
39600:   nsApplicationAccessible* applicationAcc =
 2063:     nsAccessNode::GetApplicationAccessible();
 2063: 
46207:   if (applicationAcc)
46207:     applicationAcc->RemoveChild(aAccessible);
    1: #endif
    1: }
    1: 
38359: ////////////////////////////////////////////////////////////////////////////////
38359: // NS_GetAccessibilityService
38359: ////////////////////////////////////////////////////////////////////////////////
    1: 
37808: /**
37808:  * Return accessibility service; creating one if necessary.
37808:  */
    1: nsresult
37808: NS_GetAccessibilityService(nsIAccessibilityService** aResult)
    1: {
30820:   NS_ENSURE_TRUE(aResult, NS_ERROR_NULL_POINTER);
30820:   *aResult = nsnull;
    1:  
43310:   if (nsAccessibilityService::gAccessibilityService) {
43310:     NS_ADDREF(*aResult = nsAccessibilityService::gAccessibilityService);
43310:     return NS_OK;
    1:   }
30820: 
43310:   nsRefPtr<nsAccessibilityService> service = new nsAccessibilityService();
43310:   NS_ENSURE_TRUE(service, NS_ERROR_OUT_OF_MEMORY);
43310: 
43310:   if (!service->Init()) {
43310:     service->Shutdown();
43310:     return NS_ERROR_FAILURE;
43310:   }
43310: 
76374:   statistics::A11yInitialized();
76374: 
43310:   nsAccessibilityService::gAccessibilityService = service;
43310:   NS_ADDREF(*aResult = service);
43310: 
30820:   return NS_OK;
    1: }
30820: 
38359: ////////////////////////////////////////////////////////////////////////////////
38359: // nsAccessibilityService private (DON'T put methods here)
38359: 
38359: already_AddRefed<nsAccessible>
38359: nsAccessibilityService::CreateAccessibleForDeckChild(nsIFrame* aFrame,
43504:                                                      nsIContent* aContent,
89799:                                                      nsDocAccessible* aDoc)
 1477: {
78350:   if (aFrame->GetType() == nsGkAtoms::boxFrame ||
78350:       aFrame->GetType() == nsGkAtoms::scrollFrame) {
 1477: 
38359:     nsIFrame* parentFrame = aFrame->GetParent();
78350:     if (parentFrame && parentFrame->GetType() == nsGkAtoms::deckFrame) {
 7840:       // If deck frame is for xul:tabpanels element then the given node has
 7840:       // tabpanel accessible.
 7840:       nsCOMPtr<nsIContent> parentContent = parentFrame->GetContent();
15855: #ifdef MOZ_XUL
78350:       if (parentContent->NodeInfo()->Equals(nsGkAtoms::tabpanels,
 7840:                                             kNameSpaceID_XUL)) {
89799:         nsAccessible* accessible = new nsXULTabpanelAccessible(aContent, aDoc);
46338:         NS_IF_ADDREF(accessible);
46338:         return accessible;
46338:       }
15855: #endif
89799:       nsAccessible* accessible = new nsEnumRoleAccessible(aContent, aDoc,
87094:                                                           roles::PROPERTYPAGE);
46338:       NS_IF_ADDREF(accessible);
46338:       return accessible;
 1477:     }
 1477:   }
 1477: 
46338:   return nsnull;
 1477: }
31673: 
31673: #ifdef MOZ_XUL
38359: already_AddRefed<nsAccessible>
43504: nsAccessibilityService::CreateAccessibleForXULTree(nsIContent* aContent,
89799:                                                    nsDocAccessible* aDoc)
31673: {
43504:   nsCOMPtr<nsITreeBoxObject> treeBoxObj = nsCoreUtils::GetTreeBoxObject(aContent);
31673:   if (!treeBoxObj)
38359:     return nsnull;
31673: 
31673:   nsCOMPtr<nsITreeColumns> treeColumns;
31673:   treeBoxObj->GetColumns(getter_AddRefs(treeColumns));
31673:   if (!treeColumns)
38359:     return nsnull;
38359: 
31673:   PRInt32 count = 0;
31673:   treeColumns->GetCount(&count);
31673: 
46338:   // Outline of list accessible.
46338:   if (count == 1) {
89799:     nsAccessible* accessible = new nsXULTreeAccessible(aContent, aDoc);
46338:     NS_IF_ADDREF(accessible);
46338:     return accessible;
46338:   }
46338: 
46338:   // Table or tree table accessible.
89799:   nsAccessible* accessible = new nsXULTreeGridAccessibleWrap(aContent, aDoc);
46338:   NS_IF_ADDREF(accessible);
46338:   return accessible;
31673: }
31673: #endif
79384: 
79384: ////////////////////////////////////////////////////////////////////////////////
79384: // Services
79384: ////////////////////////////////////////////////////////////////////////////////
79384: 
79384: mozilla::a11y::FocusManager*
79384: mozilla::a11y::FocusMgr()
79384: {
79384:   return nsAccessibilityService::gAccessibilityService;
79384: }
