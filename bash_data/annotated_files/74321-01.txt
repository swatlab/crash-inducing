23697: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
23697: /* ***** BEGIN LICENSE BLOCK *****
23697:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
23697:  *
23697:  * The contents of this file are subject to the Mozilla Public License Version
23697:  * 1.1 (the "License"); you may not use this file except in compliance with
23697:  * the License. You may obtain a copy of the License at
23697:  * http://www.mozilla.org/MPL/
23697:  *
23697:  * Software distributed under the License is distributed on an "AS IS" basis,
23697:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
23697:  * for the specific language governing rights and limitations under the
23697:  * License.
23697:  *
23697:  * The Original Code is the Mozilla SMIL module.
23697:  *
23697:  * The Initial Developer of the Original Code is Brian Birtles.
23697:  * Portions created by the Initial Developer are Copyright (C) 2006
23697:  * the Initial Developer. All Rights Reserved.
23697:  *
23697:  * Contributor(s):
23697:  *   Brian Birtles <birtles@gmail.com>
23697:  *
23697:  * Alternatively, the contents of this file may be used under the terms of
23697:  * either of the GNU General Public License Version 2 or later (the "GPL"),
23697:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
23697:  * in which case the provisions of the GPL or the LGPL are applicable instead
23697:  * of those above. If you wish to allow use of your version of this file only
23697:  * under the terms of either the GPL or the LGPL, and not to allow others to
23697:  * use your version of this file under the terms of the MPL, indicate your
23697:  * decision by deleting the provisions above and replace them with the notice
23697:  * and other provisions required by the GPL or the LGPL. If you do not delete
23697:  * the provisions above, a recipient may use your version of this file under
23697:  * the terms of any one of the MPL, the GPL or the LGPL.
23697:  *
23697:  * ***** END LICENSE BLOCK ***** */
23697: 
23697: #include "nsSMILTimedElement.h"
23697: #include "nsSMILAnimationFunction.h"
23697: #include "nsSMILTimeValue.h"
23697: #include "nsSMILTimeValueSpec.h"
23697: #include "nsSMILInstanceTime.h"
23697: #include "nsSMILParserUtils.h"
23697: #include "nsSMILTimeContainer.h"
23697: #include "nsGkAtoms.h"
48450: #include "nsGUIEvent.h"
48450: #include "nsEventDispatcher.h"
23697: #include "nsReadableUtils.h"
23697: #include "nsMathUtils.h"
48450: #include "nsThreadUtils.h"
48450: #include "nsIPresShell.h"
23697: #include "prdtoa.h"
23697: #include "plstr.h"
23697: #include "prtime.h"
23697: #include "nsString.h"
73905: #include "mozilla/AutoRestore.h"
74319: #include "mozilla/Util.h"
73905: 
73905: using namespace mozilla;
23697: 
23697: //----------------------------------------------------------------------
48450: // Helper class: InstanceTimeComparator
37115: 
37115: // Upon inserting an instance time into one of our instance time lists we assign
37115: // it a serial number. This allows us to sort the instance times in such a way
37115: // that where we have several equal instance times, the ones added later will
37115: // sort later. This means that when we call UpdateCurrentInterval during the
37115: // waiting state we won't unnecessarily change the begin instance.
37115: //
37115: // The serial number also means that every instance time has an unambiguous
37115: // position in the array so we can use RemoveElementSorted and the like.
37115: PRBool
37115: nsSMILTimedElement::InstanceTimeComparator::Equals(
37115:     const nsSMILInstanceTime* aElem1,
37115:     const nsSMILInstanceTime* aElem2) const
37115: {
37115:   NS_ABORT_IF_FALSE(aElem1 && aElem2,
37115:       "Trying to compare null instance time pointers");
37115:   NS_ABORT_IF_FALSE(aElem1->Serial() && aElem2->Serial(),
37115:       "Instance times have not been assigned serial numbers");
37115:   NS_ABORT_IF_FALSE(aElem1 == aElem2 || aElem1->Serial() != aElem2->Serial(),
37115:       "Serial numbers are not unique");
37115: 
37115:   return aElem1->Serial() == aElem2->Serial();
37115: }
37115: 
37115: PRBool
37115: nsSMILTimedElement::InstanceTimeComparator::LessThan(
37115:     const nsSMILInstanceTime* aElem1,
37115:     const nsSMILInstanceTime* aElem2) const
37115: {
37115:   NS_ABORT_IF_FALSE(aElem1 && aElem2,
37115:       "Trying to compare null instance time pointers");
37115:   NS_ABORT_IF_FALSE(aElem1->Serial() && aElem2->Serial(),
37115:       "Instance times have not been assigned serial numbers");
37115: 
37115:   PRInt8 cmp = aElem1->Time().CompareTo(aElem2->Time());
37115:   return cmp == 0 ? aElem1->Serial() < aElem2->Serial() : cmp < 0;
37115: }
37115: 
37115: //----------------------------------------------------------------------
48450: // Helper class: AsyncTimeEventRunner
48450: 
48450: namespace
48450: {
48450:   class AsyncTimeEventRunner : public nsRunnable
48450:   {
48450:   protected:
48450:     nsRefPtr<nsIContent> mTarget;
48450:     PRUint32             mMsg;
48450:     PRInt32              mDetail;
48450: 
48450:   public:
48450:     AsyncTimeEventRunner(nsIContent* aTarget, PRUint32 aMsg, PRInt32 aDetail)
48450:       : mTarget(aTarget), mMsg(aMsg), mDetail(aDetail)
48450:     {
48450:     }
48450: 
48450:     NS_IMETHOD Run()
48450:     {
48450:       nsUIEvent event(PR_TRUE, mMsg, mDetail);
48450:       event.eventStructType = NS_SMIL_TIME_EVENT;
48450: 
48450:       nsPresContext* context = nsnull;
48450:       nsIDocument* doc = mTarget->GetCurrentDoc();
48450:       if (doc) {
48450:         nsCOMPtr<nsIPresShell> shell = doc->GetShell();
48450:         if (shell) {
48450:           context = shell->GetPresContext();
48450:         }
48450:       }
48450: 
48450:       return nsEventDispatcher::Dispatch(mTarget, context, &event);
48450:     }
48450:   };
48450: }
48450: 
48450: //----------------------------------------------------------------------
72933: // Helper class: AutoIntervalUpdateBatcher
72933: 
72933: // RAII helper to set the mDeferIntervalUpdates flag on an nsSMILTimedElement
72933: // and perform the UpdateCurrentInterval when the object is destroyed.
72933: //
72933: // If several of these objects are allocated on the stack, the update will not
72933: // be performed until the last object for a given nsSMILTimedElement is
72933: // destroyed.
72933: NS_STACK_CLASS class nsSMILTimedElement::AutoIntervalUpdateBatcher
72933: {
72933: public:
72933:   AutoIntervalUpdateBatcher(nsSMILTimedElement& aTimedElement)
72933:     : mTimedElement(aTimedElement),
72933:       mDidSetFlag(!aTimedElement.mDeferIntervalUpdates)
72933:   {
72933:     mTimedElement.mDeferIntervalUpdates = PR_TRUE;
72933:   }
72933: 
72933:   ~AutoIntervalUpdateBatcher()
72933:   {
72933:     if (!mDidSetFlag)
72933:       return;
72933: 
72933:     mTimedElement.mDeferIntervalUpdates = PR_FALSE;
72933: 
72933:     if (mTimedElement.mDoDeferredUpdate) {
72933:       mTimedElement.mDoDeferredUpdate = PR_FALSE;
72933:       mTimedElement.UpdateCurrentInterval();
72933:     }
72933:   }
72933: 
72933: private:
72933:   nsSMILTimedElement& mTimedElement;
72933:   PRPackedBool mDidSetFlag;
72933: };
72933: 
72933: //----------------------------------------------------------------------
47196: // Templated helper functions
47196: 
47196: // Selectively remove elements from an array of type
47196: // nsTArray<nsRefPtr<nsSMILInstanceTime> > with O(n) performance.
47196: template <class TestFunctor>
47196: void
47196: nsSMILTimedElement::RemoveInstanceTimes(InstanceTimeList& aArray,
47196:                                         TestFunctor& aTest)
47196: {
47196:   InstanceTimeList newArray;
47196:   for (PRUint32 i = 0; i < aArray.Length(); ++i) {
47196:     nsSMILInstanceTime* item = aArray[i].get();
47196:     if (aTest(item, i)) {
74320:       // As per bugs 665334 and 669225 we should be careful not to remove the
74320:       // instance time that corresponds to the previous interval's end time.
74320:       //
74320:       // Most functors supplied here fulfil this condition by checking if the
74320:       // instance time is marked as "ShouldPreserve" and if so, not deleting it.
74320:       //
74320:       // However, when filtering instance times, we sometimes need to drop even
74320:       // instance times marked as "ShouldPreserve". In that case we take special
74320:       // care not to delete the end instance time of the previous interval.
74320:       NS_ABORT_IF_FALSE(!GetPreviousInterval() ||
74320:         item != GetPreviousInterval()->End(),
74320:         "Removing end instance time of previous interval");
47196:       item->Unlink();
47196:     } else {
47196:       newArray.AppendElement(item);
47196:     }
47196:   }
47196:   aArray.Clear();
47196:   aArray.SwapElements(newArray);
47196: }
47196: 
47196: //----------------------------------------------------------------------
23697: // Static members
23697: 
23697: nsAttrValue::EnumTable nsSMILTimedElement::sFillModeTable[] = {
23697:       {"remove", FILL_REMOVE},
23697:       {"freeze", FILL_FREEZE},
23697:       {nsnull, 0}
23697: };
23697: 
23697: nsAttrValue::EnumTable nsSMILTimedElement::sRestartModeTable[] = {
23697:       {"always", RESTART_ALWAYS},
23697:       {"whenNotActive", RESTART_WHENNOTACTIVE},
23697:       {"never", RESTART_NEVER},
23697:       {nsnull, 0}
23697: };
23697: 
37113: const nsSMILMilestone nsSMILTimedElement::sMaxMilestone(LL_MAXINT, PR_FALSE);
37113: 
47196: // The thresholds at which point we start filtering intervals and instance times
47196: // indiscriminately.
47196: // See FilterIntervals and FilterInstanceTimes.
47196: const PRUint8 nsSMILTimedElement::sMaxNumIntervals = 20;
47196: const PRUint8 nsSMILTimedElement::sMaxNumInstanceTimes = 100;
47196: 
72935: // Detect if we arrive in some sort of undetected recursive syncbase dependency
72935: // relationship
72935: const PRUint16 nsSMILTimedElement::sMaxUpdateIntervalRecursionDepth = 20;
72935: 
23697: //----------------------------------------------------------------------
23697: // Ctor, dtor
23697: 
23697: nsSMILTimedElement::nsSMILTimedElement()
23697: :
37113:   mAnimationElement(nsnull),
23697:   mFillMode(FILL_REMOVE),
23697:   mRestartMode(RESTART_ALWAYS),
37115:   mInstanceSerialIndex(0),
23697:   mClient(nsnull),
38818:   mCurrentInterval(nsnull),
48450:   mCurrentRepeatIteration(0),
37113:   mPrevRegisteredMilestone(sMaxMilestone),
47197:   mElementState(STATE_STARTUP),
72933:   mSeekState(SEEK_NOT_SEEKING),
72933:   mDeferIntervalUpdates(PR_FALSE),
72935:   mDoDeferredUpdate(PR_FALSE),
72935:   mUpdateIntervalRecursionDepth(0)
23697: {
23697:   mSimpleDur.SetIndefinite();
23697:   mMin.SetMillis(0L);
23697:   mMax.SetIndefinite();
37116:   mTimeDependents.Init();
23697: }
23697: 
38818: nsSMILTimedElement::~nsSMILTimedElement()
38818: {
38818:   // Unlink all instance times from dependent intervals
38818:   for (PRUint32 i = 0; i < mBeginInstances.Length(); ++i) {
38818:     mBeginInstances[i]->Unlink();
38818:   }
38818:   mBeginInstances.Clear();
38818:   for (PRUint32 i = 0; i < mEndInstances.Length(); ++i) {
38818:     mEndInstances[i]->Unlink();
38818:   }
38818:   mEndInstances.Clear();
38818: 
38818:   // Notify anyone listening to our intervals that they're gone
38818:   // (We shouldn't get any callbacks from this because all our instance times
38818:   // are now disassociated with any intervals)
55397:   mElementState = STATE_POSTACTIVE;
55397:   ResetCurrentInterval();
38818: 
38818:   for (PRInt32 i = mOldIntervals.Length() - 1; i >= 0; --i) {
47196:     mOldIntervals[i]->Unlink();
38818:   }
38818:   mOldIntervals.Clear();
72933: 
72933:   // The following assertions are important in their own right (for checking
72933:   // correct behavior) but also because AutoIntervalUpdateBatcher holds pointers
72933:   // to class so if they fail there's the possibility we might have dangling
72933:   // pointers.
72933:   NS_ABORT_IF_FALSE(!mDeferIntervalUpdates,
72933:       "Interval updates should no longer be blocked when an nsSMILTimedElement "
72933:       "disappears");
72933:   NS_ABORT_IF_FALSE(!mDoDeferredUpdate,
72933:       "There should no longer be any pending updates when an "
72933:       "nsSMILTimedElement disappears");
38818: }
38818: 
37113: void
37113: nsSMILTimedElement::SetAnimationElement(nsISMILAnimationElement* aElement)
37113: {
37113:   NS_ABORT_IF_FALSE(aElement, "NULL owner element");
37113:   NS_ABORT_IF_FALSE(!mAnimationElement, "Re-setting owner");
37113:   mAnimationElement = aElement;
37113: }
37113: 
37113: nsSMILTimeContainer*
37113: nsSMILTimedElement::GetTimeContainer()
37113: {
37113:   return mAnimationElement ? mAnimationElement->GetTimeContainer() : nsnull;
37113: }
37113: 
23697: //----------------------------------------------------------------------
23697: // nsIDOMElementTimeControl methods
23697: //
23697: // The definition of the ElementTimeControl interface differs between SMIL
23697: // Animation and SVG 1.1. In SMIL Animation all methods have a void return
23697: // type and the new instance time is simply added to the list and restart
23697: // semantics are applied as with any other instance time. In the SVG definition
23930: // the methods return a bool depending on the restart mode.
23697: //
23930: // This inconsistency has now been addressed by an erratum in SVG 1.1:
23697: //
23930: // http://www.w3.org/2003/01/REC-SVG11-20030114-errata#elementtimecontrol-interface
23697: //
23930: // which favours the definition in SMIL, i.e. instance times are just added
23930: // without first checking the restart mode.
23697: 
23930: nsresult
37113: nsSMILTimedElement::BeginElementAt(double aOffsetSeconds)
23697: {
37113:   nsSMILTimeContainer* container = GetTimeContainer();
37113:   if (!container)
23930:     return NS_ERROR_FAILURE;
24029: 
37113:   nsSMILTime currentTime = container->GetCurrentTime();
24029:   AddInstanceTimeFromCurrentTime(currentTime, aOffsetSeconds, PR_TRUE);
24029: 
23930:   return NS_OK;
23697: }
23697: 
23930: nsresult
37113: nsSMILTimedElement::EndElementAt(double aOffsetSeconds)
23697: {
37113:   nsSMILTimeContainer* container = GetTimeContainer();
37113:   if (!container)
23930:     return NS_ERROR_FAILURE;
24029: 
37113:   nsSMILTime currentTime = container->GetCurrentTime();
24029:   AddInstanceTimeFromCurrentTime(currentTime, aOffsetSeconds, PR_FALSE);
23697: 
23930:   return NS_OK;
23697: }
23697: 
23697: //----------------------------------------------------------------------
23929: // nsSVGAnimationElement methods
23929: 
23929: nsSMILTimeValue
23929: nsSMILTimedElement::GetStartTime() const
23929: {
33782:   return mElementState == STATE_WAITING || mElementState == STATE_ACTIVE
38818:          ? mCurrentInterval->Begin()->Time()
33782:          : nsSMILTimeValue();
23929: }
23929: 
23929: //----------------------------------------------------------------------
23697: // nsSMILTimedElement
23697: 
23697: void
37115: nsSMILTimedElement::AddInstanceTime(nsSMILInstanceTime* aInstanceTime,
23697:                                     PRBool aIsBegin)
23697: {
37115:   NS_ABORT_IF_FALSE(aInstanceTime, "Attempting to add null instance time");
37115: 
50802:   // Event-sensitivity: If an element is not active (but the parent time
50802:   // container is), then events are only handled for begin specifications.
50802:   if (mElementState != STATE_ACTIVE && !aIsBegin &&
50802:       aInstanceTime->IsDynamic())
50802:   {
50802:     // No need to call Unlink here--dynamic instance times shouldn't be linked
50802:     // to anything that's going to miss them
50802:     NS_ABORT_IF_FALSE(!aInstanceTime->GetBaseInterval(),
50802:         "Dynamic instance time has a base interval--we probably need to unlink"
50802:         " it if we're not going to use it");
50802:     return;
50802:   }
50802: 
37115:   aInstanceTime->SetSerial(++mInstanceSerialIndex);
37115:   InstanceTimeList& instanceList = aIsBegin ? mBeginInstances : mEndInstances;
37115:   nsRefPtr<nsSMILInstanceTime>* inserted =
37115:     instanceList.InsertElementSorted(aInstanceTime, InstanceTimeComparator());
37115:   if (!inserted) {
37115:     NS_WARNING("Insufficient memory to insert instance time");
37115:     return;
23930:   }
23697: 
23697:   UpdateCurrentInterval();
23697: }
23697: 
23697: void
37115: nsSMILTimedElement::UpdateInstanceTime(nsSMILInstanceTime* aInstanceTime,
37115:                                        nsSMILTimeValue& aUpdatedTime,
37115:                                        PRBool aIsBegin)
37115: {
37115:   NS_ABORT_IF_FALSE(aInstanceTime, "Attempting to update null instance time");
37115: 
37115:   // The reason we update the time here and not in the nsSMILTimeValueSpec is
37115:   // that it means we *could* re-sort more efficiently by doing a sorted remove
37115:   // and insert but currently this doesn't seem to be necessary given how
37115:   // infrequently we get these change notices.
37115:   aInstanceTime->DependentUpdate(aUpdatedTime);
37115:   InstanceTimeList& instanceList = aIsBegin ? mBeginInstances : mEndInstances;
37115:   instanceList.Sort(InstanceTimeComparator());
37115: 
37115:   // Generally speaking, UpdateCurrentInterval makes changes to the current
37115:   // interval and sends changes notices itself. However, in this case because
37115:   // instance times are shared between the instance time list and the intervals
37115:   // we are effectively changing the current interval outside
37115:   // UpdateCurrentInterval so we need to explicitly signal that we've made
37115:   // a change.
37115:   //
37115:   // This wouldn't be necessary if we cloned instance times on adding them to
37115:   // the current interval but this introduces other complications (particularly
37115:   // detecting which instance time is being used to define the begin of the
37115:   // current interval when doing a Reset).
38818:   PRBool changedCurrentInterval = mCurrentInterval &&
38818:     (mCurrentInterval->Begin() == aInstanceTime ||
38818:      mCurrentInterval->End() == aInstanceTime);
37115: 
37115:   UpdateCurrentInterval(changedCurrentInterval);
37115: }
37115: 
37115: void
37115: nsSMILTimedElement::RemoveInstanceTime(nsSMILInstanceTime* aInstanceTime,
37115:                                        PRBool aIsBegin)
37115: {
37115:   NS_ABORT_IF_FALSE(aInstanceTime, "Attempting to remove null instance time");
37115: 
74319:   // If the instance time should be kept (because it is or was the fixed end
74319:   // point of an interval) then just disassociate it from the creator.
74319:   if (aInstanceTime->ShouldPreserve()) {
74319:     aInstanceTime->Unlink();
74319:     return;
74319:   }
74319: 
37115:   InstanceTimeList& instanceList = aIsBegin ? mBeginInstances : mEndInstances;
74319:   mozilla::DebugOnly<PRBool> found =
37115:     instanceList.RemoveElementSorted(aInstanceTime, InstanceTimeComparator());
37115:   NS_ABORT_IF_FALSE(found, "Couldn't find instance time to delete");
37115: 
37115:   UpdateCurrentInterval();
37115: }
37115: 
47196: namespace
47196: {
47196:   class RemoveByCreator
47196:   {
47196:   public:
47196:     RemoveByCreator(const nsSMILTimeValueSpec* aCreator) : mCreator(aCreator)
47196:     { }
47196: 
47196:     PRBool operator()(nsSMILInstanceTime* aInstanceTime, PRUint32 /*aIndex*/)
47196:     {
72936:       if (aInstanceTime->GetCreator() != mCreator)
72936:         return PR_FALSE;
72936: 
72936:       // If the instance time should be kept (because it is or was the fixed end
72936:       // point of an interval) then just disassociate it from the creator.
72936:       if (aInstanceTime->ShouldPreserve()) {
72936:         aInstanceTime->Unlink();
72936:         return PR_FALSE;
72936:       }
72936: 
72936:       return PR_TRUE;
47196:     }
47196: 
47196:   private:
47196:     const nsSMILTimeValueSpec* mCreator;
47196:   };
47196: }
47196: 
37115: void
38818: nsSMILTimedElement::RemoveInstanceTimesForCreator(
38818:     const nsSMILTimeValueSpec* aCreator, PRBool aIsBegin)
38818: {
38818:   NS_ABORT_IF_FALSE(aCreator, "Creator not set");
47196: 
38818:   InstanceTimeList& instances = aIsBegin ? mBeginInstances : mEndInstances;
47196:   RemoveByCreator removeByCreator(aCreator);
47196:   RemoveInstanceTimes(instances, removeByCreator);
38818: 
38818:   UpdateCurrentInterval();
38818: }
38818: 
38818: void
23697: nsSMILTimedElement::SetTimeClient(nsSMILAnimationFunction* aClient)
23697: {
23697:   //
23697:   // No need to check for NULL. A NULL parameter simply means to remove the
23697:   // previous client which we do by setting to NULL anyway.
23697:   //
23697: 
23697:   mClient = aClient;
23697: }
23697: 
23697: void
37113: nsSMILTimedElement::SampleAt(nsSMILTime aContainerTime)
23697: {
37113:   // Milestones are cleared before a sample
37113:   mPrevRegisteredMilestone = sMaxMilestone;
37113: 
37113:   DoSampleAt(aContainerTime, PR_FALSE);
37113: }
37113: 
37113: void
37113: nsSMILTimedElement::SampleEndAt(nsSMILTime aContainerTime)
37113: {
37113:   // Milestones are cleared before a sample
37113:   mPrevRegisteredMilestone = sMaxMilestone;
37113: 
37113:   // If the current interval changes, we don't bother trying to remove any old
37113:   // milestones we'd registered. So it's possible to get a call here to end an
37113:   // interval at a time that no longer reflects the end of the current interval.
37113:   //
37113:   // For now we just check that we're actually in an interval but note that the
37113:   // initial sample we use to initialise the model is an end sample. This is
37113:   // because we want to resolve all the instance times before committing to an
37113:   // initial interval. Therefore an end sample from the startup state is also
37113:   // acceptable.
37113:   if (mElementState == STATE_ACTIVE || mElementState == STATE_STARTUP) {
37113:     DoSampleAt(aContainerTime, PR_TRUE); // End sample
37113:   } else {
37113:     // Even if this was an unnecessary milestone sample we want to be sure that
37113:     // our next real milestone is registered.
37113:     RegisterMilestone();
37113:   }
37113: }
37113: 
37113: void
37113: nsSMILTimedElement::DoSampleAt(nsSMILTime aContainerTime, PRBool aEndOnly)
37113: {
37113:   NS_ABORT_IF_FALSE(mAnimationElement,
37113:       "Got sample before being registered with an animation element");
37113:   NS_ABORT_IF_FALSE(GetTimeContainer(),
37113:       "Got sample without being registered with a time container");
37113: 
37113:   // This could probably happen if we later implement externalResourcesRequired
37113:   // (bug 277955) and whilst waiting for those resources (and the animation to
37113:   // start) we transfer a node from another document fragment that has already
37113:   // started. In such a case we might receive milestone samples registered with
37113:   // the already active container.
37113:   if (GetTimeContainer()->IsPausedByType(nsSMILTimeContainer::PAUSE_BEGIN))
37113:     return;
37113: 
59173:   // We use an end-sample to start animation since an end-sample lets us
59173:   // tentatively create an interval without committing to it (by transitioning
59173:   // to the ACTIVE state) and this is necessary because we might have
59173:   // dependencies on other animations that are yet to start. After these
59173:   // other animations start, it may be necessary to revise our initial interval.
59173:   //
59173:   // However, sometimes instead of an end-sample we can get a regular sample
59173:   // during STARTUP state. This can happen, for example, if we register
59173:   // a milestone before time t=0 and are then re-bound to the tree (which sends
59173:   // us back to the STARTUP state). In such a case we should just ignore the
59173:   // sample and wait for our real initial sample which will be an end-sample.
59173:   if (mElementState == STATE_STARTUP && !aEndOnly)
59173:     return;
37113: 
47197:   PRBool finishedSeek = PR_FALSE;
47197:   if (GetTimeContainer()->IsSeeking() && mSeekState == SEEK_NOT_SEEKING) {
47197:     mSeekState = mElementState == STATE_ACTIVE ?
47197:                  SEEK_FORWARD_FROM_ACTIVE :
47197:                  SEEK_FORWARD_FROM_INACTIVE;
47197:   } else if (mSeekState != SEEK_NOT_SEEKING &&
47197:              !GetTimeContainer()->IsSeeking()) {
47197:     finishedSeek = PR_TRUE;
47197:   }
47197: 
23697:   PRBool          stateChanged;
37113:   nsSMILTimeValue sampleTime(aContainerTime);
23697: 
23697:   do {
38819: #ifdef DEBUG
38819:     // Check invariant
38819:     if (mElementState == STATE_STARTUP || mElementState == STATE_POSTACTIVE) {
38819:       NS_ABORT_IF_FALSE(!mCurrentInterval,
38819:           "Shouldn't have current interval in startup or postactive states");
38819:     } else {
38819:       NS_ABORT_IF_FALSE(mCurrentInterval,
38819:           "Should have current interval in waiting and active states");
38819:     }
38819: #endif
38819: 
23697:     stateChanged = PR_FALSE;
23697: 
23697:     switch (mElementState)
23697:     {
23697:     case STATE_STARTUP:
23697:       {
38818:         nsSMILInterval firstInterval;
72214:         mElementState = GetNextInterval(nsnull, nsnull, nsnull, firstInterval)
23697:          ? STATE_WAITING
23697:          : STATE_POSTACTIVE;
23697:         stateChanged = PR_TRUE;
37115:         if (mElementState == STATE_WAITING) {
38818:           mCurrentInterval = new nsSMILInterval(firstInterval);
37115:           NotifyNewInterval();
37115:         }
23697:       }
23697:       break;
23697: 
23697:     case STATE_WAITING:
23697:       {
38818:         if (mCurrentInterval->Begin()->Time() <= sampleTime) {
23697:           mElementState = STATE_ACTIVE;
47196:           mCurrentInterval->FixBegin();
23697:           if (mClient) {
38818:             mClient->Activate(mCurrentInterval->Begin()->Time().GetMillis());
23697:           }
48450:           if (mSeekState == SEEK_NOT_SEEKING) {
48450:             FireTimeEventAsync(NS_SMIL_BEGIN, 0);
48450:           }
38818:           if (HasPlayed()) {
48450:             Reset(); // Apply restart behaviour
37134:             // The call to Reset() may mean that the end point of our current
37134:             // interval should be changed and so we should update the interval
37134:             // now. However, calling UpdateCurrentInterval could result in the
37134:             // interval getting deleted (perhaps through some web of syncbase
37134:             // dependencies) therefore we make updating the interval the last
48450:             // thing we do. There is no guarantee that mCurrentInterval is set
48450:             // after this.
37134:             UpdateCurrentInterval();
37134:           }
23697:           stateChanged = PR_TRUE;
23697:         }
23697:       }
23697:       break;
23697: 
23697:     case STATE_ACTIVE:
23697:       {
71823:         // Ending early will change the interval but we don't notify dependents
71823:         // of the change until we have closed off the current interval (since we
71823:         // don't want dependencies to un-end our early end).
71823:         PRBool didApplyEarlyEnd = ApplyEarlyEnd(sampleTime);
37113: 
38818:         if (mCurrentInterval->End()->Time() <= sampleTime) {
23697:           nsSMILInterval newInterval;
72214:           mElementState =
72214:             GetNextInterval(mCurrentInterval, nsnull, nsnull, newInterval)
23697:             ? STATE_WAITING
23697:             : STATE_POSTACTIVE;
23697:           if (mClient) {
23697:             mClient->Inactivate(mFillMode == FILL_FREEZE);
23697:           }
47196:           mCurrentInterval->FixEnd();
48450:           if (mSeekState == SEEK_NOT_SEEKING) {
48450:             FireTimeEventAsync(NS_SMIL_END, 0);
48450:           }
48450:           mCurrentRepeatIteration = 0;
38818:           mOldIntervals.AppendElement(mCurrentInterval.forget());
23697:           SampleFillValue();
37115:           if (mElementState == STATE_WAITING) {
38818:             mCurrentInterval = new nsSMILInterval(newInterval);
71823:           }
71823:           // We are now in a consistent state to dispatch notifications
71823:           if (didApplyEarlyEnd) {
71823:             NotifyChangedInterval(
71823:                 mOldIntervals[mOldIntervals.Length() - 1], PR_FALSE, PR_TRUE);
71823:           }
71823:           if (mElementState == STATE_WAITING) {
37115:             NotifyNewInterval();
37115:           }
47196:           FilterHistory();
23697:           stateChanged = PR_TRUE;
23697:         } else {
71823:           NS_ABORT_IF_FALSE(!didApplyEarlyEnd,
71823:               "We got an early end, but didn't end");
38818:           nsSMILTime beginTime = mCurrentInterval->Begin()->Time().GetMillis();
47197:           NS_ASSERTION(aContainerTime >= beginTime,
47197:                        "Sample time should not precede current interval");
37113:           nsSMILTime activeTime = aContainerTime - beginTime;
23697:           SampleSimpleTime(activeTime);
48450:           // We register our repeat times as milestones (except when we're
48450:           // seeking) so we should get a sample at exactly the time we repeat.
48450:           // (And even when we are seeking we want to update
48450:           // mCurrentRepeatIteration so we do that first before testing the seek
48450:           // state.)
48450:           PRUint32 prevRepeatIteration = mCurrentRepeatIteration;
48450:           if (ActiveTimeToSimpleTime(activeTime, mCurrentRepeatIteration)==0 &&
48450:               mCurrentRepeatIteration != prevRepeatIteration &&
48450:               mCurrentRepeatIteration &&
48450:               mSeekState == SEEK_NOT_SEEKING) {
48450:             FireTimeEventAsync(NS_SMIL_REPEAT,
48450:                           static_cast<PRInt32>(mCurrentRepeatIteration));
48450:           }
23697:         }
23697:       }
23697:       break;
23697: 
23697:     case STATE_POSTACTIVE:
23697:       break;
23697:     }
37113: 
37113:   // Generally we continue driving the state machine so long as we have changed
37113:   // state. However, for end samples we only drive the state machine as far as
37113:   // the waiting or postactive state because we don't want to commit to any new
37113:   // interval (by transitioning to the active state) until all the end samples
37113:   // have finished and we then have complete information about the available
37113:   // instance times upon which to base our next interval.
37113:   } while (stateChanged && (!aEndOnly || (mElementState != STATE_WAITING &&
37113:                                           mElementState != STATE_POSTACTIVE)));
37113: 
47197:   if (finishedSeek) {
47197:     DoPostSeek();
47197:   }
37113:   RegisterMilestone();
23697: }
23697: 
23697: void
37115: nsSMILTimedElement::HandleContainerTimeChange()
37115: {
37115:   // In future we could possibly introduce a separate change notice for time
37115:   // container changes and only notify those dependents who live in other time
37115:   // containers. For now we don't bother because when we re-resolve the time in
37115:   // the nsSMILTimeValueSpec we'll check if anything has changed and if not, we
37115:   // won't go any further.
37115:   if (mElementState == STATE_WAITING || mElementState == STATE_ACTIVE) {
71823:     NotifyChangedInterval(mCurrentInterval, PR_FALSE, PR_FALSE);
37115:   }
37115: }
37115: 
50803: namespace
50803: {
50803:   PRBool
50803:   RemoveNonDynamic(nsSMILInstanceTime* aInstanceTime)
50803:   {
50803:     // Generally dynamically-generated instance times (DOM calls, event-based
50803:     // times) are not associated with their creator nsSMILTimeValueSpec since
50803:     // they may outlive them.
50803:     NS_ABORT_IF_FALSE(!aInstanceTime->IsDynamic() ||
50803:          !aInstanceTime->GetCreator(),
50803:         "Dynamic instance time should be unlinked from its creator");
50803:     return !aInstanceTime->IsDynamic();
50803:   }
50803: }
50803: 
47197: void
47197: nsSMILTimedElement::Rewind()
47197: {
47197:   NS_ABORT_IF_FALSE(mAnimationElement,
47197:       "Got rewind request before being attached to an animation element");
47197: 
55395:   // It's possible to get a rewind request whilst we're already in the middle of
55395:   // a backwards seek. This can happen when we're performing tree surgery and
55395:   // seeking containers at the same time because we can end up requesting
55395:   // a local rewind on an element after binding it to a new container and then
55395:   // performing a rewind on that container as a whole without sampling in
55395:   // between.
55395:   //
55395:   // However, it should currently be impossible to get a rewind in the middle of
55395:   // a forwards seek since forwards seeks are detected and processed within the
55395:   // same (re)sample.
55395:   if (mSeekState == SEEK_NOT_SEEKING) {
47197:     mSeekState = mElementState == STATE_ACTIVE ?
47197:                  SEEK_BACKWARD_FROM_ACTIVE :
47197:                  SEEK_BACKWARD_FROM_INACTIVE;
55395:   }
55395:   NS_ABORT_IF_FALSE(mSeekState == SEEK_BACKWARD_FROM_INACTIVE ||
55395:                     mSeekState == SEEK_BACKWARD_FROM_ACTIVE,
55395:                     "Rewind in the middle of a forwards seek?");
47197: 
55397:   ClearIntervalProgress();
47197: 
50803:   UnsetBeginSpec(RemoveNonDynamic);
50803:   UnsetEndSpec(RemoveNonDynamic);
47197: 
47197:   if (mClient) {
47197:     mClient->Inactivate(PR_FALSE);
47197:   }
47197: 
47197:   if (mAnimationElement->HasAnimAttr(nsGkAtoms::begin)) {
47197:     nsAutoString attValue;
47197:     mAnimationElement->GetAnimAttr(nsGkAtoms::begin, attValue);
50805:     SetBeginSpec(attValue, &mAnimationElement->AsElement(), RemoveNonDynamic);
47197:   }
47197: 
47197:   if (mAnimationElement->HasAnimAttr(nsGkAtoms::end)) {
47197:     nsAutoString attValue;
47197:     mAnimationElement->GetAnimAttr(nsGkAtoms::end, attValue);
50805:     SetEndSpec(attValue, &mAnimationElement->AsElement(), RemoveNonDynamic);
47197:   }
47197: 
47197:   mPrevRegisteredMilestone = sMaxMilestone;
47197:   RegisterMilestone();
47197: }
47197: 
50803: namespace
50803: {
50803:   PRBool
50803:   RemoveNonDOM(nsSMILInstanceTime* aInstanceTime)
50803:   {
50803:     return !aInstanceTime->FromDOM();
50803:   }
50803: }
50803: 
23697: PRBool
23697: nsSMILTimedElement::SetAttr(nsIAtom* aAttribute, const nsAString& aValue,
50805:                             nsAttrValue& aResult,
50805:                             Element* aContextNode,
37115:                             nsresult* aParseResult)
23697: {
23697:   PRBool foundMatch = PR_TRUE;
23697:   nsresult parseResult = NS_OK;
23697: 
23697:   if (aAttribute == nsGkAtoms::begin) {
50803:     parseResult = SetBeginSpec(aValue, aContextNode, RemoveNonDOM);
23697:   } else if (aAttribute == nsGkAtoms::dur) {
23697:     parseResult = SetSimpleDuration(aValue);
23697:   } else if (aAttribute == nsGkAtoms::end) {
50803:     parseResult = SetEndSpec(aValue, aContextNode, RemoveNonDOM);
23697:   } else if (aAttribute == nsGkAtoms::fill) {
23697:     parseResult = SetFillMode(aValue);
23697:   } else if (aAttribute == nsGkAtoms::max) {
23697:     parseResult = SetMax(aValue);
23697:   } else if (aAttribute == nsGkAtoms::min) {
23697:     parseResult = SetMin(aValue);
23697:   } else if (aAttribute == nsGkAtoms::repeatCount) {
23697:     parseResult = SetRepeatCount(aValue);
23697:   } else if (aAttribute == nsGkAtoms::repeatDur) {
23697:     parseResult = SetRepeatDur(aValue);
23697:   } else if (aAttribute == nsGkAtoms::restart) {
23697:     parseResult = SetRestart(aValue);
23697:   } else {
23697:     foundMatch = PR_FALSE;
23697:   }
23697: 
23697:   if (foundMatch) {
23697:     aResult.SetTo(aValue);
23697:     if (aParseResult) {
23697:       *aParseResult = parseResult;
23697:     }
23697:   }
23697: 
23697:   return foundMatch;
23697: }
23697: 
23697: PRBool
23697: nsSMILTimedElement::UnsetAttr(nsIAtom* aAttribute)
23697: {
23697:   PRBool foundMatch = PR_TRUE;
23697: 
23697:   if (aAttribute == nsGkAtoms::begin) {
50803:     UnsetBeginSpec(RemoveNonDOM);
23697:   } else if (aAttribute == nsGkAtoms::dur) {
23697:     UnsetSimpleDuration();
23697:   } else if (aAttribute == nsGkAtoms::end) {
50803:     UnsetEndSpec(RemoveNonDOM);
23697:   } else if (aAttribute == nsGkAtoms::fill) {
23697:     UnsetFillMode();
23697:   } else if (aAttribute == nsGkAtoms::max) {
23697:     UnsetMax();
23697:   } else if (aAttribute == nsGkAtoms::min) {
23697:     UnsetMin();
23697:   } else if (aAttribute == nsGkAtoms::repeatCount) {
23697:     UnsetRepeatCount();
23697:   } else if (aAttribute == nsGkAtoms::repeatDur) {
23697:     UnsetRepeatDur();
23697:   } else if (aAttribute == nsGkAtoms::restart) {
23697:     UnsetRestart();
23697:   } else {
23697:     foundMatch = PR_FALSE;
23697:   }
23697: 
23697:   return foundMatch;
23697: }
23697: 
23697: //----------------------------------------------------------------------
23697: // Setters and unsetters
23697: 
23697: nsresult
37115: nsSMILTimedElement::SetBeginSpec(const nsAString& aBeginSpec,
50805:                                  Element* aContextNode,
50803:                                  RemovalTestFunction aRemove)
23697: {
50803:   return SetBeginOrEndSpec(aBeginSpec, aContextNode, PR_TRUE /*isBegin*/,
50803:                            aRemove);
23697: }
23697: 
23697: void
50803: nsSMILTimedElement::UnsetBeginSpec(RemovalTestFunction aRemove)
23697: {
50803:   ClearSpecs(mBeginSpecs, mBeginInstances, aRemove);
23697:   UpdateCurrentInterval();
23697: }
23697: 
23697: nsresult
37115: nsSMILTimedElement::SetEndSpec(const nsAString& aEndSpec,
50805:                                Element* aContextNode,
50803:                                RemovalTestFunction aRemove)
23697: {
50803:   return SetBeginOrEndSpec(aEndSpec, aContextNode, PR_FALSE /*!isBegin*/,
50803:                            aRemove);
23697: }
23697: 
23697: void
50803: nsSMILTimedElement::UnsetEndSpec(RemovalTestFunction aRemove)
23697: {
50803:   ClearSpecs(mEndSpecs, mEndInstances, aRemove);
23697:   UpdateCurrentInterval();
23697: }
23697: 
23697: nsresult
23697: nsSMILTimedElement::SetSimpleDuration(const nsAString& aDurSpec)
23697: {
23697:   nsSMILTimeValue duration;
23697:   PRBool isMedia;
23697:   nsresult rv;
23697: 
23697:   rv = nsSMILParserUtils::ParseClockValue(aDurSpec, &duration,
23697:           nsSMILParserUtils::kClockValueAllowIndefinite, &isMedia);
23697: 
24033:   if (NS_FAILED(rv)) {
23929:     mSimpleDur.SetIndefinite();
23697:     return NS_ERROR_FAILURE;
23929:   }
23697: 
23929:   if (duration.IsResolved() && duration.GetMillis() == 0L) {
23929:     mSimpleDur.SetIndefinite();
23697:     return NS_ERROR_FAILURE;
23929:   }
23697: 
23697:   //
23697:   // SVG-specific: "For SVG's animation elements, if "media" is specified, the
23697:   // attribute will be ignored." (SVG 1.1, section 19.2.6)
23697:   //
23697:   if (isMedia)
23697:     duration.SetIndefinite();
23697: 
23929:   // mSimpleDur should never be unresolved. ParseClockValue will either set
23929:   // duration to resolved/indefinite/media or will return a failure code.
23929:   NS_ASSERTION(duration.IsResolved() || duration.IsIndefinite(),
23929:     "Setting unresolved simple duration");
23929: 
23697:   mSimpleDur = duration;
24029:   UpdateCurrentInterval();
23697: 
23697:   return NS_OK;
23697: }
23697: 
23697: void
23697: nsSMILTimedElement::UnsetSimpleDuration()
23697: {
23697:   mSimpleDur.SetIndefinite();
23697:   UpdateCurrentInterval();
23697: }
23697: 
23697: nsresult
23697: nsSMILTimedElement::SetMin(const nsAString& aMinSpec)
23697: {
23697:   nsSMILTimeValue duration;
23697:   PRBool isMedia;
23697:   nsresult rv;
23697: 
23697:   rv = nsSMILParserUtils::ParseClockValue(aMinSpec, &duration, 0, &isMedia);
23697: 
23697:   if (isMedia) {
23697:     duration.SetMillis(0L);
23697:   }
23697: 
23697:   if (NS_FAILED(rv) || !duration.IsResolved()) {
23697:     mMin.SetMillis(0L);
23697:     return NS_ERROR_FAILURE;
23697:   }
23697: 
23697:   if (duration.GetMillis() < 0L) {
23697:     mMin.SetMillis(0L);
23697:     return NS_ERROR_FAILURE;
23697:   }
23697: 
23697:   mMin = duration;
23697:   UpdateCurrentInterval();
23697: 
23697:   return NS_OK;
23697: }
23697: 
23697: void
23697: nsSMILTimedElement::UnsetMin()
23697: {
23697:   mMin.SetMillis(0L);
23697:   UpdateCurrentInterval();
23697: }
23697: 
23697: nsresult
23697: nsSMILTimedElement::SetMax(const nsAString& aMaxSpec)
23697: {
23697:   nsSMILTimeValue duration;
23697:   PRBool isMedia;
23697:   nsresult rv;
23697: 
23697:   rv = nsSMILParserUtils::ParseClockValue(aMaxSpec, &duration,
23697:           nsSMILParserUtils::kClockValueAllowIndefinite, &isMedia);
23697: 
23697:   if (isMedia)
23697:     duration.SetIndefinite();
23697: 
23697:   if (NS_FAILED(rv) || (!duration.IsResolved() && !duration.IsIndefinite())) {
23697:     mMax.SetIndefinite();
23697:     return NS_ERROR_FAILURE;
23697:   }
23697: 
23697:   if (duration.IsResolved() && duration.GetMillis() <= 0L) {
23697:     mMax.SetIndefinite();
23697:     return NS_ERROR_FAILURE;
23697:   }
23697: 
23697:   mMax = duration;
23697:   UpdateCurrentInterval();
23697: 
23697:   return NS_OK;
23697: }
23697: 
23697: void
23697: nsSMILTimedElement::UnsetMax()
23697: {
23697:   mMax.SetIndefinite();
23697:   UpdateCurrentInterval();
23697: }
23697: 
23697: nsresult
23697: nsSMILTimedElement::SetRestart(const nsAString& aRestartSpec)
23697: {
23697:   nsAttrValue temp;
23697:   PRBool parseResult
23697:     = temp.ParseEnumValue(aRestartSpec, sRestartModeTable, PR_TRUE);
23697:   mRestartMode = parseResult
23697:                ? nsSMILRestartMode(temp.GetEnumValue())
23697:                : RESTART_ALWAYS;
23697:   UpdateCurrentInterval();
23697:   return parseResult ? NS_OK : NS_ERROR_FAILURE;
23697: }
23697: 
23697: void
23697: nsSMILTimedElement::UnsetRestart()
23697: {
23697:   mRestartMode = RESTART_ALWAYS;
23697:   UpdateCurrentInterval();
23697: }
23697: 
23697: nsresult
23697: nsSMILTimedElement::SetRepeatCount(const nsAString& aRepeatCountSpec)
23697: {
23697:   nsSMILRepeatCount newRepeatCount;
23697:   nsresult rv =
23697:     nsSMILParserUtils::ParseRepeatCount(aRepeatCountSpec, newRepeatCount);
23697: 
23697:   if (NS_SUCCEEDED(rv)) {
23697:     mRepeatCount = newRepeatCount;
23697:   } else {
23697:     mRepeatCount.Unset();
23697:   }
23697: 
24029:   UpdateCurrentInterval();
24029: 
23697:   return rv;
23697: }
23697: 
23697: void
23697: nsSMILTimedElement::UnsetRepeatCount()
23697: {
23697:   mRepeatCount.Unset();
23697:   UpdateCurrentInterval();
23697: }
23697: 
23697: nsresult
23697: nsSMILTimedElement::SetRepeatDur(const nsAString& aRepeatDurSpec)
23697: {
23697:   nsresult rv;
23697:   nsSMILTimeValue duration;
23697: 
23697:   rv = nsSMILParserUtils::ParseClockValue(aRepeatDurSpec, &duration,
23697:           nsSMILParserUtils::kClockValueAllowIndefinite);
23697: 
23929:   if (NS_FAILED(rv) || (!duration.IsResolved() && !duration.IsIndefinite())) {
23929:     mRepeatDur.SetUnresolved();
23697:     return NS_ERROR_FAILURE;
23929:   }
23697: 
24029:   mRepeatDur = duration;
23697:   UpdateCurrentInterval();
23697: 
23697:   return NS_OK;
23697: }
23697: 
23697: void
23697: nsSMILTimedElement::UnsetRepeatDur()
23697: {
23697:   mRepeatDur.SetUnresolved();
23697:   UpdateCurrentInterval();
23697: }
23697: 
23697: nsresult
23697: nsSMILTimedElement::SetFillMode(const nsAString& aFillModeSpec)
23697: {
23697:   PRUint16 previousFillMode = mFillMode;
23697: 
23697:   nsAttrValue temp;
23697:   PRBool parseResult =
23697:     temp.ParseEnumValue(aFillModeSpec, sFillModeTable, PR_TRUE);
23697:   mFillMode = parseResult
23697:             ? nsSMILFillMode(temp.GetEnumValue())
23697:             : FILL_REMOVE;
23697: 
38818:   // Check if we're in a fill-able state: i.e. we've played at least one
38818:   // interval and are now between intervals or at the end of all intervals
38818:   PRBool isFillable = HasPlayed() &&
37115:     (mElementState == STATE_WAITING || mElementState == STATE_POSTACTIVE);
37115: 
38818:   if (mClient && mFillMode != previousFillMode && isFillable) {
23697:     mClient->Inactivate(mFillMode == FILL_FREEZE);
37115:     SampleFillValue();
37115:   }
23697: 
23697:   return parseResult ? NS_OK : NS_ERROR_FAILURE;
23697: }
23697: 
23697: void
23697: nsSMILTimedElement::UnsetFillMode()
23697: {
23697:   PRUint16 previousFillMode = mFillMode;
23697:   mFillMode = FILL_REMOVE;
23697:   if ((mElementState == STATE_WAITING || mElementState == STATE_POSTACTIVE) &&
38818:       previousFillMode == FILL_FREEZE && mClient && HasPlayed())
23697:     mClient->Inactivate(PR_FALSE);
23697: }
23697: 
37113: void
37115: nsSMILTimedElement::AddDependent(nsSMILTimeValueSpec& aDependent)
37113: {
37115:   // There's probably no harm in attempting to register a dependent
37116:   // nsSMILTimeValueSpec twice, but we're not expecting it to happen.
37116:   NS_ABORT_IF_FALSE(!mTimeDependents.GetEntry(&aDependent),
37115:       "nsSMILTimeValueSpec is already registered as a dependency");
37116:   mTimeDependents.PutEntry(&aDependent);
37115: 
47196:   // Add current interval. We could add historical intervals too but that would
47196:   // cause unpredictable results since some intervals may have been filtered.
47196:   // SMIL doesn't say what to do here so for simplicity and consistency we
47196:   // simply add the current interval if there is one.
38818:   //
38818:   // It's not necessary to call SyncPauseTime since we're dealing with
37115:   // historical instance times not newly added ones.
38818:   if (mCurrentInterval) {
47196:     aDependent.HandleNewInterval(*mCurrentInterval, GetTimeContainer());
37115:   }
37115: }
37115: 
37115: void
37116: nsSMILTimedElement::RemoveDependent(nsSMILTimeValueSpec& aDependent)
37115: {
37116:   mTimeDependents.RemoveEntry(&aDependent);
37115: }
37115: 
37115: PRBool
37115: nsSMILTimedElement::IsTimeDependent(const nsSMILTimedElement& aOther) const
37115: {
37115:   const nsSMILInstanceTime* thisBegin = GetEffectiveBeginInstance();
37115:   const nsSMILInstanceTime* otherBegin = aOther.GetEffectiveBeginInstance();
37115: 
37115:   if (!thisBegin || !otherBegin)
37115:     return PR_FALSE;
37115: 
47196:   return thisBegin->IsDependentOn(*otherBegin);
37115: }
37115: 
37115: void
37115: nsSMILTimedElement::BindToTree(nsIContent* aContextNode)
37115: {
57173:   // Reset previously registered milestone since we may be registering with
57173:   // a different time container now.
57173:   mPrevRegisteredMilestone = sMaxMilestone;
57173: 
55397:   // If we were already active then clear all our timing information and start
55397:   // afresh
55397:   if (mElementState != STATE_STARTUP) {
55397:     mSeekState = SEEK_NOT_SEEKING;
55397:     Rewind();
55397:   }
55397: 
72933:   // Scope updateBatcher to last only for the ResolveReferences calls:
72933:   {
72933:     AutoIntervalUpdateBatcher updateBatcher(*this);
72933: 
37115:     // Resolve references to other parts of the tree
37115:     PRUint32 count = mBeginSpecs.Length();
37115:     for (PRUint32 i = 0; i < count; ++i) {
50805:       mBeginSpecs[i]->ResolveReferences(aContextNode);
37115:     }
37115: 
37115:     count = mEndSpecs.Length();
37115:     for (PRUint32 j = 0; j < count; ++j) {
50805:       mEndSpecs[j]->ResolveReferences(aContextNode);
37115:     }
72933:   }
37115: 
37113:   RegisterMilestone();
37113: }
37113: 
37115: void
50806: nsSMILTimedElement::HandleTargetElementChange(Element* aNewTarget)
50806: {
72933:   AutoIntervalUpdateBatcher updateBatcher(*this);
72933: 
50806:   PRUint32 count = mBeginSpecs.Length();
50806:   for (PRUint32 i = 0; i < count; ++i) {
50806:     mBeginSpecs[i]->HandleTargetElementChange(aNewTarget);
50806:   }
50806: 
50806:   count = mEndSpecs.Length();
50806:   for (PRUint32 j = 0; j < count; ++j) {
50806:     mEndSpecs[j]->HandleTargetElementChange(aNewTarget);
50806:   }
50806: }
50806: 
50806: void
37115: nsSMILTimedElement::Traverse(nsCycleCollectionTraversalCallback* aCallback)
37115: {
37115:   PRUint32 count = mBeginSpecs.Length();
37115:   for (PRUint32 i = 0; i < count; ++i) {
37115:     nsSMILTimeValueSpec* beginSpec = mBeginSpecs[i];
37115:     NS_ABORT_IF_FALSE(beginSpec,
37115:         "null nsSMILTimeValueSpec in list of begin specs");
37115:     beginSpec->Traverse(aCallback);
37115:   }
37115: 
37115:   count = mEndSpecs.Length();
37115:   for (PRUint32 j = 0; j < count; ++j) {
37115:     nsSMILTimeValueSpec* endSpec = mEndSpecs[j];
37115:     NS_ABORT_IF_FALSE(endSpec, "null nsSMILTimeValueSpec in list of end specs");
37115:     endSpec->Traverse(aCallback);
37115:   }
37115: }
37115: 
37115: void
37115: nsSMILTimedElement::Unlink()
37115: {
72933:   AutoIntervalUpdateBatcher updateBatcher(*this);
72933: 
37115:   PRUint32 count = mBeginSpecs.Length();
37115:   for (PRUint32 i = 0; i < count; ++i) {
37115:     nsSMILTimeValueSpec* beginSpec = mBeginSpecs[i];
37115:     NS_ABORT_IF_FALSE(beginSpec,
37115:         "null nsSMILTimeValueSpec in list of begin specs");
37115:     beginSpec->Unlink();
37115:   }
37115: 
37115:   count = mEndSpecs.Length();
37115:   for (PRUint32 j = 0; j < count; ++j) {
37115:     nsSMILTimeValueSpec* endSpec = mEndSpecs[j];
37115:     NS_ABORT_IF_FALSE(endSpec, "null nsSMILTimeValueSpec in list of end specs");
37115:     endSpec->Unlink();
37115:   }
37115: }
37115: 
23697: //----------------------------------------------------------------------
23697: // Implementation helpers
23697: 
23697: nsresult
23697: nsSMILTimedElement::SetBeginOrEndSpec(const nsAString& aSpec,
50805:                                       Element* aContextNode,
50803:                                       PRBool aIsBegin,
50803:                                       RemovalTestFunction aRemove)
23697: {
23697:   PRInt32 start;
23697:   PRInt32 end = -1;
23697:   PRInt32 length;
37115:   nsresult rv = NS_OK;
37115:   TimeValueSpecList& timeSpecsList = aIsBegin ? mBeginSpecs : mEndSpecs;
50803:   InstanceTimeList& instances = aIsBegin ? mBeginInstances : mEndInstances;
50803: 
50803:   ClearSpecs(timeSpecsList, instances, aRemove);
23697: 
72933:   AutoIntervalUpdateBatcher updateBatcher(*this);
72933: 
23697:   do {
23697:     start = end + 1;
23697:     end = aSpec.FindChar(';', start);
23697:     length = (end == -1) ? -1 : end - start;
37115:     nsAutoPtr<nsSMILTimeValueSpec>
37115:       spec(new nsSMILTimeValueSpec(*this, aIsBegin));
37115:     rv = spec->SetSpec(Substring(aSpec, start, length), aContextNode);
37115:     if (NS_SUCCEEDED(rv)) {
37115:       timeSpecsList.AppendElement(spec.forget());
37115:     }
37115:   } while (end != -1 && NS_SUCCEEDED(rv));
23697: 
37115:   if (NS_FAILED(rv)) {
50803:     ClearSpecs(timeSpecsList, instances, aRemove);
23697:   }
23697: 
37115:   return rv;
37115: }
37115: 
47196: namespace
47196: {
50803:   // Adaptor functor for RemoveInstanceTimes that allows us to use function
50803:   // pointers instead.
50803:   // Without this we'd have to either templatize ClearSpecs and all its callers
50803:   // or pass bool flags around to specify which removal function to use here.
50803:   class RemoveByFunction
47196:   {
47196:   public:
50803:     RemoveByFunction(nsSMILTimedElement::RemovalTestFunction aFunction)
50803:       : mFunction(aFunction) { }
47196:     PRBool operator()(nsSMILInstanceTime* aInstanceTime, PRUint32 /*aIndex*/)
47196:     {
50803:       return mFunction(aInstanceTime);
47196:     }
50803: 
50803:   private:
50803:     nsSMILTimedElement::RemovalTestFunction mFunction;
47196:   };
47196: }
47196: 
37115: void
50803: nsSMILTimedElement::ClearSpecs(TimeValueSpecList& aSpecs,
50803:                                InstanceTimeList& aInstances,
50803:                                RemovalTestFunction aRemove)
37115: {
50803:   aSpecs.Clear();
50803:   RemoveByFunction removeByFunction(aRemove);
50803:   RemoveInstanceTimes(aInstances, removeByFunction);
37115: }
47196: 
47196: void
55397: nsSMILTimedElement::ClearIntervalProgress()
47197: {
55397:   mElementState = STATE_STARTUP;
55397:   mCurrentRepeatIteration = 0;
55397:   ResetCurrentInterval();
47197: 
55397:   // Remove old intervals
47197:   for (PRInt32 i = mOldIntervals.Length() - 1; i >= 0; --i) {
47197:     mOldIntervals[i]->Unlink();
47197:   }
47197:   mOldIntervals.Clear();
47197: }
47197: 
71823: PRBool
47196: nsSMILTimedElement::ApplyEarlyEnd(const nsSMILTimeValue& aSampleTime)
47196: {
47196:   // This should only be called within DoSampleAt as a helper function
47196:   NS_ABORT_IF_FALSE(mElementState == STATE_ACTIVE,
47196:       "Unexpected state to try to apply an early end");
47196: 
71823:   PRBool updated = PR_FALSE;
71823: 
47196:   // Only apply an early end if we're not already ending.
47196:   if (mCurrentInterval->End()->Time() > aSampleTime) {
47196:     nsSMILInstanceTime* earlyEnd = CheckForEarlyEnd(aSampleTime);
47196:     if (earlyEnd) {
47196:       if (earlyEnd->IsDependent()) {
47196:         // Generate a new instance time for the early end since the
47196:         // existing instance time is part of some dependency chain that we
47196:         // don't want to participate in.
47196:         nsRefPtr<nsSMILInstanceTime> newEarlyEnd =
47196:           new nsSMILInstanceTime(earlyEnd->Time());
47196:         mCurrentInterval->SetEnd(*newEarlyEnd);
47196:       } else {
47196:         mCurrentInterval->SetEnd(*earlyEnd);
47196:       }
71823:       updated = PR_TRUE;
47196:     }
47196:   }
71823:   return updated;
47196: }
47196: 
47196: namespace
47196: {
47196:   class RemoveReset
47196:   {
47196:   public:
47196:     RemoveReset(const nsSMILInstanceTime* aCurrentIntervalBegin)
47196:       : mCurrentIntervalBegin(aCurrentIntervalBegin) { }
47196:     PRBool operator()(nsSMILInstanceTime* aInstanceTime, PRUint32 /*aIndex*/)
47196:     {
47196:       // SMIL 3.0 section 5.4.3, 'Resetting element state':
47196:       //   Any instance times associated with past Event-values, Repeat-values,
47196:       //   Accesskey-values or added via DOM method calls are removed from the
47196:       //   dependent begin and end instance times lists. In effect, all events
47196:       //   and DOM methods calls in the past are cleared. This does not apply to
47196:       //   an instance time that defines the begin of the current interval.
47196:       return aInstanceTime->IsDynamic() &&
47197:              !aInstanceTime->ShouldPreserve() &&
47196:              (!mCurrentIntervalBegin || aInstanceTime != mCurrentIntervalBegin);
47196:     }
47196: 
47196:   private:
47196:     const nsSMILInstanceTime* mCurrentIntervalBegin;
47196:   };
47196: }
47196: 
47196: void
47196: nsSMILTimedElement::Reset()
47196: {
47196:   RemoveReset resetBegin(mCurrentInterval ? mCurrentInterval->Begin() : nsnull);
47196:   RemoveInstanceTimes(mBeginInstances, resetBegin);
47196: 
47196:   RemoveReset resetEnd(nsnull);
47196:   RemoveInstanceTimes(mEndInstances, resetEnd);
47196: }
47196: 
47196: void
47197: nsSMILTimedElement::DoPostSeek()
47197: {
47197:   // Finish backwards seek
47197:   if (mSeekState == SEEK_BACKWARD_FROM_INACTIVE ||
47197:       mSeekState == SEEK_BACKWARD_FROM_ACTIVE) {
47197:     // Previously some dynamic instance times may have been marked to be
47197:     // preserved because they were endpoints of an historic interval (which may
47197:     // or may not have been filtered). Now that we've finished a seek we should
47197:     // clear that flag for those instance times whose intervals are no longer
47197:     // historic.
47197:     UnpreserveInstanceTimes(mBeginInstances);
47197:     UnpreserveInstanceTimes(mEndInstances);
47197: 
47197:     // Now that the times have been unmarked perform a reset. This might seem
47197:     // counter-intuitive when we're only doing a seek within an interval but
47197:     // SMIL seems to require this. SMIL 3.0, 'Hyperlinks and timing':
47197:     //   Resolved end times associated with events, Repeat-values,
47197:     //   Accesskey-values or added via DOM method calls are cleared when seeking
47197:     //   to time earlier than the resolved end time.
47197:     Reset();
47197:     UpdateCurrentInterval();
47197:   }
47197: 
48450:   switch (mSeekState)
48450:   {
48450:   case SEEK_FORWARD_FROM_ACTIVE:
48450:   case SEEK_BACKWARD_FROM_ACTIVE:
48450:     if (mElementState != STATE_ACTIVE) {
48450:       FireTimeEventAsync(NS_SMIL_END, 0);
48450:     }
48450:     break;
48450: 
48450:   case SEEK_FORWARD_FROM_INACTIVE:
48450:   case SEEK_BACKWARD_FROM_INACTIVE:
48450:     if (mElementState == STATE_ACTIVE) {
48450:       FireTimeEventAsync(NS_SMIL_BEGIN, 0);
48450:     }
48450:     break;
50803: 
50803:   case SEEK_NOT_SEEKING:
50803:     /* Do nothing */
50803:     break;
48450:   }
48450: 
47197:   mSeekState = SEEK_NOT_SEEKING;
47197: }
47197: 
47197: void
47197: nsSMILTimedElement::UnpreserveInstanceTimes(InstanceTimeList& aList)
47197: {
47197:   const nsSMILInterval* prevInterval = GetPreviousInterval();
47197:   const nsSMILInstanceTime* cutoff = mCurrentInterval ?
47197:       mCurrentInterval->Begin() :
47197:       prevInterval ? prevInterval->Begin() : nsnull;
47197:   PRUint32 count = aList.Length();
47197:   for (PRUint32 i = 0; i < count; ++i) {
47197:     nsSMILInstanceTime* instance = aList[i].get();
55396:     if (!cutoff || cutoff->Time().CompareTo(instance->Time()) < 0) {
47197:       instance->UnmarkShouldPreserve();
47197:     }
47197:   }
47197: }
47197: 
47197: void
47196: nsSMILTimedElement::FilterHistory()
47196: {
47196:   // We should filter the intervals first, since instance times still used in an
47196:   // interval won't be filtered.
47196:   FilterIntervals();
47196:   FilterInstanceTimes(mBeginInstances);
47196:   FilterInstanceTimes(mEndInstances);
47196: }
47196: 
47196: void
47196: nsSMILTimedElement::FilterIntervals()
47196: {
47196:   // We can filter old intervals that:
47196:   //
47196:   // a) are not the previous interval; AND
47196:   // b) are not in the middle of a dependency chain
47196:   //
47196:   // Condition (a) is necessary since the previous interval is used for applying
47196:   // fill effects and updating the current interval.
47196:   //
47196:   // Condition (b) is necessary since even if this interval itself is not
47196:   // active, it may be part of a dependency chain that includes active
47196:   // intervals. Such chains are used to establish priorities within the
47196:   // animation sandwich.
47196:   //
47196:   // Although the above conditions allow us to safely filter intervals for most
47196:   // scenarios they do not cover all cases and there will still be scenarios
47196:   // that generate intervals indefinitely. In such a case we simply set
47196:   // a maximum number of intervals and drop any intervals beyond that threshold.
47196: 
47196:   PRUint32 threshold = mOldIntervals.Length() > sMaxNumIntervals ?
47196:                        mOldIntervals.Length() - sMaxNumIntervals :
47196:                        0;
47196:   IntervalList filteredList;
47196:   for (PRUint32 i = 0; i < mOldIntervals.Length(); ++i)
47196:   {
47196:     nsSMILInterval* interval = mOldIntervals[i].get();
47196:     if (i + 1 < mOldIntervals.Length() /*skip previous interval*/ &&
47196:         (i < threshold || !interval->IsDependencyChainLink())) {
47196:       interval->Unlink(PR_TRUE /*filtered, not deleted*/);
47196:     } else {
47196:       filteredList.AppendElement(mOldIntervals[i].forget());
47196:     }
47196:   }
47196:   mOldIntervals.Clear();
47196:   mOldIntervals.SwapElements(filteredList);
47196: }
47196: 
47196: namespace
47196: {
47196:   class RemoveFiltered
47196:   {
47196:   public:
47196:     RemoveFiltered(nsSMILTimeValue aCutoff) : mCutoff(aCutoff) { }
47196:     PRBool operator()(nsSMILInstanceTime* aInstanceTime, PRUint32 /*aIndex*/)
47196:     {
47196:       // We can filter instance times that:
47196:       // a) Precede the end point of the previous interval; AND
47196:       // b) Are NOT syncbase times that might be updated to a time after the end
47196:       //    point of the previous interval; AND
47196:       // c) Are NOT fixed end points in any remaining interval.
47196:       return aInstanceTime->Time() < mCutoff &&
47196:              aInstanceTime->IsFixedTime() &&
47197:              !aInstanceTime->ShouldPreserve();
47196:     }
47196: 
47196:   private:
47196:     nsSMILTimeValue mCutoff;
47196:   };
47196: 
47196:   class RemoveBelowThreshold
47196:   {
47196:   public:
47196:     RemoveBelowThreshold(PRUint32 aThreshold,
74321:                          nsTArray<const nsSMILInstanceTime *>& aTimesToKeep)
47196:       : mThreshold(aThreshold),
74321:         mTimesToKeep(aTimesToKeep) { }
47196:     PRBool operator()(nsSMILInstanceTime* aInstanceTime, PRUint32 aIndex)
47196:     {
74321:       return aIndex < mThreshold && !mTimesToKeep.Contains(aInstanceTime);
47196:     }
47196: 
47196:   private:
47196:     PRUint32 mThreshold;
74321:     nsTArray<const nsSMILInstanceTime *>& mTimesToKeep;
47196:   };
47196: }
47196: 
47196: void
47196: nsSMILTimedElement::FilterInstanceTimes(InstanceTimeList& aList)
47196: {
47196:   if (GetPreviousInterval()) {
47196:     RemoveFiltered removeFiltered(GetPreviousInterval()->End()->Time());
47196:     RemoveInstanceTimes(aList, removeFiltered);
47196:   }
47196: 
47196:   // As with intervals it is possible to create a document that, even despite
47196:   // our most aggressive filtering, will generate instance times indefinitely
47196:   // (e.g. cyclic dependencies with TimeEvents---we can't filter such times as
47196:   // they're unpredictable due to the possibility of seeking the document which
47196:   // may prevent some events from being generated). Therefore we introduce
47196:   // a hard cutoff at which point we just drop the oldest instance times.
47196:   if (aList.Length() > sMaxNumInstanceTimes) {
47196:     PRUint32 threshold = aList.Length() - sMaxNumInstanceTimes;
74321:     // There are a few instance times we should keep though, notably:
74321:     // - the current interval begin time,
74321:     // - the previous interval end time (see note in RemoveInstanceTimes)
74321:     nsTArray<const nsSMILInstanceTime *> timesToKeep;
74321:     if (mCurrentInterval) {
74321:       timesToKeep.AppendElement(mCurrentInterval->Begin());
74321:     }
74321:     const nsSMILInterval* prevInterval = GetPreviousInterval();
74321:     if (prevInterval) {
74321:       timesToKeep.AppendElement(prevInterval->End());
74321:     }
74321:     RemoveBelowThreshold removeBelowThreshold(threshold, timesToKeep);
47196:     RemoveInstanceTimes(aList, removeBelowThreshold);
37115:   }
23697: }
23697: 
23697: //
23697: // This method is based on the pseudocode given in the SMILANIM spec.
23697: //
23697: // See:
23697: // http://www.w3.org/TR/2001/REC-smil-animation-20010904/#Timing-BeginEnd-LC-Start
23697: //
64043: PRBool
31133: nsSMILTimedElement::GetNextInterval(const nsSMILInterval* aPrevInterval,
72214:                                     const nsSMILInterval* aReplacedInterval,
37115:                                     const nsSMILInstanceTime* aFixedBeginTime,
38819:                                     nsSMILInterval& aResult) const
23697: {
37115:   NS_ABORT_IF_FALSE(!aFixedBeginTime || aFixedBeginTime->Time().IsResolved(),
37115:       "Unresolved begin time specified for interval start");
64043:   static const nsSMILTimeValue zeroTime(0L);
23697: 
38818:   if (mRestartMode == RESTART_NEVER && aPrevInterval)
64043:     return PR_FALSE;
31133: 
31133:   // Calc starting point
31133:   nsSMILTimeValue beginAfter;
31133:   PRBool prevIntervalWasZeroDur = PR_FALSE;
38818:   if (aPrevInterval) {
37115:     beginAfter = aPrevInterval->End()->Time();
37115:     prevIntervalWasZeroDur
37115:       = aPrevInterval->End()->Time() == aPrevInterval->Begin()->Time();
37134:     if (aFixedBeginTime) {
37134:       prevIntervalWasZeroDur &=
37134:         aPrevInterval->Begin()->Time() == aFixedBeginTime->Time();
37134:     }
31133:   } else {
31133:     beginAfter.SetMillis(LL_MININT);
31133:   }
31133: 
37115:   nsRefPtr<nsSMILInstanceTime> tempBegin;
37115:   nsRefPtr<nsSMILInstanceTime> tempEnd;
23697: 
23697:   while (PR_TRUE) {
37134:     // Calculate begin time
37115:     if (aFixedBeginTime) {
64043:       if (aFixedBeginTime->Time() < beginAfter) {
64043:         return PR_FALSE;
64043:       }
37115:       // our ref-counting is not const-correct
37115:       tempBegin = const_cast<nsSMILInstanceTime*>(aFixedBeginTime);
50803:     } else if ((!mAnimationElement ||
50803:                 !mAnimationElement->HasAnimAttr(nsGkAtoms::begin)) &&
50803:                beginAfter <= zeroTime) {
38818:       tempBegin = new nsSMILInstanceTime(nsSMILTimeValue(0));
23697:     } else {
31133:       PRInt32 beginPos = 0;
72214:       // If we're updating the current interval then skip any begin time that is
72214:       // dependent on the current interval's begin time. e.g.
72214:       //   <animate id="a" begin="b.begin; a.begin+2s"...
72214:       // If b's interval disappears whilst 'a' is in the waiting state the begin
72214:       // time at "a.begin+2s" should be skipped since 'a' never begun.
72214:       do {
72214:         tempBegin =
72214:           GetNextGreaterOrEqual(mBeginInstances, beginAfter, beginPos);
64043:         if (!tempBegin || !tempBegin->Time().IsResolved()) {
64043:           return PR_FALSE;
64043:         }
72214:       } while (aReplacedInterval &&
72214:                tempBegin->GetBaseTime() == aReplacedInterval->Begin());
23697:     }
42519:     NS_ABORT_IF_FALSE(tempBegin && tempBegin->Time().IsResolved() &&
42519:         tempBegin->Time() >= beginAfter,
37115:         "Got a bad begin time while fetching next interval");
23697: 
37134:     // Calculate end time
37134:     {
31133:       PRInt32 endPos = 0;
72214:       // As above with begin times, avoid creating self-referential loops
72214:       // between instance times by checking that the newly found end instance
72214:       // time is not already dependent on the end of the current interval.
72214:       do {
72214:         tempEnd =
72214:           GetNextGreaterOrEqual(mEndInstances, tempBegin->Time(), endPos);
72214:       } while (tempEnd && aReplacedInterval &&
72214:                tempEnd->GetBaseTime() == aReplacedInterval->End());
23697: 
31133:       // If the last interval ended at the same point and was zero-duration and
31133:       // this one is too, look for another end to use instead
37115:       if (tempEnd && tempEnd->Time() == tempBegin->Time() &&
37115:           prevIntervalWasZeroDur) {
37115:         tempEnd = GetNextGreater(mEndInstances, tempBegin->Time(), endPos);
23697:       }
23697: 
37134:       // If all the ends are before the beginning we have a bad interval UNLESS:
50804:       // a) We never had any end attribute to begin with (and hence we should
37134:       //    just use the active duration after allowing for the possibility of
50804:       //    an end instance provided by a DOM call), OR
50804:       // b) We have an end attribute but no end instances--this is a special
37134:       //    case that is needed for syncbase timing so that animations of the
37134:       //    following sort: <animate id="a" end="a.begin+1s" ... /> can be
37134:       //    resolved (see SVGT 1.2 Test Suite animate-elem-221-t.svg) by first
50804:       //    establishing an interval of unresolved duration, OR
50804:       // c) We have end events which leave the interval open-ended.
50804:       PRBool openEndedIntervalOk = mEndSpecs.IsEmpty() ||
50804:                                    mEndInstances.IsEmpty() ||
50804:                                    EndHasEventConditions();
37134:       if (!tempEnd && !openEndedIntervalOk)
64043:         return PR_FALSE; // Bad interval
37115: 
37115:       nsSMILTimeValue intervalEnd = tempEnd
37115:                                   ? tempEnd->Time() : nsSMILTimeValue();
37115:       nsSMILTimeValue activeEnd = CalcActiveEnd(tempBegin->Time(), intervalEnd);
37115: 
37115:       if (!tempEnd || intervalEnd != activeEnd) {
38818:         tempEnd = new nsSMILInstanceTime(activeEnd);
23697:       }
23697:     }
37115:     NS_ABORT_IF_FALSE(tempEnd, "Failed to get end point for next interval");
23697: 
31133:     // If we get two zero-length intervals in a row we will potentially have an
31133:     // infinite loop so we break it here by searching for the next begin time
31133:     // greater than tempEnd on the next time around.
37115:     if (tempEnd->Time().IsResolved() && tempBegin->Time() == tempEnd->Time()) {
31133:       if (prevIntervalWasZeroDur) {
37115:         beginAfter.SetMillis(tempEnd->Time().GetMillis() + 1);
31133:         prevIntervalWasZeroDur = PR_FALSE;
31133:         continue;
31133:       }
31133:       prevIntervalWasZeroDur = PR_TRUE;
31133:     }
31133: 
37115:     // Check for valid interval
37115:     if (tempEnd->Time() > zeroTime ||
37115:        (tempBegin->Time() == zeroTime && tempEnd->Time() == zeroTime)) {
37115:       aResult.Set(*tempBegin, *tempEnd);
64043:       return PR_TRUE;
37115:     }
37115: 
37115:     if (mRestartMode == RESTART_NEVER) {
31133:       // tempEnd <= 0 so we're going to loop which effectively means restarting
64043:       return PR_FALSE;
23697:     }
37115: 
37115:     beginAfter = tempEnd->Time();
23697:   }
23697:   NS_NOTREACHED("Hmm... we really shouldn't be here");
23697: 
64043:   return PR_FALSE;
23697: }
23697: 
37115: nsSMILInstanceTime*
37115: nsSMILTimedElement::GetNextGreater(const InstanceTimeList& aList,
31133:                                    const nsSMILTimeValue& aBase,
37115:                                    PRInt32& aPosition) const
31133: {
37115:   nsSMILInstanceTime* result = nsnull;
37115:   while ((result = GetNextGreaterOrEqual(aList, aBase, aPosition)) &&
37115:          result->Time() == aBase);
37115:   return result;
31133: }
31133: 
37115: nsSMILInstanceTime*
37115: nsSMILTimedElement::GetNextGreaterOrEqual(const InstanceTimeList& aList,
23697:                                           const nsSMILTimeValue& aBase,
37115:                                           PRInt32& aPosition) const
23697: {
37115:   nsSMILInstanceTime* result = nsnull;
23697:   PRInt32 count = aList.Length();
23697: 
37115:   for (; aPosition < count && !result; ++aPosition) {
37115:     nsSMILInstanceTime* val = aList[aPosition].get();
37115:     NS_ABORT_IF_FALSE(val, "NULL instance time in list");
37115:     if (val->Time() >= aBase) {
37115:       result = val;
23697:     }
23697:   }
23697: 
37115:   return result;
23697: }
23697: 
23697: /**
23697:  * @see SMILANIM 3.3.4
23697:  */
23697: nsSMILTimeValue
23697: nsSMILTimedElement::CalcActiveEnd(const nsSMILTimeValue& aBegin,
37113:                                   const nsSMILTimeValue& aEnd) const
23697: {
23697:   nsSMILTimeValue result;
23697: 
42519:   NS_ABORT_IF_FALSE(mSimpleDur.IsResolved() || mSimpleDur.IsIndefinite(),
37602:     "Unresolved simple duration in CalcActiveEnd");
42519:   NS_ABORT_IF_FALSE(aBegin.IsResolved(),
42519:     "Unresolved begin time in CalcActiveEnd");
23697: 
42519:   if (mRepeatDur.IsIndefinite()) {
23697:     result.SetIndefinite();
23697:   } else {
23697:     result = GetRepeatDuration();
23697:   }
23697: 
42519:   if (aEnd.IsResolved()) {
23697:     nsSMILTime activeDur = aEnd.GetMillis() - aBegin.GetMillis();
23697: 
23697:     if (result.IsResolved()) {
36757:       result.SetMillis(NS_MIN(result.GetMillis(), activeDur));
23697:     } else {
23697:       result.SetMillis(activeDur);
23697:     }
23697:   }
23697: 
23697:   result = ApplyMinAndMax(result);
23697: 
23697:   if (result.IsResolved()) {
23697:     nsSMILTime activeEnd = result.GetMillis() + aBegin.GetMillis();
23697:     result.SetMillis(activeEnd);
23697:   }
23697: 
23697:   return result;
23697: }
23697: 
23697: nsSMILTimeValue
37113: nsSMILTimedElement::GetRepeatDuration() const
23697: {
23697:   nsSMILTimeValue result;
23697: 
23697:   if (mRepeatCount.IsDefinite() && mRepeatDur.IsResolved()) {
23697:     if (mSimpleDur.IsResolved()) {
37113:       nsSMILTime activeDur =
37113:         nsSMILTime(mRepeatCount * double(mSimpleDur.GetMillis()));
36757:       result.SetMillis(NS_MIN(activeDur, mRepeatDur.GetMillis()));
23697:     } else {
23697:       result = mRepeatDur;
23697:     }
23697:   } else if (mRepeatCount.IsDefinite() && mSimpleDur.IsResolved()) {
37113:     nsSMILTime activeDur =
37113:       nsSMILTime(mRepeatCount * double(mSimpleDur.GetMillis()));
23697:     result.SetMillis(activeDur);
23697:   } else if (mRepeatDur.IsResolved()) {
23697:     result = mRepeatDur;
23697:   } else if (mRepeatCount.IsIndefinite()) {
23697:     result.SetIndefinite();
23697:   } else {
23697:     result = mSimpleDur;
23697:   }
23697: 
23697:   return result;
23697: }
23697: 
23697: nsSMILTimeValue
37113: nsSMILTimedElement::ApplyMinAndMax(const nsSMILTimeValue& aDuration) const
23697: {
23697:   if (!aDuration.IsResolved() && !aDuration.IsIndefinite()) {
23697:     return aDuration;
23697:   }
23697: 
37113:   if (mMax < mMin) {
23697:     return aDuration;
23697:   }
23697: 
23697:   nsSMILTimeValue result;
23697: 
37113:   if (aDuration > mMax) {
23697:     result = mMax;
37113:   } else if (aDuration < mMin) {
23697:     nsSMILTimeValue repeatDur = GetRepeatDuration();
37113:     result = mMin > repeatDur ? repeatDur : mMin;
23697:   } else {
23697:     result = aDuration;
23697:   }
23697: 
23697:   return result;
23697: }
23697: 
23697: nsSMILTime
23697: nsSMILTimedElement::ActiveTimeToSimpleTime(nsSMILTime aActiveTime,
23697:                                            PRUint32& aRepeatIteration)
23697: {
23697:   nsSMILTime result;
23697: 
23697:   NS_ASSERTION(mSimpleDur.IsResolved() || mSimpleDur.IsIndefinite(),
23929:       "Unresolved simple duration in ActiveTimeToSimpleTime");
47197:   NS_ASSERTION(aActiveTime >= 0, "Expecting non-negative active time");
47197:   // Note that a negative aActiveTime will give us a negative value for
47197:   // aRepeatIteration, which is bad because aRepeatIteration is unsigned
23697: 
23697:   if (mSimpleDur.IsIndefinite() || mSimpleDur.GetMillis() == 0L) {
23697:     aRepeatIteration = 0;
23697:     result = aActiveTime;
23697:   } else {
23697:     result = aActiveTime % mSimpleDur.GetMillis();
23697:     aRepeatIteration = (PRUint32)(aActiveTime / mSimpleDur.GetMillis());
23697:   }
23697: 
23697:   return result;
23697: }
23697: 
23697: //
23697: // Although in many cases it would be possible to check for an early end and
23697: // adjust the current interval well in advance the SMIL Animation spec seems to
23697: // indicate that we should only apply an early end at the latest possible
23697: // moment. In particular, this paragraph from section 3.6.8:
23697: //
23697: // 'If restart  is set to "always", then the current interval will end early if
23697: // there is an instance time in the begin list that is before (i.e. earlier
23697: // than) the defined end for the current interval. Ending in this manner will
23697: // also send a changed time notice to all time dependents for the current
23697: // interval end.'
23697: //
37115: nsSMILInstanceTime*
37113: nsSMILTimedElement::CheckForEarlyEnd(
37113:     const nsSMILTimeValue& aContainerTime) const
23697: {
38818:   NS_ABORT_IF_FALSE(mCurrentInterval,
37115:       "Checking for an early end but the current interval is not set");
23697:   if (mRestartMode != RESTART_ALWAYS)
37115:     return nsnull;
23697: 
23697:   PRInt32 position = 0;
37115:   nsSMILInstanceTime* nextBegin =
38818:     GetNextGreater(mBeginInstances, mCurrentInterval->Begin()->Time(),
38818:                    position);
23697: 
37115:   if (nextBegin &&
38818:       nextBegin->Time() > mCurrentInterval->Begin()->Time() &&
38818:       nextBegin->Time() < mCurrentInterval->End()->Time() &&
37115:       nextBegin->Time() <= aContainerTime) {
37113:     return nextBegin;
23697:   }
37113: 
37115:   return nsnull;
23697: }
23697: 
23697: void
37115: nsSMILTimedElement::UpdateCurrentInterval(PRBool aForceChangeNotice)
23697: {
72933:   // Check if updates are currently blocked (batched)
72933:   if (mDeferIntervalUpdates) {
72933:     mDoDeferredUpdate = PR_TRUE;
72933:     return;
72933:   }
72933: 
37115:   // We adopt the convention of not resolving intervals until the first
37115:   // sample. Otherwise, every time each attribute is set we'll re-resolve the
37115:   // current interval and notify all our time dependents of the change.
37113:   //
37113:   // The disadvantage of deferring resolving the interval is that DOM calls to
37113:   // to getStartTime will throw an INVALID_STATE_ERR exception until the
37115:   // document timeline begins since the start time has not yet been resolved.
37113:   if (mElementState == STATE_STARTUP)
37113:     return;
37113: 
72935:   // Check that we aren't stuck in infinite recursion updating some syncbase
72935:   // dependencies. Generally such situations should be detected in advance and
72935:   // the chain broken in a sensible and predictable manner, so if we're hitting
72935:   // this assertion we need to work out how to detect the case that's causing
72935:   // it. In release builds, just bail out before we overflow the stack.
73905:   AutoRestore<PRUint16> depthRestorer(mUpdateIntervalRecursionDepth);
72935:   if (++mUpdateIntervalRecursionDepth > sMaxUpdateIntervalRecursionDepth) {
72935:     NS_ABORT_IF_FALSE(PR_FALSE,
72935:         "Update current interval recursion depth exceeded threshold");
72935:     return;
72935:   }
72935: 
37115:   // If the interval is active the begin time is fixed.
37115:   const nsSMILInstanceTime* beginTime = mElementState == STATE_ACTIVE
38818:                                       ? mCurrentInterval->Begin()
37115:                                       : nsnull;
23697:   nsSMILInterval updatedInterval;
72214:   if (GetNextInterval(GetPreviousInterval(), mCurrentInterval,
72214:                       beginTime, updatedInterval)) {
23697: 
37115:     if (mElementState == STATE_POSTACTIVE) {
37115: 
38818:       NS_ABORT_IF_FALSE(!mCurrentInterval,
37115:           "In postactive state but the interval has been set");
38818:       mCurrentInterval = new nsSMILInterval(updatedInterval);
37115:       mElementState = STATE_WAITING;
37115:       NotifyNewInterval();
37115: 
37115:     } else {
37115: 
71823:       PRBool beginChanged = PR_FALSE;
71823:       PRBool endChanged   = PR_FALSE;
37115: 
23697:       if (mElementState != STATE_ACTIVE &&
38818:           !updatedInterval.Begin()->SameTimeAndBase(
38818:             *mCurrentInterval->Begin())) {
38818:         mCurrentInterval->SetBegin(*updatedInterval.Begin());
71823:         beginChanged = PR_TRUE;
23697:       }
23697: 
38818:       if (!updatedInterval.End()->SameTimeAndBase(*mCurrentInterval->End())) {
38818:         mCurrentInterval->SetEnd(*updatedInterval.End());
71823:         endChanged = PR_TRUE;
37115:       }
37115: 
71823:       if (beginChanged || endChanged || aForceChangeNotice) {
71823:         NotifyChangedInterval(mCurrentInterval, beginChanged, endChanged);
37115:       }
23697:     }
23697: 
37113:     // There's a chance our next milestone has now changed, so update the time
37113:     // container
37113:     RegisterMilestone();
56138:   } else { // GetNextInterval failed: Current interval is no longer valid
56138:     if (mElementState == STATE_ACTIVE) {
56138:       // The interval is active so we can't just delete it, instead trim it so
56138:       // that begin==end.
56138:       if (!mCurrentInterval->End()->SameTimeAndBase(*mCurrentInterval->Begin()))
56138:       {
56138:         mCurrentInterval->SetEnd(*mCurrentInterval->Begin());
71823:         NotifyChangedInterval(mCurrentInterval, PR_FALSE, PR_TRUE);
23697:       }
56138:       // The transition to the postactive state will take place on the next
56138:       // sample (along with firing end events, clearing intervals etc.)
56138:       RegisterMilestone();
56138:     } else if (mElementState == STATE_WAITING) {
23697:       mElementState = STATE_POSTACTIVE;
55397:       ResetCurrentInterval();
23697:     }
23697:   }
23697: }
23697: 
23697: void
23697: nsSMILTimedElement::SampleSimpleTime(nsSMILTime aActiveTime)
23697: {
23697:   if (mClient) {
23697:     PRUint32 repeatIteration;
23697:     nsSMILTime simpleTime =
23697:       ActiveTimeToSimpleTime(aActiveTime, repeatIteration);
23697:     mClient->SampleAt(simpleTime, mSimpleDur, repeatIteration);
23697:   }
23697: }
23697: 
23697: void
23697: nsSMILTimedElement::SampleFillValue()
23697: {
38818:   if (mFillMode != FILL_FREEZE || !mClient)
23697:     return;
23697: 
38819:   const nsSMILInterval* prevInterval = GetPreviousInterval();
38819:   NS_ABORT_IF_FALSE(prevInterval,
38819:       "Attempting to sample fill value but there is no previous interval");
38819:   NS_ABORT_IF_FALSE(prevInterval->End()->Time().IsResolved() &&
47196:       prevInterval->End()->IsFixedTime(),
37115:       "Attempting to sample fill value but the endpoint of the previous "
47196:       "interval is not resolved and fixed");
37115: 
38819:   nsSMILTime activeTime = prevInterval->End()->Time().GetMillis() -
38819:                           prevInterval->Begin()->Time().GetMillis();
37115: 
23697:   PRUint32 repeatIteration;
23697:   nsSMILTime simpleTime =
23697:     ActiveTimeToSimpleTime(activeTime, repeatIteration);
23697: 
31133:   if (simpleTime == 0L && repeatIteration) {
23697:     mClient->SampleLastValue(--repeatIteration);
23697:   } else {
23697:     mClient->SampleAt(simpleTime, mSimpleDur, repeatIteration);
23697:   }
23697: }
23697: 
24029: void
24029: nsSMILTimedElement::AddInstanceTimeFromCurrentTime(nsSMILTime aCurrentTime,
24029:     double aOffsetSeconds, PRBool aIsBegin)
23697: {
23697:   double offset = aOffsetSeconds * PR_MSEC_PER_SEC;
24029:   nsSMILTime timeWithOffset = aCurrentTime + PRInt64(NS_round(offset));
23697: 
37113:   nsSMILTimeValue timeVal(timeWithOffset);
23697: 
37115:   nsRefPtr<nsSMILInstanceTime> instanceTime =
38818:     new nsSMILInstanceTime(timeVal, nsSMILInstanceTime::SOURCE_DOM);
37115: 
23697:   AddInstanceTime(instanceTime, aIsBegin);
23697: }
37113: 
37113: void
37113: nsSMILTimedElement::RegisterMilestone()
37113: {
37113:   nsSMILTimeContainer* container = GetTimeContainer();
37113:   if (!container)
37113:     return;
37113:   NS_ABORT_IF_FALSE(mAnimationElement,
37113:       "Got a time container without an owning animation element");
37113: 
37113:   nsSMILMilestone nextMilestone;
37113:   if (!GetNextMilestone(nextMilestone))
37113:     return;
37113: 
37113:   // This method is called every time we might possibly have updated our
37113:   // current interval, but since nsSMILTimeContainer makes no attempt to filter
37113:   // out redundant milestones we do some rudimentary filtering here. It's not
37113:   // perfect, but unnecessary samples are fairly cheap.
37113:   if (nextMilestone >= mPrevRegisteredMilestone)
37113:     return;
37113: 
37113:   container->AddMilestone(nextMilestone, *mAnimationElement);
37113:   mPrevRegisteredMilestone = nextMilestone;
37113: }
37113: 
37113: PRBool
37113: nsSMILTimedElement::GetNextMilestone(nsSMILMilestone& aNextMilestone) const
37113: {
37113:   // Return the next key moment in our lifetime.
37113:   //
37113:   // XXX It may be possible in future to optimise this so that we only register
37113:   // for milestones if:
37113:   // a) We have time dependents, or
37113:   // b) We are dependent on events or syncbase relationships, or
37113:   // c) There are registered listeners for our events
37113:   //
37113:   // Then for the simple case where everything uses offset values we could
37113:   // ignore milestones altogether.
37113:   //
37113:   // We'd need to be careful, however, that if one of those conditions became
37113:   // true in between samples that we registered our next milestone at that
37113:   // point.
37113: 
37113:   switch (mElementState)
37113:   {
37113:   case STATE_STARTUP:
37113:     // All elements register for an initial end sample at t=0 where we resolve
37113:     // our initial interval.
37113:     aNextMilestone.mIsEnd = PR_TRUE; // Initial sample should be an end sample
37113:     aNextMilestone.mTime = 0;
37113:     return PR_TRUE;
37113: 
37113:   case STATE_WAITING:
38818:     NS_ABORT_IF_FALSE(mCurrentInterval,
37115:         "In waiting state but the current interval has not been set");
37113:     aNextMilestone.mIsEnd = PR_FALSE;
38818:     aNextMilestone.mTime = mCurrentInterval->Begin()->Time().GetMillis();
37113:     return PR_TRUE;
37113: 
37113:   case STATE_ACTIVE:
37113:     {
48450:       // Work out what comes next: the interval end or the next repeat iteration
48450:       nsSMILTimeValue nextRepeat;
48450:       if (mSeekState == SEEK_NOT_SEEKING && mSimpleDur.IsResolved()) {
48450:         nextRepeat.SetMillis(mCurrentInterval->Begin()->Time().GetMillis() +
48450:             (mCurrentRepeatIteration + 1) * mSimpleDur.GetMillis());
48450:       }
48450:       nsSMILTimeValue nextMilestone =
48450:         NS_MIN(mCurrentInterval->End()->Time(), nextRepeat);
37113: 
48450:       // Check for an early end before that time
48450:       nsSMILInstanceTime* earlyEnd = CheckForEarlyEnd(nextMilestone);
37115:       if (earlyEnd) {
37113:         aNextMilestone.mIsEnd = PR_TRUE;
37115:         aNextMilestone.mTime = earlyEnd->Time().GetMillis();
37113:         return PR_TRUE;
37113:       }
37113: 
48450:       // Apply the previously calculated milestone
48450:       if (nextMilestone.IsResolved()) {
48450:         aNextMilestone.mIsEnd = nextMilestone != nextRepeat;
48450:         aNextMilestone.mTime = nextMilestone.GetMillis();
37113:         return PR_TRUE;
37113:       }
37113: 
37113:       return PR_FALSE;
37113:     }
37113: 
37113:   case STATE_POSTACTIVE:
37113:     return PR_FALSE;
37113: 
37113:   default:
37113:     NS_ABORT_IF_FALSE(PR_FALSE, "Invalid element state");
37113:     return PR_FALSE;
37113:   }
37113: }
37115: 
37115: void
37115: nsSMILTimedElement::NotifyNewInterval()
37115: {
38818:   NS_ABORT_IF_FALSE(mCurrentInterval,
37115:       "Attempting to notify dependents of a new interval but the interval "
37115:       "is not set");
37115: 
37115:   nsSMILTimeContainer* container = GetTimeContainer();
37115:   if (container) {
37115:     container->SyncPauseTime();
37115:   }
37115: 
38818:   NotifyTimeDependentsParams params = { mCurrentInterval, container };
37116:   mTimeDependents.EnumerateEntries(NotifyNewIntervalCallback, &params);
37115: }
37115: 
37115: void
71823: nsSMILTimedElement::NotifyChangedInterval(nsSMILInterval* aInterval,
71823:                                           PRBool aBeginObjectChanged,
71823:                                           PRBool aEndObjectChanged)
37115: {
71823:   NS_ABORT_IF_FALSE(aInterval, "Null interval for change notification");
37115: 
37115:   nsSMILTimeContainer* container = GetTimeContainer();
37115:   if (container) {
37115:     container->SyncPauseTime();
37115:   }
37115: 
71823:   // Copy the instance times list since notifying the instance times can result
71823:   // in a chain reaction whereby our own interval gets deleted along with its
71823:   // instance times.
71823:   InstanceTimeList times;
71823:   aInterval->GetDependentTimes(times);
71823: 
71823:   for (PRUint32 i = 0; i < times.Length(); ++i) {
71823:     times[i]->HandleChangedInterval(container, aBeginObjectChanged,
71823:                                     aEndObjectChanged);
71823:   }
37115: }
37115: 
48450: void
48450: nsSMILTimedElement::FireTimeEventAsync(PRUint32 aMsg, PRInt32 aDetail)
48450: {
48450:   if (!mAnimationElement)
48450:     return;
48450: 
48450:   nsCOMPtr<nsIRunnable> event =
50805:     new AsyncTimeEventRunner(&mAnimationElement->AsElement(), aMsg, aDetail);
48450:   NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
48450: }
48450: 
37115: const nsSMILInstanceTime*
37115: nsSMILTimedElement::GetEffectiveBeginInstance() const
37115: {
37115:   switch (mElementState)
37115:   {
37115:   case STATE_STARTUP:
37115:     return nsnull;
37115: 
37115:   case STATE_ACTIVE:
38818:     return mCurrentInterval->Begin();
37115: 
37115:   case STATE_WAITING:
37115:   case STATE_POSTACTIVE:
38818:     {
38818:       const nsSMILInterval* prevInterval = GetPreviousInterval();
38818:       return prevInterval ? prevInterval->Begin() : nsnull;
38818:     }
37115: 
37115:   default:
37115:     NS_NOTREACHED("Invalid element state");
37115:     return nsnull;
37115:   }
37115: }
37116: 
38818: const nsSMILInterval*
38818: nsSMILTimedElement::GetPreviousInterval() const
38818: {
38818:   return mOldIntervals.IsEmpty()
38818:     ? nsnull
38818:     : mOldIntervals[mOldIntervals.Length()-1].get();
38818: }
38818: 
50804: PRBool
50804: nsSMILTimedElement::EndHasEventConditions() const
50804: {
50804:   for (PRUint32 i = 0; i < mEndSpecs.Length(); ++i) {
50804:     if (mEndSpecs[i]->IsEventBased())
50804:       return PR_TRUE;
50804:   }
50804:   return PR_FALSE;
50804: }
50804: 
37116: //----------------------------------------------------------------------
37116: // Hashtable callback functions
37116: 
37116: /* static */ PR_CALLBACK PLDHashOperator
37116: nsSMILTimedElement::NotifyNewIntervalCallback(TimeValueSpecPtrKey* aKey,
37116:                                               void* aData)
37116: {
38818:   NS_ABORT_IF_FALSE(aKey, "Null hash key for time container hash table");
38818:   NS_ABORT_IF_FALSE(aKey->GetKey(),
38818:                     "null nsSMILTimeValueSpec in set of time dependents");
38818: 
37116:   NotifyTimeDependentsParams* params =
37116:     static_cast<NotifyTimeDependentsParams*>(aData);
38818:   NS_ABORT_IF_FALSE(params, "null data ptr while enumerating hashtable");
38818:   NS_ABORT_IF_FALSE(params->mCurrentInterval, "null current-interval ptr");
37116: 
37116:   nsSMILTimeValueSpec* spec = aKey->GetKey();
37116:   spec->HandleNewInterval(*params->mCurrentInterval, params->mTimeContainer);
37116:   return PL_DHASH_NEXT;
37116: }
