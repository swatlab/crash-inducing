29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   IBM Corp.
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS number type and wrapper class.
    1:  */
26750: #ifdef XP_OS2
26750: #define _PC_53  PC_53
26750: #define _MCW_EM MCW_EM
26750: #define _MCW_PC MCW_PC
26750: #endif
    1: #include <locale.h>
    1: #include <limits.h>
    1: #include <math.h>
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jsapi.h"
    1: #include "jsatom.h"
20408: #include "jsbuiltins.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsdtoa.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
    1: #include "jsprf.h"
12581: #include "jsscope.h"
    1: #include "jsstr.h"
40901: #include "jsvector.h"
40901: 
40901: #include "jsobjinlines.h"
40900: #include "jsstrinlines.h"
40899: 
39941: using namespace js;
32758: 
32780: #ifndef JS_HAVE_STDINT_H /* Native support is innocent until proven guilty. */
32780: 
32758: JS_STATIC_ASSERT(uint8_t(-1) == UINT8_MAX);
32758: JS_STATIC_ASSERT(uint16_t(-1) == UINT16_MAX);
32758: JS_STATIC_ASSERT(uint32_t(-1) == UINT32_MAX);
32758: JS_STATIC_ASSERT(uint64_t(-1) == UINT64_MAX);
32758: 
32758: JS_STATIC_ASSERT(INT8_MAX > INT8_MIN);
32782: JS_STATIC_ASSERT(uint8_t(INT8_MAX) + uint8_t(1) == uint8_t(INT8_MIN));
32758: JS_STATIC_ASSERT(INT16_MAX > INT16_MIN);
32782: JS_STATIC_ASSERT(uint16_t(INT16_MAX) + uint16_t(1) == uint16_t(INT16_MIN));
32758: JS_STATIC_ASSERT(INT32_MAX > INT32_MIN);
32782: JS_STATIC_ASSERT(uint32_t(INT32_MAX) + uint32_t(1) == uint32_t(INT32_MIN));
32758: JS_STATIC_ASSERT(INT64_MAX > INT64_MIN);
32782: JS_STATIC_ASSERT(uint64_t(INT64_MAX) + uint64_t(1) == uint64_t(INT64_MIN));
32758: 
32758: JS_STATIC_ASSERT(INTPTR_MAX > INTPTR_MIN);
32782: JS_STATIC_ASSERT(uintptr_t(INTPTR_MAX) + uintptr_t(1) == uintptr_t(INTPTR_MIN));
32758: JS_STATIC_ASSERT(uintptr_t(-1) == UINTPTR_MAX);
32758: JS_STATIC_ASSERT(size_t(-1) == SIZE_MAX);
32758: JS_STATIC_ASSERT(PTRDIFF_MAX > PTRDIFF_MIN);
32758: JS_STATIC_ASSERT(ptrdiff_t(PTRDIFF_MAX) == PTRDIFF_MAX);
32758: JS_STATIC_ASSERT(ptrdiff_t(PTRDIFF_MIN) == PTRDIFF_MIN);
32782: JS_STATIC_ASSERT(uintptr_t(PTRDIFF_MAX) + uintptr_t(1) == uintptr_t(PTRDIFF_MIN));
32758: 
32780: #endif /* JS_HAVE_STDINT_H */
32758: 
    1: static JSBool
48470: num_isNaN(JSContext *cx, uintN argc, Value *vp)
    1: {
16519:     if (argc == 0) {
48470:         vp->setBoolean(true);
16519:         return JS_TRUE;
16519:     }
40828:     jsdouble x;
40828:     if (!ValueToNumber(cx, vp[2], &x))
40828:         return false;
48470:     vp->setBoolean(JSDOUBLE_IS_NaN(x));
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
48470: num_isFinite(JSContext *cx, uintN argc, Value *vp)
    1: {
16519:     if (argc == 0) {
48470:         vp->setBoolean(false);
16519:         return JS_TRUE;
16519:     }
40828:     jsdouble x;
40828:     if (!ValueToNumber(cx, vp[2], &x))
    1:         return JS_FALSE;
48470:     vp->setBoolean(JSDOUBLE_IS_FINITE(x));
    1:     return JS_TRUE;
    1: }
    1: 
20408: static JSBool
48470: num_parseFloat(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *str;
    1:     jsdouble d;
 4718:     const jschar *bp, *end, *ep;
    1: 
16519:     if (argc == 0) {
48470:         vp->setDouble(js_NaN);
16519:         return JS_TRUE;
16519:     }
 4127:     str = js_ValueToString(cx, vp[2]);
    1:     if (!str)
    1:         return JS_FALSE;
29366:     str->getCharsAndEnd(bp, end);
 4718:     if (!js_strtod(cx, bp, end, &ep, &d))
    1:         return JS_FALSE;
    1:     if (ep == bp) {
48470:         vp->setDouble(js_NaN);
    1:         return JS_TRUE;
    1:     }
48470:     vp->setNumber(d);
48470:     return JS_TRUE;
    1: }
    1: 
20408: #ifdef JS_TRACER
20915: static jsdouble FASTCALL
20915: ParseFloat(JSContext* cx, JSString* str)
20408: {
20408:     const jschar* bp;
20408:     const jschar* end;
20408:     const jschar* ep;
20408:     jsdouble d;
20408: 
29366:     str->getCharsAndEnd(bp, end);
20408:     if (!js_strtod(cx, bp, end, &ep, &d) || ep == bp)
20408:         return js_NaN;
20408:     return d;
20408: }
20408: #endif
20408: 
    1: /* See ECMA 15.1.2.2. */
20408: static JSBool
48470: num_parseInt(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *str;
    1:     jsdouble d;
 4718:     const jschar *bp, *end, *ep;
    1: 
16519:     if (argc == 0) {
48470:         vp->setDouble(js_NaN);
16519:         return JS_TRUE;
16519:     }
40828:     int32_t radix;
    1:     if (argc > 1) {
40828:         if (!ValueToECMAInt32(cx, vp[3], &radix))
    1:             return JS_FALSE;
    1:     } else {
    1:         radix = 0;
    1:     }
    1:     if (radix != 0 && (radix < 2 || radix > 36)) {
48470:         vp->setDouble(js_NaN);
    1:         return JS_TRUE;
    1:     }
    1: 
48470:     if (vp[2].isInt32() && (radix == 0 || radix == 10)) {
12605:         *vp = vp[2];
12605:         return JS_TRUE;
12605:     }
12605: 
 4127:     str = js_ValueToString(cx, vp[2]);
    1:     if (!str)
    1:         return JS_FALSE;
29366:     str->getCharsAndEnd(bp, end);
 4718:     if (!js_strtointeger(cx, bp, end, &ep, radix, &d))
    1:         return JS_FALSE;
    1:     if (ep == bp) {
48470:         vp->setDouble(js_NaN);
    1:         return JS_TRUE;
    1:     }
48470:     vp->setNumber(d);
48470:     return JS_TRUE;
    1: }
    1: 
20408: #ifdef JS_TRACER
20915: static jsdouble FASTCALL
20915: ParseInt(JSContext* cx, JSString* str)
20408: {
20408:     const jschar* bp;
20408:     const jschar* end;
20408:     const jschar* ep;
20408:     jsdouble d;
20408: 
29366:     str->getCharsAndEnd(bp, end);
20408:     if (!js_strtointeger(cx, bp, end, &ep, 0, &d) || ep == bp)
20408:         return js_NaN;
20408:     return d;
20408: }
20408: 
20915: static jsdouble FASTCALL
20915: ParseIntDouble(jsdouble d)
20408: {
20408:     if (!JSDOUBLE_IS_FINITE(d))
20408:         return js_NaN;
31493:     if (d > 0)
20408:         return floor(d);
31500:     if (d < 0)
31500:     	return -floor(-d);
31500:     return 0;
20408: }
20408: #endif
20408: 
    1: const char js_Infinity_str[]   = "Infinity";
    1: const char js_NaN_str[]        = "NaN";
    1: const char js_isNaN_str[]      = "isNaN";
    1: const char js_isFinite_str[]   = "isFinite";
    1: const char js_parseFloat_str[] = "parseFloat";
    1: const char js_parseInt_str[]   = "parseInt";
    1: 
20408: #ifdef JS_TRACER
20408: 
20930: JS_DEFINE_TRCINFO_2(num_parseInt,
39910:     (2, (static, DOUBLE, ParseInt, CONTEXT, STRING,     1, nanojit::ACC_NONE)),
39910:     (1, (static, DOUBLE, ParseIntDouble, DOUBLE,        1, nanojit::ACC_NONE)))
20408: 
20930: JS_DEFINE_TRCINFO_1(num_parseFloat,
39910:     (2, (static, DOUBLE, ParseFloat, CONTEXT, STRING,   1, nanojit::ACC_NONE)))
20408: 
20408: #endif /* JS_TRACER */
20408: 
    1: static JSFunctionSpec number_functions[] = {
16519:     JS_FN(js_isNaN_str,         num_isNaN,           1,0),
16519:     JS_FN(js_isFinite_str,      num_isFinite,        1,0),
32669:     JS_TN(js_parseFloat_str,    num_parseFloat,      1,0, &num_parseFloat_trcinfo),
32669:     JS_TN(js_parseInt_str,      num_parseInt,        2,0, &num_parseInt_trcinfo),
 4127:     JS_FS_END
    1: };
    1: 
48470: Class js_NumberClass = {
    1:     js_Number_str,
31452:     JSCLASS_HAS_RESERVED_SLOTS(1) | JSCLASS_HAS_CACHED_PROTO(JSProto_Number),
48470:     PropertyStub,     PropertyStub,     PropertyStub,     PropertyStub,
48470:     EnumerateStub,    ResolveStub,      ConvertStub,      NULL,
    1:     JSCLASS_NO_OPTIONAL_MEMBERS
    1: };
    1: 
    1: static JSBool
48470: Number(JSContext *cx, JSObject *obj, uintN argc, Value *argv, Value *rval)
    1: {
48470:     Value v;
    1:     if (argc != 0) {
48470:         if (!ValueToNumber(cx, &argv[0]))
12850:             return JS_FALSE;
12850:     } else {
48470:         argv[0].setInt32(0);
12850:     }
31452:     if (!JS_IsConstructing(cx))
48470:         *rval = argv[0];
31452:     else
48470:         obj->setPrimitiveThis(argv[0]);
31452:     return true;
    1: }
    1: 
    1: #if JS_HAS_TOSOURCE
    1: static JSBool
48470: num_toSource(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     char numBuf[DTOSTR_STANDARD_BUFFER_SIZE], *numStr;
    1:     char buf[64];
    1:     JSString *str;
    1: 
48470:     const Value *primp;
48470:     if (!js_GetPrimitiveThis(cx, vp, &js_NumberClass, &primp))
    1:         return JS_FALSE;
48470:     double d = primp->toNumber();
40339:     numStr = js_dtostr(JS_THREAD_DATA(cx)->dtoaState, numBuf, sizeof numBuf,
40339:                        DTOSTR_STANDARD, 0, d);
    1:     if (!numStr) {
    1:         JS_ReportOutOfMemory(cx);
    1:         return JS_FALSE;
    1:     }
    1:     JS_snprintf(buf, sizeof buf, "(new %s(%s))", js_NumberClass.name, numStr);
    1:     str = JS_NewStringCopyZ(cx, buf);
    1:     if (!str)
    1:         return JS_FALSE;
48470:     vp->setString(str);
    1:     return JS_TRUE;
    1: }
    1: #endif
    1: 
    1: /* The buf must be big enough for MIN_INT to fit including '-' and '\0'. */
23700: static char *
23700: IntToCString(jsint i, jsint base, char *buf, size_t bufSize)
    1: {
    1:     char *cp;
    1:     jsuint u;
    1: 
    1:     u = (i < 0) ? -i : i;
    1: 
    1:     cp = buf + bufSize; /* one past last buffer cell */
    1:     *--cp = '\0';       /* null terminate the string to be */
    1: 
    1:     /*
    1:      * Build the string from behind. We use multiply and subtraction
    1:      * instead of modulus because that's much faster.
    1:      */
20898:     switch (base) {
20898:     case 10:
    1:       do {
    1:           jsuint newu = u / 10;
    1:           *--cp = (char)(u - newu * 10) + '0';
    1:           u = newu;
    1:       } while (u != 0);
20898:       break;
20898:     case 16:
20898:       do {
20898:           jsuint newu = u / 16;
20898:           *--cp = "0123456789abcdef"[u - newu * 16];
20898:           u = newu;
20898:       } while (u != 0);
20898:       break;
20898:     default:
20898:       JS_ASSERT(base >= 2 && base <= 36);
20898:       do {
20898:           jsuint newu = u / base;
20898:           *--cp = "0123456789abcdefghijklmnopqrstuvwxyz"[u - newu * base];
20898:           u = newu;
20898:       } while (u != 0);
20898:       break;
20898:     }
    1:     if (i < 0)
    1:         *--cp = '-';
    1: 
 8439:     JS_ASSERT(cp >= buf);
    1:     return cp;
    1: }
    1: 
33937: static JSString * JS_FASTCALL
33937: js_NumberToStringWithBase(JSContext *cx, jsdouble d, jsint base);
33937: 
20408: static JSBool
48470: num_toString(JSContext *cx, uintN argc, Value *vp)
    1: {
48470:     const Value *primp;
48470:     if (!js_GetPrimitiveThis(cx, vp, &js_NumberClass, &primp))
    1:         return JS_FALSE;
48470:     double d = primp->toNumber();
40828:     int32_t base = 10;
48470:     if (argc != 0 && !vp[2].isUndefined()) {
40828:         if (!ValueToECMAInt32(cx, vp[2], &base))
    1:             return JS_FALSE;
40828: 
    1:         if (base < 2 || base > 36) {
    1:             char numBuf[12];
23700:             char *numStr = IntToCString(base, 10, numBuf, sizeof numBuf);
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_RADIX,
    1:                                  numStr);
    1:             return JS_FALSE;
    1:         }
    1:     }
48470:     JSString *str = js_NumberToStringWithBase(cx, d, base);
33937:     if (!str) {
    1:         JS_ReportOutOfMemory(cx);
    1:         return JS_FALSE;
    1:     }
48470:     vp->setString(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
48470: num_toLocaleString(JSContext *cx, uintN argc, Value *vp)
    1: {
39928:     size_t thousandsLength, decimalLength;
    1:     const char *numGrouping, *tmpGroup;
    1:     JSRuntime *rt;
48470:     JSString *str;
    1:     const char *num, *end, *tmpSrc;
 6152:     char *buf, *tmpDest;
16181:     const char *nint;
    1:     int digits, size, remainder, nrepeat;
    1: 
    1:     /*
    1:      * Create the string, move back to bytes to make string twiddling
    1:      * a bit easier and so we can insert platform charset seperators.
    1:      */
20408:     if (!num_toString(cx, 0, vp))
    1:         return JS_FALSE;
48470:     JS_ASSERT(vp->isString());
48470:     num = js_GetStringBytes(cx, vp->toString());
    1:     if (!num)
    1:         return JS_FALSE;
    1: 
16181:     /*
16181:      * Find the first non-integer value, whether it be a letter as in
16183:      * 'Infinity', a decimal point, or an 'e' from exponential notation.
16181:      */
16181:     nint = num;
16181:     if (*nint == '-')
16181:         nint++;
16181:     while (*nint >= '0' && *nint <= '9')
16181:         nint++;
16181:     digits = nint - num;
    1:     end = num + digits;
16181:     if (!digits)
16181:         return JS_TRUE;
    1: 
    1:     rt = cx->runtime;
    1:     thousandsLength = strlen(rt->thousandsSeparator);
    1:     decimalLength = strlen(rt->decimalSeparator);
    1: 
    1:     /* Figure out how long resulting string will be. */
16181:     size = digits + (*nint ? strlen(nint + 1) + 1 : 0);
16181:     if (*nint == '.')
16181:         size += decimalLength;
    1: 
    1:     numGrouping = tmpGroup = rt->numGrouping;
    1:     remainder = digits;
    1:     if (*num == '-')
    1:         remainder--;
    1: 
    1:     while (*tmpGroup != CHAR_MAX && *tmpGroup != '\0') {
    1:         if (*tmpGroup >= remainder)
    1:             break;
    1:         size += thousandsLength;
    1:         remainder -= *tmpGroup;
    1:         tmpGroup++;
    1:     }
    1:     if (*tmpGroup == '\0' && *numGrouping != '\0') {
    1:         nrepeat = (remainder - 1) / tmpGroup[-1];
    1:         size += thousandsLength * nrepeat;
    1:         remainder -= nrepeat * tmpGroup[-1];
    1:     } else {
    1:         nrepeat = 0;
    1:     }
    1:     tmpGroup--;
    1: 
30851:     buf = (char *)cx->malloc(size + 1);
    1:     if (!buf)
    1:         return JS_FALSE;
    1: 
    1:     tmpDest = buf;
    1:     tmpSrc = num;
    1: 
    1:     while (*tmpSrc == '-' || remainder--)
    1:         *tmpDest++ = *tmpSrc++;
    1:     while (tmpSrc < end) {
    1:         strcpy(tmpDest, rt->thousandsSeparator);
    1:         tmpDest += thousandsLength;
    1:         memcpy(tmpDest, tmpSrc, *tmpGroup);
    1:         tmpDest += *tmpGroup;
    1:         tmpSrc += *tmpGroup;
    1:         if (--nrepeat < 0)
    1:             tmpGroup--;
    1:     }
    1: 
16181:     if (*nint == '.') {
    1:         strcpy(tmpDest, rt->decimalSeparator);
    1:         tmpDest += decimalLength;
16181:         strcpy(tmpDest, nint + 1);
    1:     } else {
16181:         strcpy(tmpDest, nint);
    1:     }
    1: 
    1:     if (cx->localeCallbacks && cx->localeCallbacks->localeToUnicode)
48470:         return cx->localeCallbacks->localeToUnicode(cx, buf, Jsvalify(vp));
    1: 
    1:     str = JS_NewString(cx, buf, size);
    1:     if (!str) {
30851:         cx->free(buf);
    1:         return JS_FALSE;
    1:     }
    1: 
48470:     vp->setString(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
48470: num_valueOf(JSContext *cx, uintN argc, Value *vp)
    1: {
48470:     if (vp[1].isNumber()) {
48470:         *vp = vp[1];
    1:         return JS_TRUE;
    1:     }
48470:     JSObject *obj = ComputeThisFromVp(cx, vp);
48470:     if (!InstanceOf(cx, obj, &js_NumberClass, vp + 2))
    1:         return JS_FALSE;
40901:     *vp = obj->getPrimitiveThis();
    1:     return JS_TRUE;
    1: }
    1: 
    1: 
    1: #define MAX_PRECISION 100
    1: 
    1: static JSBool
 4127: num_to(JSContext *cx, JSDToStrMode zeroArgMode, JSDToStrMode oneArgMode,
 4127:        jsint precisionMin, jsint precisionMax, jsint precisionOffset,
48470:        uintN argc, Value *vp)
    1: {
 4127:     /* Use MAX_PRECISION+1 because precisionOffset can be 1. */
 4127:     char buf[DTOSTR_VARIABLE_BUFFER_SIZE(MAX_PRECISION+1)];
 4127:     char *numStr;
 4127: 
48470:     const Value *primp;
48470:     if (!js_GetPrimitiveThis(cx, vp, &js_NumberClass, &primp))
    1:         return JS_FALSE;
48470:     double d = primp->toNumber();
    1: 
48470:     double precision;
 4127:     if (argc == 0) {
    1:         precision = 0.0;
    1:         oneArgMode = zeroArgMode;
    1:     } else {
40828:         if (!ValueToNumber(cx, vp[2], &precision))
    1:             return JS_FALSE;
    1:         precision = js_DoubleToInteger(precision);
    1:         if (precision < precisionMin || precision > precisionMax) {
40339:             numStr = js_dtostr(JS_THREAD_DATA(cx)->dtoaState, buf, sizeof buf,
40339:                                DTOSTR_STANDARD, 0, precision);
    1:             if (!numStr)
    1:                 JS_ReportOutOfMemory(cx);
    1:             else
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_PRECISION_RANGE, numStr);
    1:             return JS_FALSE;
    1:         }
    1:     }
    1: 
40339:     numStr = js_dtostr(JS_THREAD_DATA(cx)->dtoaState, buf, sizeof buf,
40339:                        oneArgMode, (jsint)precision + precisionOffset, d);
    1:     if (!numStr) {
    1:         JS_ReportOutOfMemory(cx);
    1:         return JS_FALSE;
    1:     }
48470:     JSString *str = JS_NewStringCopyZ(cx, numStr);
    1:     if (!str)
    1:         return JS_FALSE;
48470:     vp->setString(str);
    1:     return JS_TRUE;
    1: }
    1: 
 4127: /*
 4127:  * In the following three implementations, we allow a larger range of precision
 4127:  * than ECMA requires; this is permitted by ECMA-262.
 4127:  */
    1: static JSBool
48470: num_toFixed(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return num_to(cx, DTOSTR_FIXED, DTOSTR_FIXED, -20, MAX_PRECISION, 0,
 4127:                   argc, vp);
    1: }
    1: 
    1: static JSBool
48470: num_toExponential(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     return num_to(cx, DTOSTR_STANDARD_EXPONENTIAL, DTOSTR_EXPONENTIAL, 0,
 4127:                   MAX_PRECISION, 1, argc, vp);
    1: }
    1: 
    1: static JSBool
48470: num_toPrecision(JSContext *cx, uintN argc, Value *vp)
    1: {
48470:     if (argc == 0 || vp[2].isUndefined())
20408:         return num_toString(cx, 0, vp);
 4127:     return num_to(cx, DTOSTR_STANDARD, DTOSTR_PRECISION, 1, MAX_PRECISION, 0,
 4127:                   argc, vp);
    1: }
    1: 
20408: #ifdef JS_TRACER
20408: 
33937: JS_DEFINE_TRCINFO_2(num_toString,
39910:     (2, (extern, STRING_RETRY, js_NumberToString,         CONTEXT, THIS_DOUBLE,        1,
39910:          nanojit::ACC_NONE)),
39910:     (3, (static, STRING_RETRY, js_NumberToStringWithBase, CONTEXT, THIS_DOUBLE, INT32, 1,
39910:          nanojit::ACC_NONE)))
20408: 
20408: #endif /* JS_TRACER */
20408: 
    1: static JSFunctionSpec number_methods[] = {
    1: #if JS_HAS_TOSOURCE
16519:     JS_FN(js_toSource_str,       num_toSource,          0,JSFUN_THISP_NUMBER),
    1: #endif
32669:     JS_TN(js_toString_str,       num_toString,          1,JSFUN_THISP_NUMBER, &num_toString_trcinfo),
16519:     JS_FN(js_toLocaleString_str, num_toLocaleString,    0,JSFUN_THISP_NUMBER),
16519:     JS_FN(js_valueOf_str,        num_valueOf,           0,JSFUN_THISP_NUMBER),
20587:     JS_FN(js_toJSON_str,         num_valueOf,           0,JSFUN_THISP_NUMBER),
16519:     JS_FN("toFixed",             num_toFixed,           1,JSFUN_THISP_NUMBER),
16519:     JS_FN("toExponential",       num_toExponential,     1,JSFUN_THISP_NUMBER),
16519:     JS_FN("toPrecision",         num_toPrecision,       1,JSFUN_THISP_NUMBER),
 4127:     JS_FS_END
    1: };
    1: 
    1: /* NB: Keep this in synch with number_constants[]. */
    1: enum nc_slot {
    1:     NC_NaN,
    1:     NC_POSITIVE_INFINITY,
    1:     NC_NEGATIVE_INFINITY,
    1:     NC_MAX_VALUE,
    1:     NC_MIN_VALUE,
    1:     NC_LIMIT
    1: };
    1: 
    1: /*
    1:  * Some to most C compilers forbid spelling these at compile time, or barf
    1:  * if you try, so all but MAX_VALUE are set up by js_InitRuntimeNumberState
    1:  * using union jsdpun.
    1:  */
    1: static JSConstDoubleSpec number_constants[] = {
    1:     {0,                         js_NaN_str,          0,{0,0,0}},
    1:     {0,                         "POSITIVE_INFINITY", 0,{0,0,0}},
    1:     {0,                         "NEGATIVE_INFINITY", 0,{0,0,0}},
    1:     {1.7976931348623157E+308,   "MAX_VALUE",         0,{0,0,0}},
    1:     {0,                         "MIN_VALUE",         0,{0,0,0}},
    1:     {0,0,0,{0,0,0}}
    1: };
    1: 
18295: jsdouble js_NaN;
34372: jsdouble js_PositiveInfinity;
34372: jsdouble js_NegativeInfinity;
32599: 
39733: #if (defined __GNUC__ && defined __i386__) || \
39733:     (defined __SUNPRO_CC && defined __i386)
    1: 
    1: /*
    1:  * Set the exception mask to mask all exceptions and set the FPU precision
32599:  * to 53 bit mantissa (64 bit doubles).
    1:  */
32599: inline void FIX_FPU() {
32599:     short control;
32599:     asm("fstcw %0" : "=m" (control) : );
32599:     control &= ~0x300; // Lower bits 8 and 9 (precision control).
32599:     control |= 0x2f3;  // Raise bits 0-5 (exception masks) and 9 (64-bit precision).
32599:     asm("fldcw %0" : : "m" (control) );
32599: }
    1: 
    1: #else
    1: 
    1: #define FIX_FPU() ((void)0)
    1: 
    1: #endif
    1: 
    1: JSBool
    1: js_InitRuntimeNumberState(JSContext *cx)
    1: {
34372:     JSRuntime *rt = cx->runtime;
    1: 
    1:     FIX_FPU();
    1: 
34372:     jsdpun u;
48497:     u.s.hi = JSDOUBLE_HI32_NAN;
48497:     u.s.lo = JSDOUBLE_LO32_NAN;
18295:     number_constants[NC_NaN].dval = js_NaN = u.d;
48470:     rt->NaNValue.setDouble(u.d);
    1: 
    1:     u.s.hi = JSDOUBLE_HI32_EXPMASK;
    1:     u.s.lo = 0x00000000;
34372:     number_constants[NC_POSITIVE_INFINITY].dval = js_PositiveInfinity = u.d;
48470:     rt->positiveInfinityValue.setDouble(u.d);
    1: 
    1:     u.s.hi = JSDOUBLE_HI32_SIGNBIT | JSDOUBLE_HI32_EXPMASK;
    1:     u.s.lo = 0x00000000;
34372:     number_constants[NC_NEGATIVE_INFINITY].dval = js_NegativeInfinity = u.d;
48470:     rt->negativeInfinityValue.setDouble(u.d);
    1: 
    1:     u.s.hi = 0;
    1:     u.s.lo = 1;
    1:     number_constants[NC_MIN_VALUE].dval = u.d;
    1: 
40165: #ifndef HAVE_LOCALECONV
40165:     rt->thousandsSeparator = JS_strdup(cx, "'");
40165:     rt->decimalSeparator = JS_strdup(cx, ".");
40165:     rt->numGrouping = JS_strdup(cx, "\3\0");
40165: #else
34372:     struct lconv *locale = localeconv();
    1:     rt->thousandsSeparator =
    1:         JS_strdup(cx, locale->thousands_sep ? locale->thousands_sep : "'");
    1:     rt->decimalSeparator =
    1:         JS_strdup(cx, locale->decimal_point ? locale->decimal_point : ".");
    1:     rt->numGrouping =
    1:         JS_strdup(cx, locale->grouping ? locale->grouping : "\3\0");
40165: #endif
    1: 
    1:     return rt->thousandsSeparator && rt->decimalSeparator && rt->numGrouping;
    1: }
    1: 
    1: void
    1: js_FinishRuntimeNumberState(JSContext *cx)
    1: {
    1:     JSRuntime *rt = cx->runtime;
    1: 
30851:     cx->free((void *) rt->thousandsSeparator);
30851:     cx->free((void *) rt->decimalSeparator);
30851:     cx->free((void *) rt->numGrouping);
    1:     rt->thousandsSeparator = rt->decimalSeparator = rt->numGrouping = NULL;
    1: }
    1: 
    1: JSObject *
    1: js_InitNumberClass(JSContext *cx, JSObject *obj)
    1: {
    1:     JSObject *proto, *ctor;
    1:     JSRuntime *rt;
    1: 
    1:     /* XXX must do at least once per new thread, so do it per JSContext... */
    1:     FIX_FPU();
    1: 
    1:     if (!JS_DefineFunctions(cx, obj, number_functions))
    1:         return NULL;
    1: 
48470:     proto = js_InitClass(cx, obj, NULL, &js_NumberClass, Number, 1,
    1:                          NULL, number_methods, NULL, NULL);
    1:     if (!proto || !(ctor = JS_GetConstructor(cx, proto)))
    1:         return NULL;
48470:     proto->setPrimitiveThis(Int32Value(0));
    1:     if (!JS_DefineConstDoubles(cx, ctor, number_constants))
    1:         return NULL;
    1: 
    1:     /* ECMA 15.1.1.1 */
    1:     rt = cx->runtime;
48470:     if (!JS_DefineProperty(cx, obj, js_NaN_str, Jsvalify(rt->NaNValue),
48470:                            JS_PropertyStub, JS_PropertyStub,
37031:                            JSPROP_PERMANENT | JSPROP_READONLY)) {
    1:         return NULL;
    1:     }
    1: 
    1:     /* ECMA 15.1.1.2 */
48470:     if (!JS_DefineProperty(cx, obj, js_Infinity_str, Jsvalify(rt->positiveInfinityValue),
37031:                            JS_PropertyStub, JS_PropertyStub,
37031:                            JSPROP_PERMANENT | JSPROP_READONLY)) {
    1:         return NULL;
    1:     }
    1:     return proto;
    1: }
    1: 
23700: /*
23700:  * Convert a number to C string. The buf must be large enough to accommodate
23700:  * the result, including '-' and '\0', if base == 10 or d is an integer that
23700:  * fits in 32 bits. The caller must free the resulting pointer if it does not
23700:  * point into buf.
23700:  */
23700: static char *
23700: NumberToCString(JSContext *cx, jsdouble d, jsint base, char *buf, size_t bufSize)
    1: {
48470:     int32_t i;
    1:     char *numStr;
    1: 
 8439:     JS_ASSERT(bufSize >= DTOSTR_STANDARD_BUFFER_SIZE);
48470:     if (JSDOUBLE_IS_INT32(d, &i)) {
23700:         numStr = IntToCString(i, base, buf, bufSize);
    1:     } else {
20898:         if (base == 10)
40339:             numStr = js_dtostr(JS_THREAD_DATA(cx)->dtoaState, buf, bufSize,
40339:                                DTOSTR_STANDARD, 0, d);
20898:         else
40339:             numStr = js_dtobasestr(JS_THREAD_DATA(cx)->dtoaState, base, d);
    1:         if (!numStr) {
    1:             JS_ReportOutOfMemory(cx);
    1:             return NULL;
    1:         }
    1:     }
 8439:     return numStr;
    1: }
    1: 
42641: JSString * JS_FASTCALL
42641: js_IntToString(JSContext *cx, jsint i)
42641: {
42641:     if (jsuint(i) < INT_STRING_LIMIT)
42641:         return JSString::intString(i);
42641: 
42641:     char buf[12];
42641:     return JS_NewStringCopyZ(cx, IntToCString(i, 10, buf, sizeof buf));
42641: }
42641: 
33937: static JSString * JS_FASTCALL
33937: js_NumberToStringWithBase(JSContext *cx, jsdouble d, jsint base)
20409: {
23700:     /*
23700:      * The longest possible result here that would need to fit in buf is
23700:      * (-0x80000000).toString(2), which has length 33.  (This can produce
23700:      * longer results, but in those cases buf is not used; see comment at
23700:      * NumberToCString.)
23700:      */
23700:     char buf[34];
20409:     char *numStr;
23700:     JSString *s;
20409: 
33937:     /*
33937:      * Caller is responsible for error reporting. When called from trace,
33937:      * returning NULL here will cause us to fall of trace and then retry
33937:      * from the interpreter (which will report the error).
33937:      */
20898:     if (base < 2 || base > 36)
20898:         return NULL;
33937: 
48470:     int32_t i;
48470:     if (JSDOUBLE_IS_INT32(d, &i)) {
33937:         if (base == 10 && jsuint(i) < INT_STRING_LIMIT)
33937:             return JSString::intString(i);
33937:         if (jsuint(i) < jsuint(base)) {
33937:             if (i < 10)
33937:                 return JSString::intString(i);
39928:             return JSString::unitString(jschar('a' + i - 10));
33937:         }
33937:     }
41847:     JSThreadData *data = JS_THREAD_DATA(cx);
41847:     if (data->dtoaCache.s && data->dtoaCache.base == base && data->dtoaCache.d == d)
41847:         return data->dtoaCache.s;
23700:     numStr = NumberToCString(cx, d, base, buf, sizeof buf);
20409:     if (!numStr)
20409:         return NULL;
23700:     s = JS_NewStringCopyZ(cx, numStr);
23700:     if (!(numStr >= buf && numStr < buf + sizeof buf))
30851:         js_free(numStr);
41847:     data->dtoaCache.base = base;
41847:     data->dtoaCache.d = d;
41847:     data->dtoaCache.s = s;
23700:     return s;
20409: }
20409: 
18078: JSString * JS_FASTCALL
    1: js_NumberToString(JSContext *cx, jsdouble d)
    1: {
33937:     return js_NumberToStringWithBase(cx, d, 10);
    1: }
    1: 
30023: JSBool JS_FASTCALL
48470: js_NumberValueToCharBuffer(JSContext *cx, const Value &v, JSCharBuffer &cb)
30023: {
30023:     /* Convert to C-string. */
30023:     static const size_t arrSize = DTOSTR_STANDARD_BUFFER_SIZE;
30023:     char arr[arrSize];
30023:     const char *cstr;
48470:     if (v.isInt32()) {
48470:         cstr = IntToCString(v.toInt32(), 10, arr, arrSize);
30023:     } else {
40339:         cstr = js_dtostr(JS_THREAD_DATA(cx)->dtoaState, arr, arrSize,
48470:                          DTOSTR_STANDARD, 0, v.toDouble());
30023:     }
30023:     if (!cstr)
30023:         return JS_FALSE;
30023: 
30023:     /*
30023:      * Inflate to jschar string.  The input C-string characters are < 127, so
30023:      * even if jschars are UTF-8, all chars should map to one jschar.
30023:      */
30023:     size_t cstrlen = strlen(cstr);
30023:     JS_ASSERT(cstrlen < arrSize);
31925:     size_t sizeBefore = cb.length();
48470:     if (!cb.growByUninitialized(cstrlen))
30023:         return JS_FALSE;
31890:     jschar *appendBegin = cb.begin() + sizeBefore;
30023: #ifdef DEBUG
30023:     size_t oldcstrlen = cstrlen;
30023:     JSBool ok =
30023: #endif
30023:         js_InflateStringToBuffer(cx, cstr, cstrlen, appendBegin, &cstrlen);
30023:     JS_ASSERT(ok && cstrlen == oldcstrlen);
30023:     return JS_TRUE;
30023: }
30023: 
40828: namespace js {
40828: 
48470: bool
48470: ValueToNumberSlow(JSContext *cx, Value v, double *out)
    1: {
48470:     JS_ASSERT(!v.isNumber());
40828:     goto skip_int_double;
40828:     for (;;) {
48470:         if (v.isNumber()) {
48470:             *out = v.toNumber();
48470:             return true;
40828:         }
40828:       skip_int_double:
48470:         if (v.isString()) {
48470:             jsdouble d = StringToNumberType<jsdouble>(cx, v.toString());
39942:             if (JSDOUBLE_IS_NaN(d))
12694:                 break;
40828:             *out = d;
48470:             return true;
12581:         }
48470:         if (v.isBoolean()) {
48470:             if (v.toBoolean()) {
40828:                 *out = 1.0;
48470:                 return true;
39942:             }
40828:             *out = 0.0;
48470:             return true;
12850:         }
48470:         if (v.isNull()) {
40828:             *out = 0.0;
48470:             return true;
12694:         }
48470:         if (v.isUndefined())
12694:             break;
12694: 
48470:         JS_ASSERT(v.isObject());
48470:         if (!DefaultValue(cx, &v.toObject(), JSTYPE_NUMBER, &v))
48470:             return false;
48470:         if (v.isObject())
12694:             break;
12694:     }
12694: 
40828:     *out = js_NaN;
48470:     return true;
12581: }
12581: 
40828: bool
48470: ValueToECMAInt32Slow(JSContext *cx, const Value &v, int32_t *out)
    1: {
48470:     JS_ASSERT(!v.isInt32());
    1:     jsdouble d;
48470:     if (v.isDouble()) {
48470:         d = v.toDouble();
12681:     } else {
48470:         if (!ValueToNumberSlow(cx, v, &d))
40828:             return false;
12681:     }
40828:     *out = js_DoubleToECMAInt32(d);
40828:     return true;
    1: }
    1: 
40828: bool
48470: ValueToECMAUint32Slow(JSContext *cx, const Value &v, uint32_t *out)
    1: {
48470:     JS_ASSERT(!v.isInt32());
    1:     jsdouble d;
48470:     if (v.isDouble()) {
48470:         d = v.toDouble();
12681:     } else {
48470:         if (!ValueToNumberSlow(cx, v, &d))
40828:             return false;
12681:     }
40828:     *out = js_DoubleToECMAUint32(d);
40828:     return true;
    1: }
    1: 
40828: }  /* namespace js */
40828: 
 9613: uint32
 9613: js_DoubleToECMAUint32(jsdouble d)
    1: {
12681:     int32 i;
    1:     JSBool neg;
12681:     jsdouble two32;
    1: 
12681:     if (!JSDOUBLE_IS_FINITE(d))
 9613:         return 0;
    1: 
12681:     /*
12681:      * We check whether d fits int32, not uint32, as all but the ">>>" bit
12681:      * manipulation bytecode stores the result as int, not uint. When the
48470:      * result does not fit int Value, it will be stored as a negative double.
12681:      */
12681:     i = (int32) d;
12681:     if ((jsdouble) i == d)
12681:         return (int32)i;
    1: 
    1:     neg = (d < 0);
    1:     d = floor(neg ? -d : d);
    1:     d = neg ? -d : d;
    1: 
12681:     two32 = 4294967296.0;
    1:     d = fmod(d, two32);
    1: 
11278:     return (uint32) (d >= 0 ? d : d + two32);
    1: }
    1: 
40828: namespace js {
40828: 
40828: bool
48470: ValueToInt32Slow(JSContext *cx, const Value &v, int32_t *out)
    1: {
48470:     JS_ASSERT(!v.isInt32());
    1:     jsdouble d;
48470:     if (v.isDouble()) {
48470:         d = v.toDouble();
48470:     } else if (!ValueToNumberSlow(cx, v, &d)) {
40828:         return false;
40828:     }
    1: 
    1:     if (JSDOUBLE_IS_NaN(d) || d <= -2147483649.0 || 2147483648.0 <= d) {
    1:         js_ReportValueError(cx, JSMSG_CANT_CONVERT,
    1:                             JSDVG_SEARCH_STACK, v, NULL);
40828:         return false;
    1:     }
40828:     *out = (int32) floor(d + 0.5);  /* Round to nearest */
40828:     return true;
    1: }
    1: 
40828: bool
48470: ValueToUint16Slow(JSContext *cx, const Value &v, uint16_t *out)
    1: {
48470:     JS_ASSERT(!v.isInt32());
    1:     jsdouble d;
48470:     if (v.isDouble()) {
48470:         d = v.toDouble();
48470:     } else if (!ValueToNumberSlow(cx, v, &d)) {
40828:         return false;
40828:     }
    1: 
40828:     if (d == 0 || !JSDOUBLE_IS_FINITE(d)) {
40828:         *out = 0;
40828:         return true;
40828:     }
12850: 
40828:     uint16 u = (uint16) d;
40828:     if ((jsdouble)u == d) {
40828:         *out = u;
40828:         return true;
40828:     }
40828: 
40828:     bool neg = (d < 0);
    1:     d = floor(neg ? -d : d);
    1:     d = neg ? -d : d;
40828:     jsuint m = JS_BIT(16);
    1:     d = fmod(d, (double) m);
    1:     if (d < 0)
    1:         d += m;
40828:     *out = (uint16_t) d;
40828:     return true;
12850: }
40828: 
40828: }  /* namespace js */
    1: 
    1: JSBool
 4281: js_strtod(JSContext *cx, const jschar *s, const jschar *send,
 4281:           const jschar **ep, jsdouble *dp)
    1: {
 4281:     const jschar *s1;
 4281:     size_t length, i;
    1:     char cbuf[32];
    1:     char *cstr, *istr, *estr;
    1:     JSBool negative;
    1:     jsdouble d;
 4281: 
 4281:     s1 = js_SkipWhiteSpace(s, send);
 4281:     length = send - s1;
    1: 
    1:     /* Use cbuf to avoid malloc */
    1:     if (length >= sizeof cbuf) {
30851:         cstr = (char *) cx->malloc(length + 1);
    1:         if (!cstr)
    1:            return JS_FALSE;
    1:     } else {
    1:         cstr = cbuf;
    1:     }
    1: 
 4281:     for (i = 0; i != length; i++) {
 4281:         if (s1[i] >> 8)
    1:             break;
    1:         cstr[i] = (char)s1[i];
    1:     }
 4281:     cstr[i] = 0;
    1: 
    1:     istr = cstr;
    1:     if ((negative = (*istr == '-')) != 0 || *istr == '+')
    1:         istr++;
32609:     if (*istr == 'I' && !strncmp(istr, js_Infinity_str, sizeof js_Infinity_str - 1)) {
34372:         d = negative ? js_NegativeInfinity : js_PositiveInfinity;
    1:         estr = istr + 8;
    1:     } else {
    1:         int err;
40339:         d = js_strtod_harder(JS_THREAD_DATA(cx)->dtoaState, cstr, &estr, &err);
    1:         if (d == HUGE_VAL)
34372:             d = js_PositiveInfinity;
    1:         else if (d == -HUGE_VAL)
34372:             d = js_NegativeInfinity;
    1:     }
    1: 
    1:     i = estr - cstr;
    1:     if (cstr != cbuf)
30851:         cx->free(cstr);
    1:     *ep = i ? s1 + i : s;
    1:     *dp = d;
    1:     return JS_TRUE;
    1: }
    1: 
    1: struct BinaryDigitReader
    1: {
    1:     uintN base;                 /* Base of number; must be a power of 2 */
    1:     uintN digit;                /* Current digit value in radix given by base */
    1:     uintN digitMask;            /* Mask to extract the next bit from digit */
    1:     const jschar *digits;       /* Pointer to the remaining digits */
    1:     const jschar *end;          /* Pointer to first non-digit */
    1: };
    1: 
    1: /* Return the next binary digit from the number or -1 if done */
    1: static intN GetNextBinaryDigit(struct BinaryDigitReader *bdr)
    1: {
    1:     intN bit;
    1: 
    1:     if (bdr->digitMask == 0) {
    1:         uintN c;
    1: 
    1:         if (bdr->digits == bdr->end)
    1:             return -1;
    1: 
    1:         c = *bdr->digits++;
    1:         if ('0' <= c && c <= '9')
    1:             bdr->digit = c - '0';
    1:         else if ('a' <= c && c <= 'z')
    1:             bdr->digit = c - 'a' + 10;
29366:         else
29366:             bdr->digit = c - 'A' + 10;
    1:         bdr->digitMask = bdr->base >> 1;
    1:     }
    1:     bit = (bdr->digit & bdr->digitMask) != 0;
    1:     bdr->digitMask >>= 1;
    1:     return bit;
    1: }
    1: 
    1: JSBool
 4281: js_strtointeger(JSContext *cx, const jschar *s, const jschar *send,
 4281:                 const jschar **ep, jsint base, jsdouble *dp)
    1: {
 4281:     const jschar *s1, *start;
    1:     JSBool negative;
    1:     jsdouble value;
    1: 
 4281:     s1 = js_SkipWhiteSpace(s, send);
 4281:     if (s1 == send)
 4281:         goto no_digits;
 4281:     if ((negative = (*s1 == '-')) != 0 || *s1 == '+') {
    1:         s1++;
 4281:         if (s1 == send)
 4281:             goto no_digits;
 4281:     }
    1: 
    1:     if (base == 0) {
    1:         /* No base supplied, or some base that evaluated to 0. */
    1:         if (*s1 == '0') {
    1:             /* It's either hex or octal; only increment char if str isn't '0' */
 4281:             if (s1 + 1 != send && (s1[1] == 'X' || s1[1] == 'x')) {
 4281:                 base = 16;
    1:                 s1 += 2;
 4281:                 if (s1 == send)
 4281:                     goto no_digits;
 4281:             } else {
    1:                 base = 8;
    1:             }
    1:         } else {
    1:             base = 10; /* Default to decimal. */
    1:         }
 4281:     } else if (base == 16) {
    1:         /* If base is 16, ignore hex prefix. */
 4281:         if (*s1 == '0' && s1 + 1 != send && (s1[1] == 'X' || s1[1] == 'x')) {
    1:             s1 += 2;
 4281:             if (s1 == send)
 4281:                 goto no_digits;
 4281:         }
    1:     }
    1: 
    1:     /*
    1:      * Done with the preliminaries; find some prefix of the string that's
    1:      * a number in the given base.
    1:      */
 4281:     JS_ASSERT(s1 < send);
 4281:     start = s1;
    1:     value = 0.0;
 4281:     do {
    1:         uintN digit;
    1:         jschar c = *s1;
    1:         if ('0' <= c && c <= '9')
    1:             digit = c - '0';
    1:         else if ('a' <= c && c <= 'z')
    1:             digit = c - 'a' + 10;
    1:         else if ('A' <= c && c <= 'Z')
    1:             digit = c - 'A' + 10;
    1:         else
    1:             break;
    1:         if (digit >= (uintN)base)
    1:             break;
    1:         value = value * base + digit;
 4281:     } while (++s1 != send);
    1: 
    1:     if (value >= 9007199254740992.0) {
    1:         if (base == 10) {
    1:             /*
    1:              * If we're accumulating a decimal number and the number is >=
    1:              * 2^53, then the result from the repeated multiply-add above may
40339:              * be inaccurate.  Call js_strtod_harder to get the correct answer.
    1:              */
    1:             size_t i;
    1:             size_t length = s1 - start;
30851:             char *cstr = (char *) cx->malloc(length + 1);
    1:             char *estr;
    1:             int err=0;
    1: 
    1:             if (!cstr)
    1:                 return JS_FALSE;
    1:             for (i = 0; i != length; i++)
    1:                 cstr[i] = (char)start[i];
    1:             cstr[length] = 0;
    1: 
40339:             value = js_strtod_harder(JS_THREAD_DATA(cx)->dtoaState, cstr, &estr, &err);
    1:             if (err == JS_DTOA_ENOMEM) {
    1:                 JS_ReportOutOfMemory(cx);
30851:                 cx->free(cstr);
    1:                 return JS_FALSE;
    1:             }
    1:             if (err == JS_DTOA_ERANGE && value == HUGE_VAL)
34372:                 value = js_PositiveInfinity;
30851:             cx->free(cstr);
    1:         } else if ((base & (base - 1)) == 0) {
    1:             /*
    1:              * The number may also be inaccurate for power-of-two bases.  This
    1:              * happens if the addition in value * base + digit causes a round-
    1:              * down to an even least significant mantissa bit when the first
    1:              * dropped bit is a one.  If any of the following digits in the
    1:              * number (which haven't been added in yet) are nonzero, then the
    1:              * correct action would have been to round up instead of down.  An
    1:              * example occurs when reading the number 0x1000000000000081, which
    1:              * rounds to 0x1000000000000000 instead of 0x1000000000000100.
    1:              */
    1:             struct BinaryDigitReader bdr;
    1:             intN bit, bit2;
    1:             intN j;
    1: 
    1:             bdr.base = base;
32770:             bdr.digit = 0;      // shut GCC up
    1:             bdr.digitMask = 0;
    1:             bdr.digits = start;
    1:             bdr.end = s1;
    1:             value = 0.0;
    1: 
    1:             /* Skip leading zeros. */
    1:             do {
    1:                 bit = GetNextBinaryDigit(&bdr);
    1:             } while (bit == 0);
    1: 
    1:             if (bit == 1) {
    1:                 /* Gather the 53 significant bits (including the leading 1) */
    1:                 value = 1.0;
    1:                 for (j = 52; j; j--) {
    1:                     bit = GetNextBinaryDigit(&bdr);
    1:                     if (bit < 0)
    1:                         goto done;
    1:                     value = value*2 + bit;
    1:                 }
    1:                 /* bit2 is the 54th bit (the first dropped from the mantissa) */
    1:                 bit2 = GetNextBinaryDigit(&bdr);
    1:                 if (bit2 >= 0) {
    1:                     jsdouble factor = 2.0;
    1:                     intN sticky = 0;  /* sticky is 1 if any bit beyond the 54th is 1 */
    1:                     intN bit3;
    1: 
    1:                     while ((bit3 = GetNextBinaryDigit(&bdr)) >= 0) {
    1:                         sticky |= bit3;
    1:                         factor *= 2;
    1:                     }
    1:                     value += bit2 & (bit | sticky);
    1:                     value *= factor;
    1:                 }
    1:               done:;
    1:             }
    1:         }
    1:     }
    1:     /* We don't worry about inaccurate numbers for any other base. */
    1: 
    1:     if (s1 == start) {
 4281:       no_digits:
    1:         *dp = 0.0;
    1:         *ep = s;
    1:     } else {
    1:         *dp = negative ? -value : value;
    1:         *ep = s1;
    1:     }
    1:     return JS_TRUE;
    1: }
