    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <pavlov@netscape.com>
30324:  *   Ehsan Akhgari <ehsan.akhgari@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
50546: #ifndef imgLoader_h__
50546: #define imgLoader_h__
50546: 
    1: #include "imgILoader.h"
18827: #include "imgICache.h"
18827: #include "nsWeakReference.h"
    1: #include "nsIContentSniffer.h"
18827: #include "nsRefPtrHashtable.h"
18827: #include "nsExpirationTracker.h"
18827: #include "nsAutoPtr.h"
18827: #include "prtypes.h"
18827: #include "imgRequest.h"
30324: #include "nsIObserverService.h"
42509: #include "nsIChannelPolicy.h"
    1: 
    1: #ifdef LOADER_THREADSAFE
    1: #include "prlock.h"
    1: #endif
    1: 
    1: class imgRequest;
    1: class imgRequestProxy;
    1: class imgIRequest;
    1: class imgIDecoderObserver;
    1: class nsILoadGroup;
    1: 
18827: class imgCacheEntry
18827: {
18827: public:
72903:   imgCacheEntry(imgRequest *request, PRBool mustValidateIfExpired = PR_FALSE);
25078:   ~imgCacheEntry();
18827: 
18827:   nsrefcnt AddRef()
18827:   {
18827:     NS_PRECONDITION(PRInt32(mRefCnt) >= 0, "illegal refcnt");
25078:     NS_ABORT_IF_FALSE(_mOwningThread.GetThread() == PR_GetCurrentThread(), "imgCacheEntry addref isn't thread-safe!");
18827:     ++mRefCnt;
18827:     NS_LOG_ADDREF(this, mRefCnt, "imgCacheEntry", sizeof(*this));
18827:     return mRefCnt;
18827:   }
18827:  
18827:   nsrefcnt Release()
18827:   {
18827:     NS_PRECONDITION(0 != mRefCnt, "dup release");
25078:     NS_ABORT_IF_FALSE(_mOwningThread.GetThread() == PR_GetCurrentThread(), "imgCacheEntry release isn't thread-safe!");
18827:     --mRefCnt;
18827:     NS_LOG_RELEASE(this, mRefCnt, "imgCacheEntry");
18827:     if (mRefCnt == 0) {
18827:       mRefCnt = 1; /* stabilize */
18827:       delete this;
18827:       return 0;
18827:     }
18827:     return mRefCnt;                              
18827:   }
18827: 
18827:   PRUint32 GetDataSize() const
18827:   {
18827:     return mDataSize;
18827:   }
18827:   void SetDataSize(PRUint32 aDataSize)
18827:   {
18827:     PRInt32 oldsize = mDataSize;
18827:     mDataSize = aDataSize;
32424:     UpdateCache(mDataSize - oldsize);
18827:   }
18827: 
18827:   PRInt32 GetTouchedTime() const
18827:   {
18827:     return mTouchedTime;
18827:   }
18827:   void SetTouchedTime(PRInt32 time)
18827:   {
18827:     mTouchedTime = time;
18827:     Touch(/* updateTime = */ PR_FALSE);
18827:   }
18827: 
18827:   PRInt32 GetExpiryTime() const
18827:   {
18827:     return mExpiryTime;
18827:   }
18827:   void SetExpiryTime(PRInt32 aExpiryTime)
18827:   {
18827:     mExpiryTime = aExpiryTime;
18827:     Touch();
18827:   }
18827: 
72903:   PRBool GetMustValidateIfExpired() const
18827:   {
72903:     return mMustValidateIfExpired;
18827:   }
72903:   void SetMustValidateIfExpired(PRBool aValidate)
18827:   {
72903:     mMustValidateIfExpired = aValidate;
18827:     Touch();
18827:   }
18827: 
18827:   already_AddRefed<imgRequest> GetRequest() const
18827:   {
18827:     imgRequest *req = mRequest;
18827:     NS_ADDREF(req);
18827:     return req;
18827:   }
18827: 
18827:   PRBool Evicted() const
18827:   {
18827:     return mEvicted;
18827:   }
18827: 
18827:   nsExpirationState *GetExpirationState()
18827:   {
18827:     return &mExpirationState;
18827:   }
18827: 
25078:   PRBool HasNoProxies() const
25078:   {
25078:     return mHasNoProxies;
25078:   }
25078: 
18827: private: // methods
18827:   friend class imgLoader;
18827:   friend class imgCacheQueue;
18827:   void Touch(PRBool updateTime = PR_TRUE);
32424:   void UpdateCache(PRInt32 diff = 0);
18827:   void SetEvicted(PRBool evict)
18827:   {
18827:     mEvicted = evict;
18827:   }
25078:   void SetHasNoProxies(PRBool hasNoProxies);
25078: 
25078:   // Private, unimplemented copy constructor.
25078:   imgCacheEntry(const imgCacheEntry &);
18827: 
18827: private: // data
18827:   nsAutoRefCnt mRefCnt;
18827:   NS_DECL_OWNINGTHREAD
18827: 
18827:   nsRefPtr<imgRequest> mRequest;
18827:   PRUint32 mDataSize;
18827:   PRInt32 mTouchedTime;
18827:   PRInt32 mExpiryTime;
18827:   nsExpirationState mExpirationState;
72903:   PRPackedBool mMustValidateIfExpired : 1;
25078:   PRPackedBool mEvicted : 1;
25078:   PRPackedBool mHasNoProxies : 1;
18827: };
18827: 
18827: #include <vector>
18827: 
    1: #define NS_IMGLOADER_CID \
    1: { /* 9f6a0d2e-1dd1-11b2-a5b8-951f13c846f7 */         \
    1:      0x9f6a0d2e,                                     \
    1:      0x1dd1,                                         \
    1:      0x11b2,                                         \
    1:     {0xa5, 0xb8, 0x95, 0x1f, 0x13, 0xc8, 0x46, 0xf7} \
    1: }
    1: 
18827: class imgCacheQueue
18827: {
18827: public: 
18827:   imgCacheQueue();
18827:   void Remove(imgCacheEntry *);
18827:   void Push(imgCacheEntry *);
18827:   void MarkDirty();
18827:   PRBool IsDirty();
18827:   already_AddRefed<imgCacheEntry> Pop();
18827:   void Refresh();
18827:   PRUint32 GetSize() const;
18827:   void UpdateSize(PRInt32 diff);
18827:   PRUint32 GetNumElements() const;
18827:   typedef std::vector<nsRefPtr<imgCacheEntry> > queueContainer;  
18827:   typedef queueContainer::iterator iterator;
18827:   typedef queueContainer::const_iterator const_iterator;
18827: 
18827:   iterator begin();
18827:   const_iterator begin() const;
18827:   iterator end();
18827:   const_iterator end() const;
18827: 
18827: private:
18827:   queueContainer mQueue;
18827:   PRBool mDirty;
18827:   PRUint32 mSize;
18827: };
18827: 
42553: class imgMemoryReporter;
42553: 
18827: class imgLoader : public imgILoader,
18827:                   public nsIContentSniffer,
18827:                   public imgICache,
30324:                   public nsSupportsWeakReference,
30324:                   public nsIObserver
    1: {
    1: public:
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_IMGILOADER
    1:   NS_DECL_NSICONTENTSNIFFER
18827:   NS_DECL_IMGICACHE
30324:   NS_DECL_NSIOBSERVER
    1: 
    1:   imgLoader();
    1:   virtual ~imgLoader();
    1: 
30324:   nsresult Init();
30324: 
    1:   static nsresult GetMimeTypeFromContent(const char* aContents, PRUint32 aLength, nsACString& aContentType);
    1: 
18827:   static void Shutdown(); // for use by the factory
18827: 
18827:   static nsresult ClearChromeImageCache();
18827:   static nsresult ClearImageCache();
28083:   static void MinimizeCaches();
18827: 
18827:   static nsresult InitCache();
18827: 
18827:   static PRBool RemoveFromCache(nsIURI *aKey);
18827:   static PRBool RemoveFromCache(imgCacheEntry *entry);
18827: 
18827:   static PRBool PutIntoCache(nsIURI *key, imgCacheEntry *entry);
18827: 
29251:   // Returns true if we should prefer evicting cache entry |two| over cache
29251:   // entry |one|.
18827:   // This mixes units in the worst way, but provides reasonable results.
18827:   inline static bool CompareCacheEntries(const nsRefPtr<imgCacheEntry> &one,
18827:                                          const nsRefPtr<imgCacheEntry> &two)
18827:   {
18827:     if (!one)
18827:       return false;
18827:     if (!two)
18827:       return true;
18827: 
29251:     const double sizeweight = 1.0 - sCacheTimeWeight;
29251: 
29251:     // We want large, old images to be evicted first (depending on their
29251:     // relative weights). Since a larger time is actually newer, we subtract
29251:     // time's weight, so an older image has a larger weight.
29251:     double oneweight = double(one->GetDataSize()) * sizeweight -
29251:                        double(one->GetTouchedTime()) * sCacheTimeWeight;
29251:     double twoweight = double(two->GetDataSize()) * sizeweight -
29251:                        double(two->GetTouchedTime()) * sCacheTimeWeight;
29251: 
29251:     return oneweight < twoweight;
18827:   }
18827: 
18827:   static void VerifyCacheSizes();
18827: 
25078:   // The image loader maintains a hash table of all imgCacheEntries. However,
25078:   // only some of them will be evicted from the cache: those who have no
25078:   // imgRequestProxies watching their imgRequests. 
25078:   //
25078:   // Once an imgRequest has no imgRequestProxies, it should notify us by
25078:   // calling HasNoObservers(), and null out its cache entry pointer.
25078:   // 
25078:   // Upon having a proxy start observing again, it should notify us by calling
25078:   // HasObservers(). The request's cache entry will be re-set before this
25078:   // happens, by calling imgRequest::SetCacheEntry() when an entry with no
25078:   // observers is re-requested.
25078:   static PRBool SetHasNoProxies(nsIURI *key, imgCacheEntry *entry);
25078:   static PRBool SetHasProxies(nsIURI *key);
25078: 
18827: private: // methods
18827: 
18827: 
18827:   PRBool ValidateEntry(imgCacheEntry *aEntry, nsIURI *aKey,
18827:                        nsIURI *aInitialDocumentURI, nsIURI *aReferrerURI, 
18827:                        nsILoadGroup *aLoadGroup,
18827:                        imgIDecoderObserver *aObserver, nsISupports *aCX,
18827:                        nsLoadFlags aLoadFlags, PRBool aCanMakeNewChannel,
18827:                        imgIRequest *aExistingRequest,
42509:                        imgIRequest **aProxyRequest,
42509:                        nsIChannelPolicy *aPolicy);
18827:   PRBool ValidateRequestWithNewChannel(imgRequest *request, nsIURI *aURI,
18827:                                        nsIURI *aInitialDocumentURI,
18827:                                        nsIURI *aReferrerURI,
18827:                                        nsILoadGroup *aLoadGroup,
18827:                                        imgIDecoderObserver *aObserver,
18827:                                        nsISupports *aCX, nsLoadFlags aLoadFlags,
18827:                                        imgIRequest *aExistingRequest,
42509:                                        imgIRequest **aProxyRequest,
42509:                                        nsIChannelPolicy *aPolicy);
18827: 
    1:   nsresult CreateNewProxyForRequest(imgRequest *aRequest, nsILoadGroup *aLoadGroup,
    1:                                     imgIDecoderObserver *aObserver,
    1:                                     nsLoadFlags aLoadFlags, imgIRequest *aRequestProxy,
    1:                                     imgIRequest **_retval);
18827: 
71637:   void ReadAcceptHeaderPref();
30324: 
18827: 
18827:   typedef nsRefPtrHashtable<nsCStringHashKey, imgCacheEntry> imgCacheTable;
18827: 
28083:   static nsresult EvictEntries(imgCacheTable &aCacheToClear);
28083:   static nsresult EvictEntries(imgCacheQueue &aQueueToClear);
18827: 
18827:   static imgCacheTable &GetCache(nsIURI *aURI);
18827:   static imgCacheQueue &GetCacheQueue(nsIURI *aURI);
18827:   static void CacheEntriesChanged(nsIURI *aURI, PRInt32 sizediff = 0);
18827:   static void CheckCacheLimits(imgCacheTable &cache, imgCacheQueue &queue);
18827: 
18827: private: // data
18827:   friend class imgCacheEntry;
42553:   friend class imgMemoryReporter;
18827: 
18827:   static imgCacheTable sCache;
18827:   static imgCacheQueue sCacheQueue;
18827: 
18827:   static imgCacheTable sChromeCache;
18827:   static imgCacheQueue sChromeCacheQueue;
18827:   static PRFloat64 sCacheTimeWeight;
18827:   static PRUint32 sCacheMaxSize;
30324: 
30324:   nsCString mAcceptHeader;
    1: };
    1: 
    1: 
    1: 
    1: /**
    1:  * proxy stream listener class used to handle multipart/x-mixed-replace
    1:  */
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsIStreamListener.h"
    1: 
    1: class ProxyListener : public nsIStreamListener
    1: {
    1: public:
    1:   ProxyListener(nsIStreamListener *dest);
    1:   virtual ~ProxyListener();
    1: 
    1:   /* additional members */
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSISTREAMLISTENER
    1:   NS_DECL_NSIREQUESTOBSERVER
    1: 
    1: private:
    1:   nsCOMPtr<nsIStreamListener> mDestListener;
    1: };
    1: 
    1: 
    1: /**
    1:  * validate checker
    1:  */
    1: 
    1: #include "nsCOMArray.h"
    1: 
72903: class imgCacheValidator : public nsIStreamListener
    1: {
    1: public:
72903:   imgCacheValidator(imgRequest *request, void *aContext);
    1:   virtual ~imgCacheValidator();
    1: 
    1:   void AddProxy(imgRequestProxy *aProxy);
    1: 
72903:   /* additional members */
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSISTREAMLISTENER
    1:   NS_DECL_NSIREQUESTOBSERVER
    1: 
    1: private:
    1:   nsCOMPtr<nsIStreamListener> mDestListener;
    1: 
18827:   nsRefPtr<imgRequest> mRequest;
    1:   nsCOMArray<imgIRequest> mProxies;
    1: 
    1:   void *mContext;
18827: 
18827:   static imgLoader sImgLoader;
    1: };
50546: 
50546: #endif  // imgLoader_h__
