46468: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
33649: /* vim: set shiftwidth=2 tabstop=8 autoindent cindent expandtab: */
33649: /* ***** BEGIN LICENSE BLOCK *****
33649:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
33649:  *
33649:  * The contents of this file are subject to the Mozilla Public License Version
33649:  * 1.1 (the "License"); you may not use this file except in compliance with
33649:  * the License. You may obtain a copy of the License at
33649:  * http://www.mozilla.org/MPL/
33649:  *
33649:  * Software distributed under the License is distributed on an "AS IS" basis,
33649:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
33649:  * for the specific language governing rights and limitations under the
33649:  * License.
33649:  *
33649:  * The Original Code is nsTransitionManager.
33649:  *
33649:  * The Initial Developer of the Original Code is the Mozilla Foundation.
33649:  * Portions created by the Initial Developer are Copyright (C) 2009
33649:  * the Initial Developer. All Rights Reserved.
33649:  *
33649:  * Contributor(s):
33649:  *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
33649:  *
33649:  * Alternatively, the contents of this file may be used under the terms of
33649:  * either the GNU General Public License Version 2 or later (the "GPL"), or
33649:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
33649:  * in which case the provisions of the GPL or the LGPL are applicable instead
33649:  * of those above. If you wish to allow use of your version of this file only
33649:  * under the terms of either the GPL or the LGPL, and not to allow others to
33649:  * use your version of this file under the terms of the MPL, indicate your
33649:  * decision by deleting the provisions above and replace them with the notice
33649:  * and other provisions required by the GPL or the LGPL. If you do not delete
33649:  * the provisions above, a recipient may use your version of this file under
33649:  * the terms of any one of the MPL, the GPL or the LGPL.
33649:  *
33649:  * ***** END LICENSE BLOCK ***** */
33649: 
33649: /* Code to start and animate CSS transitions. */
33649: 
33649: #include "nsTransitionManager.h"
33649: #include "nsIContent.h"
33649: #include "nsStyleContext.h"
33649: #include "nsCSSProps.h"
33649: #include "mozilla/TimeStamp.h"
33649: #include "nsRefreshDriver.h"
33649: #include "nsRuleProcessorData.h"
33649: #include "nsIStyleRule.h"
33649: #include "nsRuleWalker.h"
33649: #include "nsRuleData.h"
33649: #include "nsSMILKeySpline.h"
33649: #include "gfxColor.h"
33649: #include "nsCSSPropertySet.h"
33649: #include "nsStyleAnimation.h"
33650: #include "nsCSSDataBlock.h"
36620: #include "nsEventDispatcher.h"
36620: #include "nsGUIEvent.h"
42322: #include "mozilla/dom/Element.h"
33649: 
33649: using mozilla::TimeStamp;
33649: using mozilla::TimeDuration;
33649: 
42322: namespace dom = mozilla::dom;
42322: 
33649: /*****************************************************************************
33649:  * Per-Element data                                                          *
33649:  *****************************************************************************/
33649: 
33649: struct ElementPropertyTransition
33649: {
33649:   nsCSSProperty mProperty;
48339:   nsStyleAnimation::Value mStartValue, mEndValue;
33649:   TimeStamp mStartTime; // actual start plus transition delay
33649: 
33649:   // data from the relevant nsTransition
33649:   TimeDuration mDuration;
33649:   nsSMILKeySpline mTimingFunction;
37104: 
37104:   PRBool IsRemovedSentinel() const
37104:   {
37104:     return mStartTime.IsNull();
37104:   }
37104: 
37104:   void SetRemovedSentinel()
37104:   {
37104:     // assign the null time stamp
37104:     mStartTime = TimeStamp();
37104:   }
33649: };
33649: 
33649: /**
48339:  * A style rule that maps property-nsStyleAnimation::Value pairs.
33649:  */
48339: class AnimValuesStyleRule : public nsIStyleRule
33649: {
33649: public:
48339:   // nsISupports implementation
33649:   NS_DECL_ISUPPORTS
33649: 
33649:   // nsIStyleRule implementation
43120:   virtual void MapRuleInfoInto(nsRuleData* aRuleData);
33649: #ifdef DEBUG
43120:   virtual void List(FILE* out = stdout, PRInt32 aIndent = 0) const;
33649: #endif
33649: 
48339:   void AddValue(nsCSSProperty aProperty, nsStyleAnimation::Value &aStartValue)
33649:   {
48339:     PropertyValuePair v = { aProperty, aStartValue };
48339:     mPropertyValuePairs.AppendElement(v);
33649:   }
33649: 
48339:   // Caller must fill in returned value, when non-null.
48339:   nsStyleAnimation::Value* AddEmptyValue(nsCSSProperty aProperty)
48339:   {
48339:     PropertyValuePair *p = mPropertyValuePairs.AppendElement();
48339:     if (!p) {
48339:       return nsnull;
48339:     }
48339:     p->mProperty = aProperty;
48339:     return &p->mValue;
48339:   }
48339: 
48339:   struct PropertyValuePair {
33649:     nsCSSProperty mProperty;
48339:     nsStyleAnimation::Value mValue;
33649:   };
33649: 
33649: private:
48339:   nsTArray<PropertyValuePair> mPropertyValuePairs;
33649: };
33649: 
33649: struct ElementTransitions : public PRCList
33649: {
42322:   ElementTransitions(dom::Element *aElement, nsIAtom *aElementProperty,
33649:                      nsTransitionManager *aTransitionManager)
33649:     : mElement(aElement)
33649:     , mElementProperty(aElementProperty)
33649:     , mTransitionManager(aTransitionManager)
33649:   {
33649:     PR_INIT_CLIST(this);
33649:   }
33649:   ~ElementTransitions()
33649:   {
33649:     PR_REMOVE_LINK(this);
33649:     mTransitionManager->TransitionsRemoved();
33649:   }
33649: 
33649:   void Destroy()
33649:   {
33649:     // This will call our destructor.
33649:     mElement->DeleteProperty(mElementProperty);
33649:   }
33649: 
47891:   void EnsureStyleRuleFor(TimeStamp aRefreshTime);
33649: 
33649: 
33649:   // Either zero or one for each CSS property:
33649:   nsTArray<ElementPropertyTransition> mPropertyTransitions;
33649: 
48339:   // This style rule overrides style data with the currently
48339:   // transitioning value for an element that is executing a transition.
48339:   // It only matches when styling with animation.  When we style without
48339:   // animation, we need to not use it so that we can detect any new
48339:   // changes; if necessary we restyle immediately afterwards with
48339:   // animation.
48339:   nsRefPtr<AnimValuesStyleRule> mStyleRule;
48339:   // The refresh time associated with mStyleRule.
48339:   TimeStamp mStyleRuleRefreshTime;
33649: 
42322:   dom::Element *mElement;
33649: 
33649:   // the atom we use in mElement's prop table (must be a static atom,
33649:   // i.e., in an atom list)
33649:   nsIAtom *mElementProperty;
33649: 
33649:   nsTransitionManager *mTransitionManager;
33649: };
33649: 
33649: static void
33649: ElementTransitionsPropertyDtor(void           *aObject,
33649:                                nsIAtom        *aPropertyName,
33649:                                void           *aPropertyValue,
33649:                                void           *aData)
33649: {
33649:   ElementTransitions *et = static_cast<ElementTransitions*>(aPropertyValue);
33649:   delete et;
33649: }
33649: 
48339: void
48339: ElementTransitions::EnsureStyleRuleFor(TimeStamp aRefreshTime)
48339: {
48339:   if (!mStyleRule || mStyleRuleRefreshTime != aRefreshTime) {
48339:     mStyleRule = new AnimValuesStyleRule();
48339:     mStyleRuleRefreshTime = aRefreshTime;
33649: 
48339:     for (PRUint32 i = 0, i_end = mPropertyTransitions.Length(); i < i_end; ++i)
33649:     {
48339:       ElementPropertyTransition &pt = mPropertyTransitions[i];
37104:       if (pt.IsRemovedSentinel()) {
37104:         continue;
37104:       }
37104: 
48339:       nsStyleAnimation::Value *val = mStyleRule->AddEmptyValue(pt.mProperty);
48339:       if (!val) {
48339:         continue;
48339:       }
48339: 
33650:       double timePortion =
48339:         (aRefreshTime - pt.mStartTime).ToSeconds() / pt.mDuration.ToSeconds();
33650:       if (timePortion < 0.0)
33650:         timePortion = 0.0; // use start value during transition-delay
33650:       if (timePortion > 1.0)
33650:         timePortion = 1.0; // we might be behind on flushing
33649: 
33650:       double valuePortion =
33650:         pt.mTimingFunction.GetSplineValue(timePortion);
33650: #ifdef DEBUG
33650:       PRBool ok =
33650: #endif
34869:         nsStyleAnimation::Interpolate(pt.mProperty,
34869:                                       pt.mStartValue, pt.mEndValue,
48339:                                       valuePortion, *val);
33650:       NS_ABORT_IF_FALSE(ok, "could not interpolate values");
33649:     }
33649:   }
33649: }
33649: 
48339: NS_IMPL_ISUPPORTS1(AnimValuesStyleRule, nsIStyleRule)
48339: 
43120: /* virtual */ void
48339: AnimValuesStyleRule::MapRuleInfoInto(nsRuleData* aRuleData)
33649: {
48339:   nsStyleContext *contextParent = aRuleData->mStyleContext->GetParent();
48339:   if (contextParent && contextParent->HasPseudoElementData()) {
48339:     // Don't apply transitions to things inside of pseudo-elements.
48339:     // FIXME (Bug 522599): Add tests for this.
48339:     return;
33649:   }
33649: 
48339:   for (PRUint32 i = 0, i_end = mPropertyValuePairs.Length(); i < i_end; ++i) {
48339:     PropertyValuePair &cv = mPropertyValuePairs[i];
33649:     if (aRuleData->mSIDs & nsCachedStyleData::GetBitForSID(
33649:                              nsCSSProps::kSIDTable[cv.mProperty]))
33649:     {
33650:       void *prop =
33650:         nsCSSExpandedDataBlock::RuleDataPropertyAt(aRuleData, cv.mProperty);
33650: #ifdef DEBUG
33650:       PRBool ok =
33650: #endif
33650:         nsStyleAnimation::UncomputeValue(cv.mProperty, aRuleData->mPresContext,
48339:                                          cv.mValue, prop);
33650:       NS_ABORT_IF_FALSE(ok, "could not store computed value");
33649:     }
33649:   }
33649: }
33649: 
33649: #ifdef DEBUG
43120: /* virtual */ void
48339: AnimValuesStyleRule::List(FILE* out, PRInt32 aIndent) const
33649: {
33649:   // WRITE ME?
33649: }
33649: #endif
33649: 
33649: /*****************************************************************************
33649:  * nsTransitionManager                                                       *
33649:  *****************************************************************************/
33649: 
33649: nsTransitionManager::nsTransitionManager(nsPresContext *aPresContext)
33649:   : mPresContext(aPresContext)
33649: {
33649:   PR_INIT_CLIST(&mElementTransitions);
33649: }
33649: 
33649: nsTransitionManager::~nsTransitionManager()
33649: {
36616:   NS_ABORT_IF_FALSE(!mPresContext, "Disconnect should have been called");
36616: }
36616: 
36616: void
36616: nsTransitionManager::Disconnect()
36616: {
33649:   // Content nodes might outlive the transition manager.
33649:   while (!PR_CLIST_IS_EMPTY(&mElementTransitions)) {
33649:     ElementTransitions *head = static_cast<ElementTransitions*>(
33649:                                  PR_LIST_HEAD(&mElementTransitions));
33649:     head->Destroy();
33649:   }
36616: 
36616:   mPresContext = nsnull;
33649: }
33649: 
36528: static PRBool
36528: TransExtractComputedValue(nsCSSProperty aProperty,
36528:                           nsStyleContext* aStyleContext,
36528:                           nsStyleAnimation::Value& aComputedValue)
36528: {
36528:   PRBool result =
36528:     nsStyleAnimation::ExtractComputedValue(aProperty, aStyleContext,
36528:                                            aComputedValue);
36528:   if (aProperty == eCSSProperty_visibility) {
36528:     NS_ABORT_IF_FALSE(aComputedValue.GetUnit() ==
36528:                         nsStyleAnimation::eUnit_Enumerated,
36528:                       "unexpected unit");
36528:     aComputedValue.SetIntValue(aComputedValue.GetIntValue(),
36528:                                nsStyleAnimation::eUnit_Visibility);
36528:   }
36528:   return result;
36528: }
36528: 
33649: already_AddRefed<nsIStyleRule>
42322: nsTransitionManager::StyleContextChanged(dom::Element *aElement,
33649:                                          nsStyleContext *aOldStyleContext,
33649:                                          nsStyleContext *aNewStyleContext)
33649: {
34387:   NS_PRECONDITION(aOldStyleContext->GetPseudo() ==
34387:                       aNewStyleContext->GetPseudo(),
33649:                   "pseudo type mismatch");
40137:   // If we were called from ReparentStyleContext, this assertion would
33649:   // actually fire.  If we need to be called from there, we can probably
33649:   // just remove it; the condition probably isn't critical, although
33649:   // it's worth thinking about some more.
33649:   NS_PRECONDITION(aOldStyleContext->HasPseudoElementData() ==
33649:                       aNewStyleContext->HasPseudoElementData(),
33649:                   "pseudo type mismatch");
33649: 
35571:   // NOTE: Things in this function (and ConsiderStartingTransition)
35571:   // should never call PeekStyleData because we don't preserve gotten
35571:   // structs across reframes.
35571: 
33649:   // Return sooner (before the startedAny check below) for the most
36530:   // common case: no transitions specified or running.
33649:   const nsStyleDisplay *disp = aNewStyleContext->GetStyleDisplay();
36530:   nsCSSPseudoElements::Type pseudoType = aNewStyleContext->GetPseudoType();
46468:   if (pseudoType != nsCSSPseudoElements::ePseudo_NotPseudoElement) {
46468:     if (pseudoType != nsCSSPseudoElements::ePseudo_before &&
46468:         pseudoType != nsCSSPseudoElements::ePseudo_after) {
46468:       return nsnull;
46468:     }
46468: 
46468:     NS_ASSERTION((pseudoType == nsCSSPseudoElements::ePseudo_before &&
46468:                   aElement->Tag() == nsGkAtoms::mozgeneratedcontentbefore) ||
46468:                  (pseudoType == nsCSSPseudoElements::ePseudo_after &&
46468:                   aElement->Tag() == nsGkAtoms::mozgeneratedcontentafter),
46468:                  "Unexpected aElement coming through");
46468: 
46468:     // Else the element we want to use from now on is the element the
46468:     // :before or :after is attached to.
46468:     aElement = aElement->GetParent()->AsElement();
46468:   }
46468: 
36530:   ElementTransitions *et =
36530:       GetElementTransitions(aElement, pseudoType, PR_FALSE);
36530:   if (!et &&
36530:       disp->mTransitionPropertyCount == 1 &&
33649:       disp->mTransitions[0].GetDelay() == 0.0f &&
36530:       disp->mTransitions[0].GetDuration() == 0.0f) {
33649:     return nsnull;
33649:   }      
33649: 
33649: 
33649:   if (aNewStyleContext->PresContext()->IsProcessingAnimationStyleChange()) {
33649:     return nsnull;
33649:   }
33649:   
33649:   if (aNewStyleContext->GetParent() &&
33649:       aNewStyleContext->GetParent()->HasPseudoElementData()) {
33649:     // Ignore transitions on things that inherit properties from
33649:     // pseudo-elements.
33896:     // FIXME (Bug 522599): Add tests for this.
33649:     return nsnull;
33649:   }
33649: 
33649:   // Per http://lists.w3.org/Archives/Public/www-style/2009Aug/0109.html
33649:   // I'll consider only the transitions from the number of items in
33649:   // 'transition-property' on down, and later ones will override earlier
33649:   // ones (tracked using |whichStarted|).
33649:   PRBool startedAny = PR_FALSE;
33649:   nsCSSPropertySet whichStarted;
33649:   for (PRUint32 i = disp->mTransitionPropertyCount; i-- != 0; ) {
33649:     const nsTransition& t = disp->mTransitions[i];
33649:     // Check delay and duration first, since they default to zero, and
33649:     // when they're both zero, we can ignore the transition.
33649:     if (t.GetDelay() != 0.0f || t.GetDuration() != 0.0f) {
33649:       // We might have something to transition.  See if any of the
33649:       // properties in question changed and are animatable.
35571:       // FIXME: Would be good to find a way to share code between this
35571:       // interpretation of transition-property and the one below.
33649:       nsCSSProperty property = t.GetProperty();
33649:       if (property == eCSSPropertyExtra_no_properties ||
33649:           property == eCSSProperty_UNKNOWN) {
33649:         // Nothing to do, but need to exclude this from cases below.
33649:       } else if (property == eCSSPropertyExtra_all_properties) {
33649:         for (nsCSSProperty p = nsCSSProperty(0); 
33649:              p < eCSSProperty_COUNT_no_shorthands;
33649:              p = nsCSSProperty(p + 1)) {
33649:           ConsiderStartingTransition(p, t, aElement, et,
33649:                                      aOldStyleContext, aNewStyleContext,
33649:                                      &startedAny, &whichStarted);
33649:         }
33649:       } else if (nsCSSProps::IsShorthand(property)) {
33649:         CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(subprop, property) {
33649:           ConsiderStartingTransition(*subprop, t, aElement, et,
33649:                                      aOldStyleContext, aNewStyleContext,
33649:                                      &startedAny, &whichStarted);
33649:         }
33649:       } else {
33649:         ConsiderStartingTransition(property, t, aElement, et,
33649:                                    aOldStyleContext, aNewStyleContext,
33649:                                    &startedAny, &whichStarted);
33649:       }
33649:     }
33649:   }
33649: 
35571:   // Stop any transitions for properties that are no longer in
35571:   // 'transition-property'.
36530:   // Also stop any transitions for properties that just changed (and are
36530:   // still in the set of properties to transition), but we didn't just
36530:   // start the transition because delay and duration are both zero.
36530:   if (et) {
36530:     PRBool checkProperties =
36530:       disp->mTransitions[0].GetProperty() != eCSSPropertyExtra_all_properties;
35571:     nsCSSPropertySet allTransitionProperties;
36530:     if (checkProperties) {
35571:       for (PRUint32 i = disp->mTransitionPropertyCount; i-- != 0; ) {
35571:         const nsTransition& t = disp->mTransitions[i];
35571:         // FIXME: Would be good to find a way to share code between this
35571:         // interpretation of transition-property and the one above.
35571:         nsCSSProperty property = t.GetProperty();
35571:         if (property == eCSSPropertyExtra_no_properties ||
35571:             property == eCSSProperty_UNKNOWN) {
35571:           // Nothing to do, but need to exclude this from cases below.
35571:         } else if (property == eCSSPropertyExtra_all_properties) {
35571:           for (nsCSSProperty p = nsCSSProperty(0); 
35571:                p < eCSSProperty_COUNT_no_shorthands;
35571:                p = nsCSSProperty(p + 1)) {
35571:             allTransitionProperties.AddProperty(p);
35571:           }
35571:         } else if (nsCSSProps::IsShorthand(property)) {
35571:           CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES(subprop, property) {
35571:             allTransitionProperties.AddProperty(*subprop);
35571:           }
35571:         } else {
35571:           allTransitionProperties.AddProperty(property);
35571:         }
35571:       }
36530:     }
35571: 
35571:     nsTArray<ElementPropertyTransition> &pts = et->mPropertyTransitions;
35571:     PRUint32 i = pts.Length();
35571:     NS_ABORT_IF_FALSE(i != 0, "empty transitions list?");
36530:     nsStyleAnimation::Value currentValue;
35571:     do {
35571:       --i;
35571:       ElementPropertyTransition &pt = pts[i];
36530:           // properties no longer in 'transition-property'
36530:       if ((checkProperties &&
36530:            !allTransitionProperties.HasProperty(pt.mProperty)) ||
36530:           // properties whose computed values changed but delay and
36530:           // duration are both zero
36530:           !TransExtractComputedValue(pt.mProperty, aNewStyleContext,
36530:                                      currentValue) ||
36530:           currentValue != pt.mEndValue) {
36530:         // stop the transition
35571:         pts.RemoveElementAt(i);
35571:       }
35571:     } while (i != 0);
35571: 
35571:     if (pts.IsEmpty()) {
35571:       et->Destroy();
35571:       et = nsnull;
35571:     }
35571:   }
35571: 
33649:   if (!startedAny) {
33649:     return nsnull;
33649:   }
33649: 
33649:   NS_ABORT_IF_FALSE(et, "must have element transitions if we started "
33649:                         "any transitions");
33649: 
33649:   // In the CSS working group discussion (2009 Jul 15 telecon,
33649:   // http://www.w3.org/mid/4A5E1470.4030904@inkedblade.net ) of
33649:   // http://lists.w3.org/Archives/Public/www-style/2009Jun/0121.html ,
33649:   // the working group decided that a transition property on an
33649:   // element should not cause any transitions if the property change
33649:   // is itself inheriting a value that is transitioning on an
33649:   // ancestor.  So, to get the correct behavior, we continue the
33649:   // restyle that caused this transition using a "covering" rule that
33649:   // covers up any changes on which we started transitions, so that
33649:   // descendants don't start their own transitions.  (In the case of
33649:   // negative transition delay, this covering rule produces different
33649:   // results than applying the transition rule immediately would).
33649:   // Our caller is responsible for restyling again using this covering
33649:   // rule.
33649: 
48339:   nsRefPtr<AnimValuesStyleRule> coverRule = new AnimValuesStyleRule;
33649:   if (!coverRule) {
33649:     NS_WARNING("out of memory");
33649:     return nsnull;
33649:   }
33649:   
33649:   nsTArray<ElementPropertyTransition> &pts = et->mPropertyTransitions;
33649:   for (PRUint32 i = 0, i_end = pts.Length(); i < i_end; ++i) {
33649:     ElementPropertyTransition &pt = pts[i];
33649:     if (whichStarted.HasProperty(pt.mProperty)) {
48339:       coverRule->AddValue(pt.mProperty, pt.mStartValue);
33649:     }
33649:   }
33649: 
48340:   return coverRule.forget();
33649: }
33649: 
33649: void
33649: nsTransitionManager::ConsiderStartingTransition(nsCSSProperty aProperty,
33649:                        const nsTransition& aTransition,
42322:                        dom::Element *aElement,
33649:                        ElementTransitions *&aElementTransitions,
33649:                        nsStyleContext *aOldStyleContext,
33649:                        nsStyleContext *aNewStyleContext,
33649:                        PRBool *aStartedAny,
33649:                        nsCSSPropertySet *aWhichStarted)
33649: {
33649:   // IsShorthand itself will assert if aProperty is not a property.
33649:   NS_ABORT_IF_FALSE(!nsCSSProps::IsShorthand(aProperty),
33649:                     "property out of range");
33649: 
33649:   if (aWhichStarted->HasProperty(aProperty)) {
33649:     // A later item in transition-property already started a
33649:     // transition for this property, so we ignore this one.
33649:     // See comment above and
33649:     // http://lists.w3.org/Archives/Public/www-style/2009Aug/0109.html .
33649:     return;
33649:   }
33649: 
33649:   if (nsCSSProps::kAnimTypeTable[aProperty] == eStyleAnimType_None) {
33649:     return;
33649:   }
33649: 
33649:   ElementPropertyTransition pt;
34029:   nsStyleAnimation::Value dummyValue;
33649:   PRBool shouldAnimate =
36526:     TransExtractComputedValue(aProperty, aOldStyleContext, pt.mStartValue) &&
36526:     TransExtractComputedValue(aProperty, aNewStyleContext, pt.mEndValue) &&
33649:     pt.mStartValue != pt.mEndValue &&
33649:     // Check that we can interpolate between these values
33649:     // (If this is ever a performance problem, we could add a
33649:     // CanInterpolate method, but it seems fine for now.)
34869:     nsStyleAnimation::Interpolate(aProperty, pt.mStartValue, pt.mEndValue,
34869:                                   0.5, dummyValue);
33649: 
33649:   PRUint32 currentIndex = nsTArray<ElementPropertyTransition>::NoIndex;
33649:   if (aElementTransitions) {
33649:     nsTArray<ElementPropertyTransition> &pts =
33649:       aElementTransitions->mPropertyTransitions;
33649:     for (PRUint32 i = 0, i_end = pts.Length(); i < i_end; ++i) {
33649:       if (pts[i].mProperty == aProperty) {
33649:         currentIndex = i;
33649:         break;
33649:       }
33649:     }
33649:   }
33649: 
33649:   nsPresContext *presContext = aNewStyleContext->PresContext();
33649: 
33649:   if (!shouldAnimate) {
33649:     if (currentIndex != nsTArray<ElementPropertyTransition>::NoIndex) {
33649:       // We're in the middle of a transition, but just got a
33649:       // non-transition style change changing to exactly the
33649:       // current in-progress value.   (This is quite easy to cause
33649:       // using 'transition-delay'.)
33649:       nsTArray<ElementPropertyTransition> &pts =
33649:         aElementTransitions->mPropertyTransitions;
33649:       pts.RemoveElementAt(currentIndex);
33649:       if (pts.IsEmpty()) {
33649:         aElementTransitions->Destroy();
33649:         // |aElementTransitions| is now a dangling pointer!
33649:         aElementTransitions = nsnull;
33649:       }
35571:       // WalkTransitionRule already called RestyleForAnimation.
33649:     }
33649:     return;
33649:   }
33649: 
33649:   // When we interrupt a running transition, we want to reduce the
33649:   // duration of the new transition *if* the new transition would have
33649:   // been longer had it started from the endpoint of the currently
33649:   // running transition.
33649:   double durationFraction = 1.0;
33649: 
33649:   // We need to check two things if we have a currently running
33649:   // transition for this property:  see durationFraction comment above
33649:   // and the endpoint check below.
33649:   if (currentIndex != nsTArray<ElementPropertyTransition>::NoIndex) {
37104:     const ElementPropertyTransition &oldPT =
37104:       aElementTransitions->mPropertyTransitions[currentIndex];
33649: 
37104:     if (oldPT.mEndValue == pt.mEndValue) {
33649:       // If we got a style change that changed the value to the endpoint
33649:       // of the currently running transition, we don't want to interrupt
33649:       // its timing function.
35571:       // WalkTransitionRule already called RestyleForAnimation.
33649:       return;
33649:     }
33649: 
33649:     double fullDistance, remainingDistance;
33649: #ifdef DEBUG
33649:     PRBool ok =
33649: #endif
34869:       nsStyleAnimation::ComputeDistance(aProperty, pt.mStartValue,
34869:                                         pt.mEndValue, fullDistance);
33649:     NS_ABORT_IF_FALSE(ok, "could not compute distance");
33649:     NS_ABORT_IF_FALSE(fullDistance >= 0.0, "distance must be positive");
33649: 
37104:     if (!oldPT.IsRemovedSentinel() &&
37104:         nsStyleAnimation::ComputeDistance(aProperty, oldPT.mEndValue,
37104:                                           pt.mEndValue, remainingDistance)) {
33649:       NS_ABORT_IF_FALSE(remainingDistance >= 0.0, "distance must be positive");
33649:       durationFraction = fullDistance / remainingDistance;
33649:       if (durationFraction > 1.0) {
33649:         durationFraction = 1.0;
33649:       }
33649:     }
33649:   }
33649: 
33649: 
33649:   nsRefreshDriver *rd = presContext->RefreshDriver();
33649: 
33649:   pt.mProperty = aProperty;
33649:   float delay = aTransition.GetDelay();
33649:   float duration = aTransition.GetDuration();
33649:   if (durationFraction != 1.0) {
33649:     // Negative delays are essentially part of the transition
33649:     // function, so reduce them along with the duration, but don't
33649:     // reduce positive delays.  (See comment above about
33649:     // durationFraction.)
33649:     if (delay < 0.0f)
33649:         delay *= durationFraction;
33649:     duration *= durationFraction;
33649:   }
33649:   pt.mStartTime = rd->MostRecentRefresh() +
33649:                   TimeDuration::FromMilliseconds(delay);
33649:   pt.mDuration = TimeDuration::FromMilliseconds(duration);
33649:   const nsTimingFunction &tf = aTransition.GetTimingFunction();
33649:   pt.mTimingFunction.Init(tf.mX1, tf.mY1, tf.mX2, tf.mY2);
33649: 
33649:   if (!aElementTransitions) {
33649:     aElementTransitions =
35555:       GetElementTransitions(aElement, aNewStyleContext->GetPseudoType(),
33649:                             PR_TRUE);
33649:     if (!aElementTransitions) {
33649:       NS_WARNING("allocating ElementTransitions failed");
33649:       return;
33649:     }
33649:   }
33649:   
33649:   nsTArray<ElementPropertyTransition> &pts =
33649:     aElementTransitions->mPropertyTransitions;
33649: #ifdef DEBUG
33649:   for (PRUint32 i = 0, i_end = pts.Length(); i < i_end; ++i) {
33649:     NS_ABORT_IF_FALSE(i == currentIndex ||
33649:                       pts[i].mProperty != aProperty,
33649:                       "duplicate transitions for property");
33649:   }
33649: #endif
33649:   if (currentIndex != nsTArray<ElementPropertyTransition>::NoIndex) {
33649:     pts[currentIndex] = pt;
33649:   } else {
33649:     if (!pts.AppendElement(pt)) {
33649:       NS_WARNING("out of memory");
33649:       return;
33649:     }
33649:   }
33649: 
46468:   nsRestyleHint hint =
46468:     aNewStyleContext->GetPseudoType() ==
46468:       nsCSSPseudoElements::ePseudo_NotPseudoElement ?
46468:     eRestyle_Self : eRestyle_Subtree;
46468:   presContext->PresShell()->RestyleForAnimation(aElement, hint);
33649: 
33649:   *aStartedAny = PR_TRUE;
33649:   aWhichStarted->AddProperty(aProperty);
33649: }
33649: 
33649: ElementTransitions*
42322: nsTransitionManager::GetElementTransitions(dom::Element *aElement,
35555:                                            nsCSSPseudoElements::Type aPseudoType,
33649:                                            PRBool aCreateIfNeeded)
33649: {
36529:   if (!aCreateIfNeeded && PR_CLIST_IS_EMPTY(&mElementTransitions)) {
36529:     // Early return for the most common case.
36529:     return nsnull;
36529:   }
36529: 
33649:   nsIAtom *propName;
36529:   if (aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement) {
36529:     propName = nsGkAtoms::transitionsProperty;
36529:   } else if (aPseudoType == nsCSSPseudoElements::ePseudo_before) {
33649:     propName = nsGkAtoms::transitionsOfBeforeProperty;
35555:   } else if (aPseudoType == nsCSSPseudoElements::ePseudo_after) {
33649:     propName = nsGkAtoms::transitionsOfAfterProperty;
33649:   } else {
36529:     NS_ASSERTION(!aCreateIfNeeded,
33649:                  "should never try to create transitions for pseudo "
33649:                  "other than :before or :after");
36529:     return nsnull;
33649:   }
33649:   ElementTransitions *et = static_cast<ElementTransitions*>(
33649:                              aElement->GetProperty(propName));
33649:   if (!et && aCreateIfNeeded) {
33649:     // FIXME: Consider arena-allocating?
33649:     et = new ElementTransitions(aElement, propName, this);
33649:     if (!et) {
33649:       NS_WARNING("out of memory");
33649:       return nsnull;
33649:     }
33649:     nsresult rv = aElement->SetProperty(propName, et,
33649:                                         ElementTransitionsPropertyDtor, nsnull);
33649:     if (NS_FAILED(rv)) {
33649:       NS_WARNING("SetProperty failed");
33649:       delete et;
33649:       return nsnull;
33649:     }
33649: 
33649:     AddElementTransitions(et);
33649:   }
33649: 
33649:   return et;
33649: }
33649: 
33649: void
33649: nsTransitionManager::AddElementTransitions(ElementTransitions* aElementTransitions)
33649: {
33649:   if (PR_CLIST_IS_EMPTY(&mElementTransitions)) {
33649:     // We need to observe the refresh driver.
33649:     nsRefreshDriver *rd = mPresContext->RefreshDriver();
33649:     rd->AddRefreshObserver(this, Flush_Style);
33649:   }
33649: 
33649:   PR_INSERT_BEFORE(aElementTransitions, &mElementTransitions);
33649: }
33649: 
33649: /*
33649:  * nsISupports implementation
33649:  */
33649: 
36616: NS_IMPL_ISUPPORTS1(nsTransitionManager, nsIStyleRuleProcessor)
33649: 
33649: /*
33649:  * nsIStyleRuleProcessor implementation
33649:  */
33649: 
47891: void
33649: nsTransitionManager::WalkTransitionRule(RuleProcessorData* aData,
35555:                                         nsCSSPseudoElements::Type aPseudoType)
33649: {
35571:   ElementTransitions *et =
41644:     GetElementTransitions(aData->mElement, aPseudoType, PR_FALSE);
35571:   if (!et) {
47891:     return;
35571:   }
35571: 
46468:   if (aData->mPresContext->IsProcessingRestyles() &&
46468:       !aData->mPresContext->IsProcessingAnimationStyleChange()) {
33649:     // If we're processing a normal style change rather than one from
33649:     // animation, don't add the transition rule.  This allows us to
33649:     // compute the new style value rather than having the transition
33649:     // override it, so that we can start transitioning differently.
33649: 
35571:     // We need to immediately restyle with animation
35571:     // after doing this.
35571:     if (et) {
46468:       nsRestyleHint hint =
46468:         aPseudoType == nsCSSPseudoElements::ePseudo_NotPseudoElement ?
46468:         eRestyle_Self : eRestyle_Subtree;
46468:       mPresContext->PresShell()->RestyleForAnimation(aData->mElement, hint);
33649:     }
47891:     return;
33649:   }
33649: 
47891:   et->EnsureStyleRuleFor(
47891:     aData->mPresContext->RefreshDriver()->MostRecentRefresh());
47891: 
47891:   aData->mRuleWalker->Forward(et->mStyleRule);
33649: }
33649: 
47891: /* virtual */ void
33649: nsTransitionManager::RulesMatching(ElementRuleProcessorData* aData)
33649: {
33649:   NS_ABORT_IF_FALSE(aData->mPresContext == mPresContext,
33649:                     "pres context mismatch");
47891:   WalkTransitionRule(aData,
35555:                      nsCSSPseudoElements::ePseudo_NotPseudoElement);
35555: }
35555: 
47891: /* virtual */ void
35555: nsTransitionManager::RulesMatching(PseudoElementRuleProcessorData* aData)
35555: {
35555:   NS_ABORT_IF_FALSE(aData->mPresContext == mPresContext,
35555:                     "pres context mismatch");
35555: 
35555:   // Note:  If we're the only thing keeping a pseudo-element frame alive
35555:   // (per ProbePseudoStyleContext), we still want to keep it alive, so
35555:   // this is ok.
47891:   WalkTransitionRule(aData, aData->mPseudoType);
35539: }
35539: 
47891: /* virtual */ void
35556: nsTransitionManager::RulesMatching(AnonBoxRuleProcessorData* aData)
35556: {
35556: }
35556: 
35558: #ifdef MOZ_XUL
47891: /* virtual */ void
35558: nsTransitionManager::RulesMatching(XULTreeRuleProcessorData* aData)
35539: {
33649: }
35558: #endif
33649: 
40075: nsRestyleHint
35614: nsTransitionManager::HasStateDependentStyle(StateRuleProcessorData* aData)
33649: {
40075:   return nsRestyleHint(0);
33649: }
33649: 
39698: PRBool
39698: nsTransitionManager::HasDocumentStateDependentStyle(StateRuleProcessorData* aData)
39698: {
39698:   return PR_FALSE;
39698: }
39698: 
40075: nsRestyleHint
35533: nsTransitionManager::HasAttributeDependentStyle(AttributeRuleProcessorData* aData)
33649: {
40075:   return nsRestyleHint(0);
33649: }
33649: 
47891: /* virtual */ PRBool
47891: nsTransitionManager::MediumFeaturesChanged(nsPresContext* aPresContext)
33649: {
47891:   return PR_FALSE;
33649: }
33649: 
36620: struct TransitionEventInfo {
36620:   nsCOMPtr<nsIContent> mElement;
36620:   nsTransitionEvent mEvent;
36620: 
36620:   TransitionEventInfo(nsIContent *aElement, nsCSSProperty aProperty,
36620:                       TimeDuration aDuration)
36620:     : mElement(aElement),
36620:       mEvent(PR_TRUE, NS_TRANSITION_END,
36620:              NS_ConvertUTF8toUTF16(nsCSSProps::GetStringValue(aProperty)),
36620:              aDuration.ToSeconds())
36620:   {
36620:   }
36620: 
36620:   // nsTransitionEvent doesn't support copy-construction, so we need
36620:   // to ourselves in order to work with nsTArray
36620:   TransitionEventInfo(const TransitionEventInfo &aOther)
36620:     : mElement(aOther.mElement),
36620:       mEvent(PR_TRUE, NS_TRANSITION_END,
36620:              aOther.mEvent.propertyName, aOther.mEvent.elapsedTime)
36620:   {
36620:   }
36620: };
36620: 
33649: /* virtual */ void
33649: nsTransitionManager::WillRefresh(mozilla::TimeStamp aTime)
33649: {
36616:   NS_ABORT_IF_FALSE(mPresContext,
36616:                     "refresh driver should not notify additional observers "
36616:                     "after pres context has been destroyed");
36616: 
36620:   nsTArray<TransitionEventInfo> events;
36620: 
33649:   // Trim transitions that have completed, and post restyle events for
33649:   // frames that are still transitioning.
33649:   {
33649:     PRCList *next = PR_LIST_HEAD(&mElementTransitions);
33649:     while (next != &mElementTransitions) {
33649:       ElementTransitions *et = static_cast<ElementTransitions*>(next);
33649:       next = PR_NEXT_LINK(next);
33649: 
33649:       NS_ABORT_IF_FALSE(et->mElement->GetCurrentDoc() ==
33649:                           mPresContext->Document(),
33649:                         "nsGenericElement::UnbindFromTree should have "
33649:                         "destroyed the element transitions object");
33649: 
33649:       PRUint32 i = et->mPropertyTransitions.Length();
33649:       NS_ABORT_IF_FALSE(i != 0, "empty transitions list?");
33649:       do {
33649:         --i;
33649:         ElementPropertyTransition &pt = et->mPropertyTransitions[i];
37104:         if (pt.IsRemovedSentinel()) {
37104:           // Actually remove transitions one cycle after their
37104:           // completion.  See comment below.
37104:           et->mPropertyTransitions.RemoveElementAt(i);
37104:         } else if (pt.mStartTime + pt.mDuration <= aTime) {
33649:           // This transition has completed.
47175: 
47175:           // Fire transitionend events only for transitions on elements
47175:           // and not those on pseudo-elements, since we can't target an
47175:           // event at pseudo-elements.
47175:           if (et->mElementProperty == nsGkAtoms::transitionsProperty) {
36620:             nsCSSProperty prop = pt.mProperty;
47175:             if (nsCSSProps::PropHasFlags(prop, CSS_PROPERTY_REPORT_OTHER_NAME))
47175:             {
36620:               prop = nsCSSProps::OtherNameFor(prop);
36620:             }
36620:             events.AppendElement(
36620:               TransitionEventInfo(et->mElement, prop, pt.mDuration));
47175:           }
36620: 
37104:           // Leave this transition in the list for one more refresh
37104:           // cycle, since we haven't yet processed its style change, and
37104:           // if we also have (already, or will have from processing
37104:           // transitionend events or other refresh driver notifications)
37104:           // a non-animation style change that would affect it, we need
37104:           // to know not to start a new transition for the transition
37104:           // from the almost-completed value to the final value.
37104:           pt.SetRemovedSentinel();
33649:         }
33649:       } while (i != 0);
33649: 
33649:       // We need to restyle even if the transition rule no longer
33649:       // applies (in which case we just made it not apply).
46468:       NS_ASSERTION(et->mElementProperty == nsGkAtoms::transitionsProperty ||
46468:                    et->mElementProperty == nsGkAtoms::transitionsOfBeforeProperty ||
46468:                    et->mElementProperty == nsGkAtoms::transitionsOfAfterProperty,
46468:                    "Unexpected element property; might restyle too much");
46468:       nsRestyleHint hint = et->mElementProperty == nsGkAtoms::transitionsProperty ?
46468:         eRestyle_Self : eRestyle_Subtree;
46468:       mPresContext->PresShell()->RestyleForAnimation(et->mElement, hint);
33649: 
33649:       if (et->mPropertyTransitions.IsEmpty()) {
33649:         et->Destroy();
33649:         // |et| is now a dangling pointer!
33649:         et = nsnull;
33649:       }
33649:     }
33649:   }
33649: 
33649:   // We might have removed transitions above.
33649:   TransitionsRemoved();
36620: 
36620:   for (PRUint32 i = 0, i_end = events.Length(); i < i_end; ++i) {
36620:     TransitionEventInfo &info = events[i];
36620:     nsEventDispatcher::Dispatch(info.mElement, mPresContext, &info.mEvent);
36620: 
36620:     if (!mPresContext) {
36620:       break;
36620:     }
36620:   }
33649: }
33649: 
33649: void
33649: nsTransitionManager::TransitionsRemoved()
33649: {
33649:   // If we have no transitions left, remove ourselves from the refresh
33649:   // driver.
33649:   if (PR_CLIST_IS_EMPTY(&mElementTransitions)) {
33649:     mPresContext->RefreshDriver()->RemoveRefreshObserver(this, Flush_Style);
33649:   }
33649: }
