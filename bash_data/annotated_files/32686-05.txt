29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jsstr_h___
    1: #define jsstr_h___
    1: /*
    1:  * JS string type implementation.
    1:  *
    1:  * A JS string is a counted array of unicode characters.  To support handoff
    1:  * of API client memory, the chars are allocated separately from the length,
    1:  * necessitating a pointer after the count, to form a separately allocated
    1:  * string descriptor.  String descriptors are GC'ed, while their chars are
    1:  * allocated from the malloc heap.
    1:  */
    1: #include <ctype.h>
    1: #include "jspubtd.h"
    1: #include "jsprvtd.h"
29366: #include "jslock.h"
    1: 
    1: JS_BEGIN_EXTERN_C
    1: 
29366: #define JSSTRING_BIT(n)             ((size_t)1 << (n))
29366: #define JSSTRING_BITMASK(n)         (JSSTRING_BIT(n) - 1)
29366: 
32674: class TraceRecorder;
30275: 
32674: enum {
32674:     UNIT_STRING_LIMIT        = 256U,
32677:     INT_STRING_LIMIT         = 256U
32674: };
30275: 
29366: extern jschar *
29366: js_GetDependentStringChars(JSString *str);
29366: 
    1: /*
 4718:  * The GC-thing "string" type.
    1:  *
29366:  * When the DEPENDENT bit of the mLength field is unset, the mChars field
29366:  * points to a flat character array owned by its GC-thing descriptor.  The
29366:  * array is terminated at index length by a zero character and the size of the
29366:  * array in bytes is (length + 1) * sizeof(jschar). The terminator is purely a
29366:  * backstop, in case the chars pointer flows out to native code that requires
29366:  * \u0000 termination.
 4718:  *
29366:  * A flat string with the MUTABLE flag means that the string is accessible only
29366:  * from one thread and it is possible to turn it into a dependent string of the
29366:  * same length to optimize js_ConcatStrings. It is also possible to grow such a
29366:  * string, but extreme care must be taken to ensure that no other code relies
29366:  * on the original length of the string.
 4718:  *
29366:  * A flat string with the ATOMIZED flag means that the string is hashed as
14755:  * an atom. This flag is used to avoid re-hashing the already-atomized string.
10573:  *
29366:  * Any string with the DEFLATED flag means that the string has an entry in the
29366:  * deflated string cache. The GC uses this flag to optimize string finalization
29366:  * and avoid an expensive cache lookup for strings that were never deflated.
27477:  *
29366:  * When the DEPENDENT flag is set, the string depends on characters of another
29366:  * string strongly referenced by the mBase field. The base member may point to
29366:  * another dependent string if chars() has not been called yet.
 4718:  *
29366:  * The PREFIX flag determines the kind of the dependent string. When the flag
29366:  * is unset, the mLength field encodes both starting position relative to the
 4718:  * base string and the number of characters in the dependent string, see
29366:  * DEPENDENT_START_MASK and DEPENDENT_LENGTH_MASK below for details.
 4718:  *
29366:  * When the PREFIX flag is set, the dependent string is a prefix of the base
14755:  * string. The number of characters in the prefix is encoded using all non-flag
29366:  * bits of the mLength field and spans the same 0 .. SIZE_T_MAX/4 range as the
14755:  * length of the flat string.
 4718:  *
29366:  * NB: Always use the length() and chars() accessor methods.
    1:  */
    1: struct JSString {
29366:     friend class TraceRecorder;
29366: 
29366:     friend JSAtom *
29366:     js_AtomizeString(JSContext *cx, JSString *str, uintN flags);
29366: 
29366:     friend JSString * JS_FASTCALL
29366:     js_ConcatStrings(JSContext *cx, JSString *left, JSString *right);
29366: 
29366:     size_t          mLength;
 4718:     union {
29366:         jschar      *mChars;
29366:         JSString    *mBase;
    1:     };
    1: 
    1:     /*
29366:      * Definitions for flags stored in the high order bits of mLength.
29366:      *
29366:      * PREFIX and MUTABLE are two aliases for the same bit.  PREFIX should be
29366:      * used only if DEPENDENT is set and MUTABLE should be used only if the
29366:      * string is flat.
29366:      *
29366:      * ATOMIZED is used only with flat, immutable strings.
    1:      */
31822:     enum
31822: #if defined(_MSC_VER) && defined(_WIN64)
31822:     : size_t /* VC++ 64-bit incorrectly defaults this enum's size to int. */
31822: #endif
31822:     {
29366:         DEPENDENT =     JSSTRING_BIT(JS_BITS_PER_WORD - 1),
29366:         PREFIX =        JSSTRING_BIT(JS_BITS_PER_WORD - 2),
29366:         MUTABLE =       PREFIX,
29366:         ATOMIZED =      JSSTRING_BIT(JS_BITS_PER_WORD - 3),
29366:         DEFLATED =      JSSTRING_BIT(JS_BITS_PER_WORD - 4),
10444: 
29366:         LENGTH_BITS =   JS_BITS_PER_WORD - 4,
29366:         LENGTH_MASK =   JSSTRING_BITMASK(LENGTH_BITS),
    1: 
31822:         /*
31822:          * VC++ 64-bit incorrectly produces the compiler error "Conversion to
31822:          * enumeration type requires an explicit cast" unless we cast to size_t
31822:          * here.
31822:          */
31822:         DEPENDENT_LENGTH_BITS = size_t(LENGTH_BITS) / 2,
29366:         DEPENDENT_LENGTH_MASK = JSSTRING_BITMASK(DEPENDENT_LENGTH_BITS),
29366:         DEPENDENT_START_BITS =  LENGTH_BITS - DEPENDENT_LENGTH_BITS,
29366:         DEPENDENT_START_SHIFT = DEPENDENT_LENGTH_BITS,
29366:         DEPENDENT_START_MASK =  JSSTRING_BITMASK(DEPENDENT_START_BITS)
29366:     };
 4718: 
29366:     bool hasFlag(size_t flag) const {
29366:         return (mLength & flag) != 0;
29366:     }
 4718: 
29366:   public:
31822:     enum
31822: #if defined(_MSC_VER) && defined(_WIN64)
31822:     : size_t /* VC++ 64-bit incorrectly defaults this enum's size to int. */
31822: #endif
31822:     {
29366:         MAX_LENGTH = LENGTH_MASK,
29366:         MAX_DEPENDENT_START = DEPENDENT_START_MASK,
29366:         MAX_DEPENDENT_LENGTH = DEPENDENT_LENGTH_MASK
29366:     };
27471: 
29366:     bool isDependent() const {
29366:         return hasFlag(DEPENDENT);
29366:     }
27471: 
29366:     bool isFlat() const {
29366:         return !isDependent();
29366:     }
27471: 
29366:     bool isDeflated() const {
29366:         return hasFlag(DEFLATED);
29366:     }
 4718: 
29366:     void setDeflated() {
29366:         JS_ATOMIC_SET_MASK((jsword *) &mLength, DEFLATED);
29366:     }
10437: 
29366:     bool isMutable() const {
29366:         return !isDependent() && hasFlag(MUTABLE);
29366:     }
 4718: 
29366:     bool isAtomized() const {
29366:         return !isDependent() && hasFlag(ATOMIZED);
29366:     }
10444: 
29366:     JS_ALWAYS_INLINE jschar *chars() {
29366:         return isDependent() ? dependentChars() : flatChars();
29366:     }
29366: 
29366:     JS_ALWAYS_INLINE size_t length() const {
29366:         return isDependent() ? dependentLength() : flatLength();
29366:     }
29366: 
29366:     JS_ALWAYS_INLINE bool empty() const {
29366:         return length() == 0;
29366:     }
29366: 
29366:     JS_ALWAYS_INLINE void getCharsAndLength(const jschar *&chars, size_t &length) {
29366:         if (isDependent()) {
29366:             length = dependentLength();
29366:             chars = dependentChars();
29366:         } else {
29366:             length = flatLength();
29366:             chars = flatChars();
29366:         }
29366:     }
29366: 
29366:     JS_ALWAYS_INLINE void getCharsAndEnd(const jschar *&chars, const jschar *&end) {
29366:         end = isDependent()
29366:               ? dependentLength() + (chars = dependentChars())
29366:               : flatLength() + (chars = flatChars());
29366:     }
29366: 
29366:     /* Specific flat string initializer and accessor methods. */
29366:     void initFlat(jschar *chars, size_t length) {
29366:         JS_ASSERT(length <= MAX_LENGTH);
29366:         mLength = length;
29366:         mChars = chars;
29366:     }
29366: 
29366:     jschar *flatChars() const {
29366:         JS_ASSERT(isFlat());
29366:         return mChars;
29366:     }
29366: 
29366:     size_t flatLength() const {
29366:         JS_ASSERT(isFlat());
29366:         return mLength & LENGTH_MASK;
29366:     }
10444: 
10573:     /*
27496:      * Special flat string initializer that preserves the JSSTR_DEFLATED flag.
29366:      * Use this method when reinitializing an existing string which may be
29366:      * hashed to its deflated bytes. Newborn strings must use initFlat.
27496:      */
29366:     void reinitFlat(jschar *chars, size_t length) {
29366:         JS_ASSERT(length <= MAX_LENGTH);
29366:         mLength = (mLength & DEFLATED) | (length & ~DEFLATED);
29366:         mChars = chars;
29366:     }
27496: 
27496:     /*
29366:      * Methods to manipulate atomized and mutable flags of flat strings. It is
29366:      * safe to use these without extra locking due to the following properties:
10573:      *
29366:      *   * We do not have a flatClearAtomized method, as a string remains
29366:      *     atomized until the GC collects it.
10573:      *
29366:      *   * A thread may call flatSetMutable only when it is the only
29366:      *     thread accessing the string until a later call to
29366:      *     flatClearMutable.
10573:      *
29366:      *   * Multiple threads can call flatClearMutable but the function actually
29366:      *     clears the mutable flag only when the flag is set -- in which case
29366:      *     only one thread can access the string (see previous property).
10573:      *
29366:      * Thus, when multiple threads access the string, JSString::flatSetAtomized
29366:      * is the only function that can update the mLength field of the string by
29366:      * changing the mutable bit from 0 to 1. We call the method only after the
29366:      * string has been hashed. When some threads in js_ValueToStringId see that
29366:      * the flag is set, it knows that the string was atomized.
10573:      *
29366:      * On the other hand, if the thread sees that the flag is unset, it could
29366:      * be seeing a stale value when another thread has just atomized the string
29366:      * and set the flag. But this can lead only to an extra call to
29366:      * js_AtomizeString.  This function would find that the string was already
29366:      * hashed and return it with the atomized bit set.
10573:      */
29366:     void flatSetAtomized() {
29366:         JS_ASSERT(isFlat() && !isMutable());
29366:         JS_STATIC_ASSERT(sizeof(mLength) == sizeof(jsword));
29366:         JS_ATOMIC_SET_MASK((jsword *) &mLength, ATOMIZED);
29366:     }
10573: 
29366:     void flatSetMutable() {
29366:         JS_ASSERT(isFlat() && !isAtomized());
29366:         mLength |= MUTABLE;
29366:     }
 4718: 
29366:     void flatClearMutable() {
29366:         JS_ASSERT(isFlat());
29366:         if (hasFlag(MUTABLE))
29366:             mLength &= ~MUTABLE;
29366:     }
 4718: 
29366:     void initDependent(JSString *bstr, size_t off, size_t len) {
29366:         JS_ASSERT(off <= MAX_DEPENDENT_START);
29366:         JS_ASSERT(len <= MAX_DEPENDENT_LENGTH);
29366:         mLength = DEPENDENT | (off << DEPENDENT_START_SHIFT) | len;
29366:         mBase = bstr;
29366:     }
    1: 
29366:     /* See JSString::reinitFlat. */
29366:     void reinitDependent(JSString *bstr, size_t off, size_t len) {
29366:         JS_ASSERT(off <= MAX_DEPENDENT_START);
29366:         JS_ASSERT(len <= MAX_DEPENDENT_LENGTH);
29366:         mLength = DEPENDENT | (mLength & DEFLATED) | (off << DEPENDENT_START_SHIFT) | len;
29366:         mBase = bstr;
29366:     }
 4718: 
29366:     JSString *dependentBase() const {
29366:         JS_ASSERT(isDependent());
29366:         return mBase;
29366:     }
    1: 
29366:     bool dependentIsPrefix() const {
29366:         JS_ASSERT(isDependent());
29366:         return hasFlag(PREFIX);
29366:     }
    1: 
29366:     JS_ALWAYS_INLINE jschar *dependentChars() {
29366:         return dependentBase()->isDependent()
29366:                ? js_GetDependentStringChars(this)
29366:                : dependentBase()->flatChars() + dependentStart();
29366:     }
27496: 
29366:     JS_ALWAYS_INLINE size_t dependentStart() const {
29366:         return dependentIsPrefix()
29366:                ? 0
29366:                : ((mLength >> DEPENDENT_START_SHIFT) & DEPENDENT_START_MASK);
29366:     }
 4718: 
29366:     JS_ALWAYS_INLINE size_t dependentLength() const {
29366:         JS_ASSERT(isDependent());
29366:         return mLength & (dependentIsPrefix() ? LENGTH_MASK : DEPENDENT_LENGTH_MASK);
29366:     }
27496: 
29366:     void initPrefix(JSString *bstr, size_t len) {
29366:         JS_ASSERT(len <= MAX_LENGTH);
29366:         mLength = DEPENDENT | PREFIX | len;
29366:         mBase = bstr;
29366:     }
    1: 
29366:     /* See JSString::reinitFlat. */
29366:     void reinitPrefix(JSString *bstr, size_t len) {
29366:         JS_ASSERT(len <= MAX_LENGTH);
29366:         mLength = DEPENDENT | PREFIX | (mLength & DEFLATED) | len;
29366:         mBase = bstr;
29366:     }
    1: 
29366:     JSString *prefixBase() const {
29366:         JS_ASSERT(isDependent() && dependentIsPrefix());
29366:         return dependentBase();
29366:     }
    1: 
29366:     void prefixSetBase(JSString *bstr) {
29366:         JS_ASSERT(isDependent() && dependentIsPrefix());
29366:         mBase = bstr;
29366:     }
32607:     
32674:     static inline bool isStatic(JSString *s) {
32682:         return (s >= unitStringTable && s < &unitStringTable[UNIT_STRING_LIMIT]) ||
32682:                (s >= intStringTable && s < &intStringTable[INT_STRING_LIMIT]);
32674:     }
32674: 
32682:     static JSString unitStringTable[];
32682:     static JSString intStringTable[];
32682: 
32674:     static JSString *unitString(jschar c);
32607:     static JSString *getUnitString(JSContext *cx, JSString *str, size_t index);
32686:     static JSString *intString(jsint i);
29366: };
    1: 
    1: extern const jschar *
    1: js_GetStringChars(JSContext *cx, JSString *str);
    1: 
18040: extern JSString * JS_FASTCALL
18040: js_ConcatStrings(JSContext *cx, JSString *left, JSString *right);
    1: 
    1: extern const jschar *
    1: js_UndependString(JSContext *cx, JSString *str);
    1: 
 4718: extern JSBool
 4718: js_MakeStringImmutable(JSContext *cx, JSString *str);
 4718: 
18703: extern JSString * JS_FASTCALL
18703: js_toLowerCase(JSContext *cx, JSString *str);
18703: 
18703: extern JSString * JS_FASTCALL
18703: js_toUpperCase(JSContext *cx, JSString *str);
18703: 
    1: struct JSSubString {
    1:     size_t          length;
    1:     const jschar    *chars;
    1: };
    1: 
    1: extern jschar      js_empty_ucstr[];
    1: extern JSSubString js_EmptySubString;
    1: 
    1: /* Unicode character attribute lookup tables. */
    1: extern const uint8 js_X[];
    1: extern const uint8 js_Y[];
    1: extern const uint32 js_A[];
    1: 
    1: /* Enumerated Unicode general category types. */
    1: typedef enum JSCharType {
    1:     JSCT_UNASSIGNED             = 0,
    1:     JSCT_UPPERCASE_LETTER       = 1,
    1:     JSCT_LOWERCASE_LETTER       = 2,
    1:     JSCT_TITLECASE_LETTER       = 3,
    1:     JSCT_MODIFIER_LETTER        = 4,
    1:     JSCT_OTHER_LETTER           = 5,
    1:     JSCT_NON_SPACING_MARK       = 6,
    1:     JSCT_ENCLOSING_MARK         = 7,
    1:     JSCT_COMBINING_SPACING_MARK = 8,
    1:     JSCT_DECIMAL_DIGIT_NUMBER   = 9,
    1:     JSCT_LETTER_NUMBER          = 10,
    1:     JSCT_OTHER_NUMBER           = 11,
    1:     JSCT_SPACE_SEPARATOR        = 12,
    1:     JSCT_LINE_SEPARATOR         = 13,
    1:     JSCT_PARAGRAPH_SEPARATOR    = 14,
    1:     JSCT_CONTROL                = 15,
    1:     JSCT_FORMAT                 = 16,
    1:     JSCT_PRIVATE_USE            = 18,
    1:     JSCT_SURROGATE              = 19,
    1:     JSCT_DASH_PUNCTUATION       = 20,
    1:     JSCT_START_PUNCTUATION      = 21,
    1:     JSCT_END_PUNCTUATION        = 22,
    1:     JSCT_CONNECTOR_PUNCTUATION  = 23,
    1:     JSCT_OTHER_PUNCTUATION      = 24,
    1:     JSCT_MATH_SYMBOL            = 25,
    1:     JSCT_CURRENCY_SYMBOL        = 26,
    1:     JSCT_MODIFIER_SYMBOL        = 27,
    1:     JSCT_OTHER_SYMBOL           = 28
    1: } JSCharType;
    1: 
    1: /* Character classifying and mapping macros, based on java.lang.Character. */
    1: #define JS_CCODE(c)     (js_A[js_Y[(js_X[(uint16)(c)>>6]<<6)|((c)&0x3F)]])
    1: #define JS_CTYPE(c)     (JS_CCODE(c) & 0x1F)
    1: 
    1: #define JS_ISALPHA(c)   ((((1 << JSCT_UPPERCASE_LETTER) |                     \
    1:                            (1 << JSCT_LOWERCASE_LETTER) |                     \
    1:                            (1 << JSCT_TITLECASE_LETTER) |                     \
    1:                            (1 << JSCT_MODIFIER_LETTER) |                      \
    1:                            (1 << JSCT_OTHER_LETTER))                          \
    1:                           >> JS_CTYPE(c)) & 1)
    1: 
    1: #define JS_ISALNUM(c)   ((((1 << JSCT_UPPERCASE_LETTER) |                     \
    1:                            (1 << JSCT_LOWERCASE_LETTER) |                     \
    1:                            (1 << JSCT_TITLECASE_LETTER) |                     \
    1:                            (1 << JSCT_MODIFIER_LETTER) |                      \
    1:                            (1 << JSCT_OTHER_LETTER) |                         \
    1:                            (1 << JSCT_DECIMAL_DIGIT_NUMBER))                  \
    1:                           >> JS_CTYPE(c)) & 1)
    1: 
    1: /* A unicode letter, suitable for use in an identifier. */
    1: #define JS_ISLETTER(c)   ((((1 << JSCT_UPPERCASE_LETTER) |                    \
    1:                             (1 << JSCT_LOWERCASE_LETTER) |                    \
    1:                             (1 << JSCT_TITLECASE_LETTER) |                    \
    1:                             (1 << JSCT_MODIFIER_LETTER) |                     \
    1:                             (1 << JSCT_OTHER_LETTER) |                        \
    1:                             (1 << JSCT_LETTER_NUMBER))                        \
    1:                            >> JS_CTYPE(c)) & 1)
    1: 
    1: /*
    1:  * 'IdentifierPart' from ECMA grammar, is Unicode letter or combining mark or
    1:  * digit or connector punctuation.
    1:  */
    1: #define JS_ISIDPART(c)  ((((1 << JSCT_UPPERCASE_LETTER) |                     \
    1:                            (1 << JSCT_LOWERCASE_LETTER) |                     \
    1:                            (1 << JSCT_TITLECASE_LETTER) |                     \
    1:                            (1 << JSCT_MODIFIER_LETTER) |                      \
    1:                            (1 << JSCT_OTHER_LETTER) |                         \
    1:                            (1 << JSCT_LETTER_NUMBER) |                        \
    1:                            (1 << JSCT_NON_SPACING_MARK) |                     \
    1:                            (1 << JSCT_COMBINING_SPACING_MARK) |               \
    1:                            (1 << JSCT_DECIMAL_DIGIT_NUMBER) |                 \
    1:                            (1 << JSCT_CONNECTOR_PUNCTUATION))                 \
    1:                           >> JS_CTYPE(c)) & 1)
    1: 
    1: /* Unicode control-format characters, ignored in input */
    1: #define JS_ISFORMAT(c) (((1 << JSCT_FORMAT) >> JS_CTYPE(c)) & 1)
    1: 
    1: /*
30451:  * This table is used in JS_ISWORD.  The definition has external linkage to
30451:  * allow the raw table data to be used in the regular expression compiler.
    1:  */
30451: extern const bool js_alnum[];
30451: 
30451: /*
30451:  * This macro performs testing for the regular expression word class \w, which
30451:  * is defined by ECMA-262 15.10.2.6 to be [0-9A-Z_a-z].  If we want a
30451:  * Unicode-friendlier definition of "word", we should rename this macro to
30451:  * something regexp-y.
30451:  */
30451: #define JS_ISWORD(c)    ((c) < 128 && js_alnum[(c)])
    1: 
    1: #define JS_ISIDSTART(c) (JS_ISLETTER(c) || (c) == '_' || (c) == '$')
    1: #define JS_ISIDENT(c)   (JS_ISIDPART(c) || (c) == '_' || (c) == '$')
    1: 
    1: #define JS_ISXMLSPACE(c)        ((c) == ' ' || (c) == '\t' || (c) == '\r' ||  \
    1:                                  (c) == '\n')
    1: #define JS_ISXMLNSSTART(c)      ((JS_CCODE(c) & 0x00000100) || (c) == '_')
    1: #define JS_ISXMLNS(c)           ((JS_CCODE(c) & 0x00000080) || (c) == '.' ||  \
    1:                                  (c) == '-' || (c) == '_')
    1: #define JS_ISXMLNAMESTART(c)    (JS_ISXMLNSSTART(c) || (c) == ':')
    1: #define JS_ISXMLNAME(c)         (JS_ISXMLNS(c) || (c) == ':')
    1: 
    1: #define JS_ISDIGIT(c)   (JS_CTYPE(c) == JSCT_DECIMAL_DIGIT_NUMBER)
    1: 
32608: static inline bool
32608: JS_ISSPACE(jschar c)
32608: {
32614:     unsigned w = c;
32610: 
32610:     if (w < 256)
32644:         return (w <= ' ' && (w == ' ' || (9 <= w && w <= 0xD))) || w == 0xA0;
32610: 
32608:     return (JS_CCODE(w) & 0x00070000) == 0x00040000;
32608: }
32608: 
    1: #define JS_ISPRINT(c)   ((c) < 128 && isprint(c))
    1: 
    1: #define JS_ISUPPER(c)   (JS_CTYPE(c) == JSCT_UPPERCASE_LETTER)
    1: #define JS_ISLOWER(c)   (JS_CTYPE(c) == JSCT_LOWERCASE_LETTER)
    1: 
    1: #define JS_TOUPPER(c)   ((jschar) ((JS_CCODE(c) & 0x00100000)                 \
    1:                                    ? (c) - ((int32)JS_CCODE(c) >> 22)         \
    1:                                    : (c)))
    1: #define JS_TOLOWER(c)   ((jschar) ((JS_CCODE(c) & 0x00200000)                 \
    1:                                    ? (c) + ((int32)JS_CCODE(c) >> 22)         \
    1:                                    : (c)))
    1: 
    1: /*
    1:  * Shorthands for ASCII (7-bit) decimal and hex conversion.
    1:  * Manually inline isdigit for performance; MSVC doesn't do this for us.
    1:  */
    1: #define JS7_ISDEC(c)    ((((unsigned)(c)) - '0') <= 9)
    1: #define JS7_UNDEC(c)    ((c) - '0')
    1: #define JS7_ISHEX(c)    ((c) < 128 && isxdigit(c))
    1: #define JS7_UNHEX(c)    (uintN)(JS7_ISDEC(c) ? (c) - '0' : 10 + tolower(c) - 'a')
    1: #define JS7_ISLET(c)    ((c) < 128 && isalpha(c))
    1: 
    1: /* Initialize per-runtime string state for the first context in the runtime. */
    1: extern JSBool
    1: js_InitRuntimeStringState(JSContext *cx);
    1: 
 8029: extern JSBool
 8029: js_InitDeflatedStringCache(JSRuntime *rt);
 8029: 
    1: extern void
    1: js_FinishRuntimeStringState(JSContext *cx);
    1: 
    1: extern void
    1: js_FinishDeflatedStringCache(JSRuntime *rt);
    1: 
    1: /* Initialize the String class, returning its prototype object. */
    1: extern JSClass js_StringClass;
    1: 
    1: extern JSObject *
    1: js_InitStringClass(JSContext *cx, JSObject *obj);
    1: 
    1: extern const char js_escape_str[];
    1: extern const char js_unescape_str[];
    1: extern const char js_uneval_str[];
    1: extern const char js_decodeURI_str[];
    1: extern const char js_encodeURI_str[];
    1: extern const char js_decodeURIComponent_str[];
    1: extern const char js_encodeURIComponent_str[];
    1: 
    1: /* GC-allocate a string descriptor for the given malloc-allocated chars. */
    1: extern JSString *
18040: js_NewString(JSContext *cx, jschar *chars, size_t length);
    1: 
31477: /*
31477:  * GC-allocate a string descriptor and steal the char buffer held by |cb|.
31477:  * This function takes responsibility for adding the terminating '\0' required
31477:  * by js_NewString.
31477:  */
31477: extern JSString *
31890: js_NewStringFromCharBuffer(JSContext *cx, JSCharBuffer &cb);
31477: 
    1: extern JSString *
    1: js_NewDependentString(JSContext *cx, JSString *base, size_t start,
 4076:                       size_t length);
    1: 
    1: /* Copy a counted string and GC-allocate a descriptor for it. */
    1: extern JSString *
 4076: js_NewStringCopyN(JSContext *cx, const jschar *s, size_t n);
    1: 
    1: /* Copy a C string and GC-allocate a descriptor for it. */
    1: extern JSString *
 4076: js_NewStringCopyZ(JSContext *cx, const jschar *s);
    1: 
 6117: /*
    1:  * Convert a value to a printable C string.
    1:  */
    1: typedef JSString *(*JSValueToStringFun)(JSContext *cx, jsval v);
    1: 
    1: extern JS_FRIEND_API(const char *)
    1: js_ValueToPrintable(JSContext *cx, jsval v, JSValueToStringFun v2sfun);
    1: 
    1: #define js_ValueToPrintableString(cx,v) \
    1:     js_ValueToPrintable(cx, v, js_ValueToString)
    1: 
    1: #define js_ValueToPrintableSource(cx,v) \
    1:     js_ValueToPrintable(cx, v, js_ValueToSource)
    1: 
    1: /*
    1:  * Convert a value to a string, returning null after reporting an error,
    1:  * otherwise returning a new string reference.
    1:  */
    1: extern JS_FRIEND_API(JSString *)
    1: js_ValueToString(JSContext *cx, jsval v);
    1: 
    1: /*
30023:  * This function implements E-262-3 section 9.8, toString. Convert the given
30023:  * value to a string of jschars appended to the given buffer. On error, the
30023:  * passed buffer may have partial results appended.
30023:  */
30023: extern JS_FRIEND_API(JSBool)
31890: js_ValueToCharBuffer(JSContext *cx, jsval v, JSCharBuffer &cb);
30023: 
30023: /*
    1:  * Convert a value to its source expression, returning null after reporting
    1:  * an error, otherwise returning a new string reference.
    1:  */
    1: extern JS_FRIEND_API(JSString *)
    1: js_ValueToSource(JSContext *cx, jsval v);
    1: 
    1: /*
 4529:  * Compute a hash function from str. The caller can call this function even if
 4529:  * str is not a GC-allocated thing.
    1:  */
 4529: extern uint32
    1: js_HashString(JSString *str);
 4529: 
 4529: /*
 4529:  * Test if strings are equal. The caller can call the function even if str1
 4529:  * or str2 are not GC-allocated things.
 4529:  */
18728: extern JSBool JS_FASTCALL
 4529: js_EqualStrings(JSString *str1, JSString *str2);
    1: 
    1: /*
    1:  * Return less than, equal to, or greater than zero depending on whether
    1:  * str1 is less than, equal to, or greater than str2.
    1:  */
20408: extern int32 JS_FASTCALL
    1: js_CompareStrings(JSString *str1, JSString *str2);
    1: 
    1: /*
    1:  * Boyer-Moore-Horspool superlinear search for pat:patlen in text:textlen.
    1:  * The patlen argument must be positive and no greater than BMH_PATLEN_MAX.
    1:  * The start argument tells where in text to begin the search.
    1:  *
    1:  * Return the index of pat in text, or -1 if not found.
    1:  */
    1: #define BMH_CHARSET_SIZE 256    /* ISO-Latin-1 */
    1: #define BMH_PATLEN_MAX   255    /* skip table element is uint8 */
    1: 
    1: #define BMH_BAD_PATTERN  (-2)   /* return value if pat is not ISO-Latin-1 */
    1: 
    1: extern jsint
    1: js_BoyerMooreHorspool(const jschar *text, jsint textlen,
    1:                       const jschar *pat, jsint patlen,
    1:                       jsint start);
    1: 
    1: extern size_t
    1: js_strlen(const jschar *s);
    1: 
    1: extern jschar *
    1: js_strchr(const jschar *s, jschar c);
    1: 
    1: extern jschar *
    1: js_strchr_limit(const jschar *s, jschar c, const jschar *limit);
    1: 
    1: #define js_strncpy(t, s, n)     memcpy((t), (s), (n) * sizeof(jschar))
    1: 
    1: /*
    1:  * Return s advanced past any Unicode white space characters.
    1:  */
32608: static inline const jschar *
32608: js_SkipWhiteSpace(const jschar *s, const jschar *end)
32608: {
32608:     JS_ASSERT(s <= end);
32608:     while (s != end && JS_ISSPACE(*s))
32608:         s++;
32608:     return s;
32608: }
    1: 
    1: /*
    1:  * Inflate bytes to JS chars and vice versa.  Report out of memory via cx
    1:  * and return null on error, otherwise return the jschar or byte vector that
    1:  * was JS_malloc'ed. length is updated with the length of the new string in jschars.
    1:  */
    1: extern jschar *
    1: js_InflateString(JSContext *cx, const char *bytes, size_t *length);
    1: 
    1: extern char *
    1: js_DeflateString(JSContext *cx, const jschar *chars, size_t length);
    1: 
    1: /*
    1:  * Inflate bytes to JS chars into a buffer. 'chars' must be large enough for
    1:  * 'length' jschars. The buffer is NOT null-terminated. The destination length
    1:  * must be be initialized with the buffer size and will contain on return the
    1:  * number of copied chars.
    1:  */
    1: extern JSBool
    1: js_InflateStringToBuffer(JSContext *cx, const char *bytes, size_t length,
    1:                          jschar *chars, size_t *charsLength);
    1: 
    1: /*
    1:  * Get number of bytes in the deflated sequence of characters.
    1:  */
    1: extern size_t
    1: js_GetDeflatedStringLength(JSContext *cx, const jschar *chars,
    1:                            size_t charsLength);
    1: 
    1: /*
    1:  * Deflate JS chars to bytes into a buffer. 'bytes' must be large enough for
    1:  * 'length chars. The buffer is NOT null-terminated. The destination length
    1:  * must to be initialized with the buffer size and will contain on return the
    1:  * number of copied bytes.
    1:  */
    1: extern JSBool
    1: js_DeflateStringToBuffer(JSContext *cx, const jschar *chars,
    1:                          size_t charsLength, char *bytes, size_t *length);
    1: 
    1: /*
    1:  * Associate bytes with str in the deflated string cache, returning true on
    1:  * successful association, false on out of memory.
    1:  */
    1: extern JSBool
    1: js_SetStringBytes(JSContext *cx, JSString *str, char *bytes, size_t length);
    1: 
    1: /*
    1:  * Find or create a deflated string cache entry for str that contains its
    1:  * characters chopped from Unicode code points into bytes.
    1:  */
    1: extern const char *
    1: js_GetStringBytes(JSContext *cx, JSString *str);
    1: 
    1: /* Remove a deflated string cache entry associated with str if any. */
    1: extern void
    1: js_PurgeDeflatedStringCache(JSRuntime *rt, JSString *str);
    1: 
18115: /* Export a few natives and a helper to other files in SpiderMonkey. */
18115: extern JSBool
    1: js_str_escape(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
    1:               jsval *rval);
    1: 
18115: extern JSBool
30443: js_str_toString(JSContext *cx, uintN argc, jsval *vp);
30443: 
    1: /*
    1:  * Convert one UCS-4 char and write it into a UTF-8 buffer, which must be at
    1:  * least 6 bytes long.  Return the number of UTF-8 bytes of data written.
    1:  */
    1: extern int
    1: js_OneUcs4ToUtf8Char(uint8 *utf8Buffer, uint32 ucs4Char);
    1: 
    1: /*
    1:  * Write str into buffer escaping any non-printable or non-ASCII character.
    1:  * Guarantees that a NUL is at the end of the buffer. Returns the length of
    1:  * the written output, NOT including the NUL. If buffer is null, just returns
    1:  * the length of the output. If quote is not 0, it must be a single or double
    1:  * quote character that will quote the output.
    1:  *
    1:  * The function is only defined for debug builds.
    1: */
    1: #define js_PutEscapedString(buffer, bufferSize, str, quote)                   \
    1:     js_PutEscapedStringImpl(buffer, bufferSize, NULL, str, quote)
    1: 
    1: /*
    1:  * Write str into file escaping any non-printable or non-ASCII character.
    1:  * Returns the number of bytes written to file. If quote is not 0, it must
    1:  * be a single or double quote character that will quote the output.
    1:  *
    1:  * The function is only defined for debug builds.
    1: */
    1: #define js_FileEscapedString(file, str, quote)                                \
    1:     (JS_ASSERT(file), js_PutEscapedStringImpl(NULL, 0, file, str, quote))
    1: 
 4569: extern JS_FRIEND_API(size_t)
    1: js_PutEscapedStringImpl(char *buffer, size_t bufferSize, FILE *fp,
    1:                         JSString *str, uint32 quote);
    1: 
26008: extern JSBool
26008: js_String(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
26008: 
    1: JS_END_EXTERN_C
    1: 
    1: #endif /* jsstr_h___ */
