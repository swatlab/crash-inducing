    1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Oracle Corporation code.
    1:  *
    1:  * The Initial Developer of the Original Code is Oracle Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <pavlov@pavlov.net>
    1:  *   Vladimir Vukicevic <vladimir@pobox.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "gfxXlibSurface.h"
    1: 
    1: #include "cairo.h"
    1: #include "cairo-xlib.h"
    1: #include "cairo-xlib-xrender.h"
47116: #include <X11/Xlibint.h>	/* For XESetCloseDisplay */
47760: 
47116: #include "nsTArray.h"
47764: #include "nsAlgorithm.h"
47760: #include "nsServiceManagerUtils.h"
47760: #include "nsIPrefService.h"
52190: #include "cairo-xlib-xrender.h"
    1: 
46299: // Although the dimension parameters in the xCreatePixmapReq wire protocol are
46299: // 16-bit unsigned integers, the server's CreatePixmap returns BadAlloc if
46299: // either dimension cannot be represented by a 16-bit *signed* integer.
46299: #define XLIB_IMAGE_SIDE_SIZE_LIMIT 0x7fff
 1349: 
    1: gfxXlibSurface::gfxXlibSurface(Display *dpy, Drawable drawable, Visual *visual)
    1:     : mPixmapTaken(PR_FALSE), mDisplay(dpy), mDrawable(drawable)
    1: {
    1:     DoSizeQuery();
    1:     cairo_surface_t *surf = cairo_xlib_surface_create(dpy, drawable, visual, mSize.width, mSize.height);
    1:     Init(surf);
    1: }
    1: 
    1: gfxXlibSurface::gfxXlibSurface(Display *dpy, Drawable drawable, Visual *visual, const gfxIntSize& size)
    1:     : mPixmapTaken(PR_FALSE), mDisplay(dpy), mDrawable(drawable), mSize(size)
    1: {
47113:     NS_ASSERTION(CheckSurfaceSize(size, XLIB_IMAGE_SIDE_SIZE_LIMIT),
47113:                  "Bad size");
 1349: 
    1:     cairo_surface_t *surf = cairo_xlib_surface_create(dpy, drawable, visual, mSize.width, mSize.height);
    1:     Init(surf);
    1: }
    1: 
47113: gfxXlibSurface::gfxXlibSurface(Screen *screen, Drawable drawable, XRenderPictFormat *format,
47113:                                const gfxIntSize& size)
47113:     : mPixmapTaken(PR_FALSE), mDisplay(DisplayOfScreen(screen)),
47113:       mDrawable(drawable), mSize(size)
47113: {
47113:     NS_ASSERTION(CheckSurfaceSize(size, XLIB_IMAGE_SIDE_SIZE_LIMIT),
47113:                  "Bad Size");
    1: 
47113:     cairo_surface_t *surf =
47113:         cairo_xlib_surface_create_with_xrender_format(mDisplay, drawable,
47113:                                                       screen, format,
47113:                                                       mSize.width, mSize.height);
    1:     Init(surf);
    1: }
    1: 
    1: gfxXlibSurface::gfxXlibSurface(cairo_surface_t *csurf)
44153:     : mPixmapTaken(PR_FALSE),
44153:       mSize(cairo_xlib_surface_get_width(csurf),
44153:             cairo_xlib_surface_get_height(csurf))
    1: {
47113:     NS_PRECONDITION(cairo_surface_status(csurf) == 0,
47113:                     "Not expecting an error surface");
47113: 
    1:     mDrawable = cairo_xlib_surface_get_drawable(csurf);
    1:     mDisplay = cairo_xlib_surface_get_display(csurf);
    1: 
    1:     Init(csurf, PR_TRUE);
    1: }
    1: 
    1: gfxXlibSurface::~gfxXlibSurface()
    1: {
46300:     if (mPixmapTaken) {
46300:         XFreePixmap (mDisplay, mDrawable);
46300:     }
    1: }
    1: 
47113: static Drawable
47113: CreatePixmap(Screen *screen, const gfxIntSize& size, unsigned int depth,
47113:              Drawable relatedDrawable)
47113: {
47113:     if (!gfxASurface::CheckSurfaceSize(size, XLIB_IMAGE_SIDE_SIZE_LIMIT))
47113:         return None;
47113: 
47113:     if (relatedDrawable == None) {
47113:         relatedDrawable = RootWindowOfScreen(screen);
47113:     }
47113:     Display *dpy = DisplayOfScreen(screen);
47764:     // X gives us a fatal error if we try to create a pixmap of width
47764:     // or height 0
47113:     return XCreatePixmap(dpy, relatedDrawable,
47764:                          NS_MAX(1, size.width), NS_MAX(1, size.height),
47764:                          depth);
47113: }
47113: 
47113: /* static */
47113: already_AddRefed<gfxXlibSurface>
47113: gfxXlibSurface::Create(Screen *screen, Visual *visual,
47113:                        const gfxIntSize& size, Drawable relatedDrawable)
47113: {
47113:     Drawable drawable =
47113:         CreatePixmap(screen, size, DepthOfVisual(screen, visual),
47113:                      relatedDrawable);
47113:     if (!drawable)
47113:         return nsnull;
47113: 
47113:     nsRefPtr<gfxXlibSurface> result =
47113:         new gfxXlibSurface(DisplayOfScreen(screen), drawable, visual, size);
47113:     result->TakePixmap();
47113: 
47113:     if (result->CairoStatus() != 0)
47113:         return nsnull;
47113: 
47113:     return result.forget();
47113: }
47113: 
47113: /* static */
47113: already_AddRefed<gfxXlibSurface>
47113: gfxXlibSurface::Create(Screen *screen, XRenderPictFormat *format,
47113:                        const gfxIntSize& size, Drawable relatedDrawable)
47113: {
47113:     Drawable drawable =
47113:         CreatePixmap(screen, size, format->depth, relatedDrawable);
47113:     if (!drawable)
47113:         return nsnull;
47113: 
47113:     nsRefPtr<gfxXlibSurface> result =
47113:         new gfxXlibSurface(screen, drawable, format, size);
47113:     result->TakePixmap();
47113: 
47113:     if (result->CairoStatus() != 0)
47113:         return nsnull;
47113: 
47113:     return result.forget();
47113: }
47113: 
47760: static PRBool GetForce24bppPref()
47760: {
47760:     PRBool val = PR_FALSE; // default
47760: 
47760:     nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
47760:     if (!prefs)
47760:         return val;
47760: 
47760:     prefs->GetBoolPref("mozilla.widget.force-24bpp", &val);
47760:     return val;
47760: }
47760: 
47760: already_AddRefed<gfxASurface>
47760: gfxXlibSurface::CreateSimilarSurface(gfxContentType aContent,
47760:                                      const gfxIntSize& aSize)
47760: {
59394:     if (!mSurface || !mSurfaceValid) {
59394:       return nsnull;
59394:     }
59394: 
47760:     if (aContent == CONTENT_COLOR) {
48435:         // cairo_surface_create_similar will use a matching visual if it can.
48435:         // However, systems with 16-bit or indexed default visuals may benefit
48435:         // from rendering with 24-bit formats.
48435:         static PRBool force24bpp = GetForce24bppPref();
48435:         if (force24bpp
48435:             && cairo_xlib_surface_get_depth(CairoSurface()) != 24) {
47760:             XRenderPictFormat* format =
48435:                 XRenderFindStandardFormat(mDisplay, PictStandardRGB24);
47760:             if (format) {
48435:                 // Cairo only performs simple self-copies as desired if it
48435:                 // knows that this is a Pixmap surface.  It only knows that
48435:                 // surfaces are pixmap surfaces if it creates the Pixmap
48435:                 // itself, so we use cairo_surface_create_similar with a
48435:                 // temporary reference surface to indicate the format.
48435:                 Screen* screen = cairo_xlib_surface_get_screen(CairoSurface());
48435:                 nsRefPtr<gfxXlibSurface> depth24reference =
48435:                     gfxXlibSurface::Create(screen, format,
48435:                                            gfxIntSize(1, 1), mDrawable);
48435:                 if (depth24reference)
48435:                     return depth24reference->
48435:                         gfxASurface::CreateSimilarSurface(aContent, aSize);
48435:             }
48435:         }
47760:     }
47760: 
47760:     return gfxASurface::CreateSimilarSurface(aContent, aSize);
47760: }
47760: 
    1: void
    1: gfxXlibSurface::DoSizeQuery()
    1: {
    1:     // figure out width/height/depth
    1:     Window root_ignore;
    1:     int x_ignore, y_ignore;
    1:     unsigned int bwidth_ignore, width, height, depth;
    1: 
    1:     XGetGeometry(mDisplay,
    1:                  mDrawable,
    1:                  &root_ignore, &x_ignore, &y_ignore,
    1:                  &width, &height,
    1:                  &bwidth_ignore, &depth);
    1: 
    1:     mSize.width = width;
    1:     mSize.height = height;
    1: }
    1: 
47116: class DisplayTable {
47116: public:
47116:     static PRBool GetColormapAndVisual(Screen* screen,
47116:                                        XRenderPictFormat* format,
47116:                                        Visual* visual, Colormap* colormap,
47116:                                        Visual** visualForColormap);
47116: 
47116: private:
47116:     struct ColormapEntry {
47116:         XRenderPictFormat* mFormat;
47116:         // The Screen is needed here because colormaps (and their visuals) may
47116:         // only be used on one Screen, but XRenderPictFormats are not unique
47116:         // to any one Screen.
47116:         Screen* mScreen;
47116:         Visual* mVisual;
47116:         Colormap mColormap;
47116:     };
47116: 
47116:     class DisplayInfo {
47116:     public:
47116:         DisplayInfo(Display* display) : mDisplay(display) { }
47116:         Display* mDisplay;
47116:         nsTArray<ColormapEntry> mColormapEntries;
47116:     };
47116: 
47116:     // Comparator for finding the DisplayInfo
47116:     class FindDisplay {
47116:     public:
47116:         PRBool Equals(const DisplayInfo& info, const Display *display) const
47116:         {
47116:             return info.mDisplay == display;
47116:         }
47116:     };
47116: 
47116:     static int DisplayClosing(Display *display, XExtCodes* codes);
47116: 
47116:     nsTArray<DisplayInfo> mDisplays;
47116:     static DisplayTable* sDisplayTable;
47116: };
47116: 
47116: DisplayTable* DisplayTable::sDisplayTable;
47116: 
47116: // Pixmaps don't have a particular associated visual but the pixel values are
47116: // interpreted according to a visual/colormap pairs.
47116: //
47116: // cairo is designed for surfaces with either TrueColor visuals or the
47116: // default visual (which may not be true color).  TrueColor visuals don't
47116: // really need a colormap because the visual indicates the pixel format,
47116: // and cairo uses the default visual with the default colormap, so cairo
47116: // surfaces don't need an explicit colormap.
47116: //
47116: // However, some toolkits (e.g. GDK) need a colormap even with TrueColor
47116: // visuals.  We can create a colormap for these visuals, but it will use about
47116: // 20kB of memory in the server, so we use the default colormap when
47116: // suitable and share colormaps between surfaces.  Another reason for
47116: // minimizing colormap turnover is that the plugin process must leak resources
47116: // for each new colormap id when using older GDK libraries (bug 569775).
47116: //
47116: // Only the format of the pixels is important for rendering to Pixmaps, so if
47116: // the format of a visual matches that of the surface, then that visual can be
47116: // used for rendering to the surface.  Multiple visuals can match the same
47116: // format (but have different GLX properties), so the visual returned may
47116: // differ from the visual passed in.  Colormaps are tied to a visual, so
47116: // should only be used with their visual.
47116: 
47116: /* static */ PRBool
47116: DisplayTable::GetColormapAndVisual(Screen* aScreen, XRenderPictFormat* aFormat,
47116:                                    Visual* aVisual, Colormap* aColormap,
47116:                                    Visual** aVisualForColormap)
47116: 
47116: {
47116:     Display* display = DisplayOfScreen(aScreen);
47116: 
47116:     // Use the default colormap if the default visual matches.
47116:     Visual *defaultVisual = DefaultVisualOfScreen(aScreen);
47116:     if (aVisual == defaultVisual
47116:         || (aFormat
47116:             && aFormat == XRenderFindVisualFormat(display, defaultVisual)))
47116:     {
47116:         *aColormap = DefaultColormapOfScreen(aScreen);
47116:         *aVisualForColormap = defaultVisual;
47116:         return PR_TRUE;
47116:     }
47116: 
47116:     // Only supporting TrueColor non-default visuals
47116:     if (!aVisual || aVisual->c_class != TrueColor)
47116:         return PR_FALSE;
47116: 
47116:     if (!sDisplayTable) {
47116:         sDisplayTable = new DisplayTable();
47116:     }
47116: 
47116:     nsTArray<DisplayInfo>* displays = &sDisplayTable->mDisplays;
47116:     PRUint32 d = displays->IndexOf(display, 0, FindDisplay());
47116: 
47116:     if (d == displays->NoIndex) {
47116:         d = displays->Length();
47116:         // Register for notification of display closing, when this info
47116:         // becomes invalid.
47116:         XExtCodes *codes = XAddExtension(display);
47116:         if (!codes)
47116:             return PR_FALSE;
47116: 
47116:         XESetCloseDisplay(display, codes->extension, DisplayClosing);
47116:         // Add a new DisplayInfo.
47116:         displays->AppendElement(display);
47116:     }
47116: 
47116:     nsTArray<ColormapEntry>* entries =
47116:         &displays->ElementAt(d).mColormapEntries;
47116: 
47116:     // Only a small number of formats are expected to be used, so just do a
47116:     // simple linear search.
47116:     for (PRUint32 i = 0; i < entries->Length(); ++i) {
47116:         const ColormapEntry& entry = entries->ElementAt(i);
47116:         // Only the format and screen need to match.  (The visual may differ.)
47116:         // If there is no format (e.g. no RENDER extension) then just compare
47116:         // the visual.
47116:         if ((aFormat && entry.mFormat == aFormat && entry.mScreen == aScreen)
47116:             || aVisual == entry.mVisual) {
47116:             *aColormap = entry.mColormap;
47116:             *aVisualForColormap = entry.mVisual;
47116:             return PR_TRUE;
47116:         }
47116:     }
47116: 
47116:     // No existing entry.  Create a colormap and add an entry.
47116:     Colormap colormap = XCreateColormap(display, RootWindowOfScreen(aScreen),
47116:                                         aVisual, AllocNone);
47116:     ColormapEntry* newEntry = entries->AppendElement();
47116:     newEntry->mFormat = aFormat;
47116:     newEntry->mScreen = aScreen;
47116:     newEntry->mVisual = aVisual;
47116:     newEntry->mColormap = colormap;
47116: 
47116:     *aColormap = colormap;
47116:     *aVisualForColormap = aVisual;
47116:     return PR_TRUE;
47116: }
47116: 
47116: /* static */ int
47116: DisplayTable::DisplayClosing(Display *display, XExtCodes* codes)
47116: {
47116:     // No need to free the colormaps explicitly as they will be released when
47116:     // the connection is closed.
47116:     sDisplayTable->mDisplays.RemoveElement(display, FindDisplay());
47116:     if (sDisplayTable->mDisplays.Length() == 0) {
47116:         delete sDisplayTable;
47116:         sDisplayTable = nsnull;
47116:     }
47116:     return 0;
47116: }
47116: 
47116: PRBool
47116: gfxXlibSurface::GetColormapAndVisual(Colormap* aColormap, Visual** aVisual)
47116: {
47116:     if (!mSurfaceValid)
47116:         return PR_FALSE;
47116: 
47116:     XRenderPictFormat* format =
47116:         cairo_xlib_surface_get_xrender_format(CairoSurface());
47116:     Screen* screen = cairo_xlib_surface_get_screen(CairoSurface());
47116:     Visual* visual = cairo_xlib_surface_get_visual(CairoSurface());
47116: 
47116:     return DisplayTable::GetColormapAndVisual(screen, format, visual,
47116:                                               aColormap, aVisual);
47116: }
47116: 
47113: /* static */
47113: int
47113: gfxXlibSurface::DepthOfVisual(const Screen* screen, const Visual* visual)
47113: {
47113:     for (int d = 0; d < screen->ndepths; d++) {
47113:         const Depth& d_info = screen->depths[d];
47113:         if (visual >= &d_info.visuals[0]
47113:             && visual < &d_info.visuals[d_info.nvisuals])
47113:             return d_info.depth;
47113:     }
47113: 
47113:     NS_ERROR("Visual not on Screen.");
47113:     return 0;
47113: }
47113:     
47113: /* static */
48108: Visual*
48108: gfxXlibSurface::FindVisual(Screen *screen, gfxImageFormat format)
48108: {
48108:     int depth;
48108:     unsigned long red_mask, green_mask, blue_mask;
48108:     switch (format) {
48108:         case ImageFormatARGB32:
48108:             depth = 32;
48108:             red_mask = 0xff0000;
48108:             green_mask = 0xff00;
48108:             blue_mask = 0xff;
48108:             break;
48108:         case ImageFormatRGB24:
48108:             depth = 24;
48108:             red_mask = 0xff0000;
48108:             green_mask = 0xff00;
48108:             blue_mask = 0xff;
48108:             break;
48108:         case ImageFormatRGB16_565:
48108:             depth = 16;
48108:             red_mask = 0xf800;
48108:             green_mask = 0x7e0;
48108:             blue_mask = 0x1f;
48108:             break;
48108:         case ImageFormatA8:
48108:         case ImageFormatA1:
48108:         default:
48108:             return NULL;
48108:     }
48108: 
48108:     for (int d = 0; d < screen->ndepths; d++) {
48108:         const Depth& d_info = screen->depths[d];
48108:         if (d_info.depth != depth)
48108:             continue;
48108: 
48108:         for (int v = 0; v < d_info.nvisuals; v++) {
48108:             Visual* visual = &d_info.visuals[v];
48108: 
48108:             if (visual->c_class == TrueColor &&
48108:                 visual->red_mask == red_mask &&
48108:                 visual->green_mask == green_mask &&
48108:                 visual->blue_mask == blue_mask)
48108:                 return visual;
48108:         }
48108:     }
48108: 
48108:     return NULL;
48108: }
48108: 
48108: /* static */
    1: XRenderPictFormat*
    1: gfxXlibSurface::FindRenderFormat(Display *dpy, gfxImageFormat format)
    1: {
    1:     switch (format) {
    1:         case ImageFormatARGB32:
    1:             return XRenderFindStandardFormat (dpy, PictStandardARGB32);
    1:         case ImageFormatRGB24:
    1:             return XRenderFindStandardFormat (dpy, PictStandardRGB24);
43558:         case ImageFormatRGB16_565: {
43558:             // PictStandardRGB16_565 is not standard Xrender format
43558:             // we should try to find related visual
43558:             // and find xrender format by visual
48108:             Visual *visual = FindVisual(DefaultScreenOfDisplay(dpy), format);
43558:             if (!visual)
43558:                 return NULL;
43558:             return XRenderFindVisualFormat(dpy, visual);
43558:         }
    1:         case ImageFormatA8:
    1:             return XRenderFindStandardFormat (dpy, PictStandardA8);
    1:         case ImageFormatA1:
    1:             return XRenderFindStandardFormat (dpy, PictStandardA1);
48108:         default:
    1:             break;
    1:     }
    1: 
    1:     return (XRenderPictFormat*)NULL;
    1: }
52190: 
54106: Screen*
54106: gfxXlibSurface::XScreen()
54106: {
54106:     return cairo_xlib_surface_get_screen(CairoSurface());
54106: }
54106: 
52190: XRenderPictFormat*
52190: gfxXlibSurface::XRenderFormat()
52190: {
52190:     return cairo_xlib_surface_get_xrender_format(CairoSurface());
52190: }
52190: 
