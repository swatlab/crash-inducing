    1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Foundation code.
    1:  *
    1:  * The Initial Developer of the Original Code is Mozilla Foundation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Vladimir Vukicevic <vladimir@pobox.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "gfxPlatform.h"
    1: 
    1: #if defined(XP_WIN)
    1: #include "gfxWindowsPlatform.h"
    1: #elif defined(XP_MACOSX)
    1: #include "gfxPlatformMac.h"
    1: #elif defined(MOZ_WIDGET_GTK2)
    1: #include "gfxPlatformGtk.h"
16758: #elif defined(MOZ_WIDGET_QT)
16758: #include "gfxQtPlatform.h"
    1: #elif defined(XP_BEOS)
    1: #include "gfxBeOSPlatform.h"
    1: #elif defined(XP_OS2)
    1: #include "gfxOS2Platform.h"
42153: #elif defined(ANDROID)
42153: #include "gfxAndroidPlatform.h"
    1: #endif
    1: 
38493: #include "gfxAtoms.h"
31590: #include "gfxPlatformFontList.h"
    1: #include "gfxContext.h"
    1: #include "gfxImageSurface.h"
  218: #include "gfxTextRunCache.h"
 3118: #include "gfxTextRunWordCache.h"
19962: #include "gfxUserFontSet.h"
    1: 
37211: #include "nsUnicodeRange.h"
    1: #include "nsServiceManagerUtils.h"
23904: #include "nsTArray.h"
37211: #include "nsIUGenCategory.h"
37211: #include "nsUnicharUtilCIID.h"
37211: #include "nsILocaleService.h"
    1: 
19003: #include "nsWeakReference.h"
19003: 
    1: #include "cairo.h"
27035: #include "qcms.h"
 3787: 
11086: #include "plstr.h"
 3787: #include "nsIPrefService.h"
 3787: #include "nsIPrefBranch.h"
19003: #include "nsIPrefBranch2.h"
37211: #include "nsIPrefLocalizedString.h"
36949: #include "nsCRT.h"
47967: #include "GLContext.h"
47967: #include "GLContextProvider.h"
    1: 
41340: #include "mozilla/FunctionTimer.h"
41340: 
51677: #include "nsIGfxInfo.h"
51677: 
    1: gfxPlatform *gPlatform = nsnull;
15987: 
15987: // These two may point to the same profile
27035: static qcms_profile *gCMSOutputProfile = nsnull;
27035: static qcms_profile *gCMSsRGBProfile = nsnull;
15987: 
27035: static qcms_transform *gCMSRGBTransform = nsnull;
27035: static qcms_transform *gCMSInverseRGBTransform = nsnull;
27035: static qcms_transform *gCMSRGBATransform = nsnull;
    1: 
19003: static PRBool gCMSInitialized = PR_FALSE;
19003: static eCMSMode gCMSMode = eCMSMode_Off;
19003: static int gCMSIntent = -2;
19003: 
16571: static const char *CMPrefName = "gfx.color_management.mode";
16571: static const char *CMPrefNameOld = "gfx.color_management.enabled";
16571: static const char *CMIntentPrefName = "gfx.color_management.rendering_intent";
19003: static const char *CMProfilePrefName = "gfx.color_management.display_profile";
19003: static const char *CMForceSRGBPrefName = "gfx.color_management.force_srgb";
19003: 
19003: static void ShutdownCMS();
16571: static void MigratePrefs();
16571: 
19003: /* Class to listen for pref changes so that chrome code can dynamically
19003:    force sRGB as an output profile. See Bug #452125. */
19003: class SRGBOverrideObserver : public nsIObserver,
19003:                              public nsSupportsWeakReference
19003: {
19003: public:
19003:     NS_DECL_ISUPPORTS
19003:     NS_DECL_NSIOBSERVER
19003: };
19003: 
19003: NS_IMPL_ISUPPORTS2(SRGBOverrideObserver, nsIObserver, nsISupportsWeakReference)
19003: 
19003: NS_IMETHODIMP
19003: SRGBOverrideObserver::Observe(nsISupports *aSubject,
19003:                               const char *aTopic,
19003:                               const PRUnichar *someData)
19003: {
19003:     NS_ASSERTION(NS_strcmp(someData,
19003:                    NS_LITERAL_STRING("gfx.color_mangement.force_srgb").get()),
19003:                  "Restarting CMS on wrong pref!");
19003:     ShutdownCMS();
19003:     return NS_OK;
19003: }
19003: 
42854: #define GFX_DOWNLOADABLE_FONTS_ENABLED "gfx.downloadable_fonts.enabled"
55084: #define GFX_DOWNLOADABLE_FONTS_SANITIZE "gfx.downloadable_fonts.sanitize"
55086: #define GFX_DOWNLOADABLE_FONTS_SANITIZE_PRESERVE_OTL \
55086:             "gfx.downloadable_fonts.sanitize.preserve_otl_tables"
42854: 
43527: #define GFX_PREF_HARFBUZZ_LEVEL "gfx.font_rendering.harfbuzz.level"
43527: #define HARFBUZZ_LEVEL_DEFAULT  0
43527: 
42854: class FontPrefsObserver : public nsIObserver
42854: {
42854: public:
42854:     NS_DECL_ISUPPORTS
42854:     NS_DECL_NSIOBSERVER
42854: };
42854: 
42854: NS_IMPL_ISUPPORTS1(FontPrefsObserver, nsIObserver)
42854: 
42854: NS_IMETHODIMP
42854: FontPrefsObserver::Observe(nsISupports *aSubject,
42854:                            const char *aTopic,
42854:                            const PRUnichar *someData)
42854: {
42854:     nsCOMPtr<nsIPrefBranch> branch = do_QueryInterface(aSubject);
42854:     if (!branch || someData == nsnull) {
42854:         NS_ERROR("font pref observer code broken");
42854:         return NS_ERROR_UNEXPECTED;
42854:     }
42854:     
42854:     gfxPlatform::GetPlatform()->FontsPrefsChanged(branch, 
42854:         NS_ConvertUTF16toUTF8(someData).get());
42854: 
42854:     return NS_OK;
42854: }
42854: 
42854: 
19003: 
11086: // this needs to match the list of pref font.default.xx entries listed in all.js!
11086: // the order *must* match the order in eFontPrefLang
11086: static const char *gPrefLangNames[] = {
11086:     "x-western",
11086:     "x-central-euro",
11086:     "ja",
11086:     "zh-TW",
11086:     "zh-CN",
11086:     "zh-HK",
11086:     "ko",
11086:     "x-cyrillic",
11086:     "x-baltic",
11086:     "el",
11086:     "tr",
11086:     "th",
11086:     "he",
11086:     "ar",
11086:     "x-devanagari",
11086:     "x-tamil",
11086:     "x-armn",
11086:     "x-beng",
11086:     "x-cans",
11086:     "x-ethi",
11086:     "x-geor",
11086:     "x-gujr",
11086:     "x-guru",
11086:     "x-khmr",
11086:     "x-mlym",
13885:     "x-orya",
13885:     "x-telu",
13885:     "x-knda",
13885:     "x-sinh",
38930:     "x-tibt",
11086:     "x-unicode",
11086:     "x-user-def"
11086: };
11086: 
42854: gfxPlatform::gfxPlatform()
42854: {
43527:     mUseHarfBuzzLevel = UNINITIALIZED_VALUE;
42854:     mAllowDownloadableFonts = UNINITIALIZED_VALUE;
55084:     mDownloadableFontsSanitize = UNINITIALIZED_VALUE;
55086:     mSanitizePreserveOTLTables = UNINITIALIZED_VALUE;
42854: }
11086: 
    1: gfxPlatform*
    1: gfxPlatform::GetPlatform()
    1: {
  218:     return gPlatform;
  218: }
  218: 
  218: nsresult
  218: gfxPlatform::Init()
  218: {
  218:     NS_ASSERTION(!gPlatform, "Already started???");
38493: 
38493:     gfxAtoms::RegisterAtoms();
38493: 
51677:     /* Initialize the GfxInfo service.
51677:      * Note: we can't call functions on GfxInfo that depend
51677:      * on gPlatform until after it has been initialized
51677:      * below. GfxInfo initialization annotates our
51677:      * crash reports so we want to do it before
51677:      * we try to load any drivers and do device detection
51677:      * incase that code crashes. See bug #591561. */
51677:     nsCOMPtr<nsIGfxInfo> gfxInfo;
51677:     /* this currently will only succeed on Windows */
51677:     gfxInfo = do_GetService("@mozilla.org/gfx/info;1");
51677: 
    1: #if defined(XP_WIN)
    1:     gPlatform = new gfxWindowsPlatform;
    1: #elif defined(XP_MACOSX)
    1:     gPlatform = new gfxPlatformMac;
    1: #elif defined(MOZ_WIDGET_GTK2)
    1:     gPlatform = new gfxPlatformGtk;
16758: #elif defined(MOZ_WIDGET_QT)
16758:     gPlatform = new gfxQtPlatform;
    1: #elif defined(XP_BEOS)
    1:     gPlatform = new gfxBeOSPlatform;
    1: #elif defined(XP_OS2)
    1:     gPlatform = new gfxOS2Platform;
42153: #elif defined(ANDROID)
42153:     gPlatform = new gfxAndroidPlatform;
    1: #endif
  218:     if (!gPlatform)
  218:         return NS_ERROR_OUT_OF_MEMORY;
  218: 
  218:     nsresult rv;
  218: 
48022: #if defined(XP_MACOSX) || defined(XP_WIN) || defined(ANDROID) // temporary, until this is implemented on others
31590:     rv = gfxPlatformFontList::Init();
  218:     if (NS_FAILED(rv)) {
31590:         NS_ERROR("Could not initialize gfxPlatformFontList");
  218:         Shutdown();
  218:         return rv;
  218:     }
  218: #endif
  218: 
57104:     gPlatform->mScreenReferenceSurface =
57104:         gPlatform->CreateOffscreenSurface(gfxIntSize(1,1),
57104:                                           gfxASurface::CONTENT_COLOR_ALPHA);
57104:     if (!gPlatform->mScreenReferenceSurface) {
57104:         NS_ERROR("Could not initialize mScreenReferenceSurface");
57104:         Shutdown();
57104:         return NS_ERROR_OUT_OF_MEMORY;
57104:     }
57104: 
  323:     rv = gfxFontCache::Init();
  323:     if (NS_FAILED(rv)) {
  323:         NS_ERROR("Could not initialize gfxFontCache");
  323:         Shutdown();
  323:         return rv;
  323:     }
  323: 
 3118:     rv = gfxTextRunWordCache::Init();
  218:     if (NS_FAILED(rv)) {
 3118:         NS_ERROR("Could not initialize gfxTextRunWordCache");
 3118:         Shutdown();
 3118:         return rv;
 3118:     }
 3118: 
 3118:     rv = gfxTextRunCache::Init();
 3118:     if (NS_FAILED(rv)) {
 3118:         NS_ERROR("Could not initialize gfxTextRunCache");
  218:         Shutdown();
  218:         return rv;
    1:     }
    1: 
16571:     /* Pref migration hook. */
16571:     MigratePrefs();
16571: 
19003:     /* Create and register our CMS Override observer. */
19003:     gPlatform->overrideObserver = new SRGBOverrideObserver();
42854:     FontPrefsObserver *fontPrefObserver = new FontPrefsObserver();
42854: 
19003:     nsCOMPtr<nsIPrefBranch2> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
42854:     if (prefs) {
19003:         prefs->AddObserver(CMForceSRGBPrefName, gPlatform->overrideObserver, PR_TRUE);
55084:         prefs->AddObserver("gfx.downloadable_fonts.", fontPrefObserver, PR_FALSE);
42854:         prefs->AddObserver("gfx.font_rendering.", fontPrefObserver, PR_FALSE);
42854:     }
19003: 
  218:     return NS_OK;
    1: }
    1: 
    1: void
    1: gfxPlatform::Shutdown()
    1: {
  218:     // These may be called before the corresponding subsystems have actually
  218:     // started up. That's OK, they can handle it.
 3118:     gfxTextRunCache::Shutdown();
 3118:     gfxTextRunWordCache::Shutdown();
  323:     gfxFontCache::Shutdown();
38492:     gfxFontGroup::Shutdown();
36949: #if defined(XP_MACOSX) || defined(XP_WIN) // temporary, until this is implemented on others
31590:     gfxPlatformFontList::Shutdown();
  218: #endif
15987: 
15987:     // Free the various non-null transforms and loaded profiles
19003:     ShutdownCMS();
15987: 
19003:     /* Unregister our CMS Override callback. */
19003:     nsCOMPtr<nsIPrefBranch2> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
19003:     if (prefs)
19003:         prefs->RemoveObserver(CMForceSRGBPrefName, gPlatform->overrideObserver);
15987: 
47967:     mozilla::gl::GLContextProvider::Shutdown();
47967: 
    1:     delete gPlatform;
    1:     gPlatform = nsnull;
    1: }
    1: 
    1: gfxPlatform::~gfxPlatform()
    1: {
    1:     // The cairo folks think we should only clean up in debug builds,
    1:     // but we're generally in the habit of trying to shut down as
    1:     // cleanly as possible even in production code, so call this
    1:     // cairo_debug_* function unconditionally.
 7193:     //
 7193:     // because cairo can assert and thus crash on shutdown, don't do this in release builds
11579: #if MOZ_TREE_CAIRO && (defined(DEBUG) || defined(NS_BUILD_REFCNT_LOGGING) || defined(NS_TRACE_MALLOC))
    1:     cairo_debug_reset_static_data();
 7193: #endif
 6695: 
 6695: #if 0
 6695:     // It would be nice to do this (although it might need to be after
 6695:     // the cairo shutdown that happens in ~gfxPlatform).  It even looks
 6695:     // idempotent.  But it has fatal assertions that fire if stuff is
 6695:     // leaked, and we hit them.
 6695:     FcFini();
 6695: #endif
    1: }
    1: 
    1: already_AddRefed<gfxASurface>
 8368: gfxPlatform::OptimizeImage(gfxImageSurface *aSurface,
 8368:                            gfxASurface::gfxImageFormat format)
    1: {
    1:     const gfxIntSize& surfaceSize = aSurface->GetSize();
    1: 
38727: #ifdef XP_WIN
38727:     if (gfxWindowsPlatform::GetPlatform()->GetRenderMode() == 
38727:         gfxWindowsPlatform::RENDER_DIRECT2D) {
38727:         return nsnull;
38727:     }
38727: #endif
54253:     nsRefPtr<gfxASurface> optSurface = CreateOffscreenSurface(surfaceSize, gfxASurface::ContentFromFormat(format));
 8368:     if (!optSurface || optSurface->CairoStatus() != 0)
    1:         return nsnull;
    1: 
 9751:     gfxContext tmpCtx(optSurface);
 9751:     tmpCtx.SetOperator(gfxContext::OPERATOR_SOURCE);
 9751:     tmpCtx.SetSource(aSurface);
 9751:     tmpCtx.Paint();
    1: 
    1:     gfxASurface *ret = optSurface;
    1:     NS_ADDREF(ret);
    1:     return ret;
    1: }
    1: 
    1: nsresult
38493: gfxPlatform::GetFontList(nsIAtom *aLangGroup,
    1:                          const nsACString& aGenericFamily,
23904:                          nsTArray<nsString>& aListOfFonts)
    1: {
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: nsresult
    1: gfxPlatform::UpdateFontList()
    1: {
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
42854: PRBool 
42854: gfxPlatform::GetBoolPref(const char *aPref, PRBool aDefault)
42854: {
42854:     nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
42854:     if (prefs) {
42854:         PRBool allow;
42854:         nsresult rv = prefs->GetBoolPref(aPref, &allow);
42854:         if (NS_SUCCEEDED(rv))
42854:             return allow;
42854:     }
42854: 
42854:     return aDefault;
42854: }
19962: 
19962: PRBool
19962: gfxPlatform::DownloadableFontsEnabled()
19962: {
42854:     if (mAllowDownloadableFonts == UNINITIALIZED_VALUE) {
55084:         mAllowDownloadableFonts =
55084:             GetBoolPref(GFX_DOWNLOADABLE_FONTS_ENABLED, PR_FALSE);
19962:     }
19962: 
42854:     return mAllowDownloadableFonts;
19962: }
19962: 
55084: PRBool
55084: gfxPlatform::SanitizeDownloadedFonts()
55084: {
55084:     if (mDownloadableFontsSanitize == UNINITIALIZED_VALUE) {
55084:         mDownloadableFontsSanitize =
55084:             GetBoolPref(GFX_DOWNLOADABLE_FONTS_SANITIZE, PR_TRUE);
55084:     }
55084: 
55084:     return mDownloadableFontsSanitize;
55084: }
55084: 
55086: PRBool
55086: gfxPlatform::PreserveOTLTablesWhenSanitizing()
55086: {
55086:     if (mSanitizePreserveOTLTables == UNINITIALIZED_VALUE) {
55086:         mSanitizePreserveOTLTables =
55086:             GetBoolPref(GFX_DOWNLOADABLE_FONTS_SANITIZE_PRESERVE_OTL, PR_FALSE);
55086:     }
55086: 
55086:     return mSanitizePreserveOTLTables;
55086: }
55086: 
43527: PRInt8
43527: gfxPlatform::UseHarfBuzzLevel()
43527: {
43527:     if (mUseHarfBuzzLevel == UNINITIALIZED_VALUE) {
43527:         mUseHarfBuzzLevel = HARFBUZZ_LEVEL_DEFAULT;
43527:         nsCOMPtr<nsIPrefBranch2> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
43527:         if (prefs) {
43527:             PRInt32 level;
43527:             nsresult rv = prefs->GetIntPref(GFX_PREF_HARFBUZZ_LEVEL, &level);
43527:             if (NS_SUCCEEDED(rv)) {
43527:                 mUseHarfBuzzLevel = level;
43527:             }
43527:         }
43527:     }
43527: 
43527:     return mUseHarfBuzzLevel;
43527: }
43527: 
32808: gfxFontEntry*
32808: gfxPlatform::MakePlatformFont(const gfxProxyFontEntry *aProxyEntry,
32808:                               const PRUint8 *aFontData,
32808:                               PRUint32 aLength)
32808: {
32808:     // Default implementation does not handle activating downloaded fonts;
32808:     // just free the data and return.
32808:     // Platforms that support @font-face must override this,
32808:     // using the data to instantiate the font, and taking responsibility
32808:     // for freeing it when no longer required.
32808:     if (aFontData) {
32808:         NS_Free((void*)aFontData);
32808:     }
32808:     return nsnull;
32808: }
19962: 
    1: static void
38493: AppendGenericFontFromPref(nsString& aFonts, nsIAtom *aLangGroup, const char *aGenericName)
    1: {
    1:     nsresult rv;
    1: 
26915:     nsCOMPtr<nsIPrefBranch> prefs(do_GetService(NS_PREFSERVICE_CONTRACTID));
    1:     if (!prefs)
    1:         return;
    1: 
38493:     nsCAutoString prefName, langGroupString;
26915:     nsXPIDLCString nameValue, nameListValue;
    1: 
38493:     aLangGroup->ToUTF8String(langGroupString);
38493: 
26915:     nsCAutoString genericDotLang;
    1:     if (aGenericName) {
26915:         genericDotLang.Assign(aGenericName);
    1:     } else {
    1:         prefName.AssignLiteral("font.default.");
38493:         prefName.Append(langGroupString);
26915:         prefs->GetCharPref(prefName.get(), getter_Copies(genericDotLang));
    1:     }
    1: 
    1:     genericDotLang.AppendLiteral(".");
38493:     genericDotLang.Append(langGroupString);
    1: 
 9699:     // fetch font.name.xxx value                   
    1:     prefName.AssignLiteral("font.name.");
    1:     prefName.Append(genericDotLang);
26915:     rv = prefs->GetCharPref(prefName.get(), getter_Copies(nameValue));
    1:     if (NS_SUCCEEDED(rv)) {
    1:         if (!aFonts.IsEmpty())
    1:             aFonts.AppendLiteral(", ");
26915:         aFonts.Append(NS_ConvertUTF8toUTF16(nameValue));
    1:     }
    1: 
 9699:     // fetch font.name-list.xxx value                   
    1:     prefName.AssignLiteral("font.name-list.");
    1:     prefName.Append(genericDotLang);
26915:     rv = prefs->GetCharPref(prefName.get(), getter_Copies(nameListValue));
 9699:     if (NS_SUCCEEDED(rv) && !nameListValue.Equals(nameValue)) {
    1:         if (!aFonts.IsEmpty())
    1:             aFonts.AppendLiteral(", ");
26915:         aFonts.Append(NS_ConvertUTF8toUTF16(nameListValue));
    1:     }
    1: }
    1: 
    1: void
38493: gfxPlatform::GetPrefFonts(nsIAtom *aLanguage, nsString& aFonts, PRBool aAppendUnicode)
    1: {
    1:     aFonts.Truncate();
    1: 
38492:     AppendGenericFontFromPref(aFonts, aLanguage, nsnull);
 3609:     if (aAppendUnicode)
38493:         AppendGenericFontFromPref(aFonts, gfxAtoms::x_unicode, nsnull);
    1: }
    1: 
11086: PRBool gfxPlatform::ForEachPrefFont(eFontPrefLang aLangArray[], PRUint32 aLangArrayLen, PrefFontCallback aCallback,
11086:                                     void *aClosure)
11086: {
11086:     nsresult rv;
11086: 
26915:     nsCOMPtr<nsIPrefBranch> prefs(do_GetService(NS_PREFSERVICE_CONTRACTID));
11086:     if (!prefs)
11086:         return PR_FALSE;
11086: 
11086:     PRUint32    i;
11086:     
11086:     for (i = 0; i < aLangArrayLen; i++) {
11086:         eFontPrefLang prefLang = aLangArray[i];
11086:         const char *langGroup = GetPrefLangName(prefLang);
11086:         
11086:         nsCAutoString prefName;
26915:         nsXPIDLCString nameValue, nameListValue;
11086:     
26915:         nsCAutoString genericDotLang;
11086:         prefName.AssignLiteral("font.default.");
11086:         prefName.Append(langGroup);
26915:         prefs->GetCharPref(prefName.get(), getter_Copies(genericDotLang));
11086:     
11086:         genericDotLang.AppendLiteral(".");
11086:         genericDotLang.Append(langGroup);
11086:     
11086:         // fetch font.name.xxx value                   
11086:         prefName.AssignLiteral("font.name.");
11086:         prefName.Append(genericDotLang);
26915:         rv = prefs->GetCharPref(prefName.get(), getter_Copies(nameValue));
11086:         if (NS_SUCCEEDED(rv)) {
26915:             if (!aCallback(prefLang, NS_ConvertUTF8toUTF16(nameValue), aClosure))
11086:                 return PR_FALSE;
11086:         }
11086:     
11086:         // fetch font.name-list.xxx value                   
11086:         prefName.AssignLiteral("font.name-list.");
11086:         prefName.Append(genericDotLang);
26915:         rv = prefs->GetCharPref(prefName.get(), getter_Copies(nameListValue));
11086:         if (NS_SUCCEEDED(rv) && !nameListValue.Equals(nameValue)) {
36949:             const char kComma = ',';
36949:             const char *p, *p_end;
36949:             nsCAutoString list(nameListValue);
36949:             list.BeginReading(p);
36949:             list.EndReading(p_end);
36949:             while (p < p_end) {
36949:                 while (nsCRT::IsAsciiSpace(*p)) {
36949:                     if (++p == p_end)
36949:                         break;
36949:                 }
36949:                 if (p == p_end)
36949:                     break;
36949:                 const char *start = p;
36949:                 while (++p != p_end && *p != kComma)
36949:                     /* nothing */ ;
36949:                 nsCAutoString fontName(Substring(start, p));
36949:                 fontName.CompressWhitespace(PR_FALSE, PR_TRUE);
36949:                 if (!aCallback(prefLang, NS_ConvertUTF8toUTF16(fontName), aClosure))
11086:                     return PR_FALSE;
36949:                 p++;
36949:             }
11086:         }
11086:     }
11086: 
11086:     return PR_TRUE;
11086: }
11086: 
11086: eFontPrefLang
11086: gfxPlatform::GetFontPrefLangFor(const char* aLang)
11086: {
11086:     if (!aLang || !aLang[0])
11086:         return eFontPrefLang_Others;
11086:     for (PRUint32 i = 0; i < PRUint32(eFontPrefLang_LangCount); ++i) {
11086:         if (!PL_strcasecmp(gPrefLangNames[i], aLang))
11086:             return eFontPrefLang(i);
11086:     }
11086:     return eFontPrefLang_Others;
11086: }
11086: 
38493: eFontPrefLang
38493: gfxPlatform::GetFontPrefLangFor(nsIAtom *aLang)
38493: {
38493:     if (!aLang)
38493:         return eFontPrefLang_Others;
38493:     nsCAutoString lang;
38493:     aLang->ToUTF8String(lang);
38493:     return GetFontPrefLangFor(lang.get());
38493: }
38493: 
11086: const char*
11086: gfxPlatform::GetPrefLangName(eFontPrefLang aLang)
11086: {
11086:     if (PRUint32(aLang) < PRUint32(eFontPrefLang_AllCount))
11086:         return gPrefLangNames[PRUint32(aLang)];
11086:     return nsnull;
11086: }
11086: 
37211: eFontPrefLang
37211: gfxPlatform::GetFontPrefLangFor(PRUint8 aUnicodeRange)
37211: {
37211:     switch (aUnicodeRange) {
37211:         case kRangeSetLatin:   return eFontPrefLang_Western;
37211:         case kRangeCyrillic:   return eFontPrefLang_Cyrillic;
37211:         case kRangeGreek:      return eFontPrefLang_Greek;
37211:         case kRangeTurkish:    return eFontPrefLang_Turkish;
37211:         case kRangeHebrew:     return eFontPrefLang_Hebrew;
37211:         case kRangeArabic:     return eFontPrefLang_Arabic;
37211:         case kRangeBaltic:     return eFontPrefLang_Baltic;
37211:         case kRangeThai:       return eFontPrefLang_Thai;
37211:         case kRangeKorean:     return eFontPrefLang_Korean;
37211:         case kRangeJapanese:   return eFontPrefLang_Japanese;
37211:         case kRangeSChinese:   return eFontPrefLang_ChineseCN;
37211:         case kRangeTChinese:   return eFontPrefLang_ChineseTW;
37211:         case kRangeDevanagari: return eFontPrefLang_Devanagari;
37211:         case kRangeTamil:      return eFontPrefLang_Tamil;
37211:         case kRangeArmenian:   return eFontPrefLang_Armenian;
37211:         case kRangeBengali:    return eFontPrefLang_Bengali;
37211:         case kRangeCanadian:   return eFontPrefLang_Canadian;
37211:         case kRangeEthiopic:   return eFontPrefLang_Ethiopic;
37211:         case kRangeGeorgian:   return eFontPrefLang_Georgian;
37211:         case kRangeGujarati:   return eFontPrefLang_Gujarati;
37211:         case kRangeGurmukhi:   return eFontPrefLang_Gurmukhi;
37211:         case kRangeKhmer:      return eFontPrefLang_Khmer;
37211:         case kRangeMalayalam:  return eFontPrefLang_Malayalam;
37211:         case kRangeSetCJK:     return eFontPrefLang_CJKSet;
37211:         default:               return eFontPrefLang_Others;
37211:     }
37211: }
37211: 
11086: PRBool 
11086: gfxPlatform::IsLangCJK(eFontPrefLang aLang)
11086: {
39063:     switch (aLang) {
39063:         case eFontPrefLang_Japanese:
39063:         case eFontPrefLang_ChineseTW:
39063:         case eFontPrefLang_ChineseCN:
39063:         case eFontPrefLang_ChineseHK:
39063:         case eFontPrefLang_Korean:
39063:         case eFontPrefLang_CJKSet:
39063:             return PR_TRUE;
39063:         default:
39063:             return PR_FALSE;
39063:     }
11086: }
11086: 
11086: void 
37211: gfxPlatform::GetLangPrefs(eFontPrefLang aPrefLangs[], PRUint32 &aLen, eFontPrefLang aCharLang, eFontPrefLang aPageLang)
37211: {
37211:     if (IsLangCJK(aCharLang)) {
37211:         AppendCJKPrefLangs(aPrefLangs, aLen, aCharLang, aPageLang);
37211:     } else {
37211:         AppendPrefLang(aPrefLangs, aLen, aCharLang);
37211:     }
37211: 
37211:     AppendPrefLang(aPrefLangs, aLen, eFontPrefLang_Others);
37211: }
37211: 
37211: void
37211: gfxPlatform::AppendCJKPrefLangs(eFontPrefLang aPrefLangs[], PRUint32 &aLen, eFontPrefLang aCharLang, eFontPrefLang aPageLang)
37211: {
37211:     nsCOMPtr<nsIPrefBranch> prefs(do_GetService(NS_PREFSERVICE_CONTRACTID));
37211: 
37211:     // prefer the lang specified by the page *if* CJK
37211:     if (IsLangCJK(aPageLang)) {
37211:         AppendPrefLang(aPrefLangs, aLen, aPageLang);
37211:     }
37211:     
37211:     // if not set up, set up the default CJK order, based on accept lang settings and locale
37211:     if (mCJKPrefLangs.Length() == 0) {
37211:     
37211:         // temp array
37211:         eFontPrefLang tempPrefLangs[kMaxLenPrefLangList];
37211:         PRUint32 tempLen = 0;
37211:         
37211:         // Add the CJK pref fonts from accept languages, the order should be same order
37211:         nsCAutoString list;
37211:         if (prefs) {
37211:             nsCOMPtr<nsIPrefLocalizedString> prefString;
39467:             nsresult rv =
39467:                 prefs->GetComplexValue("intl.accept_languages",
39467:                                        NS_GET_IID(nsIPrefLocalizedString),
39467:                                        getter_AddRefs(prefString));
39467:             if (NS_SUCCEEDED(rv) && prefString) {
37211:                 nsAutoString temp;
37211:                 prefString->ToString(getter_Copies(temp));
37211:                 LossyCopyUTF16toASCII(temp, list);
37211:             }
37211:         }
37211:         
39467:         if (!list.IsEmpty()) {
37211:             const char kComma = ',';
37211:             const char *p, *p_end;
37211:             list.BeginReading(p);
37211:             list.EndReading(p_end);
37211:             while (p < p_end) {
37211:                 while (nsCRT::IsAsciiSpace(*p)) {
37211:                     if (++p == p_end)
37211:                         break;
37211:                 }
37211:                 if (p == p_end)
37211:                     break;
37211:                 const char *start = p;
37211:                 while (++p != p_end && *p != kComma)
37211:                     /* nothing */ ;
37211:                 nsCAutoString lang(Substring(start, p));
37211:                 lang.CompressWhitespace(PR_FALSE, PR_TRUE);
37211:                 eFontPrefLang fpl = gfxPlatform::GetFontPrefLangFor(lang.get());
37211:                 switch (fpl) {
37211:                     case eFontPrefLang_Japanese:
37211:                     case eFontPrefLang_Korean:
37211:                     case eFontPrefLang_ChineseCN:
37211:                     case eFontPrefLang_ChineseHK:
37211:                     case eFontPrefLang_ChineseTW:
37211:                         AppendPrefLang(tempPrefLangs, tempLen, fpl);
37211:                         break;
37211:                     default:
37211:                         break;
37211:                 }
37211:                 p++;
37211:             }
37211:         }
37211: 
37211:         do { // to allow 'break' to abort this block if a call fails
37211:             nsresult rv;
37211:             nsCOMPtr<nsILocaleService> ls =
37211:                 do_GetService(NS_LOCALESERVICE_CONTRACTID, &rv);
37211:             if (NS_FAILED(rv))
37211:                 break;
37211: 
37211:             nsCOMPtr<nsILocale> appLocale;
37211:             rv = ls->GetApplicationLocale(getter_AddRefs(appLocale));
37211:             if (NS_FAILED(rv))
37211:                 break;
37211: 
37211:             nsString localeStr;
37211:             rv = appLocale->
37211:                 GetCategory(NS_LITERAL_STRING(NSILOCALE_MESSAGE), localeStr);
37211:             if (NS_FAILED(rv))
37211:                 break;
37211: 
37211:             const nsAString& lang = Substring(localeStr, 0, 2);
37211:             if (lang.EqualsLiteral("ja")) {
37211:                 AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_Japanese);
37211:             } else if (lang.EqualsLiteral("zh")) {
37211:                 const nsAString& region = Substring(localeStr, 3, 2);
37211:                 if (region.EqualsLiteral("CN")) {
37211:                     AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_ChineseCN);
37211:                 } else if (region.EqualsLiteral("TW")) {
37211:                     AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_ChineseTW);
37211:                 } else if (region.EqualsLiteral("HK")) {
37211:                     AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_ChineseHK);
37211:                 }
37211:             } else if (lang.EqualsLiteral("ko")) {
37211:                 AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_Korean);
37211:             }
37211:         } while (0);
37211: 
37211:         // last resort... (the order is same as old gfx.)
37211:         AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_Japanese);
37211:         AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_Korean);
37211:         AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_ChineseCN);
37211:         AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_ChineseHK);
37211:         AppendPrefLang(tempPrefLangs, tempLen, eFontPrefLang_ChineseTW);
37211:         
37211:         // copy into the cached array
37211:         PRUint32 j;
37211:         for (j = 0; j < tempLen; j++) {
37211:             mCJKPrefLangs.AppendElement(tempPrefLangs[j]);
37211:         }
37211:     }
37211:     
37211:     // append in cached CJK langs
37211:     PRUint32  i, numCJKlangs = mCJKPrefLangs.Length();
37211:     
37211:     for (i = 0; i < numCJKlangs; i++) {
37211:         AppendPrefLang(aPrefLangs, aLen, (eFontPrefLang) (mCJKPrefLangs[i]));
37211:     }
37211:         
37211: }
37211: 
37211: void 
11086: gfxPlatform::AppendPrefLang(eFontPrefLang aPrefLangs[], PRUint32& aLen, eFontPrefLang aAddLang)
11086: {
11086:     if (aLen >= kMaxLenPrefLangList) return;
11086:     
11086:     // make sure
11086:     PRUint32  i = 0;
11086:     while (i < aLen && aPrefLangs[i] != aAddLang) {
11086:         i++;
11086:     }
11086:     
11086:     if (i == aLen) {
11086:         aPrefLangs[aLen] = aAddLang;
11086:         aLen++;
11086:     }
11086: }
11086: 
16571: eCMSMode
16571: gfxPlatform::GetCMSMode()
 3787: {
19003:     if (gCMSInitialized == PR_FALSE) {
19003:         gCMSInitialized = PR_TRUE;
 3787:         nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
 3787:         if (prefs) {
16571:             PRInt32 mode;
 3787:             nsresult rv =
16571:                 prefs->GetIntPref(CMPrefName, &mode);
16571:             if (NS_SUCCEEDED(rv) && (mode >= 0) && (mode < eCMSMode_AllCount)) {
19003:                 gCMSMode = static_cast<eCMSMode>(mode);
 3787:             }
 3787:         }
 3787:     }
19003:     return gCMSMode;
 3787: }
 3787: 
16152: /* Chris Murphy (CM consultant) suggests this as a default in the event that we
16152: cannot reproduce relative + Black Point Compensation.  BPC brings an
16152: unacceptable performance overhead, so we go with perceptual. */
27035: #define INTENT_DEFAULT QCMS_INTENT_PERCEPTUAL
27035: #define INTENT_MIN 0
27035: #define INTENT_MAX 3
16152: 
16152: PRBool
16152: gfxPlatform::GetRenderingIntent()
16152: {
19003:     if (gCMSIntent == -2) {
16152: 
16152:         /* Try to query the pref system for a rendering intent. */
16152:         nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
16152:         if (prefs) {
16152:             PRInt32 pIntent;
16571:             nsresult rv = prefs->GetIntPref(CMIntentPrefName, &pIntent);
16152:             if (NS_SUCCEEDED(rv)) {
16152:               
16152:                 /* If the pref is within range, use it as an override. */
16152:                 if ((pIntent >= INTENT_MIN) && (pIntent <= INTENT_MAX))
19003:                     gCMSIntent = pIntent;
16152: 
16152:                 /* If the pref is out of range, use embedded profile. */
16152:                 else
19003:                     gCMSIntent = -1;
16152:             }
16152:         }
16152: 
16152:         /* If we didn't get a valid intent from prefs, use the default. */
19003:         if (gCMSIntent == -2) 
19003:             gCMSIntent = INTENT_DEFAULT;
16152:     }
19003:     return gCMSIntent;
16152: }
16152: 
19127: void 
27035: gfxPlatform::TransformPixel(const gfxRGBA& in, gfxRGBA& out, qcms_transform *transform)
19127: {
19127: 
19127:     if (transform) {
27035:         /* we want the bytes in RGB order */
19127: #ifdef IS_LITTLE_ENDIAN
27035:         /* ABGR puts the bytes in |RGBA| order on little endian */
19127:         PRUint32 packed = in.Packed(gfxRGBA::PACKED_ABGR);
27035:         qcms_transform_data(transform,
19127:                        (PRUint8 *)&packed, (PRUint8 *)&packed,
19127:                        1);
19127:         out.~gfxRGBA();
19127:         new (&out) gfxRGBA(packed, gfxRGBA::PACKED_ABGR);
19127: #else
27035:         /* ARGB puts the bytes in |ARGB| order on big endian */
19127:         PRUint32 packed = in.Packed(gfxRGBA::PACKED_ARGB);
27035:         /* add one to move past the alpha byte */
27035:         qcms_transform_data(transform,
19127:                        (PRUint8 *)&packed + 1, (PRUint8 *)&packed + 1,
19127:                        1);
19127:         out.~gfxRGBA();
19127:         new (&out) gfxRGBA(packed, gfxRGBA::PACKED_ARGB);
19127: #endif
19127:     }
19127: 
19127:     else if (&out != &in)
19127:         out = in;
19127: }
16152: 
27035: qcms_profile *
 3787: gfxPlatform::GetPlatformCMSOutputProfile()
 3787: {
 3787:     return nsnull;
 3787: }
 3787: 
27035: qcms_profile *
 3787: gfxPlatform::GetCMSOutputProfile()
 3787: {
 3787:     if (!gCMSOutputProfile) {
41340:         NS_TIME_FUNCTION;
 3787: 
 3787:         nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
 3787:         if (prefs) {
19003: 
19003:             nsresult rv;
19003: 
19003:             /* Determine if we're using the internal override to force sRGB as
19003:                an output profile for reftests. See Bug 452125. */
19003:             PRBool hasSRGBOverride, doSRGBOverride;
19003:             rv = prefs->PrefHasUserValue(CMForceSRGBPrefName, &hasSRGBOverride);
19003:             if (NS_SUCCEEDED(rv) && hasSRGBOverride) {
19003:                 rv = prefs->GetBoolPref(CMForceSRGBPrefName, &doSRGBOverride);
19003:                 if (NS_SUCCEEDED(rv) && doSRGBOverride)
19003:                     gCMSOutputProfile = GetCMSsRGBProfile();
19003:             }
19003: 
19003:             if (!gCMSOutputProfile) {
19003: 
 3787:                 nsXPIDLCString fname;
19003:                 rv = prefs->GetCharPref(CMProfilePrefName,
 3787:                                         getter_Copies(fname));
 3787:                 if (NS_SUCCEEDED(rv) && !fname.IsEmpty()) {
27035:                     gCMSOutputProfile = qcms_profile_from_path(fname);
19003:                 }
 3787:             }
 3787:         }
 3787: 
 3787:         if (!gCMSOutputProfile) {
 3787:             gCMSOutputProfile =
 3787:                 gfxPlatform::GetPlatform()->GetPlatformCMSOutputProfile();
 3787:         }
 3787: 
22446:         /* Determine if the profile looks bogus. If so, close the profile
22446:          * and use sRGB instead. See bug 460629, */
27035:         if (gCMSOutputProfile && qcms_profile_is_bogus(gCMSOutputProfile)) {
22446:             NS_ASSERTION(gCMSOutputProfile != GetCMSsRGBProfile(),
22446:                          "Builtin sRGB profile tagged as bogus!!!");
27035:             qcms_profile_release(gCMSOutputProfile);
22446:             gCMSOutputProfile = nsnull;
22446:         }
22446: 
 3787:         if (!gCMSOutputProfile) {
15987:             gCMSOutputProfile = GetCMSsRGBProfile();
 3787:         }
16720:         /* Precache the LUT16 Interpolations for the output profile. See 
16720:            bug 444661 for details. */
27035:         qcms_profile_precache_output_transform(gCMSOutputProfile);
 3787:     }
 3787: 
 3787:     return gCMSOutputProfile;
 3787: }
 3787: 
27035: qcms_profile *
15987: gfxPlatform::GetCMSsRGBProfile()
15987: {
16720:     if (!gCMSsRGBProfile) {
16720: 
32801:         /* Create the profile using qcms. */
27035:         gCMSsRGBProfile = qcms_profile_sRGB();
16720:     }
15987:     return gCMSsRGBProfile;
15987: }
15987: 
27035: qcms_transform *
 3787: gfxPlatform::GetCMSRGBTransform()
 3787: {
 3787:     if (!gCMSRGBTransform) {
27035:         qcms_profile *inProfile, *outProfile;
 3787:         outProfile = GetCMSOutputProfile();
15987:         inProfile = GetCMSsRGBProfile();
 3787: 
 3787:         if (!inProfile || !outProfile)
 3787:             return nsnull;
 3787: 
27035:         gCMSRGBTransform = qcms_transform_create(inProfile, QCMS_DATA_RGB_8,
27035:                                               outProfile, QCMS_DATA_RGB_8,
27035:                                              QCMS_INTENT_PERCEPTUAL);
 3787:     }
 3787: 
 3787:     return gCMSRGBTransform;
 3787: }
 3787: 
27035: qcms_transform *
 5465: gfxPlatform::GetCMSInverseRGBTransform()
 5465: {
 5465:     if (!gCMSInverseRGBTransform) {
27035:         qcms_profile *inProfile, *outProfile;
 5465:         inProfile = GetCMSOutputProfile();
15987:         outProfile = GetCMSsRGBProfile();
 5465: 
 5465:         if (!inProfile || !outProfile)
 5465:             return nsnull;
 5465: 
27035:         gCMSInverseRGBTransform = qcms_transform_create(inProfile, QCMS_DATA_RGB_8,
27035:                                                      outProfile, QCMS_DATA_RGB_8,
27035:                                                      QCMS_INTENT_PERCEPTUAL);
 5465:     }
 5465: 
 5465:     return gCMSInverseRGBTransform;
 5465: }
 5465: 
27035: qcms_transform *
 3787: gfxPlatform::GetCMSRGBATransform()
 3787: {
 3787:     if (!gCMSRGBATransform) {
27035:         qcms_profile *inProfile, *outProfile;
 3787:         outProfile = GetCMSOutputProfile();
15987:         inProfile = GetCMSsRGBProfile();
 3787: 
 3787:         if (!inProfile || !outProfile)
 3787:             return nsnull;
 3787: 
27035:         gCMSRGBATransform = qcms_transform_create(inProfile, QCMS_DATA_RGBA_8,
27035:                                                outProfile, QCMS_DATA_RGBA_8,
27035:                                                QCMS_INTENT_PERCEPTUAL);
 3787:     }
 3787: 
 3787:     return gCMSRGBATransform;
 3787: }
16571: 
19003: /* Shuts down various transforms and profiles for CMS. */
19003: static void ShutdownCMS()
19003: {
19003: 
19003:     if (gCMSRGBTransform) {
27035:         qcms_transform_release(gCMSRGBTransform);
19003:         gCMSRGBTransform = nsnull;
19003:     }
19003:     if (gCMSInverseRGBTransform) {
27035:         qcms_transform_release(gCMSInverseRGBTransform);
19003:         gCMSInverseRGBTransform = nsnull;
19003:     }
19003:     if (gCMSRGBATransform) {
27035:         qcms_transform_release(gCMSRGBATransform);
19003:         gCMSRGBATransform = nsnull;
19003:     }
19003:     if (gCMSOutputProfile) {
27035:         qcms_profile_release(gCMSOutputProfile);
19003: 
19003:         // handle the aliased case
19003:         if (gCMSsRGBProfile == gCMSOutputProfile)
19003:             gCMSsRGBProfile = nsnull;
19003:         gCMSOutputProfile = nsnull;
19003:     }
19003:     if (gCMSsRGBProfile) {
27035:         qcms_profile_release(gCMSsRGBProfile);
19003:         gCMSsRGBProfile = nsnull;
19003:     }
19003: 
19003:     // Reset the state variables
19003:     gCMSIntent = -2;
19003:     gCMSMode = eCMSMode_Off;
19003:     gCMSInitialized = PR_FALSE;
19003: }
19003: 
16571: static void MigratePrefs()
16571: {
16571: 
16571:     /* Load the pref service. If we don't get it die quietly since this isn't
16571:        critical code. */
16571:     nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
16571:     if (!prefs)
16571:         return;
16571: 
16571:     /* Migrate from the boolean color_management.enabled pref - we now use
16571:        color_management.mode. */
16571:     PRBool hasOldCMPref;
16571:     nsresult rv =
16571:         prefs->PrefHasUserValue(CMPrefNameOld, &hasOldCMPref);
16571:     if (NS_SUCCEEDED(rv) && (hasOldCMPref == PR_TRUE)) {
16571:         PRBool CMWasEnabled;
16571:         rv = prefs->GetBoolPref(CMPrefNameOld, &CMWasEnabled);
16571:         if (NS_SUCCEEDED(rv) && (CMWasEnabled == PR_TRUE))
16571:             prefs->SetIntPref(CMPrefName, eCMSMode_All);
16571:         prefs->ClearUserPref(CMPrefNameOld);
16571:     }
16571: 
16571: }
32950: 
37211: // default SetupClusterBoundaries, based on Unicode properties;
37211: // platform subclasses may override if they wish
37211: static nsIUGenCategory* gGenCategory = nsnull;
37211: 
37211: static nsIUGenCategory*
37211: GetGenCategory()
37211: {
37211:     if (!gGenCategory) {
39206:         nsresult rv = CallGetService(NS_UNICHARCATEGORY_CONTRACTID, &gGenCategory);
37211:         if (NS_FAILED(rv)) {
37211:             NS_ERROR("Failed to get the Unicode character category service!");
37211:             gGenCategory = nsnull;
37211:         }
37211:     }
37211:     return gGenCategory;
37211: }
37211: 
37211: void
37211: gfxPlatform::SetupClusterBoundaries(gfxTextRun *aTextRun, const PRUnichar *aString)
37211: {
37211:     if (aTextRun->GetFlags() & gfxTextRunFactory::TEXT_IS_8BIT) {
37211:         // 8-bit text doesn't have clusters.
37211:         // XXX is this true in all languages???
37211:         // behdad: don't think so.  Czech for example IIRC has a
37211:         // 'ch' grapheme.
37211:         return;
37211:     }
37211: 
37211:     nsIUGenCategory* gc = GetGenCategory();
37211:     if (!gc) {
37211:         NS_WARNING("No Unicode category service: cannot determine clusters");
37211:         return;
37211:     }
37211: 
37211:     PRUint32 i, length = aTextRun->GetLength();
37211:     for (i = 0; i < length; ++i) {
37211:         PRBool surrogatePair = PR_FALSE;
37211:         PRUint32 ch = aString[i];
37211:         if (NS_IS_HIGH_SURROGATE(ch) &&
37211:             i < length - 1 && NS_IS_LOW_SURROGATE(aString[i+1])) {
37211:             ch = SURROGATE_TO_UCS4(ch, aString[i+1]);
37211:             surrogatePair = PR_TRUE;
37211:         }
42989:         if (i > 0 && gc->Get(ch) == nsIUGenCategory::kMark) {
37211:             gfxTextRun::CompressedGlyph g;
37211:             aTextRun->SetGlyphs(i, g.SetComplex(PR_FALSE, PR_TRUE, 0), nsnull);
37211:         }
37211:         if (surrogatePair) {
37211:             ++i;
37211:             gfxTextRun::CompressedGlyph g;
37211:             aTextRun->SetGlyphs(i, g.SetComplex(PR_FALSE, PR_TRUE, 0), nsnull);
37211:         }
37211:     }
37211: }
42854: 
42854: void
42854: gfxPlatform::FontsPrefsChanged(nsIPrefBranch *aPrefBranch, const char *aPref)
42854: {
43527:     NS_ASSERTION(aPref != nsnull, "null preference");
42854:     if (!strcmp(GFX_DOWNLOADABLE_FONTS_ENABLED, aPref)) {
42854:         mAllowDownloadableFonts = UNINITIALIZED_VALUE;
55084:     } else if (!strcmp(GFX_DOWNLOADABLE_FONTS_SANITIZE, aPref)) {
55084:         mDownloadableFontsSanitize = UNINITIALIZED_VALUE;
55086:     } else if (!strcmp(GFX_DOWNLOADABLE_FONTS_SANITIZE_PRESERVE_OTL, aPref)) {
55086:         mSanitizePreserveOTLTables = UNINITIALIZED_VALUE;
43527:     } else if (!strcmp(GFX_PREF_HARFBUZZ_LEVEL, aPref)) {
43527:         mUseHarfBuzzLevel = UNINITIALIZED_VALUE;
43527:         gfxTextRunWordCache::Flush();
43527:         gfxFontCache::GetCache()->AgeAllGenerations();
42854:     }
42854: }
