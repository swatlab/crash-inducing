    1: /* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JavaScript Debugging support - Object support
    1:  */
    1: 
    1: #include "jsd.h"
    1: 
    1: /*
    1: * #define JSD_TRACE 1
    1: */
    1: 
    1: #ifdef JSD_TRACE
    1: #define TRACEOBJ(jsdc, jsdobj, which) _traceObj(jsdc, jsdobj, which)
    1: 
    1: static char *
    1: _describeObj(JSDContext* jsdc, JSDObject *jsdobj)
    1: {
    1:     return
    1:         JS_smprintf("%0x new'd in %s at line %d using ctor %s in %s at line %d",
    1:                     (int)jsdobj,
    1:                     JSD_GetObjectNewURL(jsdc, jsdobj),
    1:                     JSD_GetObjectNewLineNumber(jsdc, jsdobj),
    1:                     JSD_GetObjectConstructorName(jsdc, jsdobj),
    1:                     JSD_GetObjectConstructorURL(jsdc, jsdobj),
    1:                     JSD_GetObjectConstructorLineNumber(jsdc, jsdobj));
    1: }
    1: 
    1: static void
    1: _traceObj(JSDContext* jsdc, JSDObject* jsdobj, int which)
    1: {
    1:     char* description;
    1: 
    1:     if( !jsdobj )
    1:         return;
    1: 
    1:     description = _describeObj(jsdc, jsdobj);
    1: 
    1:     printf("%s : %s\n",
    1:            which == 0 ? "new  " :
    1:            which == 1 ? "final" :
    1:                         "ctor ",
    1:            description);
    1:     if(description)
    1:         free(description);
    1: }
    1: #else
    1: #define TRACEOBJ(jsdc, jsdobj, which) ((void)0)
    1: #endif /* JSD_TRACE */
    1: 
    1: #ifdef DEBUG
    1: void JSD_ASSERT_VALID_OBJECT(JSDObject* jsdobj)
    1: {
    1:     JS_ASSERT(jsdobj);
    1:     JS_ASSERT(!JS_CLIST_IS_EMPTY(&jsdobj->links));
    1:     JS_ASSERT(jsdobj->obj);
    1: }
    1: #endif
    1: 
    1: 
    1: static void
    1: _destroyJSDObject(JSDContext* jsdc, JSDObject* jsdobj)
    1: {
    1:     JS_ASSERT(JSD_OBJECTS_LOCKED(jsdc));
    1: 
    1:     JS_REMOVE_LINK(&jsdobj->links);
    1:     JS_HashTableRemove(jsdc->objectsTable, jsdobj->obj);
    1: 
    1:     if(jsdobj->newURL)
    1:         jsd_DropAtom(jsdc, jsdobj->newURL);
    1:     if(jsdobj->ctorURL)
    1:         jsd_DropAtom(jsdc, jsdobj->ctorURL);
    1:     if(jsdobj->ctorName)
    1:         jsd_DropAtom(jsdc, jsdobj->ctorName);
    1:     free(jsdobj);
    1: }
    1: 
    1: static JSDObject*
    1: _createJSDObject(JSDContext* jsdc, JSContext *cx, JSObject *obj)
    1: {
    1:     JSDObject* jsdobj;
    1:     JSStackFrame* fp;
    1:     JSStackFrame* iter = NULL;
    1:     const char* newURL;
    1:     jsbytecode* pc;
    1: 
    1:     JS_ASSERT(JSD_OBJECTS_LOCKED(jsdc));
    1: 
    1:     jsdobj = (JSDObject*) calloc(1, sizeof(JSDObject));
    1:     if (jsdobj)
    1:     {
    1:         JS_INIT_CLIST(&jsdobj->links);
    1:         JS_APPEND_LINK(&jsdobj->links, &jsdc->objectsList);
    1:         jsdobj->obj = obj;
    1:         JS_HashTableAdd(jsdc->objectsTable, obj, jsdobj);
    1: 
    1:         if (jsdc->flags & JSD_DISABLE_OBJECT_TRACE)
    1:             return jsdobj;
    1:         
    1:         /* walk the stack to find js frame (if any) causing creation */
    1:         while (NULL != (fp = JS_FrameIterator(cx, &iter)))
    1:         {
    1:             if( !JS_IsNativeFrame(cx, fp) )
    1:             {
    1:                 JSScript* script = JS_GetFrameScript(cx, fp);
    1:                 if( !script )
    1:                     continue;
    1: 
    1:                 newURL = JS_GetScriptFilename(cx, script);
    1:                 if( newURL )
    1:                     jsdobj->newURL = jsd_AddAtom(jsdc, newURL);
    1: 
    1:                 pc = JS_GetFramePC(cx, fp);
    1:                 if( pc )
    1:                     jsdobj->newLineno = JS_PCToLineNumber(cx, script, pc);
    1: 
    1:                 break;
    1:             }
    1:         }
    1:     }
    1:     return jsdobj;
    1: }
    1: 
18907: void
    1: jsd_ObjectHook(JSContext *cx, JSObject *obj, JSBool isNew, void *closure)
    1: {
    1:     JSDObject* jsdobj;
    1:     JSDContext* jsdc = (JSDContext*) closure;
    1: 
    1:     if( ! jsdc || ! jsdc->inited )
    1:         return;
    1: 
    1:     JSD_LOCK_OBJECTS(jsdc);
    1:     if(isNew)
    1:     {
    1:         jsdobj = _createJSDObject(jsdc, cx, obj);
    1:         TRACEOBJ(jsdc, jsdobj, 0);
    1:     }
    1:     else
    1:     {
    1:         jsdobj = jsd_GetJSDObjectForJSObject(jsdc, obj);
    1:         if( jsdobj )
    1:         {
    1:             TRACEOBJ(jsdc, jsdobj, 1);
    1:             _destroyJSDObject(jsdc, jsdobj);
    1:         }
    1:     }
    1:     JSD_UNLOCK_OBJECTS(jsdc);
    1: }
    1: 
    1: void
    1: jsd_Constructing(JSDContext* jsdc, JSContext *cx, JSObject *obj,
    1:                  JSStackFrame *fp)
    1: {
    1:     JSDObject* jsdobj;
    1:     JSScript* script;
    1:     JSDScript* jsdscript;
    1:     const char* ctorURL;
    1:     const char* ctorName;
    1: 
    1:     JSD_LOCK_OBJECTS(jsdc);
    1:     jsdobj = jsd_GetJSDObjectForJSObject(jsdc, obj);
    1:     if( jsdobj && !jsdobj->ctorURL && !JS_IsNativeFrame(cx, fp) )
    1:     {
    1:         script = JS_GetFrameScript(cx, fp);
    1:         if( script )
    1:         {
    1:             ctorURL = JS_GetScriptFilename(cx, script);
    1:             if( ctorURL )
    1:                 jsdobj->ctorURL = jsd_AddAtom(jsdc, ctorURL);
    1: 
    1:             JSD_LOCK_SCRIPTS(jsdc);
26156:             jsdscript = jsd_FindOrCreateJSDScript(jsdc, cx, script, fp);
    1:             JSD_UNLOCK_SCRIPTS(jsdc);
    1:             if( jsdscript )
    1:             {
    1:                 ctorName = jsd_GetScriptFunctionName(jsdc, jsdscript);
    1:                 if( ctorName )
    1:                     jsdobj->ctorName = jsd_AddAtom(jsdc, ctorName);
    1:             }
    1:             jsdobj->ctorLineno = JS_GetScriptBaseLineNumber(cx, script);
    1:         }
    1:     }
    1:     TRACEOBJ(jsdc, jsdobj, 3);
    1:     JSD_UNLOCK_OBJECTS(jsdc);
    1: }
    1: 
18907: static JSHashNumber
    1: _hash_root(const void *key)
    1: {
    1:     return ((JSHashNumber) key) >> 2; /* help lame MSVC1.5 on Win16 */
    1: }
    1: 
    1: JSBool
    1: jsd_InitObjectManager(JSDContext* jsdc)
    1: {
    1:     JS_INIT_CLIST(&jsdc->objectsList);
    1:     jsdc->objectsTable = JS_NewHashTable(256, _hash_root,
    1:                                          JS_CompareValues, JS_CompareValues,
    1:                                          NULL, NULL);
    1:     return (JSBool) jsdc->objectsTable;
    1: }
    1: 
    1: void
    1: jsd_DestroyObjectManager(JSDContext* jsdc)
    1: {
36192:     jsd_DestroyObjects(jsdc);
36192:     JSD_LOCK_OBJECTS(jsdc);
36192:     JS_HashTableDestroy(jsdc->objectsTable);
36192:     JSD_UNLOCK_OBJECTS(jsdc);
36192: }
36192: 
36192: void
36192: jsd_DestroyObjects(JSDContext* jsdc)
36192: {
    1:     JSD_LOCK_OBJECTS(jsdc);
    1:     while( !JS_CLIST_IS_EMPTY(&jsdc->objectsList) )
    1:         _destroyJSDObject(jsdc, (JSDObject*)JS_NEXT_LINK(&jsdc->objectsList));
    1:     JSD_UNLOCK_OBJECTS(jsdc);
    1: }
    1: 
    1: JSDObject*
    1: jsd_IterateObjects(JSDContext* jsdc, JSDObject** iterp)
    1: {
    1:     JSDObject *jsdobj = *iterp;
    1: 
    1:     JS_ASSERT(JSD_OBJECTS_LOCKED(jsdc));
    1: 
    1:     if( !jsdobj )
    1:         jsdobj = (JSDObject *)jsdc->objectsList.next;
    1:     if( jsdobj == (JSDObject *)&jsdc->objectsList )
    1:         return NULL;
    1:     *iterp = (JSDObject*) jsdobj->links.next;
    1:     return jsdobj;
    1: }
    1: 
    1: JSObject*
    1: jsd_GetWrappedObject(JSDContext* jsdc, JSDObject* jsdobj)
    1: {
    1:     return jsdobj->obj;
    1: }
    1: 
    1: const char*
    1: jsd_GetObjectNewURL(JSDContext* jsdc, JSDObject* jsdobj)
    1: {
    1:     if( jsdobj->newURL )
    1:         return JSD_ATOM_TO_STRING(jsdobj->newURL);
    1:     return NULL;
    1: }
    1: 
    1: uintN
    1: jsd_GetObjectNewLineNumber(JSDContext* jsdc, JSDObject* jsdobj)
    1: {
    1:     return jsdobj->newLineno;
    1: }
    1: 
    1: const char*
    1: jsd_GetObjectConstructorURL(JSDContext* jsdc, JSDObject* jsdobj)
    1: {
    1:     if( jsdobj->ctorURL )
    1:         return JSD_ATOM_TO_STRING(jsdobj->ctorURL);
    1:     return NULL;
    1: }
    1: 
    1: uintN
    1: jsd_GetObjectConstructorLineNumber(JSDContext* jsdc, JSDObject* jsdobj)
    1: {
    1:     return jsdobj->ctorLineno;
    1: }
    1: 
    1: const char*
    1: jsd_GetObjectConstructorName(JSDContext* jsdc, JSDObject* jsdobj)
    1: {
    1:     if( jsdobj->ctorName )
    1:         return JSD_ATOM_TO_STRING(jsdobj->ctorName);
    1:     return NULL;
    1: }
    1: 
    1: JSDObject*
    1: jsd_GetJSDObjectForJSObject(JSDContext* jsdc, JSObject* jsobj)
    1: {
    1:     JSDObject* jsdobj;
    1: 
    1:     JSD_LOCK_OBJECTS(jsdc);
    1:     jsdobj = (JSDObject*) JS_HashTableLookup(jsdc->objectsTable, jsobj);
    1:     JSD_UNLOCK_OBJECTS(jsdc);
    1:     return jsdobj;
    1: }
    1: 
    1: JSDObject*
    1: jsd_GetObjectForValue(JSDContext* jsdc, JSDValue* jsdval)
    1: {
    1:     return jsd_GetJSDObjectForJSObject(jsdc, JSVAL_TO_OBJECT(jsdval->val));
    1: }
    1: 
    1: JSDValue*
    1: jsd_GetValueForObject(JSDContext* jsdc, JSDObject* jsdobj)
    1: {
    1:     return jsd_NewValue(jsdc, OBJECT_TO_JSVAL(jsdobj->obj));
    1: }
    1: 
    1: 
