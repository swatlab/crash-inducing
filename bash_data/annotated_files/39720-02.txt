35740: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
35740:  * vim: sw=4 ts=4 et :
35740:  * ***** BEGIN LICENSE BLOCK *****
35740:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35740:  *
35740:  * The contents of this file are subject to the Mozilla Public License Version
35740:  * 1.1 (the "License"); you may not use this file except in compliance with
35740:  * the License. You may obtain a copy of the License at
35740:  * http://www.mozilla.org/MPL/
35740:  *
35740:  * Software distributed under the License is distributed on an "AS IS" basis,
35740:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35740:  * for the specific language governing rights and limitations under the
35740:  * License.
35740:  *
35740:  * The Original Code is Mozilla Plugin App.
35740:  *
35740:  * The Initial Developer of the Original Code is
35740:  *   Chris Jones <jones.chris.g@gmail.com>
35740:  * Portions created by the Initial Developer are Copyright (C) 2009
35740:  * the Initial Developer. All Rights Reserved.
35740:  *
35740:  * Contributor(s):
36124:  *   Jim Mathies <jmathies@mozilla.com>
35740:  *
35740:  * Alternatively, the contents of this file may be used under the terms of
35740:  * either the GNU General Public License Version 2 or later (the "GPL"), or
35740:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35740:  * in which case the provisions of the GPL or the LGPL are applicable instead
35740:  * of those above. If you wish to allow use of your version of this file only
35740:  * under the terms of either the GPL or the LGPL, and not to allow others to
35740:  * use your version of this file under the terms of the MPL, indicate your
35740:  * decision by deleting the provisions above and replace them with the notice
35740:  * and other provisions required by the GPL or the LGPL. If you do not delete
35740:  * the provisions above, a recipient may use your version of this file under
35740:  * the terms of any one of the MPL, the GPL or the LGPL.
35740:  *
35740:  * ***** END LICENSE BLOCK ***** */
35740: 
35893: #include "PluginInstanceChild.h"
35925: #include "PluginModuleChild.h"
35895: #include "BrowserStreamChild.h"
35938: #include "PluginStreamChild.h"
35904: #include "StreamNotifyChild.h"
35746: 
36056: #include "mozilla/ipc/SyncChannel.h"
36056: 
35925: using namespace mozilla::plugins;
35925: 
35957: #ifdef MOZ_WIDGET_GTK2
35747: 
35740: #include <gtk/gtk.h>
35740: #include <gdk/gdkx.h>
35740: #include <gdk/gdk.h>
35740: #include "gtk2xtbin.h"
35747: 
38045: #elif defined(MOZ_WIDGET_QT)
38045: #include <QX11Info>
35747: #elif defined(OS_WIN)
38103: 
36130: using mozilla::gfx::SharedDIB;
35747: 
35747: #include <windows.h>
38660: #include <windowsx.h>
35747: 
36270: #define NS_OOPP_DOUBLEPASS_MSGID TEXT("MozDoublePassMsg")
38103: 
38103: // During nested ui loops, parent is processing windows events via spin loop,
38103: // which results in rpc in-calls to child. If child falls behind in processing
38103: // these, an ugly stall condition occurs. To ensure child stays in sync, we use
38103: // a timer callback to schedule work on in-calls.
38103: #define CHILD_MODALPUMPTIMEOUT 50
38103: #define CHILD_MODALLOOPTIMER   654321
38103: 
38103: #endif // defined(OS_WIN)
35740: 
38660: PluginInstanceChild::PluginInstanceChild(const NPPluginFuncs* aPluginIface,
39283:                                          const nsCString& aMimeType)
39283:     : mPluginIface(aPluginIface)
39283:     , mQuirks(0)
38660:     , mCachedWindowActor(nsnull)
38660:     , mCachedElementActor(nsnull)
35980: #if defined(OS_WIN)
35980:     , mPluginWindowHWND(0)
35980:     , mPluginWndProc(0)
35980:     , mPluginParentHWND(0)
38103:     , mNestedEventHook(0)
38103:     , mNestedPumpHook(0)
38103:     , mNestedEventLevelDepth(0)
38103:     , mNestedEventState(false)
38103:     , mCachedWinlessPluginHWND(0)
38103:     , mEventPumpTimer(0)
37311: #endif // OS_WIN
35980: {
35980:     memset(&mWindow, 0, sizeof(mWindow));
35980:     mData.ndata = (void*) this;
35980: #if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
35980:     mWindow.ws_info = &mWsInfo;
35980:     memset(&mWsInfo, 0, sizeof(mWsInfo));
35980: #ifdef MOZ_WIDGET_GTK2
35980:     mWsInfo.display = GDK_DISPLAY();
38045: #elif defined(MOZ_WIDGET_QT)
38045:     mWsInfo.display = QX11Info::display();
37311: #endif // MOZ_WIDGET_GTK2
37311: #endif // MOZ_X11 && XP_UNIX && !XP_MACOSX
36270: #if defined(OS_WIN)
36270:     memset(&mAlphaExtract, 0, sizeof(mAlphaExtract));
36270:     mAlphaExtract.doublePassEvent = ::RegisterWindowMessage(NS_OOPP_DOUBLEPASS_MSGID);
37311: #endif // OS_WIN
38660:     InitQuirksModes(aMimeType);
35980: }
35980: 
35893: PluginInstanceChild::~PluginInstanceChild()
35747: {
35747: #if defined(OS_WIN)
35747:   DestroyPluginWindow();
35747: #endif
35747: }
35747: 
38660: void
38660: PluginInstanceChild::InitQuirksModes(const nsCString& aMimeType)
38660: {
38660: #ifdef OS_WIN
38660:     // application/x-silverlight
38660:     // application/x-silverlight-2
38660:     NS_NAMED_LITERAL_CSTRING(silverlight, "application/x-silverlight");
38660:     if (FindInReadable(silverlight, aMimeType)) {
38660:         mQuirks |= QUIRK_SILVERLIGHT_WINLESS_INPUT_TRANSLATION;
38660:     }
38660: #endif
38660: }
38660: 
35740: NPError
38354: PluginInstanceChild::InternalGetNPObjectForValue(NPNVariable aValue,
38354:                                                  NPObject** aObject)
38354: {
38354:     PluginScriptableObjectChild* actor;
38354:     NPError result = NPERR_NO_ERROR;
38354: 
38354:     switch (aValue) {
38354:         case NPNVWindowNPObject:
38354:             if (!(actor = mCachedWindowActor)) {
38354:                 PPluginScriptableObjectChild* actorProtocol;
38354:                 CallNPN_GetValue_NPNVWindowNPObject(&actorProtocol, &result);
38354:                 if (result == NPERR_NO_ERROR) {
38354:                     actor = mCachedWindowActor =
38354:                         static_cast<PluginScriptableObjectChild*>(actorProtocol);
38354:                     NS_ASSERTION(actor, "Null actor!");
38354:                     PluginModuleChild::sBrowserFuncs.retainobject(
38354:                         actor->GetObject(false));
38354:                 }
38354:             }
38354:             break;
38354: 
38354:         case NPNVPluginElementNPObject:
38354:             if (!(actor = mCachedElementActor)) {
38354:                 PPluginScriptableObjectChild* actorProtocol;
38354:                 CallNPN_GetValue_NPNVPluginElementNPObject(&actorProtocol,
38354:                                                            &result);
38354:                 if (result == NPERR_NO_ERROR) {
38354:                     actor = mCachedElementActor =
38354:                         static_cast<PluginScriptableObjectChild*>(actorProtocol);
38354:                     NS_ASSERTION(actor, "Null actor!");
38354:                     PluginModuleChild::sBrowserFuncs.retainobject(
38354:                         actor->GetObject(false));
38354:                 }
38354:             }
38354:             break;
38354: 
38354:         default:
38354:             NS_NOTREACHED("Don't know what to do with this value type!");
38354:     }
38354: 
38354: #ifdef DEBUG
38354:     {
38354:         NPError currentResult;
38354:         PPluginScriptableObjectChild* currentActor;
38354: 
38354:         switch (aValue) {
38354:             case NPNVWindowNPObject:
38354:                 CallNPN_GetValue_NPNVWindowNPObject(&currentActor,
38354:                                                     &currentResult);
38354:                 break;
38354:             case NPNVPluginElementNPObject:
38354:                 CallNPN_GetValue_NPNVPluginElementNPObject(&currentActor,
38354:                                                            &currentResult);
38354:                 break;
38354:             default:
38354:                 NS_NOTREACHED("Don't know what to do with this value type!");
38354:         }
38354: 
38354:         // Make sure that the current actor returned by the parent matches our
38354:         // cached actor!
38354:         NS_ASSERTION(static_cast<PluginScriptableObjectChild*>(currentActor) ==
38354:                      actor, "Cached actor is out of date!");
38354:         NS_ASSERTION(currentResult == result, "Results don't match?!");
38354:     }
38354: #endif
38354: 
38354:     if (result != NPERR_NO_ERROR) {
38354:         return result;
38354:     }
38354: 
38354:     NPObject* object = actor->GetObject(false);
38354:     NS_ASSERTION(object, "Null object?!");
38354: 
38354:     *aObject = PluginModuleChild::sBrowserFuncs.retainobject(object);
38354:     return NPERR_NO_ERROR;
38354: 
38354: }
38354: 
38354: NPError
35893: PluginInstanceChild::NPN_GetValue(NPNVariable aVar,
35893:                                   void* aValue)
35740: {
37099:     PLUGIN_LOG_DEBUG(("%s (aVar=%i)", FULLFUNCTION, (int) aVar));
35971:     AssertPluginThread();
35740: 
35746:     switch(aVar) {
35740: 
35746:     case NPNVSupportsWindowless:
36011: #if defined(OS_LINUX) || defined(OS_WIN)
35951:         *((NPBool*)aValue) = true;
35951: #else
35747:         *((NPBool*)aValue) = false;
35951: #endif
35746:         return NPERR_NO_ERROR;
35746: 
35746: #if defined(OS_LINUX)
35740:     case NPNVSupportsXEmbedBool:
35747:         *((NPBool*)aValue) = true;
35740:         return NPERR_NO_ERROR;
35740: 
35740:     case NPNVToolkit:
35740:         *((NPNToolkitType*)aValue) = NPNVGtk2;
35740:         return NPERR_NO_ERROR;
35740: 
35746: #elif defined(OS_WIN)
35746:     case NPNVToolkit:
35746:         return NPERR_GENERIC_ERROR;
35746: #endif
35923:     case NPNVjavascriptEnabledBool: {
35923:         bool v = false;
35923:         NPError result;
35934:         if (!CallNPN_GetValue_NPNVjavascriptEnabledBool(&v, &result)) {
35934:             return NPERR_GENERIC_ERROR;
35934:         }
35923:         *static_cast<NPBool*>(aValue) = v;
35923:         return result;
35923:     }
35923: 
35923:     case NPNVisOfflineBool: {
35923:         bool v = false;
35923:         NPError result;
35934:         if (!CallNPN_GetValue_NPNVisOfflineBool(&v, &result)) {
35934:             return NPERR_GENERIC_ERROR;
35934:         }
35923:         *static_cast<NPBool*>(aValue) = v;
35923:         return result;
35923:     }
35923: 
35923:     case NPNVprivateModeBool: {
35923:         bool v = false;
35923:         NPError result;
35934:         if (!CallNPN_GetValue_NPNVprivateModeBool(&v, &result)) {
35934:             return NPERR_GENERIC_ERROR;
35934:         }
35923:         *static_cast<NPBool*>(aValue) = v;
35923:         return result;
35923:     }
35923: 
38354:     case NPNVWindowNPObject: // Intentional fall-through
38354:     case NPNVPluginElementNPObject: {
38354:         NPObject* object;
38354:         NPError result = InternalGetNPObjectForValue(aVar, &object);
38354:         if (result == NPERR_NO_ERROR) {
38354:             *((NPObject**)aValue) = object;
35965:         }
35965:         return result;
35965:     }
35965: 
37168:     case NPNVnetscapeWindow: {
37168: #ifdef XP_WIN
37168:         if (mWindow.type == NPWindowTypeDrawable) {
38103:             if (mCachedWinlessPluginHWND) {
38103:               *static_cast<HWND*>(aValue) = mCachedWinlessPluginHWND;
38103:               return NPERR_NO_ERROR;
38103:             }
37168:             NPError result;
38103:             if (!CallNPN_GetValue_NPNVnetscapeWindow(&mCachedWinlessPluginHWND, &result)) {
37168:                 return NPERR_GENERIC_ERROR;
37168:             }
38103:             *static_cast<HWND*>(aValue) = mCachedWinlessPluginHWND;
37168:             return result;
37168:         }
37168:         else {
37168:             *static_cast<HWND*>(aValue) = mPluginWindowHWND;
37168:             return NPERR_NO_ERROR;
37168:         }
37308: #elif defined(MOZ_X11)
37308:         NPError result;
37308:         CallNPN_GetValue_NPNVnetscapeWindow(static_cast<XID*>(aValue), &result);
37308:         return result;
37168: #else
37168:         return NPERR_GENERIC_ERROR;
37168: #endif
37168:     }
37168: 
35740:     default:
37099:         PR_LOG(gPluginLog, PR_LOG_WARNING,
37099:                ("In PluginInstanceChild::NPN_GetValue: Unhandled NPNVariable %i (%s)",
37099:                 (int) aVar, NPNVariableToString(aVar)));
35740:         return NPERR_GENERIC_ERROR;
35740:     }
35740: 
35740: }
35740: 
35951: 
35951: NPError
35951: PluginInstanceChild::NPN_SetValue(NPPVariable aVar, void* aValue)
35951: {
37099:     PR_LOG(gPluginLog, PR_LOG_DEBUG, ("%s (aVar=%i, aValue=%p)",
37099:                                       FULLFUNCTION, (int) aVar, aValue));
37099: 
35971:     AssertPluginThread();
35951: 
35951:     switch (aVar) {
35951:     case NPPVpluginWindowBool: {
35951:         NPError rv;
35951:         bool windowed = (NPBool) (intptr_t) aValue;
35951: 
35951:         if (!CallNPN_SetValue_NPPVpluginWindow(windowed, &rv))
35951:             return NPERR_GENERIC_ERROR;
35951: 
35951:         return rv;
35951:     }
35951: 
35951:     case NPPVpluginTransparentBool: {
35951:         NPError rv;
35951:         bool transparent = (NPBool) (intptr_t) aValue;
35951: 
35951:         if (!CallNPN_SetValue_NPPVpluginTransparent(transparent, &rv))
35951:             return NPERR_GENERIC_ERROR;
35951: 
35951:         return rv;
35951:     }
35951: 
35951:     default:
37099:         PR_LOG(gPluginLog, PR_LOG_WARNING,
37099:                ("In PluginInstanceChild::NPN_SetValue: Unhandled NPPVariable %i (%s)",
37099:                 (int) aVar, NPPVariableToString(aVar)));
35951:         return NPERR_GENERIC_ERROR;
35951:     }
35951: }
35951: 
35951: bool
35951: PluginInstanceChild::AnswerNPP_GetValue_NPPVpluginNeedsXEmbed(
35951:     bool* needs, NPError* rv)
35951: {
35971:     AssertPluginThread();
35971: 
38126: #ifdef MOZ_X11
38126:     // The documentation on the types for many variables in NP(N|P)_GetValue
38126:     // is vague.  Often boolean values are NPBool (1 byte), but
38126:     // https://developer.mozilla.org/en/XEmbed_Extension_for_Mozilla_Plugins
38126:     // treats NPPVpluginNeedsXEmbed as PRBool (int), and
36324:     // on x86/32-bit, flash stores to this using |movl 0x1,&needsXEmbed|.
38126:     // thus we can't use NPBool for needsXEmbed, or the three bytes above
38126:     // it on the stack would get clobbered. so protect with the larger PRBool.
38126:     PRBool needsXEmbed = 0;
38126:     if (!mPluginIface->getvalue) {
38126:         *rv = NPERR_GENERIC_ERROR;
38126:     }
38126:     else {
35951:         *rv = mPluginIface->getvalue(GetNPP(), NPPVpluginNeedsXEmbed,
38126:                                      &needsXEmbed);
38126:     }
35951:     *needs = needsXEmbed;
35951:     return true;
35951: 
35951: #else
35951: 
38126:     NS_RUNTIMEABORT("shouldn't be called on non-X11 platforms");
35952:     return false;               // not reached
35951: 
35951: #endif
35951: }
35951: 
35926: bool
35925: PluginInstanceChild::AnswerNPP_GetValue_NPPVpluginScriptableNPObject(
36078:                                           PPluginScriptableObjectChild** aValue,
36078:                                           NPError* aResult)
35746: {
35971:     AssertPluginThread();
35925: 
39411:     NPObject* object = nsnull;
38126:     NPError result = NPERR_GENERIC_ERROR;
38126:     if (mPluginIface->getvalue) {
38126:         result = mPluginIface->getvalue(GetNPP(), NPPVpluginScriptableNPObject,
35925:                                         &object);
38126:     }
36078:     if (result == NPERR_NO_ERROR && object) {
36078:         PluginScriptableObjectChild* actor = GetActorForNPObject(object);
36078: 
36078:         // If we get an actor then it has retained. Otherwise we don't need it
36078:         // any longer.
36078:         PluginModuleChild::sBrowserFuncs.releaseobject(object);
36078:         if (actor) {
36078:             *aValue = actor;
36078:             *aResult = NPERR_NO_ERROR;
35926:             return true;
35925:         }
35925: 
36078:         NS_ERROR("Failed to get actor!");
36078:         result = NPERR_GENERIC_ERROR;
35925:     }
39411:     else {
39411:         result = NPERR_GENERIC_ERROR;
39411:     }
35925: 
36078:     *aValue = nsnull;
36078:     *aResult = result;
35926:     return true;
35746: }
35746: 
35926: bool
37350: PluginInstanceChild::AnswerNPP_SetValue_NPNVprivateModeBool(const bool& value,
37350:                                                             NPError* result)
37350: {
37885:     if (!mPluginIface->setvalue) {
37885:         *result = NPERR_GENERIC_ERROR;
37885:         return true;
37885:     }
37885: 
39529:     NPBool v = value;
37350:     *result = mPluginIface->setvalue(GetNPP(), NPNVprivateModeBool, &v);
37350:     return true;
37350: }
37350: 
37350: bool
36011: PluginInstanceChild::AnswerNPP_HandleEvent(const NPRemoteEvent& event,
35933:                                            int16_t* handled)
35933: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35971:     AssertPluginThread();
35951: 
36014: #if defined(OS_LINUX) && defined(DEBUG)
36014:     if (GraphicsExpose == event.event.type)
38112:         PLUGIN_LOG_DEBUG(("  received drawable 0x%lx\n",
38112:                           event.event.xgraphicsexpose.drawable));
35951: #endif
35951: 
39534: #ifdef OS_MACOSX
39534:     // Mac OS X does not define an NPEvent structure. It defines more specific types.
39534:     NPCocoaEvent evcopy = event.event;
39534: #else
36124:     // Make a copy since we may modify values.
36011:     NPEvent evcopy = event.event;
39534: #endif
36124: 
36124: #ifdef OS_WIN
36270:     // Painting for win32. SharedSurfacePaint handles everything.
36270:     if (mWindow.type == NPWindowTypeDrawable) {
36270:        if (evcopy.event == WM_PAINT) {
36270:           *handled = SharedSurfacePaint(evcopy);
36270:           return true;
36270:        }
36270:        else if (evcopy.event == mAlphaExtract.doublePassEvent) {
36270:             // We'll render to mSharedSurfaceDib first, then render to a cached bitmap
36270:             // we store locally. The two passes are for alpha extraction, so the second
36270:             // pass must be to a flat white surface in order for things to work.
36270:             mAlphaExtract.doublePass = RENDER_BACK_ONE;
36270:             *handled = true;
36270:             return true;
36270:        }
36270:     }
38103:     *handled = WinlessHandleEvent(evcopy);
38103:     return true;
36124: #endif
36124: 
39279:     if (!mPluginIface->event)
39279:         *handled = false;
39279:     else
35933:         *handled = mPluginIface->event(&mData, reinterpret_cast<void*>(&evcopy));
35980: 
35980: #ifdef MOZ_X11
36013:     if (GraphicsExpose == event.event.type) {
35980:         // Make sure the X server completes the drawing before the parent
35980:         // draws on top and destroys the Drawable.
35980:         //
35980:         // XSync() waits for the X server to complete.  Really this child
35980:         // process does not need to wait; the parent is the process that needs
35980:         // to wait.  A possibly-slightly-better alternative would be to send
35980:         // an X event to the parent that the parent would wait for.
35980:         XSync(mWsInfo.display, False);
35980:     }
35980: #endif
35980: 
35933:     return true;
35933: }
35933: 
39720: bool
39720: PluginInstanceChild::RecvWindowPosChanged(const NPRemoteEvent& event)
39720: {
39720: #ifdef OS_WIN
39720:     int16_t dontcare;
39720:     return AnswerNPP_HandleEvent(event, &dontcare);
39720: #else
39720:     NS_RUNTIMEABORT("WindowPosChanged is a windows-only message");
39720:     return false;
39720: #endif
39720: }
39720: 
39720: 
35957: #if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
35957: static bool
35957: XVisualIDToInfo(Display* aDisplay, VisualID aVisualID,
35957:                 Visual** aVisual, unsigned int* aDepth)
35957: {
35957:     if (aVisualID == None) {
35957:         *aVisual = NULL;
35957:         *aDepth = 0;
35957:         return true;
35957:     }
35957: 
35957:     const Screen* screen = DefaultScreenOfDisplay(aDisplay);
35957: 
35957:     for (int d = 0; d < screen->ndepths; d++) {
35957:         Depth *d_info = &screen->depths[d];
35957:         for (int v = 0; v < d_info->nvisuals; v++) {
35957:             Visual* visual = &d_info->visuals[v];
35957:             if (visual->visualid == aVisualID) {
35957:                 *aVisual = visual;
35957:                 *aDepth = d_info->depth;
35957:                 return true;
35957:             }
35957:         }
35957:     }
35957: 
35957:     NS_ERROR("VisualID not on Screen.");
35957:     return false;
35957: }
35957: #endif
35957: 
35933: bool
39279: PluginInstanceChild::AnswerNPP_SetWindow(const NPRemoteWindow& aWindow)
35740: {
37099:     PLUGIN_LOG_DEBUG(("%s (aWindow=<window: 0x%lx, x: %d, y: %d, width: %d, height: %d>)",
37099:                       FULLFUNCTION,
35957:                       aWindow.window,
35954:                       aWindow.x, aWindow.y,
37099:                       aWindow.width, aWindow.height));
35971:     AssertPluginThread();
35740: 
35957: #if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
35957:     // The minimum info is sent over IPC to allow this
35957:     // code to determine the rest.
35740: 
35957:     mWindow.window = reinterpret_cast<void*>(aWindow.window);
35957:     mWindow.x = aWindow.x;
35957:     mWindow.y = aWindow.y;
35957:     mWindow.width = aWindow.width;
35957:     mWindow.height = aWindow.height;
35957:     mWindow.clipRect = aWindow.clipRect;
35957:     mWindow.type = aWindow.type;
35740: 
35957:     mWsInfo.colormap = aWindow.colormap;
35957:     if (!XVisualIDToInfo(mWsInfo.display, aWindow.visualID,
35957:                          &mWsInfo.visual, &mWsInfo.depth))
35957:         return false;
35740: 
37347:     if (aWindow.type == NPWindowTypeWindow) {
37621: #ifdef MOZ_WIDGET_GTK2
37347:         if (GdkWindow* socket_window = gdk_window_lookup(aWindow.window)) {
37347:             // A GdkWindow for the socket already exists.  Need to
37347:             // workaround https://bugzilla.gnome.org/show_bug.cgi?id=607061
37347:             // See wrap_gtk_plug_embedded in PluginModuleChild.cpp.
37347:             g_object_set_data(G_OBJECT(socket_window),
37347:                               "moz-existed-before-set-window",
37347:                               GUINT_TO_POINTER(1));
37347:         }
37621: #endif
37347:     }
37347: 
39279:     if (mPluginIface->setwindow)
39279:         (void) mPluginIface->setwindow(&mData, &mWindow);
35747: 
35746: #elif defined(OS_WIN)
36124:     switch (aWindow.type) {
36124:       case NPWindowTypeWindow:
36124:       {
36124:           if (!CreatePluginWindow())
36124:               return false;
36124: 
35747:           ReparentPluginWindow((HWND)aWindow.window);
35747:           SizePluginWindow(aWindow.width, aWindow.height);
35747: 
35747:           mWindow.window = (void*)mPluginWindowHWND;
35954:           mWindow.x = aWindow.x;
35954:           mWindow.y = aWindow.y;
35746:           mWindow.width = aWindow.width;
35746:           mWindow.height = aWindow.height;
36011:           mWindow.type = aWindow.type;
35740: 
39279:           if (mPluginIface->setwindow) {
39279:               (void) mPluginIface->setwindow(&mData, &mWindow);
35747:               WNDPROC wndProc = reinterpret_cast<WNDPROC>(
35747:                   GetWindowLongPtr(mPluginWindowHWND, GWLP_WNDPROC));
35747:               if (wndProc != PluginWindowProc) {
35747:                   mPluginWndProc = reinterpret_cast<WNDPROC>(
35747:                       SetWindowLongPtr(mPluginWindowHWND, GWLP_WNDPROC,
35747:                                        reinterpret_cast<LONG>(PluginWindowProc)));
35747:               }
35747:           }
36124:       }
36124:       break;
36124: 
36124:       case NPWindowTypeDrawable:
39279:           return SharedSurfaceSetWindow(aWindow);
36124:       break;
36124: 
36124:       default:
36124:           NS_NOTREACHED("Bad plugin window type.");
36124:           return false;
36124:       break;
36124:     }
35747: 
36069: #elif defined(OS_MACOSX)
39534: 
39534:     mWindow.x = aWindow.x;
39534:     mWindow.y = aWindow.y;
39534:     mWindow.width = aWindow.width;
39534:     mWindow.height = aWindow.height;
39534:     mWindow.clipRect = aWindow.clipRect;
39534:     mWindow.type = aWindow.type;
36069: 
35740: #else
35740: #  error Implement me for your OS
35740: #endif
35746: 
35926:     return true;
35740: }
35740: 
35747: bool
35893: PluginInstanceChild::Initialize()
35747: {
35747:     return true;
35747: }
35747: 
35747: #if defined(OS_WIN)
35747: 
35747: static const TCHAR kWindowClassName[] = TEXT("GeckoPluginWindow");
35893: static const TCHAR kPluginInstanceChildProperty[] = TEXT("PluginInstanceChildProperty");
35747: 
35747: // static
35747: bool
35893: PluginInstanceChild::RegisterWindowClass()
35747: {
35747:     static bool alreadyRegistered = false;
35747:     if (alreadyRegistered)
35747:         return true;
35747: 
35747:     alreadyRegistered = true;
35747: 
35747:     WNDCLASSEX wcex;
35747:     wcex.cbSize         = sizeof(WNDCLASSEX);
35747:     wcex.style          = CS_DBLCLKS;
35747:     wcex.lpfnWndProc    = DummyWindowProc;
35747:     wcex.cbClsExtra     = 0;
35747:     wcex.cbWndExtra     = 0;
35747:     wcex.hInstance      = GetModuleHandle(NULL);
35747:     wcex.hIcon          = 0;
35747:     wcex.hCursor        = 0;
35748:     wcex.hbrBackground  = reinterpret_cast<HBRUSH>(COLOR_WINDOW + 1);
35747:     wcex.lpszMenuName   = 0;
35747:     wcex.lpszClassName  = kWindowClassName;
35747:     wcex.hIconSm        = 0;
35747: 
35747:     return RegisterClassEx(&wcex) ? true : false;
35747: }
35747: 
35747: bool
35893: PluginInstanceChild::CreatePluginWindow()
35747: {
36124:     // already initialized
36124:     if (mPluginWindowHWND)
36124:         return true;
36124:         
35747:     if (!RegisterWindowClass())
35747:         return false;
35747: 
35747:     mPluginWindowHWND =
35747:         CreateWindowEx(WS_EX_LEFT | WS_EX_LTRREADING |
35747:                        WS_EX_NOPARENTNOTIFY | // XXXbent Get rid of this!
35747:                        WS_EX_RIGHTSCROLLBAR,
35747:                        kWindowClassName, 0,
35747:                        WS_POPUP | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, 0, 0,
35747:                        0, 0, NULL, 0, GetModuleHandle(NULL), 0);
35747:     if (!mPluginWindowHWND)
35747:         return false;
35893:     if (!SetProp(mPluginWindowHWND, kPluginInstanceChildProperty, this))
35747:         return false;
35747: 
35747:     // Apparently some plugins require an ASCII WndProc.
35747:     SetWindowLongPtrA(mPluginWindowHWND, GWLP_WNDPROC,
35747:                       reinterpret_cast<LONG>(DefWindowProcA));
35747: 
35747:     return true;
35747: }
35747: 
35747: void
35893: PluginInstanceChild::DestroyPluginWindow()
35747: {
35747:     if (mPluginWindowHWND) {
35747:         // Unsubclass the window.
35747:         WNDPROC wndProc = reinterpret_cast<WNDPROC>(
35747:             GetWindowLongPtr(mPluginWindowHWND, GWLP_WNDPROC));
35747:         if (wndProc == PluginWindowProc) {
35747:             NS_ASSERTION(mPluginWndProc, "Should have old proc here!");
35747:             SetWindowLongPtr(mPluginWindowHWND, GWLP_WNDPROC,
35747:                              reinterpret_cast<LONG>(mPluginWndProc));
35747:             mPluginWndProc = 0;
35747:         }
35747: 
35893:         RemoveProp(mPluginWindowHWND, kPluginInstanceChildProperty);
35747:         DestroyWindow(mPluginWindowHWND);
35747:         mPluginWindowHWND = 0;
35747:     }
35747: }
35747: 
35747: void
35893: PluginInstanceChild::ReparentPluginWindow(HWND hWndParent)
35747: {
35747:     if (hWndParent != mPluginParentHWND && IsWindow(hWndParent)) {
36082:         // Fix the child window's style to be a child window.
35747:         LONG style = GetWindowLongPtr(mPluginWindowHWND, GWL_STYLE);
35747:         style |= WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
36082:         style &= ~WS_POPUP;
35747:         SetWindowLongPtr(mPluginWindowHWND, GWL_STYLE, style);
36082: 
36082:         // Do the reparenting.
35747:         SetParent(mPluginWindowHWND, hWndParent);
36082: 
36082:         // Make sure we're visible.
35747:         ShowWindow(mPluginWindowHWND, SW_SHOWNA);
35747:     }
35747:     mPluginParentHWND = hWndParent;
35747: }
35747: 
35747: void
35893: PluginInstanceChild::SizePluginWindow(int width,
35747:                                       int height)
35747: {
35747:     if (mPluginWindowHWND) {
38281:         mPluginSize.x = width;
38281:         mPluginSize.y = height;
35747:         SetWindowPos(mPluginWindowHWND, NULL, 0, 0, width, height,
35747:                      SWP_NOZORDER | SWP_NOREPOSITION);
35747:     }
35747: }
35747: 
35747: // See chromium's webplugin_delegate_impl.cc for explanation of this function.
35747: // static
35747: LRESULT CALLBACK
35893: PluginInstanceChild::DummyWindowProc(HWND hWnd,
35747:                                      UINT message,
35747:                                      WPARAM wParam,
35747:                                      LPARAM lParam)
35747: {
35747:     return CallWindowProc(DefWindowProc, hWnd, message, wParam, lParam);
35747: }
35747: 
35747: // static
35747: LRESULT CALLBACK
35893: PluginInstanceChild::PluginWindowProc(HWND hWnd,
35747:                                       UINT message,
35747:                                       WPARAM wParam,
35747:                                       LPARAM lParam)
35747: {
36056:     NS_ASSERTION(!mozilla::ipc::SyncChannel::IsPumpingMessages(),
36056:                  "Failed to prevent a nonqueued message from running!");
36056: 
35893:     PluginInstanceChild* self = reinterpret_cast<PluginInstanceChild*>(
35893:         GetProp(hWnd, kPluginInstanceChildProperty));
35747:     if (!self) {
35747:         NS_NOTREACHED("Badness!");
35747:         return 0;
35747:     }
35747: 
35747:     NS_ASSERTION(self->mPluginWindowHWND == hWnd, "Wrong window!");
35747: 
38281:     // Adobe's shockwave positions the plugin window relative to the browser
38281:     // frame when it initializes. With oopp disabled, this wouldn't have an
38281:     // effect. With oopp, GeckoPluginWindow is a child of the parent plugin
38281:     // window, so the move offsets the child within the parent. Generally
38281:     // we don't want plugins moving or sizing our window, so we prevent these
38281:     // changes here.
38281:     if (message == WM_WINDOWPOSCHANGING) {
38281:       WINDOWPOS* pos = reinterpret_cast<WINDOWPOS*>(lParam);
38281:       if (pos && (!(pos->flags & SWP_NOMOVE) || !(pos->flags & SWP_NOSIZE))) {
38281:         pos->x = pos->y = 0;
38281:         pos->cx = self->mPluginSize.x;
38281:         pos->cy = self->mPluginSize.y;
38281:         LRESULT res = CallWindowProc(self->mPluginWndProc, hWnd, message, wParam,
38281:                                      lParam);
38281:         pos->x = pos->y = 0;
38281:         pos->cx = self->mPluginSize.x;
38281:         pos->cy = self->mPluginSize.y;
38281:         return res;
38281:       }
38281:     }
38281: 
37550:     // The plugin received keyboard focus, let the parent know so the dom is up to date.
37550:     if (message == WM_MOUSEACTIVATE)
37550:         self->CallPluginGotFocus();
37550: 
37551:     // Prevent lockups due to plugins making rpc calls when the parent
37551:     // is making a synchronous SetFocus api call. (bug 541362) Add more
37551:     // windowing events as needed for other api.
37551:     if (message == WM_KILLFOCUS && 
37551:         ((InSendMessageEx(NULL) & (ISMEX_REPLIED|ISMEX_SEND)) == ISMEX_SEND)) {
37551:         ReplyMessage(0); // Unblock the caller
37551:     }
37551: 
35747:     LRESULT res = CallWindowProc(self->mPluginWndProc, hWnd, message, wParam,
35747:                                  lParam);
35747: 
35747:     if (message == WM_CLOSE)
35747:         self->DestroyPluginWindow();
35747: 
35747:     if (message == WM_NCDESTROY)
35893:         RemoveProp(hWnd, kPluginInstanceChildProperty);
35747: 
35747:     return res;
35747: }
35747: 
38103: /* winless modal ui loop logic */
38103: 
38103: VOID CALLBACK
38103: PluginInstanceChild::PumpTimerProc(HWND hwnd,
38103:                                    UINT uMsg,
38103:                                    UINT_PTR idEvent,
38103:                                    DWORD dwTime)
38103: {
38103:     MessageLoop::current()->ScheduleWork();
38103: }
38103: 
38103: LRESULT CALLBACK
38103: PluginInstanceChild::NestedInputPumpHook(int nCode,
38103:                                          WPARAM wParam,
38103:                                          LPARAM lParam)
38103: {
38103:     if (nCode >= 0) {
38103:         MessageLoop::current()->ScheduleWork();
38103:     }
38103:     return CallNextHookEx(NULL, nCode, wParam, lParam);
38103: }
38103: 
38103: // gTempChildPointer is only in use from the time we enter handle event, to the
38103: // point where ui might be created by that call. If ui isn't created, there's
38103: // no issue. If ui is created, the parent can't start processing messages in
38103: // spin loop until InternalCallSetNestedEventState is set, at which point,
38103: // gTempChildPointer is no longer needed.
38103: static PluginInstanceChild* gTempChildPointer;
38103: 
38103: LRESULT CALLBACK
38103: PluginInstanceChild::NestedInputEventHook(int nCode,
38103:                                           WPARAM wParam,
38103:                                           LPARAM lParam)
38103: {
38103:     if (!gTempChildPointer) {
38103:         return CallNextHookEx(NULL, nCode, wParam, lParam);
38103:     }
38103: 
38103:     if (nCode >= 0) {
38103:         NS_ASSERTION(gTempChildPointer, "Never should be null here!");
38103:         gTempChildPointer->ResetNestedEventHook();
38103:         gTempChildPointer->SetNestedInputPumpHook();
38103:         gTempChildPointer->InternalCallSetNestedEventState(true);
38103: 
38103:         gTempChildPointer = NULL;
38103:     }
38103:     return CallNextHookEx(NULL, nCode, wParam, lParam);
38103: }
38103: 
38103: void
38103: PluginInstanceChild::SetNestedInputPumpHook()
38103: {
38103:     NS_ASSERTION(!mNestedPumpHook,
38103:         "mNestedPumpHook already setup in call to SetNestedInputPumpHook?");
38103: 
38103:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
38103: 
38103:     mNestedPumpHook = SetWindowsHookEx(WH_CALLWNDPROC,
38103:                                        NestedInputPumpHook,
38103:                                        NULL,
38103:                                        GetCurrentThreadId());
38103:     mEventPumpTimer = 
38103:         SetTimer(NULL,
38103:                  CHILD_MODALLOOPTIMER,
38103:                  CHILD_MODALPUMPTIMEOUT,
38103:                  PumpTimerProc);
38103: }
38103: 
38103: void
38103: PluginInstanceChild::ResetPumpHooks()
38103: {
38103:     if (mNestedPumpHook)
38103:         UnhookWindowsHookEx(mNestedPumpHook);
38103:     mNestedPumpHook = NULL;
38103:     if (mEventPumpTimer)
38103:         KillTimer(NULL, mEventPumpTimer);
38103: }
38103: 
38103: void
38103: PluginInstanceChild::SetNestedInputEventHook()
38103: {
38103:     NS_ASSERTION(!mNestedEventHook,
38103:         "mNestedEventHook already setup in call to SetNestedInputEventHook?");
38103: 
38103:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
38103: 
38103:     // WH_GETMESSAGE hooks are triggered by peek message calls in parent due to
38103:     // attached message queues, resulting in stomped in-process ipc calls.  So
38103:     // we use a filter hook specific to dialogs, menus, and scroll bars to kick
38103:     // things off.
38103:     mNestedEventHook = SetWindowsHookEx(WH_MSGFILTER,
38103:                                         NestedInputEventHook,
38103:                                         NULL,
38103:                                         GetCurrentThreadId());
38103: }
38103: 
38103: void
38103: PluginInstanceChild::ResetNestedEventHook()
38103: {
38103:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
38103:     if (mNestedEventHook)
38103:         UnhookWindowsHookEx(mNestedEventHook);
38103:     mNestedEventHook = NULL;
38103: }
38103: 
38103: void
38103: PluginInstanceChild::InternalCallSetNestedEventState(bool aState)
38103: {
38103:     if (aState != mNestedEventState) {
38103:         PLUGIN_LOG_DEBUG(
38103:             ("PluginInstanceChild::InternalCallSetNestedEventState(%i)",
38103:             (int)aState));
38103:         mNestedEventState = aState;
38103:         SendSetNestedEventState(mNestedEventState);
38103:     }
38103: }
38103: 
38660: /* windowless handle event helpers */
38660: 
38660: static bool
38660: NeedsNestedEventCoverage(UINT msg)
38660: {
38660:     // Events we assume some sort of modal ui *might* be generated.
38660:     switch (msg) {
38660:         case WM_LBUTTONUP:
38660:         case WM_RBUTTONUP:
38660:         case WM_MBUTTONUP:
38660:         case WM_LBUTTONDOWN:
38660:         case WM_RBUTTONDOWN:
38660:         case WM_MBUTTONDOWN:
38660:         case WM_CONTEXTMENU:
38660:             return true;
38660:     }
38660:     return false;
38660: }
38660: 
38660: static bool
38660: IsMouseInputEvent(UINT msg)
38660: {
38660:     switch (msg) {
38660:         case WM_MOUSEMOVE:
38660:         case WM_LBUTTONUP:
38660:         case WM_RBUTTONUP:
38660:         case WM_MBUTTONUP:
38660:         case WM_LBUTTONDOWN:
38660:         case WM_RBUTTONDOWN:
38660:         case WM_MBUTTONDOWN:
38660:         case WM_LBUTTONDBLCLK:
38660:         case WM_MBUTTONDBLCLK:
38660:         case WM_RBUTTONDBLCLK:
38660:             return true;
38660:     }
38660:     return false;
38660: }
38660: 
38103: int16_t
38103: PluginInstanceChild::WinlessHandleEvent(NPEvent& event)
38103: {
39279:     if (!mPluginIface->event)
39279:         return false;
39279: 
38660:     // Winless Silverlight quirk: winposchanged events are not used in
38660:     // determining the position of the plugin within the parent window,
38660:     // NPP_SetWindow values are used instead. Due to shared memory dib
38660:     // rendering, the origin of NPP_SetWindow is 0x0, so we trap
38660:     // winposchanged events here and do the translation internally for
38660:     // mouse input events.
38660:     if (mQuirks & QUIRK_SILVERLIGHT_WINLESS_INPUT_TRANSLATION) {
38660:         if (event.event == WM_WINDOWPOSCHANGED && event.lParam) {
38660:             WINDOWPOS* pos = reinterpret_cast<WINDOWPOS*>(event.lParam);
38660:             mPluginOffset.x = pos->x;
38660:             mPluginOffset.y = pos->y;
38660:         }
38660:         else if (IsMouseInputEvent(event.event)) {
38660:             event.lParam =
38660:                 MAKELPARAM((GET_X_LPARAM(event.lParam) - mPluginOffset.x),
38660:                            (GET_Y_LPARAM(event.lParam) - mPluginOffset.y));
38660:         }
38660:     }
38660: 
38660:     if (!NeedsNestedEventCoverage(event.event)) {
38103:         return mPluginIface->event(&mData, reinterpret_cast<void*>(&event));
38103:     }
38103: 
38660:     // Events that might generate nested event dispatch loops need
38660:     // special handling during delivery.
38103:     int16_t handled;
38103: 
38103:     mNestedEventLevelDepth++;
38103:     PLUGIN_LOG_DEBUG(("WinlessHandleEvent start depth: %i", mNestedEventLevelDepth));
38103: 
38103:     // On the first, non-reentrant call, setup our modal ui detection hook.
38103:     if (mNestedEventLevelDepth == 1) {
38103:         NS_ASSERTION(!gTempChildPointer, "valid gTempChildPointer here?");
38103:         gTempChildPointer = this;
38103:         SetNestedInputEventHook();
38103:     }
38103: 
38103:     bool old_state = MessageLoop::current()->NestableTasksAllowed();
38103:     MessageLoop::current()->SetNestableTasksAllowed(true);
38103:     handled = mPluginIface->event(&mData, reinterpret_cast<void*>(&event));
38103:     MessageLoop::current()->SetNestableTasksAllowed(old_state);
38103: 
38103:     gTempChildPointer = NULL;
38103: 
38103:     mNestedEventLevelDepth--;
38103:     PLUGIN_LOG_DEBUG(("WinlessHandleEvent end depth: %i", mNestedEventLevelDepth));
38103: 
38103:     NS_ASSERTION(!(mNestedEventLevelDepth < 0), "mNestedEventLevelDepth < 0?");
38103:     if (mNestedEventLevelDepth <= 0) {
38103:         ResetNestedEventHook();
38103:         ResetPumpHooks();
38103:         InternalCallSetNestedEventState(false);
38103:     }
38103:     return handled;
38103: }
38103: 
36124: /* windowless drawing helpers */
36124: 
36124: bool
39279: PluginInstanceChild::SharedSurfaceSetWindow(const NPRemoteWindow& aWindow)
36124: {
36124:     // If the surfaceHandle is empty, parent is telling us we can reuse our cached
36124:     // memory surface and hdc. Otherwise, we need to reset, usually due to a
36124:     // expanding plugin port size.
36124:     if (!aWindow.surfaceHandle) {
36124:         if (!mSharedSurfaceDib.IsValid()) {
36124:             return false;
36124:         }
36124:     }
36124:     else {
36124:         // Attach to the new shared surface parent handed us.
36124:         if (NS_FAILED(mSharedSurfaceDib.Attach((SharedDIB::Handle)aWindow.surfaceHandle,
36124:                                                aWindow.width, aWindow.height, 32)))
36124:           return false;
36270:         // Free any alpha extraction resources if needed. This will be reset
36270:         // the next time it's used.
36270:         AlphaExtractCacheRelease();
36124:     }
36124:       
36124:     // NPRemoteWindow's origin is the origin of our shared dib.
36124:     mWindow.x      = 0;
36124:     mWindow.y      = 0;
36124:     mWindow.width  = aWindow.width;
36124:     mWindow.height = aWindow.height;
36124:     mWindow.type   = aWindow.type;
36124: 
36124:     mWindow.window = reinterpret_cast<void*>(mSharedSurfaceDib.GetHDC());
39279: 
39279:     if (mPluginIface->setwindow)
39279:         mPluginIface->setwindow(&mData, &mWindow);
36124: 
36124:     return true;
36124: }
36124: 
36124: void
36124: PluginInstanceChild::SharedSurfaceRelease()
36124: {
36124:     mSharedSurfaceDib.Close();
36270:     AlphaExtractCacheRelease();
36270: }
36270: 
36270: /* double pass cache buffer - (rarely) used in cases where alpha extraction
36270:  * occurs for windowless plugins. */
36270:  
36270: bool
36270: PluginInstanceChild::AlphaExtractCacheSetup()
36270: {
36270:     AlphaExtractCacheRelease();
36270: 
36270:     mAlphaExtract.hdc = ::CreateCompatibleDC(NULL);
36270: 
36270:     if (!mAlphaExtract.hdc)
36270:         return false;
36270: 
36270:     BITMAPINFOHEADER bmih;
36270:     memset((void*)&bmih, 0, sizeof(BITMAPINFOHEADER));
36270:     bmih.biSize        = sizeof(BITMAPINFOHEADER);
36270:     bmih.biWidth       = mWindow.width;
36270:     bmih.biHeight      = mWindow.height;
36270:     bmih.biPlanes      = 1;
36270:     bmih.biBitCount    = 32;
36270:     bmih.biCompression = BI_RGB;
36270: 
36270:     void* ppvBits = nsnull;
36270:     mAlphaExtract.bmp = ::CreateDIBSection(mAlphaExtract.hdc,
36270:                                            (BITMAPINFO*)&bmih,
36270:                                            DIB_RGB_COLORS,
36270:                                            (void**)&ppvBits,
36270:                                            NULL,
36270:                                            (unsigned long)sizeof(BITMAPINFOHEADER));
36270:     if (!mAlphaExtract.bmp)
36270:       return false;
36270: 
36270:     DeleteObject(::SelectObject(mAlphaExtract.hdc, mAlphaExtract.bmp));
36270:     return true;
36124: }
36124: 
36124: void
36270: PluginInstanceChild::AlphaExtractCacheRelease()
36124: {
36270:     if (mAlphaExtract.bmp)
36270:         ::DeleteObject(mAlphaExtract.bmp);
36270: 
36270:     if (mAlphaExtract.hdc)
36270:         ::DeleteObject(mAlphaExtract.hdc);
36270: 
36270:     mAlphaExtract.bmp = NULL;
36270:     mAlphaExtract.hdc = NULL;
36270: }
36270: 
36270: void
36270: PluginInstanceChild::UpdatePaintClipRect(RECT* aRect)
36270: {
36270:     if (aRect) {
36124:         // Update the clip rect on our internal hdc
36270:         HRGN clip = ::CreateRectRgnIndirect(aRect);
36124:         ::SelectClipRgn(mSharedSurfaceDib.GetHDC(), clip);
36124:         ::DeleteObject(clip);
36124:     }
36270: }
36270: 
36270: int16_t
36270: PluginInstanceChild::SharedSurfacePaint(NPEvent& evcopy)
36270: {
39279:     if (!mPluginIface->event)
39279:         return false;
39279: 
36270:     RECT* pRect = reinterpret_cast<RECT*>(evcopy.lParam);
36270: 
36270:     switch(mAlphaExtract.doublePass) {
36270:         case RENDER_NATIVE:
36124:             // pass the internal hdc to the plugin
36270:             UpdatePaintClipRect(pRect);
36124:             evcopy.wParam = WPARAM(mSharedSurfaceDib.GetHDC());
36270:             return mPluginIface->event(&mData, reinterpret_cast<void*>(&evcopy));
36270:         break;
36270:         case RENDER_BACK_ONE:
36270:               // Handle a double pass render used in alpha extraction for transparent
36270:               // plugins. (See nsObjectFrame and gfxWindowsNativeDrawing for details.)
36270:               // We render twice, once to the shared dib, and once to a cache which
36270:               // we copy back on a second paint. These paints can't be spread across
36270:               // multiple rpc messages as delays cause animation frame changes.
36270:               if (!mAlphaExtract.bmp && !AlphaExtractCacheSetup()) {
36270:                   mAlphaExtract.doublePass = RENDER_NATIVE;
36270:                   return false;
36270:               }
36270: 
36270:               // See gfxWindowsNativeDrawing, color order doesn't have to match.
36270:               ::FillRect(mSharedSurfaceDib.GetHDC(), pRect, (HBRUSH)GetStockObject(WHITE_BRUSH));
36270:               UpdatePaintClipRect(pRect);
36270:               evcopy.wParam = WPARAM(mSharedSurfaceDib.GetHDC());
36270:               if (!mPluginIface->event(&mData, reinterpret_cast<void*>(&evcopy))) {
36270:                   mAlphaExtract.doublePass = RENDER_NATIVE;
36270:                   return false;
36270:               }
36270: 
36270:               // Copy to cache. We render to shared dib so we don't have to call
36270:               // setwindow between calls (flash issue).  
36270:               ::BitBlt(mAlphaExtract.hdc,
36270:                        pRect->left,
36270:                        pRect->top,
36270:                        pRect->right - pRect->left,
36270:                        pRect->bottom - pRect->top,
36270:                        mSharedSurfaceDib.GetHDC(),
36270:                        pRect->left,
36270:                        pRect->top,
36270:                        SRCCOPY);
36270: 
36270:               ::FillRect(mSharedSurfaceDib.GetHDC(), pRect, (HBRUSH)GetStockObject(BLACK_BRUSH));
36270:               if (!mPluginIface->event(&mData, reinterpret_cast<void*>(&evcopy))) {
36270:                   mAlphaExtract.doublePass = RENDER_NATIVE;
36270:                   return false;
36270:               }
36270:               mAlphaExtract.doublePass = RENDER_BACK_TWO;
36270:               return true;
36270:         break;
36270:         case RENDER_BACK_TWO:
36270:               // copy our cached surface back
36270:               ::BitBlt(mSharedSurfaceDib.GetHDC(),
36270:                        pRect->left,
36270:                        pRect->top,
36270:                        pRect->right - pRect->left,
36270:                        pRect->bottom - pRect->top,
36270:                        mAlphaExtract.hdc,
36270:                        pRect->left,
36270:                        pRect->top,
36270:                        SRCCOPY);
36270:               mAlphaExtract.doublePass = RENDER_NATIVE;
36270:               return true;
36270:         break;
36270:     }
36270:     return false;
36124: }
36124: 
35747: #endif // OS_WIN
35747: 
37550: bool
37550: PluginInstanceChild::AnswerSetPluginFocus()
37550: {
37550:     PR_LOG(gPluginLog, PR_LOG_DEBUG, ("%s", FULLFUNCTION));
37550: 
37550: #if defined(OS_WIN)
37550:     // Parent is letting us know something set focus to the plugin.
37550:     if (::GetFocus() == mPluginWindowHWND)
37550:         return true;
37550:     ::SetFocus(mPluginWindowHWND);
37550:     return true;
37550: #else
37550:     NS_NOTREACHED("PluginInstanceChild::AnswerSetPluginFocus not implemented!");
37550:     return false;
37550: #endif
37550: }
37550: 
37554: bool
37554: PluginInstanceChild::AnswerUpdateWindow()
37554: {
37554:     PR_LOG(gPluginLog, PR_LOG_DEBUG, ("%s", FULLFUNCTION));
37554: 
37554: #if defined(OS_WIN)
37554:     if (mPluginWindowHWND)
37554:       UpdateWindow(mPluginWindowHWND);
37554:     return true;
37554: #else
37554:     NS_NOTREACHED("PluginInstanceChild::AnswerUpdateWindow not implemented!");
37554:     return false;
37554: #endif
37554: }
37554: 
35898: PPluginScriptableObjectChild*
35943: PluginInstanceChild::AllocPPluginScriptableObject()
35835: {
35971:     AssertPluginThread();
37311:     return new PluginScriptableObjectChild(Proxy);
35835: }
35835: 
35926: bool
35965: PluginInstanceChild::DeallocPPluginScriptableObject(
35965:     PPluginScriptableObjectChild* aObject)
35835: {
35971:     AssertPluginThread();
37477:     delete aObject;
35945:     return true;
35925: }
35890: 
35965: bool
38994: PluginInstanceChild::RecvPPluginScriptableObjectConstructor(
35965:                                            PPluginScriptableObjectChild* aActor)
35965: {
35971:     AssertPluginThread();
35971: 
35965:     // This is only called in response to the parent process requesting the
35965:     // creation of an actor. This actor will represent an NPObject that is
35965:     // created by the browser and returned to the plugin.
35965:     PluginScriptableObjectChild* actor =
35965:         static_cast<PluginScriptableObjectChild*>(aActor);
37311:     NS_ASSERTION(!actor->GetObject(false), "Actor already has an object?!");
37311: 
37311:     actor->InitializeProxy();
37311:     NS_ASSERTION(actor->GetObject(false), "Actor should have an object!");
35965: 
35965:     return true;
35965: }
35965: 
37126: bool
37126: PluginInstanceChild::AnswerPBrowserStreamConstructor(
37126:     PBrowserStreamChild* aActor,
37126:     const nsCString& url,
37126:     const uint32_t& length,
37126:     const uint32_t& lastmodified,
37126:     PStreamNotifyChild* notifyData,
37126:     const nsCString& headers,
37126:     const nsCString& mimeType,
37126:     const bool& seekable,
37126:     NPError* rv,
37126:     uint16_t* stype)
37126: {
37126:     AssertPluginThread();
37126:     *rv = static_cast<BrowserStreamChild*>(aActor)
39283:           ->StreamConstructed(mimeType, seekable, stype);
37126:     return true;
37126: }
37126: 
35898: PBrowserStreamChild*
35943: PluginInstanceChild::AllocPBrowserStream(const nsCString& url,
35893:                                          const uint32_t& length,
35890:                                          const uint32_t& lastmodified,
35990:                                          PStreamNotifyChild* notifyData,
35890:                                          const nsCString& headers,
35890:                                          const nsCString& mimeType,
35890:                                          const bool& seekable,
35893:                                          NPError* rv,
35893:                                          uint16_t *stype)
35890: {
35971:     AssertPluginThread();
39283:     return new BrowserStreamChild(this, url, length, lastmodified,
39283:                                   static_cast<StreamNotifyChild*>(notifyData),
35949:                                   headers, mimeType, seekable, rv, stype);
35890: }
35890: 
35926: bool
36138: PluginInstanceChild::DeallocPBrowserStream(PBrowserStreamChild* stream)
35890: {
35971:     AssertPluginThread();
35890:     delete stream;
35926:     return true;
35890: }
35890: 
35938: PPluginStreamChild*
35943: PluginInstanceChild::AllocPPluginStream(const nsCString& mimeType,
35938:                                         const nsCString& target,
35938:                                         NPError* result)
35938: {
35938:     NS_RUNTIMEABORT("not callable");
35938:     return NULL;
35938: }
35938: 
35938: bool
36138: PluginInstanceChild::DeallocPPluginStream(PPluginStreamChild* stream)
35938: {
35971:     AssertPluginThread();
35938:     delete stream;
35938:     return true;
35938: }
35938: 
35904: PStreamNotifyChild*
35943: PluginInstanceChild::AllocPStreamNotify(const nsCString& url,
35904:                                         const nsCString& target,
35904:                                         const bool& post,
35904:                                         const nsCString& buffer,
35904:                                         const bool& file,
35904:                                         NPError* result)
35904: {
35971:     AssertPluginThread();
35904:     NS_RUNTIMEABORT("not reached");
35904:     return NULL;
35904: }
35904: 
39283: void
39283: StreamNotifyChild::ActorDestroy(ActorDestroyReason why)
35904: {
39283:     if (AncestorDeletion == why && mBrowserStream) {
39283:         NS_ERROR("Pending NPP_URLNotify not called when closing an instance.");
39283: 
39283:         // reclaim responsibility for deleting ourself
39284:         mBrowserStream->mStreamNotify = NULL;
39283:         mBrowserStream = NULL;
39283:     }
39283: }
39283: 
39283: 
39283: void
39283: StreamNotifyChild::SetAssociatedStream(BrowserStreamChild* bs)
39283: {
39283:     NS_ASSERTION(bs, "Shouldn't be null");
39283:     NS_ASSERTION(!mBrowserStream, "Two streams for one streamnotify?");
39283: 
39283:     mBrowserStream = bs;
36138: }
35971: 
36138: bool
39283: StreamNotifyChild::Recv__delete__(const NPReason& reason)
36138: {
39283:     AssertPluginThread();
39283: 
39283:     if (mBrowserStream)
39283:         mBrowserStream->NotifyPending();
39283:     else
39283:         NPP_URLNotify(reason);
39283: 
35926:     return true;
35904: }
35904: 
39283: void
39283: StreamNotifyChild::NPP_URLNotify(NPReason reason)
39283: {
39283:     PluginInstanceChild* instance = static_cast<PluginInstanceChild*>(Manager());
39283: 
39283:     if (mClosure)
39283:         instance->mPluginIface->urlnotify(instance->GetNPP(), mURL.get(),
39283:                                           reason, mClosure);
39283: }
39283: 
36110: bool
36138: PluginInstanceChild::DeallocPStreamNotify(PStreamNotifyChild* notifyData)
36110: {
36138:     AssertPluginThread();
39283: 
39283:     if (!static_cast<StreamNotifyChild*>(notifyData)->mBrowserStream)
36110:         delete notifyData;
36110:     return true;
36110: }
36110: 
35925: PluginScriptableObjectChild*
35945: PluginInstanceChild::GetActorForNPObject(NPObject* aObject)
35925: {
35971:     AssertPluginThread();
35925:     NS_ASSERTION(aObject, "Null pointer!");
35925: 
35965:     if (aObject->_class == PluginScriptableObjectChild::GetClass()) {
35965:         // One of ours! It's a browser-provided object.
35965:         ChildNPObject* object = static_cast<ChildNPObject*>(aObject);
35965:         NS_ASSERTION(object->parent, "Null actor!");
35965:         return object->parent;
35965:     }
35945: 
35925:     PluginScriptableObjectChild* actor =
35945:         PluginModuleChild::current()->GetActorForNPObject(aObject);
35945:     if (actor) {
35965:         // Plugin-provided object that we've previously wrapped.
35945:         return actor;
35945:     }
35945: 
37311:     actor = new PluginScriptableObjectChild(LocalObject);
38994:     if (!SendPPluginScriptableObjectConstructor(actor)) {
37311:         NS_ERROR("Failed to send constructor message!");
37311:         return nsnull;
37311:     }
35925: 
37311:     actor->InitializeLocal(aObject);
35925:     return actor;
35925: }
35938: 
35938: NPError
35938: PluginInstanceChild::NPN_NewStream(NPMIMEType aMIMEType, const char* aWindow,
35938:                                    NPStream** aStream)
35938: {
35971:     AssertPluginThread();
35971: 
36138:     PluginStreamChild* ps = new PluginStreamChild();
35938: 
35938:     NPError result;
35938:     CallPPluginStreamConstructor(ps, nsDependentCString(aMIMEType),
35944:                                  NullableString(aWindow), &result);
35938:     if (NPERR_NO_ERROR != result) {
35938:         *aStream = NULL;
36138:         PPluginStreamChild::Call__delete__(ps, NPERR_GENERIC_ERROR, true);
35938:         return result;
35938:     }
35938: 
35938:     *aStream = &ps->mStream;
35938:     return NPERR_NO_ERROR;
35938: }
36082: 
36835: void
36835: PluginInstanceChild::InvalidateRect(NPRect* aInvalidRect)
36082: {
36082:     NS_ASSERTION(aInvalidRect, "Null pointer!");
36082: 
36082: #ifdef OS_WIN
36124:     // Invalidate and draw locally for windowed plugins.
36124:     if (mWindow.type == NPWindowTypeWindow) {
36082:       NS_ASSERTION(IsWindow(mPluginWindowHWND), "Bad window?!");
36082:       RECT rect = { aInvalidRect->left, aInvalidRect->top,
36082:                     aInvalidRect->right, aInvalidRect->bottom };
36836:       ::InvalidateRect(mPluginWindowHWND, &rect, FALSE);
36835:       return;
36124:     }
36082: #endif
36083: 
36835:     SendNPN_InvalidateRect(*aInvalidRect);
36082: }
37311: 
37348: uint32_t
37348: PluginInstanceChild::ScheduleTimer(uint32_t interval, bool repeat,
37348:                                    TimerFunc func)
37348: {
37348:     ChildTimer* t = new ChildTimer(this, interval, repeat, func);
37348:     if (0 == t->ID()) {
37348:         delete t;
37348:         return 0;
37348:     }
37348: 
37348:     mTimers.AppendElement(t);
37348:     return t->ID();
37348: }
37348: 
37348: void
37348: PluginInstanceChild::UnscheduleTimer(uint32_t id)
37348: {
37348:     if (0 == id)
37348:         return;
37348: 
37884:     mTimers.RemoveElement(id, ChildTimer::IDComparator());
37348: }
37348: 
38669: static PLDHashOperator
38669: InvalidateObject(DeletingObjectEntry* e, void* userArg)
38669: {
38669:     NPObject* o = e->GetKey();
38669:     if (!e->mDeleted && o->_class && o->_class->invalidate)
38669:         o->_class->invalidate(o);
38669: 
38669:     return PL_DHASH_NEXT;
38669: }
38669: 
38669: static PLDHashOperator
38669: DeleteObject(DeletingObjectEntry* e, void* userArg)
38669: {
38669:     NPObject* o = e->GetKey();
38669:     if (!e->mDeleted) {
38669:         e->mDeleted = true;
38669: 
38669: #ifdef NS_BUILD_REFCNT_LOGGING
38669:         {
38669:             int32_t refcnt = o->referenceCount;
38669:             while (refcnt) {
38669:                 --refcnt;
38669:                 NS_LOG_RELEASE(o, refcnt, "NPObject");
38669:             }
38669:         }
38669: #endif
38669: 
38669:         PluginModuleChild::DeallocNPObject(o);
38669:     }
38669: 
38669:     return PL_DHASH_NEXT;
38669: }
38669: 
37311: bool
37311: PluginInstanceChild::AnswerNPP_Destroy(NPError* aResult)
37311: {
38669:     PLUGIN_LOG_DEBUG_METHOD;
38669:     AssertPluginThread();
38669: 
39283:     nsTArray<PBrowserStreamChild*> streams;
39283:     ManagedPBrowserStreamChild(streams);
39283: 
39283:     // First make sure none of these streams become deleted
39283:     for (PRUint32 i = 0; i < streams.Length(); ) {
39283:         if (static_cast<BrowserStreamChild*>(streams[i])->InstanceDying())
39283:             ++i;
39283:         else
39283:             streams.RemoveElementAt(i);
39283:     }
39283:     for (PRUint32 i = 0; i < streams.Length(); ++i)
39283:         static_cast<BrowserStreamChild*>(streams[i])->FinishDelivery();
39283: 
37348:     for (PRUint32 i = 0; i < mPendingAsyncCalls.Length(); ++i)
37348:         mPendingAsyncCalls[i]->Cancel();
37348:     mPendingAsyncCalls.TruncateLength(0);
37348: 
37884:     mTimers.Clear();
37348: 
38669:     PluginModuleChild::current()->NPP_Destroy(this);
38669:     mData.ndata = 0;
38669: 
38669:     mDeletingHash = new nsTHashtable<DeletingObjectEntry>;
38669:     mDeletingHash->Init();
38669:     PluginModuleChild::current()->FindNPObjectsForInstance(this);
38669: 
38669:     mDeletingHash->EnumerateEntries(InvalidateObject, NULL);
38669:     mDeletingHash->EnumerateEntries(DeleteObject, NULL);
37311: 
38354:     // Null out our cached actors as they should have been killed in the
38354:     // PluginInstanceDestroyed call above.
38354:     mCachedWindowActor = nsnull;
38354:     mCachedElementActor = nsnull;
38354: 
37311: #if defined(OS_WIN)
37311:     SharedSurfaceRelease();
38103:     ResetNestedEventHook();
38103:     ResetPumpHooks();
37311: #endif
37311: 
38669:     return true;
37311: }
