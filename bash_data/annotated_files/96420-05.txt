    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  * vim: set ts=2 sw=2 et tw=78:
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Steve Clark <buster@netscape.com>
 5147:  *   HÃ¥kan Waara <hwaara@chello.se>
    1:  *   Dan Rosen <dr@netscape.com>
    1:  *   Daniel Glazman <glazman@netscape.com>
38005:  *   Mats Palmgren <matspal@gmail.com>
61031:  *   Mihai Sucan <mihai.sucan@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK *****
    1:  *
    1:  * This Original Code has been modified by IBM Corporation.
    1:  * Modifications made by IBM described herein are
    1:  * Copyright (c) International Business Machines
    1:  * Corporation, 2000
    1:  *
    1:  * Modifications to Mozilla code or documentation
    1:  * identified per MPL Section 3.3
    1:  *
    1:  * Date         Modified by     Description of modification
    1:  * 05/03/2000   IBM Corp.       Observer events for reflow states
    1:  */
    1: 
    1: /* a presentation of a document, part 2 */
    1: 
78155: #ifndef nsPresShell_h_
78155: #define nsPresShell_h_
78155: 
    1: #include "nsIPresShell.h"
    1: #include "nsStubDocumentObserver.h"
78155: #include "nsISelectionController.h"
78155: #include "nsIObserver.h"
78155: #include "nsWeakReference.h"
78155: #include "nsCRT.h"
78155: #include "nsAutoPtr.h"
78155: #include "nsIWidget.h"
    1: #include "nsStyleSet.h"
78155: #include "nsPresArena.h"
78155: #include "nsFrameSelection.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsContentUtils.h"
78227: #include "nsRefreshDriver.h"
78155: 
86939: class nsRange;
78155: class nsIDragService;
78155: class nsCSSStyleSheet;
78155: 
78155: struct RangePaintInfo;
78155: struct nsCallbackEventRequest;
27962: #ifdef MOZ_REFLOW_PERF
78155: class ReflowCountMgr;
    1: #endif
    1: 
78155: #define STACK_ARENA_MARK_INCREMENT 50
78155: /* a bit under 4096, for malloc overhead */
78155: #define STACK_ARENA_BLOCK_INCREMENT 4044
    1: 
    1: /**A block of memory that the stack will 
    1:  * chop up and hand out
    1:  */
    1: struct StackBlock {
    1:    
    1:    // a block of memory.  Note that this must be first so that it will
    1:    // be aligned.
78155:    char mBlock[STACK_ARENA_BLOCK_INCREMENT];
    1: 
    1:    // another block of memory that would only be created
    1:    // if our stack overflowed. Yes we have the ability
    1:    // to grow on a stack overflow
    1:    StackBlock* mNext;
    1: 
    1:    StackBlock() : mNext(nsnull) { }
    1:    ~StackBlock() { }
    1: };
    1: 
    1: /* we hold an array of marks. A push pushes a mark on the stack
    1:  * a pop pops it off.
    1:  */
    1: struct StackMark {
    1:    // the block of memory we are currently handing out chunks of
    1:    StackBlock* mBlock;
    1:    
    1:    // our current position in the memory
    1:    size_t mPos;
    1: };
    1: 
    1: 
    1: /* A stack arena allows a stack based interface to a block of memory.
    1:  * It should be used when you need to allocate some temporary memory that
    1:  * you will immediately return.
    1:  */
    1: class StackArena {
    1: public:
    1:   StackArena();
    1:   ~StackArena();
    1: 
    1:   nsresult Init() { return mBlocks ? NS_OK : NS_ERROR_OUT_OF_MEMORY; }
    1: 
    1:   // Memory management functions
    1:   void* Allocate(size_t aSize);
    1:   void Push();
    1:   void Pop();
    1: 
84365:   size_t SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf) const {
84365:     size_t n = 0;
42982:     StackBlock *block = mBlocks;
42982:     while (block) {
88300:       n += aMallocSizeOf(block);
42982:       block = block->mNext;
42982:     }
88300:     n += aMallocSizeOf(mMarks);
84365:     return n;
42982:   }
42982: 
    1: private:
    1:   // our current position in memory
    1:   size_t mPos;
    1: 
    1:   // a list of memory block. Usually there is only one
    1:   // but if we overrun our stack size we can get more memory.
    1:   StackBlock* mBlocks;
    1: 
    1:   // the current block of memory we are passing our chucks of
    1:   StackBlock* mCurBlock;
    1: 
    1:   // our stack of mark where push has been called
    1:   StackMark* mMarks;
    1: 
    1:   // the current top of the mark list
    1:   PRUint32 mStackTop;
    1: 
    1:   // the size of the mark array
    1:   PRUint32 mMarkLength;
    1: };
    1: 
    1: class nsPresShellEventCB;
29804: class nsAutoCauseReflowNotifier;
    1: 
82568: class PresShell : public nsIPresShell,
    1:                   public nsStubDocumentObserver,
    1:                   public nsISelectionController, public nsIObserver,
64531:                   public nsSupportsWeakReference
    1: {
    1: public:
    1:   PresShell();
    1: 
    1:   NS_DECL_AND_IMPL_ZEROING_OPERATOR_NEW
    1: 
    1:   // nsISupports
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   // nsIPresShell
39668:   virtual NS_HIDDEN_(nsresult) Init(nsIDocument* aDocument,
    1:                                    nsPresContext* aPresContext,
    1:                                    nsIViewManager* aViewManager,
    1:                                    nsStyleSet* aStyleSet,
    1:                                    nsCompatibility aCompatMode);
39668:   virtual NS_HIDDEN_(void) Destroy();
    1: 
32511:   virtual NS_HIDDEN_(void*) AllocateFrame(nsQueryFrame::FrameIID aCode,
32511:                                           size_t aSize);
32511:   virtual NS_HIDDEN_(void)  FreeFrame(nsQueryFrame::FrameIID aCode,
31620:                                       void* aChunk);
31620: 
31620:   virtual NS_HIDDEN_(void*) AllocateMisc(size_t aSize);
31620:   virtual NS_HIDDEN_(void)  FreeMisc(size_t aSize, void* aChunk);
    1: 
    1:   // Dynamic stack memory allocation
    1:   virtual NS_HIDDEN_(void) PushStackMemory();
    1:   virtual NS_HIDDEN_(void) PopStackMemory();
    1:   virtual NS_HIDDEN_(void*) AllocateStackMemory(size_t aSize);
    1: 
79445:   virtual NS_HIDDEN_(nsresult) SetPreferenceStyleRules(bool aForceReflow);
    1: 
    1:   NS_IMETHOD GetSelection(SelectionType aType, nsISelection** aSelection);
    1:   virtual nsISelection* GetCurrentSelection(SelectionType aType);
    1: 
    1:   NS_IMETHOD SetDisplaySelection(PRInt16 aToggle);
    1:   NS_IMETHOD GetDisplaySelection(PRInt16 *aToggle);
56442:   NS_IMETHOD ScrollSelectionIntoView(SelectionType aType, SelectionRegion aRegion,
56442:                                      PRInt16 aFlags);
    1:   NS_IMETHOD RepaintSelection(SelectionType aType);
    1: 
39668:   virtual NS_HIDDEN_(void) BeginObservingDocument();
39668:   virtual NS_HIDDEN_(void) EndObservingDocument();
39668:   virtual NS_HIDDEN_(nsresult) InitialReflow(nscoord aWidth, nscoord aHeight);
39668:   virtual NS_HIDDEN_(nsresult) ResizeReflow(nscoord aWidth, nscoord aHeight);
54649:   virtual NS_HIDDEN_(nsresult) ResizeReflowOverride(nscoord aWidth, nscoord aHeight);
39668:   virtual NS_HIDDEN_(void) StyleChangeReflow();
39668:   virtual NS_HIDDEN_(nsIPageSequenceFrame*) GetPageSequenceFrame() const;
10998:   virtual NS_HIDDEN_(nsIFrame*) GetRealPrimaryFrameFor(nsIContent* aContent) const;
    1: 
39668:   virtual NS_HIDDEN_(nsIFrame*) GetPlaceholderFrameFor(nsIFrame* aFrame) const;
39668:   virtual NS_HIDDEN_(void) FrameNeedsReflow(nsIFrame *aFrame, IntrinsicDirty aIntrinsicDirty,
 1161:                                             nsFrameState aBitToAdd);
39668:   virtual NS_HIDDEN_(void) FrameNeedsToContinueReflow(nsIFrame *aFrame);
39668:   virtual NS_HIDDEN_(void) CancelAllPendingReflows();
79445:   virtual NS_HIDDEN_(bool) IsSafeToFlush() const;
39668:   virtual NS_HIDDEN_(void) FlushPendingNotifications(mozFlushType aType);
    1: 
    1:   /**
    1:    * Recreates the frames for a node
    1:    */
40046:   virtual NS_HIDDEN_(nsresult) RecreateFramesFor(nsIContent* aContent);
    1: 
    1:   /**
    1:    * Post a callback that should be handled after reflow has finished.
    1:    */
40046:   virtual NS_HIDDEN_(nsresult) PostReflowCallback(nsIReflowCallback* aCallback);
40046:   virtual NS_HIDDEN_(void) CancelReflowCallback(nsIReflowCallback* aCallback);
40046: 
40046:   virtual NS_HIDDEN_(void) ClearFrameRefs(nsIFrame* aFrame);
68481:   virtual NS_HIDDEN_(already_AddRefed<nsRenderingContext>) GetReferenceRenderingContext();
79445:   virtual NS_HIDDEN_(nsresult) GoToAnchor(const nsAString& aAnchorName, bool aScroll);
40046:   virtual NS_HIDDEN_(nsresult) ScrollToAnchor();
40046: 
40046:   virtual NS_HIDDEN_(nsresult) ScrollContentIntoView(nsIContent* aContent,
93554:                                                      ScrollAxis  aVertical,
93554:                                                      ScrollAxis  aHorizontal,
56647:                                                      PRUint32    aFlags);
79445:   virtual bool ScrollFrameRectIntoView(nsIFrame*     aFrame,
37077:                                        const nsRect& aRect,
93554:                                        ScrollAxis    aVertical,
93554:                                        ScrollAxis    aHorizontal,
37077:                                        PRUint32      aFlags);
37073:   virtual nsRectVisibility GetRectVisibility(nsIFrame *aFrame,
37073:                                              const nsRect &aRect,
40053:                                              nscoord aMinTwips) const;
    1: 
79445:   virtual NS_HIDDEN_(void) SetIgnoreFrameDestruction(bool aIgnore);
40046:   virtual NS_HIDDEN_(void) NotifyDestroyingFrame(nsIFrame* aFrame);
40046: 
40053:   virtual NS_HIDDEN_(nsresult) GetLinkLocation(nsIDOMNode* aNode, nsAString& aLocationString) const;
40046: 
79445:   virtual NS_HIDDEN_(nsresult) CaptureHistoryState(nsILayoutHistoryState** aLayoutHistoryState, bool aLeavingPage);
40020: 
40049:   virtual NS_HIDDEN_(void) UnsuppressPainting();
40020: 
    1:   virtual nsresult GetAgentStyleSheets(nsCOMArray<nsIStyleSheet>& aSheets);
    1:   virtual nsresult SetAgentStyleSheets(const nsCOMArray<nsIStyleSheet>& aSheets);
    1: 
    1:   virtual nsresult AddOverrideStyleSheet(nsIStyleSheet *aSheet);
    1:   virtual nsresult RemoveOverrideStyleSheet(nsIStyleSheet *aSheet);
    1: 
40055:   virtual NS_HIDDEN_(nsresult) HandleEventWithTarget(nsEvent* aEvent, nsIFrame* aFrame,
    1:                                                      nsIContent* aContent,
    1:                                                      nsEventStatus* aStatus);
40047:   virtual NS_HIDDEN_(nsIFrame*) GetEventTargetFrame();
40047:   virtual NS_HIDDEN_(already_AddRefed<nsIContent>) GetEventTargetContent(nsEvent* aEvent);
40020: 
    1: 
    1:   virtual nsresult ReconstructFrames(void);
    1:   virtual void Freeze();
    1:   virtual void Thaw();
79445:   virtual void FireOrClearDelayedEvents(bool aFireEvents);
    1: 
 5680:   virtual nsIFrame* GetFrameForPoint(nsIFrame* aFrame, nsPoint aPt);
 5680: 
40052:   virtual NS_HIDDEN_(nsresult) RenderDocument(const nsRect& aRect, PRUint32 aFlags,
    1:                                               nscolor aBackgroundColor,
 1735:                                               gfxContext* aThebesContext);
    1: 
    1:   virtual already_AddRefed<gfxASurface> RenderNode(nsIDOMNode* aNode,
43137:                                                    nsIntRegion* aRegion,
23738:                                                    nsIntPoint& aPoint,
23738:                                                    nsIntRect* aScreenRect);
    1: 
    1:   virtual already_AddRefed<gfxASurface> RenderSelection(nsISelection* aSelection,
23738:                                                         nsIntPoint& aPoint,
23738:                                                         nsIntRect* aScreenRect);
    1: 
47198:   virtual already_AddRefed<nsPIDOMWindow> GetRootWindow();
47198: 
48947:   virtual LayerManager* GetLayerManager();
48947: 
79445:   virtual void SetIgnoreViewportScrolling(bool aIgnore);
54080: 
54080:   virtual void SetDisplayPort(const nsRect& aDisplayPort);
54080: 
54081:   virtual nsresult SetResolution(float aXResolution, float aYResolution);
54081: 
    1:   //nsIViewObserver interface
    1: 
82568:   virtual void Paint(nsIView* aViewToPaint, nsIWidget* aWidget,
82568:                      const nsRegion& aDirtyRegion, const nsIntRegion& aIntDirtyRegion,
88468:                      bool aWillSendDidPaint);
82568:   virtual nsresult HandleEvent(nsIFrame*       aFrame,
    1:                                nsGUIEvent*     aEvent,
79445:                                bool            aDontRetargetEvents,
    1:                                nsEventStatus*  aEventStatus);
40055:   virtual NS_HIDDEN_(nsresult) HandleDOMEventWithTarget(nsIContent* aTargetContent,
    1:                                                         nsEvent* aEvent,
    1:                                                         nsEventStatus* aStatus);
40055:   virtual NS_HIDDEN_(nsresult) HandleDOMEventWithTarget(nsIContent* aTargetContent,
29844:                                                         nsIDOMEvent* aEvent,
29844:                                                         nsEventStatus* aStatus);
82568:   virtual bool ShouldIgnoreInvalidation();
82568:   virtual void WillPaint(bool aWillSendDidPaint);
82568:   virtual void DidPaint();
87344:   virtual void ScheduleViewManagerFlush();
82568:   virtual void DispatchSynthMouseMove(nsGUIEvent *aEvent, bool aFlushOnHoverChange);
82568:   virtual void ClearMouseCaptureOnView(nsIView* aView);
82568:   virtual bool IsVisible();
    1: 
    1:   // caret handling
40053:   virtual NS_HIDDEN_(already_AddRefed<nsCaret>) GetCaret() const;
40045:   virtual NS_HIDDEN_(void) MaybeInvalidateCaretPosition();
79445:   NS_IMETHOD SetCaretEnabled(bool aInEnable);
79445:   NS_IMETHOD SetCaretReadOnly(bool aReadOnly);
79445:   NS_IMETHOD GetCaretEnabled(bool *aOutEnabled);
79445:   NS_IMETHOD SetCaretVisibilityDuringSelection(bool aVisibility);
79445:   NS_IMETHOD GetCaretVisible(bool *_retval);
15969:   virtual void SetCaret(nsCaret *aNewCaret);
 6232:   virtual void RestoreCaret();
    1: 
    1:   NS_IMETHOD SetSelectionFlags(PRInt16 aInEnable);
    1:   NS_IMETHOD GetSelectionFlags(PRInt16 *aOutEnable);
    1: 
    1:   // nsISelectionController
    1: 
79445:   NS_IMETHOD CharacterMove(bool aForward, bool aExtend);
20532:   NS_IMETHOD CharacterExtendForDelete();
43298:   NS_IMETHOD CharacterExtendForBackspace();
79445:   NS_IMETHOD WordMove(bool aForward, bool aExtend);
79445:   NS_IMETHOD WordExtendForDelete(bool aForward);
79445:   NS_IMETHOD LineMove(bool aForward, bool aExtend);
79445:   NS_IMETHOD IntraLineMove(bool aForward, bool aExtend);
79445:   NS_IMETHOD PageMove(bool aForward, bool aExtend);
79445:   NS_IMETHOD ScrollPage(bool aForward);
79445:   NS_IMETHOD ScrollLine(bool aForward);
86684:   NS_IMETHOD ScrollCharacter(bool aRight);
79445:   NS_IMETHOD CompleteScroll(bool aForward);
79445:   NS_IMETHOD CompleteMove(bool aForward, bool aExtend);
    1:   NS_IMETHOD SelectAll();
79445:   NS_IMETHOD CheckVisibility(nsIDOMNode *node, PRInt16 startOffset, PRInt16 EndOffset, bool *_retval);
88028:   virtual nsresult CheckVisibilityContent(nsIContent* aNode, PRInt16 aStartOffset,
88028:                                           PRInt16 aEndOffset, bool* aRetval);
    1: 
    1:   // nsIDocumentObserver
56166:   NS_DECL_NSIDOCUMENTOBSERVER_BEGINUPDATE
56166:   NS_DECL_NSIDOCUMENTOBSERVER_ENDUPDATE
56166:   NS_DECL_NSIDOCUMENTOBSERVER_BEGINLOAD
56166:   NS_DECL_NSIDOCUMENTOBSERVER_ENDLOAD
64120:   NS_DECL_NSIDOCUMENTOBSERVER_CONTENTSTATECHANGED
56166:   NS_DECL_NSIDOCUMENTOBSERVER_DOCUMENTSTATESCHANGED
56166:   NS_DECL_NSIDOCUMENTOBSERVER_STYLESHEETADDED
56166:   NS_DECL_NSIDOCUMENTOBSERVER_STYLESHEETREMOVED
56166:   NS_DECL_NSIDOCUMENTOBSERVER_STYLESHEETAPPLICABLESTATECHANGED
56166:   NS_DECL_NSIDOCUMENTOBSERVER_STYLERULECHANGED
56166:   NS_DECL_NSIDOCUMENTOBSERVER_STYLERULEADDED
56166:   NS_DECL_NSIDOCUMENTOBSERVER_STYLERULEREMOVED
    1: 
 3410:   // nsIMutationObserver
 3410:   NS_DECL_NSIMUTATIONOBSERVER_CHARACTERDATACHANGED
35534:   NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTEWILLCHANGE
 3410:   NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTECHANGED
 3410:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
 3410:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
 3410:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
 3410: 
    1:   NS_DECL_NSIOBSERVER
    1: 
    1: #ifdef MOZ_REFLOW_PERF
40052:   virtual NS_HIDDEN_(void) DumpReflows();
40052:   virtual NS_HIDDEN_(void) CountReflows(const char * aName, nsIFrame * aFrame);
40052:   virtual NS_HIDDEN_(void) PaintCount(const char * aName,
68481:                                       nsRenderingContext* aRenderingContext,
40052:                                       nsPresContext* aPresContext,
40052:                                       nsIFrame * aFrame,
68487:                                       const nsPoint& aOffset,
40052:                                       PRUint32 aColor);
79445:   virtual NS_HIDDEN_(void) SetPaintFrameCount(bool aOn);
79445:   virtual bool IsPaintingFrameCounts();
    1: #endif
    1: 
    1: #ifdef DEBUG
    1:   virtual void ListStyleContexts(nsIFrame *aRootFrame, FILE *out,
    1:                                  PRInt32 aIndent = 0);
    1: 
    1:   virtual void ListStyleSheets(FILE *out, PRInt32 aIndent = 0);
    1:   virtual void VerifyStyleTree();
    1: #endif
    1: 
    1: #ifdef PR_LOGGING
    1:   static PRLogModuleInfo* gLog;
    1: #endif
    1: 
79445:   virtual NS_HIDDEN_(void) DisableNonTestMouseEvents(bool aDisable);
24947: 
27834:   virtual void UpdateCanvasBackground();
27834: 
64531:   virtual nsresult AddCanvasBackgroundColorItem(nsDisplayListBuilder& aBuilder,
61411:                                                 nsDisplayList& aList,
61411:                                                 nsIFrame* aFrame,
61411:                                                 const nsRect& aBounds,
61411:                                                 nscolor aBackstopColor,
61411:                                                 PRUint32 aFlags);
61411: 
49166:   virtual nsresult AddPrintPreviewBackgroundItem(nsDisplayListBuilder& aBuilder,
49166:                                                  nsDisplayList& aList,
49166:                                                  nsIFrame* aFrame,
49166:                                                  const nsRect& aBounds);
49166: 
49168:   virtual nscolor ComputeBackstopColor(nsIView* aDisplayRoot);
49168: 
79445:   virtual NS_HIDDEN_(nsresult) SetIsActive(bool aIsActive);
50815: 
79445:   virtual bool GetIsViewportOverridden() { return mViewportOverridden; }
59572: 
79445:   virtual bool IsLayoutFlushObserver()
60746:   {
60746:     return GetPresContext()->RefreshDriver()->
60746:       IsLayoutFlushObserver(this);
60746:   }
60746: 
    1: protected:
    1:   virtual ~PresShell();
    1: 
79445:   void HandlePostedReflowCallbacks(bool aInterruptible);
 8509:   void CancelPostedReflowCallbacks();
    1: 
    1:   void UnsuppressAndInvalidate();
    1: 
29804:   void WillCauseReflow() {
29804:     nsContentUtils::AddScriptBlocker();
29804:     ++mChangeNestCount;
29804:   }
29804:   nsresult DidCauseReflow();
29804:   friend class nsAutoCauseReflowNotifier;
29804: 
87650:   bool TouchesAreEqual(nsIDOMTouch *aTouch1, nsIDOMTouch *aTouch2);
87650:   void DispatchTouchEvent(nsEvent *aEvent,
87650:                           nsEventStatus* aStatus,
87650:                           nsPresShellEventCB* aEventCB,
87650:                           bool aTouchIsNew);
87650: 
    1:   void     WillDoReflow();
79445:   void     DidDoReflow(bool aInterruptible);
27993:   // ProcessReflowCommands returns whether we processed all our dirty roots
27993:   // without interruptions.
79445:   bool     ProcessReflowCommands(bool aInterruptible);
38310:   // MaybeScheduleReflow checks if posting a reflow is needed, then checks if
38310:   // the last reflow was interrupted. In the interrupted case ScheduleReflow is
29172:   // called off a timer, otherwise it is called directly.
38310:   void     MaybeScheduleReflow();
38310:   // Actually schedules a reflow.  This should only be called by
38310:   // MaybeScheduleReflow and the reflow timer ScheduleReflowOffTimer
38310:   // sets up.
38310:   void     ScheduleReflow();
    1: 
54649:   // Reflow regardless of whether the override bit has been set.
54649:   nsresult ResizeReflowIgnoreOverride(nscoord aWidth, nscoord aHeight);
54649: 
27993:   // DoReflow returns whether the reflow finished without interruption
79445:   bool DoReflow(nsIFrame* aFrame, bool aInterruptible);
  790: #ifdef DEBUG
  790:   void DoVerifyReflow();
  926:   void VerifyHasDirtyRootAncestor(nsIFrame* aFrame);
  790: #endif
  790: 
27993:   // Helper for ScrollContentIntoView
28165:   void DoScrollContentIntoView(nsIContent* aContent,
93554:                                ScrollAxis  aVertical,
93554:                                ScrollAxis  aHorizontal,
56647:                                PRUint32    aFlags);
27993: 
96420:   /**
96420:    * Initialize cached font inflation preference values.
96420:    *
96420:    * @see nsLayoutUtils::sFontSizeInflationEmPerLine
96420:    * @see nsLayoutUtils::sFontSizeInflationMinTwips
96420:    * @see nsLayoutUtils::sFontSizeInflationLineThreshold
96420:    */
96420:   void SetupFontInflation();
96420: 
54080:   friend struct AutoRenderingStateSaveRestore;
54080:   friend struct RenderingState;
54080: 
54080:   struct RenderingState {
54080:     RenderingState(PresShell* aPresShell) 
54080:       : mRenderFlags(aPresShell->mRenderFlags)
54081:       , mXResolution(aPresShell->mXResolution)
54081:       , mYResolution(aPresShell->mYResolution)
54080:     { }
54080:     PRUint32 mRenderFlags;
54081:     float mXResolution;
54081:     float mYResolution;
54080:   };
54080: 
54080:   struct AutoSaveRestoreRenderingState {
54080:     AutoSaveRestoreRenderingState(PresShell* aPresShell)
54080:       : mPresShell(aPresShell)
54080:       , mOldState(aPresShell)
54080:     {}
54080: 
54080:     ~AutoSaveRestoreRenderingState()
54080:     {
54080:       mPresShell->mRenderFlags = mOldState.mRenderFlags;
54081:       mPresShell->mXResolution = mOldState.mXResolution;
54081:       mPresShell->mYResolution = mOldState.mYResolution;
54080:     }
54080: 
54080:     PresShell* mPresShell;
54080:     RenderingState mOldState;
54080:   };
54080: 
54080:   void SetRenderingState(const RenderingState& aState);
54080: 
    1:   friend class nsPresShellEventCB;
    1: 
79445:   bool mCaretEnabled;
    1: #ifdef NS_DEBUG
72504:   nsStyleSet* CloneStyleSet(nsStyleSet* aSet);
79445:   bool VerifyIncrementalReflow();
79445:   bool mInVerifyReflow;
    1:   void ShowEventTargetDebug();
    1: #endif
    1: 
    1:     /**
    1:     * methods that manage rules that are used to implement the associated preferences
    1:     *  - initially created for bugs 31816, 20760, 22963
    1:     */
    1:   nsresult ClearPreferenceStyleRules(void);
    1:   nsresult CreatePreferenceStyleSheet(void);
    1:   nsresult SetPrefLinkRules(void);
    1:   nsresult SetPrefFocusRules(void);
    1:   nsresult SetPrefNoScriptRule();
    1:   nsresult SetPrefNoFramesRule(void);
    1: 
    1:   // methods for painting a range to an offscreen buffer
    1: 
    1:   // given a display list, clip the items within the list to
    1:   // the range
    1:   nsRect ClipListToRange(nsDisplayListBuilder *aBuilder,
    1:                          nsDisplayList* aList,
86939:                          nsRange* aRange);
    1: 
    1:   // create a RangePaintInfo for the range aRange containing the
    1:   // display list needed to paint the range to a surface
    1:   RangePaintInfo* CreateRangePaintInfo(nsIDOMRange* aRange,
47337:                                        nsRect& aSurfaceRect,
79445:                                        bool aForPrimarySelection);
    1: 
    1:   /*
    1:    * Paint the items to a new surface and return it.
    1:    *
    1:    * aSelection - selection being painted, if any
    1:    * aRegion - clip region, if any
    1:    * aArea - area that the surface occupies, relative to the root frame
    1:    * aPoint - reference point, typically the mouse position
    1:    * aScreenRect - [out] set to the area of the screen the painted area should
    1:    *               be displayed at
    1:    */
    1:   already_AddRefed<gfxASurface>
    1:   PaintRangePaintInfo(nsTArray<nsAutoPtr<RangePaintInfo> >* aItems,
    1:                       nsISelection* aSelection,
43137:                       nsIntRegion* aRegion,
    1:                       nsRect aArea,
23738:                       nsIntPoint& aPoint,
23738:                       nsIntRect* aScreenRect);
    1: 
    1:   /**
    1:    * Methods to handle changes to user and UA sheet lists that we get
    1:    * notified about.
    1:    */
    1:   void AddUserSheet(nsISupports* aSheet);
    1:   void AddAgentSheet(nsISupports* aSheet);
    1:   void RemoveSheet(nsStyleSet::sheetType aType, nsISupports* aSheet);
    1: 
  677:   // Hide a view if it is a popup
  677:   void HideViewIfPopup(nsIView* aView);
  677: 
  824:   // Utility method to restore the root scrollframe state
  824:   void RestoreRootScrollPosition();
  824: 
35522:   void MaybeReleaseCapturingContent()
35522:   {
70097:     nsRefPtr<nsFrameSelection> frameSelection = FrameSelection();
35522:     if (frameSelection) {
80486:       frameSelection->SetMouseDownState(false);
35522:     }
35522:     if (gCaptureInfo.mContent &&
80526:         gCaptureInfo.mContent->OwnerDoc() == mDocument) {
35522:       SetCapturingContent(nsnull, 0);
35522:     }
35522:   }
35522: 
82566:   nsresult HandleRetargetedEvent(nsEvent* aEvent, nsEventStatus* aStatus, nsIContent* aTarget)
62899:   {
62899:     PushCurrentEventInfo(nsnull, nsnull);
62899:     mCurrentEventContent = aTarget;
62899:     nsresult rv = NS_OK;
62899:     if (GetCurrentEventFrame()) {
82566:       rv = HandleEventInternal(aEvent, aStatus);
62899:     }
62899:     PopCurrentEventInfo();
62899:     return rv;
62899:   }
62899: 
42163:   nsRefPtr<nsCSSStyleSheet> mPrefStyleSheet; // mStyleSet owns it but we
10382:                                              // maintain a ref, may be null
    1: #ifdef DEBUG
    1:   PRUint32                  mUpdateCount;
    1: #endif
    1:   // reflow roots that need to be reflowed, as both a queue and a hashtable
24551:   nsTArray<nsIFrame*> mDirtyRoots;
    1: 
79445:   bool mDocumentLoading;
    1: 
79445:   bool mIgnoreFrameDestruction;
79445:   bool mHaveShutDown;
    1: 
79445:   bool mViewportOverridden;
54649: 
79445:   bool mLastRootReflowHadUnconstrainedHeight;
55051: 
29804:   // This is used to protect ourselves from triggering reflow while in the
29804:   // middle of frame construction and the like... it really shouldn't be
29804:   // needed, one hopes, but it is for now.
29804:   PRUint32  mChangeNestCount;
29804:   
    1:   nsIFrame*   mCurrentEventFrame;
    1:   nsCOMPtr<nsIContent> mCurrentEventContent;
24551:   nsTArray<nsIFrame*> mCurrentEventFrameStack;
    1:   nsCOMArray<nsIContent> mCurrentEventContentStack;
    1: 
12356:   nsCOMPtr<nsIContent>          mLastAnchorScrolledTo;
12356:   nscoord                       mLastAnchorScrollPositionY;
15969:   nsRefPtr<nsCaret>             mCaret;
15969:   nsRefPtr<nsCaret>             mOriginalCaret;
31619:   nsPresArena                   mFrameArena;
    1:   StackArena                    mStackArena;
    1:   nsCOMPtr<nsIDragService>      mDragService;
    1:   
27993: #ifdef DEBUG
27993:   // The reflow root under which we're currently reflowing.  Null when
27993:   // not in reflow.
27993:   nsIFrame* mCurrentReflowRoot;
27993: #endif
27993: 
27993:   // Set of frames that we should mark with NS_FRAME_HAS_DIRTY_CHILDREN after
27993:   // we finish reflowing mCurrentReflowRoot.
27993:   nsTHashtable< nsPtrHashKey<nsIFrame> > mFramesToDirty;
27993: 
27993:   // Information needed to properly handle scrolling content into view if the
27993:   // pre-scroll reflow flush can be interrupted.  mContentToScrollTo is
27993:   // non-null between the initial scroll attempt and the first time we finish
67816:   // processing all our dirty roots.  mContentScrollVPosition and
67816:   // mContentScrollHPosition are only used when it's non-null.
27993:   nsCOMPtr<nsIContent> mContentToScrollTo;
93554:   ScrollAxis mContentScrollVAxis;
93554:   ScrollAxis mContentScrollHAxis;
62343:   PRUint32 mContentToScrollToFlags;
27993: 
28498:   class nsDelayedEvent
28498:   {
28498:   public:
28498:     virtual ~nsDelayedEvent() {};
28498:     virtual void Dispatch(PresShell* aShell) {}
28498:   };
28498: 
28498:   class nsDelayedInputEvent : public nsDelayedEvent
28498:   {
28498:   public:
28498:     virtual void Dispatch(PresShell* aShell)
28498:     {
28498:       if (mEvent && mEvent->widget) {
28498:         nsCOMPtr<nsIWidget> w = mEvent->widget;
28498:         nsEventStatus status;
28498:         w->DispatchEvent(mEvent, status);
28498:       }
28498:     }
28498: 
28498:   protected:
28498:     void Init(nsInputEvent* aEvent)
28498:     {
28498:       mEvent->time = aEvent->time;
28498:       mEvent->refPoint = aEvent->refPoint;
28498:       mEvent->isShift = aEvent->isShift;
28498:       mEvent->isControl = aEvent->isControl;
28498:       mEvent->isAlt = aEvent->isAlt;
28498:       mEvent->isMeta = aEvent->isMeta;
28498:     }
28498: 
28498:     nsDelayedInputEvent()
28498:     : nsDelayedEvent(), mEvent(nsnull) {}
28498: 
28498:     nsInputEvent* mEvent;
28498:   };
28498: 
28498:   class nsDelayedMouseEvent : public nsDelayedInputEvent
28498:   {
28498:   public:
28498:     nsDelayedMouseEvent(nsMouseEvent* aEvent) : nsDelayedInputEvent()
28498:     {
28498:       mEvent = new nsMouseEvent(NS_IS_TRUSTED_EVENT(aEvent),
28498:                                 aEvent->message,
28498:                                 aEvent->widget,
28498:                                 aEvent->reason,
28498:                                 aEvent->context);
28498:       Init(aEvent);
28498:       static_cast<nsMouseEvent*>(mEvent)->clickCount = aEvent->clickCount;
28498:     }
28498: 
28498:     virtual ~nsDelayedMouseEvent()
28498:     {
28498:       delete static_cast<nsMouseEvent*>(mEvent);
28498:     }
28498:   };
28498: 
28498:   class nsDelayedKeyEvent : public nsDelayedInputEvent
28498:   {
28498:   public:
28498:     nsDelayedKeyEvent(nsKeyEvent* aEvent) : nsDelayedInputEvent()
28498:     {
28498:       mEvent = new nsKeyEvent(NS_IS_TRUSTED_EVENT(aEvent),
28498:                               aEvent->message,
28498:                               aEvent->widget);
28498:       Init(aEvent);
28498:       static_cast<nsKeyEvent*>(mEvent)->keyCode = aEvent->keyCode;
28498:       static_cast<nsKeyEvent*>(mEvent)->charCode = aEvent->charCode;
28498:       static_cast<nsKeyEvent*>(mEvent)->alternativeCharCodes =
28498:         aEvent->alternativeCharCodes;
28498:       static_cast<nsKeyEvent*>(mEvent)->isChar = aEvent->isChar;
28498:     }
28498: 
28498:     virtual ~nsDelayedKeyEvent()
28498:     {
28498:       delete static_cast<nsKeyEvent*>(mEvent);
28498:     }
28498:   };
28498: 
79445:   bool                                 mNoDelayedMouseEvents;
79445:   bool                                 mNoDelayedKeyEvents;
28498:   nsTArray<nsAutoPtr<nsDelayedEvent> > mDelayedEvents;
25722: 
    1:   nsCallbackEventRequest* mFirstCallbackEventRequest;
    1:   nsCallbackEventRequest* mLastCallbackEventRequest;
    1: 
79445:   bool              mIsDocumentGone;      // We've been disconnected from the document.
    1:                                           // We will refuse to paint the document until either
    1:                                           // (a) our timer fires or (b) all frames are constructed.
79445:   bool              mShouldUnsuppressPainting;  // Indicates that it is safe to unlock painting once all pending
    1:                                                 // reflows have been processed.
    1:   nsCOMPtr<nsITimer> mPaintSuppressionTimer; // This timer controls painting suppression.  Until it fires
    1:                                              // or all frames are constructed, we won't paint anything but
    1:                                              // our <body> background and scrollbars.
    1: #define PAINTLOCK_EVENT_DELAY 250 // 250ms.  This is actually
    1:                                   // pref-controlled, but we use this
    1:                                   // value if we fail to get the pref
    1:                                   // for any reason.
    1: 
    1:   static void sPaintSuppressionCallback(nsITimer* aTimer, void* aPresShell); // A callback for the timer.
    1: 
38310:   // At least on Win32 and Mac after interupting a reflow we need to post
38310:   // the resume reflow event off a timer to avoid event starvation because
38310:   // posted messages are processed before other messages when the modal
38310:   // moving/sizing loop is running, see bug 491700 for details.
29172:   nsCOMPtr<nsITimer> mReflowContinueTimer;
29172:   static void sReflowContinueCallback(nsITimer* aTimer, void* aPresShell);
79445:   bool ScheduleReflowOffTimer();
29172:   
    1: #ifdef MOZ_REFLOW_PERF
    1:   ReflowCountMgr * mReflowCountMgr;
    1: #endif
    1: 
79445:   static bool sDisableNonTestMouseEvents;
24947: 
    1: private:
    1: 
95993: 
95993: #ifdef ANDROID
95993:   nsIDocument* GetTouchEventTargetDocument();
95993: #endif
79445:   bool InZombieDocument(nsIContent *aContent);
47198:   already_AddRefed<nsIPresShell> GetParentPresShell();
    1:   nsresult RetargetEventToParent(nsGUIEvent* aEvent,
    1:                                  nsEventStatus*  aEventStatus);
    1: 
    1:   //helper funcs for event handling
    1: protected:
    1:   //protected because nsPresShellEventCB needs this.
    1:   nsIFrame* GetCurrentEventFrame();
    1: private:
    1:   void PushCurrentEventInfo(nsIFrame* aFrame, nsIContent* aContent);
    1:   void PopCurrentEventInfo();
82566:   nsresult HandleEventInternal(nsEvent* aEvent, nsEventStatus *aStatus);
82566:   nsresult HandlePositionedEvent(nsIFrame*      aTargetFrame,
    1:                                  nsGUIEvent*    aEvent,
    1:                                  nsEventStatus* aEventStatus);
36337:   // This returns the focused DOM window under our top level window.
36337:   //  I.e., when we are deactive, this returns the *last* focused DOM window.
36337:   already_AddRefed<nsPIDOMWindow> GetFocusedDOMWindowInOurWindow();
    1: 
23881:   /*
23881:    * This and the next two helper methods are used to target and position the
23881:    * context menu when the keyboard shortcut is used to open it.
23881:    *
23881:    * If another menu is open, the context menu is opened relative to the
23881:    * active menuitem within the menu, or the menu itself if no item is active.
23881:    * Otherwise, if the caret is visible, the menu is opened near the caret.
23881:    * Otherwise, if a selectable list such as a listbox is focused, the
23881:    * current item within the menu is opened relative to this item.
23881:    * Otherwise, the context menu is opened at the topleft corner of the
23881:    * view.
23881:    *
23881:    * Returns true if the context menu event should fire and false if it should
23881:    * not.
23881:    */
79445:   bool AdjustContextMenuKeyEvent(nsMouseEvent* aEvent);
23881: 
23881:   // 
79445:   bool PrepareToUseCaretPosition(nsIWidget* aEventWidget, nsIntPoint& aTargetPt);
23881: 
23881:   // Get the selected item and coordinates in device pixels relative to root
30534:   // document's root view for element, first ensuring the element is onscreen
23881:   void GetCurrentItemAndPositionForElement(nsIDOMElement *aCurrentEl,
23881:                                            nsIContent **aTargetToUse,
47902:                                            nsIntPoint& aTargetPt,
47902:                                            nsIWidget *aRootWidget);
23881: 
    1:   void FireResizeEvent();
57661:   void FireBeforeResizeEvent();
31584:   static void AsyncResizeEventCallback(nsITimer* aTimer, void* aPresShell);
23685:   nsRevocableEventPtr<nsRunnableMethod<PresShell> > mResizeEvent;
31584:   nsCOMPtr<nsITimer> mAsyncResizeEventTimer;
79445:   bool mAsyncResizeTimerIsActive;
79445:   bool mInResize;
    1: 
79445:   virtual void SynthesizeMouseMove(bool aFromScroll);
69702: 
69702:   // Check if aEvent is a mouse event and record the mouse location for later
69702:   // synth mouse moves.
69702:   void RecordMouseLocation(nsGUIEvent* aEvent);
69702:   // This is used for synthetic mouse events that are sent when what is under
69702:   // the mouse pointer may have changed without the mouse moving (eg scrolling,
69702:   // change to the document contents).
69702:   // It is set only on a presshell for a root document, this value represents
69702:   // the last observed location of the mouse relative to that root document. It
69702:   // is set to (NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE) if the mouse isn't
69702:   // over our window or there is no last observed mouse location for some
69702:   // reason.
69702:   nsPoint mMouseLocation;
87190:   class nsSynthMouseMoveEvent : public nsARefreshObserver {
69702:   public:
79445:     nsSynthMouseMoveEvent(PresShell* aPresShell, bool aFromScroll)
69702:       : mPresShell(aPresShell), mFromScroll(aFromScroll) {
69702:       NS_ASSERTION(mPresShell, "null parameter");
69702:     }
87190:     ~nsSynthMouseMoveEvent() {
87190:       Revoke();
87190:     }
87190: 
87190:     NS_INLINE_DECL_REFCOUNTING(nsSynthMouseMoveEvent)
87190:     
87190:     void Revoke() {
87190:       if (mPresShell) {
87190:         mPresShell->GetPresContext()->RefreshDriver()->
87190:           RemoveRefreshObserver(this, Flush_Display);
87190:         mPresShell = nsnull;
87190:       }
87190:     }
87190:     virtual void WillRefresh(mozilla::TimeStamp aTime) {
69702:       if (mPresShell)
69702:         mPresShell->ProcessSynthMouseMoveEvent(mFromScroll);
69702:     }
69702:   private:
69702:     PresShell* mPresShell;
79445:     bool mFromScroll;
69702:   };
69702:   nsRevocableEventPtr<nsSynthMouseMoveEvent> mSynthMouseMoveEvent;
79445:   void ProcessSynthMouseMoveEvent(bool aFromScroll);
69702: 
69702:   PresShell* GetRootPresShell();
69702: 
29987: private:
32511: #ifdef DEBUG
32511:   // Ensure that every allocation from the PresArena is eventually freed.
32511:   PRUint32 mPresArenaAllocCount;
32511: #endif
42982: 
42982: public:
42982: 
91413:   void SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf,
91413:                            size_t *aArenasSize,
91413:                            size_t *aStyleSetsSize,
91413:                            size_t *aTextRunsSize) const;
91413:   size_t SizeOfTextRuns(nsMallocSizeOfFun aMallocSizeOf) const;
74692: 
48937: protected:
48937:   void QueryIsActive();
50815:   nsresult UpdateImageLockingState();
78004: 
78004: private:
78004:   nscolor GetDefaultBackgroundColorToDraw();
    1: };
    1: 
78155: #endif /* !defined(nsPresShell_h_) */
