 29018: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 29018: 
 73590: #include "mozilla/dom/TabParent.h"
 73590: 
 29018: #include "nsFocusManager.h"
 29018: 
 29018: #include "nsIInterfaceRequestor.h"
 29018: #include "nsIInterfaceRequestorUtils.h"
 29018: #include "nsIServiceManager.h"
 29018: #include "nsIEnumerator.h"
 29018: #include "nsGkAtoms.h"
 29018: #include "nsContentUtils.h"
 29018: #include "nsIDocument.h"
 29018: #include "nsIDOMWindow.h"
 29018: #include "nsPIDOMWindow.h"
 29018: #include "nsIDOMElement.h"
 29018: #include "nsIDOMXULElement.h"
 80402: #include "nsIDOMHTMLFrameElement.h"
 29018: #include "nsIDOMHTMLInputElement.h"
 29018: #include "nsIDOMHTMLMapElement.h"
 29018: #include "nsIDOMHTMLLegendElement.h"
 69898: #include "nsIDOMDocument.h"
 29018: #include "nsIDOMRange.h"
 29018: #include "nsIHTMLDocument.h"
 29018: #include "nsIFormControlFrame.h"
 29018: #include "nsGenericHTMLElement.h"
 29018: #include "nsIDocShell.h"
 29018: #include "nsIEditorDocShell.h"
 29018: #include "nsIDocShellTreeItem.h"
 29018: #include "nsIDocShellTreeOwner.h"
 29018: #include "nsLayoutUtils.h"
 29018: #include "nsIPresShell.h"
 29018: #include "nsIContentViewer.h"
 29018: #include "nsFrameTraversal.h"
 29018: #include "nsObjectFrame.h"
 29018: #include "nsEventDispatcher.h"
 68780: #include "nsEventStateManager.h"
 29018: #include "nsIMEStateManager.h"
 29018: #include "nsIWebNavigation.h"
 29018: #include "nsCaret.h"
 29018: #include "nsIBaseWindow.h"
 29018: #include "nsIViewManager.h"
 29018: #include "nsFrameSelection.h"
101616: #include "mozilla/Selection.h"
 29018: #include "nsXULPopupManager.h"
 35170: #include "nsIDOMNodeFilter.h"
 41239: #include "nsIScriptObjectPrincipal.h"
 41239: #include "nsIPrincipal.h"
101135: #include "mozAutoDocUpdate.h"
101135: #include "nsFrameLoader.h"
101135: #include "nsIObserverService.h"
101135: #include "nsIScriptError.h"
101135: 
 41930: #include "mozilla/dom/Element.h"
101135: #include "mozilla/LookAndFeel.h"
 70840: #include "mozilla/Preferences.h"
 29018: 
 29018: #ifdef MOZ_XUL
 29018: #include "nsIDOMXULTextboxElement.h"
 29018: #include "nsIDOMXULMenuListElement.h"
 29018: #endif
 29018: 
 79384: #ifdef ACCESSIBILITY
 79384: #include "nsAccessibilityService.h"
 79384: #endif
 79384: 
 70840: using namespace mozilla;
 41634: using namespace mozilla::dom;
 82840: using namespace mozilla::widget;
 41634: 
 29018: //#define DEBUG_FOCUS 1
 29018: //#define DEBUG_FOCUS_NAVIGATION 1
 29018: #define PRINTTAGF(format, content)                     \
 29018:   {                                                    \
 29018:     nsAutoString tag(NS_LITERAL_STRING("(none)"));     \
 29018:     if (content)                                       \
 29018:       content->Tag()->ToString(tag);                   \
 29018:     printf(format, NS_ConvertUTF16toUTF8(tag).get());  \
 29018:   }
 29018: 
 29018: struct nsDelayedBlurOrFocusEvent
 29018: {
 29018:   nsDelayedBlurOrFocusEvent(PRUint32 aType,
 29018:                             nsIPresShell* aPresShell,
 29018:                             nsIDocument* aDocument,
 72326:                             nsIDOMEventTarget* aTarget)
 29018:    : mType(aType),
 29018:      mPresShell(aPresShell),
 29018:      mDocument(aDocument),
 29018:      mTarget(aTarget) { }
 29018: 
 29018:   nsDelayedBlurOrFocusEvent(const nsDelayedBlurOrFocusEvent& aOther)
 29018:    : mType(aOther.mType),
 29018:      mPresShell(aOther.mPresShell),
 29018:      mDocument(aOther.mDocument),
 29018:      mTarget(aOther.mTarget) { }
 29018: 
 29018:   PRUint32 mType;
 29018:   nsCOMPtr<nsIPresShell> mPresShell;
 29018:   nsCOMPtr<nsIDocument> mDocument;
 72326:   nsCOMPtr<nsIDOMEventTarget> mTarget;
 29018: };
 29018: 
 29018: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsFocusManager)
 29018:   NS_INTERFACE_MAP_ENTRY(nsIFocusManager)
 29018:   NS_INTERFACE_MAP_ENTRY(nsIObserver)
 29018:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
 29018:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIFocusManager)
 29018: NS_INTERFACE_MAP_END
 29018: 
 29018: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsFocusManager)
 29018: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsFocusManager)
 29018: 
 29018: NS_IMPL_CYCLE_COLLECTION_CLASS(nsFocusManager)
 29018: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsFocusManager)
 29018:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mActiveWindow)
 29018:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mFocusedWindow)
 29018:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mFocusedContent)
 29018:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mFirstBlurEvent)
 29018:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mFirstFocusEvent)
 29018:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mWindowBeingLowered)
 29018: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 29018: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsFocusManager)
 29018:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mActiveWindow)
 29018:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFocusedWindow)
 29018:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFocusedContent)
 29018:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFirstBlurEvent)
 29018:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFirstFocusEvent)
 29018:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mWindowBeingLowered)
 29018: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 29018: 
 31541: nsFocusManager* nsFocusManager::sInstance = nsnull;
 79445: bool nsFocusManager::sMouseFocusesFormControl = false;
 87215: bool nsFocusManager::sTestMode = false;
 29018: 
 71000: static const char* kObservedPrefs[] = {
 71000:   "accessibility.browsewithcaret",
 71000:   "accessibility.tabfocus_applies_to_xul",
 71000:   "accessibility.mouse_focuses_formcontrol",
 87215:   "focusmanager.testmode",
 71000:   NULL
 71000: };
 71000: 
 29018: nsFocusManager::nsFocusManager()
 29018: { }
 29018: 
 29018: nsFocusManager::~nsFocusManager()
 29018: {
 71000:   Preferences::RemoveObservers(this, kObservedPrefs);
 59509: 
 59509:   nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
 59509:   if (obs) {
 59509:     obs->RemoveObserver(this, "xpcom-shutdown");
 59509:   }
 29018: }
 29018: 
 29018: // static
 29018: nsresult
 29018: nsFocusManager::Init()
 29018: {
 29018:   nsFocusManager* fm = new nsFocusManager();
 29018:   NS_ENSURE_TRUE(fm, NS_ERROR_OUT_OF_MEMORY);
 29018:   NS_ADDREF(fm);
 29018:   sInstance = fm;
 29018: 
 29018:   nsIContent::sTabFocusModelAppliesToXUL =
 70840:     Preferences::GetBool("accessibility.tabfocus_applies_to_xul",
 29018:                          nsIContent::sTabFocusModelAppliesToXUL);
 29018: 
 49216:   sMouseFocusesFormControl =
 79445:     Preferences::GetBool("accessibility.mouse_focuses_formcontrol", false);
 49216: 
 87215:   sTestMode = Preferences::GetBool("focusmanager.testmode", false);
 87215: 
 71000:   Preferences::AddWeakObservers(fm, kObservedPrefs);
 29018: 
 59509:   nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
 59509:   if (obs) {
 80486:     obs->AddObserver(fm, "xpcom-shutdown", true);
 59509:   }
 59509: 
 29018:   return NS_OK;
 29018: }
 29018: 
 29018: // static
 29018: void
 29018: nsFocusManager::Shutdown()
 29018: {
 29018:   NS_IF_RELEASE(sInstance);
 29018: }
 29018: 
 29018: NS_IMETHODIMP
 29018: nsFocusManager::Observe(nsISupports *aSubject,
 29018:                         const char *aTopic,
 29018:                         const PRUnichar *aData)
 29018: {
 59509:   if (!nsCRT::strcmp(aTopic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID)) {
 29018:     nsDependentString data(aData);
 29018:     if (data.EqualsLiteral("accessibility.browsewithcaret")) {
 80486:       UpdateCaret(false, true, mFocusedContent);
 29018:     }
 29018:     else if (data.EqualsLiteral("accessibility.tabfocus_applies_to_xul")) {
 29018:       nsIContent::sTabFocusModelAppliesToXUL =
 70840:         Preferences::GetBool("accessibility.tabfocus_applies_to_xul",
 29018:                              nsIContent::sTabFocusModelAppliesToXUL);
 29018:     }
 49216:     else if (data.EqualsLiteral("accessibility.mouse_focuses_formcontrol")) {
 49216:       sMouseFocusesFormControl =
 70840:         Preferences::GetBool("accessibility.mouse_focuses_formcontrol",
 79445:                              false);
 49216:     }
 87215:     else if (data.EqualsLiteral("focusmanager.testmode")) {
 87215:       sTestMode = Preferences::GetBool("focusmanager.testmode", false);
 87215:     }
 59509:   } else if (!nsCRT::strcmp(aTopic, "xpcom-shutdown")) {
 59509:     mActiveWindow = nsnull;
 59509:     mFocusedWindow = nsnull;
 59509:     mFocusedContent = nsnull;
 59509:     mFirstBlurEvent = nsnull;
 59509:     mFirstFocusEvent = nsnull;
 59509:     mWindowBeingLowered = nsnull;
 71960:     mDelayedBlurFocusEvents.Clear();
 59509:     mMouseDownEventHandlingDocument = nsnull;
 29018:   }
 29018: 
 29018:   return NS_OK;
 29018: }
 29018: 
 29018: // given a frame content node, retrieve the nsIDOMWindow displayed in it 
 29018: static nsPIDOMWindow*
 29018: GetContentWindow(nsIContent* aContent)
 29018: {
 29018:   nsIDocument* doc = aContent->GetCurrentDoc();
 29018:   if (doc) {
 29018:     nsIDocument* subdoc = doc->GetSubDocumentFor(aContent);
 29018:     if (subdoc)
 29018:       return subdoc->GetWindow();
 29018:   }
 29018: 
 29018:   return nsnull;
 29018: }
 29018: 
 29018: // get the current window for the given content node 
 29018: static nsPIDOMWindow*
 29018: GetCurrentWindow(nsIContent* aContent)
 29018: {
 29018:   nsIDocument *doc = aContent->GetCurrentDoc();
 29018:   return doc ? doc->GetWindow() : nsnull;
 29018: }
 29018: 
 29018: // static
 29018: nsIContent*
 79445: nsFocusManager::GetFocusedDescendant(nsPIDOMWindow* aWindow, bool aDeep,
 29018:                                      nsPIDOMWindow** aFocusedWindow)
 29018: {
 29018:   NS_ENSURE_TRUE(aWindow, nsnull);
 29018: 
 29018:   *aFocusedWindow = nsnull;
 29018: 
 29018:   nsIContent* currentContent = nsnull;
 29018:   nsPIDOMWindow* window = aWindow->GetOuterWindow();
 29018:   while (window) {
 29018:     *aFocusedWindow = window;
 29018:     currentContent = window->GetFocusedNode();
 29018:     if (!currentContent || !aDeep)
 29018:       break;
 29018: 
 29018:     window = GetContentWindow(currentContent);
 29018:   }
 29018: 
 29018:   NS_IF_ADDREF(*aFocusedWindow);
 29018: 
 29018:   return currentContent;
 29018: }
 29018: 
 29018: // static
 29018: nsIContent*
 29018: nsFocusManager::GetRedirectedFocus(nsIContent* aContent)
 29018: {
 29018: #ifdef MOZ_XUL
 33329:   if (aContent->IsXUL()) {
 29018:     nsCOMPtr<nsIDOMNode> inputField;
 29018: 
 29018:     nsCOMPtr<nsIDOMXULTextBoxElement> textbox = do_QueryInterface(aContent);
 29018:     if (textbox) {
 29018:       textbox->GetInputField(getter_AddRefs(inputField));
 29018:     }
 29018:     else {
 29018:       nsCOMPtr<nsIDOMXULMenuListElement> menulist = do_QueryInterface(aContent);
 29018:       if (menulist) {
 29018:         menulist->GetInputField(getter_AddRefs(inputField));
 29018:       }
 29018:       else if (aContent->Tag() == nsGkAtoms::scale) {
 29018:         nsCOMPtr<nsIDocument> doc = aContent->GetCurrentDoc();
 29018:         if (!doc)
 29018:           return nsnull;
 29018: 
 29018:         nsINodeList* children = doc->BindingManager()->GetXBLChildNodesFor(aContent);
 29018:         if (children) {
 29018:           nsIContent* child = children->GetNodeAt(0);
 29018:           if (child && child->Tag() == nsGkAtoms::slider)
 29018:             return child;
 29018:         }
 29018:       }
 29018:     }
 29018: 
 29018:     if (inputField) {
 29018:       nsCOMPtr<nsIContent> retval = do_QueryInterface(inputField);
 29018:       return retval;
 29018:     }
 29018:   }
 29018: #endif
 29018: 
 29018:   return nsnull;
 29018: }
 29018: 
 68713: // static
 82841: InputContextAction::Cause
 82841: nsFocusManager::GetFocusMoveActionCause(PRUint32 aFlags)
 68713: {
 68713:   if (aFlags & nsIFocusManager::FLAG_BYMOUSE) {
 82841:     return InputContextAction::CAUSE_MOUSE;
 68713:   } else if (aFlags & nsIFocusManager::FLAG_BYKEY) {
 82841:     return InputContextAction::CAUSE_KEY;
 82841:   }
 82841:   return InputContextAction::CAUSE_UNKNOWN;
 68713: }
 68713: 
 29018: NS_IMETHODIMP
 29018: nsFocusManager::GetActiveWindow(nsIDOMWindow** aWindow)
 29018: {
 29018:   NS_IF_ADDREF(*aWindow = mActiveWindow);
 29018:   return NS_OK;
 29018: }
 29018: 
 29018: NS_IMETHODIMP
 29018: nsFocusManager::SetActiveWindow(nsIDOMWindow* aWindow)
 29018: {
 29018:   // only top-level windows can be made active
 29018:   nsCOMPtr<nsPIDOMWindow> piWindow = do_QueryInterface(aWindow);
 55579:   if (piWindow)
 55579:       piWindow = piWindow->GetOuterWindow();
 29018: 
 29018:   NS_ENSURE_TRUE(piWindow && (piWindow == piWindow->GetPrivateRoot()),
 29018:                  NS_ERROR_INVALID_ARG);
 29018: 
 29018:   RaiseWindow(piWindow);
 29018:   return NS_OK;
 29018: }
 29018: 
 29018: NS_IMETHODIMP
 29018: nsFocusManager::GetFocusedWindow(nsIDOMWindow** aFocusedWindow)
 29018: {
 29018:   NS_IF_ADDREF(*aFocusedWindow = mFocusedWindow);
 29018:   return NS_OK;
 29018: }
 29018: 
 29018: NS_IMETHODIMP nsFocusManager::SetFocusedWindow(nsIDOMWindow* aWindowToFocus)
 29018: {
 29018: #ifdef DEBUG_FOCUS
 29018:   printf("<<SetFocusedWindow begin>>\n");
 29018: #endif
 29018: 
 29018:   nsCOMPtr<nsPIDOMWindow> windowToFocus(do_QueryInterface(aWindowToFocus));
 29018:   NS_ENSURE_TRUE(windowToFocus, NS_ERROR_FAILURE);
 29018: 
 29018:   windowToFocus = windowToFocus->GetOuterWindow();
 29018: 
 29018:   nsCOMPtr<nsIContent> frameContent =
 29018:     do_QueryInterface(windowToFocus->GetFrameElementInternal());
 29018:   if (frameContent) {
 57526:     // pass false for aFocusChanged so that the caret does not get updated
 57526:     // and scrolling does not occur.
 80486:     SetFocusInner(frameContent, 0, false, true);
 29018:   }
 29018:   else {
 29018:     // this is a top-level window. If the window has a child frame focused,
 29018:     // clear the focus. Otherwise, focus should already be in this frame, or
 29018:     // already cleared. This ensures that focus will be in this frame and not
 29018:     // in a child.
 29018:     nsIContent* content = windowToFocus->GetFocusedNode();
 29018:     if (content) {
 29018:       nsCOMPtr<nsIDOMWindow> childWindow = GetContentWindow(content);
 29018:       if (childWindow)
 41071:         ClearFocus(windowToFocus);
 29018:     }
 29018:   }
 29018: 
 29018:   nsCOMPtr<nsPIDOMWindow> rootWindow = windowToFocus->GetPrivateRoot();
 29018:   if (rootWindow)
 29018:     RaiseWindow(rootWindow);
 29018: 
 29018: #ifdef DEBUG_FOCUS
 29018:   printf("<<SetFocusedWindow end>>\n");
 29018: #endif
 29018: 
 29018:   return NS_OK;
 29018: }
 29018: 
 29018: NS_IMETHODIMP
 29018: nsFocusManager::GetFocusedElement(nsIDOMElement** aFocusedElement)
 29018: {
 29018:   if (mFocusedContent)
 29018:     CallQueryInterface(mFocusedContent, aFocusedElement);
 29018:   else
 29018:     *aFocusedElement = nsnull;
 29018:   return NS_OK;
 29018: }
 29018: 
 29018: NS_IMETHODIMP
 29018: nsFocusManager::GetLastFocusMethod(nsIDOMWindow* aWindow, PRUint32* aLastFocusMethod)
 29018: {
 29018:   // the focus method is stored on the inner window
 29018:   nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(aWindow));
 29018:   if (window)
 29018:     window = window->GetCurrentInnerWindow();
 29018:   if (!window)
 29018:     window = mFocusedWindow;
 29018: 
 29018:   *aLastFocusMethod = window ? window->GetFocusMethod() : 0;
 29018: 
 29018:   NS_ASSERTION((*aLastFocusMethod & FOCUSMETHOD_MASK) == *aLastFocusMethod,
 29018:                "invalid focus method");
 29018:   return NS_OK;
 29018: }
 29018: 
 29018: NS_IMETHODIMP
 29018: nsFocusManager::SetFocus(nsIDOMElement* aElement, PRUint32 aFlags)
 29018: {
 29018: #ifdef DEBUG_FOCUS
 29018:   printf("<<SetFocus>>\n");
 29018: #endif
 29018: 
 29018:   nsCOMPtr<nsIContent> newFocus = do_QueryInterface(aElement);
 29018:   NS_ENSURE_ARG(newFocus);
 29018: 
 80486:   SetFocusInner(newFocus, aFlags, true, true);
 29018: 
 29018:   return NS_OK;
 29018: }
 29018: 
 29018: NS_IMETHODIMP
 82128: nsFocusManager::ElementIsFocusable(nsIDOMElement* aElement, PRUint32 aFlags,
 82128:                                    bool* aIsFocusable)
 82128: {
 82128:   NS_ENSURE_TRUE(aElement, NS_ERROR_INVALID_ARG);
 82128: 
 82128:   nsCOMPtr<nsIContent> aContent = do_QueryInterface(aElement);
 82128: 
 82128:   *aIsFocusable = CheckIfFocusable(aContent, aFlags) != nsnull;
 82128: 
 82128:   return NS_OK;
 82128: }
 82128: 
 82128: NS_IMETHODIMP
 29018: nsFocusManager::MoveFocus(nsIDOMWindow* aWindow, nsIDOMElement* aStartElement,
 29018:                           PRUint32 aType, PRUint32 aFlags, nsIDOMElement** aElement)
 29018: {
 29018:   *aElement = nsnull;
 29018: 
 29018: #ifdef DEBUG_FOCUS
 41071:   printf("<<MoveFocus Type: %d Flags: %x>>\n<<", aType, aFlags);
 29018: 
 29018:   nsCOMPtr<nsPIDOMWindow> focusedWindow = mFocusedWindow;
 29018:   if (focusedWindow) {
 29018:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(focusedWindow->GetExtantDocument());
 29018:     if (doc) {
 29018:       nsCAutoString spec;
 29018:       doc->GetDocumentURI()->GetSpec(spec);
 29018:       printf(" [%p] Focused Window: %s", mFocusedWindow.get(), spec.get());
 29018:     }
 29018:   }
 29018:   PRINTTAGF(">> $[[%s]]\n", mFocusedContent);
 29018: #endif
 29018: 
 31988:   // use FLAG_BYMOVEFOCUS when switching focus with MoveFocus unless one of
 31988:   // the other focus methods is already set, or we're just moving to the root
 31988:   // or caret position.
 31988:   if (aType != MOVEFOCUS_ROOT && aType != MOVEFOCUS_CARET &&
 31988:       (aFlags & FOCUSMETHOD_MASK) == 0) {
 31988:     aFlags |= FLAG_BYMOVEFOCUS;
 31988:   }
 31988: 
 29018:   nsCOMPtr<nsPIDOMWindow> window;
 29018:   nsCOMPtr<nsIContent> startContent;
 29018:   if (aStartElement) {
 29018:     startContent = do_QueryInterface(aStartElement);
 29018:     NS_ENSURE_TRUE(startContent, NS_ERROR_INVALID_ARG);
 29018: 
 29018:     window = GetCurrentWindow(startContent);
 29018:   }
 29018:   else {
 29018:     window = aWindow ? do_QueryInterface(aWindow) : mFocusedWindow;
 29018:     NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
 29018:     window = window->GetOuterWindow();
 29018:   }
 29018: 
 29018:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
 29018: 
 90009:   bool noParentTraversal = aFlags & FLAG_NOPARENTFRAME;
 29018:   nsCOMPtr<nsIContent> newFocus;
 90009:   nsresult rv = DetermineElementToMoveFocus(window, startContent, aType, noParentTraversal,
 29018:                                             getter_AddRefs(newFocus));
 29018:   NS_ENSURE_SUCCESS(rv, rv);
 29018: 
 29018: #ifdef DEBUG_FOCUS_NAVIGATION
 29018:   PRINTTAGF("-> Element to be focused: %s\n", newFocus);
 29018: #endif
 29018: 
 29018:   if (newFocus) {
 29018:     // for caret movement, pass false for the aFocusChanged argument,
 29018:     // otherwise the caret will end up moving to the focus position. This
 29018:     // would be a problem because the caret would move to the beginning of the
 29018:     // focused link making it impossible to navigate the caret over a link.
 80486:     SetFocusInner(newFocus, aFlags, aType != MOVEFOCUS_CARET, true);
 29018:     CallQueryInterface(newFocus, aElement);
 29018:   }
 29018:   else if (aType == MOVEFOCUS_ROOT || aType == MOVEFOCUS_CARET) {
 29018:     // no content was found, so clear the focus for these two types.
 29018:     ClearFocus(window);
 29018:   }
 29018: 
 29018: #ifdef DEBUG_FOCUS
 29018:   printf("<<MoveFocus end>>\n");
 29018: #endif
 29018: 
 29018:   return NS_OK;
 29018: }
 29018: 
 29018: NS_IMETHODIMP
 29018: nsFocusManager::ClearFocus(nsIDOMWindow* aWindow)
 29018: {
 29018: #ifdef DEBUG_FOCUS
 29018:   printf("<<ClearFocus begin>>\n");
 29018: #endif
 29018: 
 29018:   // if the window to clear is the focused window or an ancestor of the
 29018:   // focused window, then blur the existing focused content. Otherwise, the
 29018:   // focus is somewhere else so just update the current node.
 29018:   nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(aWindow));
 29018:   NS_ENSURE_TRUE(window, NS_ERROR_INVALID_ARG);
 29018: 
 29018:   window = window->GetOuterWindow();
 29018:   NS_ENSURE_TRUE(window, NS_ERROR_INVALID_ARG);
 29018: 
 29018:   if (IsSameOrAncestor(window, mFocusedWindow)) {
 79445:     bool isAncestor = (window != mFocusedWindow);
 80486:     if (Blur(window, nsnull, isAncestor, true)) {
 29018:       // if we are clearing the focus on an ancestor of the focused window,
 29018:       // the ancestor will become the new focused window, so focus it
 29018:       if (isAncestor)
 80486:         Focus(window, nsnull, 0, true, false, false, true);
 29018:     }
 29018:   }
 29018:   else {
 29018:     window->SetFocusedNode(nsnull);
 29018:   }
 29018: 
 29018: #ifdef DEBUG_FOCUS
 29018:   printf("<<ClearFocus end>>\n");
 29018: #endif
 29018: 
 29018:   return NS_OK;
 29018: }
 29018: 
 29018: NS_IMETHODIMP
 29018: nsFocusManager::GetFocusedElementForWindow(nsIDOMWindow* aWindow,
 79445:                                            bool aDeep,
 29018:                                            nsIDOMWindow** aFocusedWindow,
 29018:                                            nsIDOMElement** aElement)
 29018: {
 29018:   *aElement = nsnull;
 29018:   if (aFocusedWindow)
 29018:     *aFocusedWindow = nsnull;
 29018: 
 29018:   nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(aWindow));
 29018:   NS_ENSURE_TRUE(window, NS_ERROR_INVALID_ARG);
 29018: 
 29018:   window = window->GetOuterWindow();
 29018:   NS_ENSURE_TRUE(window, NS_ERROR_INVALID_ARG);
 29018: 
 29018:   nsCOMPtr<nsPIDOMWindow> focusedWindow;
 29018:   nsCOMPtr<nsIContent> focusedContent =
 29018:     GetFocusedDescendant(window, aDeep, getter_AddRefs(focusedWindow));
 29018:   if (focusedContent)
 29018:     CallQueryInterface(focusedContent, aElement);
 29018: 
 29018:   if (aFocusedWindow)
 29018:     NS_IF_ADDREF(*aFocusedWindow = focusedWindow);
 29018: 
 29018:   return NS_OK;
 29018: }
 29018: 
 29018: NS_IMETHODIMP
 29018: nsFocusManager::MoveCaretToFocus(nsIDOMWindow* aWindow)
 29018: {
 29018:   PRInt32 itemType = nsIDocShellTreeItem::typeChrome;
 29018: 
 29018:   nsCOMPtr<nsIWebNavigation> webnav = do_GetInterface(aWindow);
 29018:   nsCOMPtr<nsIDocShellTreeItem> dsti = do_QueryInterface(webnav);
 29018:   if (dsti) {
 29018:     dsti->GetItemType(&itemType);
 29018:     if (itemType != nsIDocShellTreeItem::typeChrome) {
 29018:       // don't move the caret for editable documents
 29018:       nsCOMPtr<nsIEditorDocShell> editorDocShell(do_QueryInterface(dsti));
 29018:       if (editorDocShell) {
 79445:         bool isEditable;
 29018:         editorDocShell->GetEditable(&isEditable);
 29018:         if (isEditable)
 29018:           return NS_OK;
 29018:       }
 29018: 
 29018:       nsCOMPtr<nsIDocShell> docShell = do_QueryInterface(dsti);
 29018:       NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
 29018: 
 29018:       nsCOMPtr<nsIPresShell> presShell;
 29018:       docShell->GetPresShell(getter_AddRefs(presShell));
 29018:       NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
 29018: 
 29018:       nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(aWindow));
 29018:       nsCOMPtr<nsIContent> content = window->GetFocusedNode();
 29018:       if (content)
 29018:         MoveCaretToFocus(presShell, content);
 29018:     }
 29018:   }
 29018: 
 29018:   return NS_OK;
 29018: }
 29018: 
 29018: NS_IMETHODIMP
 29018: nsFocusManager::WindowRaised(nsIDOMWindow* aWindow)
 29018: {
 29018:   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(aWindow);
 29018:   NS_ENSURE_TRUE(window && window->IsOuterWindow(), NS_ERROR_INVALID_ARG);
 29018: 
 29018: #ifdef DEBUG_FOCUS
 29018:   printf("Window %p Raised [Currently: %p %p] <<", aWindow, mActiveWindow.get(), mFocusedWindow.get());
 29018:   nsCAutoString spec;
 29018:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(window->GetExtantDocument());
 29018:   if (doc) {
 29018:     doc->GetDocumentURI()->GetSpec(spec);
 29018:     printf("[%p] Raised Window: %s", aWindow, spec.get());
 29018:   }
 29018:   if (mActiveWindow) {
 29018:     doc = do_QueryInterface(mActiveWindow->GetExtantDocument());
 29018:     if (doc) {
 29018:       doc->GetDocumentURI()->GetSpec(spec);
 29018:       printf(" [%p] Active Window: %s", mActiveWindow.get(), spec.get());
 29018:     }
 29018:   }
 29018:   printf(">>\n");
 29018: #endif
 29018: 
 29018:   if (mActiveWindow == window) {
 29018:     // The window is already active, so there is no need to focus anything,
 29018:     // but make sure that the right widget is focused. This is a special case
 29018:     // for Windows because when restoring a minimized window, a second
 29018:     // activation will occur and the top-level widget could be focused instead
 29018:     // of the child we want. We solve this by calling SetFocus to ensure that
 29018:     // what the focus manager thinks should be the current widget is actually
 29018:     // focused.
 29018:     EnsureCurrentWidgetFocused();
 29018:     return NS_OK;
 29018:   }
 29018: 
 29018:   // lower the existing window, if any. This shouldn't happen usually.
 29018:   if (mActiveWindow)
 29018:     WindowLowered(mActiveWindow);
 29018: 
 29018:   nsCOMPtr<nsIWebNavigation> webnav(do_GetInterface(aWindow));
 29018:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(webnav));
 29018:   // If there's no docShellAsItem, this window must have been closed,
 29018:   // in that case there is no tree owner.
 29018:   NS_ENSURE_TRUE(docShellAsItem, NS_OK);
 29018: 
 29018:   // set this as the active window
 29018:   mActiveWindow = window;
 29018: 
 29018:   // ensure that the window is enabled and visible
 29018:   nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
 29018:   docShellAsItem->GetTreeOwner(getter_AddRefs(treeOwner));
 29018:   nsCOMPtr<nsIBaseWindow> baseWindow = do_QueryInterface(treeOwner);
 29018:   if (baseWindow) {
 79445:     bool isEnabled = true;
 29018:     if (NS_SUCCEEDED(baseWindow->GetEnabled(&isEnabled)) && !isEnabled) {
 29018:       return NS_ERROR_FAILURE;
 29018:     }
 29018: 
 80486:     baseWindow->SetVisibility(true);
 29018:   }
 29018: 
 29018:   // inform the DOM window that it has activated, so that the active attribute
 29018:   // is updated on the window
 80486:   window->ActivateOrDeactivate(true);
 29018: 
 34280:   // send activate event
 34280:   nsCOMPtr<nsIDocument> document = do_QueryInterface(window->GetExtantDocument());
 34280:   nsContentUtils::DispatchTrustedEvent(document,
 34280:                                        window,
 34280:                                        NS_LITERAL_STRING("activate"),
 80486:                                        true, true, nsnull);
 34280: 
 29018:   // retrieve the last focused element within the window that was raised
 29018:   nsCOMPtr<nsPIDOMWindow> currentWindow;
 29018:   nsCOMPtr<nsIContent> currentFocus =
 80486:     GetFocusedDescendant(window, true, getter_AddRefs(currentWindow));
 29018: 
 29018:   NS_ASSERTION(currentWindow, "window raised with no window current");
 29018:   if (!currentWindow)
 29018:     return NS_OK;
 29018: 
 29018:   nsCOMPtr<nsIDocShell> currentDocShell = currentWindow->GetDocShell();
 29018: 
 29018:   nsCOMPtr<nsIPresShell> presShell;
 29018:   currentDocShell->GetPresShell(getter_AddRefs(presShell));
 29018:   if (presShell) {
 29018:     // disable selection mousedown state on activation
 29018:     // XXXndeakin P3 not sure if this is necessary, but it doesn't hurt
 70097:     nsRefPtr<nsFrameSelection> frameSelection = presShell->FrameSelection();
 80486:     frameSelection->SetMouseDownState(false);
 80486:   }
 80486: 
 80486:   Focus(currentWindow, currentFocus, 0, true, false, true, true);
 29018: 
 29018:   return NS_OK;
 29018: }
 29018: 
 29018: NS_IMETHODIMP
 29018: nsFocusManager::WindowLowered(nsIDOMWindow* aWindow)
 29018: {
 29018:   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(aWindow);
 29018:   NS_ENSURE_TRUE(window && window->IsOuterWindow(), NS_ERROR_INVALID_ARG);
 29018: 
 29018: #ifdef DEBUG_FOCUS
 29018:   printf("Window %p Lowered [Currently: %p %p] <<", aWindow, mActiveWindow.get(), mFocusedWindow.get());
 29018:   nsCAutoString spec;
 29018:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(window->GetExtantDocument());
 29018:   if (doc) {
 29018:     doc->GetDocumentURI()->GetSpec(spec);
 29018:     printf("[%p] Lowered Window: %s", aWindow, spec.get());
 29018:   }
 29018:   if (mActiveWindow) {
 29018:     doc = do_QueryInterface(mActiveWindow->GetExtantDocument());
 29018:     if (doc) {
 29018:       doc->GetDocumentURI()->GetSpec(spec);
 29018:       printf(" [%p] Active Window: %s", mActiveWindow.get(), spec.get());
 29018:     }
 29018:   }
 29018:   printf(">>\n");
 29018: #endif
 29018: 
 29018:   if (mActiveWindow != window)
 29018:     return NS_OK;
 29018: 
 38335:   // clear the mouse capture as the active window has changed
 38335:   nsIPresShell::SetCapturingContent(nsnull, 0);
 38335: 
 29018:   // inform the DOM window that it has deactivated, so that the active
 29018:   // attribute is updated on the window
 80486:   window->ActivateOrDeactivate(false);
 29018: 
 34280:   // send deactivate event
 34280:   nsCOMPtr<nsIDocument> document = do_QueryInterface(window->GetExtantDocument());
 34280:   nsContentUtils::DispatchTrustedEvent(document,
 34280:                                        window,
 34280:                                        NS_LITERAL_STRING("deactivate"),
 80486:                                        true, true, nsnull);
 34280: 
 29018:   // keep track of the window being lowered, so that attempts to raise the
 29018:   // window can be prevented until we return. Otherwise, focus can get into
 29018:   // an unusual state.
 29018:   mWindowBeingLowered = mActiveWindow;
 29018:   mActiveWindow = nsnull;
 29018: 
 29018:   if (mFocusedWindow)
 80486:     Blur(nsnull, nsnull, true, true);
 29018: 
 29018:   mWindowBeingLowered = nsnull;
 29018: 
 29018:   return NS_OK;
 29018: }
 29018: 
 41409: nsresult
 29018: nsFocusManager::ContentRemoved(nsIDocument* aDocument, nsIContent* aContent)
 29018: {
 29018:   NS_ENSURE_ARG(aDocument);
 29018:   NS_ENSURE_ARG(aContent);
 29018: 
 29018:   nsPIDOMWindow *window = aDocument->GetWindow();
 29018:   if (!window)
 29018:     return NS_OK;
 29018: 
 29018:   // if the content is currently focused in the window, or is an ancestor
 29018:   // of the currently focused element, reset the focus within that window.
 41409:   nsIContent* content = window->GetFocusedNode();
 29018:   if (content && nsContentUtils::ContentIsDescendantOf(content, aContent)) {
 79445:     bool shouldShowFocusRing = window->ShouldShowFocusRing();
 29018:     window->SetFocusedNode(nsnull);
 29018: 
 29018:     nsCOMPtr<nsIDocShell> docShell = window->GetDocShell();
 29018:     if (docShell) {
 29018:       nsCOMPtr<nsIPresShell> presShell;
 29018:       docShell->GetPresShell(getter_AddRefs(presShell));
 29018:       nsIMEStateManager::OnRemoveContent(presShell->GetPresContext(), content);
 29018:     }
 29018: 
 29018:     // if this window is currently focused, clear the global focused
 29018:     // element as well, but don't fire any events.
 30830:     if (window == mFocusedWindow) {
 29018:       mFocusedContent = nsnull;
 29018:     }
 30830:     else {
 30830:       // Check if the node that was focused is an iframe or similar by looking
 30830:       // if it has a subdocument. This would indicate that this focused iframe
 30830:       // and its descendants will be going away. We will need to move the
 30830:       // focus somewhere else, so just clear the focus in the toplevel window
 30830:       // so that no element is focused.
 30830:       nsIDocument* subdoc = aDocument->GetSubDocumentFor(content);
 30830:       if (subdoc) {
 30830:         nsCOMPtr<nsISupports> container = subdoc->GetContainer();
 30830:         nsCOMPtr<nsPIDOMWindow> childWindow = do_GetInterface(container);
 30830:         if (childWindow && IsSameOrAncestor(childWindow, mFocusedWindow)) {
 30830:           ClearFocus(mActiveWindow);
 30830:         }
 30830:       }
 30830:     }
 71114: 
 91765:     NotifyFocusStateChange(content, shouldShowFocusRing, false);
 30830:   }
 29018: 
 29018:   return NS_OK;
 29018: }
 29018: 
 29018: NS_IMETHODIMP
 79445: nsFocusManager::WindowShown(nsIDOMWindow* aWindow, bool aNeedsFocus)
 29018: {
 29018:   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(aWindow);
 29018:   NS_ENSURE_TRUE(window, NS_ERROR_INVALID_ARG);
 29018: 
 29018:   window = window->GetOuterWindow();
 29018: 
 29018: #ifdef DEBUG_FOCUS
 29018:   printf("Window %p Shown [Currently: %p %p] <<", window.get(), mActiveWindow.get(), mFocusedWindow.get());
 29018:   nsCAutoString spec;
 29018:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(window->GetExtantDocument());
 29018:   if (doc) {
 29018:     doc->GetDocumentURI()->GetSpec(spec);
 29018:     printf("Shown Window: %s", spec.get());
 29018:   }
 29018: 
 29018:   if (mFocusedWindow) {
 29018:     doc = do_QueryInterface(mFocusedWindow->GetExtantDocument());
 29018:     if (doc) {
 29018:       doc->GetDocumentURI()->GetSpec(spec);
 29018:       printf(" Focused Window: %s", spec.get());
 29018:     }
 29018:   }
 29018:   printf(">>\n");
 29018: #endif
 29018: 
 29018:   if (mFocusedWindow != window)
 29018:     return NS_OK;
 29018: 
 33917:   if (aNeedsFocus) {
 29018:     nsCOMPtr<nsPIDOMWindow> currentWindow;
 29018:     nsCOMPtr<nsIContent> currentFocus =
 80486:       GetFocusedDescendant(window, true, getter_AddRefs(currentWindow));
 29018:     if (currentWindow)
 80486:       Focus(currentWindow, currentFocus, 0, true, false, false, true);
 33917:   }
 33917:   else {
 33917:     // Sometimes, an element in a window can be focused before the window is
 33917:     // visible, which would mean that the widget may not be properly focused.
 33917:     // When the window becomes visible, make sure the right widget is focused.
 33917:     EnsureCurrentWidgetFocused();
 33917:   }
 29018: 
 29018:   return NS_OK;
 29018: }
 29018: 
 29018: NS_IMETHODIMP
 29018: nsFocusManager::WindowHidden(nsIDOMWindow* aWindow)
 29018: {
 29018:   // if there is no window or it is not the same or an ancestor of the
 29018:   // currently focused window, just return, as the current focus will not
 29018:   // be affected.
 29018: 
 29018:   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(aWindow);
 29018:   NS_ENSURE_TRUE(window, NS_ERROR_INVALID_ARG);
 29018: 
 29018:   window = window->GetOuterWindow();
 29018: 
 29018: #ifdef DEBUG_FOCUS
 29018:   printf("Window %p Hidden [Currently: %p %p] <<", window.get(), mActiveWindow.get(), mFocusedWindow.get());
 29018:   nsCAutoString spec;
 29018:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(window->GetExtantDocument());
 29018:   if (doc) {
 29018:     doc->GetDocumentURI()->GetSpec(spec);
 29018:     printf("Hide Window: %s", spec.get());
 29018:   }
 29018: 
 29018:   if (mFocusedWindow) {
 29018:     doc = do_QueryInterface(mFocusedWindow->GetExtantDocument());
 29018:     if (doc) {
 29018:       doc->GetDocumentURI()->GetSpec(spec);
 29018:       printf(" Focused Window: %s", spec.get());
 29018:     }
 29018:   }
 29018: 
 29018:   if (mActiveWindow) {
 29018:     doc = do_QueryInterface(mActiveWindow->GetExtantDocument());
 29018:     if (doc) {
 29018:       doc->GetDocumentURI()->GetSpec(spec);
 29018:       printf(" Active Window: %s", spec.get());
 29018:     }
 29018:   }
 29018:   printf(">>\n");
 29018: #endif
 29018: 
 29018:   if (!IsSameOrAncestor(window, mFocusedWindow))
 29018:     return NS_OK;
 29018: 
 29018:   // at this point, we know that the window being hidden is either the focused
 29018:   // window, or an ancestor of the focused window. Either way, the focus is no
 29018:   // longer valid, so it needs to be updated.
 29018: 
102033:   nsCOMPtr<nsIContent> oldFocusedContent = mFocusedContent.forget();
 64121: 
102759:   nsCOMPtr<nsIDocShell> focusedDocShell = mFocusedWindow->GetDocShell();
102759:   nsCOMPtr<nsIPresShell> presShell;
102759:   focusedDocShell->GetPresShell(getter_AddRefs(presShell));
102759: 
 64121:   if (oldFocusedContent && oldFocusedContent->IsInDoc()) {
 71114:     NotifyFocusStateChange(oldFocusedContent,
 71114:                            mFocusedWindow->ShouldShowFocusRing(),
 80486:                            false);
102759:     window->UpdateCommands(NS_LITERAL_STRING("focus"));
102759: 
102759:     if (presShell) {
102759:       SendFocusOrBlurEvent(NS_BLUR_CONTENT, presShell,
102759:                            oldFocusedContent->GetCurrentDoc(),
102759:                            oldFocusedContent, 1, false);
102759:     }
102759:   }
 29018: 
 29018:   nsIMEStateManager::OnTextStateBlur(nsnull, nsnull);
 29018:   if (presShell) {
 82840:     nsIMEStateManager::OnChangeFocus(presShell->GetPresContext(), nsnull,
 82841:                                      GetFocusMoveActionCause(0));
 80486:     SetCaretVisible(presShell, false, nsnull);
 29018:   }
 29018: 
 29018:   // if the docshell being hidden is being destroyed, then we want to move
 29018:   // focus somewhere else. Call ClearFocus on the toplevel window, which
 29018:   // will have the effect of clearing the focus and moving the focused window
 29018:   // to the toplevel window. But if the window isn't being destroyed, we are
 29018:   // likely just loading a new document in it, so we want to maintain the
 29018:   // focused window so that the new document gets properly focused.
 79445:   bool beingDestroyed;
 29018:   nsCOMPtr<nsIDocShell> docShellBeingHidden = window->GetDocShell();
 29018:   docShellBeingHidden->IsBeingDestroyed(&beingDestroyed);
 29018:   if (beingDestroyed) {
 29018:     // There is usually no need to do anything if a toplevel window is going
 29018:     // away, as we assume that WindowLowered will be called. However, this may
 29018:     // not happen if nsIAppStartup::eForceQuit is used to quit, and can cause
 29018:     // a leak. So if the active window is being destroyed, call WindowLowered
 29018:     // directly.
 29018:     NS_ASSERTION(mFocusedWindow->IsOuterWindow(), "outer window expected");
 29018:     if (mActiveWindow == mFocusedWindow || mActiveWindow == window)
 29018:       WindowLowered(mActiveWindow);
 29018:     else
 29018:       ClearFocus(mActiveWindow);
 29018:     return NS_OK;
 29018:   }
 29018: 
 29018:   // if the window being hidden is an ancestor of the focused window, adjust
 29018:   // the focused window so that it points to the one being hidden. This
 29018:   // ensures that the focused window isn't in a chain of frames that doesn't
 29018:   // exist any more.
 29018:   if (window != mFocusedWindow) {
 32922:     nsCOMPtr<nsIWebNavigation> webnav(do_GetInterface(mFocusedWindow));
 29018:     nsCOMPtr<nsIDocShellTreeItem> dsti = do_QueryInterface(webnav);
 29018:     if (dsti) {
 29461:       nsCOMPtr<nsIDocShellTreeItem> parentDsti;
 29461:       dsti->GetParent(getter_AddRefs(parentDsti));
 29461:       nsCOMPtr<nsPIDOMWindow> parentWindow = do_GetInterface(parentDsti);
 29018:       if (parentWindow)
 29018:         parentWindow->SetFocusedNode(nsnull);
 29018:     }
 29018: 
 29018:     mFocusedWindow = window;
 29018:   }
 29018: 
 29018:   return NS_OK;
 29018: }
 29018: 
 29018: NS_IMETHODIMP
 29018: nsFocusManager::FireDelayedEvents(nsIDocument* aDocument)
 29018: {
 29018:   NS_ENSURE_ARG(aDocument);
 29018: 
 29018:   // fire any delayed focus and blur events in the same order that they were added
 29018:   for (PRUint32 i = 0; i < mDelayedBlurFocusEvents.Length(); i++)
 29018:   {
 29018:     if (mDelayedBlurFocusEvents[i].mDocument == aDocument &&
 29018:         !aDocument->EventHandlingSuppressed()) {
 29018:       PRUint32 type = mDelayedBlurFocusEvents[i].mType;
 72326:       nsCOMPtr<nsIDOMEventTarget> target = mDelayedBlurFocusEvents[i].mTarget;
 29018:       nsCOMPtr<nsIPresShell> presShell = mDelayedBlurFocusEvents[i].mPresShell;
 29018:       mDelayedBlurFocusEvents.RemoveElementAt(i);
 80486:       SendFocusOrBlurEvent(type, presShell, aDocument, target, 0, false);
 29018:       --i;
 29018:     }
 29018:   }
 29018: 
 29018:   return NS_OK;
 29018: }
 29018: 
 57526: NS_IMETHODIMP
 57526: nsFocusManager::FocusPlugin(nsIContent* aContent)
 57526: {
 57526:   NS_ENSURE_ARG(aContent);
 80486:   SetFocusInner(aContent, 0, true, false);
 57526:   return NS_OK;
 57526: }
 57526: 
 71114: /* static */
 71114: void
 71114: nsFocusManager::NotifyFocusStateChange(nsIContent* aContent,
 79445:                                        bool aWindowShouldShowFocusRing,
 79445:                                        bool aGettingFocus)
 71114: {
 71114:   if (!aContent->IsElement()) {
 71114:     return;
 71114:   }
 71114:   nsEventStates eventState = NS_EVENT_STATE_FOCUS;
 71114:   if (aWindowShouldShowFocusRing) {
 71114:     eventState |= NS_EVENT_STATE_FOCUSRING;
 71114:   }
 71114:   if (aGettingFocus) {
 71114:     aContent->AsElement()->AddStates(eventState);
 71114:   } else {
 71114:     aContent->AsElement()->RemoveStates(eventState);
 71114:   }
 71114: }
 71114: 
 29018: // static
 29018: void
 29018: nsFocusManager::EnsureCurrentWidgetFocused()
 29018: {
 87215:   if (!mFocusedWindow || sTestMode)
 29018:     return;
 29018: 
 29018:   // get the main child widget for the focused window and ensure that the
 29018:   // platform knows that this widget is focused.
 29018:   nsCOMPtr<nsIDocShell> docShell = mFocusedWindow->GetDocShell();
 29018:   if (docShell) {
 29018:     nsCOMPtr<nsIPresShell> presShell;
 29018:     docShell->GetPresShell(getter_AddRefs(presShell));
 29018:     if (presShell) {
 29018:       nsIViewManager* vm = presShell->GetViewManager();
 29018:       if (vm) {
 29018:         nsCOMPtr<nsIWidget> widget;
 30530:         vm->GetRootWidget(getter_AddRefs(widget));
 29018:         if (widget)
 80486:           widget->SetFocus(false);
 29018:       }
 29018:     }
 29018:   }
 29018: }
 29018: 
 29018: void
 29018: nsFocusManager::SetFocusInner(nsIContent* aNewContent, PRInt32 aFlags,
 79445:                               bool aFocusChanged, bool aAdjustWidget)
 29018: {
 29018:   // if the element is not focusable, just return and leave the focus as is
 29018:   nsCOMPtr<nsIContent> contentToFocus = CheckIfFocusable(aNewContent, aFlags);
 29018:   if (!contentToFocus)
 29018:     return;
 29018: 
 29018:   // check if the element to focus is a frame (iframe) containing a child
 29018:   // document. Frames are never directly focused; instead focusing a frame
 29018:   // means focus what is inside the frame. To do this, the descendant content
 29018:   // within the frame is retrieved and that will be focused instead.
 29018:   nsCOMPtr<nsPIDOMWindow> newWindow;
 29018:   nsCOMPtr<nsPIDOMWindow> subWindow = GetContentWindow(contentToFocus);
 29018:   if (subWindow) {
 80486:     contentToFocus = GetFocusedDescendant(subWindow, true, getter_AddRefs(newWindow));
 29018:     // since a window is being refocused, clear aFocusChanged so that the
 29018:     // caret position isn't updated.
 80486:     aFocusChanged = false;
 29018:   }
 29018: 
 29018:   // unless it was set above, retrieve the window for the element to focus
 29018:   if (!newWindow)
 29018:     newWindow = GetCurrentWindow(contentToFocus);
 29018: 
 29018:   // if the element is already focused, just return. Note that this happens
 29018:   // after the frame check above so that we compare the element that will be
 29018:   // focused rather than the frame it is in.
 39425:   if (!newWindow || (newWindow == mFocusedWindow && contentToFocus == mFocusedContent))
 29018:     return;
 29018: 
 29018:   // don't allow focus to be placed in docshells or descendants of docshells
 30218:   // that are being destroyed. Also, ensure that the page hasn't been
 30218:   // unloaded. The prevents content from being refocused during an unload event.
 29018:   nsCOMPtr<nsIDocShell> newDocShell = newWindow->GetDocShell();
 29018:   nsCOMPtr<nsIDocShell> docShell = newDocShell;
 29018:   while (docShell) {
 79445:     bool inUnload;
 30218:     docShell->GetIsInUnload(&inUnload);
 30218:     if (inUnload)
 30218:       return;
 30218: 
 79445:     bool beingDestroyed;
 29018:     docShell->IsBeingDestroyed(&beingDestroyed);
 29018:     if (beingDestroyed)
 29018:       return;
 29018: 
 29018:     nsCOMPtr<nsIDocShellTreeItem> dsti = do_QueryInterface(docShell);
 29461:     nsCOMPtr<nsIDocShellTreeItem> parentDsti;
 29461:     dsti->GetParent(getter_AddRefs(parentDsti));
 29461:     docShell = do_QueryInterface(parentDsti);
 29018:   }
 29018: 
 29018:   // if the new element is in the same window as the currently focused element 
 79445:   bool isElementInFocusedWindow = (mFocusedWindow == newWindow);
 29018: 
 41239:   if (!isElementInFocusedWindow && mFocusedWindow && newWindow &&
 41239:       nsContentUtils::IsHandlingKeyBoardEvent()) {
 41239:     nsCOMPtr<nsIScriptObjectPrincipal> focused =
 41239:       do_QueryInterface(mFocusedWindow);
 41239:     nsCOMPtr<nsIScriptObjectPrincipal> newFocus =
 41239:       do_QueryInterface(newWindow);
 41239:     nsIPrincipal* focusedPrincipal = focused->GetPrincipal();
 41239:     nsIPrincipal* newPrincipal = newFocus->GetPrincipal();
 41239:     if (!focusedPrincipal || !newPrincipal) {
 41239:       return;
 41239:     }
 79445:     bool subsumes = false;
 41239:     focusedPrincipal->Subsumes(newPrincipal, &subsumes);
 41239:     if (!subsumes && !nsContentUtils::IsCallerTrustedForWrite()) {
 41239:       NS_WARNING("Not allowed to focus the new window!");
 41239:       return;
 41239:     }
 41239:   }
 41239: 
 29018:   // to check if the new element is in the active window, compare the
 29018:   // new root docshell for the new element with the active window's docshell.
 79445:   bool isElementInActiveWindow = false;
 29018: 
 29018:   nsCOMPtr<nsIWebNavigation> webnav = do_GetInterface(newWindow);
 29018:   nsCOMPtr<nsIDocShellTreeItem> dsti = do_QueryInterface(webnav);
 29018:   nsCOMPtr<nsPIDOMWindow> newRootWindow;
 29018:   if (dsti) {
 29018:     nsCOMPtr<nsIDocShellTreeItem> root;
 29018:     dsti->GetRootTreeItem(getter_AddRefs(root));
 29018:     newRootWindow = do_GetInterface(root);
 29018: 
 29018:     isElementInActiveWindow = (mActiveWindow && newRootWindow == mActiveWindow);
 29018:   }
 29018: 
 29018: #ifdef DEBUG_FOCUS
 29018:   PRINTTAGF("Shift Focus: %s", contentToFocus);
 41071:   printf(" Flags: %x Current Window: %p New Window: %p Current Element: %p",
 29018:          aFlags, mFocusedWindow.get(), newWindow.get(), mFocusedContent.get());
 29018:   printf(" In Active Window: %d In Focused Window: %d\n",
 29018:          isElementInActiveWindow, isElementInFocusedWindow);
 29018: #endif
 29018: 
 84911:   // Exit full-screen if we're focusing a windowed plugin on a non-MacOSX
 84911:   // system. We don't control event dispatch to windowed plugins on non-MacOSX,
 84911:   // so we can't display the "Press ESC to leave full-screen mode" warning on
 84911:   // key input if a windowed plugin is focused, so just exit full-screen
 84911:   // to guard against phishing.
 84911: #ifndef XP_MACOSX
 84911:   if (contentToFocus &&
 84911:       nsContentUtils::GetRootDocument(contentToFocus->OwnerDoc())->IsFullScreenDoc() &&
 84911:       nsContentUtils::HasPluginWithUncontrolledEventDispatch(contentToFocus)) {
 84911:     nsContentUtils::ReportToConsole(nsIScriptError::warningFlag,
 84911:                                     "DOM",
 84911:                                     contentToFocus->OwnerDoc(),
 84911:                                     nsContentUtils::eDOM_PROPERTIES,
 84911:                                     "FocusedWindowedPluginWhileFullScreen");
 84911:     nsIDocument::ExitFullScreen(true);
 84911:   }
 84911: #endif
 84911: 
 29018:   // if the FLAG_NOSWITCHFRAME flag is used, only allow the focus to be
 29018:   // shifted away from the current element if the new shell to focus is
 29018:   // the same or an ancestor shell of the currently focused shell.
 79445:   bool allowFrameSwitch = !(aFlags & FLAG_NOSWITCHFRAME) ||
 29018:                             IsSameOrAncestor(newWindow, mFocusedWindow);
 29018: 
 29018:   // if the element is in the active window, frame switching is allowed and
 29018:   // the content is in a visible window, fire blur and focus events.
 79445:   bool sendFocusEvent =
 35609:     isElementInActiveWindow && allowFrameSwitch && IsWindowVisible(newWindow);
 35609: 
 35609:   // When the following conditions are true:
 35609:   //  * an element has focus
 35609:   //  * isn't called by trusted event (i.e., called by untrusted event or by js)
 35609:   //  * the focus is moved to another document's element
 35609:   // we need to check the permission.
 35609:   if (sendFocusEvent && mFocusedContent &&
 80526:       mFocusedContent->OwnerDoc() != aNewContent->OwnerDoc()) {
 35609:     // If the caller cannot access the current focused node, the caller should
 35609:     // not be able to steal focus from it. E.g., When the current focused node
 35609:     // is in chrome, any web contents should not be able to steal the focus.
 35609:     nsCOMPtr<nsIDOMNode> domNode(do_QueryInterface(mFocusedContent));
 35609:     sendFocusEvent = nsContentUtils::CanCallerAccess(domNode);
 56988:     if (!sendFocusEvent && mMouseDownEventHandlingDocument) {
 56988:       // However, while mouse down event is handling, the handling document's
 56988:       // script should be able to steal focus.
 56988:       domNode = do_QueryInterface(mMouseDownEventHandlingDocument);
 56988:       sendFocusEvent = nsContentUtils::CanCallerAccess(domNode);
 56988:     }
 35609:   }
 35609: 
 35609:   if (sendFocusEvent) {
 29018:     // return if blurring fails or the focus changes during the blur
 29018:     if (mFocusedWindow) {
 29018:       // if the focus is being moved to another element in the same document,
 29018:       // or to a descendant, pass the existing window to Blur so that the
 29018:       // current node in the existing window is cleared. If moving to a
 29018:       // window elsewhere, we want to maintain the current node in the
 29018:       // window but still blur it.
 79445:       bool currentIsSameOrAncestor = IsSameOrAncestor(mFocusedWindow, newWindow);
 29018:       // find the common ancestor of the currently focused window and the new
 29018:       // window. The ancestor will need to have its currently focused node
 29018:       // cleared once the document has been blurred. Otherwise, we'll be in a
 29018:       // state where a document is blurred yet the chain of windows above it
 29018:       // still points to that document.
 29018:       // For instance, in the following frame tree:
 29018:       //   A
 29018:       //  B C
 29018:       //  D
 29018:       // D is focused and we want to focus C. Once D has been blurred, we need
 29018:       // to clear out the focus in A, otherwise A would still maintain that B
 29018:       // was focused, and B that D was focused.
 29018:       nsCOMPtr<nsPIDOMWindow> commonAncestor;
 29018:       if (!isElementInFocusedWindow)
 29018:         commonAncestor = GetCommonAncestor(newWindow, mFocusedWindow);
 29018: 
 29040:       if (!Blur(currentIsSameOrAncestor ? mFocusedWindow.get() : nsnull,
 57526:                 commonAncestor, !isElementInFocusedWindow, aAdjustWidget))
 29018:         return;
 29018:     }
 29018: 
 29018:     Focus(newWindow, contentToFocus, aFlags, !isElementInFocusedWindow,
 80486:           aFocusChanged, false, aAdjustWidget);
 29018:   }
 29018:   else {
 35609:     // otherwise, for inactive windows and when the caller cannot steal the
 35609:     // focus, update the node in the window, and  raise the window if desired.
 29018:     if (allowFrameSwitch)
 80486:       AdjustWindowFocus(newWindow, true);
 29018: 
 29018:     // set the focus node and method as needed
 41071:     PRUint32 focusMethod = aFocusChanged ? aFlags & FOCUSMETHODANDRING_MASK :
 41071:                            newWindow->GetFocusMethod() | (aFlags & FLAG_SHOWRING);
 29018:     newWindow->SetFocusedNode(contentToFocus, focusMethod);
 29018:     if (aFocusChanged) {
 29018:       nsCOMPtr<nsIDocShell> docShell = newWindow->GetDocShell();
 29018: 
 29018:       nsCOMPtr<nsIPresShell> presShell;
 29018:       docShell->GetPresShell(getter_AddRefs(presShell));
 29018:       if (presShell)
 29018:         ScrollIntoView(presShell, contentToFocus, aFlags);
 29018:     }
 29018: 
 29018:     // update the commands even when inactive so that the attributes for that
 29018:     // window are up to date.
 29018:     if (allowFrameSwitch)
 29018:       newWindow->UpdateCommands(NS_LITERAL_STRING("focus"));
 29018: 
 29018:     if (aFlags & FLAG_RAISE)
 29018:       RaiseWindow(newRootWindow);
 29018:   }
 29018: }
 29018: 
 79445: bool
 29018: nsFocusManager::IsSameOrAncestor(nsPIDOMWindow* aPossibleAncestor,
 29018:                                  nsPIDOMWindow* aWindow)
 29018: {
 29018:   nsCOMPtr<nsIWebNavigation> awebnav(do_GetInterface(aPossibleAncestor));
 29018:   nsCOMPtr<nsIDocShellTreeItem> ancestordsti = do_QueryInterface(awebnav);
 29018: 
 29018:   nsCOMPtr<nsIWebNavigation> fwebnav(do_GetInterface(aWindow));
 29018:   nsCOMPtr<nsIDocShellTreeItem> dsti = do_QueryInterface(fwebnav);
 29018:   while (dsti) {
 29018:     if (dsti == ancestordsti)
 80486:       return true;
 29461:     nsCOMPtr<nsIDocShellTreeItem> parentDsti;
 29461:     dsti->GetParent(getter_AddRefs(parentDsti));
 29461:     dsti.swap(parentDsti);
 29018:   }
 29018: 
 80486:   return false;
 29018: }
 29018: 
 29018: already_AddRefed<nsPIDOMWindow>
 29018: nsFocusManager::GetCommonAncestor(nsPIDOMWindow* aWindow1,
 29018:                                   nsPIDOMWindow* aWindow2)
 29018: {
 29018:   nsCOMPtr<nsIWebNavigation> webnav(do_GetInterface(aWindow1));
 29018:   nsCOMPtr<nsIDocShellTreeItem> dsti1 = do_QueryInterface(webnav);
 30830:   NS_ENSURE_TRUE(dsti1, nsnull);
 29018: 
 29018:   webnav = do_GetInterface(aWindow2);
 29018:   nsCOMPtr<nsIDocShellTreeItem> dsti2 = do_QueryInterface(webnav);
 30830:   NS_ENSURE_TRUE(dsti2, nsnull);
 29018: 
 75183:   nsAutoTArray<nsIDocShellTreeItem*, 30> parents1, parents2;
 29018:   do {
 29018:     parents1.AppendElement(dsti1);
 29461:     nsCOMPtr<nsIDocShellTreeItem> parentDsti1;
 29461:     dsti1->GetParent(getter_AddRefs(parentDsti1));
 29461:     dsti1.swap(parentDsti1);
 29018:   } while (dsti1);
 29018:   do {
 29018:     parents2.AppendElement(dsti2);
 29461:     nsCOMPtr<nsIDocShellTreeItem> parentDsti2;
 29461:     dsti2->GetParent(getter_AddRefs(parentDsti2));
 29461:     dsti2.swap(parentDsti2);
 29018:   } while (dsti2);
 29018: 
 29018:   PRUint32 pos1 = parents1.Length();
 29018:   PRUint32 pos2 = parents2.Length();
 29018:   nsIDocShellTreeItem* parent = nsnull;
 29018:   PRUint32 len;
 38330:   for (len = NS_MIN(pos1, pos2); len > 0; --len) {
 29018:     nsIDocShellTreeItem* child1 = parents1.ElementAt(--pos1);
 29018:     nsIDocShellTreeItem* child2 = parents2.ElementAt(--pos2);
 29018:     if (child1 != child2) {
 29018:       break;
 29018:     }
 29018:     parent = child1;
 29018:   }
 29018: 
 29018:   nsCOMPtr<nsPIDOMWindow> window = do_GetInterface(parent);
 29018:   return window.forget();
 29018: }
 29018: 
 29018: void
 35609: nsFocusManager::AdjustWindowFocus(nsPIDOMWindow* aWindow,
 79445:                                   bool aCheckPermission)
 29018: {
 79445:   bool isVisible = IsWindowVisible(aWindow);
 29018: 
 29018:   nsCOMPtr<nsPIDOMWindow> window(aWindow);
 29018:   while (window) {
 29018:     // get the containing <iframe> or equivalent element so that it can be
 29018:     // focused below.
 29018:     nsCOMPtr<nsIContent> frameContent =
 29018:       do_QueryInterface(window->GetFrameElementInternal());
 29018: 
 29018:     nsCOMPtr<nsIWebNavigation> webnav(do_GetInterface(window));
 29018:     nsCOMPtr<nsIDocShellTreeItem> dsti = do_QueryInterface(webnav);
 29461:     if (!dsti) 
 29461:       return;
 29461:     nsCOMPtr<nsIDocShellTreeItem> parentDsti;
 29461:     dsti->GetParent(getter_AddRefs(parentDsti));
 29461: 
 29461:     window = do_GetInterface(parentDsti);
 29018:     if (window) {
 29018:       // if the parent window is visible but aWindow was not, then we have
 29018:       // likely moved up and out from a hidden tab to the browser window, or a
 29018:       // similar such arrangement. Stop adjusting the current nodes.
 29018:       if (IsWindowVisible(window) != isVisible)
 29018:         break;
 29018: 
 35609:       // When aCheckPermission is true, we should check whether the caller can
 35609:       // access the window or not.  If it cannot access, we should stop the
 35609:       // adjusting.
 35609:       if (aCheckPermission && !nsContentUtils::CanCallerAccess(window))
 35609:         break;
 35609: 
 29018:       window->SetFocusedNode(frameContent);
 29018:     }
 29018:   }
 29018: }
 29018: 
 79445: bool
 29018: nsFocusManager::IsWindowVisible(nsPIDOMWindow* aWindow)
 29018: {
 29018:   if (!aWindow)
 80486:     return false;
 29018: 
 29018:   nsCOMPtr<nsIDocShell> docShell = aWindow->GetDocShell();
 29018:   nsCOMPtr<nsIBaseWindow> baseWin(do_QueryInterface(docShell));
 29018:   if (!baseWin)
 80486:     return false;
 29018: 
 79445:   bool visible = false;
 29018:   baseWin->GetVisibility(&visible);
 29018:   return visible;
 29018: }
 29018: 
 79445: bool
 41068: nsFocusManager::IsNonFocusableRoot(nsIContent* aContent)
 41068: {
 41068:   NS_PRECONDITION(aContent, "aContent must not be NULL");
 41068:   NS_PRECONDITION(aContent->IsInDoc(), "aContent must be in a document");
 41068: 
 41068:   // If aContent is in designMode, the root element is not focusable.
 41068:   // NOTE: in designMode, most elements are not focusable, just the document is
 41068:   //       focusable.
 41068:   // Also, if aContent is not editable but it isn't in designMode, it's not
 41068:   // focusable.
 41068:   nsIDocument* doc = aContent->GetCurrentDoc();
 41068:   NS_ASSERTION(doc, "aContent must have current document");
 41634:   return aContent == doc->GetRootElement() &&
 41068:            (doc->HasFlag(NODE_IS_EDITABLE) || !aContent->IsEditable());
 41068: }
 41068: 
 29018: nsIContent*
 29018: nsFocusManager::CheckIfFocusable(nsIContent* aContent, PRUint32 aFlags)
 29018: {
 29018:   if (!aContent)
 29018:     return nsnull;
 29018: 
 29018:   // this is a special case for some XUL elements where an anonymous child is
 29018:   // actually focusable and not the element itself.
 29018:   nsIContent* redirectedFocus = GetRedirectedFocus(aContent);
 29018:   if (redirectedFocus)
 29018:     return CheckIfFocusable(redirectedFocus, aFlags);
 29018: 
 29018:   nsCOMPtr<nsIDocument> doc = aContent->GetCurrentDoc();
 29018:   // can't focus elements that are not in documents
 29018:   if (!doc)
 29018:     return nsnull;
 29018: 
 29018:   // Make sure that our frames are up to date
 57591:   doc->FlushPendingNotifications(Flush_Layout);
 29018: 
 46225:   nsIPresShell *shell = doc->GetShell();
 29018:   if (!shell)
 29018:     return nsnull;
 29018: 
 29018:   // the root content can always be focused
 41634:   if (aContent == doc->GetRootElement())
 29018:     return aContent;
 29018: 
 29018:   // cannot focus content in print preview mode. Only the root can be focused.
 29018:   nsPresContext* presContext = shell->GetPresContext();
 29018:   if (presContext && presContext->Type() == nsPresContext::eContext_PrintPreview)
 29018:     return nsnull;
 29018: 
 36657:   nsIFrame* frame = aContent->GetPrimaryFrame();
 29018:   if (!frame)
 29018:     return nsnull;
 29018: 
 33329:   if (aContent->Tag() == nsGkAtoms::area && aContent->IsHTML()) {
 29018:     // HTML areas do not have their own frame, and the img frame we get from
 36657:     // GetPrimaryFrame() is not relevant as to whether it is focusable or
 29018:     // not, so we have to do all the relevant checks manually for them.
 80910:     return frame->IsVisibleConsideringAncestors() &&
 29018:            aContent->IsFocusable() ? aContent : nsnull;
 29018:   }
 29018: 
 29018:   // if this is a child frame content node, check if it is visible and
 29018:   // call the content node's IsFocusable method instead of the frame's
 29018:   // IsFocusable method. This skips checking the style system and ensures that
 29018:   // offscreen browsers can still be focused.
 29018:   nsIDocument* subdoc = doc->GetSubDocumentFor(aContent);
 29018:   if (subdoc && IsWindowVisible(subdoc->GetWindow())) {
 29018:     const nsStyleUserInterface* ui = frame->GetStyleUserInterface();
 29018:     PRInt32 tabIndex = (ui->mUserFocus == NS_STYLE_USER_FOCUS_IGNORE ||
 29018:                         ui->mUserFocus == NS_STYLE_USER_FOCUS_NONE) ? -1 : 0;
 41071:     return aContent->IsFocusable(&tabIndex, aFlags & FLAG_BYMOUSE) ? aContent : nsnull;
 29018:   }
 29018:   
 29018:   return frame->IsFocusable(nsnull, aFlags & FLAG_BYMOUSE) ? aContent : nsnull;
 29018: }
 29018: 
 79445: bool
 29018: nsFocusManager::Blur(nsPIDOMWindow* aWindowToClear,
 29018:                      nsPIDOMWindow* aAncestorWindowToFocus,
 79445:                      bool aIsLeavingDocument,
 79445:                      bool aAdjustWidgets)
 29018: {
 29417:   // hold a reference to the focused content, which may be null
 29417:   nsCOMPtr<nsIContent> content = mFocusedContent;
 29417:   if (content) {
 29417:     if (!content->IsInDoc()) {
 29417:       mFocusedContent = nsnull;
 80486:       return true;
 29417:     }
 29417:     if (content == mFirstBlurEvent)
 80486:       return true;
 29417:   }
 29417: 
 29018:   // hold a reference to the focused window
 29018:   nsCOMPtr<nsPIDOMWindow> window = mFocusedWindow;
 29417:   if (!window) {
 29417:     mFocusedContent = nsnull;
 80486:     return true;
 29417:   }
 29417: 
 29417:   nsCOMPtr<nsIDocShell> docShell = window->GetDocShell();
 29417:   if (!docShell) {
 29417:     mFocusedContent = nsnull;
 80486:     return true;
 29417:   }
 29018: 
 29018:   // Keep a ref to presShell since dispatching the DOM event may cause
 29018:   // the document to be destroyed.
 29018:   nsCOMPtr<nsIPresShell> presShell;
 29018:   docShell->GetPresShell(getter_AddRefs(presShell));
 29417:   if (!presShell) {
 29417:     mFocusedContent = nsnull;
 80486:     return true;
 29417:   }
 29018: 
 79445:   bool clearFirstBlurEvent = false;
 29018:   if (!mFirstBlurEvent) {
 29018:     mFirstBlurEvent = content;
 80486:     clearFirstBlurEvent = true;
 29018:   }
 29018: 
 29018:   // if there is still an active window, adjust the IME state.
 29018:   // This has to happen before the focus is cleared below, otherwise, the IME
 29018:   // compositionend event won't get fired at the element being blurred.
 29018:   nsIMEStateManager::OnTextStateBlur(nsnull, nsnull);
 82840:   if (mActiveWindow) {
 82840:     nsIMEStateManager::OnChangeFocus(presShell->GetPresContext(), nsnull,
 82841:                                      GetFocusMoveActionCause(0));
 82840:   }
 29018: 
 29018:   // now adjust the actual focus, by clearing the fields in the focus manager
 29018:   // and in the window.
 29018:   mFocusedContent = nsnull;
 79445:   bool shouldShowFocusRing = window->ShouldShowFocusRing();
 29018:   if (aWindowToClear)
 29018:     aWindowToClear->SetFocusedNode(nsnull);
 29018: 
 29018: #ifdef DEBUG_FOCUS
 29018:   PRINTTAGF("**Element %s has been blurred\n", content);
 29018: #endif
 29018: 
 41068:   // Don't fire blur event on the root content which isn't editable.
 79445:   bool sendBlurEvent =
 41068:     content && content->IsInDoc() && !IsNonFocusableRoot(content);
 29018:   if (content) {
 41068:     if (sendBlurEvent) {
 80486:       NotifyFocusStateChange(content, shouldShowFocusRing, false);
 29018:     }
 29018: 
 73590:     // if an object/plug-in/remote browser is being blurred, move the system focus
 73590:     // to the parent window, otherwise events will still get fired at the plugin.
 29274:     // But don't do this if we are blurring due to the window being lowered,
 29274:     // otherwise, the parent window can get raised again.
 73590:     if (mActiveWindow) {
 36657:       nsIFrame* contentFrame = content->GetPrimaryFrame();
 29018:       nsIObjectFrame* objectFrame = do_QueryFrame(contentFrame);
 87215:       if (aAdjustWidgets && objectFrame && !sTestMode) {
 29018:         // note that the presshell's widget is being retrieved here, not the one
 29018:         // for the object frame.
 29018:         nsIViewManager* vm = presShell->GetViewManager();
 29018:         if (vm) {
 29018:           nsCOMPtr<nsIWidget> widget;
 30530:           vm->GetRootWidget(getter_AddRefs(widget));
 29018:           if (widget)
 80486:             widget->SetFocus(false);
 29018:         }
 29018:       }
 73590: 
 73590:       // if the object being blurred is a remote browser, deactivate remote content
 73590:       TabParent* remote = GetRemoteForContent(content);
 73590:       if (remote) {
 73590:         remote->Deactivate();
 73590:   #ifdef DEBUG_FOCUS
 73590:       printf("*Remote browser deactivated\n");
 73590:   #endif
 73590:       }
 29018:     }
 29274:   }
 29018: 
 79445:   bool result = true;
 41068:   if (sendBlurEvent) {
 29018:     // if there is an active window, update commands. If there isn't an active
 29018:     // window, then this was a blur caused by the active window being lowered,
 29018:     // so there is no need to update the commands
 29018:     if (mActiveWindow)
 29018:       window->UpdateCommands(NS_LITERAL_STRING("focus"));
 29018: 
 29018:     SendFocusOrBlurEvent(NS_BLUR_CONTENT, presShell,
 80486:                          content->GetCurrentDoc(), content, 1, false);
 29018:   }
 29018: 
 29018:   // if we are leaving the document or the window was lowered, make the caret
 29018:   // invisible.
 29018:   if (aIsLeavingDocument || !mActiveWindow)
 80486:     SetCaretVisible(presShell, false, nsnull);
 29018: 
 29018:   // at this point, it is expected that this window will be still be
 29018:   // focused, but the focused content will be null, as it was cleared before
 29018:   // the event. If this isn't the case, then something else was focused during
 29018:   // the blur event above and we should just return. However, if
 29018:   // aIsLeavingDocument is set, a new document is desired, so make sure to
 29018:   // blur the document and window.
 29018:   if (mFocusedWindow != window ||
 29018:       (mFocusedContent != nsnull && !aIsLeavingDocument)) {
 80486:     result = false;
 29018:   }
 29018:   else if (aIsLeavingDocument) {
 80486:     window->TakeFocus(false, 0);
 29018: 
 29018:     // clear the focus so that the ancestor frame hierarchy is in the correct
 29018:     // state. Pass true because aAncestorWindowToFocus is thought to be
 29018:     // focused at this point.
 29018:     if (aAncestorWindowToFocus)
 80486:       aAncestorWindowToFocus->SetFocusedNode(nsnull, 0, true);
 29018: 
 29018:     mFocusedWindow = nsnull;
 29018:     mFocusedContent = nsnull;
 29018: 
 29018:     // pass 1 for the focus method when calling SendFocusOrBlurEvent just so
 29452:     // that the check is made for suppressed documents. Check to ensure that
 29452:     // the document isn't null in case someone closed it during the blur above
 29018:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(window->GetExtantDocument());
 29452:     if (doc)
 80486:       SendFocusOrBlurEvent(NS_BLUR_CONTENT, presShell, doc, doc, 1, false);
 29018:     if (mFocusedWindow == nsnull)
 80486:       SendFocusOrBlurEvent(NS_BLUR_CONTENT, presShell, doc, window, 1, false);
 29018: 
 29018:     // check if a different window was focused
 29018:     result = (mFocusedWindow == nsnull && mActiveWindow);
 29018:   }
 29018:   else if (mActiveWindow) {
 29018:     // Otherwise, the blur of the element without blurring the document
 42263:     // occurred normally. Call UpdateCaret to redisplay the caret at the right
 29018:     // location within the document. This is needed to ensure that the caret
 29018:     // used for caret browsing is made visible again when an input field is
 29018:     // blurred.
 80486:     UpdateCaret(false, true, nsnull);
 29018:   }
 29018: 
 29018:   if (clearFirstBlurEvent)
 29018:     mFirstBlurEvent = nsnull;
 29018: 
 29018:   return result;
 29018: }
 29018: 
 29018: void
 29018: nsFocusManager::Focus(nsPIDOMWindow* aWindow,
 29018:                       nsIContent* aContent,
 29018:                       PRUint32 aFlags,
 79445:                       bool aIsNewDocument,
 79445:                       bool aFocusChanged,
 79445:                       bool aWindowRaised,
 79445:                       bool aAdjustWidgets)
 29018: {
 29018:   if (!aWindow)
 29018:     return;
 29018: 
 33241:   if (aContent && (aContent == mFirstFocusEvent || aContent == mFirstBlurEvent))
 29018:     return;
 29018: 
 29018:   // Keep a reference to the presShell since dispatching the DOM event may
 29018:   // cause the document to be destroyed.
 29018:   nsCOMPtr<nsIDocShell> docShell = aWindow->GetDocShell();
 29452:   if (!docShell)
 29452:     return;
 29018: 
 29018:   nsCOMPtr<nsIPresShell> presShell;
 29018:   docShell->GetPresShell(getter_AddRefs(presShell));
 29018:   if (!presShell)
 29018:     return;
 29018: 
 29018:   // If the focus actually changed, set the focus method (mouse, keyboard, etc).
 29018:   // Otherwise, just get the current focus method and use that. This ensures
 29018:   // that the method is set during the document and window focus events.
 41071:   PRUint32 focusMethod = aFocusChanged ? aFlags & FOCUSMETHODANDRING_MASK :
 41071:                          aWindow->GetFocusMethod() | (aFlags & FLAG_SHOWRING);
 29018: 
 29018:   if (!IsWindowVisible(aWindow)) {
 29018:     // if the window isn't visible, for instance because it is a hidden tab,
 29018:     // update the current focus and scroll it into view but don't do anything else
 29018:     if (CheckIfFocusable(aContent, aFlags)) {
 29018:       aWindow->SetFocusedNode(aContent, focusMethod);
 29018:       if (aFocusChanged)
 29018:         ScrollIntoView(presShell, aContent, aFlags);
 29018:     }
 29018:     return;
 29018:   }
 29018: 
 79445:   bool clearFirstFocusEvent = false;
 29018:   if (!mFirstFocusEvent) {
 29018:     mFirstFocusEvent = aContent;
 80486:     clearFirstFocusEvent = true;
 29018:   }
 29018: 
 29018: #ifdef DEBUG_FOCUS
 29018:   PRINTTAGF("**Element %s has been focused", aContent);
 29018:   nsCOMPtr<nsIDocument> docm = do_QueryInterface(aWindow->GetExtantDocument());
 29018:   if (docm)
 41634:     PRINTTAGF(" from %s", docm->GetRootElement());
 41071:   printf(" [Newdoc: %d FocusChanged: %d Raised: %d Flags: %x]\n",
 29018:          aIsNewDocument, aFocusChanged, aWindowRaised, aFlags);
 29018: #endif
 29018: 
 48711:   if (aIsNewDocument) {
 29018:     // if this is a new document, update the parent chain of frames so that
 29018:     // focus can be traversed from the top level down to the newly focused
 29018:     // window.
 80486:     AdjustWindowFocus(aWindow, false);
 29018: 
 48711:     // Update the window touch registration to reflect the state of
 48711:     // the new document that got focus
 48711:     aWindow->UpdateTouchState();
 48711:   }
 48711: 
 29018:   // indicate that the window has taken focus.
 80486:   if (aWindow->TakeFocus(true, focusMethod))
 80486:     aIsNewDocument = true;
 29018: 
 29018:   mFocusedWindow = aWindow;
 29018: 
 57526:   // Update the system focus by focusing the root widget.  But avoid this
 57526:   // if 1) aAdjustWidgets is false or 2) aContent is a plugin that has its
 57526:   // own widget and is either already focused or is about to be focused.
 57526:   nsCOMPtr<nsIWidget> objectFrameWidget;
 57526:   if (aContent) {
 57526:     nsIFrame* contentFrame = aContent->GetPrimaryFrame();
 57526:     nsIObjectFrame* objectFrame = do_QueryFrame(contentFrame);
 57526:     if (objectFrame)
 57526:       objectFrameWidget = objectFrame->GetWidget();
 57526:   }
 87215:   if (aAdjustWidgets && !objectFrameWidget && !sTestMode) {
 29018:     nsIViewManager* vm = presShell->GetViewManager();
 29018:     if (vm) {
 29018:       nsCOMPtr<nsIWidget> widget;
 30530:       vm->GetRootWidget(getter_AddRefs(widget));
 29018:       if (widget)
 80486:         widget->SetFocus(false);
 29018:     }
 57526:   }
 29018: 
 29018:   // if switching to a new document, first fire the focus event on the
 29018:   // document and then the window.
 29018:   if (aIsNewDocument) {
 29018:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(aWindow->GetExtantDocument());
 29452:     if (doc)
 29018:       SendFocusOrBlurEvent(NS_FOCUS_CONTENT, presShell, doc,
 33344:                            doc, aFlags & FOCUSMETHOD_MASK, aWindowRaised);
 29018:     if (mFocusedWindow == aWindow && mFocusedContent == nsnull)
 29018:       SendFocusOrBlurEvent(NS_FOCUS_CONTENT, presShell, doc,
 33344:                            aWindow, aFlags & FOCUSMETHOD_MASK, aWindowRaised);
 29018:   }
 29018: 
 29018:   // check to ensure that the element is still focusable, and that nothing
 29018:   // else was focused during the events above.
 29018:   if (CheckIfFocusable(aContent, aFlags) &&
 29018:       mFocusedWindow == aWindow && mFocusedContent == nsnull) {
 29018:     mFocusedContent = aContent;
 56051: 
 56051:     nsIContent* focusedNode = aWindow->GetFocusedNode();
 79445:     bool isRefocus = focusedNode && focusedNode->IsEqualTo(aContent);
 56051: 
 29018:     aWindow->SetFocusedNode(aContent, focusMethod);
 29018: 
 79445:     bool sendFocusEvent =
 41068:       aContent && aContent->IsInDoc() && !IsNonFocusableRoot(aContent);
 64121:     nsPresContext* presContext = presShell->GetPresContext();
 41068:     if (sendFocusEvent) {
 29018:       // if the focused element changed, scroll it into view
 29018:       if (aFocusChanged)
 29018:         ScrollIntoView(presShell, aContent, aFlags);
 29018: 
 80486:       NotifyFocusStateChange(aContent, aWindow->ShouldShowFocusRing(), true);
 29018: 
 73590:       // if this is an object/plug-in/remote browser, focus its widget.  Note that we might
 36657:       // no longer be in the same document, due to the events we fired above when
 36657:       // aIsNewDocument.
 73590:       if (presShell->GetDocument() == aContent->GetDocument()) {
 87215:         if (aAdjustWidgets && objectFrameWidget && !sTestMode)
 80486:           objectFrameWidget->SetFocus(false);
 73590: 
 73590:         // if the object being focused is a remote browser, activate remote content
 73590:         TabParent* remote = GetRemoteForContent(aContent);
 73590:         if (remote) {
 73590:           remote->Activate();
 73590: #ifdef DEBUG_FOCUS
 73590:           printf("*Remote browser activated\n");
 73590: #endif
 73590:         }
 36657:       }
 29018: 
 82841:       nsIMEStateManager::OnChangeFocus(presContext, aContent,
 82841:                                        GetFocusMoveActionCause(aFlags));
 29018: 
 29018:       // as long as this focus wasn't because a window was raised, update the
 29018:       // commands
 29018:       // XXXndeakin P2 someone could adjust the focus during the update
 29018:       if (!aWindowRaised)
 29018:         aWindow->UpdateCommands(NS_LITERAL_STRING("focus"));
 29018: 
 56051:       SendFocusOrBlurEvent(NS_FOCUS_CONTENT, presShell,
 56051:                            aContent->GetCurrentDoc(),
 56051:                            aContent, aFlags & FOCUSMETHOD_MASK,
 56051:                            aWindowRaised, isRefocus);
 29018: 
 29018:       nsIMEStateManager::OnTextStateFocus(presContext, aContent);
 41068:     } else {
 41068:       nsIMEStateManager::OnTextStateBlur(presContext, nsnull);
 82840:       nsIMEStateManager::OnChangeFocus(presContext, nsnull,
 82841:                                        GetFocusMoveActionCause(aFlags));
 41068:       if (!aWindowRaised) {
 41068:         aWindow->UpdateCommands(NS_LITERAL_STRING("focus"));
 41068:       }
 29018:     }
 29018:   }
 29018:   else {
 57526:     // If the window focus event (fired above when aIsNewDocument) caused
 57526:     // the plugin not to be focusable, update the system focus by focusing
 57526:     // the root widget.
 57526:     if (aAdjustWidgets && objectFrameWidget &&
 87215:         mFocusedWindow == aWindow && mFocusedContent == nsnull &&
 87215:         !sTestMode) {
 57526:       nsIViewManager* vm = presShell->GetViewManager();
 57526:       if (vm) {
 57526:         nsCOMPtr<nsIWidget> widget;
 57526:         vm->GetRootWidget(getter_AddRefs(widget));
 57526:         if (widget)
 80486:           widget->SetFocus(false);
 57526:       }
 57526:     }
 57526: 
 29018:     nsPresContext* presContext = presShell->GetPresContext();
 29018:     nsIMEStateManager::OnTextStateBlur(presContext, nsnull);
 82840:     nsIMEStateManager::OnChangeFocus(presContext, nsnull,
 82841:                                      GetFocusMoveActionCause(aFlags));
 29018: 
 29018:     if (!aWindowRaised)
 29018:       aWindow->UpdateCommands(NS_LITERAL_STRING("focus"));
 29018:   }
 29018: 
 29018:   // update the caret visibility and position to match the newly focused
 29018:   // element. However, don't update the position if this was a focus due to a
 29018:   // mouse click as the selection code would already have moved the caret as
 29018:   // needed. If this is a different document than was focused before, also
 29018:   // update the caret's visibility. If this is the same document, the caret
 29018:   // visibility should be the same as before so there is no need to update it.
 29018:   if (mFocusedContent == aContent)
 29018:     UpdateCaret(aFocusChanged && !(aFlags & FLAG_BYMOUSE), aIsNewDocument,
 29018:                 mFocusedContent);
 29018: 
 29018:   if (clearFirstFocusEvent)
 29018:     mFirstFocusEvent = nsnull;
 29018: }
 29018: 
 36462: class FocusBlurEvent : public nsRunnable
 36462: {
 36462: public:
 36462:   FocusBlurEvent(nsISupports* aTarget, PRUint32 aType,
 79445:                  nsPresContext* aContext, bool aWindowRaised,
 79445:                  bool aIsRefocus)
 36462:   : mTarget(aTarget), mType(aType), mContext(aContext),
 56051:     mWindowRaised(aWindowRaised), mIsRefocus(aIsRefocus) {}
 36462: 
 36462:   NS_IMETHOD Run()
 36462:   {
 80486:     nsFocusEvent event(true, mType);
 36462:     event.flags |= NS_EVENT_FLAG_CANT_BUBBLE;
 36462:     event.fromRaise = mWindowRaised;
 56051:     event.isRefocus = mIsRefocus;
 36462:     return nsEventDispatcher::Dispatch(mTarget, mContext, &event);
 36462:   }
 36462: 
 36462:   nsCOMPtr<nsISupports>   mTarget;
 36462:   PRUint32                mType;
 39823:   nsRefPtr<nsPresContext> mContext;
 79445:   bool                    mWindowRaised;
 79445:   bool                    mIsRefocus;
 36462: };
 36462: 
 29018: void
 29018: nsFocusManager::SendFocusOrBlurEvent(PRUint32 aType,
 29018:                                      nsIPresShell* aPresShell,
 29018:                                      nsIDocument* aDocument,
 29018:                                      nsISupports* aTarget,
 33344:                                      PRUint32 aFocusMethod,
 79445:                                      bool aWindowRaised,
 79445:                                      bool aIsRefocus)
 29018: {
 29018:   NS_ASSERTION(aType == NS_FOCUS_CONTENT || aType == NS_BLUR_CONTENT,
 29018:                "Wrong event type for SendFocusOrBlurEvent");
 29018: 
 72326:   nsCOMPtr<nsIDOMEventTarget> eventTarget = do_QueryInterface(aTarget);
 29018: 
 29018:   // for focus events, if this event was from a mouse or key and event
 29018:   // handling on the document is suppressed, queue the event and fire it
 29018:   // later. For blur events, a non-zero value would be set for aFocusMethod.
 29452:   if (aFocusMethod && aDocument && aDocument->EventHandlingSuppressed()) {
 33344:     // aFlags is always 0 when aWindowRaised is true so this won't be called
 33344:     // on a window raise.
 33344:     NS_ASSERTION(!aWindowRaised, "aWindowRaised should not be set");
 33344: 
 29018:     for (PRUint32 i = mDelayedBlurFocusEvents.Length(); i > 0; --i) {
 29018:       // if this event was already queued, remove it and append it to the end
 29018:       if (mDelayedBlurFocusEvents[i - 1].mType == aType &&
 29018:           mDelayedBlurFocusEvents[i - 1].mPresShell == aPresShell &&
 29018:           mDelayedBlurFocusEvents[i - 1].mDocument == aDocument &&
 29018:           mDelayedBlurFocusEvents[i - 1].mTarget == eventTarget) {
 29018:         mDelayedBlurFocusEvents.RemoveElementAt(i - 1);
 29018:       }
 29018:     }
 29018: 
 29018:     mDelayedBlurFocusEvents.AppendElement(
 29018:       nsDelayedBlurOrFocusEvent(aType, aPresShell, aDocument, eventTarget));
 29018:     return;
 29018:   }
 29018: 
 79384: #ifdef ACCESSIBILITY
 79384:   nsAccessibilityService* accService = GetAccService();
 79384:   if (accService) {
 79384:     if (aType == NS_FOCUS_CONTENT)
 79384:       accService->NotifyOfDOMFocus(aTarget);
 79384:     else
 79384:       accService->NotifyOfDOMBlur(aTarget);
 79384:   }
 79384: #endif
 79384: 
 36462:   nsContentUtils::AddScriptRunner(
 36462:     new FocusBlurEvent(aTarget, aType, aPresShell->GetPresContext(),
 56051:                        aWindowRaised, aIsRefocus));
 29018: }
 29018: 
 29018: void
 29018: nsFocusManager::ScrollIntoView(nsIPresShell* aPresShell,
 29018:                                nsIContent* aContent,
 29018:                                PRUint32 aFlags)
 29018: {
 29018:   // if the noscroll flag isn't set, scroll the newly focused element into view
 29018:   if (!(aFlags & FLAG_NOSCROLL))
 29018:     aPresShell->ScrollContentIntoView(aContent,
 93554:                                       nsIPresShell::ScrollAxis(
 93554:                                         nsIPresShell::SCROLL_MINIMUM,
 93554:                                         nsIPresShell::SCROLL_IF_NOT_VISIBLE),
 93554:                                       nsIPresShell::ScrollAxis(
 93554:                                         nsIPresShell::SCROLL_MINIMUM,
 93554:                                         nsIPresShell::SCROLL_IF_NOT_VISIBLE),
 56647:                                       nsIPresShell::SCROLL_OVERFLOW_HIDDEN);
 29018: }
 29018: 
 29018: 
 29018: void
 29018: nsFocusManager::RaiseWindow(nsPIDOMWindow* aWindow)
 29018: {
 29018:   // don't raise windows that are already raised or are in the process of
 29018:   // being lowered
 30217:   if (!aWindow || aWindow == mActiveWindow || aWindow == mWindowBeingLowered)
 29018:     return;
 29018: 
 87215:   if (sTestMode) {
 87215:     // In test mode, emulate the existing window being lowered and the new
 87215:     // window being raised.
 87215:     if (mActiveWindow)
 87215:       WindowLowered(mActiveWindow);
 87215:     WindowRaised(aWindow);
 87215:     return;
 87215:   }
 87215: 
 33769: #if defined(XP_WIN) || defined(XP_OS2)
 30217:   // Windows would rather we focus the child widget, otherwise, the toplevel
 30217:   // widget will always end up being focused. Fortunately, focusing the child
 30217:   // widget will also have the effect of raising the window this widget is in.
 30217:   // But on other platforms, we can just focus the toplevel widget to raise
 30217:   // the window.
 30217:   nsCOMPtr<nsPIDOMWindow> childWindow;
 80486:   GetFocusedDescendant(aWindow, true, getter_AddRefs(childWindow));
 30217:   if (!childWindow)
 30217:     childWindow = aWindow;
 30217: 
 30217:   nsCOMPtr<nsIDocShell> docShell = aWindow->GetDocShell();
 30217:   if (!docShell)
 30217:     return;
 30217: 
 30217:   nsCOMPtr<nsIPresShell> presShell;
 30217:   docShell->GetPresShell(getter_AddRefs(presShell));
 30217:   if (!presShell)
 30217:     return;
 30217: 
 30217:   nsIViewManager* vm = presShell->GetViewManager();
 30217:   if (vm) {
 30217:     nsCOMPtr<nsIWidget> widget;
 30530:     vm->GetRootWidget(getter_AddRefs(widget));
 30217:     if (widget)
 80486:       widget->SetFocus(true);
 30217:   }
 30217: #else
 29018:   nsCOMPtr<nsIWebNavigation> webnav = do_GetInterface(aWindow);
 29018:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin = do_QueryInterface(webnav);
 29018:   if (treeOwnerAsWin) {
 29018:     nsCOMPtr<nsIWidget> widget;
 29018:     treeOwnerAsWin->GetMainWidget(getter_AddRefs(widget));
 29018:     if (widget)
 80486:       widget->SetFocus(true);
 29018:   }
 30217: #endif
 29018: }
 29018: 
 29018: void
 79445: nsFocusManager::UpdateCaret(bool aMoveCaretToFocus,
 79445:                             bool aUpdateVisibility,
 29018:                             nsIContent* aContent)
 29018: {
 29018: #ifdef DEBUG_FOCUS
 29018:   printf("Update Caret: %d %d\n", aMoveCaretToFocus, aUpdateVisibility);
 29018: #endif
 29018: 
 29018:   if (!mFocusedWindow)
 29018:     return;
 29018: 
 29018:   // this is called when a document is focused or when the caretbrowsing
 29018:   // preference is changed
 29018:   nsCOMPtr<nsIDocShell> focusedDocShell = mFocusedWindow->GetDocShell();
 29018:   nsCOMPtr<nsIDocShellTreeItem> dsti = do_QueryInterface(focusedDocShell);
 29018:   if (!dsti)
 29018:     return;
 29018: 
 29018:   PRInt32 itemType;
 29018:   dsti->GetItemType(&itemType);
 29018:   if (itemType == nsIDocShellTreeItem::typeChrome)
 29018:     return;  // Never browse with caret in chrome
 29018: 
 79445:   bool browseWithCaret =
 70840:     Preferences::GetBool("accessibility.browsewithcaret");
 29018: 
 29018:   nsCOMPtr<nsIPresShell> presShell;
 29018:   focusedDocShell->GetPresShell(getter_AddRefs(presShell));
 29018:   if (!presShell)
 29018:     return;
 29018: 
 29018:   // If this is an editable document which isn't contentEditable, or a
 29018:   // contentEditable document and the node to focus is contentEditable,
 29018:   // return, so that we don't mess with caret visibility.
 79445:   bool isEditable = false;
 29018:   nsCOMPtr<nsIEditorDocShell> editorDocShell(do_QueryInterface(dsti));
 29018:   if (editorDocShell) {
 29018:     editorDocShell->GetEditable(&isEditable);
 29018: 
 29018:     if (isEditable) {
 29018:       nsCOMPtr<nsIHTMLDocument> doc =
 29018:         do_QueryInterface(presShell->GetDocument());
 29018: 
 79445:       bool isContentEditableDoc =
 29018:         doc && doc->GetEditingState() == nsIHTMLDocument::eContentEditable;
 29018: 
 79445:       bool isFocusEditable =
 29018:         aContent && aContent->HasFlag(NODE_IS_EDITABLE);
 29018:       if (!isContentEditableDoc || isFocusEditable)
 29018:         return;
 29018:     }
 29018:   }
 29018: 
 29018:   if (!isEditable && aMoveCaretToFocus)
 29018:     MoveCaretToFocus(presShell, aContent);
 29018: 
 29018:   if (!aUpdateVisibility)
 29018:     return;
 29018: 
 29018:   // XXXndeakin this doesn't seem right. It should be checking for this only
 29018:   // on the nearest ancestor frame which is a chrome frame. But this is
 29018:   // what the existing code does, so just leave it for now.
 29018:   if (!browseWithCaret) {
 29018:     nsCOMPtr<nsIContent> docContent =
 29018:       do_QueryInterface(mFocusedWindow->GetFrameElementInternal());
 29018:     if (docContent)
 29018:       browseWithCaret = docContent->AttrValueIs(kNameSpaceID_None,
 29018:                                                 nsGkAtoms::showcaret,
 29018:                                                 NS_LITERAL_STRING("true"),
 29018:                                                 eCaseMatters);
 29018:   }
 29018: 
 29018:   SetCaretVisible(presShell, browseWithCaret, aContent);
 29018: }
 29018: 
 29018: void
 29018: nsFocusManager::MoveCaretToFocus(nsIPresShell* aPresShell, nsIContent* aContent)
 29018: {
 69898:   // domDoc is a document interface we can create a range with
 69898:   nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(aPresShell->GetDocument());
 69898:   if (domDoc) {
 70097:     nsRefPtr<nsFrameSelection> frameSelection = aPresShell->FrameSelection();
 29018:     nsCOMPtr<nsISelection> domSelection = frameSelection->
 29018:       GetSelection(nsISelectionController::SELECTION_NORMAL);
 29018:     if (domSelection) {
 29018:       nsCOMPtr<nsIDOMNode> currentFocusNode(do_QueryInterface(aContent));
 29018:       // First clear the selection. This way, if there is no currently focused
 29018:       // content, the selection will just be cleared.
 29018:       domSelection->RemoveAllRanges();
 29018:       if (currentFocusNode) {
 29018:         nsCOMPtr<nsIDOMRange> newRange;
 69898:         nsresult rv = domDoc->CreateRange(getter_AddRefs(newRange));
 29018:         if (NS_SUCCEEDED(rv)) {
 29018:           // Set the range to the start of the currently focused node
 29018:           // Make sure it's collapsed
 29018:           newRange->SelectNodeContents(currentFocusNode);
 29018:           nsCOMPtr<nsIDOMNode> firstChild;
 29018:           currentFocusNode->GetFirstChild(getter_AddRefs(firstChild));
 29018:           if (!firstChild ||
 29018:               aContent->IsNodeOfType(nsINode::eHTML_FORM_CONTROL)) {
 29018:             // If current focus node is a leaf, set range to before the
 29018:             // node by using the parent as a container.
 29018:             // This prevents it from appearing as selected.
 29018:             newRange->SetStartBefore(currentFocusNode);
 29018:             newRange->SetEndBefore(currentFocusNode);
 29018:           }
 29018:           domSelection->AddRange(newRange);
 29018:           domSelection->CollapseToStart();
 29018:         }
 29018:       }
 29018:     }
 29018:   }
 29018: }
 29018: 
 29018: nsresult
 29018: nsFocusManager::SetCaretVisible(nsIPresShell* aPresShell,
 79445:                                 bool aVisible,
 29018:                                 nsIContent* aContent)
 29018: {
 29018:   // When browsing with caret, make sure caret is visible after new focus
 29018:   // Return early if there is no caret. This can happen for the testcase
 29018:   // for bug 308025 where a window is closed in a blur handler.
 40045:   nsRefPtr<nsCaret> caret = aPresShell->GetCaret();
 29018:   if (!caret)
 29018:     return NS_OK;
 29018: 
 79445:   bool caretVisible = false;
 29018:   caret->GetCaretVisible(&caretVisible);
 29018:   if (!aVisible && !caretVisible)
 29018:     return NS_OK;
 29018: 
 70097:   nsRefPtr<nsFrameSelection> frameSelection;
 29018:   if (aContent) {
 36657:     NS_ASSERTION(aContent->GetDocument() == aPresShell->GetDocument(),
 36657:                  "Wrong document?");
 36657:     nsIFrame *focusFrame = aContent->GetPrimaryFrame();
 29018:     if (focusFrame)
 29018:       frameSelection = focusFrame->GetFrameSelection();
 29018:   }
 29018: 
 70097:   nsRefPtr<nsFrameSelection> docFrameSelection = aPresShell->FrameSelection();
 29018: 
 29018:   if (docFrameSelection && caret &&
 29018:      (frameSelection == docFrameSelection || !aContent)) {
 29018:     nsISelection* domSelection = docFrameSelection->
 29018:       GetSelection(nsISelectionController::SELECTION_NORMAL);
 29018:     if (domSelection) {
 58616:       // First, hide the caret to prevent attempting to show it in SetCaretDOMSelection
 80486:       caret->SetCaretVisible(false);
 58616: 
 58616:       // Tell the caret which selection to use
 29018:       caret->SetCaretDOMSelection(domSelection);
 29018: 
 29018:       // In content, we need to set the caret. The only special case is edit
 29018:       // fields, which have a different frame selection from the document.
 29018:       // They will take care of making the caret visible themselves.
 29018: 
 29018:       nsCOMPtr<nsISelectionController> selCon(do_QueryInterface(aPresShell));
 29018:       if (!selCon)
 29018:         return NS_ERROR_FAILURE;
 29018: 
 29018:       selCon->SetCaretEnabled(aVisible);
 29018:       caret->SetCaretVisible(aVisible);
 29018:     }
 29018:   }
 29018: 
 29018:   return NS_OK;
 29018: }
 29018: 
 29018: nsresult
 29018: nsFocusManager::GetSelectionLocation(nsIDocument* aDocument,
 29018:                                      nsIPresShell* aPresShell,
 29018:                                      nsIContent **aStartContent,
 29018:                                      nsIContent **aEndContent)
 29018: {
 29018:   *aStartContent = *aEndContent = nsnull;
 29018:   nsresult rv = NS_ERROR_FAILURE;
 29018: 
 29018:   nsPresContext* presContext = aPresShell->GetPresContext();
 29018:   NS_ASSERTION(presContext, "mPresContent is null!!");
 29018: 
 70097:   nsRefPtr<nsFrameSelection> frameSelection = aPresShell->FrameSelection();
 29018: 
 29018:   nsCOMPtr<nsISelection> domSelection;
 29018:   if (frameSelection) {
 29018:     domSelection = frameSelection->
 29018:       GetSelection(nsISelectionController::SELECTION_NORMAL);
 29018:   }
 29018: 
 29018:   nsCOMPtr<nsIDOMNode> startNode, endNode;
 79445:   bool isCollapsed = false;
 29018:   nsCOMPtr<nsIContent> startContent, endContent;
 29018:   PRInt32 startOffset = 0;
 29018:   if (domSelection) {
 29018:     domSelection->GetIsCollapsed(&isCollapsed);
 29018:     nsCOMPtr<nsIDOMRange> domRange;
 29018:     rv = domSelection->GetRangeAt(0, getter_AddRefs(domRange));
 29018:     if (domRange) {
 29018:       domRange->GetStartContainer(getter_AddRefs(startNode));
 29018:       domRange->GetEndContainer(getter_AddRefs(endNode));
 29018:       domRange->GetStartOffset(&startOffset);
 29018: 
 29018:       nsIContent *childContent = nsnull;
 29018: 
 29018:       startContent = do_QueryInterface(startNode);
 41639:       if (startContent && startContent->IsElement()) {
 29018:         NS_ASSERTION(startOffset >= 0, "Start offset cannot be negative");  
 29018:         childContent = startContent->GetChildAt(startOffset);
 29018:         if (childContent) {
 29018:           startContent = childContent;
 29018:         }
 29018:       }
 29018: 
 29018:       endContent = do_QueryInterface(endNode);
 41639:       if (endContent && endContent->IsElement()) {
 29018:         PRInt32 endOffset = 0;
 29018:         domRange->GetEndOffset(&endOffset);
 29018:         NS_ASSERTION(endOffset >= 0, "End offset cannot be negative");
 29018:         childContent = endContent->GetChildAt(endOffset);
 29018:         if (childContent) {
 29018:           endContent = childContent;
 29018:         }
 29018:       }
 29018:     }
 29018:   }
 29018:   else {
 29018:     rv = NS_ERROR_INVALID_ARG;
 29018:   }
 29018: 
 29018:   nsIFrame *startFrame = nsnull;
 29018:   if (startContent) {
 36657:     startFrame = startContent->GetPrimaryFrame();
 29018:     if (isCollapsed) {
 29018:       // Next check to see if our caret is at the very end of a node
 29018:       // If so, the caret is actually sitting in front of the next
 29018:       // logical frame's primary node - so for this case we need to
 29018:       // change caretContent to that node.
 29018: 
 71773:       if (startContent->NodeType() == nsIDOMNode::TEXT_NODE) {
 29018:         nsAutoString nodeValue;
 71773:         startContent->AppendTextTo(nodeValue);
 29018: 
 79445:         bool isFormControl =
 29018:           startContent->IsNodeOfType(nsINode::eHTML_FORM_CONTROL);
 29018: 
 29018:         if (nodeValue.Length() == (PRUint32)startOffset && !isFormControl &&
 41634:             startContent != aDocument->GetRootElement()) {
 29018:           // Yes, indeed we were at the end of the last node
 29018:           nsCOMPtr<nsIFrameEnumerator> frameTraversal;
 29018:           nsresult rv = NS_NewFrameTraversal(getter_AddRefs(frameTraversal),
 29018:                                              presContext, startFrame,
 29018:                                              eLeaf,
 80486:                                              false, // aVisual
 80486:                                              false, // aLockInScrollView
 80486:                                              true      // aFollowOOFs
 29018:                                              );
 29018:           NS_ENSURE_SUCCESS(rv, rv);
 29018: 
 29018:           nsIFrame *newCaretFrame = nsnull;
 29018:           nsCOMPtr<nsIContent> newCaretContent = startContent;
 79445:           bool endOfSelectionInStartNode(startContent == endContent);
 29018:           do {
 29018:             // Continue getting the next frame until the primary content for the frame
 29018:             // we are on changes - we don't want to be stuck in the same place
 29018:             frameTraversal->Next();
 31380:             newCaretFrame = static_cast<nsIFrame*>(frameTraversal->CurrentItem());
 29018:             if (nsnull == newCaretFrame)
 29018:               break;
 29018:             newCaretContent = newCaretFrame->GetContent();            
 29018:           } while (!newCaretContent || newCaretContent == startContent);
 29018: 
 29018:           if (newCaretFrame && newCaretContent) {
 29018:             // If the caret is exactly at the same position of the new frame,
 29018:             // then we can use the newCaretFrame and newCaretContent for our position
 40045:             nsRefPtr<nsCaret> caret = aPresShell->GetCaret();
 29018:             nsRect caretRect;
 39425:             nsIFrame *frame = caret->GetGeometry(domSelection, &caretRect);
 39425:             if (frame) {
 47148:               nsPoint caretWidgetOffset;
 47148:               nsIWidget *widget = frame->GetNearestWidget(caretWidgetOffset);
 47148:               caretRect.MoveBy(caretWidgetOffset);
 39425:               nsPoint newCaretOffset;
 47148:               nsIWidget *newCaretWidget = newCaretFrame->GetNearestWidget(newCaretOffset);
 47148:               if (widget == newCaretWidget && caretRect.y == newCaretOffset.y &&
 39425:                   caretRect.x == newCaretOffset.x) {
 29018:                 // The caret is at the start of the new element.
 29018:                 startFrame = newCaretFrame;
 29018:                 startContent = newCaretContent;
 29018:                 if (endOfSelectionInStartNode) {
 29018:                   endContent = newCaretContent; // Ensure end of selection is not before start
 29018:                 }
 29018:               }
 29018:             }
 29018:           }
 29018:         }
 29018:       }
 29018:     }
 39425:   }
 29018: 
 29018:   *aStartContent = startContent;
 29018:   *aEndContent = endContent;
 29018:   NS_IF_ADDREF(*aStartContent);
 29018:   NS_IF_ADDREF(*aEndContent);
 29018: 
 29018:   return rv;
 29018: }
 29018: 
 29018: nsresult
 29018: nsFocusManager::DetermineElementToMoveFocus(nsPIDOMWindow* aWindow,
 29018:                                             nsIContent* aStartContent,
 90009:                                             PRInt32 aType, bool aNoParentTraversal,
 29018:                                             nsIContent** aNextContent)
 29018: {
 29018:   *aNextContent = nsnull;
 29018: 
 29018:   nsCOMPtr<nsIDocShell> docShell = aWindow->GetDocShell();
 29018:   if (!docShell)
 29018:     return NS_OK;
 29018: 
 29018:   nsCOMPtr<nsIContent> startContent = aStartContent;
 90842:   if (!startContent && aType != MOVEFOCUS_CARET) {
 90842:     if (aType == MOVEFOCUS_FORWARDDOC || aType == MOVEFOCUS_BACKWARDDOC) {
 90842:       // When moving between documents, make sure to get the right
 90842:       // starting content in a descendant.
 90842:       nsCOMPtr<nsPIDOMWindow> focusedWindow;
 90842:       startContent = GetFocusedDescendant(aWindow, true, getter_AddRefs(focusedWindow));
 90842:     }
 90842:     else {
 29018:       startContent = aWindow->GetFocusedNode();
 90842:     }
 90842:   }
 29018: 
 29018:   nsCOMPtr<nsIDocument> doc;
 29018:   if (startContent)
 29018:     doc = startContent->GetCurrentDoc();
 29018:   else
 29018:     doc = do_QueryInterface(aWindow->GetExtantDocument());
 29018:   if (!doc)
 29018:     return NS_OK;
 29018: 
 78125:   LookAndFeel::GetInt(LookAndFeel::eIntID_TabFocusModel,
 78125:                       &nsIContent::sTabFocusModel);
 29018: 
 29018:   if (aType == MOVEFOCUS_ROOT) {
 80486:     NS_IF_ADDREF(*aNextContent = GetRootForFocus(aWindow, doc, false, false));
 29018:     return NS_OK;
 29018:   }
 29018:   if (aType == MOVEFOCUS_FORWARDDOC) {
 90842:     NS_IF_ADDREF(*aNextContent = GetNextTabbableDocument(startContent, true));
 29018:     return NS_OK;
 29018:   }
 29018:   if (aType == MOVEFOCUS_BACKWARDDOC) {
 90842:     NS_IF_ADDREF(*aNextContent = GetNextTabbableDocument(startContent, false));
 29018:     return NS_OK;
 29018:   }
 29018:   
 41634:   nsIContent* rootContent = doc->GetRootElement();
 29018:   NS_ENSURE_TRUE(rootContent, NS_OK);
 29018: 
 46225:   nsIPresShell *presShell = doc->GetShell();
 29018:   NS_ENSURE_TRUE(presShell, NS_OK);
 29018: 
 29018:   if (aType == MOVEFOCUS_FIRST) {
 29018:     if (!aStartContent)
 29018:       startContent = rootContent;
 29018:     return GetNextTabbableContent(presShell, startContent,
 29018:                                   nsnull, startContent,
 80486:                                   true, 1, false, aNextContent);
 29018:   }
 29018:   if (aType == MOVEFOCUS_LAST) {
 29018:     if (!aStartContent)
 29018:       startContent = rootContent;
 29018:     return GetNextTabbableContent(presShell, startContent,
 29018:                                   nsnull, startContent,
 80486:                                   false, 0, false, aNextContent);
 29018:   }
 29018: 
 79445:   bool forward = (aType == MOVEFOCUS_FORWARD || aType == MOVEFOCUS_CARET);
 79445:   bool doNavigation = true;
 79445:   bool ignoreTabIndex = false;
 29018:   // when a popup is open, we want to ensure that tab navigation occurs only
 29018:   // within the most recently opened panel. If a popup is open, its frame will
 29018:   // be stored in popupFrame.
 29018:   nsIFrame* popupFrame = nsnull;
 29018: 
 29018:   PRInt32 tabIndex = forward ? 1 : 0;
 29018:   if (startContent) {
 36657:     nsIFrame* frame = startContent->GetPrimaryFrame();
 29018:     if (startContent->Tag() == nsGkAtoms::area &&
 33329:         startContent->IsHTML())
 29018:       startContent->IsFocusable(&tabIndex);
 29018:     else if (frame)
 29018:       frame->IsFocusable(&tabIndex, 0);
 35170:     else
 35170:       startContent->IsFocusable(&tabIndex);
 29018: 
 29018:     // if the current element isn't tabbable, ignore the tabindex and just
 29018:     // look for the next element. The root content won't have a tabindex
 29018:     // so just treat this as the beginning of the tab order.
 29018:     if (tabIndex < 0) {
 29018:       tabIndex = 1;
 29018:       if (startContent != rootContent)
 80486:         ignoreTabIndex = true;
 29018:     }
 29018: 
 29018:     // check if the focus is currently inside a popup. Elements such as the
 29018:     // autocomplete widget use the noautofocus attribute to allow the focus to
 29018:     // remain outside the popup when it is opened.
 29018:     if (frame) {
 29018:       popupFrame = nsLayoutUtils::GetClosestFrameOfType(frame,
 29018:                                                         nsGkAtoms::menuPopupFrame);
 29018:     }
 29018: 
 29018:     if (popupFrame) {
 29018:       // Don't navigate outside of a popup, so pretend that the
 29018:       // root content is the popup itself
 29018:       rootContent = popupFrame->GetContent();
 29018:       NS_ASSERTION(rootContent, "Popup frame doesn't have a content node");
 29018:     }
 41068:     else if (!forward) {
 41068:       // If focus moves backward and when current focused node is root
 41068:       // content or <body> element which is editable by contenteditable
 41068:       // attribute, focus should move to its parent document.
 41068:       if (startContent == rootContent) {
 80486:         doNavigation = false;
 41068:       } else {
 41068:         nsIDocument* doc = startContent->GetCurrentDoc();
 41068:         if (startContent ==
 41068:               nsLayoutUtils::GetEditableRootContentByContentEditable(doc)) {
 80486:           doNavigation = false;
 41068:         }
 41068:       }
 29018:     }
 29018:   }
 29018:   else {
 29018: #ifdef MOZ_XUL
 99680:     if (aType != MOVEFOCUS_CARET) {
 29018:       // if there is no focus, yet a panel is open, focus the first item in
 29018:       // the panel
 29018:       nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 29018:       if (pm)
 29018:         popupFrame = pm->GetTopPopup(ePopupTypePanel);
 99680:     }
 29018: #endif
 29018:     if (popupFrame) {
 29018:       rootContent = popupFrame->GetContent();
 29018:       NS_ASSERTION(rootContent, "Popup frame doesn't have a content node");
 29018:       startContent = rootContent;
 29018:     }
 29018:     else {
 29018:       // Otherwise, for content shells, start from the location of the caret.
 29018:       PRInt32 itemType;
 29018:       nsCOMPtr<nsIDocShellTreeItem> shellItem = do_QueryInterface(docShell);
 29018:       shellItem->GetItemType(&itemType);
 29018:       if (itemType != nsIDocShellTreeItem::typeChrome) {
 29018:         nsCOMPtr<nsIContent> endSelectionContent;
 29018:         GetSelectionLocation(doc, presShell,
 29018:                              getter_AddRefs(startContent),
 29018:                              getter_AddRefs(endSelectionContent));
 29018:         // If the selection is on the rootContent, then there is no selection
 29018:         if (startContent == rootContent) {
 29018:           startContent = nsnull;
 29018:         }
 29018: 
 38430:         if (aType == MOVEFOCUS_CARET) {
 38430:           // GetFocusInSelection finds a focusable link near the caret.
 38430:           // If there is no start content though, don't do this to avoid
 38430:           // focusing something unexpected.
 29018:           if (startContent) {
 29018:             GetFocusInSelection(aWindow, startContent,
 29018:                                 endSelectionContent, aNextContent);
 38430:           }
 29018:           return NS_OK;
 29018:         }
 29018: 
 38430:         if (startContent) {
 29018:           // when starting from a selection, we always want to find the next or
 29018:           // previous element in the document. So the tabindex on elements
 29018:           // should be ignored.
 80486:           ignoreTabIndex = true;
 29018:         }
 29018:       }
 29018: 
 29018:       if (!startContent) {
 29018:         // otherwise, just use the root content as the starting point
 29018:         startContent = rootContent;
 29018:         NS_ENSURE_TRUE(startContent, NS_OK);
 29018:       }
 29018:     }
 29018:   }
 29018: 
 29018:   NS_ASSERTION(startContent, "starting content not set");
 29018: 
 29018:   // keep a reference to the starting content. If we find that again, it means
 29018:   // we've iterated around completely and we don't want to adjust the focus.
 29018:   // The skipOriginalContentCheck will be set to true only for the first time
 29018:   // GetNextTabbableContent is called. This ensures that we don't break out
 29018:   // when nothing is focused to start with. Specifically,
 29018:   // GetNextTabbableContent first checks the root content -- which happens to
 29018:   // be the same as the start content -- when nothing is focused and tabbing
 29018:   // forward. Without skipOriginalContentCheck set to true, we'd end up
 29018:   // returning right away and focusing nothing. Luckily, GetNextTabbableContent
 29018:   // will never wrap around on its own, and can only return the original
 29018:   // content when it is called a second time or later.
 79445:   bool skipOriginalContentCheck = true;
 29018:   nsIContent* originalStartContent = startContent;
 29018: 
 29018: #ifdef DEBUG_FOCUS_NAVIGATION
 29018:   PRINTTAGF("Focus Navigation Start Content %s\n", startContent);
 29018:   printf("[Tabindex: %d Ignore: %d]", tabIndex, ignoreTabIndex);
 29018: #endif
 29018: 
 29018:   while (doc) {
 29018:     if (doNavigation) {
 29018:       nsCOMPtr<nsIContent> nextFocus;
 29018:       nsresult rv = GetNextTabbableContent(presShell, rootContent,
 29018:                                            skipOriginalContentCheck ? nsnull : originalStartContent,
 29018:                                            startContent, forward,
 29018:                                            tabIndex, ignoreTabIndex,
 29018:                                            getter_AddRefs(nextFocus));
 29018:       NS_ENSURE_SUCCESS(rv, rv);
 29018: 
 29018:       // found a content node to focus.
 29018:       if (nextFocus) {
 29018: #ifdef DEBUG_FOCUS_NAVIGATION
 29018:         PRINTTAGF("Next Content: %s\n", nextFocus);
 29018: #endif
 29018:         // as long as the found node was not the same as the starting node,
 29018:         // set it as the return value.
 29018:         if (nextFocus != originalStartContent)
 29018:           NS_ADDREF(*aNextContent = nextFocus);
 29018:         return NS_OK;
 29018:       }
 29018: 
 29018:       if (popupFrame) {
 29018:         // in a popup, so start again from the beginning of the popup. However,
 29018:         // if we already started at the beginning, then there isn't anything to
 29018:         // focus, so just return
 29018:         if (startContent != rootContent) {
 29018:           startContent = rootContent;
 29018:           tabIndex = forward ? 1 : 0;
 29018:           continue;
 29018:         }
 29018:         return NS_OK;
 29018:       }
 29018:     }
 29018: 
 80486:     doNavigation = true;
 80486:     skipOriginalContentCheck = false;
 80486:     ignoreTabIndex = false;
 29018: 
 90009:     if (aNoParentTraversal) {
 90009:       startContent = rootContent;
 90009:       tabIndex = forward ? 1 : 0;
 90009:       continue;
 90009:     }
 90009: 
 29018:     // reached the beginning or end of the document. Traverse up to the parent
 29018:     // document and try again.
 29018:     nsCOMPtr<nsIDocShellTreeItem> dsti = do_QueryInterface(docShell);
 29018: 
 29018:     nsCOMPtr<nsIDocShellTreeItem> docShellParent;
 29018:     dsti->GetParent(getter_AddRefs(docShellParent));
 29018:     if (docShellParent) {
 29018:       // move up to the parent shell and try again from there.
 29018: 
 29018:       // first, get the frame element this window is inside.
 29018:       nsCOMPtr<nsPIDOMWindow> piWindow = do_GetInterface(docShell);
 29018:       NS_ENSURE_TRUE(piWindow, NS_ERROR_FAILURE);
 29018: 
 29018:       // Next, retrieve the parent docshell, document and presshell.
 29018:       docShell = do_QueryInterface(docShellParent);
 29018:       NS_ENSURE_TRUE(docShell, NS_ERROR_FAILURE);
 29018: 
 29018:       nsCOMPtr<nsPIDOMWindow> piParentWindow = do_GetInterface(docShellParent);
 29018:       NS_ENSURE_TRUE(piParentWindow, NS_ERROR_FAILURE);
 29018:       doc = do_QueryInterface(piParentWindow->GetExtantDocument());
 29018:       NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
 29018: 
 46225:       presShell = doc->GetShell();
 29018: 
 41634:       rootContent = doc->GetRootElement();
 29018:       startContent = do_QueryInterface(piWindow->GetFrameElementInternal());
 29018:       if (startContent) {
 36657:         nsIFrame* frame = startContent->GetPrimaryFrame();
 29018:         if (!frame)
 29018:           return NS_OK;
 29018: 
 29018:         frame->IsFocusable(&tabIndex, 0);
 29018:         if (tabIndex < 0) {
 29018:           tabIndex = 1;
 80486:           ignoreTabIndex = true;
 29018:         }
 29018: 
 29018:         // if the frame is inside a popup, make sure to scan only within the
 29018:         // popup. This handles the situation of tabbing amongst elements
 29018:         // inside an iframe which is itself inside a popup. Otherwise,
 29018:         // navigation would move outside the popup when tabbing outside the
 29018:         // iframe.
 29018:         popupFrame = nsLayoutUtils::GetClosestFrameOfType(frame,
 29018:                                                           nsGkAtoms::menuPopupFrame);
 29018:         if (popupFrame) {
 29018:           rootContent = popupFrame->GetContent();
 29018:           NS_ASSERTION(rootContent, "Popup frame doesn't have a content node");
 29018:         }
 29018:       }
 29018:       else {
 29018:         startContent = rootContent;
 29018:         tabIndex = forward ? 1 : 0;
 29018:       }
 29018:     }
 29018:     else {
 29018:       // no parent, so call the tree owner. This will tell the embedder that
 29018:       // it should take the focus.
 79445:       bool tookFocus;
 29018:       docShell->TabToTreeOwner(forward, &tookFocus);
 29018:       // if the tree owner, took the focus, blur the current content
 29018:       if (tookFocus) {
 29018:         nsCOMPtr<nsPIDOMWindow> window = do_GetInterface(docShell);
 29018:         if (window->GetFocusedNode() == mFocusedContent)
 80486:           Blur(mFocusedWindow, nsnull, true, true);
 29018:         else
 29018:           window->SetFocusedNode(nsnull);
 29018:         return NS_OK;
 29018:       }
 29018: 
 29018:       // reset the tab index and start again from the beginning or end
 29018:       startContent = rootContent;
 29018:       tabIndex = forward ? 1 : 0;
 29018:     }
 29018: 
 29018:     // wrapped all the way around and didn't find anything to move the focus
 29018:     // to, so just break out
 29018:     if (startContent == originalStartContent)
 29018:       break;
 29018:   }
 29018: 
 29018:   return NS_OK;
 29018: }
 29018: 
 29018: nsresult
 29018: nsFocusManager::GetNextTabbableContent(nsIPresShell* aPresShell,
 29018:                                        nsIContent* aRootContent,
 29018:                                        nsIContent* aOriginalStartContent,
 29018:                                        nsIContent* aStartContent,
 79445:                                        bool aForward,
 29018:                                        PRInt32 aCurrentTabIndex,
 79445:                                        bool aIgnoreTabIndex,
 29018:                                        nsIContent** aResultContent)
 29018: {
 29018:   *aResultContent = nsnull;
 29018: 
 35170:   nsCOMPtr<nsIContent> startContent = aStartContent;
 35170:   if (!startContent)
 29018:     return NS_OK;
 29018: 
 29018: #ifdef DEBUG_FOCUS_NAVIGATION
 29018:   PRINTTAGF("GetNextTabbable: %s", aStartContent);
 29018:   printf(" tabindex: %d\n", aCurrentTabIndex);
 29018: #endif
 29018: 
 29018:   nsPresContext* presContext = aPresShell->GetPresContext();
 29018: 
 79445:   bool getNextFrame = true;
 35170:   nsCOMPtr<nsIContent> iterStartContent = aStartContent;
 29018:   while (1) {
 36657:     nsIFrame* startFrame = iterStartContent->GetPrimaryFrame();
 35170:     // if there is no frame, look for another content node that has a frame
 35170:     if (!startFrame) {
 35170:       // if the root content doesn't have a frame, just return
 35170:       if (iterStartContent == aRootContent)
 29018:         return NS_OK;
 35170: 
 35170:       // look for the next or previous content node in tree order
 69185:       iterStartContent = aForward ? iterStartContent->GetNextNode() : iterStartContent->GetPreviousContent();
 35170:       // we've already skipped over the initial focused content, so we
 35170:       // don't want to traverse frames.
 80486:       getNextFrame = false;
 35170:       if (iterStartContent)
 35170:         continue;
 35170: 
 35170:       // otherwise, as a last attempt, just look at the root content
 35170:       iterStartContent = aRootContent;
 35170:       continue;
 29018:     }
 29018: 
 29018:     nsCOMPtr<nsIFrameEnumerator> frameTraversal;
 29018:     nsresult rv = NS_NewFrameTraversal(getter_AddRefs(frameTraversal),
 35170:                                        presContext, startFrame,
 29018:                                        ePreOrder,
 80486:                                        false, // aVisual
 80486:                                        false, // aLockInScrollView
 80486:                                        true      // aFollowOOFs
 29018:                                        );
 29018:     NS_ENSURE_SUCCESS(rv, rv);
 29018: 
 35170:     if (iterStartContent == aRootContent) {
 41068:       if (!aForward) {
 29018:         frameTraversal->Last();
 41068:       } else if (aRootContent->IsFocusable()) {
 41068:         frameTraversal->Next();
 41068:       }
 29018:     }
 35170:     else if (getNextFrame &&
 35170:              (!iterStartContent || iterStartContent->Tag() != nsGkAtoms::area ||
 35170:               !iterStartContent->IsHTML())) {
 29018:       // Need to do special check in case we're in an imagemap which has multiple
 29018:       // content nodes per frame, so don't skip over the starting frame.
 29018:       if (aForward)
 29018:         frameTraversal->Next();
 29018:       else
 29018:         frameTraversal->Prev();
 29018:     }
 29018: 
 29018:     // Walk frames to find something tabbable matching mCurrentTabIndex
 29018:     nsIFrame* frame = static_cast<nsIFrame*>(frameTraversal->CurrentItem());
 29018:     while (frame) {
 29018:       // TabIndex not set defaults to 0 for form elements, anchors and other
 29018:       // elements that are normally focusable. Tabindex defaults to -1
 29018:       // for elements that are not normally focusable.
 29018:       // The returned computed tabindex from IsFocusable() is as follows:
 29018:       //          < 0 not tabbable at all
 29018:       //          == 0 in normal tab order (last after positive tabindexed items)
 29018:       //          > 0 can be tabbed to in the order specified by this value
 29018: 
 29018:       PRInt32 tabIndex;
 29018:       frame->IsFocusable(&tabIndex, 0);
 29018: 
 29018: #ifdef DEBUG_FOCUS_NAVIGATION
 29018:       if (frame->GetContent()) {
 29018:         PRINTTAGF("Next Tabbable %s:", frame->GetContent());
 29018:         printf(" with tabindex: %d expected: %d\n", tabIndex, aCurrentTabIndex);
 29018:       }
 29018: #endif
 29018: 
 29018:       nsIContent* currentContent = frame->GetContent();
 29018:       if (tabIndex >= 0) {
 29018:         NS_ASSERTION(currentContent, "IsFocusable set a tabindex for a frame with no content");
 29018:         if (currentContent->Tag() == nsGkAtoms::img &&
 29018:             currentContent->HasAttr(kNameSpaceID_None, nsGkAtoms::usemap)) {
 29018:           // This is an image with a map. Image map areas are not traversed by
 29018:           // nsIFrameTraversal so look for the next or previous area element.
 29018:           nsIContent *areaContent =
 29018:             GetNextTabbableMapArea(aForward, aCurrentTabIndex,
 35170:                                    currentContent, iterStartContent);
 29018:           if (areaContent) {
 29018:             NS_ADDREF(*aResultContent = areaContent);
 29018:             return NS_OK;
 29018:           }
 29018:         }
 29018:         else if (aIgnoreTabIndex || aCurrentTabIndex == tabIndex) {
 29018:           // break out if we've wrapped around to the start again.
 29018:           if (aOriginalStartContent && currentContent == aOriginalStartContent) {
 29018:             NS_ADDREF(*aResultContent = currentContent);
 29018:             return NS_OK;
 29018:           }
 29018: 
 29018:           // found a node with a matching tab index. Check if it is a child
 29018:           // frame. If so, navigate into the child frame instead.
 29018:           nsIDocument* doc = currentContent->GetCurrentDoc();
 29018:           NS_ASSERTION(doc, "content not in document");
 29018:           nsIDocument* subdoc = doc->GetSubDocumentFor(currentContent);
 29018:           if (subdoc) {
 29018:             if (!subdoc->EventHandlingSuppressed()) {
 29018:               if (aForward) {
 29018:                 // when tabbing forward into a frame, return the root
 29018:                 // frame so that the canvas becomes focused.
 29018:                 nsCOMPtr<nsPIDOMWindow> subframe = subdoc->GetWindow();
 29018:                 if (subframe) {
 41068:                   // If the subframe body is editable by contenteditable,
 41068:                   // we should set the editor's root element rather than the
 41068:                   // actual root element.  Otherwise, we should set the focus
 41068:                   // to the root content.
 41068:                   *aResultContent =
 41068:                     nsLayoutUtils::GetEditableRootContentByContentEditable(subdoc);
 41068:                   if (!*aResultContent ||
 41068:                       !((*aResultContent)->GetPrimaryFrame())) {
 41068:                     *aResultContent =
 80486:                       GetRootForFocus(subframe, subdoc, false, true);
 41068:                   }
 29018:                   if (*aResultContent) {
 29018:                     NS_ADDREF(*aResultContent);
 29018:                     return NS_OK;
 29018:                   }
 29018:                 }
 29018:               }
 41634:               Element* rootElement = subdoc->GetRootElement();
 46225:               nsIPresShell* subShell = subdoc->GetShell();
 41634:               if (rootElement && subShell) {
 41634:                 rv = GetNextTabbableContent(subShell, rootElement,
 41634:                                             aOriginalStartContent, rootElement,
 29018:                                             aForward, (aForward ? 1 : 0),
 80486:                                             false, aResultContent);
 29018:                 NS_ENSURE_SUCCESS(rv, rv);
 29018:                 if (*aResultContent)
 29018:                   return NS_OK;
 29018:               }
 29018:             }
 29018:           }
 29018:           // otherwise, use this as the next content node to tab to, unless
 29018:           // this was the element we started on. This would happen for
 29018:           // instance on an element with child frames, where frame navigation
 29018:           // could return the original element again. In that case, just skip
 29018:           // it. Also, if the next content node is the root content, then
 29018:           // return it. This latter case would happen only if someone made a
 29018:           // popup focusable.
 31115:           // Also, when going backwards, check to ensure that the focus
 31115:           // wouldn't be redirected. Otherwise, for example, when an input in
 31115:           // a textbox is focused, the enclosing textbox would be found and
 31115:           // the same inner input would be returned again.
 31115:           else if (currentContent == aRootContent ||
 35170:                    (currentContent != startContent &&
 31115:                     (aForward || !GetRedirectedFocus(currentContent)))) {
 29018:             NS_ADDREF(*aResultContent = currentContent);
 29018:             return NS_OK;
 29018:           }
 29018:         }
 29018:       }
 29018:       else if (aOriginalStartContent && currentContent == aOriginalStartContent) {
 29018:         // not focusable, so return if we have wrapped around to the original
 29018:         // content. This is necessary in case the original starting content was
 29018:         // not focusable.
 29018:         NS_ADDREF(*aResultContent = currentContent);
 29018:         return NS_OK;
 29018:       }
 29018: 
 29018:       // Move to the next or previous frame, but ignore continuation frames
 29018:       // since only the first frame should be involved in focusability.
 29018:       // Otherwise, a loop will occur in the following example:
 29018:       //   <span tabindex="1">...<a/><a/>...</span>
 29018:       // where the text wraps onto multiple lines. Tabbing from the second
 29018:       // link can find one of the span's continuation frames between the link
 29018:       // and the end of the span, and the span would end up getting focused
 29018:       // again.
 29018:       do {
 29018:         if (aForward)
 29018:           frameTraversal->Next();
 29018:         else
 29018:           frameTraversal->Prev();
 29018:         frame = static_cast<nsIFrame*>(frameTraversal->CurrentItem());
 29018:       } while (frame && frame->GetPrevContinuation());
 29018:     }
 29018: 
 29018:     // If already at lowest priority tab (0), end search completely.
 29018:     // A bit counterintuitive but true, tabindex order goes 1, 2, ... 32767, 0
 29018:     if (aCurrentTabIndex == (aForward ? 0 : 1)) {
 29018:       // if going backwards, the canvas should be focused once the beginning
 29018:       // has been reached.
 29018:       if (!aForward) {
 29018:         nsCOMPtr<nsPIDOMWindow> window = GetCurrentWindow(aRootContent);
 29018:         NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
 29018:         NS_IF_ADDREF(*aResultContent =
 80486:                      GetRootForFocus(window, aRootContent->GetCurrentDoc(), false, true));
 29018:       }
 29018:       break;
 29018:     }
 29018: 
 29018:     // continue looking for next highest priority tabindex
 29018:     aCurrentTabIndex = GetNextTabIndex(aRootContent, aCurrentTabIndex, aForward);
 35170:     startContent = iterStartContent = aRootContent;
 29018:   }
 29018: 
 29018:   return NS_OK;
 29018: }
 29018: 
 29018: nsIContent*
 79445: nsFocusManager::GetNextTabbableMapArea(bool aForward,
 29018:                                        PRInt32 aCurrentTabIndex,
 29018:                                        nsIContent* aImageContent,
 29018:                                        nsIContent* aStartContent)
 29018: {
 29018:   nsAutoString useMap;
 29018:   aImageContent->GetAttr(kNameSpaceID_None, nsGkAtoms::usemap, useMap);
 29018: 
 29018:   nsCOMPtr<nsIDocument> doc = aImageContent->GetDocument();
 29018:   if (doc) {
 71031:     nsCOMPtr<nsIContent> mapContent = doc->FindImageMap(useMap);
 71031:     if (!mapContent)
 29018:       return nsnull;
 29018:     PRUint32 count = mapContent->GetChildCount();
 29018:     // First see if the the start content is in this map
 29018: 
 29018:     PRInt32 index = mapContent->IndexOf(aStartContent);
 29018:     PRInt32 tabIndex;
 29018:     if (index < 0 || (aStartContent->IsFocusable(&tabIndex) &&
 29018:                       tabIndex != aCurrentTabIndex)) {
 29018:       // If aStartContent is in this map we must start iterating past it.
 29018:       // We skip the case where aStartContent has tabindex == aStartContent
 29018:       // since the next tab ordered element might be before it
 29018:       // (or after for backwards) in the child list.
 29018:       index = aForward ? -1 : (PRInt32)count;
 29018:     }
 29018: 
 29018:     // GetChildAt will return nsnull if our index < 0 or index >= count
 29018:     nsCOMPtr<nsIContent> areaContent;
 29018:     while ((areaContent = mapContent->GetChildAt(aForward ? ++index : --index)) != nsnull) {
 29018:       if (areaContent->IsFocusable(&tabIndex) && tabIndex == aCurrentTabIndex) {
 29018:         return areaContent;
 29018:       }
 29018:     }
 29018:   }
 29018: 
 29018:   return nsnull;
 29018: }
 29018: 
 29018: PRInt32
 29018: nsFocusManager::GetNextTabIndex(nsIContent* aParent,
 29018:                                 PRInt32 aCurrentTabIndex,
 79445:                                 bool aForward)
 29018: {
 29018:   PRInt32 tabIndex, childTabIndex;
 29018: 
 29018:   if (aForward) {
 29018:     tabIndex = 0;
 88030:     for (nsIContent* child = aParent->GetFirstChild();
 88030:          child;
 88030:          child = child->GetNextSibling()) {
 29018:       childTabIndex = GetNextTabIndex(child, aCurrentTabIndex, aForward);
 29018:       if (childTabIndex > aCurrentTabIndex && childTabIndex != tabIndex) {
 29018:         tabIndex = (tabIndex == 0 || childTabIndex < tabIndex) ? childTabIndex : tabIndex;
 29018:       }
 29018: 
 29018:       nsAutoString tabIndexStr;
 29018:       child->GetAttr(kNameSpaceID_None, nsGkAtoms::tabindex, tabIndexStr);
 29018:       PRInt32 ec, val = tabIndexStr.ToInteger(&ec);
 29018:       if (NS_SUCCEEDED (ec) && val > aCurrentTabIndex && val != tabIndex) {
 29018:         tabIndex = (tabIndex == 0 || val < tabIndex) ? val : tabIndex;
 29018:       }
 29018:     }
 29018:   }
 29018:   else { /* !aForward */
 29018:     tabIndex = 1;
 88030:     for (nsIContent* child = aParent->GetFirstChild();
 88030:          child;
 88030:          child = child->GetNextSibling()) {
 29018:       childTabIndex = GetNextTabIndex(child, aCurrentTabIndex, aForward);
 29018:       if ((aCurrentTabIndex == 0 && childTabIndex > tabIndex) ||
 29018:           (childTabIndex < aCurrentTabIndex && childTabIndex > tabIndex)) {
 29018:         tabIndex = childTabIndex;
 29018:       }
 29018: 
 29018:       nsAutoString tabIndexStr;
 29018:       child->GetAttr(kNameSpaceID_None, nsGkAtoms::tabindex, tabIndexStr);
 29018:       PRInt32 ec, val = tabIndexStr.ToInteger(&ec);
 29018:       if (NS_SUCCEEDED (ec)) {
 29018:         if ((aCurrentTabIndex == 0 && val > tabIndex) ||
 29018:             (val < aCurrentTabIndex && val > tabIndex) ) {
 29018:           tabIndex = val;
 29018:         }
 29018:       }
 29018:     }
 29018:   }
 29018: 
 29018:   return tabIndex;
 29018: }
 29018: 
 29018: nsIContent*
 29018: nsFocusManager::GetRootForFocus(nsPIDOMWindow* aWindow,
 29018:                                 nsIDocument* aDocument,
 79445:                                 bool aIsForDocNavigation,
 79445:                                 bool aCheckVisibility)
 29018: {
 29018:   // the root element's canvas may be focused as long as the document is in a
 29018:   // a non-chrome shell and does not contain a frameset.
 29018:   if (aIsForDocNavigation) {
 29018:     nsCOMPtr<nsIContent> docContent =
 29018:       do_QueryInterface(aWindow->GetFrameElementInternal());
 60230:     // document navigation skips iframes and frames that are specifically non-focusable
 60230:     if (docContent) {
 60230:       if (docContent->Tag() == nsGkAtoms::iframe)
 29018:         return nsnull;
 60230: 
 60230:       nsIFrame* frame = docContent->GetPrimaryFrame();
 60230:       if (!frame || !frame->IsFocusable(nsnull, 0))
 60230:         return nsnull;
 60230:     }
 29018:   }
 29018:   else  {
 29018:     PRInt32 itemType;
 29018:     nsCOMPtr<nsIDocShellTreeItem> shellItem = do_QueryInterface(aWindow->GetDocShell());
 29018:     shellItem->GetItemType(&itemType);
 29018: 
 29018:     if (itemType == nsIDocShellTreeItem::typeChrome)
 29018:       return nsnull;
 29018:   }
 29018: 
 29018:   if (aCheckVisibility && !IsWindowVisible(aWindow))
 29018:     return nsnull;
 29018: 
 41634:   Element *rootElement = aDocument->GetRootElement();
 88030:   if (!rootElement) {
 88030:     return nsnull;
 88030:   }
 88030: 
 41634:   if (aCheckVisibility && !rootElement->GetPrimaryFrame()) {
 29018:     return nsnull;
 29018:   }
 29018: 
 29018:   // Finally, check if this is a frameset
 29018:   nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(aDocument);
 88030:   if (htmlDoc && aDocument->GetHtmlChildElement(nsGkAtoms::frameset)) {
 29018:     return nsnull;
 29018:   }
 29018: 
 41634:   return rootElement;
 29018: }
 29018: 
 73590: TabParent*
 73590: nsFocusManager::GetRemoteForContent(nsIContent* aContent) {
 73590:   if (!aContent ||
 80649:       (aContent->Tag() != nsGkAtoms::browser &&
 80649:        aContent->Tag() != nsGkAtoms::iframe) ||
 73590:       !aContent->IsXUL() ||
 73590:       !aContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::Remote,
 73590:                              nsGkAtoms::_true, eIgnoreCase))
 73590:     return nsnull;
 73590: 
 73590:   nsCOMPtr<nsIFrameLoaderOwner> loaderOwner = do_QueryInterface(aContent);
 73590:   if (!loaderOwner)
 73590:     return nsnull;
 73590: 
 73590:   nsRefPtr<nsFrameLoader> frameLoader = loaderOwner->GetFrameLoader();
 73590:   if (!frameLoader)
 73590:     return nsnull;
 73590: 
 73590:   PBrowserParent* remoteBrowser = frameLoader->GetRemoteBrowser();
 73590:   TabParent* remote = static_cast<TabParent*>(remoteBrowser);
 73590:   return remote;
 73590: }
 73590: 
 29018: void
 29018: nsFocusManager::GetLastDocShell(nsIDocShellTreeItem* aItem,
 29018:                                 nsIDocShellTreeItem** aResult)
 29018: {
 29018:   *aResult = nsnull;
 29018: 
 29018:   nsCOMPtr<nsIDocShellTreeItem> curItem = aItem;
 29018:   while (curItem) {
 29018:     PRInt32 childCount = 0;
 29018:     curItem->GetChildCount(&childCount);
 29018:     if (!childCount) {
 29018:       *aResult = curItem;
 29018:       NS_ADDREF(*aResult);
 29018:       return;
 29018:     }
 29018: 
 29018:     
 29018:     curItem->GetChildAt(childCount - 1, getter_AddRefs(curItem));
 29018:   }
 29018: }
 29018: 
 29018: void
 29018: nsFocusManager::GetNextDocShell(nsIDocShellTreeItem* aItem,
 29018:                                 nsIDocShellTreeItem** aResult)
 29018: {
 29018:   *aResult = nsnull;
 29018: 
 29018:   PRInt32 childCount = 0;
 29018:   aItem->GetChildCount(&childCount);
 29018:   if (childCount) {
 29018:     aItem->GetChildAt(0, aResult);
 29018:     if (*aResult)
 29018:       return;
 29018:   }
 29018: 
 29018:   nsCOMPtr<nsIDocShellTreeItem> curItem = aItem;
 29018:   while (curItem) {
 29018:     nsCOMPtr<nsIDocShellTreeItem> parentItem;
 29018:     curItem->GetParent(getter_AddRefs(parentItem));
 29018:     if (!parentItem)
 29018:       return;
 29018: 
 29018:     // Note that we avoid using GetChildOffset() here because docshell
 29018:     // child offsets can't be trusted to be correct. bug 162283.
 29018:     nsCOMPtr<nsIDocShellTreeItem> iterItem;
 29018:     childCount = 0;
 29018:     parentItem->GetChildCount(&childCount);
 29018:     for (PRInt32 index = 0; index < childCount; ++index) {
 29018:       parentItem->GetChildAt(index, getter_AddRefs(iterItem));
 29018:       if (iterItem == curItem) {
 29018:         ++index;
 29018:         if (index < childCount) {
 29018:           parentItem->GetChildAt(index, aResult);
 29018:           if (*aResult)
 29018:             return;
 29018:         }
 29018:         break;
 29018:       }
 29018:     }
 29018: 
 29018:     curItem = parentItem;
 29018:   }
 29018: }
 29018: 
 29018: void
 29018: nsFocusManager::GetPreviousDocShell(nsIDocShellTreeItem* aItem,
 29018:                                     nsIDocShellTreeItem** aResult)
 29018: {
 29018:   *aResult = nsnull;
 29018: 
 29018:   nsCOMPtr<nsIDocShellTreeItem> parentItem;
 29018:   aItem->GetParent(getter_AddRefs(parentItem));
 29018:   if (!parentItem)
 29018:     return;
 29018: 
 29018:   // Note that we avoid using GetChildOffset() here because docshell
 29018:   // child offsets can't be trusted to be correct. bug 162283.
 29018:   PRInt32 childCount = 0;
 29018:   parentItem->GetChildCount(&childCount);
 29018:   nsCOMPtr<nsIDocShellTreeItem> prevItem, iterItem;
 29018:   for (PRInt32 index = 0; index < childCount; ++index) {
 29018:     parentItem->GetChildAt(index, getter_AddRefs(iterItem));
 29018:     if (iterItem == aItem)
 29018:       break;
 29018:     prevItem = iterItem;
 29018:   }
 29018: 
 29018:   if (prevItem)
 29018:     GetLastDocShell(prevItem, aResult);
 29018:   else
 29018:     NS_ADDREF(*aResult = parentItem);
 29018: }
 29018: 
 29018: nsIContent*
 90842: nsFocusManager::GetNextTabbablePanel(nsIDocument* aDocument, nsIFrame* aCurrentPopup, bool aForward)
 29018: {
 90842:   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 90842:   if (!pm)
 90842:     return nsnull;
 90842: 
 90842:   // Iterate through the array backwards if aForward is false.
 90842:   nsTArray<nsIFrame *> popups = pm->GetVisiblePopups();
 90842:   PRInt32 i = aForward ? 0 : popups.Length() - 1;
 90842:   PRInt32 end = aForward ? popups.Length() : -1;
 90842: 
 90842:   for (; i != end; aForward ? i++ : i--) {
 90842:     nsIFrame* popupFrame = popups[i];
 90842:     if (aCurrentPopup) {
 90842:       // If the current popup is set, then we need to skip over this popup and
 90842:       // wait until the currently focused popup is found. Once found, the
 90842:       // current popup will be cleared so that the next popup is used.
 90842:       if (aCurrentPopup == popupFrame)
 90842:         aCurrentPopup = nsnull;
 90842:       continue;
 90842:     }
 90842: 
 90842:     // Skip over non-panels
 90842:     if (popupFrame->GetContent()->Tag() != nsGkAtoms::panel ||
 90842:         (aDocument && popupFrame->GetContent()->GetCurrentDoc() != aDocument)) {
 90842:       continue;
 90842:     }
 90842: 
 90842:     // Find the first focusable content within the popup. If there isn't any
 90842:     // focusable content in the popup, skip to the next popup.
 90842:     nsIPresShell* presShell = popupFrame->PresContext()->GetPresShell();
 90842:     if (presShell) {
 90842:       nsCOMPtr<nsIContent> nextFocus;
 90842:       nsIContent* popup = popupFrame->GetContent();
 90842:       nsresult rv = GetNextTabbableContent(presShell, popup,
 90842:                                            nsnull, popup,
 90842:                                            true, 1, false,
 90842:                                            getter_AddRefs(nextFocus));
 90842:       if (NS_SUCCEEDED(rv) && nextFocus) {
 90842:         return nextFocus.get();
 90842:       }
 90842:     }
 90842:   }
 90842: 
 90842:   return nsnull;
 90842: }
 90842: 
 90842: nsIContent*
 90842: nsFocusManager::GetNextTabbableDocument(nsIContent* aStartContent, bool aForward)
 90842: {
 90842:   // If currentPopup is set, then the starting content is in a panel.
 90842:   nsIFrame* currentPopup = nsnull;
 90842:   nsCOMPtr<nsIDocument> doc;
 29018:   nsCOMPtr<nsIDocShellTreeItem> startItem;
 90842: 
 90842:   if (aStartContent) {
 90842:     doc = aStartContent->GetCurrentDoc();
 90842:     if (doc) {
 90842:       startItem = do_QueryInterface(doc->GetWindow()->GetDocShell());
 90842:     }
 90842: 
 90842:     // Check if the starting content is inside a panel. Document navigation
 90842:     // must start from this panel instead of the document root.
 90842:     nsIContent* content = aStartContent;
 90842:     while (content) {
 90842:       if (content->NodeInfo()->Equals(nsGkAtoms::panel, kNameSpaceID_XUL)) {
 90842:         currentPopup = content->GetPrimaryFrame();
 90842:         break;
 90842:       }
 90842:       content = content->GetParent();
 90842:     }
 90842:   }
 90842:   else if (mFocusedWindow) {
 29018:     startItem = do_QueryInterface(mFocusedWindow->GetDocShell());
 90842:     doc = do_QueryInterface(mFocusedWindow->GetExtantDocument());
 29018:   }
 29018:   else {
 29018:     nsCOMPtr<nsIWebNavigation> webnav = do_GetInterface(mActiveWindow);
 29018:     startItem = do_QueryInterface(webnav);
 90842: 
 90842:     if (mActiveWindow) {
 90842:       doc = do_QueryInterface(mActiveWindow->GetExtantDocument());
 90842:     }
 90842:   }
 90842: 
 29018:   if (!startItem)
 29018:     return nsnull;
 29018: 
 29018:   // perform a depth first search (preorder) of the docshell tree
 29018:   // looking for an HTML Frame or a chrome document
 90842:   nsIContent* content = aStartContent;
 29018:   nsCOMPtr<nsIDocShellTreeItem> curItem = startItem;
 29018:   nsCOMPtr<nsIDocShellTreeItem> nextItem;
 29018:   do {
 90842:     // If moving forward, check for a panel in the starting document. If one
 90842:     // exists with focusable content, return that content instead of the next
 90842:     // document. If currentPopup is set, then, another panel may exist. If no
 90842:     // such panel exists, then continue on to check the next document.
 90842:     // When moving backwards, and the starting content is in a panel, then
 90842:     // check for additional panels in the starting document. If the starting
 90842:     // content is not in a panel, move back to the previous document and check
 90842:     // for panels there.
 90842: 
 90842:     bool checkPopups = false;
 90842:     nsCOMPtr<nsPIDOMWindow> nextFrame = nsnull;
 90842: 
 90842:     if (doc && (aForward || currentPopup)) {
 90842:       nsIContent* popupContent = GetNextTabbablePanel(doc, currentPopup, aForward);
 90842:       if (popupContent)
 90842:         return popupContent;
 90842: 
 90842:       if (!aForward && currentPopup) {
 90842:         // The starting content was in a popup, yet no other popups were
 90842:         // found. Move onto the starting content's document.
 90842:         nextFrame = doc->GetWindow();
 90842:       }
 90842:     }
 90842: 
 90842:     // Look for the next or previous document.
 90842:     if (!nextFrame) {
 29018:       if (aForward) {
 29018:         GetNextDocShell(curItem, getter_AddRefs(nextItem));
 29018:         if (!nextItem) {
 29018:           // wrap around to the beginning, which is the top of the tree
 29018:           startItem->GetRootTreeItem(getter_AddRefs(nextItem));
 29018:         }
 29018:       }
 29018:       else {
 29018:         GetPreviousDocShell(curItem, getter_AddRefs(nextItem));
 29018:         if (!nextItem) {
 29018:           // wrap around to the end, which is the last item in the tree
 29018:           nsCOMPtr<nsIDocShellTreeItem> rootItem;
 29018:           startItem->GetRootTreeItem(getter_AddRefs(rootItem));
 29018:           GetLastDocShell(rootItem, getter_AddRefs(nextItem));
 29018:         }
 90842: 
 90842:         // When going back to the previous document, check for any focusable
 90842:         // popups in that previous document first.
 90842:         checkPopups = true;
 29018:       }
 29018: 
 29018:       curItem = nextItem;
 90842:       nextFrame = do_GetInterface(nextItem);
 90842:     }
 90842: 
 29018:     if (!nextFrame)
 29018:       return nsnull;
 29018: 
 90842:     // Clear currentPopup for the next iteration
 90842:     currentPopup = nsnull;
 90842: 
 90842:     // If event handling is suppressed, move on to the next document. Set
 90842:     // content to null so that the popup check will be skipped on the next
 90842:     // loop iteration.
 90842:     doc = do_QueryInterface(nextFrame->GetExtantDocument());
 90842:     if (!doc || doc->EventHandlingSuppressed()) {
 90842:       content = nsnull;
 90842:       continue;
 90842:     }
 90842: 
 90842:     if (checkPopups) {
 90842:       // When iterating backwards, check the panels of the previous document
 90842:       // first. If a panel exists that has focusable content, focus that.
 90842:       // Otherwise, continue on to focus the document.
 90842:       nsIContent* popupContent = GetNextTabbablePanel(doc, nsnull, false);
 90842:       if (popupContent)
 90842:         return popupContent;
 90842:     }
 90842: 
 80486:     content = GetRootForFocus(nextFrame, doc, true, true);
 80486:     if (content && !GetRootForFocus(nextFrame, doc, false, false)) {
 29018:       // if the found content is in a chrome shell or a frameset, navigate
 29018:       // forward one tabbable item so that the first item is focused. Note
 29018:       // that we always go forward and not back here.
 29018:       nsCOMPtr<nsIContent> nextFocus;
 41634:       Element* rootElement = doc->GetRootElement();
 46225:       nsIPresShell* presShell = doc->GetShell();
 29018:       if (presShell) {
 41634:         nsresult rv = GetNextTabbableContent(presShell, rootElement,
 41634:                                              nsnull, rootElement,
 80486:                                              true, 1, false,
 29018:                                              getter_AddRefs(nextFocus));
 29018:         return NS_SUCCEEDED(rv) ? nextFocus.get() : nsnull;
 29018:       }
 29018:     }
 90842: 
 29018:   } while (!content);
 29018: 
 29018:   return content;
 29018: }
 29018: 
 29018: void
 29018: nsFocusManager::GetFocusInSelection(nsPIDOMWindow* aWindow,
 29018:                                     nsIContent* aStartSelection,
 29018:                                     nsIContent* aEndSelection,
 29018:                                     nsIContent** aFocusedContent)
 29018: {
 29018:   *aFocusedContent = nsnull;
 29018: 
 29018:   nsCOMPtr<nsIContent> testContent = aStartSelection;
 29018:   nsCOMPtr<nsIContent> nextTestContent = aEndSelection;
 29018: 
 29018:   nsCOMPtr<nsIContent> currentFocus = aWindow->GetFocusedNode();
 29018: 
 29018:   // We now have the correct start node in selectionContent!
 29018:   // Search for focusable elements, starting with selectionContent
 29018: 
 29018:   // Method #1: Keep going up while we look - an ancestor might be focusable
 29018:   // We could end the loop earlier, such as when we're no longer
 36657:   // in the same frame, by comparing selectionContent->GetPrimaryFrame()
 29018:   // with a variable holding the starting selectionContent
 29018:   while (testContent) {
 29018:     // Keep testing while selectionContent is equal to something,
 29018:     // eventually we'll run out of ancestors
 29018: 
 29018:     nsCOMPtr<nsIURI> uri;
 29018:     if (testContent == currentFocus ||
 29018:         testContent->IsLink(getter_AddRefs(uri))) {
 29018:       NS_ADDREF(*aFocusedContent = testContent);
 29018:       return;
 29018:     }
 29018: 
 29018:     // Get the parent
 29018:     testContent = testContent->GetParent();
 29018: 
 29018:     if (!testContent) {
 29018:       // We run this loop again, checking the ancestor chain of the selection's end point
 29018:       testContent = nextTestContent;
 29018:       nextTestContent = nsnull;
 29018:     }
 29018:   }
 29018: 
 29018:   // We couldn't find an anchor that was an ancestor of the selection start
 29018:   // Method #2: look for anchor in selection's primary range (depth first search)
 29018: 
 29018:   // Turn into nodes so that we can use GetNextSibling() and GetFirstChild()
 29018:   nsCOMPtr<nsIDOMNode> selectionNode(do_QueryInterface(aStartSelection));
 29018:   nsCOMPtr<nsIDOMNode> endSelectionNode(do_QueryInterface(aEndSelection));
 29018:   nsCOMPtr<nsIDOMNode> testNode;
 29018: 
 29018:   do {
 29018:     testContent = do_QueryInterface(selectionNode);
 29018: 
 29018:     // We're looking for any focusable link that could be part of the
 29018:     // main document's selection.
 29018:     nsCOMPtr<nsIURI> uri;
 29018:     if (testContent == currentFocus ||
 29018:         testContent->IsLink(getter_AddRefs(uri))) {
 29018:       NS_ADDREF(*aFocusedContent = testContent);
 29018:       return;
 29018:     }
 29018: 
 29018:     selectionNode->GetFirstChild(getter_AddRefs(testNode));
 29018:     if (testNode) {
 29018:       selectionNode = testNode;
 29018:       continue;
 29018:     }
 29018: 
 29018:     if (selectionNode == endSelectionNode)
 29018:       break;
 29018:     selectionNode->GetNextSibling(getter_AddRefs(testNode));
 29018:     if (testNode) {
 29018:       selectionNode = testNode;
 29018:       continue;
 29018:     }
 29018: 
 29018:     do {
 29018:       selectionNode->GetParentNode(getter_AddRefs(testNode));
 29018:       if (!testNode || testNode == endSelectionNode) {
 29018:         selectionNode = nsnull;
 29018:         break;
 29018:       }
 29018:       testNode->GetNextSibling(getter_AddRefs(selectionNode));
 29018:       if (selectionNode)
 29018:         break;
 29018:       selectionNode = testNode;
 80486:     } while (true);
 29018:   }
 29018:   while (selectionNode && selectionNode != endSelectionNode);
 29018: }
 29018: 
 29018: nsresult
 29018: NS_NewFocusManager(nsIFocusManager** aResult)
 29018: {
 29018:   NS_IF_ADDREF(*aResult = nsFocusManager::GetFocusManager());
 29018:   return NS_OK;
 29018: }
