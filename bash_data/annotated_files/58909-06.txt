    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla.org code.
    1:  *
36532:  * The Initial Developer of the Original Code is Mozilla Foundation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2006
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *         Jonas Sicking <jonas@sicking.cc> (Original Author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef nsNodeUtils_h___
    1: #define nsNodeUtils_h___
    1: 
39584: #include "nsINode.h"
    1: 
41902: struct CharacterDataChangeInfo;
    1: struct JSContext;
    1: struct JSObject;
 1391: class nsIVariant;
47799: class nsIDOMNode;
 1391: class nsIDOMUserDataHandler;
    1: template<class E> class nsCOMArray;
 4305: class nsCycleCollectionTraversalCallback;
    1: 
    1: class nsNodeUtils
    1: {
    1: public:
    1:   /**
 5681:    * Send CharacterDataWillChange notifications to nsIMutationObservers.
 5681:    * @param aContent  Node whose data changed
 5681:    * @param aInfo     Struct with information details about the change
 5681:    * @see nsIMutationObserver::CharacterDataWillChange
 5681:    */
 5681:   static void CharacterDataWillChange(nsIContent* aContent,
 5681:                                       CharacterDataChangeInfo* aInfo);
 5681: 
 5681:   /**
    1:    * Send CharacterDataChanged notifications to nsIMutationObservers.
    1:    * @param aContent  Node whose data changed
    1:    * @param aInfo     Struct with information details about the change
    1:    * @see nsIMutationObserver::CharacterDataChanged
    1:    */
    1:   static void CharacterDataChanged(nsIContent* aContent,
    1:                                    CharacterDataChangeInfo* aInfo);
    1: 
    1:   /**
29833:    * Send AttributeWillChange notifications to nsIMutationObservers.
51352:    * @param aElement      Element whose data will change
29833:    * @param aNameSpaceID  Namespace of changing attribute
29833:    * @param aAttribute    Local-name of changing attribute
29833:    * @param aModType      Type of change (add/change/removal)
29833:    * @see nsIMutationObserver::AttributeWillChange
29833:    */
51352:   static void AttributeWillChange(mozilla::dom::Element* aElement,
29833:                                   PRInt32 aNameSpaceID,
29833:                                   nsIAtom* aAttribute,
29833:                                   PRInt32 aModType);
29833: 
29833:   /**
    1:    * Send AttributeChanged notifications to nsIMutationObservers.
51351:    * @param aElement      Element whose data changed
    1:    * @param aNameSpaceID  Namespace of changed attribute
    1:    * @param aAttribute    Local-name of changed attribute
    1:    * @param aModType      Type of change (add/change/removal)
    1:    * @see nsIMutationObserver::AttributeChanged
    1:    */
51351:   static void AttributeChanged(mozilla::dom::Element* aElement,
    1:                                PRInt32 aNameSpaceID,
    1:                                nsIAtom* aAttribute,
35535:                                PRInt32 aModType);
    1: 
    1:   /**
    1:    * Send ContentAppended notifications to nsIMutationObservers
    1:    * @param aContainer           Node into which new child/children were added
42107:    * @param aFirstNewContent     First new child
    1:    * @param aNewIndexInContainer Index of first new child
    1:    * @see nsIMutationObserver::ContentAppended
    1:    */
    1:   static void ContentAppended(nsIContent* aContainer,
42107:                               nsIContent* aFirstNewContent,
    1:                               PRInt32 aNewIndexInContainer);
    1: 
    1:   /**
    1:    * Send ContentInserted notifications to nsIMutationObservers
    1:    * @param aContainer        Node into which new child was inserted
    1:    * @param aChild            Newly inserted child
    1:    * @param aIndexInContainer Index of new child
    1:    * @see nsIMutationObserver::ContentInserted
    1:    */
    1:   static void ContentInserted(nsINode* aContainer,
    1:                               nsIContent* aChild,
    1:                               PRInt32 aIndexInContainer);
    1:   /**
    1:    * Send ContentRemoved notifications to nsIMutationObservers
    1:    * @param aContainer        Node from which child was removed
    1:    * @param aChild            Removed child
    1:    * @param aIndexInContainer Index of removed child
    1:    * @see nsIMutationObserver::ContentRemoved
    1:    */
    1:   static void ContentRemoved(nsINode* aContainer,
    1:                              nsIContent* aChild,
48038:                              PRInt32 aIndexInContainer,
48038:                              nsIContent* aPreviousSibling);
    1:   /**
55347:    * Send AttributeChildRemoved notifications to nsIMutationObservers.
55347:    * @param aAttribute Attribute from which the child has been removed.
55347:    * @param aChild     Removed child.
55347:    * @see nsIMutationObserver2::AttributeChildRemoved.
55347:    */
55347:   static void AttributeChildRemoved(nsINode* aAttribute, nsIContent* aChild);
55347:   /**
    1:    * Send ParentChainChanged notifications to nsIMutationObservers
    1:    * @param aContent  The piece of content that had its parent changed.
    1:    * @see nsIMutationObserver::ParentChainChanged
    1:    */
    1:   static void ParentChainChanged(nsIContent *aContent);
    1: 
    1:   /**
    1:    * To be called when reference count of aNode drops to zero.
    1:    * @param aNode The node which is going to be deleted.
    1:    */
 1391:   static void LastRelease(nsINode* aNode);
    1: 
    1:   /**
    1:    * Clones aNode, its attributes and, if aDeep is PR_TRUE, its descendant nodes
    1:    * If aNewNodeInfoManager is not null, it is used to create new nodeinfos for
    1:    * the clones. aNodesWithProperties will be filled with all the nodes that
    1:    * have properties, and every node in it will be followed by its clone.
    1:    *
    1:    * @param aNode Node to clone.
    1:    * @param aDeep If PR_TRUE the function will be called recursively on
    1:    *              descendants of the node
    1:    * @param aNewNodeInfoManager The nodeinfo manager to use to create new
    1:    *                            nodeinfos for aNode and its attributes and
    1:    *                            descendants. May be null if the nodeinfos
    1:    *                            shouldn't be changed.
    1:    * @param aNodesWithProperties All nodes (from amongst aNode and its
    1:    *                             descendants) with properties. Every node will
    1:    *                             be followed by its clone.
    1:    * @param aResult *aResult will contain the cloned node.
    1:    */
    1:   static nsresult Clone(nsINode *aNode, PRBool aDeep,
    1:                         nsNodeInfoManager *aNewNodeInfoManager,
    1:                         nsCOMArray<nsINode> &aNodesWithProperties,
    1:                         nsIDOMNode **aResult)
    1:   {
    1:     return CloneAndAdopt(aNode, PR_TRUE, aDeep, aNewNodeInfoManager, nsnull,
58908:                          nsnull, nsnull, aNodesWithProperties, aResult);
    1:   }
    1: 
    1:   /**
    1:    * Walks aNode, its attributes and descendant nodes. If aNewNodeInfoManager is
    1:    * not null, it is used to create new nodeinfos for the nodes. Also reparents
    1:    * the XPConnect wrappers for the nodes in aNewScope if aCx is not null.
    1:    * aNodesWithProperties will be filled with all the nodes that have
    1:    * properties.
    1:    *
    1:    * @param aNode Node to adopt.
    1:    * @param aNewNodeInfoManager The nodeinfo manager to use to create new
    1:    *                            nodeinfos for aNode and its attributes and
    1:    *                            descendants. May be null if the nodeinfos
    1:    *                            shouldn't be changed.
    1:    * @param aCx Context to use for reparenting the wrappers, or null if no
    1:    *            reparenting should be done. Must be null if aNewNodeInfoManager
    1:    *            is null.
58908:    * @param aOldScope Old scope for the wrappers. May be null if aCx is null.
    1:    * @param aNewScope New scope for the wrappers. May be null if aCx is null.
    1:    * @param aNodesWithProperties All nodes (from amongst aNode and its
    1:    *                             descendants) with properties.
    1:    */
    1:   static nsresult Adopt(nsINode *aNode, nsNodeInfoManager *aNewNodeInfoManager,
58908:                         JSContext *aCx, JSObject *aOldScope,
58908:                         JSObject *aNewScope,
    1:                         nsCOMArray<nsINode> &aNodesWithProperties)
    1:   {
39584:     nsresult rv = CloneAndAdopt(aNode, PR_FALSE, PR_TRUE, aNewNodeInfoManager,
58908:                                 aCx, aOldScope, aNewScope, aNodesWithProperties,
39584:                                 nsnull);
40487: 
39584:     nsMutationGuard::DidMutate();
39584: 
39584:     return rv;
    1:   }
    1: 
    1:   /**
    1:    * Call registered userdata handlers for operation aOperation for the nodes in
    1:    * aNodesWithProperties. If aCloned is PR_TRUE aNodesWithProperties should
    1:    * contain both the original and the cloned nodes (and only the userdata
    1:    * handlers registered for the original nodes will be called).
    1:    *
    1:    * @param aNodesWithProperties Contains the nodes that might have properties
    1:    *                             registered on them. If aCloned is PR_TRUE every
    1:    *                             one of those nodes should be immediately
    1:    *                             followed in the array by the cloned node.
    1:    * @param aOwnerDocument The ownerDocument of the original nodes.
    1:    * @param aOperation The operation to call a userdata handler for.
    1:    * @param aCloned If PR_TRUE aNodesWithProperties will contain both original
    1:    *                and cloned nodes.
    1:    */
    1:   static nsresult CallUserDataHandlers(nsCOMArray<nsINode> &aNodesWithProperties,
    1:                                        nsIDocument *aOwnerDocument,
    1:                                        PRUint16 aOperation, PRBool aCloned);
    1: 
    1:   /**
 1391:    * Helper for the cycle collector to traverse the DOM UserData and
 1391:    * UserDataHandlers for aNode.
 1391:    *
 1391:    * @param aNode the node to traverse UserData and UserDataHandlers for
 1391:    * @param aCb the cycle collection callback
 1391:    */
 1391:   static void TraverseUserData(nsINode* aNode,
 1391:                                nsCycleCollectionTraversalCallback &aCb);
 1391: 
 1391:   /**
    1:    * A basic implementation of the DOM cloneNode method. Calls nsINode::Clone to
    1:    * do the actual cloning of the node.
    1:    *
    1:    * @param aNode the node to clone
    1:    * @param aDeep if true all descendants will be cloned too
58904:    * @param aCallUserDataHandlers if true, user data handlers will be called
    1:    * @param aResult the clone
    1:    */
    1:   static nsresult CloneNodeImpl(nsINode *aNode, PRBool aDeep,
58904:                                 PRBool aCallUserDataHandlers,
    1:                                 nsIDOMNode **aResult);
    1: 
 1391:   /**
 1391:    * Release the UserData and UserDataHandlers for aNode.
 1391:    *
 1391:    * @param aNode the node to release the UserData and UserDataHandlers for
 1391:    */
 1391:   static void UnlinkUserData(nsINode *aNode);
 1391: 
    1: private:
    1:   /**
    1:    * Walks aNode, its attributes and, if aDeep is PR_TRUE, its descendant nodes.
    1:    * If aClone is PR_TRUE the nodes will be cloned. If aNewNodeInfoManager is
    1:    * not null, it is used to create new nodeinfos for the nodes. Also reparents
    1:    * the XPConnect wrappers for the nodes in aNewScope if aCx is not null.
    1:    * aNodesWithProperties will be filled with all the nodes that have
    1:    * properties.
    1:    *
    1:    * @param aNode Node to adopt/clone.
    1:    * @param aClone If PR_TRUE the node will be cloned and the cloned node will
    1:    *               be in aResult.
    1:    * @param aDeep If PR_TRUE the function will be called recursively on
    1:    *              descendants of the node
    1:    * @param aNewNodeInfoManager The nodeinfo manager to use to create new
    1:    *                            nodeinfos for aNode and its attributes and
    1:    *                            descendants. May be null if the nodeinfos
    1:    *                            shouldn't be changed.
    1:    * @param aCx Context to use for reparenting the wrappers, or null if no
    1:    *            reparenting should be done. Must be null if aClone is PR_TRUE or
    1:    *            if aNewNodeInfoManager is null.
58908:    * @param aOldScope Old scope for the wrappers. May be null if aCx is null.
    1:    * @param aNewScope New scope for the wrappers. May be null if aCx is null.
    1:    * @param aNodesWithProperties All nodes (from amongst aNode and its
    1:    *                             descendants) with properties. If aClone is
    1:    *                             PR_TRUE every node will be followed by its
    1:    *                             clone.
33982:    * @param aResult If aClone is PR_FALSE then aResult must be null, else
33982:    *                *aResult will contain the cloned node.
    1:    */
    1:   static nsresult CloneAndAdopt(nsINode *aNode, PRBool aClone, PRBool aDeep,
    1:                                 nsNodeInfoManager *aNewNodeInfoManager,
58908:                                 JSContext *aCx, JSObject *aOldScope,
58908:                                 JSObject *aNewScope,
    1:                                 nsCOMArray<nsINode> &aNodesWithProperties,
33674:                                 nsIDOMNode **aResult)
33674:   {
33982:     NS_ASSERTION(!aClone == !aResult,
33982:                  "aResult must be null when adopting and non-null when "
33982:                  "cloning");
33982: 
33674:     nsCOMPtr<nsINode> clone;
33674:     nsresult rv = CloneAndAdopt(aNode, aClone, aDeep, aNewNodeInfoManager,
58908:                                 aCx, aOldScope, aNewScope, aNodesWithProperties,
33674:                                 nsnull, getter_AddRefs(clone));
33674:     NS_ENSURE_SUCCESS(rv, rv);
33674: 
33674:     return clone ? CallQueryInterface(clone, aResult) : NS_OK;
33674:   }
33674: 
33674:   /**
33674:    * See above for arguments that aren't described here.
33674:    *
33674:    * @param aParent If aClone is PR_TRUE the cloned node will be appended to
33674:    *                aParent's children. May be null. If not null then aNode
33674:    *                must be an nsIContent.
33982:    * @param aResult If aClone is PR_TRUE then *aResult will contain the cloned
33982:    *                node.
33674:    */
33674:   static nsresult CloneAndAdopt(nsINode *aNode, PRBool aClone, PRBool aDeep,
33674:                                 nsNodeInfoManager *aNewNodeInfoManager,
58908:                                 JSContext *aCx, JSObject *aOldScope,
58908:                                 JSObject *aNewScope,
33674:                                 nsCOMArray<nsINode> &aNodesWithProperties,
33674:                                 nsINode *aParent, nsINode **aResult);
    1: };
    1: 
    1: #endif // nsNodeUtils_h___
