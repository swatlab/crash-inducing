    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Radha Kulkarni <radha@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /**
    1:  * The interface to nsISHentry. Each document or subframe in 
    1:  * Session History will have a nsISHEntry associated with it which will
    1:  * hold all information required to recreate the document from history
    1:  * 
    1:  */
    1: #include "nsIHistoryEntry.idl"
    1: 
    1: interface nsILayoutHistoryState;
    1: interface nsIContentViewer;
    1: interface nsIURI;
    1: interface nsIInputStream;
    1: interface nsIDocShellTreeItem;
    1: interface nsISupportsArray;
69563: interface nsIStructuredCloneContainer;
80519: interface nsIBFCacheEntry;
80519: 
    1: %{C++
23738: struct nsIntRect;
14631: class nsDocShellEditorData;
80519: class nsSHEntryShared;
    1: %}
23738: [ref] native nsIntRect(nsIntRect);
14631: [ptr] native nsDocShellEditorDataPtr(nsDocShellEditorData);
80519: [ptr] native nsSHEntryShared(nsSHEntryShared);
14631: 
80519: [scriptable, uuid(6443FD72-A50F-4B8B-BB82-BB1FA04CB15D)]
    1: interface nsISHEntry : nsIHistoryEntry
    1: {
    1:     /** URI for the document */
    1:     void setURI(in nsIURI aURI);
    1: 
    1:     /** Referrer URI */
    1:     attribute nsIURI referrerURI;
    1: 
    1:     /** Content viewer, for fast restoration of presentation */
    1:     attribute nsIContentViewer contentViewer;
    1: 
    1:     /** Whether the content viewer is marked "sticky" */
    1:     attribute boolean sticky;
    1: 
    1:     /** Saved state of the global window object */
    1:     attribute nsISupports windowState;
    1: 
    1:     /**
    1:      * Saved position and dimensions of the content viewer; we must adjust the
    1:      * root view's widget accordingly if this has changed when the presentation
    1:      * is restored.
    1:      */
23738:     [noscript] void getViewerBounds(in nsIntRect bounds);
23738:     [noscript] void setViewerBounds([const] in nsIntRect bounds);
    1: 
    1:     /**
    1:      * Saved child docshells corresponding to contentViewer.  The child shells
    1:      * are restored as children of the parent docshell, in this order, when the
    1:      * parent docshell restores a saved presentation.
    1:      */
    1: 
    1:     /** Append a child shell to the end of our list. */
    1:     void addChildShell(in nsIDocShellTreeItem shell);
    1: 
    1:     /**
    1:      * Get the child shell at |index|; returns null if |index| is out of bounds.
    1:      */
    1:     nsIDocShellTreeItem childShellAt(in long index);
    1: 
    1:     /**
    1:      * Clear the child shell list.
    1:      */
    1:     void clearChildShells();
    1: 
    1:     /** Saved refresh URI list for the content viewer */
    1:     attribute nsISupportsArray refreshURIList;
    1: 
    1:     /**
    1:      * Ensure that the cached presentation members are self-consistent.
    1:      * If either |contentViewer| or |windowState| are null, then all of the
    1:      * following members are cleared/reset:
    1:      *  contentViewer, sticky, windowState, viewerBounds, childShells,
    1:      *  refreshURIList.
    1:      */
    1:     void syncPresentationState();
    1: 
    1:     /** Title for the document */
    1:     void setTitle(in AString aTitle);
    1: 
    1:     /** Post Data for the document */
    1:     attribute nsIInputStream postData;
    1: 
    1:     /** LayoutHistoryState for scroll position and form values */
    1:     attribute nsILayoutHistoryState layoutHistoryState;
    1: 
    1:     /** parent of this entry */
    1:     attribute nsISHEntry parent;
    1: 
    1:     /**
    1:      * The loadType for this entry. This is typically loadHistory except
    1:      * when reload is pressed, it has the appropriate reload flag
    1:      */
    1:     attribute unsigned long loadType;
    1: 
    1:     /**
    1:      * An ID to help identify this entry from others during
    1:      * subframe navigation
    1:      */
    1:     attribute unsigned long ID;
    1: 
    1:     /** attribute to set and get the cache key for the entry */
    1:     attribute nsISupports cacheKey;
    1: 
    1:     /** attribute to indicate whether layoutHistoryState should be saved */
    1:     attribute boolean saveLayoutStateFlag;
    1: 
    1:     /** attribute to indicate whether the page is already expired in cache */
    1:     attribute boolean expirationStatus;
    1: 
    1:     /**
    1:      * attribute to indicate the content-type of the document that this
    1:      * is a session history entry for
    1:      */
    1:     attribute ACString contentType; 
    1: 
73554:     /**
73554:      * If we created this SHEntry via history.pushState or modified it via
73554:      * history.replaceState, and if we changed the SHEntry's URI via the
73554:      * push/replaceState call, and if the SHEntry's new URI differs from its
73554:      * old URI by more than just the hash, then we set this field to true.
73554:      *
73554:      * Additionally, if this SHEntry was created by calling pushState from a
73554:      * SHEntry whose URI was modified, this SHEntry's URIWasModified field is
73554:      * true.
73554:      *
73554:      */
73554:     attribute boolean URIWasModified;
73554:  
    1:     /** Set/Get scrollers' positon in anchored pages */
    1:     void setScrollPosition(in long x, in long y);
    1:     void getScrollPosition(out long x, out long y);
    1: 
    1:     /** Additional ways to create an entry */
 6007:     [noscript] void create(in nsIURI URI, in AString title,
    1:                            in nsIInputStream inputStream,
    1:                            in nsILayoutHistoryState layoutHistoryState,
    1:                            in nsISupports cacheKey, in ACString contentType,
50721:                            in nsISupports owner,
50721:                            in unsigned long long docshellID,
50721:                            in boolean dynamicCreation);
    1: 
    1:     nsISHEntry clone();
    1: 
    1:     /** Attribute that indicates if this entry is for a subframe navigation */
    1:     void setIsSubFrame(in boolean aFlag);
    1: 
    1:     /** Return any content viewer present in or below this node in the
    1:         nsSHEntry tree.  This will differ from contentViewer in the case
    1:         where a child nsSHEntry has the content viewer for this tree. */
    1:     nsIContentViewer getAnyContentViewer(out nsISHEntry ownerEntry);
    1: 
    1:     /**
    1:      * Get the owner, if any, that was associated with the channel
    1:      * that the document that was loaded to create this history entry
    1:      * came from.
    1:      */
 6007:     attribute nsISupports owner;
14631: 
14631:     /**
37802:      * Get/set data associated with this history state via a pushState() call,
69563:      * serialized using structured clone.
37802:      **/
69563:     attribute nsIStructuredCloneContainer stateData;
37802: 
37802:     /**
14631:      * Gets the owning pointer to the editor data assosicated with
14631:      * this shistory entry. This forgets its pointer, so free it when
14631:      * you're done.
14631:      */
14631:     [noscript, notxpcom] nsDocShellEditorDataPtr forgetEditorData();
14631: 
14631:     /**
14631:      * Sets the owning pointer to the editor data assosicated with
14631:      * this shistory entry. Unless forgetEditorData() is called, this
14631:      * shentry will destroy the editor data when it's destroyed.
14631:      */
14631:     [noscript, notxpcom] void setEditorData(in nsDocShellEditorDataPtr aData);
14631: 
14631:     /** Returns true if this shistory entry is storing a detached editor. */
14631:     [noscript, notxpcom] boolean hasDetachedEditor();
50721: 
50721:     /**
50721:      * Returns true if the related docshell was added because of
50721:      * dynamic addition of an iframe/frame.
50721:      */
50721:     boolean isDynamicallyAdded();
50721: 
50721:     /**
50721:      * Returns true if any of the child entries returns true
50721:      * when isDynamicallyAdded is called on it.
50721:      */
50721:     boolean hasDynamicallyAddedChild();
50721: 
50721:     /**
50721:      * The history ID of the docshell.
50721:      */
50721:     attribute unsigned long long docshellID;
80519: 
80519:     readonly attribute nsIBFCacheEntry BFCacheEntry;
80519: 
80519:     /**
80519:      * Does this SHEntry point to the given BFCache entry?  If so, evicting
80519:      * the BFCache entry will evict the SHEntry, since the two entries
80519:      * correspond to the same document.
80519:      */
80519:     [notxpcom, noscript]
80519:     boolean hasBFCacheEntry(in nsIBFCacheEntry aEntry);
80519: 
80519:     /**
80519:      * Adopt aEntry's BFCacheEntry, so now both this and aEntry point to
80519:      * aEntry's BFCacheEntry.
80519:      */
80519:     void adoptBFCacheEntry(in nsISHEntry aEntry);
80519: 
80519:     /**
80519:      * Create a new BFCache entry and drop our reference to our old one.  This
80519:      * call unlinks this SHEntry from any other SHEntries for its document.
80519:      */
80519:     void abandonBFCacheEntry();
80519: 
80519:     /**
80519:      * Does this SHEntry correspond to the same document as aEntry?  This is
80519:      * true iff the two SHEntries have the same BFCacheEntry.  So in
80519:      * particular, sharesDocumentWith(aEntry) is guaranteed to return true if
80519:      * it's preceeded by a call to adoptBFCacheEntry(aEntry).
80519:      */
80519:     boolean sharesDocumentWith(in nsISHEntry aEntry);
    1: };
    1: 
60876: [scriptable, uuid(bb66ac35-253b-471f-a317-3ece940f04c5)]
58185: interface nsISHEntryInternal : nsISupports
58185: {
58185:     [notxpcom] void RemoveFromBFCacheAsync();
58185:     [notxpcom] void RemoveFromBFCacheSync();
60876: 
60876:     /**
60876:      * A number that is assigned by the sHistory when the entry is activated
60876:      */
60876:     attribute unsigned long lastTouched;
80519: 
80519:     /**
80519:      * Some state, particularly that related to the back/forward cache, is
80519:      * shared between SHEntries which correspond to the same document.  This
80519:      * method gets a pointer to that shared state.
80519:      *
80519:      * This shared state is the SHEntry's BFCacheEntry.  So
80519:      * hasBFCacheEntry(getSharedState()) is guaranteed to return true.
80519:      */
80519:     [noscript, notxpcom]
80519:     nsSHEntryShared getSharedState();
58185: };
    1: 
    1: %{ C++
    1: // {BFD1A791-AD9F-11d3-BDC7-0050040A9B44}
    1: #define NS_SHENTRY_CID \
    1: {0xbfd1a791, 0xad9f, 0x11d3, {0xbd, 0xc7, 0x0, 0x50, 0x4, 0xa, 0x9b, 0x44}}
    1: 
    1: #define NS_SHENTRY_CONTRACTID \
    1:     "@mozilla.org/browser/session-history-entry;1"
    1: 
    1: %}
    1: 
