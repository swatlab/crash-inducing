    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Original Author: David W. Hyatt (hyatt@netscape.com)
    1:  *   - Brendan Eich (brendan@mozilla.org)
    1:  *   - Mike Pinkerton (pinkerton@netscape.com)
    1:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsNetUtil.h"
    1: #include "nsXBLService.h"
    1: #include "nsXBLWindowKeyHandler.h"
    1: #include "nsIInputStream.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsHashtable.h"
    1: #include "nsIURI.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIURL.h"
    1: #include "nsIChannel.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsIParser.h"
    1: #include "nsParserCIID.h"
    1: #include "nsNetUtil.h"
    1: #include "plstr.h"
    1: #include "nsIContent.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDocument.h"
    1: #include "nsIXMLContentSink.h"
    1: #include "nsContentCID.h"
    1: #include "nsXMLDocument.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsIMemory.h"
    1: #include "nsIObserverService.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsXBLContentSink.h"
    1: #include "nsXBLBinding.h"
    1: #include "nsXBLPrototypeBinding.h"
    1: #include "nsIXBLDocumentInfo.h"
    1: #include "nsCRT.h"
    1: #include "nsContentUtils.h"
    1: #include "nsSyncLoadService.h"
    1: #include "nsIDOM3Node.h"
    1: #include "nsContentPolicyUtils.h"
26413: #include "nsTArray.h"
    1: 
    1: #include "nsIPresShell.h"
    1: #include "nsIDocumentObserver.h"
    1: #include "nsFrameManager.h"
    1: #include "nsStyleContext.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsIScriptError.h"
    1: 
    1: #ifdef MOZ_XUL
    1: #include "nsXULPrototypeCache.h"
    1: #endif
    1: #include "nsIDOMLoadListener.h"
    1: #include "nsIDOMEventGroup.h"
    1: 
  255: #define NS_MAX_XBL_BINDING_RECURSION 20
  255: 
    1: static PRBool IsChromeOrResourceURI(nsIURI* aURI)
    1: {
    1:   PRBool isChrome = PR_FALSE;
    1:   PRBool isResource = PR_FALSE;
    1:   if (NS_SUCCEEDED(aURI->SchemeIs("chrome", &isChrome)) && 
    1:       NS_SUCCEEDED(aURI->SchemeIs("resource", &isResource)))
    1:       return (isChrome || isResource);
    1:   return PR_FALSE;
    1: }
    1: 
    1: static PRBool
    1: IsAncestorBinding(nsIDocument* aDocument,
    1:                   nsIURI* aChildBindingURI,
    1:                   nsIContent* aChild)
    1: {
    1:   NS_ASSERTION(aDocument, "expected a document");
    1:   NS_ASSERTION(aChildBindingURI, "expected a binding URI");
    1:   NS_ASSERTION(aChild, "expected a child content");
    1: 
  255:   PRUint32 bindingRecursion = 0;
    1:   nsBindingManager* bindingManager = aDocument->BindingManager();
16126:   for (nsIContent *bindingParent = aChild->GetBindingParent();
16126:        bindingParent;
16126:        bindingParent = bindingParent->GetBindingParent()) {
    1:     nsXBLBinding* binding = bindingManager->GetBinding(bindingParent);
    1:     if (!binding) {
    1:       continue;
    1:     }
16992: 
34526:     if (binding->PrototypeBinding()->CompareBindingURI(aChildBindingURI)) {
  255:       ++bindingRecursion;
  255:       if (bindingRecursion < NS_MAX_XBL_BINDING_RECURSION) {
  255:         continue;
  255:       }
    1:       nsCAutoString spec;
    1:       aChildBindingURI->GetSpec(spec);
    1:       NS_ConvertUTF8toUTF16 bindingURI(spec);
    1:       const PRUnichar* params[] = { bindingURI.get() };
    1:       nsContentUtils::ReportToConsole(nsContentUtils::eXBL_PROPERTIES,
  255:                                       "TooDeepBindingRecursion",
    1:                                       params, NS_ARRAY_LENGTH(params),
    1:                                       aDocument->GetDocumentURI(),
    1:                                       EmptyString(), 0, 0,
    1:                                       nsIScriptError::warningFlag,
    1:                                       "XBL");
    1:       return PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
16019: PRBool CheckTagNameWhiteList(PRInt32 aNameSpaceID, nsIAtom *aTagName)
16019: {
16019:   static nsIContent::AttrValuesArray kValidXULTagNames[] =  {
16019:     &nsGkAtoms::autorepeatbutton, &nsGkAtoms::box, &nsGkAtoms::browser,
16019:     &nsGkAtoms::button, &nsGkAtoms::hbox, &nsGkAtoms::image, &nsGkAtoms::menu,
16019:     &nsGkAtoms::menubar, &nsGkAtoms::menuitem, &nsGkAtoms::menupopup,
16019:     &nsGkAtoms::row, &nsGkAtoms::slider, &nsGkAtoms::spacer,
16019:     &nsGkAtoms::splitter, &nsGkAtoms::text, &nsGkAtoms::tree, nsnull};
16019: 
16019:   PRUint32 i;
16019:   if (aNameSpaceID == kNameSpaceID_XUL) {
16019:     for (i = 0; kValidXULTagNames[i]; ++i) {
16019:       if (aTagName == *(kValidXULTagNames[i])) {
16019:         return PR_TRUE;
16019:       }
16019:     }
16019:   }
16330: #ifdef MOZ_SVG
16019:   else if (aNameSpaceID == kNameSpaceID_SVG &&
16019:            aTagName == nsGkAtoms::generic) {
16019:     return PR_TRUE;
16019:   }
16330: #endif
16019: 
16019:   return PR_FALSE;
16019: }
16019: 
    1: // Individual binding requests.
    1: class nsXBLBindingRequest
    1: {
    1: public:
    1:   nsCOMPtr<nsIURI> mBindingURI;
    1:   nsCOMPtr<nsIContent> mBoundElement;
    1: 
    1:   static nsXBLBindingRequest*
    1:   Create(nsFixedSizeAllocator& aPool, nsIURI* aURI, nsIContent* aBoundElement) {
    1:     void* place = aPool.Alloc(sizeof(nsXBLBindingRequest));
    1:     return place ? ::new (place) nsXBLBindingRequest(aURI, aBoundElement) : nsnull;
    1:   }
    1: 
    1:   static void
    1:   Destroy(nsFixedSizeAllocator& aPool, nsXBLBindingRequest* aRequest) {
    1:     aRequest->~nsXBLBindingRequest();
    1:     aPool.Free(aRequest, sizeof(*aRequest));
    1:   }
    1: 
    1:   void DocumentLoaded(nsIDocument* aBindingDoc)
    1:   {
    1:     // We only need the document here to cause frame construction, so
    1:     // we need the current doc, not the owner doc.
    1:     nsIDocument* doc = mBoundElement->GetCurrentDoc();
    1:     if (!doc)
    1:       return;
    1: 
    1:     // Get the binding.
    1:     PRBool ready = PR_FALSE;
    1:     gXBLService->BindingReady(mBoundElement, mBindingURI, &ready);
    1: 
    1:     if (!ready)
    1:       return;
    1: 
    1:     // If |mBoundElement| is (in addition to having binding |mBinding|)
    1:     // also a descendant of another element with binding |mBinding|,
    1:     // then we might have just constructed it due to the
    1:     // notification of its parent.  (We can know about both if the
    1:     // binding loads were triggered from the DOM rather than frame
    1:     // construction.)  So we have to check both whether the element
    1:     // has a primary frame and whether it's in the undisplayed map
    1:     // before sending a ContentInserted notification, or bad things
    1:     // will happen.
  981:     nsIPresShell *shell = doc->GetPrimaryShell();
    1:     if (shell) {
    1:       nsIFrame* childFrame = shell->GetPrimaryFrameFor(mBoundElement);
    1:       if (!childFrame) {
    1:         // Check to see if it's in the undisplayed content map.
    1:         nsStyleContext* sc =
    1:           shell->FrameManager()->GetUndisplayedContent(mBoundElement);
    1: 
    1:         if (!sc) {
    1:           shell->RecreateFramesFor(mBoundElement);
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   static nsIXBLService* gXBLService;
    1:   static int gRefCnt;
    1: 
    1: protected:
    1:   nsXBLBindingRequest(nsIURI* aURI, nsIContent* aBoundElement)
    1:     : mBindingURI(aURI),
    1:       mBoundElement(aBoundElement)
    1:   {
    1:     gRefCnt++;
    1:     if (gRefCnt == 1) {
    1:       CallGetService("@mozilla.org/xbl;1", &gXBLService);
    1:     }
    1:   }
    1: 
    1:   ~nsXBLBindingRequest()
    1:   {
    1:     gRefCnt--;
    1:     if (gRefCnt == 0) {
    1:       NS_IF_RELEASE(gXBLService);
    1:     }
    1:   }
    1: 
    1: private:
    1:   // Hide so that only Create() and Destroy() can be used to
    1:   // allocate and deallocate from the heap
    1:   static void* operator new(size_t) CPP_THROW_NEW { return 0; }
    1:   static void operator delete(void*, size_t) {}
    1: };
    1: 
    1: static const size_t kBucketSizes[] = {
    1:   sizeof(nsXBLBindingRequest)
    1: };
    1: 
    1: static const PRInt32 kNumBuckets = sizeof(kBucketSizes)/sizeof(size_t);
    1: static const PRInt32 kNumElements = 64;
    1: static const PRInt32 kInitialSize = (NS_SIZE_IN_HEAP(sizeof(nsXBLBindingRequest))) * kNumElements;
    1: 
    1: nsIXBLService* nsXBLBindingRequest::gXBLService = nsnull;
    1: int nsXBLBindingRequest::gRefCnt = 0;
    1: 
    1: // nsXBLStreamListener, a helper class used for 
    1: // asynchronous parsing of URLs
    1: /* Header file */
    1: class nsXBLStreamListener : public nsIStreamListener, public nsIDOMLoadListener
    1: {
    1: public:
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSISTREAMLISTENER
    1:   NS_DECL_NSIREQUESTOBSERVER
    1: 
    1:   NS_IMETHOD Load(nsIDOMEvent* aEvent);
    1:   NS_IMETHOD BeforeUnload(nsIDOMEvent* aEvent) { return NS_OK; }
    1:   NS_IMETHOD Unload(nsIDOMEvent* aEvent) { return NS_OK; }
    1:   NS_IMETHOD Abort(nsIDOMEvent* aEvent) { return NS_OK; }
    1:   NS_IMETHOD Error(nsIDOMEvent* aEvent) { return NS_OK; }
    1:   NS_IMETHOD HandleEvent(nsIDOMEvent* aEvent) { return NS_OK; }
    1: 
23645:   nsXBLStreamListener(nsXBLService* aXBLService,
23645:                       nsIDocument* aBoundDocument,
23645:                       nsIXMLContentSink* aSink,
23645:                       nsIDocument* aBindingDocument);
 7672:   ~nsXBLStreamListener();
    1: 
  731:   void AddRequest(nsXBLBindingRequest* aRequest) { mBindingRequests.AppendElement(aRequest); }
    1:   PRBool HasRequest(nsIURI* aURI, nsIContent* aBoundElement);
    1: 
    1: private:
    1:   nsXBLService* mXBLService; // [WEAK]
    1: 
    1:   nsCOMPtr<nsIStreamListener> mInner;
26413:   nsAutoTArray<nsXBLBindingRequest*, 8> mBindingRequests;
    1:   
23645:   nsCOMPtr<nsIWeakReference> mBoundDocument;
23645:   nsCOMPtr<nsIXMLContentSink> mSink; // Only set until OnStartRequest
23645:   nsCOMPtr<nsIDocument> mBindingDocument; // Only set until OnStartRequest
    1: };
    1: 
    1: /* Implementation file */
    1: NS_IMPL_ISUPPORTS4(nsXBLStreamListener, nsIStreamListener, nsIRequestObserver, nsIDOMLoadListener, nsIDOMEventListener)
    1: 
    1: nsXBLStreamListener::nsXBLStreamListener(nsXBLService* aXBLService,
23645:                                          nsIDocument* aBoundDocument,
23645:                                          nsIXMLContentSink* aSink,
23645:                                          nsIDocument* aBindingDocument)
23645: : mSink(aSink), mBindingDocument(aBindingDocument)
    1: {
    1:   /* member initializers and constructor code */
    1:   mXBLService = aXBLService;
23645:   mBoundDocument = do_GetWeakReference(aBoundDocument);
 7672: }
 7672: 
 7672: nsXBLStreamListener::~nsXBLStreamListener()
 7672: {
29634:   for (PRUint32 i = 0; i < mBindingRequests.Length(); i++) {
26413:     nsXBLBindingRequest* req = mBindingRequests.ElementAt(i);
 7672:     nsXBLBindingRequest::Destroy(mXBLService->mPool, req);
 7672:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXBLStreamListener::OnDataAvailable(nsIRequest *request, nsISupports* aCtxt, nsIInputStream* aInStr, 
    1:                                      PRUint32 aSourceOffset, PRUint32 aCount)
    1: {
    1:   if (mInner)
    1:     return mInner->OnDataAvailable(request, aCtxt, aInStr, aSourceOffset, aCount);
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXBLStreamListener::OnStartRequest(nsIRequest* request, nsISupports* aCtxt)
    1: {
23645:   // Make sure we don't hold on to the sink and binding document past this point
23645:   nsCOMPtr<nsIXMLContentSink> sink;
23645:   mSink.swap(sink);
23645:   nsCOMPtr<nsIDocument> doc;
23645:   mBindingDocument.swap(doc);
23645: 
23645:   nsCOMPtr<nsIChannel> channel = do_QueryInterface(request);
23645:   NS_ENSURE_TRUE(channel, NS_ERROR_UNEXPECTED);
23645: 
23645:   nsCOMPtr<nsILoadGroup> group;
23645:   request->GetLoadGroup(getter_AddRefs(group));
23645: 
23645:   nsresult rv = doc->StartDocumentLoad("loadAsInteractiveData",
23645:                                        channel,
23645:                                        group,
23645:                                        nsnull,
23645:                                        getter_AddRefs(mInner),
23645:                                        PR_TRUE,
23645:                                        sink);
23645:   NS_ENSURE_SUCCESS(rv, rv);
23645: 
23645:   // Make sure to add ourselves as a listener after StartDocumentLoad,
23645:   // since that resets the event listners on the document.
23645:   nsCOMPtr<nsIDOMEventTarget> target(do_QueryInterface(doc));
23645:   target->AddEventListener(NS_LITERAL_STRING("load"), this, PR_FALSE);
23645:   
23631:   return mInner->OnStartRequest(request, aCtxt);
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsXBLStreamListener::OnStopRequest(nsIRequest* request, nsISupports* aCtxt, nsresult aStatus)
    1: {
    1:   nsresult rv = NS_OK;
    1:   if (mInner) {
    1:      rv = mInner->OnStopRequest(request, aCtxt, aStatus);
    1:   }
    1: 
 7672:   // Don't hold onto the inner listener; holding onto it can create a cycle
 7672:   // with the document
 7672:   mInner = nsnull;
    1: 
    1:   return rv;
    1: }
    1: 
    1: PRBool
    1: nsXBLStreamListener::HasRequest(nsIURI* aURI, nsIContent* aElt)
    1: {
    1:   // XXX Could be more efficient.
26413:   PRUint32 count = mBindingRequests.Length();
    1:   for (PRUint32 i = 0; i < count; i++) {
26413:     nsXBLBindingRequest* req = mBindingRequests.ElementAt(i);
    1:     PRBool eq;
    1:     if (req->mBoundElement == aElt &&
    1:         NS_SUCCEEDED(req->mBindingURI->Equals(aURI, &eq)) && eq)
    1:       return PR_TRUE;
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: nsresult
    1: nsXBLStreamListener::Load(nsIDOMEvent* aEvent)
    1: {
    1:   nsresult rv = NS_OK;
    1:   PRUint32 i;
26413:   PRUint32 count = mBindingRequests.Length();
    1: 
 7672:   // Get the binding document; note that we don't hold onto it in this object
 7672:   // to avoid creating a cycle
 7672:   nsCOMPtr<nsIDOMEventTarget> target;
 7672:   aEvent->GetCurrentTarget(getter_AddRefs(target));
 7672:   nsCOMPtr<nsIDocument> bindingDocument = do_QueryInterface(target);
 7672:   NS_ASSERTION(bindingDocument, "Event not targeted at document?!");
 7672: 
    1:   // See if we're still alive.
23645:   nsCOMPtr<nsIDocument> doc(do_QueryReferent(mBoundDocument));
    1:   if (!doc) {
    1:     NS_WARNING("XBL load did not complete until after document went away! Modal dialog bug?\n");
    1:   }
    1:   else {
    1:     // We have to do a flush prior to notification of the document load.
    1:     // This has to happen since the HTML content sink can be holding on
    1:     // to notifications related to our children (e.g., if you bind to the
    1:     // <body> tag) that result in duplication of content.  
    1:     // We need to get the sink's notifications flushed and then make the binding
    1:     // ready.
    1:     if (count > 0) {
26413:       nsXBLBindingRequest* req = mBindingRequests.ElementAt(0);
    1:       nsIDocument* document = req->mBoundElement->GetCurrentDoc();
    1:       if (document)
    1:         document->FlushPendingNotifications(Flush_ContentAndNotify);
    1:     }
    1: 
    1:     // Remove ourselves from the set of pending docs.
    1:     nsBindingManager *bindingManager = doc->BindingManager();
 7672:     nsIURI* documentURI = bindingDocument->GetDocumentURI();
    1:     bindingManager->RemoveLoadingDocListener(documentURI);
    1: 
 7672:     if (!bindingDocument->GetRootContent()) {
    1:       NS_WARNING("*** XBL doc with no root element! Something went horribly wrong! ***");
    1:       return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     // Put our doc info in the doc table.
 7672:     nsBindingManager *xblDocBindingManager = bindingDocument->BindingManager();
    1:     nsCOMPtr<nsIXBLDocumentInfo> info =
    1:       xblDocBindingManager->GetXBLDocumentInfo(documentURI);
    1:     xblDocBindingManager->RemoveXBLDocumentInfo(info); // Break the self-imposed cycle.
    1:     if (!info) {
    1:       NS_ERROR("An XBL file is malformed.  Did you forget the XBL namespace on the bindings tag?");
    1:       return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     // If the doc is a chrome URI, then we put it into the XUL cache.
    1: #ifdef MOZ_XUL
    1:     if (IsChromeOrResourceURI(documentURI)) {
    1:       nsXULPrototypeCache* cache = nsXULPrototypeCache::GetInstance();
    1:       if (cache && cache->IsEnabled())
    1:         cache->PutXBLDocumentInfo(info);
    1:     }
    1: #endif
    1:   
    1:     bindingManager->PutXBLDocumentInfo(info);
    1: 
    1:     // Notify all pending requests that their bindings are
    1:     // ready and can be installed.
    1:     for (i = 0; i < count; i++) {
26413:       nsXBLBindingRequest* req = mBindingRequests.ElementAt(i);
 7672:       req->DocumentLoaded(bindingDocument);
    1:     }
    1:   }
    1: 
 1418:   target->RemoveEventListener(NS_LITERAL_STRING("load"), (nsIDOMLoadListener*)this, PR_FALSE);
    1: 
    1:   return rv;
    1: }
    1: 
    1: // Implementation /////////////////////////////////////////////////////////////////
    1: 
    1: // Static member variable initialization
    1: PRUint32 nsXBLService::gRefCnt = 0;
14747: PRBool nsXBLService::gAllowDataURIs = PR_FALSE;
    1: 
    1: nsHashtable* nsXBLService::gClassTable = nsnull;
    1: 
    1: JSCList  nsXBLService::gClassLRUList = JS_INIT_STATIC_CLIST(&nsXBLService::gClassLRUList);
    1: PRUint32 nsXBLService::gClassLRUListLength = 0;
    1: PRUint32 nsXBLService::gClassLRUListQuota = 64;
    1: 
    1: // Implement our nsISupports methods
    1: NS_IMPL_ISUPPORTS3(nsXBLService, nsIXBLService, nsIObserver, nsISupportsWeakReference)
    1: 
    1: // Constructors/Destructors
    1: nsXBLService::nsXBLService(void)
    1: {
    1:   mPool.Init("XBL Binding Requests", kBucketSizes, kNumBuckets, kInitialSize);
    1: 
    1:   gRefCnt++;
    1:   if (gRefCnt == 1) {
    1:     gClassTable = new nsHashtable();
    1:   }
14747:   
14747:   nsContentUtils::AddBoolPrefVarCache("layout.debug.enable_data_xbl",
14747:                                       &gAllowDataURIs);
    1: }
    1: 
    1: nsXBLService::~nsXBLService(void)
    1: {
    1:   gRefCnt--;
    1:   if (gRefCnt == 0) {
    1:     // Walk the LRU list removing and deleting the nsXBLJSClasses.
    1:     FlushMemory();
    1: 
    1:     // Any straggling nsXBLJSClass instances held by unfinalized JS objects
    1:     // created for bindings will be deleted when those objects are finalized
    1:     // (and not put on gClassLRUList, because length >= quota).
    1:     gClassLRUListLength = gClassLRUListQuota = 0;
    1: 
    1:     // At this point, the only hash table entries should be for referenced
    1:     // XBL class structs held by unfinalized JS binding objects.
    1:     delete gClassTable;
    1:     gClassTable = nsnull;
    1:   }
    1: }
    1: 
    1: // This function loads a particular XBL file and installs all of the bindings
    1: // onto the element.
    1: NS_IMETHODIMP
 3645: nsXBLService::LoadBindings(nsIContent* aContent, nsIURI* aURL,
 3645:                            nsIPrincipal* aOriginPrincipal, PRBool aAugmentFlag,
    1:                            nsXBLBinding** aBinding, PRBool* aResolveStyle) 
    1: {
 3645:   NS_PRECONDITION(aOriginPrincipal, "Must have an origin principal");
 3645:   
    1:   *aBinding = nsnull;
    1:   *aResolveStyle = PR_FALSE;
    1: 
    1:   nsresult rv;
    1: 
 1567:   nsCOMPtr<nsIDocument> document = aContent->GetOwnerDoc();
    1: 
    1:   // XXX document may be null if we're in the midst of paint suppression
    1:   if (!document)
    1:     return NS_OK;
    1: 
21636:   nsCAutoString urlspec;
21636:   if (nsContentUtils::GetWrapperSafeScriptFilename(document, aURL, urlspec)) {
21636:     // Block an attempt to load a binding that has special wrapper
21636:     // automation needs.
21636: 
21636:     return NS_OK;
21636:   }
21636: 
    1:   nsBindingManager *bindingManager = document->BindingManager();
    1:   
    1:   nsXBLBinding *binding = bindingManager->GetBinding(aContent);
    1:   if (binding && !aAugmentFlag) {
    1:     nsXBLBinding *styleBinding = binding->GetFirstStyleBinding();
    1:     if (styleBinding) {
    1:       if (binding->MarkedForDeath()) {
    1:         FlushStyleBindings(aContent);
    1:         binding = nsnull;
    1:       }
    1:       else {
    1:         // See if the URIs match.
34526:         if (styleBinding->PrototypeBinding()->CompareBindingURI(aURL))
    1:           return NS_OK;
    1:         FlushStyleBindings(aContent);
    1:         binding = nsnull;
    1:       }
    1:     }
    1:   }
    1: 
    1:   PRBool ready;
    1:   nsRefPtr<nsXBLBinding> newBinding;
 3645:   if (NS_FAILED(rv = GetBinding(aContent, aURL, PR_FALSE, aOriginPrincipal,
 3645:                                 &ready, getter_AddRefs(newBinding)))) {
    1:     return rv;
    1:   }
    1: 
    1:   if (!newBinding) {
    1: #ifdef DEBUG
    1:     nsCAutoString spec;
    1:     aURL->GetSpec(spec);
    1:     nsCAutoString str(NS_LITERAL_CSTRING("Failed to locate XBL binding. XBL is now using id instead of name to reference bindings. Make sure you have switched over.  The invalid binding name is: ") + spec);
    1:     NS_ERROR(str.get());
    1: #endif
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (::IsAncestorBinding(document, aURL, aContent)) {
    1:     return NS_ERROR_ILLEGAL_VALUE;
    1:   }
    1: 
    1:   if (aAugmentFlag) {
    1:     nsXBLBinding *baseBinding;
    1:     nsXBLBinding *nextBinding = newBinding;
    1:     do {
    1:       baseBinding = nextBinding;
    1:       nextBinding = baseBinding->GetBaseBinding();
    1:       baseBinding->SetIsStyleBinding(PR_FALSE);
    1:     } while (nextBinding);
    1: 
    1:     // XXX Handle adjusting the prototype chain! We need to somehow indicate to
    1:     // InstallImplementation that the whole chain should just be whacked and rebuilt.
    1:     // We are becoming the new binding.
    1:     baseBinding->SetBaseBinding(binding);
    1:     bindingManager->SetBinding(aContent, newBinding);
    1:   }
    1:   else {
    1:     // We loaded a style binding.  It goes on the end.
    1:     if (binding) {
    1:       // Get the last binding that is in the append layer.
    1:       binding->RootBinding()->SetBaseBinding(newBinding);
    1:     }
    1:     else {
    1:       // Install the binding on the content node.
    1:       bindingManager->SetBinding(aContent, newBinding);
    1:     }
    1:   }
    1: 
    1:   // Set the binding's bound element.
    1:   newBinding->SetBoundElement(aContent);
    1: 
    1:   // Tell the binding to build the anonymous content.
    1:   newBinding->GenerateAnonymousContent();
    1: 
13098:   // Tell the binding to install event handlers
13098:   newBinding->InstallEventHandlers();
13098: 
13098:   // Set up our properties
13098:   rv = newBinding->InstallImplementation();
13098:   NS_ENSURE_SUCCESS(rv, rv);
13098: 
    1:   // Figure out if we have any scoped sheets.  If so, we do a second resolve.
    1:   *aResolveStyle = newBinding->HasStyleSheets();
    1:   
 7216:   newBinding.swap(*aBinding);
 7216: 
    1:   return NS_OK; 
    1: }
    1: 
    1: nsresult
    1: nsXBLService::FlushStyleBindings(nsIContent* aContent)
    1: {
    1:   nsCOMPtr<nsIDocument> document = aContent->GetOwnerDoc();
    1: 
    1:   // XXX doc will be null if we're in the midst of paint suppression.
    1:   if (! document)
    1:     return NS_OK;
    1: 
    1:   nsBindingManager *bindingManager = document->BindingManager();
    1:   
    1:   nsXBLBinding *binding = bindingManager->GetBinding(aContent);
    1:   
    1:   if (binding) {
    1:     nsXBLBinding *styleBinding = binding->GetFirstStyleBinding();
    1: 
    1:     if (styleBinding) {
    1:       // Clear out the script references.
    1:       styleBinding->ChangeDocument(document, nsnull);
    1:     }
    1: 
    1:     if (styleBinding == binding) 
    1:       bindingManager->SetBinding(aContent, nsnull); // Flush old style bindings
    1:   }
    1:    
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXBLService::ResolveTag(nsIContent* aContent, PRInt32* aNameSpaceID,
    1:                          nsIAtom** aResult)
    1: {
    1:   nsIDocument* document = aContent->GetOwnerDoc();
    1:   if (document) {
    1:     *aResult = document->BindingManager()->ResolveTag(aContent, aNameSpaceID);
    1:     NS_IF_ADDREF(*aResult);
    1:   }
    1:   else {
    1:     *aNameSpaceID = aContent->GetNameSpaceID();
    1:     NS_ADDREF(*aResult = aContent->Tag());
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: //
    1: // AttachGlobalKeyHandler
    1: //
    1: // Creates a new key handler and prepares to listen to key events on the given
    1: // event receiver (either a document or an content node). If the receiver is content,
    1: // then extra work needs to be done to hook it up to the document (XXX WHY??)
    1: //
    1: NS_IMETHODIMP
 1418: nsXBLService::AttachGlobalKeyHandler(nsPIDOMEventTarget* aTarget)
    1: {
    1:   // check if the receiver is a content node (not a document), and hook
    1:   // it to the document if that is the case.
 1418:   nsCOMPtr<nsPIDOMEventTarget> piTarget = aTarget;
 1418:   nsCOMPtr<nsIContent> contentNode(do_QueryInterface(aTarget));
    1:   if (contentNode) {
    1:     // Only attach if we're really in a document
    1:     nsCOMPtr<nsIDocument> doc = contentNode->GetCurrentDoc();
    1:     if (doc)
 1418:       piTarget = do_QueryInterface(doc); // We're a XUL keyset. Attach to our document.
    1:   }
    1:     
 1418:   if (!piTarget)
    1:     return NS_ERROR_FAILURE;
    1: 
16430:   // the listener already exists, so skip this
16430:   if (contentNode && contentNode->GetProperty(nsGkAtoms::listener))
16430:     return NS_OK;
16430:     
    1:   nsCOMPtr<nsIDOMElement> elt(do_QueryInterface(contentNode));
    1: 
    1:   // Create the key handler
    1:   nsXBLWindowKeyHandler* handler;
 1418:   NS_NewXBLWindowKeyHandler(elt, piTarget, &handler); // This addRef's
    1:   if (!handler)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // listen to these events
    1:   nsCOMPtr<nsIDOMEventGroup> systemGroup;
 1418:   piTarget->GetSystemEventGroup(getter_AddRefs(systemGroup));
 1418:   nsCOMPtr<nsIDOM3EventTarget> target = do_QueryInterface(piTarget);
    1: 
    1:   target->AddGroupedEventListener(NS_LITERAL_STRING("keydown"), handler,
    1:                                   PR_FALSE, systemGroup);
    1:   target->AddGroupedEventListener(NS_LITERAL_STRING("keyup"), handler, 
    1:                                   PR_FALSE, systemGroup);
    1:   target->AddGroupedEventListener(NS_LITERAL_STRING("keypress"), handler, 
    1:                                   PR_FALSE, systemGroup);
    1: 
16430:   if (contentNode)
16430:     return contentNode->SetProperty(nsGkAtoms::listener, handler,
16430:                                     nsPropertyTable::SupportsDtorFunc, PR_TRUE);
16430: 
16430:   // release the handler. The reference will be maintained by the event target,
16430:   // and, if there is a content node, the property.
15435:   NS_RELEASE(handler);
16430:   return NS_OK;
16430: }
16430: 
16430: //
16430: // DetachGlobalKeyHandler
16430: //
16430: // Removes a key handler added by DeatchGlobalKeyHandler.
16430: //
16430: NS_IMETHODIMP
16430: nsXBLService::DetachGlobalKeyHandler(nsPIDOMEventTarget* aTarget)
16430: {
16430:   nsCOMPtr<nsPIDOMEventTarget> piTarget = aTarget;
16430:   nsCOMPtr<nsIContent> contentNode(do_QueryInterface(aTarget));
16430:   if (!contentNode) // detaching is only supported for content nodes
16430:     return NS_ERROR_FAILURE;
16430: 
16430:   // Only attach if we're really in a document
16430:   nsCOMPtr<nsIDocument> doc = contentNode->GetCurrentDoc();
16430:   if (doc)
16430:     piTarget = do_QueryInterface(doc);
16430:   if (!piTarget)
16430:     return NS_ERROR_FAILURE;
16430: 
16430:   nsIDOMEventListener* handler =
16430:     static_cast<nsIDOMEventListener*>(contentNode->GetProperty(nsGkAtoms::listener));
16430:   if (!handler)
16430:     return NS_ERROR_FAILURE;
16430: 
16430:   nsCOMPtr<nsIDOMEventGroup> systemGroup;
16430:   piTarget->GetSystemEventGroup(getter_AddRefs(systemGroup));
16430:   nsCOMPtr<nsIDOM3EventTarget> target = do_QueryInterface(piTarget);
16430: 
16430:   target->RemoveGroupedEventListener(NS_LITERAL_STRING("keydown"), handler,
16430:                                      PR_FALSE, systemGroup);
16430:   target->RemoveGroupedEventListener(NS_LITERAL_STRING("keyup"), handler, 
16430:                                      PR_FALSE, systemGroup);
16430:   target->RemoveGroupedEventListener(NS_LITERAL_STRING("keypress"), handler, 
16430:                                      PR_FALSE, systemGroup);
16430: 
16430:   contentNode->DeleteProperty(nsGkAtoms::listener);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXBLService::Observe(nsISupports* aSubject, const char* aTopic, const PRUnichar* aSomeData)
    1: {
    1:   if (nsCRT::strcmp(aTopic, "memory-pressure") == 0)
    1:     FlushMemory();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXBLService::FlushMemory()
    1: {
    1:   while (!JS_CLIST_IS_EMPTY(&gClassLRUList)) {
    1:     JSCList* lru = gClassLRUList.next;
 3233:     nsXBLJSClass* c = static_cast<nsXBLJSClass*>(lru);
    1: 
    1:     JS_REMOVE_AND_INIT_LINK(lru);
    1:     delete c;
    1:     gClassLRUListLength--;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // Internal helper methods ////////////////////////////////////////////////////////////////
    1: 
    1: NS_IMETHODIMP nsXBLService::BindingReady(nsIContent* aBoundElement, 
    1:                                          nsIURI* aURI, 
    1:                                          PRBool* aIsReady)
    1: {
 3645:   // Don't do a security check here; we know this binding is set to go.
 3645:   return GetBinding(aBoundElement, aURI, PR_TRUE, nsnull, aIsReady, nsnull);
    1: }
    1: 
    1: nsresult
    1: nsXBLService::GetBinding(nsIContent* aBoundElement, nsIURI* aURI, 
 3645:                          PRBool aPeekOnly, nsIPrincipal* aOriginPrincipal,
 3645:                          PRBool* aIsReady, nsXBLBinding** aResult)
    1: {
    1:   // More than 6 binding URIs are rare, see bug 55070 comment 18.
 8996:   nsAutoTArray<nsIURI*, 6> uris;
 3645:   return GetBinding(aBoundElement, aURI, aPeekOnly, aOriginPrincipal, aIsReady,
 3645:                     aResult, uris);
    1: }
    1: 
    1: nsresult
    1: nsXBLService::GetBinding(nsIContent* aBoundElement, nsIURI* aURI, 
 3645:                          PRBool aPeekOnly, nsIPrincipal* aOriginPrincipal,
 3645:                          PRBool* aIsReady, nsXBLBinding** aResult,
    1:                          nsTArray<nsIURI*>& aDontExtendURIs)
    1: {
    1:   NS_ASSERTION(aPeekOnly || aResult,
    1:                "Must have non-null out param if not just peeking to see "
    1:                "whether the binding is ready");
    1:   
    1:   if (aResult)
    1:     *aResult = nsnull;
    1: 
    1:   if (!aURI)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCAutoString ref;
    1:   nsCOMPtr<nsIURL> url(do_QueryInterface(aURI));
    1:   if (url)
    1:     url->GetRef(ref);
    1: 
    1:   nsCOMPtr<nsIDocument> boundDocument = aBoundElement->GetOwnerDoc();
    1: 
    1:   nsCOMPtr<nsIXBLDocumentInfo> docInfo;
 3645:   nsresult rv = LoadBindingDocumentInfo(aBoundElement, boundDocument, aURI,
 3645:                                         aOriginPrincipal,
 3645:                                         PR_FALSE, getter_AddRefs(docInfo));
 3645:   NS_ENSURE_SUCCESS(rv, rv);
 3645:   
    1:   if (!docInfo)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // Get our doc info and determine our script access.
    1:   nsCOMPtr<nsIDocument> doc;
    1:   docInfo->GetDocument(getter_AddRefs(doc));
    1:   PRBool allowScripts;
    1:   docInfo->GetScriptAccess(&allowScripts);
    1: 
    1:   nsXBLPrototypeBinding* protoBinding;
    1:   docInfo->GetPrototypeBinding(ref, &protoBinding);
    1: 
    1:   NS_ASSERTION(protoBinding, "Unable to locate an XBL binding.");
    1:   if (!protoBinding)
    1:     return NS_ERROR_FAILURE;
    1: 
34526:   NS_ENSURE_TRUE(aDontExtendURIs.AppendElement(protoBinding->BindingURI()),
34526:                  NS_ERROR_OUT_OF_MEMORY);
34526:   nsCOMPtr<nsIURI> altBindingURI = protoBinding->AlternateBindingURI();
34526:   if (altBindingURI) {
34526:     NS_ENSURE_TRUE(aDontExtendURIs.AppendElement(altBindingURI),
34526:                    NS_ERROR_OUT_OF_MEMORY);
34526:   }
34526: 
    1:   nsCOMPtr<nsIContent> child = protoBinding->GetBindingElement();
    1: 
    1:   // Our prototype binding must have all its resources loaded.
    1:   PRBool ready = protoBinding->LoadResources();
    1:   if (!ready) {
    1:     // Add our bound element to the protos list of elts that should
    1:     // be notified when the stylesheets and scripts finish loading.
    1:     protoBinding->AddResourceListener(aBoundElement);
    1:     return NS_ERROR_FAILURE; // The binding isn't ready yet.
    1:   }
    1: 
    1:   // If our prototype already has a base, then don't check for an "extends" attribute.
    1:   nsRefPtr<nsXBLBinding> baseBinding;
    1:   PRBool hasBase = protoBinding->HasBasePrototype();
    1:   nsXBLPrototypeBinding* baseProto = protoBinding->GetBasePrototype();
    1:   if (baseProto) {
 3645:     // Use the NodePrincipal() of the <binding> element in question
 3645:     // for the security check.
 3645:     rv = GetBinding(aBoundElement, baseProto->BindingURI(), aPeekOnly,
 3645:                     child->NodePrincipal(), aIsReady,
 3645:                     getter_AddRefs(baseBinding), aDontExtendURIs);
    1:     if (NS_FAILED(rv))
    1:       return rv; // We aren't ready yet.
    1:   }
    1:   else if (hasBase) {
    1:     // Check for the presence of 'extends' and 'display' attributes
    1:     nsAutoString display, extends;
    1:     child->GetAttr(kNameSpaceID_None, nsGkAtoms::display, display);
    1:     child->GetAttr(kNameSpaceID_None, nsGkAtoms::extends, extends);
    1:     PRBool hasDisplay = !display.IsEmpty();
    1:     PRBool hasExtends = !extends.IsEmpty();
    1:     
    1:     nsAutoString value(extends);
    1:          
    1:     if (!hasExtends) 
    1:       protoBinding->SetHasBasePrototype(PR_FALSE);
    1:     else {
    1:       // Now slice 'em up to see what we've got.
    1:       nsAutoString prefix;
    1:       PRInt32 offset;
    1:       if (hasDisplay) {
    1:         offset = display.FindChar(':');
    1:         if (-1 != offset) {
    1:           display.Left(prefix, offset);
    1:           display.Cut(0, offset+1);
    1:         }
    1:       }
    1:       else if (hasExtends) {
    1:         offset = extends.FindChar(':');
    1:         if (-1 != offset) {
    1:           extends.Left(prefix, offset);
    1:           extends.Cut(0, offset+1);
    1:           display = extends;
    1:         }
    1:       }
    1: 
    1:       nsAutoString nameSpace;
    1: 
    1:       if (!prefix.IsEmpty()) {
    1:         nsCOMPtr<nsIAtom> prefixAtom = do_GetAtom(prefix);
    1: 
    1:         nsCOMPtr<nsIDOM3Node> node(do_QueryInterface(child));
    1: 
    1:         if (node) {
    1:           node->LookupNamespaceURI(prefix, nameSpace);
    1: 
    1:           if (!nameSpace.IsEmpty()) {
    1:             if (!hasDisplay) {
    1:               // We extend some widget/frame. We don't really have a
    1:               // base binding.
    1:               protoBinding->SetHasBasePrototype(PR_FALSE);
    1:               //child->UnsetAttr(kNameSpaceID_None, nsGkAtoms::extends, PR_FALSE);
    1:             }
    1: 
    1:             PRInt32 nameSpaceID =
    1:               nsContentUtils::NameSpaceManager()->GetNameSpaceID(nameSpace);
    1: 
    1:             nsCOMPtr<nsIAtom> tagName = do_GetAtom(display);
16019:             // Check the white list
16019:             if (!CheckTagNameWhiteList(nameSpaceID, tagName)) {
16019:               const PRUnichar* params[] = { display.get() };
16019:               nsContentUtils::ReportToConsole(nsContentUtils::eXBL_PROPERTIES,
16019:                                               "InvalidExtendsBinding",
16019:                                               params, NS_ARRAY_LENGTH(params),
16019:                                               doc->GetDocumentURI(),
16019:                                               EmptyString(), 0, 0,
16019:                                               nsIScriptError::errorFlag,
16019:                                               "XBL");
19718:               NS_ASSERTION(!IsChromeOrResourceURI(aURI),
19718:                            "Invalid extends value");
16019:               return NS_ERROR_ILLEGAL_VALUE;
16019:             }
16019: 
    1:             protoBinding->SetBaseTag(nameSpaceID, tagName);
    1:           }
    1:         }
    1:       }
    1: 
    1:       if (hasExtends && (hasDisplay || nameSpace.IsEmpty())) {
    1:         // Look up the prefix.
    1:         // We have a base class binding. Load it right now.
    1:         nsCOMPtr<nsIURI> bindingURI;
 3645:         rv = NS_NewURI(getter_AddRefs(bindingURI), value,
    1:                        doc->GetDocumentCharacterSet().get(),
    1:                        doc->GetBaseURI());
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:         
    1:         PRUint32 count = aDontExtendURIs.Length();
    1:         for (PRUint32 index = 0; index < count; ++index) {
    1:           PRBool equal;
    1:           rv = aDontExtendURIs[index]->Equals(bindingURI, &equal);
    1:           NS_ENSURE_SUCCESS(rv, rv);
    1:           if (equal) {
    1:             nsCAutoString spec;
    1:             protoBinding->BindingURI()->GetSpec(spec);
    1:             NS_ConvertUTF8toUTF16 protoSpec(spec);
    1:             const PRUnichar* params[] = { protoSpec.get(), value.get() };
    1:             nsContentUtils::ReportToConsole(nsContentUtils::eXBL_PROPERTIES,
    1:                                             "CircularExtendsBinding",
    1:                                             params, NS_ARRAY_LENGTH(params),
    1:                                             boundDocument->GetDocumentURI(),
    1:                                             EmptyString(), 0, 0,
    1:                                             nsIScriptError::warningFlag,
    1:                                             "XBL");
    1:             return NS_ERROR_ILLEGAL_VALUE;
    1:           }
    1:         }
    1: 
 3645:         // Use the NodePrincipal() of the <binding> element in question
 3645:         // for the security check.
 3645:         rv = GetBinding(aBoundElement, bindingURI, aPeekOnly,
 3645:                         child->NodePrincipal(), aIsReady,
    1:                         getter_AddRefs(baseBinding), aDontExtendURIs);
    1:         if (NS_FAILED(rv))
    1:           return rv; // Binding not yet ready or an error occurred.
    1:         if (!aPeekOnly) {
    1:           // Make sure to set the base prototype.
    1:           baseProto = baseBinding->PrototypeBinding();
    1:           protoBinding->SetBasePrototype(baseProto);
    1:           child->UnsetAttr(kNameSpaceID_None, nsGkAtoms::extends, PR_FALSE);
    1:           child->UnsetAttr(kNameSpaceID_None, nsGkAtoms::display, PR_FALSE);
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   *aIsReady = PR_TRUE;
    1:   if (!aPeekOnly) {
    1:     // Make a new binding
    1:     nsXBLBinding *newBinding = new nsXBLBinding(protoBinding);
    1:     NS_ENSURE_TRUE(newBinding, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     if (baseBinding)
    1:       newBinding->SetBaseBinding(baseBinding);
    1: 
    1:     NS_ADDREF(*aResult = newBinding);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
25976: static PRBool SchemeIs(nsIURI* aURI, const char* aScheme)
25976: {
25976:   nsCOMPtr<nsIURI> baseURI = NS_GetInnermostURI(aURI);
25976:   NS_ENSURE_TRUE(baseURI, PR_FALSE);
25976: 
25976:   PRBool isScheme = PR_FALSE;
25976:   return NS_SUCCEEDED(baseURI->SchemeIs(aScheme, &isScheme)) && isScheme;
25976: }
25976: 
    1: NS_IMETHODIMP
    1: nsXBLService::LoadBindingDocumentInfo(nsIContent* aBoundElement,
    1:                                       nsIDocument* aBoundDocument,
    1:                                       nsIURI* aBindingURI,
 3645:                                       nsIPrincipal* aOriginPrincipal,
    1:                                       PRBool aForceSyncLoad,
    1:                                       nsIXBLDocumentInfo** aResult)
    1: {
    1:   NS_PRECONDITION(aBindingURI, "Must have a binding URI");
 3645:   NS_PRECONDITION(!aOriginPrincipal || aBoundDocument,
 3645:                   "If we're doing a security check, we better have a document!");
    1:   
 2324:   nsresult rv;
 3645:   if (aOriginPrincipal) {
 3645:     // Security check - Enforce same-origin policy, except to chrome.
 3645:     // We have to be careful to not pass aContent as the context here. 
 3645:     // Otherwise, if there is a JS-implemented content policy, we will attempt
 3645:     // to wrap the content node, which will try to load XBL bindings for it, if
 3645:     // any. Since we're not done loading this binding yet, that will reenter
 3645:     // this method and we'll end up creating a binding and then immediately
 3645:     // clobbering it in our table.  That makes things very confused, leading to
 3645:     // misbehavior and crashes.
 2324:     rv = nsContentUtils::
 3645:       CheckSecurityBeforeLoad(aBindingURI, aOriginPrincipal,
 2324:                               nsIScriptSecurityManager::ALLOW_CHROME,
14747:                               gAllowDataURIs,
 2501:                               nsIContentPolicy::TYPE_XBL,
 2324:                               aBoundDocument);
 2324:     NS_ENSURE_SUCCESS(rv, rv);
25971: 
25971:     // Also make sure that we're same-origin with the bound document
26242:     // except if the stylesheet has the system principal.
26242:     PRBool isSystem;
26242:     rv = nsContentUtils::GetSecurityManager()->
26242:       IsSystemPrincipal(aOriginPrincipal, &isSystem);
25971:     NS_ENSURE_SUCCESS(rv, rv);
25971: 
26242:     if (!isSystem &&
25977:         !(gAllowDataURIs && SchemeIs(aBindingURI, "data")) &&
25977:         !SchemeIs(aBindingURI, "chrome")) {
25971:       rv = aBoundDocument->NodePrincipal()->CheckMayLoad(aBindingURI,
25971:                                                          PR_TRUE);
25971:       NS_ENSURE_SUCCESS(rv, rv);
25971:     }
25971:   }
    1: 
    1:   *aResult = nsnull;
    1:   nsCOMPtr<nsIXBLDocumentInfo> info;
    1: 
    1:   nsCOMPtr<nsIURI> documentURI;
    1:   rv = aBindingURI->Clone(getter_AddRefs(documentURI));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:   nsCOMPtr<nsIURL> documentURL(do_QueryInterface(documentURI));
    1:   if (documentURL)
    1:     documentURL->SetRef(EmptyCString());
    1: 
    1: #ifdef MOZ_XUL
    1:   // We've got a file.  Check our XBL document cache.
    1:   nsXULPrototypeCache* cache = nsXULPrototypeCache::GetInstance();
    1:   PRBool useXULCache = cache && cache->IsEnabled(); 
    1: 
    1:   if (useXULCache) {
    1:     // The first line of defense is the chrome cache.  
    1:     // This cache crosses the entire product, so that any XBL bindings that are
    1:     // part of chrome will be reused across all XUL documents.
    1:     info = cache->GetXBLDocumentInfo(documentURI); 
    1:   }
    1: #endif
    1: 
    1:   if (!info) {
    1:     // The second line of defense is the binding manager's document table.
    1:     nsBindingManager *bindingManager = nsnull;
    1: 
    1:     if (aBoundDocument) {
    1:       bindingManager = aBoundDocument->BindingManager();
    1:       info = bindingManager->GetXBLDocumentInfo(documentURI);
    1:     }
    1: 
    1:     nsINodeInfo *ni = nsnull;
    1:     if (aBoundElement)
    1:       ni = aBoundElement->NodeInfo();
    1: 
    1:     if (!info && bindingManager &&
    1:         (!ni || !(ni->Equals(nsGkAtoms::scrollbar, kNameSpaceID_XUL) ||
    1:                   ni->Equals(nsGkAtoms::thumb, kNameSpaceID_XUL) ||
    1:                   ((ni->Equals(nsGkAtoms::input) ||
    1:                     ni->Equals(nsGkAtoms::select)) &&
33329:                    aBoundElement->IsHTML()))) && !aForceSyncLoad) {
    1:       // The third line of defense is to investigate whether or not the
    1:       // document is currently being loaded asynchronously.  If so, there's no
    1:       // document yet, but we need to glom on our request so that it will be
    1:       // processed whenever the doc does finish loading.
    1:       nsCOMPtr<nsIStreamListener> listener;
    1:       if (bindingManager)
    1:         listener = bindingManager->GetLoadingDocListener(documentURI);
    1:       if (listener) {
    1:         nsXBLStreamListener* xblListener =
 3233:           static_cast<nsXBLStreamListener*>(listener.get());
    1:         // Create a new load observer.
    1:         if (!xblListener->HasRequest(aBindingURI, aBoundElement)) {
    1:           nsXBLBindingRequest* req = nsXBLBindingRequest::Create(mPool, aBindingURI, aBoundElement);
    1:           xblListener->AddRequest(req);
    1:         }
    1:         return NS_OK;
    1:       }
    1:     }
    1:      
    1:     if (!info) {
    1:       // Finally, if all lines of defense fail, we go and fetch the binding
    1:       // document.
    1:       
    1:       // Always load chrome synchronously
    1:       PRBool chrome;
    1:       if (NS_SUCCEEDED(documentURI->SchemeIs("chrome", &chrome)) && chrome)
    1:         aForceSyncLoad = PR_TRUE;
    1: 
    1:       nsCOMPtr<nsIDocument> document;
    1:       FetchBindingDocument(aBoundElement, aBoundDocument, documentURI,
    1:                            aBindingURI, aForceSyncLoad, getter_AddRefs(document));
    1:    
    1:       if (document) {
    1:         nsBindingManager *xblDocBindingManager = document->BindingManager();
    1:         info = xblDocBindingManager->GetXBLDocumentInfo(documentURI);
    1:         if (!info) {
    1:           NS_ERROR("An XBL file is malformed.  Did you forget the XBL namespace on the bindings tag?");
    1:           return NS_ERROR_FAILURE;
    1:         }
    1:         xblDocBindingManager->RemoveXBLDocumentInfo(info); // Break the self-imposed cycle.
    1: 
    1:         // If the doc is a chrome URI, then we put it into the XUL cache.
    1: #ifdef MOZ_XUL
    1:         if (useXULCache && IsChromeOrResourceURI(documentURI)) {
    1:           cache->PutXBLDocumentInfo(info);
    1:         }
    1: #endif
    1:         
    1:         if (bindingManager) {
    1:           // Also put it in our binding manager's document table.
    1:           bindingManager->PutXBLDocumentInfo(info);
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (!info)
    1:     return NS_OK;
    1:  
    1:   *aResult = info;
    1:   NS_IF_ADDREF(*aResult);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXBLService::FetchBindingDocument(nsIContent* aBoundElement, nsIDocument* aBoundDocument,
    1:                                    nsIURI* aDocumentURI, nsIURI* aBindingURI, 
    1:                                    PRBool aForceSyncLoad, nsIDocument** aResult)
    1: {
    1:   nsresult rv = NS_OK;
    1:   // Initialize our out pointer to nsnull
    1:   *aResult = nsnull;
    1: 
23631:   // Now we have to synchronously load the binding file.
23631:   // Create an XML content sink and a parser. 
    1:   nsCOMPtr<nsILoadGroup> loadGroup;
    1:   if (aBoundDocument)
    1:     loadGroup = aBoundDocument->GetDocumentLoadGroup();
    1: 
    1:   // We really shouldn't have to force a sync load for anything here... could
    1:   // we get away with not doing that?  Not sure.
    1:   if (IsChromeOrResourceURI(aDocumentURI))
    1:     aForceSyncLoad = PR_TRUE;
    1: 
    1:   // Create document and contentsink and set them up.
    1:   nsCOMPtr<nsIDocument> doc;
    1:   rv = NS_NewXMLDocument(getter_AddRefs(doc));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIXMLContentSink> xblSink;
    1:   rv = NS_NewXBLContentSink(getter_AddRefs(xblSink), doc, aDocumentURI, nsnull);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Open channel
    1:   nsCOMPtr<nsIChannel> channel;
    1:   rv = NS_NewChannel(getter_AddRefs(channel), aDocumentURI, nsnull, loadGroup);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
18942:   nsCOMPtr<nsIInterfaceRequestor> sameOriginChecker = nsContentUtils::GetSameOriginChecker();
 2324:   NS_ENSURE_TRUE(sameOriginChecker, NS_ERROR_OUT_OF_MEMORY);
 2324: 
 2324:   channel->SetNotificationCallbacks(sameOriginChecker);
 2324: 
    1:   if (!aForceSyncLoad) {
    1:     // We can be asynchronous
23645:     nsXBLStreamListener* xblListener =
23645:       new nsXBLStreamListener(this, aBoundDocument, xblSink, doc);
    1:     NS_ENSURE_TRUE(xblListener,NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     // Add ourselves to the list of loading docs.
    1:     nsBindingManager *bindingManager;
    1:     if (aBoundDocument)
    1:       bindingManager = aBoundDocument->BindingManager();
    1:     else
    1:       bindingManager = nsnull;
    1: 
    1:     if (bindingManager)
    1:       bindingManager->PutLoadingDocListener(aDocumentURI, xblListener);
    1: 
    1:     // Add our request.
    1:     nsXBLBindingRequest* req = nsXBLBindingRequest::Create(mPool,
    1:                                                            aBindingURI,
    1:                                                            aBoundElement);
    1:     xblListener->AddRequest(req);
    1: 
    1:     // Now kick off the async read.
22745:     rv = channel->AsyncOpen(xblListener, nsnull);
22745:     if (NS_FAILED(rv)) {
22745:       // Well, we won't be getting a load.  Make sure to clean up our stuff!
22745:       if (bindingManager) {
22745:         bindingManager->RemoveLoadingDocListener(aDocumentURI);
22745:       }
22745:     }
    1:     return NS_OK;
    1:   }
    1: 
23645:   nsCOMPtr<nsIStreamListener> listener;
23645:   rv = doc->StartDocumentLoad("loadAsInteractiveData",
23645:                               channel,
23645:                               loadGroup,
23645:                               nsnull,
23645:                               getter_AddRefs(listener),
23645:                               PR_TRUE,
23645:                               xblSink);
23645:   NS_ENSURE_SUCCESS(rv, rv);
23645: 
    1:   // Now do a blocking synchronous parse of the file.
    1:   nsCOMPtr<nsIInputStream> in;
    1:   rv = channel->Open(getter_AddRefs(in));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = nsSyncLoadService::PushSyncStreamToListener(in, listener, channel);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   doc.swap(*aResult);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // Creation Routine ///////////////////////////////////////////////////////////////////////
    1: 
    1: nsresult NS_NewXBLService(nsIXBLService** aResult);
    1: 
    1: nsresult
    1: NS_NewXBLService(nsIXBLService** aResult)
    1: {
    1:   nsXBLService* result = new nsXBLService;
    1:   if (! result)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ADDREF(*aResult = result);
    1: 
    1:   // Register the first (and only) nsXBLService as a memory pressure observer
    1:   // so it can flush the LRU list in low-memory situations.
    1:   nsCOMPtr<nsIObserverService> os = do_GetService("@mozilla.org/observer-service;1");
    1:   if (os)
    1:     os->AddObserver(result, "memory-pressure", PR_TRUE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
