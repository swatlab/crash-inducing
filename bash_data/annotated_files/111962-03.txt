111677: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
111677:  * vim: set ts=4 sw=4 et tw=79:
111677:  *
111677:  * ***** BEGIN LICENSE BLOCK *****
111677:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
111677:  *
111677:  * The contents of this file are subject to the Mozilla Public License Version
111677:  * 1.1 (the "License"); you may not use this file except in compliance with
111677:  * the License. You may obtain a copy of the License at
111677:  * http://www.mozilla.org/MPL/
111677:  *
111677:  * Software distributed under the License is distributed on an "AS IS" basis,
111677:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
111677:  * for the specific language governing rights and limitations under the
111677:  * License.
111677:  *
111677:  * The Original Code is Mozilla Communicator client code, released
111677:  * March 31, 1998.
111677:  *
111677:  * The Initial Developer of the Original Code is
111677:  * Netscape Communications Corporation.
111677:  * Portions created by the Initial Developer are Copyright (C) 1998
111677:  * the Initial Developer. All Rights Reserved.
111677:  *
111677:  * Contributor(s):
111758:  *   Andrew Drake <adrake@adrake.org>
111677:  *
111677:  * Alternatively, the contents of this file may be used under the terms of
111677:  * either of the GNU General Public License Version 2 or later (the "GPL"),
111677:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
111677:  * in which case the provisions of the GPL or the LGPL are applicable instead
111677:  * of those above. If you wish to allow use of your version of this file only
111677:  * under the terms of either the GPL or the LGPL, and not to allow others to
111677:  * use your version of this file under the terms of the MPL, indicate your
111677:  * decision by deleting the provisions above and replace them with the notice
111677:  * and other provisions required by the GPL or the LGPL. If you do not delete
111677:  * the provisions above, a recipient may use your version of this file under
111677:  * the terms of any one of the MPL, the GPL or the LGPL.
111677:  *
111677:  * ***** END LICENSE BLOCK ***** */
111677: 
111677: #include "Ion.h"
111706: #include "IonAnalysis.h"
111706: #include "IonBuilder.h"
111736: #include "IonSpewer.h"
111706: #include "IonLIR.h"
111732: #include "GreedyAllocator.h"
111744: #include "LICM.h"
111756: #include "ValueNumbering.h"
111758: #include "LinearScan.h"
111804: #include "jscompartment.h"
111845: #include "IonCompartment.h"
111930: #include "CodeGenerator.h"
111706: 
111706: #if defined(JS_CPU_X86)
111706: # include "x86/Lowering-x86.h"
111706: #elif defined(JS_CPU_X64)
111706: # include "x64/Lowering-x64.h"
111706: #elif defined(JS_CPU_ARM)
111706: # include "arm/Lowering-arm.h"
111706: #endif
111793: #include "jsgcmark.h"
111793: #include "jsgcinlines.h"
111818: #include "vm/Stack-inl.h"
111677: 
111677: using namespace js;
111677: using namespace js::ion;
111677: 
111791: IonOptions ion::js_IonOptions;
111791: 
111793: // Assert that IonCode is gc::Cell aligned.
111793: JS_STATIC_ASSERT(sizeof(IonCode) % gc::Cell::CellSize == 0);
111793: 
111677: #ifdef JS_THREADSAFE
111677: static bool IonTLSInitialized = false;
111677: static PRUintn IonTLSIndex;
111677: #else
111677: static IonContext *GlobalIonContext;
111677: #endif
111677: 
111677: IonContext::IonContext(JSContext *cx, TempAllocator *temp)
111677:   : cx(cx),
111677:     temp(temp)
111677: {
111677:     SetIonContext(this);
111706: }
111677: 
111677: IonContext::~IonContext()
111677: {
111677:     SetIonContext(NULL);
111677: }
111677: 
111782: bool
111782: ion::InitializeIon()
111677: {
111677: #ifdef JS_THREADSAFE
111677:     if (!IonTLSInitialized) {
111677:         PRStatus status = PR_NewThreadPrivateIndex(&IonTLSIndex, NULL);
111677:         if (status != PR_SUCCESS)
111677:             return false;
111677:         IonTLSInitialized = true;
111677:     }
111677: #endif
111734:     CheckLogging();
111677:     return true;
111677: }
111677: 
111677: #ifdef JS_THREADSAFE
111782: IonContext *
111782: ion::GetIonContext()
111677: {
111677:     return (IonContext *)PR_GetThreadPrivate(IonTLSIndex);
111677: }
111677: 
111782: bool
111782: ion::SetIonContext(IonContext *ctx)
111677: {
111677:     return PR_SetThreadPrivate(IonTLSIndex, ctx) == PR_SUCCESS;
111677: }
111677: #else
111782: IonContext *
111782: ion::GetIonContext()
111677: {
111677:     JS_ASSERT(GlobalIonContext);
111677:     return GlobalIonContext;
111677: }
111677: 
111782: bool
111782: ion::SetIonContext(IonContext *ctx)
111677: {
111677:     GlobalIonContext = ctx;
111677:     return true;
111677: }
111677: #endif
111677: 
111805: IonCompartment::IonCompartment()
111805:   : execAlloc_(NULL),
111935:     enterJIT_(NULL),
111935:     bailoutHandler_(NULL),
111935:     returnError_(NULL)
111805: {
111805: }
111805: 
111805: bool
111805: IonCompartment::initialize(JSContext *cx)
111805: {
111817:     execAlloc_ = js::OffTheBooks::new_<JSC::ExecutableAllocator>();
111817:     if (!execAlloc_)
111805:         return false;
111805: 
111805:     return true;
111805: }
111805: 
111817: void
111817: IonCompartment::mark(JSTracer *trc, JSCompartment *compartment)
111817: {
111936:     if (!compartment->active)
111936:         return;
111936: 
111935:     // These must be available if we could be running JIT code.
111935:     if (enterJIT_)
111817:         MarkIonCode(trc, enterJIT_, "enterJIT");
111935:     if (returnError_)
111935:         MarkIonCode(trc, returnError_, "returnError");
111935: 
111935:     // These need to be here until we can figure out how to make the GC
111935:     // scan these references inside the code generator itself.
111935:     if (bailoutHandler_)
111935:         MarkIonCode(trc, bailoutHandler_, "bailoutHandler");
111935:     for (size_t i = 0; i < bailoutTables_.length(); i++) {
111935:         if (bailoutTables_[i])
111935:             MarkIonCode(trc, bailoutTables_[i], "bailoutTable");
111935:     }
111935: }
111817: 
111817: void
111817: IonCompartment::sweep(JSContext *cx)
111817: {
111817:     if (enterJIT_ && IsAboutToBeFinalized(cx, enterJIT_))
111817:         enterJIT_ = NULL;
111935:     if (bailoutHandler_ && IsAboutToBeFinalized(cx, bailoutHandler_))
111935:         bailoutHandler_ = NULL;
111935:     if (returnError_ && IsAboutToBeFinalized(cx, returnError_))
111935:         returnError_ = NULL;
111935: 
111935:     for (size_t i = 0; i < bailoutTables_.length(); i++) {
111935:         if (bailoutTables_[i] && IsAboutToBeFinalized(cx, bailoutTables_[i]))
111935:             bailoutTables_[i] = NULL;
111935:     }
111935: }
111935: 
111935: IonCode *
111935: IonCompartment::getBailoutTable(const FrameSizeClass &frameClass)
111935: {
111935:     JS_ASSERT(frameClass != FrameSizeClass::None());
111935:     return bailoutTables_[frameClass.classId()];
111935: }
111935: 
111935: IonCode *
111935: IonCompartment::getBailoutTable(JSContext *cx, const FrameSizeClass &frameClass)
111935: {
111935:     uint32 id = frameClass.classId();
111935: 
111935:     if (id >= bailoutTables_.length()) {
111935:         size_t numToPush = id - bailoutTables_.length() + 1;
111935:         if (!bailoutTables_.reserve(bailoutTables_.length() + numToPush))
111935:             return NULL;
111935:         for (size_t i = 0; i < numToPush; i++)
111935:             bailoutTables_.infallibleAppend(NULL);
111935:     }
111935: 
111935:     if (!bailoutTables_[id])
111935:         bailoutTables_[id] = generateBailoutTable(cx, id);
111935: 
111935:     return bailoutTables_[id];
111817: }
111817: 
111805: IonCompartment::~IonCompartment()
111805: {
111817:     Foreground::delete_(execAlloc_);
111805: }
111805: 
111935: IonActivation::IonActivation(JSContext *cx, StackFrame *fp)
111935:   : cx_(cx),
111935:     prev_(cx->compartment->ionCompartment()->activation()),
111935:     entryfp_(fp),
111935:     oldFrameRegs_(cx->regs()),
111935:     bailout_(NULL)
111935: {
111935:     cx->compartment->ionCompartment()->active_ = this;
111935:     cx->stack.repointRegs(NULL);
111935: }
111935: 
111935: IonActivation::~IonActivation()
111935: {
111935:     JS_ASSERT(cx_->compartment->ionCompartment()->active_ == this);
111935:     JS_ASSERT(!bailout_);
111935: 
111935:     cx_->compartment->ionCompartment()->active_ = prev();
111935:     cx_->stack.repointRegs(&oldFrameRegs_);
111935: }
111935: 
111793: IonCode *
111865: IonCode::New(JSContext *cx, uint8 *code, uint32 bufferSize, JSC::ExecutablePool *pool)
111793: {
111793:     IonCode *codeObj = NewGCThing<IonCode>(cx, gc::FINALIZE_IONCODE, sizeof(IonCode));
111793:     if (!codeObj) {
111793:         pool->release();
111793:         return NULL;
111793:     }
111793: 
111865:     new (codeObj) IonCode(code, bufferSize, pool);
111793:     return codeObj;
111793: }
111793: 
111782: void
111865: IonCode::copyFrom(MacroAssembler &masm)
111865: {
111865:     // Store the IonCode pointer right before the code buffer, so we can
111865:     // recover the gcthing from relocation tables.
111865:     *(IonCode **)(code_ - sizeof(IonCode *)) = this;
111865: 
111865:     insnSize_ = masm.instructionsSize();
111865:     masm.executableCopy(code_);
111865: 
111922:     masm.processCodeLabels(code_);
111922: 
111920:     dataSize_ = masm.dataSize();
111920:     masm.processDeferredData(code_, code_ + dataOffset());
111920: 
111865:     relocTableSize_ = masm.relocationTableSize();
111920:     masm.copyRelocationTable(code_ + relocTableOffset());
111865: }
111865: 
111865: void
111865: IonCode::trace(JSTracer *trc)
111865: {
111865:     if (relocTableSize_) {
111920:         uint8 *start = code_ + relocTableOffset();
111865:         CompactBufferReader reader(start, start + relocTableSize_);
111865:         MacroAssembler::TraceRelocations(trc, this, reader);
111865:     }
111865: }
111865: 
111865: void
111793: IonCode::finalize(JSContext *cx)
111782: {
111782:     if (pool_)
111782:         pool_->release();
111793: }
111793: 
111818: IonScript::IonScript()
111935:   : method_(NULL),
111935:     deoptTable_(NULL),
111935:     snapshots_(0),
111935:     snapshotsSize_(0),
111935:     bailoutTable_(0),
111935:     bailoutEntries_(0)
111818: {
111818: }
111818: 
111818: IonScript *
111935: IonScript::New(JSContext *cx, size_t snapshotsSize, size_t bailoutEntries)
111818: {
111935:     if (snapshotsSize >= MAX_BUFFER_SIZE ||
111935:         (bailoutEntries >= MAX_BUFFER_SIZE / sizeof(uint32)))
111935:     {
111935:         js_ReportOutOfMemory(cx);
111935:         return NULL;
111818:     }
111818: 
111935:     // This should not overflow on x86, because the memory is already allocated
111935:     // *somewhere* and if their total overflowed there would be no memory left
111935:     // at all.
111935:     size_t bytes = snapshotsSize +
111935:                    bailoutEntries * sizeof(uint32);
111935:     uint8 *buffer = (uint8 *)cx->malloc_(sizeof(IonScript) + bytes);
111935:     if (!buffer)
111935:         return NULL;
111935: 
111935:     IonScript *script = reinterpret_cast<IonScript *>(buffer);
111935:     new (script) IonScript();
111935: 
111935:     script->snapshots_ = sizeof(IonScript);
111935:     script->snapshotsSize_ = snapshotsSize;
111935: 
111935:     script->bailoutTable_ = script->snapshots_ + snapshotsSize;
111935:     script->bailoutEntries_ = bailoutEntries;
111935: 
111935:     return script;
111935: }
111935: 
111935: 
111793: void
111793: IonScript::trace(JSTracer *trc, JSScript *script)
111793: {
111818:     if (method_)
111818:         MarkIonCode(trc, method_, "method");
111935:     if (deoptTable_)
111935:         MarkIonCode(trc, deoptTable_, "deoptimizationTable");
111935: }
111935: 
111935: void
111935: IonScript::copySnapshots(const SnapshotWriter *writer)
111935: {
111935:     JS_ASSERT(writer->length() == snapshotsSize_);
111935:     memcpy((uint8 *)this + snapshots_, writer->buffer(), snapshotsSize_);
111935: }
111935: 
111935: void
111935: IonScript::copyBailoutTable(const SnapshotOffset *table)
111935: {
111935:     memcpy(bailoutTable(), table, bailoutEntries_ * sizeof(uint32));
111782: }
111782: 
111782: void
111804: IonScript::Trace(JSTracer *trc, JSScript *script)
111804: {
111804:     if (script->ion && script->ion != ION_DISABLED_SCRIPT)
111804:         script->ion->trace(trc, script);
111804: }
111804: 
111804: void
111782: IonScript::Destroy(JSContext *cx, JSScript *script)
111782: {
111792:     if (!script->ion || script->ion == ION_DISABLED_SCRIPT)
111782:         return;
111782: 
111782:     cx->free_(script->ion);
111782: }
111782: 
111734: static bool
111734: TestCompiler(IonBuilder &builder, MIRGraph &graph)
111706: {
111736:     IonSpewer spew(&graph, builder.script);
111736:     spew.init();
111706: 
111706:     if (!builder.build())
111706:         return false;
111736:     spew.spewPass("Build SSA");
111706: 
111749:     if (!SplitCriticalEdges(&builder, graph))
111749:         return false;
111749:     spew.spewPass("Split Critical Edges");
111749: 
111706:     if (!ReorderBlocks(graph))
111706:         return false;
111736:     spew.spewPass("Reorder Blocks");
111706: 
111738:     if (!BuildDominatorTree(graph))
111738:         return false;
111739:     spew.spewPass("Dominator tree");
111738: 
111718:     if (!BuildPhiReverseMapping(graph))
111718:         return false;
111718:     // No spew, graph not changed.
111718: 
111706:     if (!ApplyTypeInformation(graph))
111706:         return false;
111736:     spew.spewPass("Apply types");
111706: 
111791:     if (js_IonOptions.gvn) {
111791:         ValueNumberer gvn(graph, js_IonOptions.gvnIsOptimistic);
111756:         if (!gvn.analyze())
111756:             return false;
111756:         spew.spewPass("GVN");
111791:     }
111756: 
111791:     if (js_IonOptions.licm) {
111744:         LICM licm(graph);
111744:         if (!licm.analyze())
111744:             return false;
111744:         spew.spewPass("LICM");
111791:     }
111744: 
111900:     LIRGraph lir(graph);
111962:     LIRGenerator lirgen(&builder, graph, lir);
111706:     if (!lirgen.generate())
111706:         return false;
111736:     spew.spewPass("Generate LIR");
111706: 
111791:     if (js_IonOptions.lsra) {
111763:         LinearScanAllocator regalloc(&lirgen, lir);
111758:         if (!regalloc.go())
111758:             return false;
111758:         spew.spewPass("Allocate Registers", &regalloc);
111791:     } else {
111791:         GreedyAllocator greedy(&builder, lir);
111791:         if (!greedy.allocate())
111791:             return false;
111791:         spew.spewPass("Allocate Registers");
111791:     }
111736: 
111768:     CodeGenerator codegen(&builder, lir);
111768:     if (!codegen.generate())
111768:         return false;
111768:     spew.spewPass("Code generation");
111768: 
111736:     spew.finish();
111732: 
111734:     return true;
111734: }
111734: 
111734: static bool
111734: IonCompile(JSContext *cx, JSScript *script, StackFrame *fp)
111734: {
111734:     TempAllocator temp(&cx->tempPool);
111734:     IonContext ictx(cx, &temp);
111734: 
111805:     if (!cx->compartment->ensureIonCompartmentExists(cx))
111805:         return false;
111804: 
111734:     MIRGraph graph;
111734:     DummyOracle oracle;
111734: 
111734:     JSFunction *fun = fp->isFunctionFrame() ? fp->fun() : NULL;
111734:     IonBuilder builder(cx, script, fun, temp, graph, &oracle);
111734:     if (!TestCompiler(builder, graph))
111734:         return false;
111734: 
111734:     return true;
111734: }
111734: 
111935: static bool
111935: CheckFrame(StackFrame *fp)
111935: {
111935:     if (!fp->isFunctionFrame()) {
111935:         // Support for this is almost there - we would need a new
111936:         // pushBailoutFrame. For the most part we just don't support
111935:         // the opcodes in a global script yet.
111935:         IonSpew(IonSpew_Abort, "global frame");
111935:         return false;
111935:     }
111935: 
111935:     if (fp->isEvalFrame()) {
111935:         // Eval frames are not yet supported. Supporting this will require new
111935:         // logic in pushBailoutFrame to deal with linking prev.
111935:         IonSpew(IonSpew_Abort, "eval frame");
111935:         return false;
111935:     }
111935: 
111935:     if (fp->isConstructing()) {
111935:         // Constructors are not supported yet. We need a way to communicate the
111935:         // constructing bit through Ion frames.
111935:         IonSpew(IonSpew_Abort, "constructing frame");
111935:         return false;
111935:     }
111935: 
111935:     if (fp->hasCallObj()) {
111935:         // Functions with call objects aren't supported yet. To support them,
111935:         // we need to fix bug 659577 which would prevent aliasing locals to
111935:         // stack slots.
111935:         IonSpew(IonSpew_Abort, "frame has callobj");
111935:         return false;
111935:     }
111935: 
111935:     if (fp->script()->usesArguments) {
111935:         // Functions with arguments objects, or scripts that use arguments, are
111935:         // not supported yet.
111935:         IonSpew(IonSpew_Abort, "frame has argsobj");
111935:         return false;
111935:     }
111935: 
111935:     if (fp->isGeneratorFrame()) {
111935:         // Err... no.
111935:         IonSpew(IonSpew_Abort, "generator frame");
111935:         return false;
111935:     }
111935: 
111935:     if (fp->isDebuggerFrame()) {
111935:         IonSpew(IonSpew_Abort, "debugger frame");
111935:         return false;
111935:     }
111935: 
111935:     // This check is to not overrun the stack. Eventually, we will want to
111935:     // handle this when we support JSOP_ARGUMENTS or function calls.
111935:     if (fp->numActualArgs() >= SNAPSHOT_MAX_NARGS) {
111935:         IonSpew(IonSpew_Abort, "too many actual args");
111935:         return false;
111935:     }
111935: 
111935:     JS_ASSERT(!fp->hasArgsObj());
111935:     JS_ASSERT_IF(fp->fun(), !fp->fun()->isHeavyweight());
111935:     return true;
111935: }
111935: 
111792: MethodStatus
111792: ion::Compile(JSContext *cx, JSScript *script, js::StackFrame *fp)
111734: {
111792:     JS_ASSERT(ion::IsEnabled());
111734: 
111792:     if (script->ion) {
111818:         if (script->ion == ION_DISABLED_SCRIPT || !script->ion->method())
111792:             return Method_CantCompile;
111792: 
111818:         return Method_Compiled;
111706:     }
111706: 
111935:     if (!CheckFrame(fp))
111935:         return Method_CantCompile;
111935: 
111792:     if (!IonCompile(cx, script, fp)) {
111792:         script->ion = ION_DISABLED_SCRIPT;
111792:         return Method_CantCompile;
111792:     }
111792: 
111818:     return Method_Compiled;
111792: }
111792: 
111792: bool
111818: ion::Cannon(JSContext *cx, StackFrame *fp)
111792: {
111792:     JS_ASSERT(ion::IsEnabled());
111935:     JS_ASSERT(CheckFrame(fp));
111792: 
111818:     EnterIonCode enterJIT = cx->compartment->ionCompartment()->enterJIT(cx);
111818:     if (!enterJIT)
111818:         return false;
111818: 
111818:     int argc = 0;
111818:     Value *argv = NULL;
111818: 
111934:     void *calleeToken;
111818:     if (fp->isFunctionFrame()) {
111934:         argc = CountArgSlots(fp->fun());
111934:         argv = fp->formalArgs() - 1;
111935:         calleeToken = CalleeToToken(&fp->callee());
111934:     } else {
111934:         calleeToken = CalleeToToken(fp->script());
111792:     }
111792: 
111818:     JSScript *script = fp->script();
111818:     IonScript *ion = script->ion;
111818:     IonCode *code = ion->method();
111818:     void *jitcode = code->raw();
111818: 
111818:     JSBool ok;
111818:     Value result;
111818:     {
111818:         AssertCompartmentUnchanged pcc(cx);
111935:         IonContext ictx(cx, NULL);
111935:         IonActivation activation(cx, fp);
111818:         JSAutoResolveFlags rf(cx, RESOLVE_INFER);
111935: 
111934:         ok = enterJIT(jitcode, argc, argv, &result, calleeToken);
111818:     }
111818: 
111818:     JS_ASSERT(fp == cx->fp());
111818: 
111818:     // The trampoline wrote the return value but did not set the HAS_RVAL flag.
111818:     fp->setReturnValue(result);
111818:     fp->markActivationObjectsAsPut();
111818: 
111818:     return !!ok;
111818: }
111818: 
