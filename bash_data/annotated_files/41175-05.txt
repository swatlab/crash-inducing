35778: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
35778:  * vim: sw=4 ts=4 et :
35778:  */
35778: /* ***** BEGIN LICENSE BLOCK *****
35778:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35778:  *
35778:  * The contents of this file are subject to the Mozilla Public License Version
35778:  * 1.1 (the "License"); you may not use this file except in compliance with
35778:  * the License. You may obtain a copy of the License at
35778:  * http://www.mozilla.org/MPL/
35778:  *
35778:  * Software distributed under the License is distributed on an "AS IS" basis,
35778:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35778:  * for the specific language governing rights and limitations under the
35778:  * License.
35778:  *
35778:  * The Original Code is Mozilla Plugin App.
35778:  *
35778:  * The Initial Developer of the Original Code is
35778:  *   Chris Jones <jones.chris.g@gmail.com>
35778:  * Portions created by the Initial Developer are Copyright (C) 2009
35778:  * the Initial Developer. All Rights Reserved.
35778:  *
35778:  * Contributor(s):
35778:  *
35778:  * Alternatively, the contents of this file may be used under the terms of
35778:  * either the GNU General Public License Version 2 or later (the "GPL"), or
35778:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35778:  * in which case the provisions of the GPL or the LGPL are applicable instead
35778:  * of those above. If you wish to allow use of your version of this file only
35778:  * under the terms of either the GPL or the LGPL, and not to allow others to
35778:  * use your version of this file under the terms of the MPL, indicate your
35778:  * decision by deleting the provisions above and replace them with the notice
35778:  * and other provisions required by the GPL or the LGPL. If you do not delete
35778:  * the provisions above, a recipient may use your version of this file under
35778:  * the terms of any one of the MPL, the GPL or the LGPL.
35778:  *
35778:  * ***** END LICENSE BLOCK ***** */
35778: 
35778: #ifndef ipc_glue_SyncChannel_h
35778: #define ipc_glue_SyncChannel_h 1
35778: 
35778: #include "mozilla/ipc/AsyncChannel.h"
35778: 
35778: namespace mozilla {
35778: namespace ipc {
35778: //-----------------------------------------------------------------------------
35778: 
35778: class SyncChannel : public AsyncChannel
35778: {
35778: protected:
35778:     typedef uint16 MessageId;
35778: 
35778: public:
38106:     static const int32 kNoTimeout;
38106: 
35788:     class /*NS_INTERFACE_CLASS*/ SyncListener : 
35788:         public AsyncChannel::AsyncListener
35778:     {
35778:     public:
35787:         virtual ~SyncListener() { }
36140: 
36140:         virtual void OnChannelClose() = 0;
36140:         virtual void OnChannelError() = 0;
35778:         virtual Result OnMessageReceived(const Message& aMessage) = 0;
38107:         virtual bool OnReplyTimeout() = 0;
35778:         virtual Result OnMessageReceived(const Message& aMessage,
35778:                                          Message*& aReply) = 0;
35778:     };
35778: 
36078:     SyncChannel(SyncListener* aListener);
36078:     virtual ~SyncChannel();
35778: 
38681:     NS_OVERRIDE
38681:     virtual bool Send(Message* msg) {
35778:         return AsyncChannel::Send(msg);
35778:     }
35778: 
35778:     // Synchronously send |msg| (i.e., wait for |reply|)
38681:     virtual bool Send(Message* msg, Message* reply);
35778: 
38107:     void SetReplyTimeoutMs(int32 aTimeoutMs) {
38107:         AssertWorkerThread();
38107:         mTimeoutMs = (aTimeoutMs <= 0) ? kNoTimeout : aTimeoutMs;
38107:     }
38107: 
35778:     // Override the AsyncChannel handler so we can dispatch sync messages
35940:     NS_OVERRIDE virtual void OnMessageReceived(const Message& msg);
35940:     NS_OVERRIDE virtual void OnChannelError();
35778: 
36093:     static bool IsPumpingMessages() {
36093:         return sIsPumpingMessages;
36093:     }
36093:     static void SetIsPumpingMessages(bool aIsPumping) {
36093:         sIsPumpingMessages = aIsPumping;
36093:     }
36056: 
35778: protected:
35778:     // Executed on the worker thread
35859:     bool ProcessingSyncMessage() {
35859:         return mProcessingSyncMessage;
35778:     }
35778: 
35778:     void OnDispatchMessage(const Message& aMsg);
38100: 
38100:     NS_OVERRIDE
38100:     bool OnSpecialMessage(uint16 id, const Message& msg)
38100:     {
38100:         // SyncChannel doesn't care about any special messages yet
38100:         return AsyncChannel::OnSpecialMessage(id, msg);
38100:     }
38100: 
38106:     //
38106:     // Return true if the wait ended because a notification was
38106:     // received.  That is, true => event received.
38106:     //
38106:     // Return false if the time elapsed from when we started the
38106:     // process of waiting until afterwards exceeded the currently
38106:     // allotted timeout.  That *DOES NOT* mean false => "no event" (==
38106:     // timeout); there are many circumstances that could cause the
38106:     // measured elapsed time to exceed the timeout EVEN WHEN we were
38106:     // notified.
38106:     //
38106:     // So in sum: true is a meaningful return value; false isn't,
38106:     // necessarily.
38106:     //
38106:     bool WaitForNotify();
38106: 
38106:     bool ShouldContinueFromTimeout();
35778: 
35778:     // Executed on the IO thread.
35977:     void NotifyWorkerThread();
35778: 
35859:     // On both
35859:     bool AwaitingSyncReply() {
35859:         mMutex.AssertCurrentThreadOwns();
35859:         return mPendingReply != 0;
35859:     }
35859: 
37473:     int32 NextSeqno() {
37473:         AssertWorkerThread();
37473:         return mChild ? --mNextSeqno : ++mNextSeqno;
37473:     }
37473: 
35778:     MessageId mPendingReply;
35859:     bool mProcessingSyncMessage;
35778:     Message mRecvd;
37473:     // This is only accessed from the worker thread; seqno's are
37473:     // completely opaque to the IO thread.
37473:     int32 mNextSeqno;
36056: 
36093:     static bool sIsPumpingMessages;
38106: 
38119:     int32 mTimeoutMs;
38119: 
39845: #ifdef OS_WIN
39845:     HANDLE mEvent;
39845: #endif
39845: 
38106: private:
38106:     bool EventOccurred();
35778: };
35778: 
35778: 
35778: } // namespace ipc
35778: } // namespace mozilla
35778: #endif  // ifndef ipc_glue_SyncChannel_h
