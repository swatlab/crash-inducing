    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Brendan Eich (brendan@mozilla.org)
    1:  *   Scott MacGregor (mscott@netscape.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsIAtom.h"
    1: #include "nsIXBLDocumentInfo.h"
    1: #include "nsIInputStream.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsHashtable.h"
    1: #include "nsIURI.h"
    1: #include "nsIURL.h"
 1418: #include "nsIDOMEventTarget.h"
    1: #include "nsIChannel.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsIParser.h"
    1: #include "nsParserCIID.h"
    1: #include "nsNetUtil.h"
    1: #include "plstr.h"
    1: #include "nsIContent.h"
    1: #include "nsIDocument.h"
    1: #include "nsContentUtils.h"
    1: #ifdef MOZ_XUL
    1: #include "nsIXULDocument.h"
    1: #endif
    1: #include "nsIXMLContentSink.h"
    1: #include "nsContentCID.h"
    1: #include "nsXMLDocument.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMText.h"
    1: #include "jsapi.h"
    1: #include "nsXBLService.h"
    1: #include "nsXBLInsertionPoint.h"
    1: #include "nsIXPConnect.h"
    1: #include "nsIScriptContext.h"
    1: #include "nsCRT.h"
    1: 
    1: // Event listeners
    1: #include "nsIEventListenerManager.h"
    1: #include "nsIDOMMouseListener.h"
    1: #include "nsIDOMMouseMotionListener.h"
    1: #include "nsIDOMLoadListener.h"
    1: #include "nsIDOMFocusListener.h"
    1: #include "nsIDOMKeyListener.h"
    1: #include "nsIDOMFormListener.h"
    1: #include "nsIDOMXULListener.h"
    1: #include "nsIDOMDragListener.h"
    1: #include "nsIDOMContextMenuListener.h"
    1: #include "nsIDOMEventGroup.h"
    1: #include "nsAttrName.h"
    1: 
    1: #include "nsGkAtoms.h"
    1: 
    1: #include "nsIDOMAttr.h"
    1: #include "nsIDOMNamedNodeMap.h"
    1: 
    1: #include "nsXBLPrototypeHandler.h"
    1: 
    1: #include "nsXBLPrototypeBinding.h"
    1: #include "nsXBLBinding.h"
    1: #include "nsIPrincipal.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsIEventListenerManager.h"
    1: #include "nsGUIEvent.h"
    1: 
    1: #include "prprf.h"
    1: #include "nsNodeUtils.h"
    1: 
 6392: // Nasty hack.  Maybe we could move some of the classinfo utility methods
 6392: // (e.g. WrapNative and ThrowJSException) over to nsContentUtils?
 6392: #include "nsDOMClassInfo.h"
 6392: #include "nsJSUtils.h"
 6392: 
    1: // Helper classes
    1: 
    1: /***********************************************************************/
    1: //
    1: // The JS class for XBLBinding
    1: //
18907: static void
    1: XBLFinalize(JSContext *cx, JSObject *obj)
    1: {
 6392:   nsIXBLDocumentInfo* docInfo =
 6392:     static_cast<nsIXBLDocumentInfo*>(::JS_GetPrivate(cx, obj));
 6392:   NS_RELEASE(docInfo);
 6392:   
12197:   nsXBLJSClass* c = static_cast<nsXBLJSClass*>(::JS_GET_CLASS(cx, obj));
    1:   c->Drop();
    1: }
    1: 
18907: static JSBool
 6392: XBLResolve(JSContext *cx, JSObject *obj, jsval id, uintN flags,
 6392:            JSObject **objp)
 6392: {
 6392:   // Note: if we get here, that means that the implementation for some binding
 6392:   // was installed, which means that AllowScripts() tested true.  Hence no need
 6392:   // to do checks like that here.
 6392:   
 6392:   // Default to not resolving things.
 6392:   NS_ASSERTION(*objp, "Must have starting object");
 6392: 
 6392:   JSObject* origObj = *objp;
 6392:   *objp = NULL;
 6392: 
 6392:   if (!JSVAL_IS_STRING(id)) {
 6392:     return JS_TRUE;
 6392:   }
 6392: 
 6392:   nsDependentJSString fieldName(id);
 6392: 
 6392:   jsval slotVal;
 6392:   ::JS_GetReservedSlot(cx, obj, 0, &slotVal);
 6392:   NS_ASSERTION(!JSVAL_IS_VOID(slotVal), "How did that happen?");
 6392:     
 6392:   nsXBLPrototypeBinding* protoBinding =
 6392:     static_cast<nsXBLPrototypeBinding*>(JSVAL_TO_PRIVATE(slotVal));
 6392:   NS_ASSERTION(protoBinding, "Must have prototype binding!");
 6392: 
 6392:   nsXBLProtoImplField* field = protoBinding->FindField(fieldName);
 6392:   if (!field) {
 6392:     return JS_TRUE;
 6392:   }
 6392: 
 6392:   // We have this field.  Time to install it.  Get our node.
12197:   JSClass* nodeClass = ::JS_GET_CLASS(cx, origObj);
 6392:   if (!nodeClass) {
 6392:     return JS_FALSE;
 6392:   }
 6392:   
 6392:   if (~nodeClass->flags &
 6392:       (JSCLASS_HAS_PRIVATE | JSCLASS_PRIVATE_IS_NSISUPPORTS)) {
 6393:     nsDOMClassInfo::ThrowJSException(cx, NS_ERROR_UNEXPECTED);
 6393:     return JS_FALSE;
 6392:   }
 6392: 
 6392:   nsCOMPtr<nsIXPConnectWrappedNative> xpcWrapper =
 6392:     do_QueryInterface(static_cast<nsISupports*>(::JS_GetPrivate(cx, origObj)));
 6392:   if (!xpcWrapper) {
 6393:     // Looks like whatever |origObj| is it's not our nsIContent.  It might well
 6393:     // be the proto our binding installed, however, where the private is the
 6393:     // nsIXBLDocumentInfo, so just baul out quietly.  Do NOT throw an exception
 6393:     // here.
 6393:     // We could make this stricter by checking the class maybe, but whatever
 6393:     return JS_TRUE;
 6392:   }
 6392: 
 6392:   nsCOMPtr<nsIContent> content = do_QueryWrappedNative(xpcWrapper);
 6392:   if (!content) {
 6392:     nsDOMClassInfo::ThrowJSException(cx, NS_ERROR_UNEXPECTED);
 6392:     return JS_FALSE;
 6392:   }
 6392: 
 6392:   // This mirrors code in nsXBLProtoImpl::InstallImplementation
 6392:   nsIDocument* doc = content->GetOwnerDoc();
 6392:   if (!doc) {
 6392:     return JS_TRUE;
 6392:   }
 6392: 
 6392:   nsIScriptGlobalObject* global = doc->GetScriptGlobalObject();
 6392:   if (!global) {
 6392:     return JS_TRUE;
 6392:   }
 6392: 
 6392:   nsCOMPtr<nsIScriptContext> context = global->GetContext();
 6392:   if (!context) {
 6392:     return JS_TRUE;
 6392:   }
 6392: 
 6392: 
 6392:   // Now we either resolve or fail
 6535:   PRBool didInstall;
 6392:   nsresult rv = field->InstallField(context, origObj,
22121:                                     content->NodePrincipal(),
 6535:                                     protoBinding->DocURI(),
 6535:                                     &didInstall);
 6392:   if (NS_FAILED(rv)) {
 6392:     if (!::JS_IsExceptionPending(cx)) {
 6392:       nsDOMClassInfo::ThrowJSException(cx, rv);
 6392:     }
 6392: 
 6392:     return JS_FALSE;
 6392:   }
 6392: 
 6535:   if (didInstall) {
 6535:     *objp = origObj;
 6535:   }
 6535:   // else we didn't resolve this field after all
 6535: 
 6392:   return JS_TRUE;
 6392: }
 6392: 
    1: nsXBLJSClass::nsXBLJSClass(const nsAFlatCString& aClassName)
    1: {
    1:   memset(this, 0, sizeof(nsXBLJSClass));
 3233:   next = prev = static_cast<JSCList*>(this);
    1:   name = ToNewCString(aClassName);
 6392:   flags =
 6392:     JSCLASS_HAS_PRIVATE | JSCLASS_PRIVATE_IS_NSISUPPORTS |
 6392:     JSCLASS_NEW_RESOLVE | JSCLASS_NEW_RESOLVE_GETS_START |
 6392:     // Our one reserved slot holds the relevant nsXBLPrototypeBinding
 6392:     JSCLASS_HAS_RESERVED_SLOTS(1);
    1:   addProperty = delProperty = setProperty = getProperty = ::JS_PropertyStub;
    1:   enumerate = ::JS_EnumerateStub;
 6392:   resolve = (JSResolveOp)XBLResolve;
    1:   convert = ::JS_ConvertStub;
    1:   finalize = XBLFinalize;
    1: }
    1: 
    1: nsrefcnt
    1: nsXBLJSClass::Destroy()
    1: {
 3233:   NS_ASSERTION(next == prev && prev == static_cast<JSCList*>(this),
    1:                "referenced nsXBLJSClass is on LRU list already!?");
    1: 
    1:   if (nsXBLService::gClassTable) {
    1:     nsCStringKey key(name);
    1:     (nsXBLService::gClassTable)->Remove(&key);
    1:   }
    1: 
    1:   if (nsXBLService::gClassLRUListLength >= nsXBLService::gClassLRUListQuota) {
    1:     // Over LRU list quota, just unhash and delete this class.
    1:     delete this;
    1:   } else {
    1:     // Put this most-recently-used class on end of the LRU-sorted freelist.
 3233:     JSCList* mru = static_cast<JSCList*>(this);
    1:     JS_APPEND_LINK(mru, &nsXBLService::gClassLRUList);
    1:     nsXBLService::gClassLRUListLength++;
    1:   }
    1: 
    1:   return 0;
    1: }
    1: 
    1: // Implementation /////////////////////////////////////////////////////////////////
    1: 
    1: // Constructors/Destructors
    1: nsXBLBinding::nsXBLBinding(nsXBLPrototypeBinding* aBinding)
    1:   : mPrototypeBinding(aBinding),
    1:     mInsertionPointTable(nsnull),
    1:     mIsStyleBinding(PR_TRUE),
13098:     mMarkedForDeath(PR_FALSE)
    1: {
    1:   NS_ASSERTION(mPrototypeBinding, "Must have a prototype binding!");
    1:   // Grab a ref to the document info so the prototype binding won't die
    1:   NS_ADDREF(mPrototypeBinding->XBLDocumentInfo());
    1: }
    1: 
    1: 
    1: nsXBLBinding::~nsXBLBinding(void)
    1: {
    1:   delete mInsertionPointTable;
    1:   nsIXBLDocumentInfo* info = mPrototypeBinding->XBLDocumentInfo();
    1:   NS_RELEASE(info);
    1: }
    1: 
20261: static PLDHashOperator
 1829: TraverseKey(nsISupports* aKey, nsInsertionPointList* aData, void* aClosure)
 1829: {
 1829:   nsCycleCollectionTraversalCallback &cb = 
 3233:     *static_cast<nsCycleCollectionTraversalCallback*>(aClosure);
 1829: 
13202:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mInsertionPointTable key");
 1829:   cb.NoteXPCOMChild(aKey);
 1829:   if (aData) {
13202:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSTARRAY(*aData, nsXBLInsertionPoint,
13202:                                                "mInsertionPointTable value")
 1829:   }
 1829:   return PL_DHASH_NEXT;
 1829: }
 1829: 
 7230: NS_IMPL_CYCLE_COLLECTION_CLASS(nsXBLBinding)
 1829: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_NATIVE(nsXBLBinding)
 1829:   // XXX Probably can't unlink mPrototypeBinding->XBLDocumentInfo(), because
 1829:   //     mPrototypeBinding is weak.
 1829:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mContent)
 1829:   // XXX What about mNextBinding and mInsertionPointTable?
 1829: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 1829: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_BEGIN(nsXBLBinding)
 1829:   cb.NoteXPCOMChild(tmp->mPrototypeBinding->XBLDocumentInfo());
 1829:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mContent)
 1829:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_MEMBER(mNextBinding, nsXBLBinding)
 1829:   if (tmp->mInsertionPointTable)
 1829:     tmp->mInsertionPointTable->EnumerateRead(TraverseKey, &cb);
 1829: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 1829: NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE(nsXBLBinding, AddRef)
 1829: NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE(nsXBLBinding, Release)
 1829: 
    1: void
    1: nsXBLBinding::SetBaseBinding(nsXBLBinding* aBinding)
    1: {
    1:   if (mNextBinding) {
    1:     NS_ERROR("Base XBL binding is already defined!");
    1:     return;
    1:   }
    1: 
    1:   mNextBinding = aBinding; // Comptr handles rel/add
    1: }
    1: 
    1: void
    1: nsXBLBinding::InstallAnonymousContent(nsIContent* aAnonParent, nsIContent* aElement)
    1: {
    1:   // We need to ensure two things.
    1:   // (1) The anonymous content should be fooled into thinking it's in the bound
    1:   // element's document, assuming that the bound element is in a document
    1:   // Note that we don't change the current doc of aAnonParent here, since that
    1:   // quite simply does not matter.  aAnonParent is just a way of keeping refs
    1:   // to all its kids, which are anonymous content from the point of view of
    1:   // aElement.
    1:   // (2) The children's parent back pointer should not be to this synthetic root
    1:   // but should instead point to the enclosing parent element.
    1:   nsIDocument* doc = aElement->GetCurrentDoc();
    1:   PRBool allowScripts = AllowScripts();
    1: 
14228:   nsAutoScriptBlocker scriptBlocker;
14228: 
    1:   PRUint32 childCount = aAnonParent->GetChildCount();
    1:   for (PRUint32 i = 0; i < childCount; i++) {
    1:     nsIContent *child = aAnonParent->GetChildAt(i);
    1:     child->UnbindFromTree();
    1:     nsresult rv =
    1:       child->BindToTree(doc, aElement, mBoundElement, allowScripts);
    1:     if (NS_FAILED(rv)) {
    1:       // Oh, well... Just give up.
    1:       // XXXbz This really shouldn't be a void method!
    1:       child->UnbindFromTree();
    1:       return;
    1:     }        
    1: 
    1: #ifdef MOZ_XUL
    1:     // To make XUL templates work (and other goodies that happen when
    1:     // an element is added to a XUL document), we need to notify the
    1:     // XUL document using its special API.
    1:     nsCOMPtr<nsIXULDocument> xuldoc(do_QueryInterface(doc));
    1:     if (xuldoc)
    1:       xuldoc->AddSubtreeToDocument(child);
    1: #endif
    1:   }
    1: }
    1: 
    1: void
    1: nsXBLBinding::SetBoundElement(nsIContent* aElement)
    1: {
    1:   mBoundElement = aElement;
    1:   if (mNextBinding)
    1:     mNextBinding->SetBoundElement(aElement);
    1: }
    1: 
    1: PRBool
    1: nsXBLBinding::HasStyleSheets() const
    1: {
    1:   // Find out if we need to re-resolve style.  We'll need to do this
    1:   // if we have additional stylesheets in our binding document.
    1:   if (mPrototypeBinding->HasStyleSheets())
    1:     return PR_TRUE;
    1: 
    1:   return mNextBinding ? mNextBinding->HasStyleSheets() : PR_FALSE;
    1: }
    1: 
    1: struct EnumData {
    1:   nsXBLBinding* mBinding;
    1:  
    1:   EnumData(nsXBLBinding* aBinding)
    1:     :mBinding(aBinding)
  731:   {}
    1: };
    1: 
    1: struct ContentListData : public EnumData {
    1:   nsBindingManager* mBindingManager;
    1:   nsresult          mRv;
    1: 
    1:   ContentListData(nsXBLBinding* aBinding, nsBindingManager* aManager)
    1:     :EnumData(aBinding), mBindingManager(aManager), mRv(NS_OK)
  731:   {}
    1: };
    1: 
20261: static PLDHashOperator
    1: BuildContentLists(nsISupports* aKey,
    1:                   nsAutoPtr<nsInsertionPointList>& aData,
    1:                   void* aClosure)
    1: {
    1:   ContentListData* data = (ContentListData*)aClosure;
    1:   nsBindingManager* bm = data->mBindingManager;
    1:   nsXBLBinding* binding = data->mBinding;
    1: 
    1:   nsIContent *boundElement = binding->GetBoundElement();
    1: 
    1:   PRInt32 count = aData->Length();
    1:   
    1:   if (count == 0)
    1:     return PL_DHASH_NEXT;
    1: 
    1:   // XXX Could this array just be altered in place and passed directly to
    1:   // SetContentListFor?  We'd save space if we could pull this off.
    1:   nsInsertionPointList* contentList = new nsInsertionPointList;
    1:   if (!contentList) {
    1:     data->mRv = NS_ERROR_OUT_OF_MEMORY;
    1:     return PL_DHASH_STOP;
    1:   }
    1: 
    1:   // Figure out the relevant content node.
    1:   nsXBLInsertionPoint* currPoint = aData->ElementAt(0);
    1:   nsCOMPtr<nsIContent> parent = currPoint->GetInsertionParent();
 6864:   if (!parent) {
 6864:     data->mRv = NS_ERROR_FAILURE;
 6864:     return PL_DHASH_STOP;
 6864:   }
    1:   PRInt32 currIndex = currPoint->GetInsertionIndex();
    1: 
    1:   nsCOMPtr<nsIDOMNodeList> nodeList;
    1:   if (parent == boundElement) {
    1:     // We are altering anonymous nodes to accommodate insertion points.
    1:     nodeList = binding->GetAnonymousNodes();
    1:   }
    1:   else {
    1:     // We are altering the explicit content list of a node to accommodate insertion points.
    1:     nsCOMPtr<nsIDOMNode> node(do_QueryInterface(parent));
    1:     node->GetChildNodes(getter_AddRefs(nodeList));
    1:   }
    1: 
    1:   nsXBLInsertionPoint* pseudoPoint = nsnull;
    1:   PRUint32 childCount;
    1:   nodeList->GetLength(&childCount);
    1:   PRInt32 j = 0;
    1: 
    1:   for (PRUint32 i = 0; i < childCount; i++) {
    1:     nsCOMPtr<nsIDOMNode> node;
    1:     nodeList->Item(i, getter_AddRefs(node));
    1:     nsCOMPtr<nsIContent> child(do_QueryInterface(node));
    1:     if (((PRInt32)i) == currIndex) {
    1:       // Add the currPoint to the insertion point list.
    1:       contentList->AppendElement(currPoint);
    1: 
    1:       // Get the next real insertion point and update our currIndex.
    1:       j++;
    1:       if (j < count) {
    1:         currPoint = aData->ElementAt(j);
    1:         currIndex = currPoint->GetInsertionIndex();
    1:       }
    1: 
    1:       // Null out our current pseudo-point.
    1:       pseudoPoint = nsnull;
    1:     }
    1:     
    1:     if (!pseudoPoint) {
    1:       pseudoPoint = new nsXBLInsertionPoint(parent, (PRUint32) -1, nsnull);
    1:       if (pseudoPoint) {
    1:         contentList->AppendElement(pseudoPoint);
    1:       }
    1:     }
    1:     if (pseudoPoint) {
    1:       pseudoPoint->AddChild(child);
    1:     }
    1:   }
    1: 
    1:   // Add in all the remaining insertion points.
    1:   contentList->AppendElements(aData->Elements() + j, count - j);
    1:   
    1:   // Now set the content list using the binding manager,
    1:   // If the bound element is the parent, then we alter the anonymous node list
    1:   // instead.  This allows us to always maintain two distinct lists should
    1:   // insertion points be nested into an inner binding.
    1:   if (parent == boundElement)
    1:     bm->SetAnonymousNodesFor(parent, contentList);
    1:   else 
    1:     bm->SetContentListFor(parent, contentList);
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
20261: static PLDHashOperator
    1: RealizeDefaultContent(nsISupports* aKey,
    1:                       nsAutoPtr<nsInsertionPointList>& aData,
    1:                       void* aClosure)
    1: {
    1:   ContentListData* data = (ContentListData*)aClosure;
    1:   nsBindingManager* bm = data->mBindingManager;
    1:   nsXBLBinding* binding = data->mBinding;
    1: 
    1:   PRInt32 count = aData->Length();
    1:  
    1:   for (PRInt32 i = 0; i < count; i++) {
    1:     nsXBLInsertionPoint* currPoint = aData->ElementAt(i);
    1:     PRInt32 insCount = currPoint->ChildCount();
    1:     
    1:     if (insCount == 0) {
    1:       nsCOMPtr<nsIContent> defContent = currPoint->GetDefaultContentTemplate();
    1:       if (defContent) {
    1:         // We need to take this template and use it to realize the
    1:         // actual default content (through cloning).
    1:         // Clone this insertion point element.
    1:         nsCOMPtr<nsIContent> insParent = currPoint->GetInsertionParent();
 6864:         if (!insParent) {
 6864:           data->mRv = NS_ERROR_FAILURE;
 6864:           return PL_DHASH_STOP;
 6864:         }
    1:         nsIDocument *document = insParent->GetOwnerDoc();
    1:         if (!document) {
    1:           data->mRv = NS_ERROR_FAILURE;
    1:           return PL_DHASH_STOP;
    1:         }
    1: 
    1:         nsCOMPtr<nsIDOMNode> clonedNode;
    1:         nsCOMArray<nsINode> nodesWithProperties;
    1:         nsNodeUtils::Clone(defContent, PR_TRUE, document->NodeInfoManager(),
    1:                            nodesWithProperties, getter_AddRefs(clonedNode));
    1: 
    1:         // Now that we have the cloned content, install the default content as
    1:         // if it were additional anonymous content.
    1:         nsCOMPtr<nsIContent> clonedContent(do_QueryInterface(clonedNode));
    1:         binding->InstallAnonymousContent(clonedContent, insParent);
    1: 
    1:         // Cache the clone so that it can be properly destroyed if/when our
    1:         // other anonymous content is destroyed.
    1:         currPoint->SetDefaultContent(clonedContent);
    1: 
    1:         // Now make sure the kids of the clone are added to the insertion point as
    1:         // children.
    1:         PRUint32 cloneKidCount = clonedContent->GetChildCount();
    1:         for (PRUint32 k = 0; k < cloneKidCount; k++) {
    1:           nsIContent *cloneChild = clonedContent->GetChildAt(k);
    1:           bm->SetInsertionParent(cloneChild, insParent);
    1:           currPoint->AddChild(cloneChild);
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
20261: static PLDHashOperator
    1: ChangeDocumentForDefaultContent(nsISupports* aKey,
    1:                                 nsAutoPtr<nsInsertionPointList>& aData,
    1:                                 void* aClosure)
    1: {
    1:   PRInt32 count = aData->Length();
    1:   for (PRInt32 i = 0; i < count; i++) {
10861:     aData->ElementAt(i)->UnbindDefaultContent();
    1:   }
    1: 
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
    1: void
    1: nsXBLBinding::GenerateAnonymousContent()
    1: {
    1:   // Fetch the content element for this binding.
    1:   nsIContent* content =
    1:     mPrototypeBinding->GetImmediateChild(nsGkAtoms::content);
    1: 
    1:   if (!content) {
    1:     // We have no anonymous content.
    1:     if (mNextBinding)
    1:       mNextBinding->GenerateAnonymousContent();
    1: 
    1:     return;
    1:   }
    1:      
    1:   // Find out if we're really building kids or if we're just
    1:   // using the attribute-setting shorthand hack.
    1:   PRUint32 contentCount = content->GetChildCount();
    1: 
    1:   // Plan to build the content by default.
    1:   PRBool hasContent = (contentCount > 0);
    1:   PRBool hasInsertionPoints = mPrototypeBinding->HasInsertionPoints();
    1: 
    1: #ifdef DEBUG
    1:   // See if there's an includes attribute.
    1:   if (nsContentUtils::HasNonEmptyAttr(content, kNameSpaceID_None,
    1:                                       nsGkAtoms::includes)) {
    1:     nsCAutoString message("An XBL Binding with URI ");
    1:     nsCAutoString uri;
    1:     mPrototypeBinding->BindingURI()->GetSpec(uri);
    1:     message += uri;
    1:     message += " is still using the deprecated\n<content includes=\"\"> syntax! Use <children> instead!\n"; 
    1:     NS_WARNING(message.get());
    1:   }
    1: #endif
    1: 
    1:   if (hasContent || hasInsertionPoints) {
    1:     nsIDocument* doc = mBoundElement->GetOwnerDoc();
    1: 
    1:     // XXX doc will be null if we're in the midst of paint suppression.
    1:     if (! doc)
    1:       return;
    1:     
    1:     nsBindingManager *bindingManager = doc->BindingManager();
    1: 
    1:     nsCOMPtr<nsIDOMNodeList> children;
    1:     bindingManager->GetContentListFor(mBoundElement, getter_AddRefs(children));
    1:  
    1:     nsCOMPtr<nsIDOMNode> node;
    1:     nsCOMPtr<nsIContent> childContent;
    1:     PRUint32 length;
    1:     children->GetLength(&length);
    1:     if (length > 0 && !hasInsertionPoints) {
    1:       // There are children being placed underneath us, but we have no specified
    1:       // insertion points, and therefore no place to put the kids.  Don't generate
    1:       // anonymous content.
    1:       // Special case template and observes.
    1:       for (PRUint32 i = 0; i < length; i++) {
    1:         children->Item(i, getter_AddRefs(node));
    1:         childContent = do_QueryInterface(node);
    1: 
    1:         nsINodeInfo *ni = childContent->NodeInfo();
    1:         nsIAtom *localName = ni->NameAtom();
    1:         if (ni->NamespaceID() != kNameSpaceID_XUL ||
    1:             (localName != nsGkAtoms::observes &&
    1:              localName != nsGkAtoms::_template)) {
    1:           hasContent = PR_FALSE;
    1:           break;
    1:         }
    1:       }
    1:     }
    1: 
    1:     if (hasContent || hasInsertionPoints) {
    1:       nsIDocument *document = mBoundElement->GetOwnerDoc();
    1:       if (!document) {
    1:         return;
    1:       }
    1: 
    1:       nsCOMPtr<nsIDOMNode> clonedNode;
    1:       nsCOMArray<nsINode> nodesWithProperties;
    1:       nsNodeUtils::Clone(content, PR_TRUE, document->NodeInfoManager(),
    1:                          nodesWithProperties, getter_AddRefs(clonedNode));
    1: 
    1:       mContent = do_QueryInterface(clonedNode);
    1:       InstallAnonymousContent(mContent, mBoundElement);
    1: 
    1:       if (hasInsertionPoints) {
    1:         // Now check and see if we have a single insertion point 
    1:         // or multiple insertion points.
    1:       
    1:         // Enumerate the prototype binding's insertion table to build
    1:         // our table of instantiated insertion points.
    1:         mPrototypeBinding->InstantiateInsertionPoints(this);
    1: 
    1:         // We now have our insertion point table constructed.  We
    1:         // enumerate this table.  For each array of insertion points
    1:         // bundled under the same content node, we generate a content
    1:         // list.  In the case of the bound element, we generate a new
    1:         // anonymous node list that will be used in place of the binding's
    1:         // cached anonymous node list.
    1:         ContentListData data(this, bindingManager);
    1:         mInsertionPointTable->Enumerate(BuildContentLists, &data);
    1:         if (NS_FAILED(data.mRv)) {
    1:           return;
    1:         }
    1: 
    1:         // We need to place the children
    1:         // at their respective insertion points.
    1:         PRUint32 index = 0;
    1:         PRBool multiplePoints = PR_FALSE;
    1:         nsIContent *singlePoint = GetSingleInsertionPoint(&index,
    1:                                                           &multiplePoints);
    1:       
    1:         if (children) {
    1:           if (multiplePoints) {
    1:             // We must walk the entire content list in order to determine where
    1:             // each child belongs.
    1:             children->GetLength(&length);
    1:             for (PRUint32 i = 0; i < length; i++) {
    1:               children->Item(i, getter_AddRefs(node));
    1:               childContent = do_QueryInterface(node);
    1: 
    1:               // Now determine the insertion point in the prototype table.
    1:               PRUint32 index;
    1:               nsIContent *point = GetInsertionPoint(childContent, &index);
    1:               bindingManager->SetInsertionParent(childContent, point);
    1: 
    1:               // Find the correct nsIXBLInsertion point in our table.
    1:               nsInsertionPointList* arr = nsnull;
    1:               GetInsertionPointsFor(point, &arr);
    1:               nsXBLInsertionPoint* insertionPoint = nsnull;
    1:               PRInt32 arrCount = arr->Length();
    1:               for (PRInt32 j = 0; j < arrCount; j++) {
    1:                 insertionPoint = arr->ElementAt(j);
    1:                 if (insertionPoint->Matches(point, index))
    1:                   break;
    1:                 insertionPoint = nsnull;
    1:               }
    1: 
    1:               if (insertionPoint) 
    1:                 insertionPoint->AddChild(childContent);
    1:               else {
    1:                 // We were unable to place this child.  All anonymous content
    1:                 // should be thrown out.  Special-case template and observes.
    1: 
    1:                 nsINodeInfo *ni = childContent->NodeInfo();
    1:                 nsIAtom *localName = ni->NameAtom();
    1:                 if (ni->NamespaceID() != kNameSpaceID_XUL ||
    1:                     (localName != nsGkAtoms::observes &&
    1:                      localName != nsGkAtoms::_template)) {
22958:                   // Undo InstallAnonymousContent
22958:                   PRUint32 childCount = mContent->GetChildCount();
22958: #ifdef MOZ_XUL
22958:                   nsCOMPtr<nsIXULDocument> xuldoc(do_QueryInterface(doc));
22958: #endif
22958:                   for (PRUint32 k = 0; k < childCount; ++k) {
22958:                     nsIContent* child = mContent->GetChildAt(k);
22958:                     child->UnbindFromTree();
22958: #ifdef MOZ_XUL
22958:                     if (xuldoc) {
22958:                       xuldoc->RemoveSubtreeFromDocument(child);
22958:                     }
22958: #endif
22958:                   }
22958: 
    1:                   // Kill all anonymous content.
    1:                   mContent = nsnull;
    1:                   bindingManager->SetContentListFor(mBoundElement, nsnull);
    1:                   bindingManager->SetAnonymousNodesFor(mBoundElement, nsnull);
    1:                   return;
    1:                 }
    1:               }
    1:             }
    1:           }
    1:           else {
    1:             // All of our children are shunted to this single insertion point.
    1:             nsInsertionPointList* arr = nsnull;
    1:             GetInsertionPointsFor(singlePoint, &arr);
    1:             nsXBLInsertionPoint* insertionPoint = arr->ElementAt(0);
    1:         
    1:             nsCOMPtr<nsIDOMNode> node;
    1:             nsCOMPtr<nsIContent> content;
    1:             PRUint32 length;
    1:             children->GetLength(&length);
    1:           
    1:             for (PRUint32 i = 0; i < length; i++) {
    1:               children->Item(i, getter_AddRefs(node));
    1:               content = do_QueryInterface(node);
    1:               bindingManager->SetInsertionParent(content, singlePoint);
    1:               insertionPoint->AddChild(content);
    1:             }
    1:           }
    1:         }
    1: 
    1:         // Now that all of our children have been added, we need to walk all of our
    1:         // nsIXBLInsertion points to see if any of them have default content that
    1:         // needs to be built.
    1:         mInsertionPointTable->Enumerate(RealizeDefaultContent, &data);
    1:         if (NS_FAILED(data.mRv)) {
    1:           return;
    1:         }
    1:       }
    1:     }
    1: 
    1:     mPrototypeBinding->SetInitialAttributes(mBoundElement, mContent);
    1:   }
    1: 
    1:   // Always check the content element for potential attributes.
    1:   // This shorthand hack always happens, even when we didn't
    1:   // build anonymous content.
    1:   const nsAttrName* attrName;
    1:   for (PRUint32 i = 0; (attrName = content->GetAttrNameAt(i)); ++i) {
    1:     PRInt32 namespaceID = attrName->NamespaceID();
13301:     // Hold a strong reference here so that the atom doesn't go away during
13301:     // UnsetAttr.
13301:     nsCOMPtr<nsIAtom> name = attrName->LocalName();
    1: 
    1:     if (name != nsGkAtoms::includes) {
    1:       if (!nsContentUtils::HasNonEmptyAttr(mBoundElement, namespaceID, name)) {
    1:         nsAutoString value2;
    1:         content->GetAttr(namespaceID, name, value2);
    1:         mBoundElement->SetAttr(namespaceID, name, attrName->GetPrefix(),
    1:                                value2, PR_FALSE);
    1:       }
    1:     }
    1: 
    1:     // Conserve space by wiping the attributes off the clone.
    1:     if (mContent)
    1:       mContent->UnsetAttr(namespaceID, name, PR_FALSE);
    1:   }
    1: }
    1: 
    1: void
    1: nsXBLBinding::InstallEventHandlers()
    1: {
    1:   // Don't install handlers if scripts aren't allowed.
    1:   if (AllowScripts()) {
    1:     // Fetch the handlers prototypes for this binding.
    1:     nsXBLPrototypeHandler* handlerChain = mPrototypeBinding->GetPrototypeHandlers();
    1: 
    1:     if (handlerChain) {
    1:       nsCOMPtr<nsIEventListenerManager> manager;
    1:       mBoundElement->GetListenerManager(PR_TRUE, getter_AddRefs(manager));
    1:       if (!manager)
    1:         return;
    1: 
    1:       nsCOMPtr<nsIDOMEventGroup> systemEventGroup;
  541:       PRBool isChromeDoc =
  541:         nsContentUtils::IsChromeDoc(mBoundElement->GetOwnerDoc());
    1:       nsXBLPrototypeHandler* curr;
    1:       for (curr = handlerChain; curr; curr = curr->GetNextHandler()) {
    1:         // Fetch the event type.
    1:         nsCOMPtr<nsIAtom> eventAtom = curr->GetEventName();
    1:         if (!eventAtom ||
    1:             eventAtom == nsGkAtoms::keyup ||
    1:             eventAtom == nsGkAtoms::keydown ||
    1:             eventAtom == nsGkAtoms::keypress)
    1:           continue;
    1: 
    1:         nsAutoString type;
    1:         eventAtom->ToString(type);
    1: 
    1:         // If this is a command, add it in the system event group, otherwise 
    1:         // add it to the standard event group.
    1: 
    1:         // This is a weak ref. systemEventGroup above is already a
    1:         // strong ref, so we are guaranteed it will not go away.
    1:         nsIDOMEventGroup* eventGroup = nsnull;
    1:         if (curr->GetType() & (NS_HANDLER_TYPE_XBL_COMMAND | NS_HANDLER_TYPE_SYSTEM)) {
    1:           if (!systemEventGroup)
    1:             manager->GetSystemEventGroupLM(getter_AddRefs(systemEventGroup));
    1:           eventGroup = systemEventGroup;
    1:         }
    1: 
    1:         nsXBLEventHandler* handler = curr->GetEventHandler();
    1:         if (handler) {
    1:           // Figure out if we're using capturing or not.
    1:           PRInt32 flags = (curr->GetPhase() == NS_PHASE_CAPTURING) ?
    1:             NS_EVENT_FLAG_CAPTURE : NS_EVENT_FLAG_BUBBLE;
    1: 
  541:           PRBool hasAllowUntrustedAttr = curr->HasAllowUntrustedAttr();
  541:           if ((hasAllowUntrustedAttr && curr->AllowUntrustedEvents()) ||
  541:               (!hasAllowUntrustedAttr && !isChromeDoc)) {
    1:             flags |= NS_PRIV_EVENT_UNTRUSTED_PERMITTED;
    1:           }
    1: 
    1:           manager->AddEventListenerByType(handler, type, flags, eventGroup);
    1:         }
    1:       }
    1: 
    1:       const nsCOMArray<nsXBLKeyEventHandler>* keyHandlers =
    1:         mPrototypeBinding->GetKeyEventHandlers();
    1:       PRInt32 i;
    1:       for (i = 0; i < keyHandlers->Count(); ++i) {
    1:         nsXBLKeyEventHandler* handler = keyHandlers->ObjectAt(i);
  541:         handler->SetIsBoundToChrome(isChromeDoc);
    1: 
    1:         nsAutoString type;
    1:         handler->GetEventName(type);
    1: 
    1:         // If this is a command, add it in the system event group, otherwise 
    1:         // add it to the standard event group.
    1: 
    1:         // This is a weak ref. systemEventGroup above is already a
    1:         // strong ref, so we are guaranteed it will not go away.
    1:         nsIDOMEventGroup* eventGroup = nsnull;
    1:         if (handler->GetType() & (NS_HANDLER_TYPE_XBL_COMMAND | NS_HANDLER_TYPE_SYSTEM)) {
    1:           if (!systemEventGroup)
    1:             manager->GetSystemEventGroupLM(getter_AddRefs(systemEventGroup));
    1:           eventGroup = systemEventGroup;
    1:         }
    1: 
    1:         // Figure out if we're using capturing or not.
    1:         PRInt32 flags = (handler->GetPhase() == NS_PHASE_CAPTURING) ?
    1:           NS_EVENT_FLAG_CAPTURE : NS_EVENT_FLAG_BUBBLE;
    1: 
    1:         // For key handlers we have to set NS_PRIV_EVENT_UNTRUSTED_PERMITTED flag.
    1:         // Whether the handling of the event is allowed or not is handled in
    1:         // nsXBLKeyEventHandler::HandleEvent
    1:         flags |= NS_PRIV_EVENT_UNTRUSTED_PERMITTED;
    1: 
    1:         manager->AddEventListenerByType(handler, type, flags, eventGroup);
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (mNextBinding)
    1:     mNextBinding->InstallEventHandlers();
    1: }
    1: 
    1: nsresult
    1: nsXBLBinding::InstallImplementation()
    1: {
    1:   // Always install the base class properties first, so that
    1:   // derived classes can reference the base class properties.
    1: 
    1:   if (mNextBinding) {
    1:     nsresult rv = mNextBinding->InstallImplementation();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1:   
    1:   // iterate through each property in the prototype's list and install the property.
    1:   if (AllowScripts())
    1:     return mPrototypeBinding->InstallImplementation(mBoundElement);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsIAtom*
    1: nsXBLBinding::GetBaseTag(PRInt32* aNameSpaceID)
    1: {
    1:   nsIAtom *tag = mPrototypeBinding->GetBaseTag(aNameSpaceID);
    1:   if (!tag && mNextBinding)
    1:     return mNextBinding->GetBaseTag(aNameSpaceID);
    1: 
    1:   return tag;
    1: }
    1: 
    1: void
    1: nsXBLBinding::AttributeChanged(nsIAtom* aAttribute, PRInt32 aNameSpaceID,
    1:                                PRBool aRemoveFlag, PRBool aNotify)
    1: {
    1:   // XXX Change if we ever allow multiple bindings in a chain to contribute anonymous content
    1:   if (!mContent) {
    1:     if (mNextBinding)
    1:       mNextBinding->AttributeChanged(aAttribute, aNameSpaceID,
    1:                                      aRemoveFlag, aNotify);
    1:   } else {
    1:     mPrototypeBinding->AttributeChanged(aAttribute, aNameSpaceID, aRemoveFlag,
    1:                                         mBoundElement, mContent, aNotify);
    1:   }
    1: }
    1: 
    1: void
    1: nsXBLBinding::ExecuteAttachedHandler()
    1: {
    1:   if (mNextBinding)
    1:     mNextBinding->ExecuteAttachedHandler();
    1: 
    1:   if (AllowScripts())
    1:     mPrototypeBinding->BindingAttached(mBoundElement);
    1: }
    1: 
    1: void
    1: nsXBLBinding::ExecuteDetachedHandler()
    1: {
    1:   if (AllowScripts())
    1:     mPrototypeBinding->BindingDetached(mBoundElement);
    1: 
    1:   if (mNextBinding)
    1:     mNextBinding->ExecuteDetachedHandler();
    1: }
    1: 
    1: void
    1: nsXBLBinding::UnhookEventHandlers()
    1: {
    1:   nsXBLPrototypeHandler* handlerChain = mPrototypeBinding->GetPrototypeHandlers();
    1: 
    1:   if (handlerChain) {
 8069:     nsCOMPtr<nsIEventListenerManager> manager;
 8069:     mBoundElement->GetListenerManager(PR_FALSE, getter_AddRefs(manager));
 8069:     if (!manager) {
 8069:       return;
 8069:     }
 8069:                                       
    1:     nsCOMPtr<nsIDOMEventGroup> systemEventGroup;
    1:     nsXBLPrototypeHandler* curr;
    1:     for (curr = handlerChain; curr; curr = curr->GetNextHandler()) {
    1:       nsXBLEventHandler* handler = curr->GetCachedEventHandler();
 8069:       if (!handler) {
 8069:         continue;
 8069:       }
 8069:       
    1:       nsCOMPtr<nsIAtom> eventAtom = curr->GetEventName();
    1:       if (!eventAtom ||
    1:           eventAtom == nsGkAtoms::keyup ||
    1:           eventAtom == nsGkAtoms::keydown ||
    1:           eventAtom == nsGkAtoms::keypress)
    1:         continue;
    1: 
    1:       nsAutoString type;
    1:       eventAtom->ToString(type);
    1: 
    1:       // Figure out if we're using capturing or not.
 8069:       PRInt32 flags = (curr->GetPhase() == NS_PHASE_CAPTURING) ?
 8069:         NS_EVENT_FLAG_CAPTURE : NS_EVENT_FLAG_BUBBLE;
    1: 
 8069:       // If this is a command, remove it from the system event group,
 8069:       // otherwise remove it from the standard event group.
    1: 
    1:       // This is a weak ref. systemEventGroup above is already a
    1:       // strong ref, so we are guaranteed it will not go away.
    1:       nsIDOMEventGroup* eventGroup = nsnull;
    1:       if (curr->GetType() & (NS_HANDLER_TYPE_XBL_COMMAND | NS_HANDLER_TYPE_SYSTEM)) {
    1:         if (!systemEventGroup)
 8069:           manager->GetSystemEventGroupLM(getter_AddRefs(systemEventGroup));
    1:         eventGroup = systemEventGroup;
    1:       }
    1: 
 8069:       manager->RemoveEventListenerByType(handler, type, flags, eventGroup);
    1:     }
    1: 
    1:     const nsCOMArray<nsXBLKeyEventHandler>* keyHandlers =
    1:       mPrototypeBinding->GetKeyEventHandlers();
    1:     PRInt32 i;
    1:     for (i = 0; i < keyHandlers->Count(); ++i) {
    1:       nsXBLKeyEventHandler* handler = keyHandlers->ObjectAt(i);
    1: 
    1:       nsAutoString type;
    1:       handler->GetEventName(type);
    1: 
    1:       // Figure out if we're using capturing or not.
 8069:       PRInt32 flags = (handler->GetPhase() == NS_PHASE_CAPTURING) ?
 8069:         NS_EVENT_FLAG_CAPTURE : NS_EVENT_FLAG_BUBBLE;
    1: 
    1:       // If this is a command, remove it from the system event group, otherwise 
    1:       // remove it from the standard event group.
    1: 
    1:       // This is a weak ref. systemEventGroup above is already a
    1:       // strong ref, so we are guaranteed it will not go away.
    1:       nsIDOMEventGroup* eventGroup = nsnull;
    1:       if (handler->GetType() & (NS_HANDLER_TYPE_XBL_COMMAND | NS_HANDLER_TYPE_SYSTEM)) {
    1:         if (!systemEventGroup)
 8069:           manager->GetSystemEventGroupLM(getter_AddRefs(systemEventGroup));
    1:         eventGroup = systemEventGroup;
    1:       }
    1: 
 8069:       manager->RemoveEventListenerByType(handler, type, flags, eventGroup);
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsXBLBinding::ChangeDocument(nsIDocument* aOldDocument, nsIDocument* aNewDocument)
    1: {
    1:   if (aOldDocument != aNewDocument) {
 7064:     // Only style bindings get their prototypes unhooked.  First do ourselves.
    1:     if (mIsStyleBinding) {
    1:       // Now the binding dies.  Unhook our prototypes.
 7064:       if (mPrototypeBinding->HasImplementation()) { 
 7064:         nsIScriptGlobalObject *global = aOldDocument->GetScopeObject();
    1:         if (global) {
 7144:           nsCOMPtr<nsIScriptContext> context = global->GetContext();
    1:           if (context) {
 7064:             JSContext *cx = (JSContext *)context->GetNativeContext();
    1:  
    1:             nsCOMPtr<nsIXPConnectJSObjectHolder> wrapper;
    1:             nsresult rv = nsContentUtils::XPConnect()->
 7064:               WrapNative(cx, global->GetGlobalJSObject(),
    1:                          mBoundElement, NS_GET_IID(nsISupports),
    1:                          getter_AddRefs(wrapper));
    1:             if (NS_FAILED(rv))
    1:               return;
    1: 
    1:             JSObject* scriptObject = nsnull;
    1:             rv = wrapper->GetJSObject(&scriptObject);
    1:             if (NS_FAILED(rv))
    1:               return;
    1: 
    1:             // XXX Stay in sync! What if a layered binding has an
    1:             // <interface>?!
 7064:             // XXXbz what does that comment mean, really?  It seems to date
 7064:             // back to when there was such a thing as an <interface>, whever
 7064:             // that was...
    1: 
 7064:             // Find the right prototype.
 7064:             JSObject* base = scriptObject;
 7064:             JSObject* proto;
 7064:             JSAutoRequest ar(cx);
 7064:             for ( ; true; base = proto) { // Will break out on null proto
 7064:               proto = ::JS_GetPrototype(cx, base);
 7064:               if (!proto) {
 7064:                 break;
 7064:               }
 7064: 
12197:               JSClass* clazz = ::JS_GET_CLASS(cx, proto);
 7064:               if (!clazz ||
 7064:                   (~clazz->flags &
 7064:                    (JSCLASS_HAS_PRIVATE | JSCLASS_PRIVATE_IS_NSISUPPORTS)) ||
 7064:                   JSCLASS_RESERVED_SLOTS(clazz) != 1) {
 7064:                 // Clearly not the right class
 7064:                 continue;
 7064:               }
 7064: 
 7064:               nsCOMPtr<nsIXBLDocumentInfo> docInfo =
 7064:                 do_QueryInterface(static_cast<nsISupports*>
 7064:                                              (::JS_GetPrivate(cx, proto)));
 7064:               if (!docInfo) {
 7064:                 // Not the proto we seek
 7064:                 continue;
 7064:               }
 7064:               
 7064:               jsval protoBinding;
 7064:               if (!::JS_GetReservedSlot(cx, proto, 0, &protoBinding)) {
 7064:                 NS_ERROR("Really shouldn't happen");
 7064:                 continue;
 7064:               }
 7064: 
 7064:               if (JSVAL_TO_PRIVATE(protoBinding) != mPrototypeBinding) {
 7064:                 // Not the right binding
 7064:                 continue;
 7064:               }
 7064: 
 7064:               // Alright!  This is the right prototype.  Pull it out of the
 7064:               // proto chain.
 7064:               JSObject* grandProto = ::JS_GetPrototype(cx, proto);
 7064:               ::JS_SetPrototype(cx, base, grandProto);
 7064:               break;
    1:             }
    1: 
 7144:             mPrototypeBinding->UndefineFields(cx, scriptObject);
 7144: 
    1:             // Don't remove the reference from the document to the
    1:             // wrapper here since it'll be removed by the element
    1:             // itself when that's taken out of the document.
    1:           }
    1:         }
    1:       }
 8069: 
 8069:       // Remove our event handlers
 8069:       UnhookEventHandlers();
    1:     }
    1: 
 7064:     // Then do our ancestors.  This reverses the construction order, so that at
 7064:     // all times things are consistent as far as everyone is concerned.
 7064:     if (mNextBinding) {
 7064:       mNextBinding->ChangeDocument(aOldDocument, aNewDocument);
 7064:     }
 7064: 
    1:     // Update the anonymous content.
 7064:     // XXXbz why not only for style bindings?
    1:     nsIContent *anonymous = mContent;
    1:     if (anonymous) {
    1:       // Also kill the default content within all our insertion points.
    1:       if (mInsertionPointTable)
    1:         mInsertionPointTable->Enumerate(ChangeDocumentForDefaultContent,
    1:                                         nsnull);
    1: 
    1: #ifdef MOZ_XUL
    1:       nsCOMPtr<nsIXULDocument> xuldoc(do_QueryInterface(aOldDocument));
    1: #endif
    1: 
14228:       nsAutoScriptBlocker scriptBlocker;
22741:       // Unbind the _kids_ of the anonymous content, not just the anonymous
22741:       // content itself, since they are bound to some other parent.  Basically
22741:       // we want to undo the mess that InstallAnonymousContent created.
22741:       PRUint32 childCount = anonymous->GetChildCount();
22741:       for (PRUint32 i = 0; i < childCount; i++) {
22741:         anonymous->GetChildAt(i)->UnbindFromTree();
22741:       }
22741:       
    1:       anonymous->UnbindFromTree(); // Kill it.
    1: 
    1: #ifdef MOZ_XUL
    1:       // To make XUL templates work (and other XUL-specific stuff),
    1:       // we'll need to notify it using its add & remove APIs. Grab the
    1:       // interface now...
    1:       if (xuldoc)
    1:         xuldoc->RemoveSubtreeFromDocument(anonymous);
    1: #endif
    1:     }
    1: 
    1:     // Make sure that henceforth we don't claim that mBoundElement's children
    1:     // have insertion parents in the old document.
    1:     nsBindingManager* bindingManager = aOldDocument->BindingManager();
    1:     for (PRUint32 i = mBoundElement->GetChildCount(); i > 0; --i) {
    1:       NS_ASSERTION(mBoundElement->GetChildAt(i-1),
    1:                    "Must have child at i for 0 <= i < GetChildCount()!");
    1:       bindingManager->SetInsertionParent(mBoundElement->GetChildAt(i-1),
    1:                                          nsnull);
    1:     }
    1:   }
    1: }
    1: 
    1: PRBool
    1: nsXBLBinding::InheritsStyle() const
    1: {
    1:   // XXX Will have to change if we ever allow multiple bindings to contribute anonymous content.
    1:   // Most derived binding with anonymous content determines style inheritance for now.
    1: 
    1:   // XXX What about bindings with <content> but no kids, e.g., my treecell-text binding?
    1:   if (mContent)
    1:     return mPrototypeBinding->InheritsStyle();
    1:   
    1:   if (mNextBinding)
    1:     return mNextBinding->InheritsStyle();
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: void
    1: nsXBLBinding::WalkRules(nsIStyleRuleProcessor::EnumFunc aFunc, void* aData)
    1: {
    1:   if (mNextBinding)
    1:     mNextBinding->WalkRules(aFunc, aData);
    1: 
    1:   nsIStyleRuleProcessor *rules = mPrototypeBinding->GetRuleProcessor();
    1:   if (rules)
    1:     (*aFunc)(rules, aData);
    1: }
    1: 
    1: // Internal helper methods ////////////////////////////////////////////////////////////////
    1: 
    1: // static
    1: nsresult
    1: nsXBLBinding::DoInitJSClass(JSContext *cx, JSObject *global, JSObject *obj,
    1:                             const nsAFlatCString& aClassName,
 6392:                             nsXBLPrototypeBinding* aProtoBinding,
    1:                             void **aClassObject)
    1: {
    1:   // First ensure our JS class is initialized.
    1:   jsval val;
    1:   JSObject* proto;
    1: 
    1:   nsCAutoString className(aClassName);
    1:   JSObject* parent_proto = nsnull;  // If we have an "obj" we can set this
    1:   JSAutoRequest ar(cx);
    1:   if (obj) {
    1:     // Retrieve the current prototype of obj.
    1:     parent_proto = ::JS_GetPrototype(cx, obj);
    1:     if (parent_proto) {
    1:       // We need to create a unique classname based on aClassName and
    1:       // parent_proto.  Append a space (an invalid URI character) to ensure that
    1:       // we don't have accidental collisions with the case when parent_proto is
    1:       // null and aClassName ends in some bizarre numbers (yeah, it's unlikely).
    1:       jsid parent_proto_id;
    1:       if (!::JS_GetObjectId(cx, parent_proto, &parent_proto_id)) {
    1:         // Probably OOM
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:       }
    1: 
    1:       // One space, maybe "0x", at most 16 chars (on a 64-bit system) of long,
    1:       // and a null-terminator (which PR_snprintf ensures is there even if the
    1:       // string representation of what we're printing does not fit in the buffer
    1:       // provided).
    1:       char buf[20];
    1:       PR_snprintf(buf, sizeof(buf), " %lx", parent_proto_id);
    1:       className.Append(buf);
    1:     }
    1:   }
    1: 
    1:   if ((!::JS_LookupPropertyWithFlags(cx, global, className.get(),
    1:                                      JSRESOLVE_CLASSNAME,
    1:                                      &val)) ||
    1:       JSVAL_IS_PRIMITIVE(val)) {
    1:     // We need to initialize the class.
    1: 
    1:     nsXBLJSClass* c;
    1:     void* classObject;
    1:     nsCStringKey key(className);
    1:     classObject = (nsXBLService::gClassTable)->Get(&key);
    1: 
    1:     if (classObject) {
 3233:       c = static_cast<nsXBLJSClass*>(classObject);
    1: 
    1:       // If c is on the LRU list (i.e., not linked to itself), remove it now!
 3233:       JSCList* link = static_cast<JSCList*>(c);
    1:       if (c->next != link) {
    1:         JS_REMOVE_AND_INIT_LINK(link);
    1:         nsXBLService::gClassLRUListLength--;
    1:       }
    1:     } else {
    1:       if (JS_CLIST_IS_EMPTY(&nsXBLService::gClassLRUList)) {
    1:         // We need to create a struct for this class.
    1:         c = new nsXBLJSClass(className);
    1: 
    1:         if (!c)
    1:           return NS_ERROR_OUT_OF_MEMORY;
    1:       } else {
    1:         // Pull the least recently used class struct off the list.
    1:         JSCList* lru = (nsXBLService::gClassLRUList).next;
    1:         JS_REMOVE_AND_INIT_LINK(lru);
    1:         nsXBLService::gClassLRUListLength--;
    1: 
    1:         // Remove any mapping from the old name to the class struct.
 3233:         c = static_cast<nsXBLJSClass*>(lru);
    1:         nsCStringKey oldKey(c->name);
    1:         (nsXBLService::gClassTable)->Remove(&oldKey);
    1: 
    1:         // Change the class name and we're done.
    1:         nsMemory::Free((void*) c->name);
    1:         c->name = ToNewCString(className);
    1:       }
    1: 
    1:       // Add c to our table.
    1:       (nsXBLService::gClassTable)->Put(&key, (void*)c);
    1:     }
    1: 
    1:     // The prototype holds a strong reference to its class struct.
    1:     c->Hold();
    1: 
    1:     // Make a new object prototyped by parent_proto and parented by global.
    1:     proto = ::JS_InitClass(cx,                  // context
    1:                            global,              // global object
    1:                            parent_proto,        // parent proto 
    1:                            c,                   // JSClass
    1:                            nsnull,              // JSNative ctor
    1:                            0,                   // ctor args
    1:                            nsnull,              // proto props
    1:                            nsnull,              // proto funcs
    1:                            nsnull,              // ctor props (static)
    1:                            nsnull);             // ctor funcs (static)
    1:     if (!proto) {
    1:       // This will happen if we're OOM or if the security manager
    1:       // denies defining the new class...
    1: 
    1:       (nsXBLService::gClassTable)->Remove(&key);
    1: 
    1:       c->Drop();
    1: 
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
 6392:     // Keep this proto binding alive while we're alive.  Do this first so that
 6392:     // we can guarantee that in XBLFinalize this will be non-null.
 6392:     nsIXBLDocumentInfo* docInfo = aProtoBinding->XBLDocumentInfo();
 6392:     ::JS_SetPrivate(cx, proto, docInfo);
 6392:     NS_ADDREF(docInfo);
 6392: 
 6392:     if (!::JS_SetReservedSlot(cx, proto, 0, PRIVATE_TO_JSVAL(aProtoBinding))) {
 6392:       (nsXBLService::gClassTable)->Remove(&key);
 6392: 
 6392:       // |c| will get dropped when |proto| is finalized
 6392: 
 6392:       return NS_ERROR_OUT_OF_MEMORY;
 6392:     }
 6392: 
    1:     *aClassObject = (void*)proto;
    1:   }
    1:   else {
    1:     proto = JSVAL_TO_OBJECT(val);
    1:   }
    1: 
    1:   if (obj) {
    1:     // Set the prototype of our object to be the new class.
    1:     if (!::JS_SetPrototype(cx, obj, proto)) {
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsXBLBinding::AllowScripts()
    1: {
    1:   PRBool result;
    1:   mPrototypeBinding->GetAllowScripts(&result);
    1:   if (!result) {
    1:     return result;
    1:   }
    1: 
    1:   // Nasty hack.  Use the JSContext of the bound node, since the
    1:   // security manager API expects to get the docshell type from
    1:   // that.  But use the nsIPrincipal of our document.
    1:   nsIScriptSecurityManager* mgr = nsContentUtils::GetSecurityManager();
    1:   if (!mgr) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   nsIDocument* doc = mBoundElement->GetOwnerDoc();
    1:   if (!doc) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   nsIScriptGlobalObject* global = doc->GetScriptGlobalObject();
    1:   if (!global) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   nsCOMPtr<nsIScriptContext> context = global->GetContext();
    1:   if (!context) {
    1:     return PR_FALSE;
    1:   }
    1:   
    1:   JSContext* cx = (JSContext*) context->GetNativeContext();
    1: 
    1:   nsCOMPtr<nsIDocument> ourDocument;
    1:   mPrototypeBinding->XBLDocumentInfo()->GetDocument(getter_AddRefs(ourDocument));
    1:   PRBool canExecute;
    1:   nsresult rv =
    1:     mgr->CanExecuteScripts(cx, ourDocument->NodePrincipal(), &canExecute);
20601:   if (NS_FAILED(rv) || !canExecute) {
20601:     return PR_FALSE;
20601:   }
20601: 
20601:   // Now one last check: make sure that we're not allowing a privilege
20601:   // escalation here.
20601:   PRBool haveCert;
20601:   doc->NodePrincipal()->GetHasCertificate(&haveCert);
20601:   if (!haveCert) {
20601:     return PR_TRUE;
20601:   }
20601: 
20601:   PRBool subsumes;
20601:   rv = ourDocument->NodePrincipal()->Subsumes(doc->NodePrincipal(), &subsumes);
20601:   return NS_SUCCEEDED(rv) && subsumes;
    1: }
    1: 
 6864: void
 6864: nsXBLBinding::RemoveInsertionParent(nsIContent* aParent)
 6864: {
 6864:   if (mNextBinding) {
 6864:     mNextBinding->RemoveInsertionParent(aParent);
 6864:   }
 6864:   if (mInsertionPointTable) {
 6864:     nsInsertionPointList* list = nsnull;
 6864:     mInsertionPointTable->Get(aParent, &list);
 6864:     if (list) {
 6864:       PRInt32 count = list->Length();
 6864:       for (PRInt32 i = 0; i < count; ++i) {
 6864:         nsRefPtr<nsXBLInsertionPoint> currPoint = list->ElementAt(i);
10861:         currPoint->UnbindDefaultContent();
 6864: #ifdef DEBUG
 6864:         nsCOMPtr<nsIContent> parent = currPoint->GetInsertionParent();
 6864:         NS_ASSERTION(!parent || parent == aParent, "Wrong insertion parent!");
 6864: #endif
 6864:         currPoint->ClearInsertionParent();
 6864:       }
 6864:       mInsertionPointTable->Remove(aParent);
 6864:     }
 6864:   }
 6864: }
 6864: 
 6864: PRBool
 6864: nsXBLBinding::HasInsertionParent(nsIContent* aParent)
 6864: {
 6864:   if (mInsertionPointTable) {
 6864:     nsInsertionPointList* list = nsnull;
 6864:     mInsertionPointTable->Get(aParent, &list);
 6864:     if (list) {
 6864:       return PR_TRUE;
 6864:     }
 6864:   }
 6864:   return mNextBinding ? mNextBinding->HasInsertionParent(aParent) : PR_FALSE;
 6864: }
 6864: 
    1: nsresult
    1: nsXBLBinding::GetInsertionPointsFor(nsIContent* aParent,
    1:                                     nsInsertionPointList** aResult)
    1: {
    1:   if (!mInsertionPointTable) {
    1:     mInsertionPointTable =
    1:       new nsClassHashtable<nsISupportsHashKey, nsInsertionPointList>;
    1:     if (!mInsertionPointTable || !mInsertionPointTable->Init(4)) {
    1:       delete mInsertionPointTable;
    1:       mInsertionPointTable = nsnull;
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   mInsertionPointTable->Get(aParent, aResult);
    1: 
    1:   if (!*aResult) {
    1:     *aResult = new nsInsertionPointList;
    1:     if (!*aResult || !mInsertionPointTable->Put(aParent, *aResult)) {
    1:       delete *aResult;
    1:       *aResult = nsnull;
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
 6864:     if (aParent) {
 6864:       aParent->SetFlags(NODE_IS_INSERTION_PARENT);
 6864:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
 1685: nsInsertionPointList*
 1685: nsXBLBinding::GetExistingInsertionPointsFor(nsIContent* aParent)
 1685: {
 1685:   if (!mInsertionPointTable) {
 1685:     return nsnull;
 1685:   }
 1685: 
 1685:   nsInsertionPointList* result = nsnull;
 1685:   mInsertionPointTable->Get(aParent, &result);
 1685:   return result;
 1685: }
 1685: 
    1: nsIContent*
    1: nsXBLBinding::GetInsertionPoint(nsIContent* aChild, PRUint32* aIndex)
    1: {
    1:   if (mContent) {
    1:     return mPrototypeBinding->GetInsertionPoint(mBoundElement, mContent,
    1:                                                 aChild, aIndex);
    1:   }
    1: 
    1:   if (mNextBinding)
    1:     return mNextBinding->GetInsertionPoint(aChild, aIndex);
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: nsIContent*
    1: nsXBLBinding::GetSingleInsertionPoint(PRUint32* aIndex,
    1:                                       PRBool* aMultipleInsertionPoints)
    1: {
    1:   *aMultipleInsertionPoints = PR_FALSE;
    1:   if (mContent) {
    1:     return mPrototypeBinding->GetSingleInsertionPoint(mBoundElement, mContent, 
    1:                                                       aIndex, 
    1:                                                       aMultipleInsertionPoints);
    1:   }
    1: 
    1:   if (mNextBinding)
    1:     return mNextBinding->GetSingleInsertionPoint(aIndex,
    1:                                                  aMultipleInsertionPoints);
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: nsXBLBinding*
    1: nsXBLBinding::RootBinding()
    1: {
    1:   if (mNextBinding)
    1:     return mNextBinding->RootBinding();
    1: 
    1:   return this;
    1: }
    1: 
    1: nsXBLBinding*
    1: nsXBLBinding::GetFirstStyleBinding()
    1: {
    1:   if (mIsStyleBinding)
    1:     return this;
    1: 
    1:   return mNextBinding ? mNextBinding->GetFirstStyleBinding() : nsnull;
    1: }
    1: 
 6392: PRBool
 6392: nsXBLBinding::ResolveAllFields(JSContext *cx, JSObject *obj) const
 6392: {
 6392:   if (!mPrototypeBinding->ResolveAllFields(cx, obj)) {
 6392:     return PR_FALSE;
 6392:   }
 6392: 
 6392:   if (mNextBinding) {
 6392:     return mNextBinding->ResolveAllFields(cx, obj);
 6392:   }
 6392: 
 6392:   return PR_TRUE;
 6392: }
 6392: 
    1: void
    1: nsXBLBinding::MarkForDeath()
    1: {
    1:   mMarkedForDeath = PR_TRUE;
    1:   ExecuteDetachedHandler();
    1: }
    1: 
    1: PRBool
    1: nsXBLBinding::ImplementsInterface(REFNSIID aIID) const
    1: {
    1:   return mPrototypeBinding->ImplementsInterface(aIID) ||
    1:     (mNextBinding && mNextBinding->ImplementsInterface(aIID));
    1: }
    1: 
    1: already_AddRefed<nsIDOMNodeList>
    1: nsXBLBinding::GetAnonymousNodes()
    1: {
    1:   if (mContent) {
    1:     nsCOMPtr<nsIDOMElement> elt(do_QueryInterface(mContent));
    1:     nsIDOMNodeList *nodeList = nsnull;
    1:     elt->GetChildNodes(&nodeList);
    1:     return nodeList;
    1:   }
    1: 
    1:   if (mNextBinding)
    1:     return mNextBinding->GetAnonymousNodes();
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: PRBool
    1: nsXBLBinding::ShouldBuildChildFrames() const
    1: {
    1:   if (mContent)
    1:     return mPrototypeBinding->ShouldBuildChildFrames();
    1: 
    1:   if (mNextBinding) 
    1:     return mNextBinding->ShouldBuildChildFrames();
    1: 
    1:   return PR_TRUE;
    1: }
