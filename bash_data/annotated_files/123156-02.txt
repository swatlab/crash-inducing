113584: /* -*- Mode: C++; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil -*- */
113584: /* vim: set ts=4 sw=4 et tw=99: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 75615: 
 75622: /* Inline members for javascript type inference. */
 75615: 
 76083: #include "jsarray.h"
 75615: #include "jsanalyze.h"
 75615: #include "jscompartment.h"
 75615: #include "jsinfer.h"
 75617: #include "jsprf.h"
 97569: 
103320: #include "gc/Root.h"
 76058: #include "vm/GlobalObject.h"
121078: #ifdef JS_ION
112430: #include "ion/IonFrames.h"
121078: #endif
 75615: 
 76157: #include "vm/Stack-inl.h"
 76157: 
 75615: #ifndef jsinferinlines_h___
 75615: #define jsinferinlines_h___
 75615: 
115021: inline bool
115021: js::TaggedProto::isObject() const
115021: {
115021:     /* Skip NULL and Proxy::LazyProto. */
115021:     return uintptr_t(proto) > uintptr_t(Proxy::LazyProto);
115021: }
115021: 
115021: inline bool
115021: js::TaggedProto::isLazy() const
115021: {
115021:     return proto == Proxy::LazyProto;
115021: }
115021: 
115021: inline JSObject *
115021: js::TaggedProto::toObject() const
115021: {
115021:     JS_ASSERT(isObject());
115021:     return proto;
115021: }
115021: 
115021: inline JSObject *
115021: js::TaggedProto::toObjectOrNull() const
115021: {
115021:     JS_ASSERT(!proto || isObject());
115021:     return proto;
115021: }
115021: 
115021: template<class Outer>
115021: inline bool
115032: js::TaggedProtoOperations<Outer>::isLazy() const
115021: {
115021:     return value()->isLazy();
115021: }
115021: 
115021: template<class Outer>
115021: inline bool
115032: js::TaggedProtoOperations<Outer>::isObject() const
115021: {
115021:     return value()->isObject();
115021: }
115021: 
115021: template<class Outer>
115021: inline JSObject *
115032: js::TaggedProtoOperations<Outer>::toObject() const
115021: {
115021:     return value()->toObject();
115021: }
115021: 
115021: template<class Outer>
115021: inline JSObject *
115032: js::TaggedProtoOperations<Outer>::toObjectOrNull() const
115021: {
115021:     return value()->toObjectOrNull();
115021: }
115021: 
105550: namespace js {
105550: namespace types {
105550: 
105550: /////////////////////////////////////////////////////////////////////
105550: // CompilerOutput & RecompileInfo
105550: /////////////////////////////////////////////////////////////////////
105550: 
108351: inline
108351: CompilerOutput::CompilerOutput()
108351:   : script(NULL),
121812:     kindInt(MethodJIT),
108351:     constructing(false),
108351:     barriers(false),
108351:     chunkIndex(false)
108351: {
108351: }
108351: 
108351: inline mjit::JITScript *
108351: CompilerOutput::mjit() const
108351: {
108351: #ifdef JS_METHODJIT
121812:     JS_ASSERT(kind() == MethodJIT && isValid());
108351:     return script->getJIT(constructing, barriers);
108351: #else
108351:     return NULL;
108351: #endif
108351: }
108351: 
113552: inline ion::IonScript *
113552: CompilerOutput::ion() const
113552: {
121078: #ifdef JS_ION
121812:     JS_ASSERT(kind() != MethodJIT && isValid());
121812:     switch (kind()) {
121812:       case MethodJIT: break;
121812:       case Ion: return script->ionScript();
121812:       case ParallelIon: return script->parallelIonScript();
121812:     }
121812: #endif
121812:     JS_NOT_REACHED("Invalid kind of CompilerOutput");
121078:     return NULL;
113418: }
113418: 
105550: inline bool
105550: CompilerOutput::isValid() const
105550: {
108351:     if (!script)
108351:         return false;
108351: 
121078: #if defined(DEBUG) && (defined(JS_METHODJIT) || defined(JS_ION))
108351:     TypeCompartment &types = script->compartment()->types;
108351: #endif
108351: 
121812:     switch (kind()) {
121812:       case MethodJIT: {
105550: #ifdef JS_METHODJIT
108351:         mjit::JITScript *jit = script->getJIT(constructing, barriers);
108351:         if (!jit)
108351:             return false;
108351:         mjit::JITChunk *chunk = jit->chunkDescriptor(chunkIndex).chunk;
108351:         if (!chunk)
108351:             return false;
108351:         JS_ASSERT(this == chunk->recompileInfo.compilerOutput(types));
105550:         return true;
121812: #endif
108351:       }
113552: 
121812:       case Ion:
121078: #ifdef JS_ION
113582:         if (script->hasIonScript()) {
113552:             JS_ASSERT(this == script->ion->recompileInfo().compilerOutput(types));
113418:             return true;
113552:         }
113582:         if (script->isIonCompilingOffThread())
113582:             return true;
121812: #endif
121812:         return false;
121812: 
121812:       case ParallelIon:
121812: #ifdef JS_ION
121812:         if (script->hasParallelIonScript()) {
121812:             JS_ASSERT(this == script->parallelIonScript()->recompileInfo().compilerOutput(types));
121812:             return true;
121812:         }
121812:         if (script->isParallelIonCompilingOffThread())
121812:             return true;
121812: #endif
113582:         return false;
113582:     }
105550:     return false;
105550: }
105550: 
105550: inline CompilerOutput*
108351: RecompileInfo::compilerOutput(TypeCompartment &types) const
108351: {
108351:     return &(*types.constrainedOutputs)[outputIndex];
108351: }
108351: 
108351: inline CompilerOutput*
105550: RecompileInfo::compilerOutput(JSContext *cx) const
105550: {
113552:     return compilerOutput(cx->compartment->types);
105550: }
105550: 
 75615: /////////////////////////////////////////////////////////////////////
 75615: // Types
 75615: /////////////////////////////////////////////////////////////////////
 75615: 
 77353: /* static */ inline Type
114328: Type::ObjectType(RawObject obj)
 77353: {
 77353:     if (obj->hasSingletonType())
 86976:         return Type(uintptr_t(obj) | 1);
 86976:     return Type(uintptr_t(obj->type()));
 77353: }
 77353: 
 77353: /* static */ inline Type
 77353: Type::ObjectType(TypeObject *obj)
 77353: {
 77353:     if (obj->singleton)
 86976:         return Type(uintptr_t(obj->singleton.get()) | 1);
 86976:     return Type(uintptr_t(obj));
 77353: }
 77353: 
 77353: /* static */ inline Type
 77353: Type::ObjectType(TypeObjectKey *obj)
 77353: {
 86976:     return Type(uintptr_t(obj));
 77353: }
 77353: 
 77353: inline Type
 75615: GetValueType(JSContext *cx, const Value &val)
 75615: {
 75720:     JS_ASSERT(cx->typeInferenceEnabled());
 75615:     if (val.isDouble())
 77353:         return Type::DoubleType();
 77353:     if (val.isObject())
 77353:         return Type::ObjectType(&val.toObject());
 77353:     return Type::PrimitiveType(val.extractNonDoubleType());
 77353: }
 77353: 
 77353: inline TypeFlags
 77353: PrimitiveTypeFlag(JSValueType type)
 77353: {
 77353:     switch (type) {
 77353:       case JSVAL_TYPE_UNDEFINED:
 77353:         return TYPE_FLAG_UNDEFINED;
 77353:       case JSVAL_TYPE_NULL:
 77353:         return TYPE_FLAG_NULL;
 77353:       case JSVAL_TYPE_BOOLEAN:
 77353:         return TYPE_FLAG_BOOLEAN;
 75615:       case JSVAL_TYPE_INT32:
 77353:         return TYPE_FLAG_INT32;
 77353:       case JSVAL_TYPE_DOUBLE:
 77353:         return TYPE_FLAG_DOUBLE;
 75615:       case JSVAL_TYPE_STRING:
 77353:         return TYPE_FLAG_STRING;
 76128:       case JSVAL_TYPE_MAGIC:
 77353:         return TYPE_FLAG_LAZYARGS;
 76128:       default:
 77353:         JS_NOT_REACHED("Bad type");
 77353:         return 0;
 76128:     }
 75615: }
 77353: 
 77353: inline JSValueType
 77353: TypeFlagPrimitive(TypeFlags flags)
 77353: {
 77353:     switch (flags) {
 77353:       case TYPE_FLAG_UNDEFINED:
 77353:         return JSVAL_TYPE_UNDEFINED;
 77353:       case TYPE_FLAG_NULL:
 77353:         return JSVAL_TYPE_NULL;
 77353:       case TYPE_FLAG_BOOLEAN:
 77353:         return JSVAL_TYPE_BOOLEAN;
 77353:       case TYPE_FLAG_INT32:
 77353:         return JSVAL_TYPE_INT32;
 77353:       case TYPE_FLAG_DOUBLE:
 77353:         return JSVAL_TYPE_DOUBLE;
 77353:       case TYPE_FLAG_STRING:
 77353:         return JSVAL_TYPE_STRING;
 77353:       case TYPE_FLAG_LAZYARGS:
 77353:         return JSVAL_TYPE_MAGIC;
 75615:       default:
 77353:         JS_NOT_REACHED("Bad type");
 77353:         return (JSValueType) 0;
 75615:     }
 75615: }
 75615: 
 75615: /*
 75615:  * Get the canonical representation of an id to use when doing inference.  This
 75615:  * maintains the constraint that if two different jsids map to the same property
 75615:  * in JS (e.g. 3 and "3"), they have the same type representation.
 75615:  */
 75615: inline jsid
 75679: MakeTypeId(JSContext *cx, jsid id)
 75615: {
 76103:     JS_ASSERT(!JSID_IS_EMPTY(id));
 76103: 
 75615:     /*
 75615:      * All integers must map to the aggregate property for index types, including
 75615:      * negative integers.
 75615:      */
 75615:     if (JSID_IS_INT(id))
 75615:         return JSID_VOID;
 75615: 
 75615:     /*
 75615:      * Check for numeric strings, as in js_StringIsIndex, but allow negative
 75679:      * and overflowing integers.
 75615:      */
 75615:     if (JSID_IS_STRING(id)) {
 75688:         JSFlatString *str = JSID_TO_FLAT_STRING(id);
 75688:         const jschar *cp = str->getCharsZ(cx);
 75615:         if (JS7_ISDEC(*cp) || *cp == '-') {
 75615:             cp++;
 75615:             while (JS7_ISDEC(*cp))
 75615:                 cp++;
 76073:             if (*cp == 0)
 75615:                 return JSID_VOID;
 75615:         }
 75720:         return id;
 75615:     }
 75615: 
 75615:     return JSID_VOID;
 75615: }
 75615: 
 75682: const char * TypeIdStringImpl(jsid id);
 75682: 
 75638: /* Convert an id for printing during debug. */
 75638: static inline const char *
 75640: TypeIdString(jsid id)
 75638: {
 75638: #ifdef DEBUG
 75657:     return TypeIdStringImpl(id);
 75638: #else
 75641:     return "(missing)";
 75638: #endif
 75638: }
 75638: 
113354: /* Assert code to know which PCs are reasonable to be considering inlining on. */
113327: inline bool
113327: IsInlinableCall(jsbytecode *pc)
113327: {
113327:     JSOp op = JSOp(*pc);
113327: 
113327:     // CALL, FUNCALL, FUNAPPLY (Standard callsites)
113354:     // NEW (IonMonkey-only callsite)
113327:     // GETPROP, CALLPROP, and LENGTH. (Inlined Getters)
113327:     // SETPROP, SETNAME, SETGNAME (Inlined Setters)
113327:     return op == JSOP_CALL || op == JSOP_FUNCALL || op == JSOP_FUNAPPLY ||
113354: #ifdef JS_ION
113354:            op == JSOP_NEW ||
113354: #endif
113327:            op == JSOP_GETPROP || op == JSOP_CALLPROP || op == JSOP_LENGTH ||
113327:            op == JSOP_SETPROP || op == JSOP_SETGNAME || op == JSOP_SETNAME;
113327: 
113327: }
113327: 
 75720: /*
 75720:  * Structure for type inference entry point functions. All functions which can
 75720:  * change type information must use this, and functions which depend on
 75720:  * intermediate types (i.e. JITs) can use this to ensure that intermediate
 75720:  * information is not collected and does not change.
 75720:  *
 75720:  * Pins inference results so that intermediate type information, TypeObjects
 75720:  * and JSScripts won't be collected during GC. Does additional sanity checking
 75720:  * that inference is not reentrant and that recompilations occur properly.
 75720:  */
 75720: struct AutoEnterTypeInference
 75720: {
 94740:     FreeOp *freeOp;
 94740:     JSCompartment *compartment;
 75987:     bool oldActiveAnalysis;
 75987:     bool oldActiveInference;
 75720: 
 75720:     AutoEnterTypeInference(JSContext *cx, bool compiling = false)
 75720:     {
 75720:         JS_ASSERT_IF(!compiling, cx->compartment->types.inferenceEnabled);
 94740:         init(cx->runtime->defaultFreeOp(), cx->compartment);
 94740:     }
 94740: 
 94740:     AutoEnterTypeInference(FreeOp *fop, JSCompartment *comp)
 94740:     {
 94740:         init(fop, comp);
 75720:     }
 75720: 
 75720:     ~AutoEnterTypeInference()
 75720:     {
 94740:         compartment->activeAnalysis = oldActiveAnalysis;
 94740:         compartment->activeInference = oldActiveInference;
 75987: 
 75893:         /*
 75987:          * If there are no more type inference activations on the stack,
 75987:          * process any triggered recompilations. Note that we should not be
 75987:          * invoking any scripted code while type inference is running.
 75987:          * :TODO: assert this.
 75893:          */
 94740:         if (!compartment->activeInference) {
 94740:             TypeCompartment *types = &compartment->types;
 75987:             if (types->pendingNukeTypes)
 94740:                 types->nukeTypes(freeOp);
 75987:             else if (types->pendingRecompiles)
 94740:                 types->processPendingRecompiles(freeOp);
 75987:         }
 75720:     }
 94740: 
 94740:   private:
 94740:     void init(FreeOp *fop, JSCompartment *comp) {
 94740:         freeOp = fop;
 94740:         compartment = comp;
 94740:         oldActiveAnalysis = compartment->activeAnalysis;
 94740:         oldActiveInference = compartment->activeInference;
 94740:         compartment->activeAnalysis = true;
 94740:         compartment->activeInference = true;
 94740:     }
 75720: };
 75720: 
 75893: /*
 75893:  * Structure marking the currently compiled script, for constraints which can
 75893:  * trigger recompilation.
 75893:  */
 75893: struct AutoEnterCompilation
 75893: {
105550:     JSContext *cx;
 87654:     RecompileInfo &info;
121812:     CompilerOutput::Kind kind;
 75893: 
121812:     AutoEnterCompilation(JSContext *cx, CompilerOutput::Kind kind)
105550:       : cx(cx),
113418:         info(cx->compartment->types.compiledInfo),
121812:         kind(kind)
 75893:     {
109114:         JS_ASSERT(cx->compartment->activeAnalysis);
105550:         JS_ASSERT(info.outputIndex == RecompileInfo::NoCompilerRunning);
105550:     }
105550: 
105550:     bool init(JSScript *script, bool constructing, unsigned chunkIndex)
105550:     {
105550:         CompilerOutput co;
105550:         co.script = script;
121812:         co.setKind(kind);
105550:         co.constructing = constructing;
108442:         co.barriers = cx->compartment->compileBarriers();
105550:         co.chunkIndex = chunkIndex;
105550: 
108351:         // This flag is used to prevent adding the current compiled script in
108351:         // the list of compiler output which should be invalided.  This is
108351:         // necessary because we can run some analysis might discard the script
108351:         // it-self, which can happen when the monitored value does not reflect
108351:         // the types propagated by the type inference.
108351:         co.pendingRecompilation = true;
108351: 
108351:         JS_ASSERT(!co.isValid());
105550:         TypeCompartment &types = cx->compartment->types;
105550:         if (!types.constrainedOutputs) {
105550:             types.constrainedOutputs = cx->new_< Vector<CompilerOutput> >(cx);
105550:             if (!types.constrainedOutputs) {
105550:                 types.setPendingNukeTypes(cx);
105550:                 return false;
105550:             }
105550:         }
105550: 
123156:         info.outputIndex = types.constrainedOutputs->length();
113418:         // I hope we GC before we reach 64k of compilation attempts.
105550:         if (info.outputIndex >= RecompileInfo::NoCompilerRunning)
105550:             return false;
105550: 
123156:         if (!types.constrainedOutputs->append(co)) {
123156:             info.outputIndex = RecompileInfo::NoCompilerRunning;
105550:             return false;
123156:         }
105550:         return true;
 75893:     }
 75893: 
113582:     void initExisting(RecompileInfo oldInfo)
113582:     {
113582:         // Initialize the active compilation index from that produced during a
113582:         // previous compilation, for finishing an off thread compilation.
113582:         info = oldInfo;
113582:     }
113582: 
 75893:     ~AutoEnterCompilation()
 75893:     {
123156:         // Handle failure cases of init.
123156:         if (info.outputIndex >= RecompileInfo::NoCompilerRunning)
123156:             return;
123156: 
123156:         JS_ASSERT(info.outputIndex < cx->compartment->types.constrainedOutputs->length());
105550:         CompilerOutput *co = info.compilerOutput(cx);
108351:         co->pendingRecompilation = false;
108351:         if (!co->isValid())
108351:             co->invalidate();
108351: 
105550:         info.outputIndex = RecompileInfo::NoCompilerRunning;
 75893:     }
 75893: };
 75893: 
 76148: /////////////////////////////////////////////////////////////////////
 76148: // Interface functions
 76148: /////////////////////////////////////////////////////////////////////
 76148: 
 76148: /*
 76148:  * These functions check whether inference is enabled before performing some
 76148:  * action on the type state. To avoid checking cx->typeInferenceEnabled()
 76148:  * everywhere, it is generally preferred to use one of these functions or
 76148:  * a type function on JSScript to perform inference operations.
 76148:  */
 76148: 
 76148: /*
 76148:  * Get the default 'new' object for a given standard class, per the currently
 76148:  * active global.
 76148:  */
 76148: inline TypeObject *
 76148: GetTypeNewObject(JSContext *cx, JSProtoKey key)
 76148: {
115032:     js::RootedObject proto(cx);
109255:     if (!js_GetClassPrototype(cx, key, &proto))
 76148:         return NULL;
 76148:     return proto->getNewType(cx);
 76148: }
 76148: 
 76148: /* Get a type object for the immediate allocation site within a native. */
 76148: inline TypeObject *
 76179: GetTypeCallerInitObject(JSContext *cx, JSProtoKey key)
 76148: {
 76148:     if (cx->typeInferenceEnabled()) {
 76157:         jsbytecode *pc;
115105:         RootedScript script(cx, cx->stack.currentScript(&pc));
 77399:         if (script)
 77391:             return TypeScript::InitObject(cx, script, pc, key);
 76148:     }
 76179:     return GetTypeNewObject(cx, key);
 76148: }
 76148: 
 76175: /*
 76175:  * When using a custom iterator within the initialization of a 'for in' loop,
 76175:  * mark the iterator values as unknown.
 76175:  */
 76148: inline void
 76175: MarkIteratorUnknown(JSContext *cx)
 76148: {
 76175:     extern void MarkIteratorUnknownSlow(JSContext *cx);
 76148: 
 76148:     if (cx->typeInferenceEnabled())
 76175:         MarkIteratorUnknownSlow(cx);
 76148: }
 76148: 
 76148: /*
 80962:  * Monitor a javascript call, either on entry to the interpreter or made
 80962:  * from within the interpreter.
 76148:  */
 95084: inline bool
 80962: TypeMonitorCall(JSContext *cx, const js::CallArgs &args, bool constructing)
 76148: {
114328:     extern void TypeMonitorCallSlow(JSContext *cx, HandleObject callee,
 80962:                                     const CallArgs &args, bool constructing);
 76148: 
115032:     js::RootedObject callee(cx, &args.callee());
 77884:     if (callee->isFunction()) {
 83234:         JSFunction *fun = callee->toFunction();
 77884:         if (fun->isInterpreted()) {
115032:             js::RootedScript script(cx, fun->script());
104376:             if (!script->ensureRanAnalysis(cx))
 95084:                 return false;
 77884:             if (cx->typeInferenceEnabled())
 76148:                 TypeMonitorCallSlow(cx, callee, args, constructing);
 76148:         }
 76148:     }
 95084: 
 95084:     return true;
 77884: }
 76148: 
 77353: inline bool
114328: TrackPropertyTypes(JSContext *cx, HandleObject obj, jsid id)
 77353: {
 77361:     if (!cx->typeInferenceEnabled() || obj->hasLazyType() || obj->type()->unknownProperties())
 77361:         return false;
 77361: 
 77361:     if (obj->hasSingletonType() && !obj->type()->maybeGetProperty(cx, id))
 77361:         return false;
 77361: 
 77361:     return true;
 77353: }
 77353: 
 76148: /* Add a possible type for a property of obj. */
 76148: inline void
114328: AddTypePropertyId(JSContext *cx, HandleObject obj, jsid id, Type type)
 76148: {
 77361:     if (cx->typeInferenceEnabled())
 77361:         id = MakeTypeId(cx, id);
 77353:     if (TrackPropertyTypes(cx, obj, id))
 77353:         obj->type()->addPropertyType(cx, id, type);
 76148: }
 76148: 
 76148: inline void
114328: AddTypePropertyId(JSContext *cx, HandleObject obj, jsid id, const Value &value)
 76148: {
 77361:     if (cx->typeInferenceEnabled())
 77361:         id = MakeTypeId(cx, id);
 77353:     if (TrackPropertyTypes(cx, obj, id))
 77353:         obj->type()->addPropertyType(cx, id, value);
 76148: }
 76148: 
 76148: inline void
 77353: AddTypeProperty(JSContext *cx, TypeObject *obj, const char *name, Type type)
 76148: {
 76148:     if (cx->typeInferenceEnabled() && !obj->unknownProperties())
 76148:         obj->addPropertyType(cx, name, type);
 76148: }
 76148: 
 76148: inline void
 76148: AddTypeProperty(JSContext *cx, TypeObject *obj, const char *name, const Value &value)
 76148: {
 76148:     if (cx->typeInferenceEnabled() && !obj->unknownProperties())
 76148:         obj->addPropertyType(cx, name, value);
 76148: }
 76148: 
 76148: /* Set one or more dynamic flags on a type object. */
 76148: inline void
114328: MarkTypeObjectFlags(JSContext *cx, RawObject obj, TypeObjectFlags flags)
 76148: {
 77374:     if (cx->typeInferenceEnabled() && !obj->hasLazyType() && !obj->type()->hasAllFlags(flags))
 77361:         obj->type()->setFlags(cx, flags);
 77353: }
 76148: 
 77353: /*
 77353:  * Mark all properties of a type object as unknown. If markSetsUnknown is set,
 77353:  * scan the entire compartment and mark all type sets containing it as having
 77353:  * an unknown object. This is needed for correctness in dealing with mutable
 77353:  * __proto__, which can change the type of an object dynamically.
 77353:  */
 76148: inline void
 77353: MarkTypeObjectUnknownProperties(JSContext *cx, TypeObject *obj,
 77353:                                 bool markSetsUnknown = false)
 76148: {
 77353:     if (cx->typeInferenceEnabled()) {
 77353:         if (!obj->unknownProperties())
 76148:             obj->markUnknown(cx);
 77361:         if (markSetsUnknown && !(obj->flags & OBJECT_FLAG_SETS_MARKED_UNKNOWN))
 77353:             cx->compartment->types.markSetsUnknown(cx, obj);
 77353:     }
 76148: }
 76148: 
 76148: /*
 76148:  * Mark any property which has been deleted or configured to be non-writable or
 76148:  * have a getter/setter.
 76148:  */
 76148: inline void
114328: MarkTypePropertyConfigured(JSContext *cx, HandleObject obj, jsid id)
 76148: {
 77361:     if (cx->typeInferenceEnabled())
 77361:         id = MakeTypeId(cx, id);
 77361:     if (TrackPropertyTypes(cx, obj, id))
 77353:         obj->type()->markPropertyConfigured(cx, id);
 77353: }
 76148: 
 77414: /* Mark a state change on a particular object. */
 76148: inline void
114328: MarkObjectStateChange(JSContext *cx, HandleObject obj)
 76148: {
 77414:     if (cx->typeInferenceEnabled() && !obj->hasLazyType() && !obj->type()->unknownProperties())
 77414:         obj->type()->markStateChange(cx);
 76148: }
 76148: 
 76148: /*
 76148:  * For an array or object which has not yet escaped and been referenced elsewhere,
 76148:  * pick a new type based on the object's current contents.
 76148:  */
 76148: 
 76148: inline void
114328: FixArrayType(JSContext *cx, HandleObject obj)
 76148: {
 76148:     if (cx->typeInferenceEnabled())
 76148:         cx->compartment->types.fixArrayType(cx, obj);
 76148: }
 76148: 
 76148: inline void
114328: FixObjectType(JSContext *cx, HandleObject obj)
 76148: {
 76148:     if (cx->typeInferenceEnabled())
 76148:         cx->compartment->types.fixObjectType(cx, obj);
 76148: }
 76148: 
 76148: /* Interface helpers for JSScript */
115105: extern void TypeMonitorResult(JSContext *cx, HandleScript script, jsbytecode *pc,
115105:                               const js::Value &rval);
115105: extern void TypeDynamicResult(JSContext *cx, HandleScript script, jsbytecode *pc,
115105:                               js::types::Type type);
 76148: 
 77341: inline bool
 77341: UseNewTypeAtEntry(JSContext *cx, StackFrame *fp)
 77341: {
115105: 
115105:     if (!fp->isConstructing() || !cx->typeInferenceEnabled() || !fp->prev())
115105:         return false;
115105: 
115105:     RootedScript prevScript(cx, fp->prev()->script());
115105:     return UseNewType(cx, prevScript, fp->prevpc());
 77341: }
 77341: 
105653: inline bool
105653: UseNewTypeForClone(JSFunction *fun)
105653: {
119065:     AutoAssertNoGC nogc;
119065: 
105653:     if (fun->hasSingletonType() || !fun->isInterpreted())
105653:         return false;
105653: 
105653:     /*
105653:      * When a function is being used as a wrapper for another function, it
105653:      * improves precision greatly to distinguish between different instances of
105653:      * the wrapper; otherwise we will conflate much of the information about
105653:      * the wrapped functions.
105653:      *
105653:      * An important example is the Class.create function at the core of the
105653:      * Prototype.js library, which looks like:
105653:      *
105653:      * var Class = {
105653:      *   create: function() {
105653:      *     return function() {
105653:      *       this.initialize.apply(this, arguments);
105653:      *     }
105653:      *   }
105653:      * };
105653:      *
105653:      * Each instance of the innermost function will have a different wrapped
105653:      * initialize method. We capture this, along with similar cases, by looking
105653:      * for short scripts which use both .apply and arguments. For such scripts,
105653:      * whenever creating a new instance of the function we both give that
105653:      * instance a singleton type and clone the underlying script.
105653:      */
105653: 
121004:     RawScript script = fun->script().get(nogc);
105653: 
105653:     if (script->length >= 50)
105653:         return false;
105653: 
108509:     if (script->hasConsts() || script->hasObjects() || script->hasRegexps() || fun->isHeavyweight())
105653:         return false;
105653: 
105653:     bool hasArguments = false;
105653:     bool hasApply = false;
105653: 
105653:     for (jsbytecode *pc = script->code;
105653:          pc != script->code + script->length;
105653:          pc += GetBytecodeLength(pc))
105653:     {
105653:         if (*pc == JSOP_ARGUMENTS)
105653:             hasArguments = true;
105653:         if (*pc == JSOP_FUNAPPLY)
105653:             hasApply = true;
105653:     }
105653: 
105653:     return hasArguments && hasApply;
105653: }
105653: 
 75615: /////////////////////////////////////////////////////////////////////
 76148: // Script interface functions
 75615: /////////////////////////////////////////////////////////////////////
 75615: 
 77391: /* static */ inline unsigned
115105: TypeScript::NumTypeSets(RawScript script)
 76158: {
 77439:     return script->nTypeSets + analyze::TotalSlots(script);
 76158: }
 76158: 
109045: /* static */ inline HeapTypeSet *
115105: TypeScript::ReturnTypes(RawScript script)
 76158: {
109045:     TypeSet *types = script->types->typeArray() + script->nTypeSets + js::analyze::CalleeSlot();
109045:     return types->toHeapTypeSet();
 76158: }
 76158: 
109045: /* static */ inline StackTypeSet *
115105: TypeScript::ThisTypes(RawScript script)
 75718: {
109045:     TypeSet *types = script->types->typeArray() + script->nTypeSets + js::analyze::ThisSlot();
109045:     return types->toStackTypeSet();
 75718: }
 75718: 
 75987: /*
 75987:  * Note: for non-escaping arguments and locals, argTypes/localTypes reflect
 75987:  * only the initial type of the variable (e.g. passed values for argTypes,
 75987:  * or undefined for localTypes) and not types from subsequent assignments.
 75987:  */
 75987: 
109045: /* static */ inline StackTypeSet *
115105: TypeScript::ArgTypes(RawScript script, unsigned i)
 75718: {
 77391:     JS_ASSERT(i < script->function()->nargs);
109045:     TypeSet *types = script->types->typeArray() + script->nTypeSets + js::analyze::ArgSlot(i);
109045:     return types->toStackTypeSet();
 75718: }
 75718: 
109045: /* static */ inline StackTypeSet *
115105: TypeScript::LocalTypes(RawScript script, unsigned i)
 75718: {
 77391:     JS_ASSERT(i < script->nfixed);
109045:     TypeSet *types = script->types->typeArray() + script->nTypeSets + js::analyze::LocalSlot(script, i);
109045:     return types->toStackTypeSet();
 75718: }
 75718: 
109045: /* static */ inline StackTypeSet *
115105: TypeScript::SlotTypes(RawScript script, unsigned slot)
 75987: {
 77391:     JS_ASSERT(slot < js::analyze::TotalSlots(script));
109045:     TypeSet *types = script->types->typeArray() + script->nTypeSets + slot;
109045:     return types->toStackTypeSet();
 75718: }
 75718: 
 77391: /* static */ inline TypeObject *
115105: TypeScript::StandardType(JSContext *cx, HandleScript script, JSProtoKey key)
 75708: {
115032:     js::RootedObject proto(cx);
109255:     if (!js_GetClassPrototype(cx, key, &proto, NULL))
 75708:         return NULL;
 75708:     return proto->getNewType(cx);
 75708: }
 75708: 
 77361: struct AllocationSiteKey {
 77361:     JSScript *script;
 77884: 
 84755:     uint32_t offset : 24;
 77361:     JSProtoKey kind : 8;
 75708: 
 84755:     static const uint32_t OFFSET_LIMIT = (1 << 23);
 77361: 
 77361:     AllocationSiteKey() { PodZero(this); }
 77361: 
 77361:     typedef AllocationSiteKey Lookup;
 77361: 
 84755:     static inline uint32_t hash(AllocationSiteKey key) {
 91527:         return uint32_t(size_t(key.script->code + key.offset)) ^ key.kind;
 75708:     }
 75708: 
 77361:     static inline bool match(const AllocationSiteKey &a, const AllocationSiteKey &b) {
 77361:         return a.script == b.script && a.offset == b.offset && a.kind == b.kind;
 77361:     }
 77361: };
 77361: 
 77391: /* static */ inline TypeObject *
115105: TypeScript::InitObject(JSContext *cx, HandleScript script, jsbytecode *pc, JSProtoKey kind)
 77361: {
103065:     JS_ASSERT(!UseNewTypeForInitializer(cx, script, pc, kind));
 93664: 
 77361:     /* :XXX: Limit script->length so we don't need to check the offset up front? */
 84755:     uint32_t offset = pc - script->code;
 77361: 
110476:     if (!cx->typeInferenceEnabled() || !script->compileAndGo || offset >= AllocationSiteKey::OFFSET_LIMIT)
 77361:         return GetTypeNewObject(cx, kind);
 77361: 
 77361:     AllocationSiteKey key;
 77391:     key.script = script;
 77361:     key.offset = offset;
 77361:     key.kind = kind;
 77361: 
 77361:     if (!cx->compartment->types.allocationSiteTable)
113559:         return cx->compartment->types.addAllocationSiteTypeObject(cx, key);
 77361: 
 77361:     AllocationSiteTable::Ptr p = cx->compartment->types.allocationSiteTable->lookup(key);
 77361: 
 77361:     if (p)
 77361:         return p->value;
113559:     return cx->compartment->types.addAllocationSiteTypeObject(cx, key);
 75615: }
 75615: 
 93664: /* Set the type to use for obj according to the site it was allocated at. */
 93664: static inline bool
103320: SetInitializerObjectType(JSContext *cx, HandleScript script, jsbytecode *pc, HandleObject obj)
 93664: {
 93664:     if (!cx->typeInferenceEnabled())
 93664:         return true;
 93664: 
103065:     JSProtoKey key = JSCLASS_CACHED_PROTO_KEY(obj->getClass());
103065:     JS_ASSERT(key != JSProto_Null);
103065: 
103065:     if (UseNewTypeForInitializer(cx, script, pc, key)) {
108951:         if (!JSObject::setSingletonType(cx, obj))
 93664:             return false;
 93664: 
 93664:         /*
 93664:          * Inference does not account for types of run-once initializer
 93664:          * objects, as these may not be created until after the script
 93664:          * has been analyzed.
 93664:          */
 93664:         TypeScript::Monitor(cx, script, pc, ObjectValue(*obj));
 93664:     } else {
 93664:         types::TypeObject *type = TypeScript::InitObject(cx, script, pc, key);
 93664:         if (!type)
 93664:             return false;
 93664:         obj->setType(type);
 93664:     }
 93664: 
 93664:     return true;
 93664: }
 93664: 
 77391: /* static */ inline void
115105: TypeScript::Monitor(JSContext *cx, HandleScript script, jsbytecode *pc, const js::Value &rval)
 75615: {
 76148:     if (cx->typeInferenceEnabled())
 77391:         TypeMonitorResult(cx, script, pc, rval);
 75615: }
 75615: 
 77391: /* static */ inline void
115105: TypeScript::MonitorOverflow(JSContext *cx, HandleScript script, jsbytecode *pc)
 75633: {
 76061:     if (cx->typeInferenceEnabled())
 77391:         TypeDynamicResult(cx, script, pc, Type::DoubleType());
 75718: }
 75718: 
 77391: /* static */ inline void
115105: TypeScript::MonitorString(JSContext *cx, HandleScript script, jsbytecode *pc)
 75820: {
 76061:     if (cx->typeInferenceEnabled())
 77391:         TypeDynamicResult(cx, script, pc, Type::StringType());
 75820: }
 75820: 
 77391: /* static */ inline void
115105: TypeScript::MonitorUnknown(JSContext *cx, HandleScript script, jsbytecode *pc)
 75718: {
 76061:     if (cx->typeInferenceEnabled())
 77391:         TypeDynamicResult(cx, script, pc, Type::UnknownType());
 75633: }
 75633: 
 77391: /* static */ inline void
115105: TypeScript::GetPcScript(JSContext *cx, MutableHandleScript script, jsbytecode **pc)
 87809: {
119065:     AutoAssertNoGC nogc;
112538: #ifdef JS_ION
113551:     if (cx->fp()->beginsIonActivation()) {
112430:         ion::GetPcScript(cx, script, pc);
112538:         return;
112538:     }
112538: #endif
121004:     script.set(cx->fp()->script().get(nogc));
 87809:     *pc = cx->regs().pc;
 87809: }
 87809: 
 87809: /* static */ inline void
 87809: TypeScript::MonitorOverflow(JSContext *cx)
 87809: {
115105:     RootedScript script(cx);
 87809:     jsbytecode *pc;
 87809:     GetPcScript(cx, &script, &pc);
 87809:     MonitorOverflow(cx, script, pc);
 87809: }
 87809: 
 87809: /* static */ inline void
 87809: TypeScript::MonitorString(JSContext *cx)
 87809: {
115105:     RootedScript script(cx);
 87809:     jsbytecode *pc;
 87809:     GetPcScript(cx, &script, &pc);
 87809:     MonitorString(cx, script, pc);
 87809: }
 87809: 
 87809: /* static */ inline void
 87809: TypeScript::MonitorUnknown(JSContext *cx)
 87809: {
115105:     RootedScript script(cx);
 87809:     jsbytecode *pc;
 87809:     GetPcScript(cx, &script, &pc);
 87809:     MonitorUnknown(cx, script, pc);
 87809: }
 87809: 
 87809: /* static */ inline void
 88054: TypeScript::Monitor(JSContext *cx, const js::Value &rval)
 88054: {
115105:     RootedScript script(cx);
 88054:     jsbytecode *pc;
 88054:     GetPcScript(cx, &script, &pc);
 88054:     Monitor(cx, script, pc, rval);
 88054: }
 88054: 
 88054: /* static */ inline void
114328: TypeScript::MonitorAssign(JSContext *cx, HandleObject obj, jsid id)
 76083: {
 77399:     if (cx->typeInferenceEnabled() && !obj->hasSingletonType()) {
 76083:         /*
 76083:          * Mark as unknown any object which has had dynamic assignments to
 76083:          * non-integer properties at SETELEM opcodes. This avoids making large
 77399:          * numbers of type properties for hashmap-style objects. We don't need
 77399:          * to do this for objects with singleton type, because type properties
 77399:          * are only constructed for them when analyzed scripts depend on those
 77399:          * specific properties.
 76083:          */
 84755:         uint32_t i;
 76083:         if (js_IdIsIndex(id, &i))
 76083:             return;
 77353:         MarkTypeObjectUnknownProperties(cx, obj->type());
 76083:     }
 76083: }
 76083: 
 77391: /* static */ inline void
115105: TypeScript::SetThis(JSContext *cx, HandleScript script, Type type)
 75615: {
 77884:     if (!cx->typeInferenceEnabled())
 76020:         return;
 77884:     JS_ASSERT(script->types);
 75723: 
 75723:     /* Analyze the script regardless if -a was used. */
 77446:     bool analyze = cx->hasRunOption(JSOPTION_METHODJIT_ALWAYS);
 75723: 
 77391:     if (!ThisTypes(script)->hasType(type) || analyze) {
 76158:         AutoEnterTypeInference enter(cx);
 75615: 
 76158:         InferSpew(ISpewOps, "externalType: setThis #%u: %s",
 77391:                   script->id(), TypeString(type));
 77391:         ThisTypes(script)->addType(cx, type);
 75720: 
104376:         if (analyze)
 77391:             script->ensureRanInference(cx);
 76020:     }
 75720: }
 75723: 
 77391: /* static */ inline void
115105: TypeScript::SetThis(JSContext *cx, HandleScript script, const js::Value &value)
 75791: {
 75791:     if (cx->typeInferenceEnabled())
 77391:         SetThis(cx, script, GetValueType(cx, value));
 75791: }
 75791: 
 77391: /* static */ inline void
115105: TypeScript::SetLocal(JSContext *cx, HandleScript script, unsigned local, Type type)
 75720: {
 77884:     if (!cx->typeInferenceEnabled())
 76020:         return;
 77884:     JS_ASSERT(script->types);
 77884: 
 77391:     if (!LocalTypes(script, local)->hasType(type)) {
 76158:         AutoEnterTypeInference enter(cx);
 75720: 
 76158:         InferSpew(ISpewOps, "externalType: setLocal #%u %u: %s",
 77391:                   script->id(), local, TypeString(type));
 77391:         LocalTypes(script, local)->addType(cx, type);
 75720:     }
 75720: }
 75720: 
 77391: /* static */ inline void
115105: TypeScript::SetLocal(JSContext *cx, HandleScript script, unsigned local, const js::Value &value)
 75775: {
 75775:     if (cx->typeInferenceEnabled()) {
 77353:         Type type = GetValueType(cx, value);
 77391:         SetLocal(cx, script, local, type);
 75775:     }
 75775: }
 75775: 
 77391: /* static */ inline void
115105: TypeScript::SetArgument(JSContext *cx, HandleScript script, unsigned arg, Type type)
 75720: {
 77884:     if (!cx->typeInferenceEnabled())
 76020:         return;
 77884:     JS_ASSERT(script->types);
 77884: 
 77391:     if (!ArgTypes(script, arg)->hasType(type)) {
 76158:         AutoEnterTypeInference enter(cx);
 75720: 
 76158:         InferSpew(ISpewOps, "externalType: setArg #%u %u: %s",
 77391:                   script->id(), arg, TypeString(type));
 77391:         ArgTypes(script, arg)->addType(cx, type);
 75720:     }
 75720: }
 75720: 
 77391: /* static */ inline void
115105: TypeScript::SetArgument(JSContext *cx, HandleScript script, unsigned arg, const js::Value &value)
 75615: {
 75720:     if (cx->typeInferenceEnabled()) {
 77353:         Type type = GetValueType(cx, value);
 77391:         SetArgument(cx, script, arg, type);
 75718:     }
 75718: }
 75718: 
 75615: /////////////////////////////////////////////////////////////////////
 75615: // TypeCompartment
 75615: /////////////////////////////////////////////////////////////////////
 75615: 
 77361: inline JSCompartment *
 77361: TypeCompartment::compartment()
 77361: {
 77361:     return (JSCompartment *)((char *)this - offsetof(JSCompartment, types));
 77361: }
 77361: 
 75615: inline void
 77353: TypeCompartment::addPending(JSContext *cx, TypeConstraint *constraint, TypeSet *source, Type type)
 75615: {
 75615:     JS_ASSERT(this == &cx->compartment->types);
103783:     JS_ASSERT(!cx->runtime->isHeapBusy());
 75615: 
 76182:     InferSpew(ISpewOps, "pending: %sC%p%s %s",
 76182:               InferSpewColor(constraint), constraint, InferSpewColorReset(),
 76182:               TypeString(type));
 75615: 
 80429:     if ((pendingCount == pendingCapacity) && !growPendingArray(cx))
 80429:         return;
 75615: 
 75615:     PendingWork &pending = pendingArray[pendingCount++];
 75615:     pending.constraint = constraint;
 75615:     pending.source = source;
 75615:     pending.type = type;
 75615: }
 75615: 
 75615: inline void
 75615: TypeCompartment::resolvePending(JSContext *cx)
 75615: {
 75615:     JS_ASSERT(this == &cx->compartment->types);
 75615: 
 75615:     if (resolving) {
 75615:         /* There is an active call further up resolving the worklist. */
 75615:         return;
 75615:     }
 75615: 
 75615:     resolving = true;
 75615: 
 75615:     /* Handle all pending type registrations. */
 75615:     while (pendingCount) {
 75615:         const PendingWork &pending = pendingArray[--pendingCount];
 76182:         InferSpew(ISpewOps, "resolve: %sC%p%s %s",
 76182:                   InferSpewColor(pending.constraint), pending.constraint,
 76182:                   InferSpewColorReset(), TypeString(pending.type));
 75615:         pending.constraint->newType(cx, pending.source, pending.type);
 75615:     }
 75615: 
 75615:     resolving = false;
 75615: }
 75615: 
 75615: /////////////////////////////////////////////////////////////////////
 75615: // TypeSet
 75615: /////////////////////////////////////////////////////////////////////
 75615: 
 75615: /*
 75615:  * The sets of objects and scripts in a type set grow monotonically, are usually
 75615:  * empty, almost always small, and sometimes big.  For empty or singleton sets,
 75615:  * the pointer refers directly to the value.  For sets fitting into SET_ARRAY_SIZE,
 75615:  * an array of this length is used to store the elements.  For larger sets, a hash
 75615:  * table filled to 25%-50% of capacity is used, with collisions resolved by linear
 75615:  * probing.  TODO: replace these with jshashtables.
 75615:  */
 75615: const unsigned SET_ARRAY_SIZE = 8;
 75615: 
 75615: /* Get the capacity of a set with the given element count. */
 75615: static inline unsigned
 75615: HashSetCapacity(unsigned count)
 75615: {
 75615:     JS_ASSERT(count >= 2);
 75615: 
 75615:     if (count <= SET_ARRAY_SIZE)
 75615:         return SET_ARRAY_SIZE;
 75615: 
 75615:     unsigned log2;
 75615:     JS_FLOOR_LOG2(log2, count);
 75615:     return 1 << (log2 + 2);
 75615: }
 75615: 
 75615: /* Compute the FNV hash for the low 32 bits of v. */
 75641: template <class T, class KEY>
 84755: static inline uint32_t
 75641: HashKey(T v)
 75615: {
 84755:     uint32_t nv = KEY::keyBits(v);
 75615: 
 84755:     uint32_t hash = 84696351 ^ (nv & 0xff);
 75615:     hash = (hash * 16777619) ^ ((nv >> 8) & 0xff);
 75615:     hash = (hash * 16777619) ^ ((nv >> 16) & 0xff);
 75615:     return (hash * 16777619) ^ ((nv >> 24) & 0xff);
 75615: }
 75615: 
 75615: /*
 75641:  * Insert space for an element into the specified set and grow its capacity if needed.
 75641:  * returned value is an existing or new entry (NULL if new).
 75615:  */
 75641: template <class T, class U, class KEY>
 75720: static U **
109045: HashSetInsertTry(LifoAlloc &alloc, U **&values, unsigned &count, T key)
 75615: {
 75615:     unsigned capacity = HashSetCapacity(count);
 75641:     unsigned insertpos = HashKey<T,KEY>(key) & (capacity - 1);
 75615: 
 75641:     /* Whether we are converting from a fixed array to hashtable. */
 75641:     bool converting = (count == SET_ARRAY_SIZE);
 75615: 
 75641:     if (!converting) {
 75641:         while (values[insertpos] != NULL) {
 75641:             if (KEY::getKey(values[insertpos]) == key)
 75720:                 return &values[insertpos];
 75641:             insertpos = (insertpos + 1) & (capacity - 1);
 75615:         }
 75615:     }
 75615: 
 75615:     count++;
 75615:     unsigned newCapacity = HashSetCapacity(count);
 75615: 
 75641:     if (newCapacity == capacity) {
 75641:         JS_ASSERT(!converting);
 75720:         return &values[insertpos];
 75641:     }
 75641: 
109045:     U **newValues = alloc.newArray<U*>(newCapacity);
 77439:     if (!newValues)
 75720:         return NULL;
 75720:     PodZero(newValues, newCapacity);
 75615: 
 75615:     for (unsigned i = 0; i < capacity; i++) {
 75615:         if (values[i]) {
 75641:             unsigned pos = HashKey<T,KEY>(KEY::getKey(values[i])) & (newCapacity - 1);
 75615:             while (newValues[pos] != NULL)
 75615:                 pos = (pos + 1) & (newCapacity - 1);
 75615:             newValues[pos] = values[i];
 75615:         }
 75615:     }
 75615: 
 75615:     values = newValues;
 75615: 
 75641:     insertpos = HashKey<T,KEY>(key) & (newCapacity - 1);
 75641:     while (values[insertpos] != NULL)
 75641:         insertpos = (insertpos + 1) & (newCapacity - 1);
 75720:     return &values[insertpos];
 75615: }
 75615: 
 75615: /*
 75641:  * Insert an element into the specified set if it is not already there, returning
 75641:  * an entry which is NULL if the element was not there.
 75615:  */
 75641: template <class T, class U, class KEY>
 75720: static inline U **
109045: HashSetInsert(LifoAlloc &alloc, U **&values, unsigned &count, T key)
 75615: {
 75615:     if (count == 0) {
 75641:         JS_ASSERT(values == NULL);
 75615:         count++;
 75720:         return (U **) &values;
 75615:     }
 75615: 
 75615:     if (count == 1) {
 75641:         U *oldData = (U*) values;
 75720:         if (KEY::getKey(oldData) == key)
 75720:             return (U **) &values;
 75720: 
109045:         values = alloc.newArray<U*>(SET_ARRAY_SIZE);
 75720:         if (!values) {
 75720:             values = (U **) oldData;
 75720:             return NULL;
 75641:         }
 75720:         PodZero(values, SET_ARRAY_SIZE);
 75641:         count++;
 75615: 
 75615:         values[0] = oldData;
 75720:         return &values[1];
 75615:     }
 75615: 
 75615:     if (count <= SET_ARRAY_SIZE) {
 75615:         for (unsigned i = 0; i < count; i++) {
 75641:             if (KEY::getKey(values[i]) == key)
 75720:                 return &values[i];
 75615:         }
 75615: 
 75615:         if (count < SET_ARRAY_SIZE) {
 75641:             count++;
 75720:             return &values[count - 1];
 75641:         }
 75615:     }
 75615: 
109045:     return HashSetInsertTry<T,U,KEY>(alloc, values, count, key);
 75615: }
 75615: 
 75641: /* Lookup an entry in a hash set, return NULL if it does not exist. */
 75641: template <class T, class U, class KEY>
 75641: static inline U *
 75641: HashSetLookup(U **values, unsigned count, T key)
 75615: {
 75615:     if (count == 0)
 75641:         return NULL;
 75615: 
 75615:     if (count == 1)
 75641:         return (KEY::getKey((U *) values) == key) ? (U *) values : NULL;
 75615: 
 75615:     if (count <= SET_ARRAY_SIZE) {
 75615:         for (unsigned i = 0; i < count; i++) {
 75641:             if (KEY::getKey(values[i]) == key)
 75641:                 return values[i];
 75615:         }
 75641:         return NULL;
 75615:     }
 75615: 
 75615:     unsigned capacity = HashSetCapacity(count);
 75641:     unsigned pos = HashKey<T,KEY>(key) & (capacity - 1);
 75615: 
 75615:     while (values[pos] != NULL) {
 75641:         if (KEY::getKey(values[pos]) == key)
 75641:             return values[pos];
 75615:         pos = (pos + 1) & (capacity - 1);
 75615:     }
 75615: 
 75641:     return NULL;
 75615: }
 75615: 
 97880: inline TypeObjectKey *
 97880: Type::objectKey() const
 97880: {
 97880:     JS_ASSERT(isObject());
 97880:     if (isTypeObject())
 97880:         TypeObject::readBarrier((TypeObject *) data);
 97880:     else
 97880:         JSObject::readBarrier((JSObject *) (data ^ 1));
 97880:     return (TypeObjectKey *) data;
 97880: }
 97880: 
114328: inline RawObject
 97880: Type::singleObject() const
 97880: {
 97880:     JS_ASSERT(isSingleObject());
 97880:     JSObject::readBarrier((JSObject *) (data ^ 1));
 97880:     return (JSObject *) (data ^ 1);
 97880: }
 97880: 
 97880: inline TypeObject *
 97880: Type::typeObject() const
 97880: {
 97880:     JS_ASSERT(isTypeObject());
 97880:     TypeObject::readBarrier((TypeObject *) data);
 97880:     return (TypeObject *) data;
 97880: }
 97880: 
 75615: inline bool
 77353: TypeSet::hasType(Type type)
 75615: {
 75697:     if (unknown())
 75615:         return true;
 75615: 
 77353:     if (type.isUnknown()) {
 75718:         return false;
 77353:     } else if (type.isPrimitive()) {
 77361:         return !!(flags & PrimitiveTypeFlag(type.primitive()));
 77353:     } else if (type.isAnyObject()) {
 77361:         return !!(flags & TYPE_FLAG_ANYOBJECT);
 75641:     } else {
 77361:         return !!(flags & TYPE_FLAG_ANYOBJECT) ||
 77353:             HashSetLookup<TypeObjectKey*,TypeObjectKey,TypeObjectKey>
 77361:             (objectSet, baseObjectCount(), type.objectKey()) != NULL;
 75615:     }
 75615: }
 75615: 
 75615: inline void
 84755: TypeSet::setBaseObjectCount(uint32_t count)
 77361: {
 77361:     JS_ASSERT(count <= TYPE_FLAG_OBJECT_COUNT_LIMIT);
 77361:     flags = (flags & ~TYPE_FLAG_OBJECT_COUNT_MASK)
 77361:           | (count << TYPE_FLAG_OBJECT_COUNT_SHIFT);
 77361: }
 77361: 
 77361: inline void
 77353: TypeSet::clearObjects()
 75761: {
 77361:     setBaseObjectCount(0);
 75761:     objectSet = NULL;
 75761: }
 75761: 
 75761: inline void
 77353: TypeSet::addType(JSContext *cx, Type type)
 75615: {
 75987:     JS_ASSERT(cx->compartment->activeInference);
 75615: 
 75697:     if (unknown())
 75615:         return;
 75615: 
 77353:     if (type.isUnknown()) {
 80557:         flags |= TYPE_FLAG_BASE_MASK;
 77353:         clearObjects();
 80557:         JS_ASSERT(unknown());
 77353:     } else if (type.isPrimitive()) {
 77353:         TypeFlags flag = PrimitiveTypeFlag(type.primitive());
 77361:         if (flags & flag)
 75615:             return;
 75615: 
 75615:         /* If we add float to a type set it is also considered to contain int. */
 75615:         if (flag == TYPE_FLAG_DOUBLE)
 75615:             flag |= TYPE_FLAG_INT32;
 75615: 
 77361:         flags |= flag;
 75615:     } else {
 77361:         if (flags & TYPE_FLAG_ANYOBJECT)
 77353:             return;
 77353:         if (type.isAnyObject())
 77353:             goto unknownObject;
109045: 
109045:         LifoAlloc &alloc =
109045:             purged() ? cx->compartment->analysisLifoAlloc : cx->compartment->typeLifoAlloc;
109045: 
 84755:         uint32_t objectCount = baseObjectCount();
 77353:         TypeObjectKey *object = type.objectKey();
 77353:         TypeObjectKey **pentry = HashSetInsert<TypeObjectKey *,TypeObjectKey,TypeObjectKey>
109045:                                      (alloc, objectSet, objectCount, object);
 77439:         if (!pentry) {
 77439:             cx->compartment->types.setPendingNukeTypes(cx);
 77439:             return;
 77439:         }
 77439:         if (*pentry)
 75615:             return;
 75720:         *pentry = object;
 75761: 
 77396:         setBaseObjectCount(objectCount);
 77396: 
 77396:         if (objectCount == TYPE_FLAG_OBJECT_COUNT_LIMIT)
 77361:             goto unknownObject;
 77361: 
 77353:         if (type.isTypeObject()) {
 77353:             TypeObject *nobject = type.typeObject();
 77353:             JS_ASSERT(!nobject->singleton);
 77353:             if (nobject->unknownProperties())
 77353:                 goto unknownObject;
 76176:             if (objectCount > 1) {
 77353:                 nobject->contribution += (objectCount - 1) * (objectCount - 1);
 77353:                 if (nobject->contribution >= TypeObject::CONTRIBUTION_LIMIT) {
 76182:                     InferSpew(ISpewOps, "limitUnknown: %sT%p%s",
 76182:                               InferSpewColor(this), this, InferSpewColorReset());
 77353:                     goto unknownObject;
 75761:                 }
 75615:             }
 76176:         }
 77353:     }
 77353: 
 77353:     if (false) {
 77353:     unknownObject:
 77353:         type = Type::AnyObjectType();
 77361:         flags |= TYPE_FLAG_ANYOBJECT;
 77353:         clearObjects();
 77353:     }
 75615: 
 76182:     InferSpew(ISpewOps, "addType: %sT%p%s %s",
 76182:               InferSpewColor(this), this, InferSpewColorReset(),
 76182:               TypeString(type));
 75812: 
 75615:     /* Propagate the type to all constraints. */
 75615:     TypeConstraint *constraint = constraintList;
 75615:     while (constraint) {
 75615:         cx->compartment->types.addPending(cx, constraint, this, type);
 75615:         constraint = constraint->next;
 75615:     }
 75615: 
 75615:     cx->compartment->types.resolvePending(cx);
 75615: }
 75615: 
 75944: inline void
 75944: TypeSet::setOwnProperty(JSContext *cx, bool configured)
 75944: {
 75944:     TypeFlags nflags = TYPE_FLAG_OWN_PROPERTY | (configured ? TYPE_FLAG_CONFIGURED_PROPERTY : 0);
 75944: 
 77361:     if ((flags & nflags) == nflags)
 75944:         return;
 75944: 
 77361:     flags |= nflags;
 75944: 
 75944:     /* Propagate the change to all constraints. */
 75944:     TypeConstraint *constraint = constraintList;
 75944:     while (constraint) {
 75944:         constraint->newPropertyState(cx, this);
 75944:         constraint = constraint->next;
 75944:     }
 75944: }
 75944: 
 75919: inline unsigned
 75919: TypeSet::getObjectCount()
 75919: {
 77353:     JS_ASSERT(!unknownObject());
 84755:     uint32_t count = baseObjectCount();
 77361:     if (count > SET_ARRAY_SIZE)
 77361:         return HashSetCapacity(count);
 77361:     return count;
 75919: }
 75919: 
 77353: inline TypeObjectKey *
 75919: TypeSet::getObject(unsigned i)
 75919: {
 77353:     JS_ASSERT(i < getObjectCount());
 77361:     if (baseObjectCount() == 1) {
 75919:         JS_ASSERT(i == 0);
 77353:         return (TypeObjectKey *) objectSet;
 75919:     }
 75919:     return objectSet[i];
 75919: }
 75919: 
114328: inline RawObject
 77353: TypeSet::getSingleObject(unsigned i)
 77353: {
 77353:     TypeObjectKey *key = getObject(i);
 86976:     return (uintptr_t(key) & 1) ? (JSObject *)(uintptr_t(key) ^ 1) : NULL;
 77353: }
 77353: 
 76059: inline TypeObject *
 77353: TypeSet::getTypeObject(unsigned i)
 76059: {
 77353:     TypeObjectKey *key = getObject(i);
 86976:     return (key && !(uintptr_t(key) & 1)) ? (TypeObject *) key : NULL;
 76059: }
 76059: 
 75615: /////////////////////////////////////////////////////////////////////
 75615: // TypeCallsite
 75615: /////////////////////////////////////////////////////////////////////
 75615: 
 75615: inline
 76103: TypeCallsite::TypeCallsite(JSContext *cx, JSScript *script, jsbytecode *pc,
 75708:                            bool isNew, unsigned argumentCount)
 75708:     : script(script), pc(pc), isNew(isNew), argumentCount(argumentCount),
 76103:       thisTypes(NULL), returnTypes(NULL)
 75615: {
 75720:     /* Caller must check for failure. */
109045:     argumentTypes = cx->analysisLifoAlloc().newArray<StackTypeSet*>(argumentCount);
 75615: }
 75615: 
 75615: /////////////////////////////////////////////////////////////////////
 75641: // TypeObject
 75615: /////////////////////////////////////////////////////////////////////
 75615: 
115021: inline TypeObject::TypeObject(TaggedProto proto, bool function, bool unknown)
 76179: {
 77353:     PodZero(this);
 77353: 
 89336:     /* Inner objects may not appear on prototype chains. */
115021:     JS_ASSERT_IF(proto.isObject(), !proto.toObject()->getClass()->ext.outerObject);
 89336: 
115021:     this->proto = proto.raw();
 77884: 
 77361:     if (function)
 77361:         flags |= OBJECT_FLAG_FUNCTION;
 77361:     if (unknown)
 77361:         flags |= OBJECT_FLAG_UNKNOWN_MASK;
 77353: 
 77461:     InferSpew(ISpewOps, "newObject: %s", TypeObjectString(this));
 76179: }
 76179: 
 84755: inline uint32_t
 77361: TypeObject::basePropertyCount() const
 77361: {
 77361:     return (flags & OBJECT_FLAG_PROPERTY_COUNT_MASK) >> OBJECT_FLAG_PROPERTY_COUNT_SHIFT;
 77361: }
 77361: 
 77361: inline void
 84755: TypeObject::setBasePropertyCount(uint32_t count)
 77361: {
 77361:     JS_ASSERT(count <= OBJECT_FLAG_PROPERTY_COUNT_LIMIT);
 77361:     flags = (flags & ~OBJECT_FLAG_PROPERTY_COUNT_MASK)
 77361:           | (count << OBJECT_FLAG_PROPERTY_COUNT_SHIFT);
 77361: }
 77361: 
109045: inline HeapTypeSet *
109135: TypeObject::getProperty(JSContext *cx, jsid id, bool own)
 75615: {
 75987:     JS_ASSERT(cx->compartment->activeInference);
 75679:     JS_ASSERT(JSID_IS_VOID(id) || JSID_IS_EMPTY(id) || JSID_IS_STRING(id));
 76103:     JS_ASSERT_IF(!JSID_IS_EMPTY(id), id == MakeTypeId(cx, id));
 75919:     JS_ASSERT(!unknownProperties());
 75615: 
 84755:     uint32_t propertyCount = basePropertyCount();
 75720:     Property **pprop = HashSetInsert<jsid,Property,Property>
109045:                            (cx->compartment->typeLifoAlloc, propertySet, propertyCount, id);
 77439:     if (!pprop) {
 77439:         cx->compartment->types.setPendingNukeTypes(cx);
 75720:         return NULL;
 77439:     }
 75641: 
 77361:     if (!*pprop) {
 77396:         setBasePropertyCount(propertyCount);
 97682:         if (!addProperty(cx, id, pprop)) {
 97682:             setBasePropertyCount(0);
 97682:             propertySet = NULL;
 77396:             return NULL;
 97682:         }
 77396:         if (propertyCount == OBJECT_FLAG_PROPERTY_COUNT_LIMIT) {
 77361:             markUnknown(cx);
109045: 
109045:             /*
109045:              * Return an arbitrary property in the object, as all have unknown
109045:              * type and are treated as configured.
109045:              */
109045:             unsigned count = getPropertyCount();
109045:             for (unsigned i = 0; i < count; i++) {
109045:                 if (Property *prop = getProperty(i))
109045:                     return &prop->types;
 75615:             }
 75615: 
109045:             JS_NOT_REACHED("Missing property");
109045:             return NULL;
109045:         }
109045:     }
 77361: 
109045:     HeapTypeSet *types = &(*pprop)->types;
109135:     if (own)
 77361:         types->setOwnProperty(cx, false);
 77361: 
 77361:     return types;
 77361: }
 77361: 
109045: inline HeapTypeSet *
 77361: TypeObject::maybeGetProperty(JSContext *cx, jsid id)
 77353: {
 77361:     JS_ASSERT(JSID_IS_VOID(id) || JSID_IS_EMPTY(id) || JSID_IS_STRING(id));
 77361:     JS_ASSERT_IF(!JSID_IS_EMPTY(id), id == MakeTypeId(cx, id));
 77353:     JS_ASSERT(!unknownProperties());
 77353: 
 77361:     Property *prop = HashSetLookup<jsid,Property,Property>
 77361:         (propertySet, basePropertyCount(), id);
 77361: 
 77361:     return prop ? &prop->types : NULL;
 77353: }
 77353: 
 75919: inline unsigned
 75919: TypeObject::getPropertyCount()
 75919: {
 84755:     uint32_t count = basePropertyCount();
 77361:     if (count > SET_ARRAY_SIZE)
 77361:         return HashSetCapacity(count);
 77361:     return count;
 75919: }
 75919: 
 75919: inline Property *
 75919: TypeObject::getProperty(unsigned i)
 75919: {
 77361:     JS_ASSERT(i < getPropertyCount());
 77361:     if (basePropertyCount() == 1) {
 75919:         JS_ASSERT(i == 0);
 75919:         return (Property *) propertySet;
 75919:     }
 75919:     return propertySet[i];
 75919: }
 75919: 
 76179: inline void
 76179: TypeObject::setFlagsFromKey(JSContext *cx, JSProtoKey key)
 76179: {
 76179:     TypeObjectFlags flags = 0;
 75641: 
 76179:     switch (key) {
 76179:       case JSProto_Array:
104429:         flags = OBJECT_FLAG_NON_TYPED_ARRAY
104429:               | OBJECT_FLAG_NON_DOM;
 76179:         break;
 76179: 
103065:       case JSProto_Int8Array:
103065:       case JSProto_Uint8Array:
103065:       case JSProto_Int16Array:
103065:       case JSProto_Uint16Array:
103065:       case JSProto_Int32Array:
103065:       case JSProto_Uint32Array:
103065:       case JSProto_Float32Array:
103065:       case JSProto_Float64Array:
103065:       case JSProto_Uint8ClampedArray:
 76179:         flags = OBJECT_FLAG_NON_DENSE_ARRAY
104429:               | OBJECT_FLAG_NON_PACKED_ARRAY
104429:               | OBJECT_FLAG_NON_DOM;
 76179:         break;
103065: 
103065:       default:
103065:         flags = OBJECT_FLAG_NON_DENSE_ARRAY
103065:               | OBJECT_FLAG_NON_PACKED_ARRAY
104429:               | OBJECT_FLAG_NON_TYPED_ARRAY
104429:               | OBJECT_FLAG_NON_DOM;
103065:         break;
 75679:     }
 75679: 
 76179:     if (!hasAllFlags(flags))
 76179:         setFlags(cx, flags);
 75679: }
 75679: 
 82129: inline void
 82129: TypeObject::writeBarrierPre(TypeObject *type)
 82129: {
 82129: #ifdef JSGC_INCREMENTAL
 83302:     if (!type)
 82129:         return;
 82129: 
 82129:     JSCompartment *comp = type->compartment();
 91557:     if (comp->needsBarrier()) {
 91557:         TypeObject *tmp = type;
 91557:         MarkTypeObjectUnbarriered(comp->barrierTracer(), &tmp, "write barrier");
 91557:         JS_ASSERT(tmp == type);
 91557:     }
 82129: #endif
 82129: }
 82129: 
 82129: inline void
 82129: TypeObject::writeBarrierPost(TypeObject *type, void *addr)
 82129: {
 82129: }
 82129: 
 82129: inline void
 83302: TypeObject::readBarrier(TypeObject *type)
 83302: {
 83302: #ifdef JSGC_INCREMENTAL
 83302:     JSCompartment *comp = type->compartment();
 91557:     if (comp->needsBarrier()) {
 91557:         TypeObject *tmp = type;
 91557:         MarkTypeObjectUnbarriered(comp->barrierTracer(), &tmp, "read barrier");
 91557:         JS_ASSERT(tmp == type);
 91557:     }
 83302: #endif
 83302: }
 83302: 
 83302: inline void
 82129: TypeNewScript::writeBarrierPre(TypeNewScript *newScript)
 82129: {
 82129: #ifdef JSGC_INCREMENTAL
 82129:     if (!newScript)
 82129:         return;
 82129: 
 82129:     JSCompartment *comp = newScript->fun->compartment();
 82129:     if (comp->needsBarrier()) {
 91557:         MarkObject(comp->barrierTracer(), &newScript->fun, "write barrier");
 90409:         MarkShape(comp->barrierTracer(), &newScript->shape, "write barrier");
 82129:     }
 82129: #endif
 82129: }
 82129: 
 82129: inline void
 82129: TypeNewScript::writeBarrierPost(TypeNewScript *newScript, void *addr)
 82129: {
 82129: }
 82129: 
 82129: inline
 82129: Property::Property(jsid id)
 82129:   : id(id)
 82129: {
 82129: }
 82129: 
 82129: inline
 82129: Property::Property(const Property &o)
 82129:   : id(o.id.get()), types(o.types)
 82129: {
 82129: }
 82129: 
 75679: } } /* namespace js::types */
 75679: 
 76158: inline bool
 83256: JSScript::ensureHasTypes(JSContext *cx)
 77391: {
 83256:     return types || makeTypes(cx);
 77391: }
 77391: 
 77391: inline bool
104376: JSScript::ensureRanAnalysis(JSContext *cx)
 77391: {
102717:     js::analyze::AutoEnterAnalysis aea(cx->compartment);
107154:     js::RootedScript self(cx, this);
 86437: 
 86437:     if (!self->ensureHasTypes(cx))
 77391:         return false;
 86437:     if (!self->hasAnalysis() && !self->makeAnalysis(cx))
 77884:         return false;
 86437:     JS_ASSERT(self->analysis()->ranBytecode());
 77391:     return true;
 76158: }
 76158: 
 76158: inline bool
 76158: JSScript::ensureRanInference(JSContext *cx)
 76158: {
115032:     js::RootedScript self(cx, this);
104376:     if (!ensureRanAnalysis(cx))
 77391:         return false;
103320:     if (!self->analysis()->ranInference()) {
 76158:         js::types::AutoEnterTypeInference enter(cx);
103320:         self->analysis()->analyzeTypes(cx);
 76158:     }
103320:     return !self->analysis()->OOM() &&
 80501:         !cx->compartment->types.pendingNukeTypes;
 77391: }
 77391: 
 77391: inline bool
 77391: JSScript::hasAnalysis()
 77391: {
 77391:     return types && types->analysis;
 77391: }
 77391: 
 77391: inline js::analyze::ScriptAnalysis *
 77391: JSScript::analysis()
 77391: {
 77391:     JS_ASSERT(hasAnalysis());
 77391:     return types->analysis;
 76158: }
 76158: 
 75987: inline void
 77884: JSScript::clearAnalysis()
 77884: {
 77884:     if (types)
 77884:         types->analysis = NULL;
 77884: }
 77884: 
 77884: inline void
109045: JSScript::clearPropertyReadTypes()
109045: {
109045:     if (types && types->propertyReadTypes)
109045:         types->propertyReadTypes = NULL;
109045: }
109045: 
109045: inline void
 84755: js::analyze::ScriptAnalysis::addPushedType(JSContext *cx, uint32_t offset, uint32_t which,
 77353:                                            js::types::Type type)
 75987: {
 75987:     js::types::TypeSet *pushed = pushedTypes(offset, which);
 75987:     pushed->addType(cx, type);
 75987: }
 75987: 
115032: namespace js {
103405: 
103405: template <>
115032: struct RootMethods<const types::Type>
103405: {
115032:     static types::Type initial() { return types::Type::UnknownType(); }
103405:     static ThingRootKind kind() { return THING_ROOT_TYPE; }
115032:     static bool poisoned(const types::Type &v) {
103405:         return (v.isTypeObject() && IsPoisonedPtr(v.typeObject()))
103405:             || (v.isSingleObject() && IsPoisonedPtr(v.singleObject()));
103405:     }
103405: };
103405: 
103405: template <>
115032: struct RootMethods<types::Type>
103405: {
115032:     static types::Type initial() { return types::Type::UnknownType(); }
103405:     static ThingRootKind kind() { return THING_ROOT_TYPE; }
115032:     static bool poisoned(const types::Type &v) {
103405:         return (v.isTypeObject() && IsPoisonedPtr(v.typeObject()))
103405:             || (v.isSingleObject() && IsPoisonedPtr(v.singleObject()));
103405:     }
103405: };
103405: 
115032: } // namespace js
115032: 
115032: namespace JS {
115032: template<> class AnchorPermitted<js::types::TypeObject *> { };
103405: }  // namespace JS
103405: 
 75615: #endif // jsinferinlines_h___
