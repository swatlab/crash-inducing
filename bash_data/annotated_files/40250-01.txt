33564: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
33564:  * vim: set ts=4 sw=4 et tw=99 ft=cpp:
33564:  *
33564:  * ***** BEGIN LICENSE BLOCK *****
33564:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
33564:  *
33564:  * The contents of this file are subject to the Mozilla Public License Version
33564:  * 1.1 (the "License"); you may not use this file except in compliance with
33564:  * the License. You may obtain a copy of the License at
33564:  * http://www.mozilla.org/MPL/
33564:  *
33564:  * Software distributed under the License is distributed on an "AS IS" basis,
33564:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
33564:  * for the specific language governing rights and limitations under the
33564:  * License.
33564:  *
33564:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
33564:  * June 12, 2009.
33564:  *
33564:  * The Initial Developer of the Original Code is
33564:  *   the Mozilla Corporation.
33564:  *
33564:  * Contributor(s):
33564:  *   David Anderson <danderson@mozilla.com>
33564:  *   Andreas Gal <gal@mozilla.com>
33564:  *
33564:  * Alternatively, the contents of this file may be used under the terms of
33564:  * either of the GNU General Public License Version 2 or later (the "GPL"),
33564:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
33564:  * in which case the provisions of the GPL or the LGPL are applicable instead
33564:  * of those above. If you wish to allow use of your version of this file only
33564:  * under the terms of either the GPL or the LGPL, and not to allow others to
33564:  * use your version of this file under the terms of the MPL, indicate your
33564:  * decision by deleting the provisions above and replace them with the notice
33564:  * and other provisions required by the GPL or the LGPL. If you do not delete
33564:  * the provisions above, a recipient may use your version of this file under
33564:  * the terms of any one of the MPL, the GPL or the LGPL.
33564:  *
33564:  * ***** END LICENSE BLOCK ***** */
33564: 
33564: class RecursiveSlotMap : public SlotMap
33564: {
34319:   protected:
34319:     unsigned downPostSlots;
34319:     LIns *rval_ins;
34319: 
33564:   public:
34319:     RecursiveSlotMap(TraceRecorder& rec, unsigned downPostSlots, LIns* rval_ins)
34319:       : SlotMap(rec), downPostSlots(downPostSlots), rval_ins(rval_ins)
33564:     {
33564:     }
33564: 
33564:     JS_REQUIRES_STACK void
33564:     adjustTypes()
33564:     {
34319:         /* Check if the return value should be promoted. */
34319:         if (slots[downPostSlots].lastCheck == TypeCheck_Demote)
34319:             rval_ins = mRecorder.lir->ins1(LIR_i2f, rval_ins);
34319:         /* Adjust any global variables. */
34319:         for (unsigned i = downPostSlots + 1; i < slots.length(); i++)
34319:             adjustType(slots[i]);
34319:     }
34319: 
34319:     JS_REQUIRES_STACK void
34319:     adjustTail(TypeConsensus consensus)
34319:     {
34319:         /*
34319:          * exit->sp_adj = ((downPostSlots + 1) * sizeof(double)) - nativeStackBase
34319:          *
34319:          * Store at exit->sp_adj - sizeof(double)
34319:          */
34319:         ptrdiff_t retOffset = downPostSlots * sizeof(double) -
36361:                               mRecorder.tree->nativeStackBase;
34319:         mRecorder.lir->insStorei(mRecorder.addName(rval_ins, "rval_ins"),
34319:                                  mRecorder.lirbuf->sp, retOffset);
34319:     }
34319: };
34319: 
34319: class UpRecursiveSlotMap : public RecursiveSlotMap
34319: {
34319:   public:
34319:     UpRecursiveSlotMap(TraceRecorder& rec, unsigned downPostSlots, LIns* rval_ins)
34319:       : RecursiveSlotMap(rec, downPostSlots, rval_ins)
34319:     {
34319:     }
34319: 
34319:     JS_REQUIRES_STACK void
34319:     adjustTail(TypeConsensus consensus)
34319:     {
34319:         LirBuffer* lirbuf = mRecorder.lirbuf;
34319:         LirWriter* lir = mRecorder.lir;
34319: 
34319:         /*
34319:          * The native stack offset of the return value once this frame has
34319:          * returned, is:
36361:          *      -tree->nativeStackBase + downPostSlots * sizeof(double)
34319:          *
34319:          * Note, not +1, since the offset is 0-based.
34319:          *
34319:          * This needs to be adjusted down one frame. The amount to adjust must
34319:          * be the amount down recursion added, which was just guarded as
34319:          * |downPostSlots|. So the offset is:
34319:          *
36361:          *      -tree->nativeStackBase + downPostSlots * sizeof(double) -
34319:          *                                   downPostSlots * sizeof(double)
34319:          * Or:
36361:          *      -tree->nativeStackBase
34319:          *
34319:          * This makes sense because this slot is just above the highest sp for
34319:          * the down frame.
34319:          */
36361:         lir->insStorei(rval_ins, lirbuf->sp, -mRecorder.tree->nativeStackBase);
34319: 
34319:         lirbuf->sp = lir->ins2(LIR_piadd, lirbuf->sp,
34319:                                lir->insImmWord(-int(downPostSlots) * sizeof(double)));
34319:         lir->insStorei(lirbuf->sp, lirbuf->state, offsetof(InterpState, sp));
34319:         lirbuf->rp = lir->ins2(LIR_piadd, lirbuf->rp,
34319:                                lir->insImmWord(-int(sizeof(FrameInfo*))));
34319:         lir->insStorei(lirbuf->rp, lirbuf->state, offsetof(InterpState, rp));
33564:     }
33564: };
33564: 
33564: #if defined DEBUG
40237: static JS_REQUIRES_STACK void
40237: AssertDownFrameIsConsistent(JSContext* cx, VMSideExit* anchor, FrameInfo* fi)
33564: {
33564:     JS_ASSERT(anchor->recursive_down);
33564:     JS_ASSERT(anchor->recursive_down->callerHeight == fi->callerHeight);
33564: 
33564:     unsigned downPostSlots = fi->callerHeight;
37741:     TraceType* typeMap = fi->get_typemap();
33564: 
37741:     CaptureStackTypes(cx, 1, typeMap);
37741:     const TraceType* m1 = anchor->recursive_down->get_typemap();
33564:     for (unsigned i = 0; i < downPostSlots; i++) {
33564:         if (m1[i] == typeMap[i])
33564:             continue;
33755:         if ((typeMap[i] == TT_INT32 && m1[i] == TT_DOUBLE) ||
33755:             (typeMap[i] == TT_DOUBLE && m1[i] == TT_INT32)) {
33564:             continue;
33742:         }
33564:         JS_NOT_REACHED("invalid RECURSIVE_MISMATCH exit");
33564:     }
33564:     JS_ASSERT(memcmp(anchor->recursive_down, fi, sizeof(FrameInfo)) == 0);
33564: }
33564: #endif
33564: 
33564: JS_REQUIRES_STACK VMSideExit*
33564: TraceRecorder::downSnapshot(FrameInfo* downFrame)
33564: {
33564:     JS_ASSERT(!pendingSpecializedNative);
33564: 
33564:     /* Build the typemap the exit will have. Note extra stack slot for return value. */
33564:     unsigned downPostSlots = downFrame->callerHeight;
36361:     unsigned ngslots = tree->globalSlots->length();
33564:     unsigned exitTypeMapLen = downPostSlots + 1 + ngslots;
37741:     TraceType* exitTypeMap = (TraceType*)alloca(sizeof(TraceType) * exitTypeMapLen);
37741:     TraceType* typeMap = downFrame->get_typemap();
39939: 
39939: 
39939:     /* Add stack slots. */
33564:     for (unsigned i = 0; i < downPostSlots; i++)
33564:         exitTypeMap[i] = typeMap[i];
39939: 
39939:     /* Add the return type. */
39939:     JS_ASSERT_IF(*cx->fp->regs->pc != JSOP_RETURN, *cx->fp->regs->pc == JSOP_STOP);
39939:     if (*cx->fp->regs->pc == JSOP_RETURN)
33564:         exitTypeMap[downPostSlots] = determineSlotType(&stackval(-1));
39939:     else
39939:         exitTypeMap[downPostSlots] = TT_PSEUDOBOOLEAN;
39939: 
39939:     /* Add global types. */
33564:     determineGlobalTypes(&exitTypeMap[downPostSlots + 1]);
33564: 
33564:     VMSideExit* exit = (VMSideExit*)
37741:         traceMonitor->traceAlloc->alloc(sizeof(VMSideExit) + sizeof(TraceType) * exitTypeMapLen);
33564: 
40229:     PodZero(exit);
33564:     exit->from = fragment;
33564:     exit->calldepth = 0;
34351:     JS_ASSERT(unsigned(exit->calldepth) == callDepth);
33564:     exit->numGlobalSlots = ngslots;
33564:     exit->numStackSlots = downPostSlots + 1;
33564:     exit->numStackSlotsBelowCurrentFrame = cx->fp->down->argv ?
33564:         nativeStackOffset(&cx->fp->argv[-2]) / sizeof(double) : 0;
33564:     exit->exitType = UNSTABLE_LOOP_EXIT;
33564:     exit->block = cx->fp->down->blockChain;
33564:     exit->pc = downFrame->pc + JSOP_CALL_LENGTH;
33564:     exit->imacpc = NULL;
36361:     exit->sp_adj = ((downPostSlots + 1) * sizeof(double)) - tree->nativeStackBase;
33564:     exit->rp_adj = exit->calldepth * sizeof(FrameInfo*);
33564:     exit->nativeCalleeWord = 0;
33564:     exit->lookupFlags = js_InferFlags(cx, 0);
37741:     memcpy(exit->fullTypeMap(), exitTypeMap, sizeof(TraceType) * exitTypeMapLen);
33564: #if defined JS_JIT_SPEW
33564:     TreevisLogExit(cx, exit);
33564: #endif
33564:     return exit;
33564: }
33564: 
33564: JS_REQUIRES_STACK AbortableRecordingStatus
33564: TraceRecorder::upRecursion()
33564: {
33564:     JS_ASSERT((JSOp)*cx->fp->down->regs->pc == JSOP_CALL);
33564:     JS_ASSERT(js_CodeSpec[js_GetOpcode(cx, cx->fp->down->script,
33564:               cx->fp->down->regs->pc)].length == JSOP_CALL_LENGTH);
33564: 
33564:     JS_ASSERT(callDepth == 0);
33564: 
33564:     /*
33564:      * If some operation involving interpreter frame slurping failed, go to
33564:      * that code right away, and don't bother with emitting the up-recursive
33564:      * guards again.
33564:      */
33564:     if (anchor && (anchor->exitType == RECURSIVE_EMPTY_RP_EXIT ||
33564:         anchor->exitType == RECURSIVE_SLURP_MISMATCH_EXIT ||
33564:         anchor->exitType == RECURSIVE_SLURP_FAIL_EXIT)) {
35083:         return slurpDownFrames(cx->fp->down->regs->pc);
33564:     }
33564: 
33564:     jsbytecode* return_pc = cx->fp->down->regs->pc;
33564:     jsbytecode* recursive_pc = return_pc + JSOP_CALL_LENGTH;
33564: 
33564:     /*
33564:      * It is possible that the down frame isn't the same at runtime. It's not
33564:      * enough to guard on the PC, since the typemap could be different as well.
33564:      * To deal with this, guard that the FrameInfo on the callstack is 100%
33564:      * identical.
33564:      *
33564:      * Note that though the counted slots is called "downPostSlots", this is
33564:      * the number of slots after the CALL instruction has theoretically popped
33564:      * callee/this/argv, but before the return value is pushed. This is
33564:      * intended since the FrameInfo pushed by down recursion would not have
33564:      * the return value yet. Instead, when closing the loop, the return value
33564:      * becomes the sole stack type that deduces type stability.
33564:      */
33564:     unsigned totalSlots = NativeStackSlots(cx, 1);
33564:     unsigned downPostSlots = totalSlots - NativeStackSlots(cx, 0);
37741:     FrameInfo* fi = (FrameInfo*)alloca(sizeof(FrameInfo) + totalSlots * sizeof(TraceType));
38642:     fi->block = NULL;
33564:     fi->pc = (jsbytecode*)return_pc;
33564:     fi->imacpc = NULL;
33564: 
33564:     /*
33564:      * Need to compute this from the down frame, since the stack could have
33564:      * moved on this one.
33564:      */
33564:     fi->spdist = cx->fp->down->regs->sp - cx->fp->down->slots;
33564:     JS_ASSERT(cx->fp->argc == cx->fp->down->argc);
39928:     fi->set_argc(uint16(cx->fp->argc), false);
33564:     fi->callerHeight = downPostSlots;
33564:     fi->callerArgc = cx->fp->down->argc;
33564: 
33564:     if (anchor && anchor->exitType == RECURSIVE_MISMATCH_EXIT) {
33564:         /*
33564:          * Case 0: Anchoring off a RECURSIVE_MISMATCH guard. Guard on this FrameInfo.
33564:          * This is always safe because this point is only reached on simple "call myself"
33564:          * recursive functions.
33564:          */
33564: #if defined DEBUG
33564:         AssertDownFrameIsConsistent(cx, anchor, fi);
33564: #endif
33564:         fi = anchor->recursive_down;
33564:     } else if (recursive_pc != fragment->root->ip) {
33564:         /*
33564:          * Case 1: Guess that down-recursion has to started back out, infer types
33564:          * from the down frame.
33564:          */
37741:         CaptureStackTypes(cx, 1, fi->get_typemap());
33564:     } else {
36361:         /* Case 2: Guess that up-recursion is backing out, infer types from our Tree. */
36361:         JS_ASSERT(tree->nStackTypes == downPostSlots + 1);
37741:         TraceType* typeMap = fi->get_typemap();
33564:         for (unsigned i = 0; i < downPostSlots; i++)
36361:             typeMap[i] = tree->typeMap[i];
33564:     }
33564: 
33564:     fi = traceMonitor->frameCache->memoize(fi);
33564: 
33564:     /*
33564:      * Guard that there are more recursive frames. If coming from an anchor
33564:      * where this was already computed, don't bother doing it again.
33564:      */
33564:     if (!anchor || anchor->exitType != RECURSIVE_MISMATCH_EXIT) {
33564:         VMSideExit* exit = snapshot(RECURSIVE_EMPTY_RP_EXIT);
33564: 
33564:         /* Guard that rp >= sr + 1 */
33564:         guard(true,
33564:               lir->ins2(LIR_pge, lirbuf->rp,
33564:                         lir->ins2(LIR_piadd,
33564:                                   lir->insLoad(LIR_ldp, lirbuf->state,
33564:                                                offsetof(InterpState, sor)),
33564:                                   INS_CONSTWORD(sizeof(FrameInfo*)))),
33564:               exit);
33564:     }
33564: 
33567:     debug_only_printf(LC_TMRecorder, "guardUpRecursive fragment->root=%p fi=%p\n", (void*)fragment->root, (void*)fi);
33564: 
33564:     /* Guard that the FrameInfo above is the same FrameInfo pointer. */
33564:     VMSideExit* exit = snapshot(RECURSIVE_MISMATCH_EXIT);
33564:     LIns* prev_rp = lir->insLoad(LIR_ldp, lirbuf->rp, -int32_t(sizeof(FrameInfo*)));
33564:     guard(true, lir->ins2(LIR_peq, prev_rp, INS_CONSTPTR(fi)), exit);
33564: 
33564:     /*
33564:      * Now it's time to try and close the loop. Get a special exit that points
33564:      * at the down frame, after the return has been propagated up.
33564:      */
33564:     exit = downSnapshot(fi);
33564: 
39939:     LIns* rval_ins;
39939:     if (*cx->fp->regs->pc == JSOP_RETURN) {
39939:         rval_ins = (!anchor || anchor->exitType != RECURSIVE_SLURP_FAIL_EXIT) ?
34319:                    get(&stackval(-1)) :
34319:                    NULL;
39939:         JS_ASSERT(rval_ins);
39939:     } else {
39939:         rval_ins = INS_CONST(JSVAL_TO_SPECIAL(JSVAL_VOID));
39939:     }
39939: 
37741:     TraceType returnType = exit->stackTypeMap()[downPostSlots];
34319:     if (returnType == TT_INT32) {
39939:         JS_ASSERT(*cx->fp->regs->pc == JSOP_RETURN);
34319:         JS_ASSERT(determineSlotType(&stackval(-1)) == TT_INT32);
34319:         JS_ASSERT(isPromoteInt(rval_ins));
37741:         rval_ins = demote(lir, rval_ins);
34319:     }
33564: 
34319:     UpRecursiveSlotMap slotMap(*this, downPostSlots, rval_ins);
33564:     for (unsigned i = 0; i < downPostSlots; i++)
33564:         slotMap.addSlot(exit->stackType(i));
39939:     if (*cx->fp->regs->pc == JSOP_RETURN)
33564:         slotMap.addSlot(&stackval(-1));
39939:     else
39939:         slotMap.addSlot(TT_PSEUDOBOOLEAN);
36361:     VisitGlobalSlots(slotMap, cx, *tree->globalSlots);
33564:     if (recursive_pc == (jsbytecode*)fragment->root->ip) {
33564:         debug_only_print0(LC_TMTracer, "Compiling up-recursive loop...\n");
33564:     } else {
33564:         debug_only_print0(LC_TMTracer, "Compiling up-recursive branch...\n");
33564:         exit->exitType = RECURSIVE_UNLINKED_EXIT;
33564:         exit->recursive_pc = recursive_pc;
33564:     }
36361:     JS_ASSERT(tree->recursion != Recursion_Disallowed);
36361:     if (tree->recursion != Recursion_Detected)
36361:         tree->recursion = Recursion_Unwinds;
33564:     return closeLoop(slotMap, exit);
33564: }
33564: 
33565: class SlurpInfo
33564: {
33566: public:
33564:     unsigned curSlot;
37741:     TraceType* typeMap;
33564:     VMSideExit* exit;
33564:     unsigned slurpFailSlot;
33564: };
33564: 
33564: JS_REQUIRES_STACK AbortableRecordingStatus
33564: TraceRecorder::slurpDownFrames(jsbytecode* return_pc)
33564: {
33564:     /* Missing - no go */
33564:     if (cx->fp->argc != cx->fp->fun->nargs)
33564:         RETURN_STOP_A("argc != nargs");
33564: 
33564:     LIns* argv_ins;
33564:     unsigned frameDepth;
33564:     unsigned downPostSlots;
33564: 
33564:     JSStackFrame* fp = cx->fp;
33564:     LIns* fp_ins = addName(lir->insLoad(LIR_ldp, cx_ins, offsetof(JSContext, fp)), "fp");
33564: 
33564:     /*
33564:      * When first emitting slurp code, do so against the down frame. After
33564:      * popping the interpreter frame, it is illegal to resume here, as the
33564:      * down frame has been moved up. So all this code should be skipped if
33564:      * anchoring off such an exit.
33564:      */
33564:     if (!anchor || anchor->exitType != RECURSIVE_SLURP_FAIL_EXIT) {
33564:         fp_ins = addName(lir->insLoad(LIR_ldp, fp_ins, offsetof(JSStackFrame, down)), "downFp");
33564:         fp = fp->down;
33564: 
33564:         argv_ins = addName(lir->insLoad(LIR_ldp, fp_ins, offsetof(JSStackFrame, argv)), "argv");
33564: 
33564:         /* If recovering from a SLURP_MISMATCH, all of this is unnecessary. */
33564:         if (!anchor || anchor->exitType != RECURSIVE_SLURP_MISMATCH_EXIT) {
33564:             /* fp->down should not be NULL. */
33564:             guard(false, lir->ins_peq0(fp_ins), RECURSIVE_LOOP_EXIT);
33564: 
33564:             /* fp->down->argv should not be NULL. */
33564:             guard(false, lir->ins_peq0(argv_ins), RECURSIVE_LOOP_EXIT);
33564: 
33564:             /*
33564:              * Guard on the script being the same. This might seem unnecessary,
33564:              * but it lets the recursive loop end cleanly if it doesn't match.
33564:              * With only the pc check, it is harder to differentiate between
33564:              * end-of-recursion and recursion-returns-to-different-pc.
33564:              */
33564:             guard(true,
33564:                   lir->ins2(LIR_peq,
33564:                             addName(lir->insLoad(LIR_ldp,
33564:                                                  fp_ins,
33564:                                                  offsetof(JSStackFrame, script)),
33564:                                     "script"),
33564:                             INS_CONSTPTR(cx->fp->down->script)),
33564:                   RECURSIVE_LOOP_EXIT);
33564:         }
33564: 
33564:         /* fp->down->regs->pc should be == pc. */
33564:         guard(true,
33564:               lir->ins2(LIR_peq,
33564:                         lir->insLoad(LIR_ldp,
33564:                                      addName(lir->insLoad(LIR_ldp, fp_ins, offsetof(JSStackFrame, regs)),
33564:                                              "regs"),
33564:                                      offsetof(JSFrameRegs, pc)),
33564:                         INS_CONSTPTR(return_pc)),
33564:               RECURSIVE_SLURP_MISMATCH_EXIT);
33564: 
33564:         /* fp->down->argc should be == argc. */
33564:         guard(true,
33564:               lir->ins2(LIR_eq,
33564:                         addName(lir->insLoad(LIR_ld, fp_ins, offsetof(JSStackFrame, argc)),
33564:                                 "argc"),
33564:                         INS_CONST(cx->fp->argc)),
33564:               MISMATCH_EXIT);
33564: 
33564:         /* Pop the interpreter frame. */
33564:         LIns* args[] = { lirbuf->state, cx_ins };
33564:         guard(false, lir->ins_eq0(lir->insCall(&js_PopInterpFrame_ci, args)), MISMATCH_EXIT);
33564: 
33564:         /* Compute slots for the down frame. */
33564:         downPostSlots = NativeStackSlots(cx, 1) - NativeStackSlots(cx, 0);
33564:         frameDepth = 1;
33564:     } else {
33564:         /* Note: loading argv from fp, not fp->down. */
33564:         argv_ins = addName(lir->insLoad(LIR_ldp, fp_ins, offsetof(JSStackFrame, argv)), "argv");
33564: 
33564:         /* Slots for this frame, minus the return value. */
33564:         downPostSlots = NativeStackSlots(cx, 0) - 1;
33564:         frameDepth = 0;
33564:     }
33564: 
33564:     /*
33564:      * This is a special exit used as a template for the stack-slurping code.
33564:      * LeaveTree will ignore all but the final slot, which contains the return
33564:      * value. The slurpSlot variable keeps track of the last slot that has been
33564:      * unboxed, as to avoid re-unboxing when taking a SLURP_FAIL exit.
33564:      */
36361:     unsigned numGlobalSlots = tree->globalSlots->length();
33564:     unsigned safeSlots = NativeStackSlots(cx, frameDepth) + 1 + numGlobalSlots;
33564:     jsbytecode* recursive_pc = return_pc + JSOP_CALL_LENGTH;
34347:     VMSideExit* exit = (VMSideExit*)
37741:         traceMonitor->traceAlloc->alloc(sizeof(VMSideExit) + sizeof(TraceType) * safeSlots);
40229:     PodZero(exit);
33564:     exit->pc = (jsbytecode*)recursive_pc;
33564:     exit->from = fragment;
33564:     exit->exitType = RECURSIVE_SLURP_FAIL_EXIT;
33564:     exit->numStackSlots = downPostSlots + 1;
33564:     exit->numGlobalSlots = numGlobalSlots;
36361:     exit->sp_adj = ((downPostSlots + 1) * sizeof(double)) - tree->nativeStackBase;
33564:     exit->recursive_pc = recursive_pc;
33564: 
33564:     /*
33564:      * Build the exit typemap. This may capture extra types, but they are
33564:      * thrown away.
33564:      */
37741:     TraceType* typeMap = exit->stackTypeMap();
33564:     jsbytecode* oldpc = cx->fp->regs->pc;
33564:     cx->fp->regs->pc = exit->pc;
37741:     CaptureStackTypes(cx, frameDepth, typeMap);
33564:     cx->fp->regs->pc = oldpc;
39939:     if (!anchor || anchor->exitType != RECURSIVE_SLURP_FAIL_EXIT) {
39939:         JS_ASSERT_IF(*cx->fp->regs->pc != JSOP_RETURN, *cx->fp->regs->pc == JSOP_STOP);
39939:         if (*cx->fp->regs->pc == JSOP_RETURN)
33564:             typeMap[downPostSlots] = determineSlotType(&stackval(-1));
34332:         else
39939:             typeMap[downPostSlots] = TT_PSEUDOBOOLEAN;
39939:     } else {
34332:         typeMap[downPostSlots] = anchor->stackTypeMap()[anchor->numStackSlots - 1];
39939:     }
33564:     determineGlobalTypes(&typeMap[exit->numStackSlots]);
33564: #if defined JS_JIT_SPEW
33564:     TreevisLogExit(cx, exit);
33564: #endif
33564: 
33564:     /*
34319:      * Return values are tricky because there are two cases. Anchoring off a
34319:      * slurp failure (the second case) means the return value has already been
34319:      * moved. However it can still be promoted to link trees together, so we
34319:      * load it from the new location.
34319:      *
34319:      * In all other cases, the return value lives in the tracker and it can be
34319:      * grabbed safely.
33564:      */
34319:     LIns* rval_ins;
40250:     intptr_t offset = exit->sp_adj - sizeof(double);
37741:     TraceType returnType = exit->stackTypeMap()[downPostSlots];
40250: 
33564:     if (!anchor || anchor->exitType != RECURSIVE_SLURP_FAIL_EXIT) {
34319:         rval_ins = get(&stackval(-1));
34319:         if (returnType == TT_INT32) {
34319:             JS_ASSERT(determineSlotType(&stackval(-1)) == TT_INT32);
34319:             JS_ASSERT(isPromoteInt(rval_ins));
37741:             rval_ins = demote(lir, rval_ins);
34319:         }
34319:         /*
34319:          * The return value must be written out early, before slurping can fail,
34319:          * otherwise it will not be available when there's a type mismatch.
34319:          */
40250:         lir->insStorei(rval_ins, lirbuf->sp, offset);
34319:     } else {
34319:         switch (returnType)
34319:         {
34319:           case TT_PSEUDOBOOLEAN:
34319:           case TT_INT32:
40250:             rval_ins = lir->insLoad(LIR_ld, lirbuf->sp, offset);
34319:             break;
34319:           case TT_DOUBLE:
40250:             rval_ins = lir->insLoad(LIR_ldf, lirbuf->sp, offset);
34319:             break;
34319:           case TT_FUNCTION:
34319:           case TT_OBJECT:
34319:           case TT_STRING:
34319:           case TT_NULL:
40250:             rval_ins = lir->insLoad(LIR_ldp, lirbuf->sp, offset);
34319:             break;
34319:           default:
34319:             JS_NOT_REACHED("unknown type");
34330:             RETURN_STOP_A("unknown type"); 
34319:         }
33564:     }
33564: 
33564:     /* Slurp */
33564:     SlurpInfo info;
33564:     info.curSlot = 0;
33564:     info.exit = exit;
33564:     info.typeMap = typeMap;
33564:     info.slurpFailSlot = (anchor && anchor->exitType == RECURSIVE_SLURP_FAIL_EXIT) ?
33564:                          anchor->slurpFailSlot : 0;
33564: 
33564:     /* callee */
33564:     slurpSlot(lir->insLoad(LIR_ldp, argv_ins, -2 * ptrdiff_t(sizeof(jsval))),
33564:               &fp->argv[-2],
33564:               &info);
33564:     /* this */
33564:     slurpSlot(lir->insLoad(LIR_ldp, argv_ins, -1 * ptrdiff_t(sizeof(jsval))),
33564:               &fp->argv[-1],
33564:               &info);
33564:     /* args[0..n] */
33564:     for (unsigned i = 0; i < JS_MAX(fp->argc, fp->fun->nargs); i++)
33564:         slurpSlot(lir->insLoad(LIR_ldp, argv_ins, i * sizeof(jsval)), &fp->argv[i], &info);
33564:     /* argsobj */
33564:     slurpSlot(addName(lir->insLoad(LIR_ldp, fp_ins, offsetof(JSStackFrame, argsobj)), "argsobj"),
33564:               &fp->argsobj,
33564:               &info);
37694:     /* scopeChain */
37694:     slurpSlot(addName(lir->insLoad(LIR_ldp, fp_ins, offsetof(JSStackFrame, scopeChain)), "scopeChain"),
39911:               &fp->scopeChainVal,
37694:               &info);
33564:     /* vars */
33564:     LIns* slots_ins = addName(lir->insLoad(LIR_ldp, fp_ins, offsetof(JSStackFrame, slots)),
33564:                               "slots");
33564:     for (unsigned i = 0; i < fp->script->nfixed; i++)
33564:         slurpSlot(lir->insLoad(LIR_ldp, slots_ins, i * sizeof(jsval)), &fp->slots[i], &info);
33564:     /* stack vals */
33564:     unsigned nfixed = fp->script->nfixed;
33564:     jsval* stack = StackBase(fp);
33564:     LIns* stack_ins = addName(lir->ins2(LIR_piadd,
33564:                                         slots_ins,
33564:                                         INS_CONSTWORD(nfixed * sizeof(jsval))),
33564:                               "stackBase");
33564:     size_t limit = size_t(fp->regs->sp - StackBase(fp));
33564:     if (anchor && anchor->exitType == RECURSIVE_SLURP_FAIL_EXIT)
33564:         limit--;
33564:     else
33564:         limit -= fp->fun->nargs + 2;
33564:     for (size_t i = 0; i < limit; i++)
33564:         slurpSlot(lir->insLoad(LIR_ldp, stack_ins, i * sizeof(jsval)), &stack[i], &info);
33564: 
33564:     JS_ASSERT(info.curSlot == downPostSlots);
33564: 
33564:     /* Jump back to the start */
33564:     exit = copy(exit);
33564:     exit->exitType = UNSTABLE_LOOP_EXIT;
33564: #if defined JS_JIT_SPEW
33564:     TreevisLogExit(cx, exit);
33564: #endif
33564: 
34319:     RecursiveSlotMap slotMap(*this, downPostSlots, rval_ins);
33564:     for (unsigned i = 0; i < downPostSlots; i++)
33564:         slotMap.addSlot(typeMap[i]);
39939:     if (*cx->fp->regs->pc == JSOP_RETURN)
34332:         slotMap.addSlot(&stackval(-1), typeMap[downPostSlots]);
39939:     else
39939:         slotMap.addSlot(TT_PSEUDOBOOLEAN);
36361:     VisitGlobalSlots(slotMap, cx, *tree->globalSlots);
33564:     debug_only_print0(LC_TMTracer, "Compiling up-recursive slurp...\n");
33564:     exit = copy(exit);
33564:     if (exit->recursive_pc == fragment->root->ip)
33564:         exit->exitType = UNSTABLE_LOOP_EXIT;
33564:     else
33564:         exit->exitType = RECURSIVE_UNLINKED_EXIT;
33567:     debug_only_printf(LC_TMTreeVis, "TREEVIS CHANGEEXIT EXIT=%p TYPE=%s\n", (void*)exit,
33564:                       getExitName(exit->exitType));
36361:     JS_ASSERT(tree->recursion >= Recursion_Unwinds);
33564:     return closeLoop(slotMap, exit);
33564: }
33564: 
36439: class ImportFrameSlotsVisitor : public SlotVisitorBase
36439: {
36439:     TraceRecorder &mRecorder;
36439: public:
36439:     ImportFrameSlotsVisitor(TraceRecorder &recorder) : mRecorder(recorder)
36439:     {}
36439: 
36439:     JS_REQUIRES_STACK JS_ALWAYS_INLINE bool
36439:     visitStackSlots(jsval *vp, size_t count, JSStackFrame* fp) {
36439:         for (size_t i = 0; i < count; ++i)
36439:             mRecorder.get(vp++);
36439:         return true;
36439:     }
36439: };
36439: 
33564: JS_REQUIRES_STACK AbortableRecordingStatus
33564: TraceRecorder::downRecursion()
33564: {
33564:     JSStackFrame* fp = cx->fp;
33564:     if ((jsbytecode*)fragment->ip < fp->script->code ||
33564:         (jsbytecode*)fragment->ip >= fp->script->code + fp->script->length) {
33564:         RETURN_STOP_A("inner recursive call must compile first");
33564:     }
33564: 
33564:     /* Adjust the stack by the budget the down-frame needs. */
33564:     int slots = NativeStackSlots(cx, 1) - NativeStackSlots(cx, 0);
37694:     JS_ASSERT(unsigned(slots) == NativeStackSlots(cx, 1) - fp->argc - 2 - fp->script->nfixed - 2);
33564: 
33564:     /* Guard that there is enough stack space. */
36361:     JS_ASSERT(tree->maxNativeStackSlots >= tree->nativeStackBase / sizeof(double));
36361:     int guardSlots = slots + tree->maxNativeStackSlots -
36361:                      tree->nativeStackBase / sizeof(double);
33564:     LIns* sp_top = lir->ins2(LIR_piadd, lirbuf->sp, lir->insImmWord(guardSlots * sizeof(double)));
33564:     guard(true, lir->ins2(LIR_plt, sp_top, eos_ins), OOM_EXIT);
33564: 
33564:     /* Guard that there is enough call stack space. */
33564:     LIns* rp_top = lir->ins2(LIR_piadd, lirbuf->rp, lir->insImmWord(sizeof(FrameInfo*)));
33564:     guard(true, lir->ins2(LIR_plt, rp_top, eor_ins), OOM_EXIT);
33564: 
36439:     /*
36439:      * For every slot in the new frame that is not in the tracker, create a load
36439:      * in the tracker. This is necessary because otherwise snapshot() will see
36439:      * missing imports and use the down frame, rather than the new frame.
36439:      * This won't affect performance because the loads will be killed if not
36439:      * used.
36439:      */
36439:     ImportFrameSlotsVisitor visitor(*this);
36439:     VisitStackSlots(visitor, cx, callDepth);
36439: 
33564:     /* Add space for a new JIT frame. */
33564:     lirbuf->sp = lir->ins2(LIR_piadd, lirbuf->sp, lir->insImmWord(slots * sizeof(double)));
33564:     lir->insStorei(lirbuf->sp, lirbuf->state, offsetof(InterpState, sp));
33564:     lirbuf->rp = lir->ins2(LIR_piadd, lirbuf->rp, lir->insImmWord(sizeof(FrameInfo*)));
33564:     lir->insStorei(lirbuf->rp, lirbuf->state, offsetof(InterpState, rp));
33564:     --callDepth;
37009:     clearCurrentFrameSlotsFromTracker(nativeFrameTracker);
33564: 
33564:     /*
33564:      * If the callee and caller have identical call sites, this is a down-
33564:      * recursive loop. Otherwise something special happened. For example, a
33564:      * recursive call that is unwinding could nest back down recursively again.
33564:      * In this case, we build a fragment that ideally we'll never invoke
33564:      * directly, but link from a down-recursive branch. The UNLINKED_EXIT tells
33564:      * closeLoop() that the peer trees should match the recursive pc, not the
33564:      * tree pc.
33564:      */
33564:     VMSideExit* exit;
33564:     if ((jsbytecode*)fragment->root->ip == fp->script->code)
33564:         exit = snapshot(UNSTABLE_LOOP_EXIT);
33564:     else
33564:         exit = snapshot(RECURSIVE_UNLINKED_EXIT);
33564:     exit->recursive_pc = fp->script->code;
33564:     debug_only_print0(LC_TMTracer, "Compiling down-recursive function call.\n");
36361:     JS_ASSERT(tree->recursion != Recursion_Disallowed);
36361:     tree->recursion = Recursion_Detected;
33564:     return closeLoop(exit);
33564: }
33564: 
33591: JS_REQUIRES_STACK LIns*
33564: TraceRecorder::slurpInt32Slot(LIns* val_ins, jsval* vp, VMSideExit* exit)
33564: {
33564:     guard(true,
33564:           lir->ins2(LIR_or,
33564:                     lir->ins2(LIR_peq,
33564:                               lir->ins2(LIR_piand, val_ins, INS_CONSTWORD(JSVAL_TAGMASK)),
33564:                               INS_CONSTWORD(JSVAL_DOUBLE)),
33564:                     lir->ins2(LIR_peq,
33564:                               lir->ins2(LIR_piand, val_ins, INS_CONSTWORD(1)),
33564:                               INS_CONSTWORD(1))),
33564:           exit);
33564:     LIns* space = lir->insAlloc(sizeof(int32));
33564:     LIns* args[] = { space, val_ins };
33564:     LIns* result = lir->insCall(&js_TryUnboxInt32_ci, args);
33564:     guard(false, lir->ins_eq0(result), exit);
33564:     LIns* int32_ins = lir->insLoad(LIR_ld, space, 0);
33564:     return int32_ins;
33564: }
33564: 
33591: JS_REQUIRES_STACK LIns*
33564: TraceRecorder::slurpDoubleSlot(LIns* val_ins, jsval* vp, VMSideExit* exit)
33564: {
33564:     guard(true,
33564:           lir->ins2(LIR_or,
33564:                     lir->ins2(LIR_peq,
33564:                               lir->ins2(LIR_piand, val_ins, INS_CONSTWORD(JSVAL_TAGMASK)),
33564:                               INS_CONSTWORD(JSVAL_DOUBLE)),
33564:                     lir->ins2(LIR_peq,
33564:                               lir->ins2(LIR_piand, val_ins, INS_CONSTWORD(1)),
33564:                               INS_CONSTWORD(1))),
33564:           exit);
33564:     LIns* args[] = { val_ins };
33564:     LIns* dbl_ins = lir->insCall(&js_UnboxDouble_ci, args);
33564:     return dbl_ins;
33564: }
33564: 
33591: JS_REQUIRES_STACK LIns*
33564: TraceRecorder::slurpBoolSlot(LIns* val_ins, jsval* vp, VMSideExit* exit)
33564: {
33564:     guard(true,
33614:           lir->ins2(LIR_peq,
33564:                     lir->ins2(LIR_piand, val_ins, INS_CONSTWORD(JSVAL_TAGMASK)),
33564:                     INS_CONSTWORD(JSVAL_SPECIAL)),
33564:           exit);
33614:     LIns* bool_ins = lir->ins2(LIR_pirsh, val_ins, INS_CONST(JSVAL_TAGBITS));
33564:     bool_ins = p2i(bool_ins);
33564:     return bool_ins;
33564: }
33564: 
33591: JS_REQUIRES_STACK LIns*
33564: TraceRecorder::slurpStringSlot(LIns* val_ins, jsval* vp, VMSideExit* exit)
33564: {
33564:     guard(true,
33614:           lir->ins2(LIR_peq,
33564:                     lir->ins2(LIR_piand, val_ins, INS_CONSTWORD(JSVAL_TAGMASK)),
33564:                     INS_CONSTWORD(JSVAL_STRING)),
33564:           exit);
33564:     LIns* str_ins = lir->ins2(LIR_piand, val_ins, INS_CONSTWORD(~JSVAL_TAGMASK));
33564:     return str_ins;
33564: }
33564: 
33591: JS_REQUIRES_STACK LIns*
33564: TraceRecorder::slurpNullSlot(LIns* val_ins, jsval* vp, VMSideExit* exit)
33564: {
33564:     guard(true, lir->ins_peq0(val_ins), exit);
33564:     return val_ins;
33564: }
33564: 
33591: JS_REQUIRES_STACK LIns*
33564: TraceRecorder::slurpObjectSlot(LIns* val_ins, jsval* vp, VMSideExit* exit)
33564: {
33564:     /* Must not be NULL */
33564:     guard(false, lir->ins_peq0(val_ins), exit);
33564: 
33564:     /* Must be an object */
33564:     guard(true,
33564:           lir->ins_peq0(lir->ins2(LIR_piand, val_ins, INS_CONSTWORD(JSVAL_TAGMASK))),
33564:           exit);
33564: 
33564:     /* Must NOT have a function class */
33564:     guard(false,
33564:           lir->ins2(LIR_peq,
33564:                     lir->ins2(LIR_piand,
33564:                               lir->insLoad(LIR_ldp, val_ins, offsetof(JSObject, classword)),
33564:                               INS_CONSTWORD(~JSSLOT_CLASS_MASK_BITS)),
33564:                     INS_CONSTPTR(&js_FunctionClass)),
33564:           exit);
33564:     return val_ins;
33564: }
33564: 
33591: JS_REQUIRES_STACK LIns*
33564: TraceRecorder::slurpFunctionSlot(LIns* val_ins, jsval* vp, VMSideExit* exit)
33564: {
33564:     /* Must not be NULL */
33564:     guard(false, lir->ins_peq0(val_ins), exit);
33564: 
33564:     /* Must be an object */
33564:     guard(true,
33564:           lir->ins_peq0(lir->ins2(LIR_piand, val_ins, INS_CONSTWORD(JSVAL_TAGMASK))),
33564:           exit);
33564: 
33564:     /* Must have a function class */
33564:     guard(true,
33564:           lir->ins2(LIR_peq,
33564:                     lir->ins2(LIR_piand,
33564:                               lir->insLoad(LIR_ldp, val_ins, offsetof(JSObject, classword)),
33564:                               INS_CONSTWORD(~JSSLOT_CLASS_MASK_BITS)),
33564:                     INS_CONSTPTR(&js_FunctionClass)),
33564:           exit);
33564:     return val_ins;
33564: }
33564: 
33564: JS_REQUIRES_STACK LIns*
33564: TraceRecorder::slurpSlot(LIns* val_ins, jsval* vp, VMSideExit* exit)
33564: {
33564:     switch (exit->slurpType)
33564:     {
33564:     case TT_PSEUDOBOOLEAN:
33564:         return slurpBoolSlot(val_ins, vp, exit);
33564:     case TT_INT32:
33564:         return slurpInt32Slot(val_ins, vp, exit);
33564:     case TT_DOUBLE:
33564:         return slurpDoubleSlot(val_ins, vp, exit);
33564:     case TT_STRING:
33564:         return slurpStringSlot(val_ins, vp, exit);
33564:     case TT_NULL:
33564:         return slurpNullSlot(val_ins, vp, exit);
33564:     case TT_OBJECT:
33564:         return slurpObjectSlot(val_ins, vp, exit);
33564:     case TT_FUNCTION:
33564:         return slurpFunctionSlot(val_ins, vp, exit);
33564:     default:
33564:         JS_NOT_REACHED("invalid type in typemap");
33564:         return NULL;
33564:     }
33564: }
33564: 
33564: JS_REQUIRES_STACK void
33564: TraceRecorder::slurpSlot(LIns* val_ins, jsval* vp, SlurpInfo* info)
33564: {
33564:     /* Don't re-read slots that aren't needed. */
33564:     if (info->curSlot < info->slurpFailSlot) {
33564:         info->curSlot++;
33564:         return;
33564:     }
33564:     VMSideExit* exit = copy(info->exit);
33564:     exit->slurpFailSlot = info->curSlot;
33564:     exit->slurpType = info->typeMap[info->curSlot];
33564: 
33564: #if defined DEBUG
33564:     /* Make sure that we don't try and record infinity branches */
33564:     JS_ASSERT_IF(anchor && anchor->exitType == RECURSIVE_SLURP_FAIL_EXIT &&
33564:                  info->curSlot == info->slurpFailSlot,
33564:                  anchor->slurpType != exit->slurpType);
33564: #endif
33564: 
33564:     LIns* val = slurpSlot(val_ins, vp, exit);
33564:     lir->insStorei(val,
33564:                    lirbuf->sp,
36361:                    -tree->nativeStackBase + ptrdiff_t(info->curSlot) * sizeof(double));
33564:     info->curSlot++;
33564: }
33564: 
