68870: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
68870:  *
68870:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Chris Waterson <waterson@netscape.com>
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Peter Annema <disttsc@bart.nl>
    1:  *   Brendan Eich <brendan@mozilla.org>
    1:  *   Mike Shaver <shaver@mozilla.org>
    1:  *   Mark Hammond <mhammond@skippinet.com.au>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK *****
    1:  *
    1:  * This Original Code has been modified by IBM Corporation.
    1:  * Modifications made by IBM described herein are
    1:  * Copyright (c) International Business Machines
    1:  * Corporation, 2000
    1:  *
    1:  * Modifications to Mozilla code or documentation
    1:  * identified per MPL Section 3.3
    1:  *
    1:  * Date         Modified by     Description of modification
    1:  * 03/27/2000   IBM Corp.       Added PR_CALLBACK for Optlink
    1:  *                               use in OS2
    1:  */
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsDOMCID.h"
    1: #include "nsDOMError.h"
    1: #include "nsDOMString.h"
    1: #include "nsIDOMEvent.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "nsHashtable.h"
    1: #include "nsIAtom.h"
 7242: #include "nsIBaseWindow.h"
    1: #include "nsIDOMAttr.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMMouseListener.h"
    1: #include "nsIDOMMouseMotionListener.h"
    1: #include "nsIDOMLoadListener.h"
    1: #include "nsIDOMFocusListener.h"
    1: #include "nsIDOMKeyListener.h"
    1: #include "nsIDOMFormListener.h"
    1: #include "nsIDOMContextMenuListener.h"
    1: #include "nsIDOMEventListener.h"
 1418: #include "nsIDOMEventTarget.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMXULCommandDispatcher.h"
    1: #include "nsIDOMXULElement.h"
    1: #include "nsIDOMElementCSSInlineStyle.h"
    1: #include "nsIDOMXULSelectCntrlItemEl.h"
    1: #include "nsIDocument.h"
    1: #include "nsIEventListenerManager.h"
68780: #include "nsEventStateManager.h"
29018: #include "nsFocusManager.h"
    1: #include "nsIFastLoadService.h"
    1: #include "nsHTMLStyleSheet.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIObjectInputStream.h"
    1: #include "nsIObjectOutputStream.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIPrincipal.h"
    1: #include "nsIRDFCompositeDataSource.h"
    1: #include "nsIRDFNode.h"
    1: #include "nsIRDFService.h"
    1: #include "nsIScriptContext.h"
    1: #include "nsIScriptRuntime.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIScriptGlobalObjectOwner.h"
    1: #include "nsIServiceManager.h"
63693: #include "mozilla/css/StyleRule.h"
    1: #include "nsIStyleSheet.h"
    1: #include "nsIURL.h"
    1: #include "nsIViewManager.h"
    1: #include "nsIWidget.h"
    1: #include "nsIXULDocument.h"
    1: #include "nsIXULTemplateBuilder.h"
    1: #include "nsIXBLService.h"
    1: #include "nsLayoutCID.h"
    1: #include "nsContentCID.h"
    1: #include "nsRDFCID.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsXULControllers.h"
    1: #include "nsIBoxObject.h"
    1: #include "nsPIBoxObject.h"
    1: #include "nsXULDocument.h"
 3129: #include "nsXULPopupListener.h"
    1: #include "nsRuleWalker.h"
68870: #include "nsIDOMViewCSS.h"
    1: #include "nsIDOMCSSStyleDeclaration.h"
38849: #include "nsCSSParser.h"
    1: #include "nsIListBoxObject.h"
    1: #include "nsContentUtils.h"
    1: #include "nsContentList.h"
    1: #include "nsMutationEvent.h"
    1: #include "nsIDOMMutationEvent.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsDOMAttributeMap.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsXULContentUtils.h"
    1: #include "nsNodeUtils.h"
13432: #include "nsFrameLoader.h"
    1: #include "prlog.h"
    1: #include "rdf.h"
29471: #include "nsIDOM3EventTarget.h"
29471: #include "nsIDOMEventGroup.h"
    1: #include "nsIControllers.h"
    1: 
    1: // The XUL doc interface
    1: #include "nsIDOMXULDocument.h"
    1: 
    1: #include "nsReadableUtils.h"
    1: #include "nsITimelineService.h"
    1: #include "nsIFrame.h"
    1: #include "nsNodeInfoManager.h"
    1: #include "nsXBLBinding.h"
    1: #include "nsEventDispatcher.h"
14228: #include "mozAutoDocUpdate.h"
15254: #include "nsIDOMXULCommandEvent.h"
15254: #include "nsIDOMNSEvent.h"
20136: #include "nsCCUncollectableMarker.h"
    1: 
63693: namespace css = mozilla::css;
63693: 
    1: // Global object maintenance
    1: nsIXBLService * nsXULElement::gXBLService = nsnull;
    1: 
    1: /**
    1:  * A tearoff class for nsXULElement to implement nsIScriptEventHandlerOwner.
    1:  */
    1: class nsScriptEventHandlerOwnerTearoff : public nsIScriptEventHandlerOwner
    1: {
    1: public:
    1:     nsScriptEventHandlerOwnerTearoff(nsXULElement* aElement)
    1:     : mElement(aElement) {}
    1: 
    1:     NS_DECL_CYCLE_COLLECTING_ISUPPORTS
    1:     NS_DECL_CYCLE_COLLECTION_CLASS(nsScriptEventHandlerOwnerTearoff)
    1: 
    1:     // nsIScriptEventHandlerOwner
    1:     virtual nsresult CompileEventHandler(nsIScriptContext* aContext,
    1:                                          nsISupports* aTarget,
    1:                                          nsIAtom *aName,
    1:                                          const nsAString& aBody,
    1:                                          const char* aURL,
    1:                                          PRUint32 aLineNo,
    1:                                          nsScriptObjectHolder &aHandler);
    1:     virtual nsresult GetCompiledEventHandler(nsIAtom *aName,
    1:                                              nsScriptObjectHolder &aHandler);
    1: 
    1: private:
    1:     nsRefPtr<nsXULElement> mElement;
    1: };
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: static NS_DEFINE_CID(kXULPopupListenerCID,        NS_XULPOPUPLISTENER_CID);
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: #ifdef XUL_PROTOTYPE_ATTRIBUTE_METERING
    1: PRUint32             nsXULPrototypeAttribute::gNumElements;
    1: PRUint32             nsXULPrototypeAttribute::gNumAttributes;
    1: PRUint32             nsXULPrototypeAttribute::gNumEventHandlers;
    1: PRUint32             nsXULPrototypeAttribute::gNumCacheTests;
    1: PRUint32             nsXULPrototypeAttribute::gNumCacheHits;
    1: PRUint32             nsXULPrototypeAttribute::gNumCacheSets;
    1: PRUint32             nsXULPrototypeAttribute::gNumCacheFills;
    1: #endif
    1: 
13432: class nsXULElementTearoff : public nsIDOMElementCSSInlineStyle,
13432:                             public nsIFrameLoaderOwner
    1: {
    1: public:
13432:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
13432:   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsXULElementTearoff,
13432:                                            nsIDOMElementCSSInlineStyle)
    1: 
    1:   nsXULElementTearoff(nsXULElement *aElement)
    1:     : mElement(aElement)
    1:   {
    1:   }
    1: 
48944:   NS_IMETHOD GetStyle(nsIDOMCSSStyleDeclaration** aStyle)
48944:   {
48944:     nsresult rv;
48944:     *aStyle = static_cast<nsXULElement*>(mElement.get())->GetStyle(&rv);
48944:     NS_ENSURE_SUCCESS(rv, rv);
48944:     NS_ADDREF(*aStyle);
48944:     return NS_OK;
48944:   }
13432:   NS_FORWARD_NSIFRAMELOADEROWNER(static_cast<nsXULElement*>(mElement.get())->);
    1: private:
13432:   nsCOMPtr<nsIDOMXULElement> mElement;
    1: };
    1: 
13432: NS_IMPL_CYCLE_COLLECTION_1(nsXULElementTearoff, mElement)
13432: 
13432: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsXULElementTearoff)
13432: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsXULElementTearoff)
13432: 
13432: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsXULElementTearoff)
13432:   NS_INTERFACE_MAP_ENTRY(nsIFrameLoaderOwner)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMElementCSSInlineStyle)
    1: NS_INTERFACE_MAP_END_AGGREGATED(mElement)
    1: 
    1: //----------------------------------------------------------------------
    1: // nsXULElement
    1: //
    1: 
48124: nsXULElement::nsXULElement(already_AddRefed<nsINodeInfo> aNodeInfo)
38452:     : nsStyledElement(aNodeInfo),
    1:       mBindingParent(nsnull)
    1: {
    1:     XUL_PROTOTYPE_ATTRIBUTE_METER(gNumElements);
    1: }
    1: 
67604: nsXULElement::nsXULSlots::nsXULSlots()
67604:     : nsXULElement::nsDOMSlots()
    1: {
    1: }
    1: 
    1: nsXULElement::nsXULSlots::~nsXULSlots()
    1: {
    1:     NS_IF_RELEASE(mControllers); // Forces release
13432:     if (mFrameLoader) {
13432:         mFrameLoader->Destroy();
13432:     }
    1: }
    1: 
    1: nsINode::nsSlots*
    1: nsXULElement::CreateSlots()
    1: {
67604:     return new nsXULSlots();
    1: }
    1: 
    1: /* static */
    1: already_AddRefed<nsXULElement>
    1: nsXULElement::Create(nsXULPrototypeElement* aPrototype, nsINodeInfo *aNodeInfo,
    1:                      PRBool aIsScriptable)
    1: {
48124:     nsCOMPtr<nsINodeInfo> ni = aNodeInfo;
48124:     nsXULElement *element = new nsXULElement(ni.forget());
    1:     if (element) {
    1:         NS_ADDREF(element);
    1: 
    1:         element->mPrototype = aPrototype;
 6041:         if (aPrototype->mHasIdAttribute) {
67607:             element->SetHasID();
 6041:         }
 6041:         if (aPrototype->mHasClassAttribute) {
 6041:             element->SetFlags(NODE_MAY_HAVE_CLASS);
 6041:         }
 6041:         if (aPrototype->mHasStyleAttribute) {
67608:             element->SetMayHaveStyle();
 6041:         }
    1: 
    1:         NS_ASSERTION(aPrototype->mScriptTypeID != nsIProgrammingLanguage::UNKNOWN,
    1:                     "Need to know the language!");
    1:         element->SetScriptTypeID(aPrototype->mScriptTypeID);
    1: 
    1:         if (aIsScriptable) {
    1:             // Check each attribute on the prototype to see if we need to do
    1:             // any additional processing and hookup that would otherwise be
    1:             // done 'automagically' by SetAttr().
    1:             for (PRUint32 i = 0; i < aPrototype->mNumAttributes; ++i) {
    1:                 element->AddListenerFor(aPrototype->mAttributes[i].mName,
    1:                                         PR_TRUE);
    1:             }
    1:         }
    1:     }
    1: 
    1:     return element;
    1: }
    1: 
    1: nsresult
    1: nsXULElement::Create(nsXULPrototypeElement* aPrototype,
    1:                      nsIDocument* aDocument,
    1:                      PRBool aIsScriptable,
41635:                      Element** aResult)
    1: {
    1:     // Create an nsXULElement from a prototype
    1:     NS_PRECONDITION(aPrototype != nsnull, "null ptr");
    1:     if (! aPrototype)
    1:         return NS_ERROR_NULL_POINTER;
    1: 
    1:     NS_PRECONDITION(aResult != nsnull, "null ptr");
    1:     if (! aResult)
    1:         return NS_ERROR_NULL_POINTER;
    1: 
    1:     nsCOMPtr<nsINodeInfo> nodeInfo;
    1:     if (aDocument) {
    1:         nsINodeInfo* ni = aPrototype->mNodeInfo;
19197:         nodeInfo = aDocument->NodeInfoManager()->GetNodeInfo(ni->NameAtom(),
    1:                                                              ni->GetPrefixAtom(),
19197:                                                              ni->NamespaceID());
19747:         NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);
    1:     }
    1:     else {
    1:         nodeInfo = aPrototype->mNodeInfo;
    1:     }
    1: 
    1:     nsRefPtr<nsXULElement> element = Create(aPrototype, nodeInfo,
    1:                                             aIsScriptable);
    1:     if (!element) {
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     NS_ADDREF(*aResult = element.get());
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
48124: NS_NewXULElement(nsIContent** aResult, already_AddRefed<nsINodeInfo> aNodeInfo)
    1: {
48124:     NS_PRECONDITION(aNodeInfo.get(), "need nodeinfo for non-proto Create");
    1: 
51393:     nsIDocument* doc = aNodeInfo.get()->GetDocument();
51393:     if (doc && !doc->AllowXULXBL()) {
51393:         nsCOMPtr<nsINodeInfo> ni = aNodeInfo;
51393:         return NS_ERROR_NOT_AVAILABLE;
51393:     }
51393: 
51393:     NS_ADDREF(*aResult = new nsXULElement(aNodeInfo));
51393: 
51393:     return NS_OK;
51393: }
51393: 
51393: void
51393: NS_TrustedNewXULElement(nsIContent** aResult, already_AddRefed<nsINodeInfo> aNodeInfo)
51393: {
51393:     NS_PRECONDITION(aNodeInfo.get(), "need nodeinfo for non-proto Create");
50997: 
50997:     // Create an nsXULElement with the specified namespace and tag.
51393:     NS_ADDREF(*aResult = new nsXULElement(aNodeInfo));
50986: }
50986: 
    1: //----------------------------------------------------------------------
    1: // nsISupports interface
    1: 
 1829: NS_IMPL_CYCLE_COLLECTION_CLASS(nsXULElement)
 1829: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsXULElement,
38452:                                                   nsStyledElement)
 1829:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_MEMBER(mPrototype,
 1829:                                                     nsXULPrototypeElement)
62825:     {
62825:         nsXULSlots* slots = static_cast<nsXULSlots*>(tmp->GetExistingSlots());
62825:         if (slots) {
62825:             NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mFrameLoader");
62825:             nsISupports *frameLoader =
62825:                 static_cast<nsIFrameLoader*>(slots->mFrameLoader);
62825:             cb.NoteXPCOMChild(frameLoader);
62825:         }
62825:     }
 1829: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 1829: 
38452: NS_IMPL_ADDREF_INHERITED(nsXULElement, nsStyledElement)
38452: NS_IMPL_RELEASE_INHERITED(nsXULElement, nsStyledElement)
    1: 
48124: DOMCI_NODE_DATA(XULElement, nsXULElement)
40490: 
21218: NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsXULElement)
21218:     NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(nsXULElement)
21218:         NS_INTERFACE_TABLE_ENTRY(nsXULElement, nsIDOMNode)
21218:         NS_INTERFACE_TABLE_ENTRY(nsXULElement, nsIDOMElement)
21218:         NS_INTERFACE_TABLE_ENTRY(nsXULElement, nsIDOMXULElement)
21218:     NS_OFFSET_AND_INTERFACE_TABLE_END
21218:     NS_ELEMENT_INTERFACE_TABLE_TO_MAP_SEGUE
21218:     NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIScriptEventHandlerOwner,
21218:                                    new nsScriptEventHandlerOwnerTearoff(this))
21218:     NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMElementCSSInlineStyle,
21218:                                    new nsXULElementTearoff(this))
21218:     NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIFrameLoaderOwner,
21218:                                    new nsXULElementTearoff(this))
39587:     NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(XULElement)
21218: NS_ELEMENT_INTERFACE_MAP_END
    1: 
    1: //----------------------------------------------------------------------
    1: // nsIDOMNode interface
    1: 
    1: nsresult
    1: nsXULElement::Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const
    1: {
    1:     *aResult = nsnull;
    1: 
    1:     // If we have a prototype, so will our clone.
    1:     nsRefPtr<nsXULElement> element;
    1:     if (mPrototype) {
    1:         element = nsXULElement::Create(mPrototype, aNodeInfo, PR_TRUE);
    1:         NS_ASSERTION(GetScriptTypeID() == mPrototype->mScriptTypeID,
    1:                      "Didn't get the default language from proto?");
    1:     }
    1:     else {
48124:         nsCOMPtr<nsINodeInfo> ni = aNodeInfo;
48124:         element = new nsXULElement(ni.forget());
    1:         if (element) {
    1:         	// If created from a prototype, we will already have the script
    1:         	// language specified by the proto - otherwise copy it directly
    1:         	element->SetScriptTypeID(GetScriptTypeID());
    1:         }
    1:     }
    1: 
    1:     if (!element) {
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     // XXX TODO: set up RDF generic builder n' stuff if there is a
    1:     // 'datasources' attribute? This is really kind of tricky,
    1:     // because then we'd need to -selectively- copy children that
    1:     // -weren't- generated from RDF. Ugh. Forget it.
    1: 
    1:     // Note that we're _not_ copying mControllers.
    1: 
    1:     nsresult rv = CopyInnerTo(element);
    1:     if (NS_SUCCEEDED(rv)) {
    1:         NS_ADDREF(*aResult = element);
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsXULElement::GetElementsByAttribute(const nsAString& aAttribute,
    1:                                      const nsAString& aValue,
    1:                                      nsIDOMNodeList** aReturn)
    1: {
    1:     nsCOMPtr<nsIAtom> attrAtom(do_GetAtom(aAttribute));
    1:     NS_ENSURE_TRUE(attrAtom, NS_ERROR_OUT_OF_MEMORY);
    1:     void* attrValue = new nsString(aValue);
    1:     NS_ENSURE_TRUE(attrValue, NS_ERROR_OUT_OF_MEMORY);
    1:     nsContentList *list = 
    1:         new nsContentList(this,
    1:                           nsXULDocument::MatchAttribute,
    1:                           nsContentUtils::DestroyMatchString,
    1:                           attrValue,
    1:                           PR_TRUE,
    1:                           attrAtom,
    1:                           kNameSpaceID_Unknown);
    1:     NS_ENSURE_TRUE(list, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     NS_ADDREF(*aReturn = list);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULElement::GetElementsByAttributeNS(const nsAString& aNamespaceURI,
    1:                                        const nsAString& aAttribute,
    1:                                        const nsAString& aValue,
    1:                                        nsIDOMNodeList** aReturn)
    1: {
    1:     nsCOMPtr<nsIAtom> attrAtom(do_GetAtom(aAttribute));
    1:     NS_ENSURE_TRUE(attrAtom, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     PRInt32 nameSpaceId = kNameSpaceID_Wildcard;
    1:     if (!aNamespaceURI.EqualsLiteral("*")) {
    1:       nsresult rv =
    1:         nsContentUtils::NameSpaceManager()->RegisterNameSpace(aNamespaceURI,
    1:                                                               nameSpaceId);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1: 
    1:     void* attrValue = new nsString(aValue);
    1:     NS_ENSURE_TRUE(attrValue, NS_ERROR_OUT_OF_MEMORY);
    1:     
    1:     nsContentList *list = 
    1:         new nsContentList(this,
    1:                           nsXULDocument::MatchAttribute,
    1:                           nsContentUtils::DestroyMatchString,
    1:                           attrValue,
    1:                           PR_TRUE,
    1:                           attrAtom,
    1:                           nameSpaceId);
    1:     NS_ENSURE_TRUE(list, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     NS_ADDREF(*aReturn = list);
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULElement::GetEventListenerManagerForAttr(nsIEventListenerManager** aManager,
    1:                                              nsISupports** aTarget,
    1:                                              PRBool* aDefer)
    1: {
    1:     // XXXbz sXBL/XBL2 issue: should we instead use GetCurrentDoc()
    1:     // here, override BindToTree for those classes and munge event
    1:     // listeners there?
    1:     nsIDocument* doc = GetOwnerDoc();
    1:     if (!doc)
    1:         return NS_ERROR_UNEXPECTED; // XXX
    1: 
15042:     nsPIDOMWindow *window;
41634:     Element *root = doc->GetRootElement();
15042:     if ((!root || root == this) && !mNodeInfo->Equals(nsGkAtoms::overlay) &&
15042:         (window = doc->GetInnerWindow()) && window->IsInnerWindow()) {
    1: 
 1418:         nsCOMPtr<nsPIDOMEventTarget> piTarget = do_QueryInterface(window);
 1418:         if (!piTarget)
    1:             return NS_ERROR_UNEXPECTED;
    1: 
29474:         *aDefer = PR_FALSE;
29474:         *aManager = piTarget->GetListenerManager(PR_TRUE);
29474:         NS_ENSURE_STATE(*aManager);
29474:         NS_ADDREF(*aManager);
    1:         NS_ADDREF(*aTarget = window);
29474:         return NS_OK;
    1:     }
    1: 
38452:     return nsStyledElement::GetEventListenerManagerForAttr(aManager,
    1:                                                            aTarget,
    1:                                                            aDefer);
    1: }
    1: 
41071: // returns true if the element is not a list
41071: static PRBool IsNonList(nsINodeInfo* aNodeInfo)
41071: {
41071:   return !aNodeInfo->Equals(nsGkAtoms::tree) &&
41071:          !aNodeInfo->Equals(nsGkAtoms::listbox) &&
41071:          !aNodeInfo->Equals(nsGkAtoms::richlistbox);
41071: }
41071: 
    1: PRBool
41071: nsXULElement::IsFocusable(PRInt32 *aTabIndex, PRBool aWithMouse)
    1: {
12728:   /* 
12728:    * Returns true if an element may be focused, and false otherwise. The inout
12728:    * argument aTabIndex will be set to the tab order index to be used; -1 for
12728:    * elements that should not be part of the tab order and a greater value to
12728:    * indicate its tab order.
12728:    *
12728:    * Confusingly, the supplied value for the aTabIndex argument may indicate
12728:    * whether the element may be focused as a result of the -moz-user-focus
13629:    * property, where -1 means no and 0 means yes.
12728:    *
12728:    * For controls, the element cannot be focused and is not part of the tab
12728:    * order if it is disabled.
12728:    *
12728:    * Controls (those that implement nsIDOMXULControlElement):
12728:    *  *aTabIndex = -1  no tabindex     Not focusable or tabbable
12728:    *  *aTabIndex = -1  tabindex="-1"   Not focusable or tabbable
12728:    *  *aTabIndex = -1  tabindex=">=0"  Focusable and tabbable
12728:    *  *aTabIndex >= 0  no tabindex     Focusable and tabbable
12728:    *  *aTabIndex >= 0  tabindex="-1"   Focusable but not tabbable
12728:    *  *aTabIndex >= 0  tabindex=">=0"  Focusable and tabbable
12728:    * Non-controls:
12728:    *  *aTabIndex = -1                  Not focusable or tabbable
12728:    *  *aTabIndex >= 0                  Focusable and tabbable
12728:    *
12728:    * If aTabIndex is null, then the tabindex is not computed, and
12728:    * true is returned for non-disabled controls and false otherwise.
12728:    */
12728: 
12728:   // elements are not focusable by default
12728:   PRBool shouldFocus = PR_FALSE;
12728: 
41071: #ifdef XP_MACOSX
41071:   // on Mac, mouse interactions only focus the element if it's a list
41071:   if (aWithMouse && IsNonList(mNodeInfo))
41071:     return PR_FALSE;
41071: #endif
41071: 
    1:   nsCOMPtr<nsIDOMXULControlElement> xulControl = 
 3233:     do_QueryInterface(static_cast<nsIContent*>(this));
    1:   if (xulControl) {
12728:     // a disabled element cannot be focused and is not part of the tab order
12728:     PRBool disabled;
    1:     xulControl->GetDisabled(&disabled);
    1:     if (disabled) {
12728:       if (aTabIndex)
12728:         *aTabIndex = -1;
12728:       return PR_FALSE;
12728:     }
12728:     shouldFocus = PR_TRUE;
12728:   }
12728: 
12728:   if (aTabIndex) {
13629:     if (xulControl) {
13629:       if (HasAttr(kNameSpaceID_None, nsGkAtoms::tabindex)) {
12728:         // if either the aTabIndex argument or a specified tabindex is non-negative,
12728:         // the element becomes focusable.
12728:         PRInt32 tabIndex = 0;
    1:         xulControl->GetTabIndex(&tabIndex);
12728:         shouldFocus = *aTabIndex >= 0 || tabIndex >= 0;
12728:         *aTabIndex = tabIndex;
13629:       }
13629:       else {
13629:         // otherwise, if there is no tabindex attribute, just use the value of
35170:         // *aTabIndex to indicate focusability. Reset any supplied tabindex to 0.
13629:         shouldFocus = *aTabIndex >= 0;
35170:         if (shouldFocus)
35170:           *aTabIndex = 0;
13629:       }
12728: 
12728:       if (shouldFocus && sTabFocusModelAppliesToXUL &&
    1:           !(sTabFocusModel & eTabFocus_formElementsMask)) {
    1:         // By default, the tab focus model doesn't apply to xul element on any system but OS X.
    1:         // on OS X we're following it for UI elements (XUL) as sTabFocusModel is based on
    1:         // "Full Keyboard Access" system setting (see mac/nsILookAndFeel).
    1:         // both textboxes and list elements (i.e. trees and list) should always be focusable
    1:         // (textboxes are handled as html:input)
13008:         // For compatibility, we only do this for controls, otherwise elements like <browser>
13008:         // cannot take this focus.
41071:         if (IsNonList(mNodeInfo))
12728:           *aTabIndex = -1;
12728:       }
12728:     }
13008:     else {
13008:       shouldFocus = *aTabIndex >= 0;
13008:     }
13008:   }
12728: 
12728:   return shouldFocus;
    1: }
    1: 
    1: void
    1: nsXULElement::PerformAccesskey(PRBool aKeyCausesActivation,
    1:                                PRBool aIsTrustedEvent)
    1: {
    1:     nsCOMPtr<nsIContent> content(this);
    1: 
    1:     if (Tag() == nsGkAtoms::label) {
    1:         nsCOMPtr<nsIDOMElement> element;
    1: 
    1:         nsAutoString control;
    1:         GetAttr(kNameSpaceID_None, nsGkAtoms::control, control);
    1:         if (!control.IsEmpty()) {
    1:             nsCOMPtr<nsIDOMDocument> domDocument =
    1:                 do_QueryInterface(content->GetCurrentDoc());
    1:             if (domDocument)
    1:                 domDocument->GetElementById(control, getter_AddRefs(element));
    1:         }
    1:         // here we'll either change |content| to the element referenced by
    1:         // |element|, or clear it.
    1:         content = do_QueryInterface(element);
    1: 
    1:         if (!content)
    1:             return;
    1:     }
    1: 
36655:     nsIFrame* frame = content->GetPrimaryFrame();
    1:     if (!frame)
    1:         return;
    1: 
    1:     const nsStyleVisibility* vis = frame->GetStyleVisibility();
    1: 
    1:     if (vis->mVisible == NS_STYLE_VISIBILITY_COLLAPSE ||
    1:         vis->mVisible == NS_STYLE_VISIBILITY_HIDDEN ||
    1:         !frame->AreAncestorViewsVisible())
    1:         return;
    1: 
51609:     nsXULElement* elm = FromContent(content);
 7823:     if (elm) {
    1:         // Define behavior for each type of XUL element.
    1:         nsIAtom *tag = content->Tag();
29018:         if (tag != nsGkAtoms::toolbarbutton) {
29018:           nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29244:           if (fm) {
29244:             nsCOMPtr<nsIDOMElement> element;
29244:             // for radio buttons, focus the radiogroup instead
29244:             if (tag == nsGkAtoms::radio) {
51609:               nsCOMPtr<nsIDOMXULSelectControlItemElement> controlItem(do_QueryInterface(content));
29244:               if (controlItem) {
29244:                 PRBool disabled;
29244:                 controlItem->GetDisabled(&disabled);
29244:                 if (!disabled) {
29244:                   nsCOMPtr<nsIDOMXULSelectControlElement> selectControl;
29244:                   controlItem->GetControl(getter_AddRefs(selectControl));
29244:                   element = do_QueryInterface(selectControl);
29244:                 }
29244:               }
29244:             }
29244:             else {
29244:               element = do_QueryInterface(content);
29244:             }
29244:             if (element)
29018:               fm->SetFocus(element, nsIFocusManager::FLAG_BYKEY);
29018:           }
29244:         }
40485:         if (aKeyCausesActivation && tag != nsGkAtoms::textbox && tag != nsGkAtoms::menulist) {
51609:           elm->ClickWithInputSource(nsIDOMNSMouseEvent::MOZ_SOURCE_KEYBOARD);
40485:         }
    1:     }
 7823:     else {
 7823:         content->PerformAccesskey(aKeyCausesActivation, aIsTrustedEvent);
 7823:     }
 7823: }
    1: 
    1: 
    1: //----------------------------------------------------------------------
    1: // nsIScriptEventHandlerOwner interface
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsScriptEventHandlerOwnerTearoff)
    1: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsScriptEventHandlerOwnerTearoff)
    1:   tmp->mElement = nsnull;
    1: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsScriptEventHandlerOwnerTearoff)
 3233:   cb.NoteXPCOMChild(static_cast<nsIContent*>(tmp->mElement));
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
  791: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsScriptEventHandlerOwnerTearoff)
    1:   NS_INTERFACE_MAP_ENTRY(nsIScriptEventHandlerOwner)
    1: NS_INTERFACE_MAP_END_AGGREGATED(mElement)
    1: 
    1: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsScriptEventHandlerOwnerTearoff)
    1: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsScriptEventHandlerOwnerTearoff)
    1: 
    1: nsresult
    1: nsScriptEventHandlerOwnerTearoff::GetCompiledEventHandler(
    1:                                                 nsIAtom *aName,
    1:                                                 nsScriptObjectHolder &aHandler)
    1: {
    1:     XUL_PROTOTYPE_ATTRIBUTE_METER(gNumCacheTests);
    1:     aHandler.drop();
    1: 
    1:     nsXULPrototypeAttribute *attr =
    1:         mElement->FindPrototypeAttribute(kNameSpaceID_None, aName);
    1:     if (attr) {
    1:         XUL_PROTOTYPE_ATTRIBUTE_METER(gNumCacheHits);
    1:         aHandler.set(attr->mEventHandler);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsScriptEventHandlerOwnerTearoff::CompileEventHandler(
    1:                                                 nsIScriptContext* aContext,
    1:                                                 nsISupports* aTarget,
    1:                                                 nsIAtom *aName,
    1:                                                 const nsAString& aBody,
    1:                                                 const char* aURL,
    1:                                                 PRUint32 aLineNo,
    1:                                                 nsScriptObjectHolder &aHandler)
    1: {
    1:     nsresult rv;
    1: 
    1:     XUL_PROTOTYPE_ATTRIBUTE_METER(gNumCacheSets);
    1: 
    1:     // XXX sXBL/XBL2 issue! Owner or current document?
    1:     nsCOMPtr<nsIXULDocument> xuldoc = do_QueryInterface(mElement->GetOwnerDoc());
    1: 
68468:     nsIScriptContext* context = NULL;
 7230:     nsXULPrototypeElement* elem = mElement->mPrototype;
 7230:     if (elem && xuldoc) {
    1:         // It'll be shared among the instances of the prototype.
    1: 
    1:         // Use the prototype document's special context.  Because
    1:         // scopeObject is null, the JS engine has no other source of
    1:         // <the-new-shared-event-handler>.__proto__ than to look in
    1:         // cx->globalObject for Function.prototype.  That prototype
    1:         // keeps the global object alive, so if we use this document's
    1:         // global object, we'll be putting something in the prototype
    1:         // that protects this document's global object from GC.
    1:         nsCOMPtr<nsIScriptGlobalObjectOwner> globalOwner;
    1:         rv = xuldoc->GetScriptGlobalObjectOwner(getter_AddRefs(globalOwner));
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:         NS_ENSURE_TRUE(globalOwner, NS_ERROR_UNEXPECTED);
    1: 
    1:         nsIScriptGlobalObject* global = globalOwner->GetScriptGlobalObject();
    1:         NS_ENSURE_TRUE(global, NS_ERROR_UNEXPECTED);
    1: 
    1:         context = global->GetScriptContext(aContext->GetScriptTypeID());
    1:         // It could be possible the language has been setup on aContext but
    1:         // not on the global - we don't demand-create language contexts on the
    1:         // nsGlobalWindow
    1:         NS_ASSERTION(context,
    1:                      "Failed to get a language context from the global!?");
    1:         NS_ENSURE_TRUE(context, NS_ERROR_UNEXPECTED);
    1:     }
    1:     else {
    1:         // We don't have a prototype, so the passed context is ok.
    1:         NS_ASSERTION(aTarget != nsnull, "no prototype and no target?!");
    1:         context = aContext;
    1:     }
    1: 
    1:     // Compile the event handler
    1:     PRUint32 argCount;
    1:     const char **argNames;
    1:     nsContentUtils::GetEventArgNames(kNameSpaceID_XUL, aName, &argCount,
    1:                                      &argNames);
26165: 
26165:     nsCxPusher pusher;
26165:     if (!pusher.Push((JSContext*)context->GetNativeContext())) {
26165:       return NS_ERROR_FAILURE;
26165:     }
26165: 
    1:     rv = context->CompileEventHandler(aName, argCount, argNames,
11775:                                       aBody, aURL, aLineNo,
11775:                                       SCRIPTVERSION_DEFAULT,  // for now?
11775:                                       aHandler);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // XXX: Shouldn't this use context and not aContext?
    1:     // XXXmarkh - is GetNativeGlobal() the correct scope?
    1:     rv = aContext->BindCompiledEventHandler(aTarget, aContext->GetNativeGlobal(),
    1:                                             aName, aHandler);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     nsXULPrototypeAttribute *attr =
    1:         mElement->FindPrototypeAttribute(kNameSpaceID_None, aName);
    1:     if (attr) {
    1:         XUL_PROTOTYPE_ATTRIBUTE_METER(gNumCacheFills);
    1:         // take a copy of the event handler, and tell the language about it.
    1:         if (aHandler) {
 7230:             NS_ASSERTION(!attr->mEventHandler, "Leaking handler.");
 7230: 
    1:             rv = nsContentUtils::HoldScriptObject(aContext->GetScriptTypeID(),
 7230:                                                   elem,
 7230:                                                   &NS_CYCLE_COLLECTION_NAME(nsXULPrototypeNode),
 7230:                                                   aHandler,
 7230:                                                   elem->mHoldsScriptObject);
    1:             if (NS_FAILED(rv)) return rv;
 7230: 
 7230:             elem->mHoldsScriptObject = PR_TRUE;
    1:         }
    1:         attr->mEventHandler = (void *)aHandler;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: void
    1: nsXULElement::AddListenerFor(const nsAttrName& aName,
    1:                              PRBool aCompileEventHandlers)
    1: {
    1:     // If appropriate, add a popup listener and/or compile the event
    1:     // handler. Called when we change the element's document, create a
    1:     // new element, change an attribute's value, etc.
    1:     // Eventlistenener-attributes are always in the null namespace
    1:     if (aName.IsAtom()) {
    1:         nsIAtom *attr = aName.Atom();
    1:         MaybeAddPopupListener(attr);
  265:         if (aCompileEventHandlers &&
  265:             nsContentUtils::IsEventAttributeName(attr, EventNameType_XUL)) {
    1:             nsAutoString value;
    1:             GetAttr(kNameSpaceID_None, attr, value);
    1:             AddScriptEventListener(attr, value, PR_TRUE);
    1:         }
    1:     }
    1: }
    1: 
    1: void
    1: nsXULElement::MaybeAddPopupListener(nsIAtom* aLocalName)
    1: {
    1:     // If appropriate, add a popup listener. Called when we change the
    1:     // element's document, create a new element, change an attribute's
    1:     // value, etc.
    1:     if (aLocalName == nsGkAtoms::menu ||
    1:         aLocalName == nsGkAtoms::contextmenu ||
    1:         // XXXdwh popup and context are deprecated
    1:         aLocalName == nsGkAtoms::popup ||
    1:         aLocalName == nsGkAtoms::context) {
    1:         AddPopupListener(aLocalName);
    1:     }
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: // nsIContent interface
    1: //
    1: 
13432: nsresult
13432: nsXULElement::BindToTree(nsIDocument* aDocument,
13432:                          nsIContent* aParent,
13432:                          nsIContent* aBindingParent,
13432:                          PRBool aCompileEventHandlers)
13432: {
43079:   nsresult rv = nsStyledElement::BindToTree(aDocument, aParent,
13432:                                             aBindingParent,
13432:                                             aCompileEventHandlers);
13432:   NS_ENSURE_SUCCESS(rv, rv);
13432: 
13432:   if (aDocument) {
23256:       NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
23256:                    "Missing a script blocker!");
13432:       // We're in a document now.  Kick off the frame load.
13432:       LoadSrc();
13432:   }
13432: 
13432:   return rv;
13432: }
13432: 
    1: void
 1684: nsXULElement::UnbindFromTree(PRBool aDeep, PRBool aNullParent)
 1684: {
 1684:     // mControllers can own objects that are implemented
 1684:     // in JavaScript (such as some implementations of
 1684:     // nsIControllers.  These objects prevent their global
 1684:     // object's script object from being garbage collected,
 1684:     // which means JS continues to hold an owning reference
 1684:     // to the nsGlobalWindow, which owns the document,
 1684:     // which owns this content.  That's a cycle, so we break
 1684:     // it here.  (It might be better to break this by releasing
 1684:     // mDocument in nsGlobalWindow::SetDocShell, but I'm not
 1684:     // sure whether that would fix all possible cycles through
 1684:     // mControllers.)
13432:     nsXULSlots* slots = static_cast<nsXULSlots*>(GetExistingDOMSlots());
 1684:     if (slots) {
 1684:         NS_IF_RELEASE(slots->mControllers);
13432:         if (slots->mFrameLoader) {
13432:             // This element is being taken out of the document, destroy the
13432:             // possible frame loader.
13432:             // XXXbz we really want to only partially destroy the frame
13432:             // loader... we don't want to tear down the docshell.  Food for
13432:             // later bug.
13432:             slots->mFrameLoader->Destroy();
13432:             slots->mFrameLoader = nsnull;
13432:         }
 1684:     }
 1684: 
38452:     nsStyledElement::UnbindFromTree(aDeep, aNullParent);
 1684: }
 1684: 
    1: nsresult
29805: nsXULElement::RemoveChildAt(PRUint32 aIndex, PRBool aNotify, PRBool aMutationEvent)
    1: {
29805:     NS_ASSERTION(aMutationEvent, "Someone tried to inhibit mutations on XUL child removal.");
20665:     nsresult rv;
    1:     nsCOMPtr<nsIContent> oldKid = mAttrsAndChildren.GetSafeChildAt(aIndex);
    1:     if (!oldKid) {
    1:       return NS_OK;
    1:     }
    1: 
    1:     // On the removal of a <treeitem>, <treechildren>, or <treecell> element,
    1:     // the possibility exists that some of the items in the removed subtree
    1:     // are selected (and therefore need to be deselected). We need to account for this.
    1:     nsCOMPtr<nsIDOMXULMultiSelectControlElement> controlElement;
    1:     nsCOMPtr<nsIListBoxObject> listBox;
    1:     PRBool fireSelectionHandler = PR_FALSE;
    1: 
    1:     // -1 = do nothing, -2 = null out current item
    1:     // anything else = index to re-set as current
    1:     PRInt32 newCurrentIndex = -1;
    1: 
    1:     if (oldKid->NodeInfo()->Equals(nsGkAtoms::listitem, kNameSpaceID_XUL)) {
    1:       // This is the nasty case. We have (potentially) a slew of selected items
    1:       // and cells going away.
    1:       // First, retrieve the tree.
    1:       // Check first whether this element IS the tree
 3233:       controlElement = do_QueryInterface(static_cast<nsIContent*>(this));
    1: 
    1:       // If it's not, look at our parent
    1:       if (!controlElement)
    1:         rv = GetParentTree(getter_AddRefs(controlElement));
    1: 
    1:       nsCOMPtr<nsIDOMElement> oldKidElem = do_QueryInterface(oldKid);
    1:       if (controlElement && oldKidElem) {
    1:         // Iterate over all of the items and find out if they are contained inside
    1:         // the removed subtree.
    1:         PRInt32 length;
    1:         controlElement->GetSelectedCount(&length);
    1:         for (PRInt32 i = 0; i < length; i++) {
    1:           nsCOMPtr<nsIDOMXULSelectControlItemElement> node;
    1:           controlElement->GetSelectedItem(i, getter_AddRefs(node));
    1:           // we need to QI here to do an XPCOM-correct pointercompare
    1:           nsCOMPtr<nsIDOMElement> selElem = do_QueryInterface(node);
    1:           if (selElem == oldKidElem &&
    1:               NS_SUCCEEDED(controlElement->RemoveItemFromSelection(node))) {
    1:             length--;
    1:             i--;
    1:             fireSelectionHandler = PR_TRUE;
    1:           }
    1:         }
    1: 
    1:         nsCOMPtr<nsIDOMXULSelectControlItemElement> curItem;
    1:         controlElement->GetCurrentItem(getter_AddRefs(curItem));
    1:         nsCOMPtr<nsIContent> curNode = do_QueryInterface(curItem);
    1:         if (curNode && nsContentUtils::ContentIsDescendantOf(curNode, oldKid)) {
    1:             // Current item going away
    1:             nsCOMPtr<nsIBoxObject> box;
    1:             controlElement->GetBoxObject(getter_AddRefs(box));
    1:             listBox = do_QueryInterface(box);
    1:             if (listBox && oldKidElem) {
    1:               listBox->GetIndexOfItem(oldKidElem, &newCurrentIndex);
    1:             }
    1: 
    1:             // If any of this fails, we'll just set the current item to null
    1:             if (newCurrentIndex == -1)
    1:               newCurrentIndex = -2;
    1:         }
    1:       }
    1:     }
    1: 
38452:     rv = nsStyledElement::RemoveChildAt(aIndex, aNotify, aMutationEvent);
    1:     
    1:     if (newCurrentIndex == -2)
    1:         controlElement->SetCurrentItem(nsnull);
    1:     else if (newCurrentIndex > -1) {
    1:         // Make sure the index is still valid
    1:         PRInt32 treeRows;
    1:         listBox->GetRowCount(&treeRows);
    1:         if (treeRows > 0) {
36761:             newCurrentIndex = PR_MIN((treeRows - 1), newCurrentIndex);
    1:             nsCOMPtr<nsIDOMElement> newCurrentItem;
    1:             listBox->GetItemAtIndex(newCurrentIndex, getter_AddRefs(newCurrentItem));
    1:             nsCOMPtr<nsIDOMXULSelectControlItemElement> xulCurItem = do_QueryInterface(newCurrentItem);
    1:             if (xulCurItem)
    1:                 controlElement->SetCurrentItem(xulCurItem);
    1:         } else {
    1:             controlElement->SetCurrentItem(nsnull);
    1:         }
    1:     }
    1: 
    1:     nsIDocument* doc;
    1:     if (fireSelectionHandler && (doc = GetCurrentDoc())) {
    1:       nsContentUtils::DispatchTrustedEvent(doc,
 3233:                                            static_cast<nsIContent*>(this),
    1:                                            NS_LITERAL_STRING("select"),
    1:                                            PR_FALSE,
    1:                                            PR_TRUE);
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: void
    1: nsXULElement::UnregisterAccessKey(const nsAString& aOldValue)
    1: {
    1:     // If someone changes the accesskey, unregister the old one
    1:     //
    1:     nsIDocument* doc = GetCurrentDoc();
    1:     if (doc && !aOldValue.IsEmpty()) {
46225:         nsIPresShell *shell = doc->GetShell();
    1: 
    1:         if (shell) {
    1:             nsIContent *content = this;
    1: 
    1:             // find out what type of content node this is
    1:             if (mNodeInfo->Equals(nsGkAtoms::label)) {
    1:                 // For anonymous labels the unregistering must
    1:                 // occur on the binding parent control.
16126:                 // XXXldb: And what if the binding parent is null?
    1:                 content = GetBindingParent();
    1:             }
    1: 
    1:             if (content) {
    1:                 shell->GetPresContext()->EventStateManager()->
    1:                     UnregisterAccessKey(content, aOldValue.First());
    1:             }
    1:         }
    1:     }
    1: }
    1: 
    1: nsresult
    1: nsXULElement::BeforeSetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
    1:                             const nsAString* aValue, PRBool aNotify)
    1: {
    1:     if (aNamespaceID == kNameSpaceID_None && aName == nsGkAtoms::accesskey &&
    1:         IsInDoc()) {
    1:         const nsAttrValue* attrVal = FindLocalOrProtoAttr(aNamespaceID, aName);
    1:         if (attrVal) {
    1:             nsAutoString oldValue;
    1:             attrVal->ToString(oldValue);
    1:             UnregisterAccessKey(oldValue);
    1:         }
    1:     } 
10912:     else if (aNamespaceID == kNameSpaceID_None && (aName ==
10912:              nsGkAtoms::command || aName == nsGkAtoms::observes) && IsInDoc()) {
10912: //         XXX sXBL/XBL2 issue! Owner or current document?
10912:         nsAutoString oldValue;
10912:         GetAttr(kNameSpaceID_None, nsGkAtoms::observes, oldValue);
10912:         if (oldValue.IsEmpty()) {
10912:           GetAttr(kNameSpaceID_None, nsGkAtoms::command, oldValue);
10912:         }
10912: 
10912:         if (!oldValue.IsEmpty()) {
10912:           RemoveBroadcaster(oldValue);
10912:         }
10912:     }
46199:     else if (aNamespaceID == kNameSpaceID_None &&
46199:              aValue &&
46199:              mNodeInfo->Equals(nsGkAtoms::window) &&
46199:              aName == nsGkAtoms::chromemargin) {
46199:       nsAttrValue attrValue;
46199:       nsIntMargin margins;
46199:       // Make sure the margin format is valid first
46199:       if (!attrValue.ParseIntMarginValue(*aValue)) {
46199:           return NS_ERROR_INVALID_ARG;
46199:       }
46199:     }
    1: 
38452:     return nsStyledElement::BeforeSetAttr(aNamespaceID, aName,
    1:                                           aValue, aNotify);
    1: }
    1: 
    1: nsresult
    1: nsXULElement::AfterSetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
    1:                            const nsAString* aValue, PRBool aNotify)
    1: {
    1:     if (aNamespaceID == kNameSpaceID_None) {
33380:         // XXX UnsetAttr handles more attributes than we do. See bug 233642.
    1: 
    1:         // Add popup and event listeners. We can't call AddListenerFor since
    1:         // the attribute isn't set yet.
    1:         MaybeAddPopupListener(aName);
  265:         if (nsContentUtils::IsEventAttributeName(aName, EventNameType_XUL) && aValue) {
    1:             // If mPrototype->mScriptTypeID != GetScriptTypeID(), it means
    1:             // we are resolving an overlay with a different default script
    1:             // language.  We can't defer compilation of those handlers as
    1:             // we will have lost the script language (storing it on each
    1:             // nsXULPrototypeAttribute is expensive!)
    1:             PRBool defer = mPrototype == nsnull ||
    1:                            mPrototype->mScriptTypeID == GetScriptTypeID();
    1:             AddScriptEventListener(aName, *aValue, defer);
    1:         }
    1: 
    1:         // Hide chrome if needed
46199:         if (mNodeInfo->Equals(nsGkAtoms::window) && aValue) {
46199:           if (aName == nsGkAtoms::hidechrome) {
34053:               HideWindowChrome(aValue->EqualsLiteral("true"));
34053:           }
46199:           else if (aName == nsGkAtoms::chromemargin) {
46199:               SetChromeMargins(aValue);
46199:           }
46199:         }
34053: 
34053:         // title, (in)activetitlebarcolor and drawintitlebar are settable on
34053:         // any root node (windows, dialogs, etc)
16977:         nsIDocument *document = GetCurrentDoc();
41634:         if (document && document->GetRootElement() == this) {
34053:             if (aName == nsGkAtoms::title) {
16977:                 document->NotifyPossibleTitleChange(PR_FALSE);
16977:             }
34053:             else if ((aName == nsGkAtoms::activetitlebarcolor ||
34053:                       aName == nsGkAtoms::inactivetitlebarcolor)) {
 7242:                 nscolor color = NS_RGBA(0, 0, 0, 0);
 7242:                 nsAttrValue attrValue;
47856:                 attrValue.ParseColor(*aValue);
 7242:                 attrValue.GetColorValue(color);
14886:                 SetTitlebarColor(color, aName == nsGkAtoms::activetitlebarcolor);
 7242:             }
34053:             else if (aName == nsGkAtoms::drawintitlebar) {
34053:                 SetDrawsInTitlebar(aValue && aValue->EqualsLiteral("true"));
34053:             }
34053:             else if (aName == nsGkAtoms::localedir) {
30836:                 // if the localedir changed on the root element, reset the document direction
30836:                 nsCOMPtr<nsIXULDocument> xuldoc = do_QueryInterface(document);
30836:                 if (xuldoc) {
30836:                     xuldoc->ResetDocumentDirection();
30836:                 }
30836:             }
34053:             else if (aName == nsGkAtoms::lwtheme ||
34053:                      aName == nsGkAtoms::lwthemetextcolor) {
33380:                 // if the lwtheme changed, make sure to reset the document lwtheme cache
33380:                 nsCOMPtr<nsIXULDocument> xuldoc = do_QueryInterface(document);
33380:                 if (xuldoc) {
33380:                     xuldoc->ResetDocumentLWTheme();
33380:                 }
33380:             }
34053:         }
33380: 
13432:         if (aName == nsGkAtoms::src && document) {
13432:             LoadSrc();
13432:         }
13432: 
    1:         // XXX need to check if they're changing an event handler: if
    1:         // so, then we need to unhook the old one.  Or something.
    1:     }
    1: 
38452:     return nsStyledElement::AfterSetAttr(aNamespaceID, aName,
    1:                                          aValue, aNotify);
    1: }
    1: 
    1: PRBool
    1: nsXULElement::ParseAttribute(PRInt32 aNamespaceID,
    1:                              nsIAtom* aAttribute,
    1:                              const nsAString& aValue,
    1:                              nsAttrValue& aResult)
    1: {
    1:     // Parse into a nsAttrValue
38452:     if (!nsStyledElement::ParseAttribute(aNamespaceID, aAttribute, aValue,
    1:                                          aResult)) {
    1:         // Fall back to parsing as atom for short values
    1:         aResult.ParseStringOrAtom(aValue);
    1:     }
    1: 
    1:     return PR_TRUE;
    1: }
    1: 
    1: const nsAttrName*
    1: nsXULElement::InternalGetExistingAttrNameFromQName(const nsAString& aStr) const
    1: {
    1:     const nsAttrName* attrName =
39101:         mAttrsAndChildren.GetExistingAttrNameFromQName(aStr);
    1:     if (attrName) {
    1:         return attrName;
    1:     }
    1: 
    1:     if (mPrototype) {
    1:         PRUint32 i;
    1:         for (i = 0; i < mPrototype->mNumAttributes; ++i) {
    1:             attrName = &mPrototype->mAttributes[i].mName;
39101:             if (attrName->QualifiedNameEquals(aStr)) {
    1:                 return attrName;
    1:             }
    1:         }
    1:     }
    1: 
    1:     return nsnull;
    1: }
    1: 
    1: PRBool
    1: nsXULElement::GetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                       nsAString& aResult) const
    1: {
    1:     NS_ASSERTION(nsnull != aName, "must have attribute name");
    1:     NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown,
    1:                  "must have a real namespace ID!");
    1: 
    1:     const nsAttrValue* val = FindLocalOrProtoAttr(aNameSpaceID, aName);
    1: 
    1:     if (!val) {
    1:         // Since we are returning a success code we'd better do
    1:         // something about the out parameters (someone may have
    1:         // given us a non-empty string).
    1:         aResult.Truncate();
    1:         return PR_FALSE;
    1:     }
    1: 
    1:     val->ToString(aResult);
    1: 
    1:     return PR_TRUE;
    1: }
    1: 
    1: PRBool
    1: nsXULElement::HasAttr(PRInt32 aNameSpaceID, nsIAtom* aName) const
    1: {
    1:     NS_ASSERTION(nsnull != aName, "must have attribute name");
    1:     NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown,
    1:                  "must have a real namespace ID!");
    1: 
    1:     return mAttrsAndChildren.GetAttr(aName, aNameSpaceID) ||
    1:            FindPrototypeAttribute(aNameSpaceID, aName);
    1: }
    1: 
    1: PRBool
    1: nsXULElement::AttrValueIs(PRInt32 aNameSpaceID,
    1:                           nsIAtom* aName,
    1:                           const nsAString& aValue,
    1:                           nsCaseTreatment aCaseSensitive) const
    1: {
    1:   NS_ASSERTION(aName, "Must have attr name");
    1:   NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown, "Must have namespace");
    1: 
    1:   const nsAttrValue* val = FindLocalOrProtoAttr(aNameSpaceID, aName);
    1:   return val && val->Equals(aValue, aCaseSensitive);
    1: }
    1: 
    1: PRBool
    1: nsXULElement::AttrValueIs(PRInt32 aNameSpaceID,
    1:                           nsIAtom* aName,
    1:                           nsIAtom* aValue,
    1:                           nsCaseTreatment aCaseSensitive) const
    1: {
    1:   NS_ASSERTION(aName, "Must have attr name");
    1:   NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown, "Must have namespace");
    1:   NS_ASSERTION(aValue, "Null value atom");
    1: 
    1:   const nsAttrValue* val = FindLocalOrProtoAttr(aNameSpaceID, aName);
    1:   return val && val->Equals(aValue, aCaseSensitive);
    1: }
    1: 
    1: PRInt32
    1: nsXULElement::FindAttrValueIn(PRInt32 aNameSpaceID,
    1:                               nsIAtom* aName,
    1:                               AttrValuesArray* aValues,
    1:                               nsCaseTreatment aCaseSensitive) const
    1: {
    1:   NS_ASSERTION(aName, "Must have attr name");
    1:   NS_ASSERTION(aNameSpaceID != kNameSpaceID_Unknown, "Must have namespace");
    1:   NS_ASSERTION(aValues, "Null value array");
    1:   
    1:   const nsAttrValue* val = FindLocalOrProtoAttr(aNameSpaceID, aName);
    1:   if (val) {
    1:     for (PRInt32 i = 0; aValues[i]; ++i) {
    1:       if (val->Equals(*aValues[i], aCaseSensitive)) {
    1:         return i;
    1:       }
    1:     }
    1:     return ATTR_VALUE_NO_MATCH;
    1:   }
    1:   return ATTR_MISSING;
    1: }
    1: 
    1: nsresult
    1: nsXULElement::UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aName, PRBool aNotify)
    1: {
 8668:     // This doesn't call BeforeSetAttr/AfterSetAttr for now.
 8668:     
    1:     NS_ASSERTION(nsnull != aName, "must have attribute name");
    1:     nsresult rv;
    1: 
    1:     // Because It's Hard to maintain a magic ``unset'' value in
    1:     // the local attributes, we'll fault all the attributes,
    1:     // unhook ourselves from the prototype, and then remove the
    1:     // local copy of the attribute that we want to unset. In
    1:     // other words, we'll become ``heavyweight''.
    1:     //
    1:     // We can avoid this if the attribute isn't in the prototype,
    1:     // then we just need to remove it locally
    1: 
    1:     nsXULPrototypeAttribute *protoattr =
    1:         FindPrototypeAttribute(aNameSpaceID, aName);
    1:     if (protoattr) {
    1:         // We've got an attribute on the prototype, so we need to
    1:         // fully fault and remove the local copy.
    1:         rv = MakeHeavyweight();
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1: 
63386:     nsIDocument* doc = GetCurrentDoc();
63386:     mozAutoDocUpdate updateBatch(doc, UPDATE_CONTENT_MODEL, aNotify);
63259: 
43079:     PRBool isId = PR_FALSE;
43079:     if (aName == nsGkAtoms::id && aNameSpaceID == kNameSpaceID_None) {
43079:       // Have to do this before clearing flag. See RemoveFromIdTable
43079:       RemoveFromIdTable();
43079:       isId = PR_TRUE;
43079:     }
43079: 
    1:     PRInt32 index = mAttrsAndChildren.IndexOfAttr(aName, aNameSpaceID);
    1:     if (index < 0) {
    1:         NS_ASSERTION(!protoattr, "we used to have a protoattr, we should now "
    1:                                  "have a normal one");
    1: 
    1:         return NS_OK;
    1:     }
    1: 
    1:     nsAutoString oldValue;
    1:     GetAttr(aNameSpaceID, aName, oldValue);
    1: 
 3410:     // When notifying, make sure to keep track of states whose value
 3410:     // depends solely on the value of an attribute.
56168:     nsEventStates stateMask;
 3410:     if (aNotify) {
56168:         stateMask = IntrinsicState();
 3410:  
29833:         nsNodeUtils::AttributeWillChange(this, aNameSpaceID, aName,
29833:                                          nsIDOMMutationEvent::REMOVAL);
 3410:     }
    1: 
    1:     PRBool hasMutationListeners = aNotify &&
    1:         nsContentUtils::HasMutationListeners(this,
 3137:             NS_EVENT_BITS_MUTATION_ATTRMODIFIED, this);
    1: 
    1:     nsCOMPtr<nsIDOMAttr> attrNode;
    1:     if (hasMutationListeners) {
    1:         nsAutoString ns;
    1:         nsContentUtils::NameSpaceManager()->GetNameSpaceURI(aNameSpaceID, ns);
39101:         GetAttributeNodeNS(ns, nsDependentAtomString(aName), getter_AddRefs(attrNode));
    1:     }
    1: 
    1:     nsDOMSlots *slots = GetExistingDOMSlots();
    1:     if (slots && slots->mAttributeMap) {
    1:       slots->mAttributeMap->DropAttribute(aNameSpaceID, aName);
    1:     }
    1: 
51858:     // The id-handling code, and in the future possibly other code, need to
51858:     // react to unexpected attribute changes.
51858:     nsMutationGuard::DidMutate();
51858: 
    1:     nsAttrValue ignored;
    1:     rv = mAttrsAndChildren.RemoveAttrAt(index, ignored);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // XXX if the RemoveAttrAt() call fails, we might end up having removed
    1:     // the attribute from the attribute map even though the attribute is still
    1:     // on the element
    1:     // https://bugzilla.mozilla.org/show_bug.cgi?id=296205
    1: 
    1:     // Deal with modification of magical attributes that side-effect
    1:     // other things.
    1:     // XXX Know how to remove POPUP event listeners when an attribute is unset?
    1: 
43079:     if (isId) {
67607:         ClearHasID();
43079:     }
43079: 
    1:     if (aNameSpaceID == kNameSpaceID_None) {
46199:         if (mNodeInfo->Equals(nsGkAtoms::window)) {
46199:             if (aName == nsGkAtoms::hidechrome) {
    1:                 HideWindowChrome(PR_FALSE);
    1:             }
46199:             else if (aName == nsGkAtoms::chromemargin) {
46199:                 ResetChromeMargins();
46199:             }
46199:         }
    1: 
41634:         if (doc && doc->GetRootElement() == this) {
14886:             if ((aName == nsGkAtoms::activetitlebarcolor ||
34053:                  aName == nsGkAtoms::inactivetitlebarcolor)) {
 7242:                 // Use 0, 0, 0, 0 as the "none" color.
14886:                 SetTitlebarColor(NS_RGBA(0, 0, 0, 0), aName == nsGkAtoms::activetitlebarcolor);
 7242:             }
34053:             else if (aName == nsGkAtoms::localedir) {
30836:                 // if the localedir changed on the root element, reset the document direction
30836:                 nsCOMPtr<nsIXULDocument> xuldoc = do_QueryInterface(doc);
30836:                 if (xuldoc) {
30836:                     xuldoc->ResetDocumentDirection();
30836:                 }
30836:             }
34053:             else if ((aName == nsGkAtoms::lwtheme ||
34053:                       aName == nsGkAtoms::lwthemetextcolor)) {
33380:                 // if the lwtheme changed, make sure to restyle appropriately
33380:                 nsCOMPtr<nsIXULDocument> xuldoc = do_QueryInterface(doc);
33380:                 if (xuldoc) {
33380:                     xuldoc->ResetDocumentLWTheme();
33380:                 }
33380:             }
34053:             else if (aName == nsGkAtoms::drawintitlebar) {
34053:                 SetDrawsInTitlebar(PR_FALSE);
34053:             }
34053:         }
33380: 
    1:         // If the accesskey attribute is removed, unregister it here
23176:         // Also see nsXULLabelFrame, nsBoxFrame and nsTextBoxFrame's AttributeChanged
    1:         if (aName == nsGkAtoms::accesskey || aName == nsGkAtoms::control) {
    1:             UnregisterAccessKey(oldValue);
    1:         }
    1: 
    1:         // Check to see if the OBSERVES attribute is being unset.  If so, we
    1:         // need to remove our broadcaster goop completely.
    1:         if (doc && (aName == nsGkAtoms::observes ||
    1:                           aName == nsGkAtoms::command)) {
10912:             RemoveBroadcaster(oldValue);
    1:         }
    1:     }
    1: 
    1:     if (doc) {
 6674:         nsRefPtr<nsXBLBinding> binding =
 6674:             doc->BindingManager()->GetBinding(this);
    1:         if (binding)
    1:             binding->AttributeChanged(aName, aNameSpaceID, PR_TRUE, aNotify);
    1: 
    1:     }
    1: 
    1:     if (aNotify) {
56168:         stateMask ^= IntrinsicState();
56168:         if (doc && !stateMask.IsEmpty()) {
 3410:             MOZ_AUTO_DOC_UPDATE(doc, UPDATE_CONTENT_STATE, aNotify);
64120:             doc->ContentStateChanged(this, stateMask);
 3410:         }
    1:         nsNodeUtils::AttributeChanged(this, aNameSpaceID, aName,
35535:                                       nsIDOMMutationEvent::REMOVAL);
    1:     }
    1: 
 3311:     if (hasMutationListeners) {
34394:         mozAutoRemovableBlockerRemover blockerRemover(GetOwnerDoc());
14319: 
 3311:         nsMutationEvent mutation(PR_TRUE, NS_MUTATION_ATTRMODIFIED);
 3311: 
 3311:         mutation.mRelatedNode = attrNode;
 3311:         mutation.mAttrName = aName;
 3311: 
 3311:         if (!oldValue.IsEmpty())
 3311:           mutation.mPrevAttrValue = do_GetAtom(oldValue);
 3311:         mutation.mAttrChange = nsIDOMMutationEvent::REMOVAL;
 3311: 
 3311:         mozAutoSubtreeModified subtree(GetOwnerDoc(), this);
 3311:         nsEventDispatcher::Dispatch(static_cast<nsIContent*>(this),
 3311:                                     nsnull, &mutation);
 3311:     }
 3311: 
    1:     return NS_OK;
    1: }
    1: 
10912: void
10912: nsXULElement::RemoveBroadcaster(const nsAString & broadcasterId)
10912: {
10912:     nsCOMPtr<nsIDOMXULDocument> xuldoc = do_QueryInterface(GetOwnerDoc());
10912:     if (xuldoc) {
10912:         nsCOMPtr<nsIDOMElement> broadcaster;
10912:         nsCOMPtr<nsIDOMDocument> domDoc (do_QueryInterface(xuldoc));
10912:         domDoc->GetElementById(broadcasterId, getter_AddRefs(broadcaster));
10912:         if (broadcaster) {
10912:             xuldoc->RemoveBroadcastListenerFor(broadcaster, this,
10912:               NS_LITERAL_STRING("*"));
10912:         }
10912:     }
10912: }
10912: 
    1: const nsAttrName*
    1: nsXULElement::GetAttrNameAt(PRUint32 aIndex) const
    1: {
    1:     PRUint32 localCount = mAttrsAndChildren.AttrCount();
    1:     PRUint32 protoCount = mPrototype ? mPrototype->mNumAttributes : 0;
    1: 
    1:     if (localCount > protoCount) {
    1:         // More local than proto, put local first
    1: 
    1:         // Is the index low enough to just grab a local attr?
    1:         if (aIndex < localCount) {
    1:             return mAttrsAndChildren.AttrNameAt(aIndex);
    1:         }
    1: 
    1:         aIndex -= localCount;
    1: 
    1:         // Search though prototype attributes while skipping names that exist in
    1:         // the local array.
    1:         for (PRUint32 i = 0; i < protoCount; i++) {
    1:             const nsAttrName* name = &mPrototype->mAttributes[i].mName;
    1:             if (mAttrsAndChildren.GetAttr(name->LocalName(), name->NamespaceID())) {
    1:                 aIndex++;
    1:             }
    1:             if (i == aIndex) {
    1:                 return name;
    1:             }
    1:         }
    1:     }
    1:     else {
    1:         // More proto than local, put proto first
    1: 
    1:         // Is the index low enough to just grab a proto attr?
    1:         if (aIndex < protoCount) {
    1:             return &mPrototype->mAttributes[aIndex].mName;
    1:         }
    1: 
    1:         aIndex -= protoCount;
    1: 
    1:         // Search though local attributes while skipping names that exist in
    1:         // the prototype array.
    1:         for (PRUint32 i = 0; i < localCount; i++) {
    1:             const nsAttrName* name = mAttrsAndChildren.AttrNameAt(i);
    1: 
    1:             for (PRUint32 j = 0; j < protoCount; j++) {
    1:                 if (mPrototype->mAttributes[j].mName.Equals(*name)) {
    1:                     aIndex++;
    1:                     break;
    1:                 }
    1:             }
    1:             if (i == aIndex) {
    1:                 return name;
    1:             }
    1:         }
    1:     }
    1: 
    1:     return nsnull;
    1: }
    1: 
    1: PRUint32
    1: nsXULElement::GetAttrCount() const
    1: {
    1:     PRUint32 localCount = mAttrsAndChildren.AttrCount();
    1:     PRUint32 protoCount = mPrototype ? mPrototype->mNumAttributes : 0;
    1: 
    1:     if (localCount > protoCount) {
    1:         // More local than proto, remove dups from proto array
    1:         PRUint32 count = localCount;
    1: 
    1:         for (PRUint32 i = 0; i < protoCount; i++) {
    1:             const nsAttrName* name = &mPrototype->mAttributes[i].mName;
    1:             if (!mAttrsAndChildren.GetAttr(name->LocalName(), name->NamespaceID())) {
    1:                 count++;
    1:             }
    1:         }
    1: 
    1:         return count;
    1:     }
    1: 
    1:     // More proto than local, remove dups from local array
    1:     PRUint32 count = protoCount;
    1: 
    1:     for (PRUint32 i = 0; i < localCount; i++) {
    1:         const nsAttrName* name = mAttrsAndChildren.AttrNameAt(i);
    1: 
    1:         count++;
    1:         for (PRUint32 j = 0; j < protoCount; j++) {
    1:             if (mPrototype->mAttributes[j].mName.Equals(*name)) {
    1:                 count--;
    1:                 break;
    1:             }
    1:         }
    1:     }
    1: 
    1:     return count;
    1: }
    1: 
 8462: void
 8462: nsXULElement::DestroyContent()
 8462: {
13432:     nsXULSlots* slots = static_cast<nsXULSlots*>(GetExistingDOMSlots());
 8462:     if (slots) {
 8462:         NS_IF_RELEASE(slots->mControllers);
13432:         if (slots->mFrameLoader) {
13432:             slots->mFrameLoader->Destroy();
13432:             slots->mFrameLoader = nsnull;
13432:         }
 8462:     }
 8462: 
38452:     nsStyledElement::DestroyContent();
 8462: }
    1: 
    1: #ifdef DEBUG
    1: void
    1: nsXULElement::List(FILE* out, PRInt32 aIndent) const
    1: {
31437:     nsCString prefix("XUL");
    1:     if (HasSlots()) {
    1:       prefix.Append('*');
    1:     }
    1:     prefix.Append(' ');
    1: 
38452:     nsStyledElement::List(out, aIndent, prefix);
    1: }
    1: #endif
    1: 
    1: nsresult
    1: nsXULElement::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
    1: {
    1:     aVisitor.mForceContentDispatch = PR_TRUE; //FIXME! Bug 329119
    1:     nsIAtom* tag = Tag();
29471:     if (IsRootOfNativeAnonymousSubtree() &&
29471:         (tag == nsGkAtoms::scrollbar || tag == nsGkAtoms::scrollcorner) &&
29471:         (aVisitor.mEvent->message == NS_MOUSE_CLICK ||
29471:          aVisitor.mEvent->message == NS_MOUSE_DOUBLECLICK ||
29471:          aVisitor.mEvent->message == NS_XUL_COMMAND ||
31035:          aVisitor.mEvent->message == NS_CONTEXTMENU ||
31035:          aVisitor.mEvent->message == NS_DRAGDROP_START ||
31035:          aVisitor.mEvent->message == NS_DRAGDROP_GESTURE)) {
29471:         // Don't propagate these events from native anonymous scrollbar.
29471:         aVisitor.mCanHandle = PR_TRUE;
29471:         aVisitor.mParentTarget = nsnull;
29471:         return NS_OK;
29471:     }
    1:     if (aVisitor.mEvent->message == NS_XUL_COMMAND &&
29844:         aVisitor.mEvent->eventStructType == NS_INPUT_EVENT &&
 3233:         aVisitor.mEvent->originalTarget == static_cast<nsIContent*>(this) &&
    1:         tag != nsGkAtoms::command) {
29844:         // Check that we really have an xul command event. That will be handled
29844:         // in a special way.
29844:         nsCOMPtr<nsIDOMXULCommandEvent> xulEvent =
29844:             do_QueryInterface(aVisitor.mDOMEvent);
    1:         // See if we have a command elt.  If so, we execute on the command
    1:         // instead of on our content element.
    1:         nsAutoString command;
29844:         if (xulEvent && GetAttr(kNameSpaceID_None, nsGkAtoms::command, command) &&
29844:             !command.IsEmpty()) {
    1:             // Stop building the event target chain for the original event.
    1:             // We don't want it to propagate to any DOM nodes.
    1:             aVisitor.mCanHandle = PR_FALSE;
    1: 
    1:             // XXX sXBL/XBL2 issue! Owner or current document?
    1:             nsCOMPtr<nsIDOMDocument> domDoc(do_QueryInterface(GetCurrentDoc()));
    1:             NS_ENSURE_STATE(domDoc);
    1:             nsCOMPtr<nsIDOMElement> commandElt;
    1:             domDoc->GetElementById(command, getter_AddRefs(commandElt));
    1:             nsCOMPtr<nsIContent> commandContent(do_QueryInterface(commandElt));
    1:             if (commandContent) {
    1:                 // Create a new command event to dispatch to the element
    1:                 // pointed to by the command attribute.  The new event's
    1:                 // sourceEvent will be the original command event that we're
    1:                 // handling.
15254:                 nsCOMPtr<nsIDOMNSEvent> nsevent =
15254:                     do_QueryInterface(aVisitor.mDOMEvent);
15254:                 while (nsevent) {
15254:                     nsCOMPtr<nsIDOMEventTarget> oTarget;
15254:                     nsevent->GetOriginalTarget(getter_AddRefs(oTarget));
15254:                     NS_ENSURE_STATE(!SameCOMIdentity(oTarget, commandContent));
15254:                     nsCOMPtr<nsIDOMEvent> tmp;
15254:                     nsCOMPtr<nsIDOMXULCommandEvent> commandEvent =
15254:                         do_QueryInterface(nsevent);
15254:                     if (commandEvent) {
15254:                         commandEvent->GetSourceEvent(getter_AddRefs(tmp));
15254:                     }
15254:                     nsevent = do_QueryInterface(tmp);
15254:                 }
15254: 
29844:                 nsInputEvent* orig =
29844:                     static_cast<nsInputEvent*>(aVisitor.mEvent);
29844:                 nsContentUtils::DispatchXULCommand(
29844:                   commandContent,
29844:                   NS_IS_TRUSTED_EVENT(aVisitor.mEvent),
29844:                   aVisitor.mDOMEvent,
29844:                   nsnull,
29844:                   orig->isControl,
29844:                   orig->isAlt,
29844:                   orig->isShift,
29844:                   orig->isMeta);
    1:             } else {
    1:                 NS_WARNING("A XUL element is attached to a command that doesn't exist!\n");
    1:             }
    1:             return NS_OK;
    1:         }
    1:     }
    1: 
38452:     return nsStyledElement::PreHandleEvent(aVisitor);
    1: }
    1: 
    1: // XXX This _should_ be an implementation method, _not_ publicly exposed :-(
    1: NS_IMETHODIMP
    1: nsXULElement::GetResource(nsIRDFResource** aResource)
    1: {
    1:     nsAutoString id;
    1:     GetAttr(kNameSpaceID_None, nsGkAtoms::ref, id);
    1:     if (id.IsEmpty()) {
    1:         GetAttr(kNameSpaceID_None, nsGkAtoms::id, id);
    1:     }
    1: 
    1:     if (!id.IsEmpty()) {
    1:         return nsXULContentUtils::RDFService()->
    1:             GetUnicodeResource(id, aResource);
    1:     }
    1:     *aResource = nsnull;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsXULElement::GetDatabase(nsIRDFCompositeDataSource** aDatabase)
    1: {
    1:     nsCOMPtr<nsIXULTemplateBuilder> builder;
    1:     GetBuilder(getter_AddRefs(builder));
    1: 
    1:     if (builder)
    1:         builder->GetDatabase(aDatabase);
    1:     else
    1:         *aDatabase = nsnull;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsXULElement::GetBuilder(nsIXULTemplateBuilder** aBuilder)
    1: {
    1:     *aBuilder = nsnull;
    1: 
    1:     // XXX sXBL/XBL2 issue! Owner or current document?
    1:     nsCOMPtr<nsIXULDocument> xuldoc = do_QueryInterface(GetCurrentDoc());
    1:     if (xuldoc)
    1:         xuldoc->GetTemplateBuilderFor(this, aBuilder);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: //----------------------------------------------------------------------
    1: // Implementation methods
    1: 
43079: // XXX DoGetID and DoGetClasses must be defined here because we have proto
43079: // attributes.
    1: nsIAtom*
43079: nsXULElement::DoGetID() const
    1: {
67607:     NS_ASSERTION(HasID(), "Unexpected call");
43079:     const nsAttrValue* attr =
43079:         FindLocalOrProtoAttr(kNameSpaceID_None, nsGkAtoms::id);
43079: 
67607:     // We need the nullcheck here because during unlink the prototype loses
43079:     // all of its attributes. We might want to change that.
43079:     // The nullcheck would also be needed if we make UnsetAttr use
43079:     // nsGenericElement::UnsetAttr as that calls out to various code between
67607:     // removing the attribute and calling ClearHasID().
43079: 
43079:     return attr ? attr->GetAtomValue() : nsnull;
    1: }
    1: 
    1: const nsAttrValue*
19132: nsXULElement::DoGetClasses() const
    1: {
19132:     NS_ASSERTION(HasFlag(NODE_MAY_HAVE_CLASS), "Unexpected call");
    1:     return FindLocalOrProtoAttr(kNameSpaceID_None, nsGkAtoms::_class);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULElement::WalkContentStyleRules(nsRuleWalker* aRuleWalker)
    1: {
    1:     return NS_OK;
    1: }
    1: 
63693: css::StyleRule*
    1: nsXULElement::GetInlineStyleRule()
    1: {
67608:     if (!MayHaveStyle()) {
 6041:         return nsnull;
 6041:     }
    1:     // Fetch the cached style rule from the attributes.
    1:     const nsAttrValue* attrVal = FindLocalOrProtoAttr(kNameSpaceID_None, nsGkAtoms::style);
    1: 
    1:     if (attrVal && attrVal->Type() == nsAttrValue::eCSSStyleRule) {
    1:         return attrVal->GetCSSStyleRuleValue();
    1:     }
    1: 
    1:     return nsnull;
    1: }
    1: 
    1: nsChangeHint
    1: nsXULElement::GetAttributeChangeHint(const nsIAtom* aAttribute,
    1:                                      PRInt32 aModType) const
    1: {
    1:     nsChangeHint retval(NS_STYLE_HINT_NONE);
    1: 
    1:     if (aAttribute == nsGkAtoms::value &&
    1:         (aModType == nsIDOMMutationEvent::REMOVAL ||
    1:          aModType == nsIDOMMutationEvent::ADDITION)) {
    1:       nsIAtom *tag = Tag();
    1:       if (tag == nsGkAtoms::label || tag == nsGkAtoms::description)
    1:         // Label and description dynamically morph between a normal
    1:         // block and a cropping single-line XUL text frame.  If the
    1:         // value attribute is being added or removed, then we need to
    1:         // return a hint of frame change.  (See bugzilla bug 95475 for
    1:         // details.)
    1:         retval = NS_STYLE_HINT_FRAMECHANGE;
    1:     } else {
    1:         // if left or top changes we reflow. This will happen in xul
30836:         // containers that manage positioned children such as a stack.
32443:         if (nsGkAtoms::left == aAttribute || nsGkAtoms::top == aAttribute ||
63170:             nsGkAtoms::right == aAttribute || nsGkAtoms::bottom == aAttribute ||
63170:             nsGkAtoms::start == aAttribute || nsGkAtoms::end == aAttribute)
    1:             retval = NS_STYLE_HINT_REFLOW;
    1:     }
    1: 
    1:     return retval;
    1: }
    1: 
    1: NS_IMETHODIMP_(PRBool)
    1: nsXULElement::IsAttributeMapped(const nsIAtom* aAttribute) const
    1: {
    1:     return PR_FALSE;
    1: }
    1: 
    1: // Controllers Methods
    1: NS_IMETHODIMP
    1: nsXULElement::GetControllers(nsIControllers** aResult)
    1: {
    1:     if (! Controllers()) {
59659:         nsDOMSlots* slots = DOMSlots();
    1: 
    1:         nsresult rv;
    1:         rv = NS_NewXULControllers(nsnull, NS_GET_IID(nsIControllers),
 3233:                                   reinterpret_cast<void**>(&slots->mControllers));
    1: 
    1:         NS_ASSERTION(NS_SUCCEEDED(rv), "unable to create a controllers");
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
    1: 
    1:     *aResult = Controllers();
    1:     NS_IF_ADDREF(*aResult);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULElement::GetBoxObject(nsIBoxObject** aResult)
    1: {
    1:   *aResult = nsnull;
    1: 
    1:   // XXX sXBL/XBL2 issue! Owner or current document?
26701:   nsIDocument* nsDoc = GetOwnerDoc();
    1: 
    1:   return nsDoc ? nsDoc->GetBoxObjectFor(this, aResult) : NS_ERROR_FAILURE;
    1: }
    1: 
    1: // Methods for setting/getting attributes from nsIDOMXULElement
    1: #define NS_IMPL_XUL_STRING_ATTR(_method, _atom)                     \
    1:   NS_IMETHODIMP                                                     \
    1:   nsXULElement::Get##_method(nsAString& aReturn)                    \
    1:   {                                                                 \
    1:     GetAttr(kNameSpaceID_None, nsGkAtoms::_atom, aReturn);         \
    1:     return NS_OK;                                                   \
    1:   }                                                                 \
    1:   NS_IMETHODIMP                                                     \
    1:   nsXULElement::Set##_method(const nsAString& aValue)               \
    1:   {                                                                 \
    1:     return SetAttr(kNameSpaceID_None, nsGkAtoms::_atom, aValue,    \
    1:                    PR_TRUE);                                        \
    1:   }
    1: 
    1: #define NS_IMPL_XUL_BOOL_ATTR(_method, _atom)                       \
    1:   NS_IMETHODIMP                                                     \
    1:   nsXULElement::Get##_method(PRBool* aResult)                       \
    1:   {                                                                 \
    1:     *aResult = BoolAttrIsTrue(nsGkAtoms::_atom);                   \
    1:                                                                     \
    1:     return NS_OK;                                                   \
    1:   }                                                                 \
    1:   NS_IMETHODIMP                                                     \
    1:   nsXULElement::Set##_method(PRBool aValue)                         \
    1:   {                                                                 \
    1:     if (aValue)                                                     \
    1:       SetAttr(kNameSpaceID_None, nsGkAtoms::_atom,                 \
    1:               NS_LITERAL_STRING("true"), PR_TRUE);                  \
    1:     else                                                            \
    1:       UnsetAttr(kNameSpaceID_None, nsGkAtoms::_atom, PR_TRUE);     \
    1:                                                                     \
    1:     return NS_OK;                                                   \
    1:   }
    1: 
    1: 
    1: NS_IMPL_XUL_STRING_ATTR(Id, id)
    1: NS_IMPL_XUL_STRING_ATTR(ClassName, _class)
    1: NS_IMPL_XUL_STRING_ATTR(Align, align)
    1: NS_IMPL_XUL_STRING_ATTR(Dir, dir)
    1: NS_IMPL_XUL_STRING_ATTR(Flex, flex)
    1: NS_IMPL_XUL_STRING_ATTR(FlexGroup, flexgroup)
    1: NS_IMPL_XUL_STRING_ATTR(Ordinal, ordinal)
    1: NS_IMPL_XUL_STRING_ATTR(Orient, orient)
    1: NS_IMPL_XUL_STRING_ATTR(Pack, pack)
    1: NS_IMPL_XUL_BOOL_ATTR(Hidden, hidden)
    1: NS_IMPL_XUL_BOOL_ATTR(Collapsed, collapsed)
    1: NS_IMPL_XUL_BOOL_ATTR(AllowEvents, allowevents)
    1: NS_IMPL_XUL_STRING_ATTR(Observes, observes)
    1: NS_IMPL_XUL_STRING_ATTR(Menu, menu)
    1: NS_IMPL_XUL_STRING_ATTR(ContextMenu, contextmenu)
    1: NS_IMPL_XUL_STRING_ATTR(Tooltip, tooltip)
    1: NS_IMPL_XUL_STRING_ATTR(Width, width)
    1: NS_IMPL_XUL_STRING_ATTR(Height, height)
    1: NS_IMPL_XUL_STRING_ATTR(MinWidth, minwidth)
    1: NS_IMPL_XUL_STRING_ATTR(MinHeight, minheight)
    1: NS_IMPL_XUL_STRING_ATTR(MaxWidth, maxwidth)
    1: NS_IMPL_XUL_STRING_ATTR(MaxHeight, maxheight)
    1: NS_IMPL_XUL_STRING_ATTR(Persist, persist)
    1: NS_IMPL_XUL_STRING_ATTR(Left, left)
    1: NS_IMPL_XUL_STRING_ATTR(Top, top)
    1: NS_IMPL_XUL_STRING_ATTR(Datasources, datasources)
    1: NS_IMPL_XUL_STRING_ATTR(Ref, ref)
    1: NS_IMPL_XUL_STRING_ATTR(TooltipText, tooltiptext)
    1: NS_IMPL_XUL_STRING_ATTR(StatusText, statustext)
    1: 
    1: nsresult
48944: nsXULElement::EnsureLocalStyle()
    1: {
  916:     // Clone the prototype rule, if we don't have a local one.
  916:     if (mPrototype &&
  916:         !mAttrsAndChildren.GetAttr(nsGkAtoms::style, kNameSpaceID_None)) {
  916: 
  916:         nsXULPrototypeAttribute *protoattr =
  916:                   FindPrototypeAttribute(kNameSpaceID_None, nsGkAtoms::style);
  916:         if (protoattr && protoattr->mValue.Type() == nsAttrValue::eCSSStyleRule) {
50636:             nsCOMPtr<nsICSSRule> ruleClone =
50636:                 protoattr->mValue.GetCSSStyleRuleValue()->Clone();
  916: 
50380:             nsString stringValue;
50380:             protoattr->mValue.ToString(stringValue);
50380: 
  916:             nsAttrValue value;
63693:             nsRefPtr<css::StyleRule> styleRule = do_QueryObject(ruleClone);
50380:             value.SetTo(styleRule, &stringValue);
  916: 
50636:             nsresult rv =
50636:                 mAttrsAndChildren.SetAndTakeAttr(nsGkAtoms::style, value);
  916:             NS_ENSURE_SUCCESS(rv, rv);
  916:         }
  916:     }
  916: 
48944:     return NS_OK;
    1: }
    1: 
13432: nsresult
13432: nsXULElement::LoadSrc()
13432: {
13432:     // Allow frame loader only on objects for which a container box object
13432:     // can be obtained.
13432:     nsIAtom* tag = Tag();
13432:     if (tag != nsGkAtoms::browser &&
13432:         tag != nsGkAtoms::editor &&
13432:         tag != nsGkAtoms::iframe) {
13432:         return NS_OK;
13432:     }
13432:     if (!IsInDoc() ||
41634:         !GetOwnerDoc()->GetRootElement() ||
41634:         GetOwnerDoc()->GetRootElement()->
13432:             NodeInfo()->Equals(nsGkAtoms::overlay, kNameSpaceID_XUL)) {
13432:         return NS_OK;
13432:     }
13432:     nsXULSlots* slots = static_cast<nsXULSlots*>(GetSlots());
13432:     NS_ENSURE_TRUE(slots, NS_ERROR_OUT_OF_MEMORY);
13432:     if (!slots->mFrameLoader) {
50721:         // PR_FALSE as the last parameter so that xul:iframe/browser/editor
50721:         // session history handling works like dynamic html:iframes.
50721:         // Usually xul elements are used in chrome, which doesn't have
50721:         // session history at all.
50721:         slots->mFrameLoader = nsFrameLoader::Create(this, PR_FALSE);
31661:         NS_ENSURE_TRUE(slots->mFrameLoader, NS_OK);
13432:     }
13432: 
13432:     return slots->mFrameLoader->LoadFrame();
13432: }
13432: 
13432: nsresult
13432: nsXULElement::GetFrameLoader(nsIFrameLoader **aFrameLoader)
13432: {
34076:     *aFrameLoader = GetFrameLoader().get();
34076:     return NS_OK;
34076: }
34076: 
34076: already_AddRefed<nsFrameLoader>
34076: nsXULElement::GetFrameLoader()
34076: {
13432:     nsXULSlots* slots = static_cast<nsXULSlots*>(GetExistingSlots());
34076:     if (!slots)
34076:         return nsnull;
34076: 
34076:     nsFrameLoader* loader = slots->mFrameLoader;
34076:     NS_IF_ADDREF(loader);
34076:     return loader;
13432: }
13432: 
16549: nsresult
16549: nsXULElement::SwapFrameLoaders(nsIFrameLoaderOwner* aOtherOwner)
16549: {
16549:     nsCOMPtr<nsIContent> otherContent(do_QueryInterface(aOtherOwner));
16549:     NS_ENSURE_TRUE(otherContent, NS_ERROR_NOT_IMPLEMENTED);
16549: 
16549:     nsXULElement* otherEl = FromContent(otherContent);
16549:     NS_ENSURE_TRUE(otherEl, NS_ERROR_NOT_IMPLEMENTED);
16549: 
16549:     if (otherEl == this) {
16549:         // nothing to do
16549:         return NS_OK;
16549:     }
16549: 
16549:     nsXULSlots *ourSlots = static_cast<nsXULSlots*>(GetExistingDOMSlots());
16549:     nsXULSlots *otherSlots =
16549:         static_cast<nsXULSlots*>(otherEl->GetExistingDOMSlots());
16549:     if (!ourSlots || !ourSlots->mFrameLoader ||
16549:         !otherSlots || !otherSlots->mFrameLoader) {
16549:         // Can't handle swapping when there is nothing to swap... yet.
16549:         return NS_ERROR_NOT_IMPLEMENTED;
16549:     }
16549: 
16549:     return
16549:         ourSlots->mFrameLoader->SwapWithOtherLoader(otherSlots->mFrameLoader,
16549:                                                     ourSlots->mFrameLoader,
16549:                                                     otherSlots->mFrameLoader);
16549: }
16549: 
    1: NS_IMETHODIMP
    1: nsXULElement::GetParentTree(nsIDOMXULMultiSelectControlElement** aTreeElement)
    1: {
    1:     for (nsIContent* current = GetParent(); current;
    1:          current = current->GetParent()) {
    1:         if (current->NodeInfo()->Equals(nsGkAtoms::listbox,
    1:                                         kNameSpaceID_XUL)) {
    1:             CallQueryInterface(current, aTreeElement);
    1:             // XXX returning NS_OK because that's what the code used to do;
    1:             // is that the right thing, though?
    1: 
    1:             return NS_OK;
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULElement::Focus()
    1: {
29018:     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:     nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(static_cast<nsIContent*>(this));
29018:     return fm ? fm->SetFocus(this, 0) : NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULElement::Blur()
    1: {
29018:     if (!ShouldBlur(this))
29018:       return NS_OK;
29018: 
    1:     nsIDocument* doc = GetCurrentDoc();
    1:     if (!doc)
    1:       return NS_OK;
    1: 
29018:     nsIDOMWindow* win = doc->GetWindow();
29018:     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:     if (win && fm)
29018:       return fm->ClearFocus(win);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULElement::Click()
    1: {
40485:   return ClickWithInputSource(nsIDOMNSMouseEvent::MOZ_SOURCE_UNKNOWN);
40485: }
40485: 
40485: nsresult
40485: nsXULElement::ClickWithInputSource(PRUint16 aInputSource)
40485: {
    1:     if (BoolAttrIsTrue(nsGkAtoms::disabled))
    1:         return NS_OK;
    1: 
    1:     nsCOMPtr<nsIDocument> doc = GetCurrentDoc(); // Strong just in case
    1:     if (doc) {
46225:         nsCOMPtr<nsIPresShell> shell = doc->GetShell();
36917:         if (shell) {
    1:             // strong ref to PresContext so events don't destroy it
39823:             nsRefPtr<nsPresContext> context = shell->GetPresContext();
    1: 
    1:             PRBool isCallerChrome = nsContentUtils::IsCallerChrome();
    1: 
    1:             nsMouseEvent eventDown(isCallerChrome, NS_MOUSE_BUTTON_DOWN,
    1:                                    nsnull, nsMouseEvent::eReal);
    1:             nsMouseEvent eventUp(isCallerChrome, NS_MOUSE_BUTTON_UP,
    1:                                  nsnull, nsMouseEvent::eReal);
    1:             nsMouseEvent eventClick(isCallerChrome, NS_MOUSE_CLICK, nsnull,
    1:                                     nsMouseEvent::eReal);
40485:             eventDown.inputSource = eventUp.inputSource = eventClick.inputSource 
40485:                                   = aInputSource;
    1: 
    1:             // send mouse down
    1:             nsEventStatus status = nsEventStatus_eIgnore;
 3233:             nsEventDispatcher::Dispatch(static_cast<nsIContent*>(this),
    1:                                         context, &eventDown,  nsnull, &status);
    1: 
    1:             // send mouse up
    1:             status = nsEventStatus_eIgnore;  // reset status
 3233:             nsEventDispatcher::Dispatch(static_cast<nsIContent*>(this),
    1:                                         context, &eventUp, nsnull, &status);
    1: 
    1:             // send mouse click
    1:             status = nsEventStatus_eIgnore;  // reset status
 3233:             nsEventDispatcher::Dispatch(static_cast<nsIContent*>(this),
    1:                                         context, &eventClick, nsnull, &status);
    1:         }
    1:     }
    1: 
    1:     // oncommand is fired when an element is clicked...
    1:     return DoCommand();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXULElement::DoCommand()
    1: {
    1:     nsCOMPtr<nsIDocument> doc = GetCurrentDoc(); // strong just in case
    1:     if (doc) {
29844:         nsContentUtils::DispatchXULCommand(this, PR_TRUE);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsIContent *
    1: nsXULElement::GetBindingParent() const
    1: {
    1:     return mBindingParent;
    1: }
    1: 
    1: PRBool
    1: nsXULElement::IsNodeOfType(PRUint32 aFlags) const
    1: {
41646:     return !(aFlags & ~eCONTENT);
    1: }
    1: 
    1: static void
    1: PopupListenerPropertyDtor(void* aObject, nsIAtom* aPropertyName,
    1:                           void* aPropertyValue, void* aData)
    1: {
 3129:   nsIDOMEventListener* listener =
 3233:     static_cast<nsIDOMEventListener*>(aPropertyValue);
    1:   if (!listener) {
    1:     return;
    1:   }
29471:   nsCOMPtr<nsIDOM3EventTarget> target =
 3233:     do_QueryInterface(static_cast<nsINode*>(aObject));
    1:   if (target) {
29471:     nsCOMPtr<nsIDOMEventGroup> systemGroup;
29471:     static_cast<nsPIDOMEventTarget*>(aObject)->
29471:       GetSystemEventGroup(getter_AddRefs(systemGroup));
29471:     if (systemGroup) {
29471:       target->RemoveGroupedEventListener(NS_LITERAL_STRING("mousedown"),
29471:                                          listener, PR_FALSE, systemGroup);
29471: 
29471:       target->RemoveGroupedEventListener(NS_LITERAL_STRING("contextmenu"),
29471:                                          listener, PR_FALSE, systemGroup);
29471:     }
    1:   }
    1:   NS_RELEASE(listener);
    1: }
    1: 
    1: nsresult
    1: nsXULElement::AddPopupListener(nsIAtom* aName)
    1: {
 3129:     // Add a popup listener to the element
 3129:     PRBool isContext = (aName == nsGkAtoms::context ||
 3129:                         aName == nsGkAtoms::contextmenu);
 3129:     nsIAtom* listenerAtom = isContext ?
 3129:                             nsGkAtoms::contextmenulistener :
 3129:                             nsGkAtoms::popuplistener;
 3129: 
 3129:     nsCOMPtr<nsIDOMEventListener> popupListener =
 3233:         static_cast<nsIDOMEventListener*>(GetProperty(listenerAtom));
    1:     if (popupListener) {
    1:         // Popup listener is already installed.
    1:         return NS_OK;
    1:     }
 3129: 
29471:     nsCOMPtr<nsIDOMEventGroup> systemGroup;
29471:     GetSystemEventGroup(getter_AddRefs(systemGroup));
29471:     NS_ENSURE_STATE(systemGroup);
29471: 
 3129:     nsresult rv = NS_NewXULPopupListener(this, isContext,
 3129:                                          getter_AddRefs(popupListener));
 3129:     if (NS_FAILED(rv))
 3129:         return rv;
    1: 
    1:     // Add the popup as a listener on this element.
29471:     nsCOMPtr<nsIDOM3EventTarget> target(do_QueryInterface(static_cast<nsIContent *>(this)));
    1:     NS_ENSURE_TRUE(target, NS_ERROR_FAILURE);
    1:     rv = SetProperty(listenerAtom, popupListener, PopupListenerPropertyDtor,
    1:                      PR_TRUE);
    1:     NS_ENSURE_SUCCESS(rv, rv);
 3129:     // Want the property to have a reference to the listener.
 3129:     nsIDOMEventListener* listener = nsnull;
 3129:     popupListener.swap(listener);
29471: 
29471:     if (isContext) {
29471:       target->AddGroupedEventListener(NS_LITERAL_STRING("contextmenu"),
29471:                                       listener, PR_FALSE, systemGroup);
29471:     } else {
29471:       target->AddGroupedEventListener(NS_LITERAL_STRING("mousedown"),
29471:                                       listener, PR_FALSE, systemGroup);
29471:     }
    1:     return NS_OK;
    1: }
    1: 
56168: nsEventStates
 2896: nsXULElement::IntrinsicState() const
 2896: {
56168:     nsEventStates state = nsStyledElement::IntrinsicState();
 2896: 
 2896:     const nsIAtom* tag = Tag();
 2896:     if (GetNameSpaceID() == kNameSpaceID_XUL &&
 2896:         (tag == nsGkAtoms::textbox || tag == nsGkAtoms::textarea) &&
 2896:         !HasAttr(kNameSpaceID_None, nsGkAtoms::readonly)) {
 2896:         state |= NS_EVENT_STATE_MOZ_READWRITE;
 2896:         state &= ~NS_EVENT_STATE_MOZ_READONLY;
 2896:     }
 2896: 
 2896:     return state;
 2896: }
 2896: 
    1: //----------------------------------------------------------------------
    1: 
    1: nsGenericElement::nsAttrInfo
    1: nsXULElement::GetAttrInfo(PRInt32 aNamespaceID, nsIAtom *aName) const
    1: {
    1: 
38452:     nsAttrInfo info(nsStyledElement::GetAttrInfo(aNamespaceID, aName));
    1:     if (!info.mValue) {
    1:         nsXULPrototypeAttribute *protoattr =
    1:             FindPrototypeAttribute(aNamespaceID, aName);
    1:         if (protoattr) {
    1:             return nsAttrInfo(&protoattr->mName, &protoattr->mValue);
    1:         }
    1:     }
    1: 
    1:     return info;
    1: }
    1: 
    1: 
    1: nsXULPrototypeAttribute *
    1: nsXULElement::FindPrototypeAttribute(PRInt32 aNamespaceID,
    1:                                      nsIAtom* aLocalName) const
    1: {
    1:     if (!mPrototype) {
    1:         return nsnull;
    1:     }
    1: 
    1:     PRUint32 i, count = mPrototype->mNumAttributes;
    1:     if (aNamespaceID == kNameSpaceID_None) {
    1:         // Common case so optimize for this
    1:         for (i = 0; i < count; ++i) {
    1:             nsXULPrototypeAttribute *protoattr = &mPrototype->mAttributes[i];
    1:             if (protoattr->mName.Equals(aLocalName)) {
    1:                 return protoattr;
    1:             }
    1:         }
    1:     }
    1:     else {
    1:         for (i = 0; i < count; ++i) {
    1:             nsXULPrototypeAttribute *protoattr = &mPrototype->mAttributes[i];
    1:             if (protoattr->mName.Equals(aLocalName, aNamespaceID)) {
    1:                 return protoattr;
    1:             }
    1:         }
    1:     }
    1: 
    1:     return nsnull;
    1: }
    1: 
    1: nsresult nsXULElement::MakeHeavyweight()
    1: {
    1:     if (!mPrototype)
    1:         return NS_OK;           // already heavyweight
    1: 
    1:     nsRefPtr<nsXULPrototypeElement> proto;
    1:     proto.swap(mPrototype);
    1: 
    1:     PRBool hadAttributes = mAttrsAndChildren.AttrCount() > 0;
    1: 
    1:     PRUint32 i;
    1:     nsresult rv;
    1:     for (i = 0; i < proto->mNumAttributes; ++i) {
    1:         nsXULPrototypeAttribute* protoattr = &proto->mAttributes[i];
    1: 
    1:         // We might have a local value for this attribute, in which case
    1:         // we don't want to copy the prototype's value.
    1:         if (hadAttributes &&
    1:             mAttrsAndChildren.GetAttr(protoattr->mName.LocalName(),
    1:                                       protoattr->mName.NamespaceID())) {
    1:             continue;
    1:         }
    1: 
50380:         nsAttrValue attrValue;
50380:         
50380:         // Style rules need to be cloned.
50380:         if (protoattr->mValue.Type() == nsAttrValue::eCSSStyleRule) {
50636:             nsCOMPtr<nsICSSRule> ruleClone =
50636:                 protoattr->mValue.GetCSSStyleRuleValue()->Clone();
50380: 
50380:             nsString stringValue;
50380:             protoattr->mValue.ToString(stringValue);
50380: 
63693:             nsRefPtr<css::StyleRule> styleRule = do_QueryObject(ruleClone);
50380:             attrValue.SetTo(styleRule, &stringValue);
50380:         }
50380:         else {
50380:             attrValue.SetTo(protoattr->mValue);
50380:         }
50380: 
    1:         // XXX we might wanna have a SetAndTakeAttr that takes an nsAttrName
    1:         if (protoattr->mName.IsAtom()) {
    1:             rv = mAttrsAndChildren.SetAndTakeAttr(protoattr->mName.Atom(), attrValue);
    1:         }
    1:         else {
    1:             rv = mAttrsAndChildren.SetAndTakeAttr(protoattr->mName.NodeInfo(),
    1:                                                   attrValue);
    1:         }
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULElement::HideWindowChrome(PRBool aShouldHide)
    1: {
    1:     nsIDocument* doc = GetCurrentDoc();
41634:     if (!doc || doc->GetRootElement() != this)
    1:       return NS_ERROR_UNEXPECTED;
    1: 
 4856:     // only top level chrome documents can hide the window chrome
20078:     if (!doc->IsRootDisplayDocument())
 4856:       return NS_OK;
 4856: 
46225:     nsIPresShell *shell = doc->GetShell();
    1: 
    1:     if (shell) {
36655:         nsIFrame* frame = GetPrimaryFrame();
    1: 
    1:         nsPresContext *presContext = shell->GetPresContext();
    1: 
 4856:         if (frame && presContext && presContext->IsChrome()) {
    1:             nsIView* view = frame->GetClosestView();
    1: 
    1:             if (view) {
    1:                 nsIWidget* w = view->GetWidget();
    1:                 NS_ENSURE_STATE(w);
    1:                 w->HideWindowChrome(aShouldHide);
    1:             }
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
34053: nsIWidget*
34053: nsXULElement::GetWindowWidget()
 7242: {
 7242:     nsIDocument* doc = GetCurrentDoc();
 7242: 
 7242:     // only top level chrome documents can set the titlebar color
20078:     if (doc->IsRootDisplayDocument()) {
 7242:         nsCOMPtr<nsISupports> container = doc->GetContainer();
 7242:         nsCOMPtr<nsIBaseWindow> baseWindow = do_QueryInterface(container);
 7242:         if (baseWindow) {
 7242:             nsCOMPtr<nsIWidget> mainWidget;
 7242:             baseWindow->GetMainWidget(getter_AddRefs(mainWidget));
34053:             return mainWidget;
34053:         }
34053:     }
34053:     return nsnull;
34053: }
34053: 
34053: void
34053: nsXULElement::SetTitlebarColor(nscolor aColor, PRBool aActive)
34053: {
34053:     nsIWidget* mainWidget = GetWindowWidget();
 7242:     if (mainWidget) {
14886:         mainWidget->SetWindowTitlebarColor(aColor, aActive);
 7242:     }
 7242: }
34053: 
61932: class SetDrawInTitleBarEvent : public nsRunnable
61932: {
61932: public:
61932:   SetDrawInTitleBarEvent(nsIWidget* aWidget, PRBool aState)
61932:     : mWidget(aWidget)
61932:     , mState(aState)
61932:   {}
61932: 
61932:   NS_IMETHOD Run() {
61932:     NS_ASSERTION(mWidget, "You shouldn't call this runnable with a null widget!");
61932: 
61932:     mWidget->SetDrawsInTitlebar(mState);
61932:     return NS_OK;
61932:   }
61932: 
61932: private:
61932:   nsCOMPtr<nsIWidget> mWidget;
61932:   PRBool mState;
61932: };
61932: 
34053: void
34053: nsXULElement::SetDrawsInTitlebar(PRBool aState)
34053: {
34053:     nsIWidget* mainWidget = GetWindowWidget();
34053:     if (mainWidget) {
62308:         nsContentUtils::AddScriptRunner(new SetDrawInTitleBarEvent(mainWidget, aState));
 7242:     }
 7242: }
 7242: 
46199: void
46199: nsXULElement::SetChromeMargins(const nsAString* aValue)
46199: {
46199:     if (!aValue)
46199:         return;
46199: 
46199:     nsIWidget* mainWidget = GetWindowWidget();
46199:     if (!mainWidget)
46199:         return;
46199: 
46199:     // top, right, bottom, left - see nsAttrValue
46199:     nsAttrValue attrValue;
46199:     nsIntMargin margins;
46199: 
46199:     nsAutoString data;
46199:     data.Assign(*aValue);
46199:     if (attrValue.ParseIntMarginValue(data) &&
46199:         attrValue.GetIntMarginValue(margins)) {
46199:         mainWidget->SetNonClientMargins(margins);
46199:     }
46199: }
46199: 
46199: void
46199: nsXULElement::ResetChromeMargins()
46199: {
46199:     nsIWidget* mainWidget = GetWindowWidget();
46199:     if (!mainWidget)
46199:         return;
46199:     // See nsIWidget
46199:     nsIntMargin margins(-1,-1,-1,-1);
46199:     mainWidget->SetNonClientMargins(margins);
46199: }
46199: 
    1: PRBool
    1: nsXULElement::BoolAttrIsTrue(nsIAtom* aName)
    1: {
    1:     const nsAttrValue* attr =
    1:         FindLocalOrProtoAttr(kNameSpaceID_None, aName);
    1: 
    1:     return attr && attr->Type() == nsAttrValue::eAtom &&
    1:            attr->GetAtomValue() == nsGkAtoms::_true;
    1: }
    1: 
    1: void
    1: nsXULElement::RecompileScriptEventListeners()
    1: {
    1:     PRInt32 i, count = mAttrsAndChildren.AttrCount();
    1:     PRBool haveLocalAttributes = (count > 0);
    1:     for (i = 0; i < count; ++i) {
    1:         const nsAttrName *name = mAttrsAndChildren.AttrNameAt(i);
    1: 
    1:         // Eventlistenener-attributes are always in the null namespace
    1:         if (!name->IsAtom()) {
    1:             continue;
    1:         }
    1: 
    1:         nsIAtom *attr = name->Atom();
  265:         if (!nsContentUtils::IsEventAttributeName(attr, EventNameType_XUL)) {
    1:             continue;
    1:         }
    1: 
    1:         nsAutoString value;
    1:         GetAttr(kNameSpaceID_None, attr, value);
    1:         AddScriptEventListener(attr, value, PR_TRUE);
    1:     }
    1: 
    1:     if (mPrototype) {
    1:         // If we have a prototype, the node we are binding to should
    1:         // have the same script-type - otherwise we will compile the
    1:         // event handlers incorrectly.
    1:         NS_ASSERTION(mPrototype->mScriptTypeID == GetScriptTypeID(),
    1:                      "Prototype and node confused about default language?");
    1: 
    1:         count = mPrototype->mNumAttributes;
    1:         for (i = 0; i < count; ++i) {
    1:             const nsAttrName &name = mPrototype->mAttributes[i].mName;
    1: 
    1:             // Eventlistenener-attributes are always in the null namespace
    1:             if (!name.IsAtom()) {
    1:                 continue;
    1:             }
    1: 
    1:             nsIAtom *attr = name.Atom();
    1: 
    1:             // Don't clobber a locally modified attribute.
    1:             if (haveLocalAttributes && mAttrsAndChildren.GetAttr(attr)) {
    1:                 continue;
    1:             }
    1: 
  265:             if (!nsContentUtils::IsEventAttributeName(attr, EventNameType_XUL)) {
    1:                 continue;
    1:             }
    1: 
    1:             nsAutoString value;
    1:             GetAttr(kNameSpaceID_None, attr, value);
    1:             AddScriptEventListener(attr, value, PR_TRUE);
    1:         }
    1:     }
    1: }
    1: 
 7230: NS_IMPL_CYCLE_COLLECTION_CLASS(nsXULPrototypeNode)
 7286: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_NATIVE(nsXULPrototypeNode)
 7286:     if (tmp->mType == nsXULPrototypeNode::eType_Element) {
 7286:         static_cast<nsXULPrototypeElement*>(tmp)->Unlink();
 7286:     }
67680:     else if (tmp->mType == nsXULPrototypeNode::eType_Script) {
67680:         static_cast<nsXULPrototypeScript*>(tmp)->UnlinkJSObjects();
67680:     }
 7286: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 1829: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_BEGIN(nsXULPrototypeNode)
 1829:     if (tmp->mType == nsXULPrototypeNode::eType_Element) {
 1829:         nsXULPrototypeElement *elem =
 3233:             static_cast<nsXULPrototypeElement*>(tmp);
13669:         cb.NoteXPCOMChild(elem->mNodeInfo);
 1829:         PRUint32 i;
13669:         for (i = 0; i < elem->mNumAttributes; ++i) {
13669:             const nsAttrName& name = elem->mAttributes[i].mName;
13669:             if (!name.IsAtom())
13669:                 cb.NoteXPCOMChild(name.NodeInfo());
13669:         }
20136:         for (i = 0; i < elem->mChildren.Length(); ++i) {
20136:             NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_PTR(elem->mChildren[i].get(),
13202:                                                          nsXULPrototypeNode,
13202:                                                          "mChildren[i]")
 1829:         }
 1829:     }
 7230:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
 7230: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 7230: NS_IMPL_CYCLE_COLLECTION_TRACE_NATIVE_BEGIN(nsXULPrototypeNode)
 7230:     if (tmp->mType == nsXULPrototypeNode::eType_Element) {
 7230:         nsXULPrototypeElement *elem =
 7230:             static_cast<nsXULPrototypeElement*>(tmp);
 7230:         if (elem->mHoldsScriptObject) {
 7230:             PRUint32 i;
 7230:             for (i = 0; i < elem->mNumAttributes; ++i) {
 7230:                 void *handler = elem->mAttributes[i].mEventHandler;
 7230:                 NS_IMPL_CYCLE_COLLECTION_TRACE_CALLBACK(elem->mScriptTypeID,
 7230:                                                         handler)
 7230:             }
 7230:         }
 7230:     }
 7227:     else if (tmp->mType == nsXULPrototypeNode::eType_Script) {
 7230:         nsXULPrototypeScript *script =
 7230:             static_cast<nsXULPrototypeScript*>(tmp);
 7230:         NS_IMPL_CYCLE_COLLECTION_TRACE_CALLBACK(script->mScriptObject.mLangID,
 7230:                                                 script->mScriptObject.mObject)
 7227:     }
 7230: NS_IMPL_CYCLE_COLLECTION_TRACE_END
67680: NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE(nsXULPrototypeNode, AddRef)
 1829: NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE(nsXULPrototypeNode, Release)
 1829: 
    1: //----------------------------------------------------------------------
    1: //
    1: // nsXULPrototypeAttribute
    1: //
    1: 
    1: nsXULPrototypeAttribute::~nsXULPrototypeAttribute()
    1: {
    1:     MOZ_COUNT_DTOR(nsXULPrototypeAttribute);
    1: }
    1: 
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: // nsXULPrototypeElement
    1: //
    1: 
    1: nsresult
    1: nsXULPrototypeElement::Serialize(nsIObjectOutputStream* aStream,
    1:                                  nsIScriptGlobalObject* aGlobal,
    1:                                  const nsCOMArray<nsINodeInfo> *aNodeInfos)
    1: {
    1:     nsresult rv;
    1: 
    1:     // Write basic prototype data
    1:     rv = aStream->Write32(mType);
    1: 
    1:     // Write script language
    1:     rv |= aStream->Write32(mScriptTypeID);
    1: 
    1:     // Write Node Info
    1:     PRInt32 index = aNodeInfos->IndexOf(mNodeInfo);
    1:     NS_ASSERTION(index >= 0, "unknown nsINodeInfo index");
    1:     rv |= aStream->Write32(index);
    1: 
    1:     // Write Attributes
    1:     rv |= aStream->Write32(mNumAttributes);
    1: 
    1:     nsAutoString attributeValue;
    1:     PRUint32 i;
    1:     for (i = 0; i < mNumAttributes; ++i) {
    1:         nsCOMPtr<nsINodeInfo> ni;
    1:         if (mAttributes[i].mName.IsAtom()) {
19197:             ni = mNodeInfo->NodeInfoManager()->
    1:                 GetNodeInfo(mAttributes[i].mName.Atom(), nsnull,
19197:                             kNameSpaceID_None);
    1:             NS_ASSERTION(ni, "the nodeinfo should already exist");
    1:         }
    1:         else {
    1:             ni = mAttributes[i].mName.NodeInfo();
    1:         }
    1: 
    1:         index = aNodeInfos->IndexOf(ni);
    1:         NS_ASSERTION(index >= 0, "unknown nsINodeInfo index");
    1:         rv |= aStream->Write32(index);
    1: 
    1:         mAttributes[i].mValue.ToString(attributeValue);
    1:         rv |= aStream->WriteWStringZ(attributeValue.get());
    1:     }
    1: 
    1:     // Now write children
20136:     rv |= aStream->Write32(PRUint32(mChildren.Length()));
20136:     for (i = 0; i < mChildren.Length(); i++) {
20136:         nsXULPrototypeNode* child = mChildren[i].get();
    1:         switch (child->mType) {
    1:         case eType_Element:
    1:         case eType_Text:
    1:         case eType_PI:
    1:             rv |= child->Serialize(aStream, aGlobal, aNodeInfos);
    1:             break;
    1:         case eType_Script:
    1:             rv |= aStream->Write32(child->mType);
 3233:             nsXULPrototypeScript* script = static_cast<nsXULPrototypeScript*>(child);
    1: 
    1:             rv |= aStream->Write32(script->mScriptObject.mLangID);
    1: 
    1:             rv |= aStream->Write8(script->mOutOfLine);
    1:             if (! script->mOutOfLine) {
    1:                 rv |= script->Serialize(aStream, aGlobal, aNodeInfos);
    1:             } else {
    1:                 rv |= aStream->WriteCompoundObject(script->mSrcURI,
    1:                                                    NS_GET_IID(nsIURI),
    1:                                                    PR_TRUE);
    1: 
    1:                 if (script->mScriptObject.mObject) {
    1:                     // This may return NS_OK without muxing script->mSrcURI's
    1:                     // data into the FastLoad file, in the case where that
    1:                     // muxed document is already there (written by a prior
    1:                     // session, or by an earlier FastLoad episode during this
    1:                     // session).
    1:                     rv |= script->SerializeOutOfLine(aStream, aGlobal);
    1:                 }
    1:             }
    1:             break;
    1:         }
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsXULPrototypeElement::Deserialize(nsIObjectInputStream* aStream,
    1:                                    nsIScriptGlobalObject* aGlobal,
    1:                                    nsIURI* aDocumentURI,
    1:                                    const nsCOMArray<nsINodeInfo> *aNodeInfos)
    1: {
    1:     NS_PRECONDITION(aNodeInfos, "missing nodeinfo array");
    1:     nsresult rv;
    1: 
    1:     // Read script language
 6041:     PRUint32 scriptId = 0;
 6041:     rv = aStream->Read32(&scriptId);
 6041:     mScriptTypeID = scriptId;
 6041: 
    1:     // Read Node Info
    1:     PRUint32 number;
    1:     rv |= aStream->Read32(&number);
    1:     mNodeInfo = aNodeInfos->SafeObjectAt(number);
    1:     if (!mNodeInfo)
    1:         return NS_ERROR_UNEXPECTED;
    1: 
    1:     // Read Attributes
    1:     rv |= aStream->Read32(&number);
    1:     mNumAttributes = PRInt32(number);
    1: 
    1:     PRUint32 i;
    1:     if (mNumAttributes > 0) {
    1:         mAttributes = new nsXULPrototypeAttribute[mNumAttributes];
    1:         if (! mAttributes)
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:         nsAutoString attributeValue;
    1:         for (i = 0; i < mNumAttributes; ++i) {
    1:             rv |= aStream->Read32(&number);
    1:             nsINodeInfo* ni = aNodeInfos->SafeObjectAt(number);
    1:             if (!ni)
    1:                 return NS_ERROR_UNEXPECTED;
    1: 
    1:             mAttributes[i].mName.SetTo(ni);
    1: 
    1:             rv |= aStream->ReadString(attributeValue);
    1:             rv |= SetAttrAt(i, attributeValue, aDocumentURI);
    1:         }
    1:     }
    1: 
    1:     rv |= aStream->Read32(&number);
20136:     PRUint32 numChildren = PRInt32(number);
20136: 
20136:     if (numChildren > 0) {
20136:         if (!mChildren.SetCapacity(numChildren))
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1: 
20136:         for (i = 0; i < numChildren; i++) {
    1:             rv |= aStream->Read32(&number);
    1:             Type childType = (Type)number;
    1: 
20136:             nsRefPtr<nsXULPrototypeNode> child;
    1: 
    1:             switch (childType) {
    1:             case eType_Element:
    1:                 child = new nsXULPrototypeElement();
    1:                 if (! child)
    1:                     return NS_ERROR_OUT_OF_MEMORY;
    1:                 child->mType = childType;
    1: 
    1:                 rv |= child->Deserialize(aStream, aGlobal, aDocumentURI,
    1:                                          aNodeInfos);
    1:                 break;
    1:             case eType_Text:
    1:                 child = new nsXULPrototypeText();
    1:                 if (! child)
    1:                     return NS_ERROR_OUT_OF_MEMORY;
    1:                 child->mType = childType;
    1: 
    1:                 rv |= child->Deserialize(aStream, aGlobal, aDocumentURI,
    1:                                          aNodeInfos);
    1:                 break;
    1:             case eType_PI:
    1:                 child = new nsXULPrototypePI();
    1:                 if (! child)
    1:                     return NS_ERROR_OUT_OF_MEMORY;
    1:                 child->mType = childType;
    1: 
    1:                 rv |= child->Deserialize(aStream, aGlobal, aDocumentURI,
    1:                                          aNodeInfos);
    1:                 break;
    1:             case eType_Script: {
    1:                 PRUint32 langID = nsIProgrammingLanguage::UNKNOWN;
    1:                 rv |= aStream->Read32(&langID);
    1: 
    1:                 // language version/options obtained during deserialization.
    1:                 nsXULPrototypeScript* script = new nsXULPrototypeScript(langID, 0, 0);
    1:                 if (! script)
    1:                     return NS_ERROR_OUT_OF_MEMORY;
    1:                 child = script;
    1:                 child->mType = childType;
    1: 
    1:                 rv |= aStream->Read8(&script->mOutOfLine);
    1:                 if (! script->mOutOfLine) {
    1:                     rv |= script->Deserialize(aStream, aGlobal, aDocumentURI,
    1:                                               aNodeInfos);
    1:                 } else {
    1:                     rv |= aStream->ReadObject(PR_TRUE, getter_AddRefs(script->mSrcURI));
    1: 
    1:                     rv |= script->DeserializeOutOfLine(aStream, aGlobal);
    1:                 }
    1:                 // If we failed to deserialize, consider deleting 'script'?
    1:                 break;
    1:             }
    1:             default:
    1:                 NS_NOTREACHED("Unexpected child type!");
    1:                 rv = NS_ERROR_UNEXPECTED;
    1:             }
    1: 
20136:             mChildren.AppendElement(child);
    1: 
    1:             // Oh dear. Something failed during the deserialization.
    1:             // We don't know what.  But likely consequences of failed
    1:             // deserializations included calls to |AbortFastLoads| which
    1:             // shuts down the FastLoadService and closes our streams.
    1:             // If that happens, next time through this loop, we die a messy
    1:             // death. So, let's just fail now, and propagate that failure
    1:             // upward so that the ChromeProtocolHandler knows it can't use
    1:             // a cached chrome channel for this.
    1:             if (NS_FAILED(rv))
    1:                 return rv;
    1:         }
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsXULPrototypeElement::SetAttrAt(PRUint32 aPos, const nsAString& aValue,
    1:                                  nsIURI* aDocumentURI)
    1: {
    1:     NS_PRECONDITION(aPos < mNumAttributes, "out-of-bounds");
    1: 
    1:     // WARNING!!
    1:     // This code is largely duplicated in nsXULElement::SetAttr.
    1:     // Any changes should be made to both functions.
    1: 
    1:     if (!mNodeInfo->NamespaceEquals(kNameSpaceID_XUL)) {
    1:         mAttributes[aPos].mValue.ParseStringOrAtom(aValue);
    1: 
    1:         return NS_OK;
    1:     }
    1: 
    1:     if (mAttributes[aPos].mName.Equals(nsGkAtoms::id) &&
    1:         !aValue.IsEmpty()) {
 6041:         mHasIdAttribute = PR_TRUE;
    1:         // Store id as atom.
    1:         // id="" means that the element has no id. Not that it has
    1:         // emptystring as id.
    1:         mAttributes[aPos].mValue.ParseAtom(aValue);
    1: 
    1:         return NS_OK;
    1:     }
    1:     else if (mAttributes[aPos].mName.Equals(nsGkAtoms::_class)) {
 6041:         mHasClassAttribute = PR_TRUE;
    1:         // Compute the element's class list
    1:         mAttributes[aPos].mValue.ParseAtomArray(aValue);
    1: 
    1:         return NS_OK;
    1:     }
    1:     else if (mAttributes[aPos].mName.Equals(nsGkAtoms::style)) {
 6041:         mHasStyleAttribute = PR_TRUE;
    1:         // Parse the element's 'style' attribute
63693:         nsRefPtr<css::StyleRule> rule;
38849: 
38849:         nsCSSParser parser;
    1: 
    1:         // XXX Get correct Base URI (need GetBaseURI on *prototype* element)
38849:         parser.ParseStyleAttribute(aValue, aDocumentURI, aDocumentURI,
 1036:                                    // This is basically duplicating what
 1036:                                    // nsINode::NodePrincipal() does
 1036:                                    mNodeInfo->NodeInfoManager()->
 1036:                                      DocumentPrincipal(),
    1:                                    getter_AddRefs(rule));
    1:         if (rule) {
50380:             mAttributes[aPos].mValue.SetTo(rule, &aValue);
    1: 
    1:             return NS_OK;
    1:         }
    1:         // Don't abort if parsing failed, it could just be malformed css.
    1:     }
    1: 
    1:     mAttributes[aPos].mValue.ParseStringOrAtom(aValue);
    1: 
    1:     return NS_OK;
    1: }
    1: 
 7230: void
67680: nsXULPrototypeElement::Unlink()
 7230: {
 7230:     if (mHoldsScriptObject) {
 7230:         nsContentUtils::DropScriptObjects(mScriptTypeID, this,
 7230:                                           &NS_CYCLE_COLLECTION_NAME(nsXULPrototypeNode));
 7230:         mHoldsScriptObject = PR_FALSE;
 7230:     }
 7230:     mNumAttributes = 0;
 7230:     delete[] mAttributes;
 7230:     mAttributes = nsnull;
 7230: }
 7230: 
    1: //----------------------------------------------------------------------
    1: //
    1: // nsXULPrototypeScript
    1: //
    1: 
    1: nsXULPrototypeScript::nsXULPrototypeScript(PRUint32 aLangID, PRUint32 aLineNo, PRUint32 aVersion)
    1:     : nsXULPrototypeNode(eType_Script),
    1:       mLineNo(aLineNo),
    1:       mSrcLoading(PR_FALSE),
    1:       mOutOfLine(PR_TRUE),
    1:       mSrcLoadWaiters(nsnull),
    1:       mLangVersion(aVersion),
    1:       mScriptObject(aLangID)
    1: {
    1:     NS_ASSERTION(aLangID != nsIProgrammingLanguage::UNKNOWN,
    1:                  "The language ID must be known and constant");
    1: }
    1: 
    1: 
    1: nsXULPrototypeScript::~nsXULPrototypeScript()
    1: {
10981:     UnlinkJSObjects();
    1: }
    1: 
    1: nsresult
    1: nsXULPrototypeScript::Serialize(nsIObjectOutputStream* aStream,
    1:                                 nsIScriptGlobalObject* aGlobal,
    1:                                 const nsCOMArray<nsINodeInfo> *aNodeInfos)
    1: {
    1:     nsIScriptContext *context = aGlobal->GetScriptContext(
    1:                                         mScriptObject.mLangID);
    1:     NS_ASSERTION(!mSrcLoading || mSrcLoadWaiters != nsnull ||
    1:                  !mScriptObject.mObject,
    1:                  "script source still loading when serializing?!");
    1:     if (!mScriptObject.mObject)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     // Write basic prototype data
    1:     nsresult rv;
    1:     rv = aStream->Write32(mLineNo);
    1:     if (NS_FAILED(rv)) return rv;
    1:     rv = aStream->Write32(mLangVersion);
    1:     if (NS_FAILED(rv)) return rv;
    1:     // And delegate the writing to the nsIScriptContext
    1:     rv = context->Serialize(aStream, mScriptObject.mObject);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULPrototypeScript::SerializeOutOfLine(nsIObjectOutputStream* aStream,
    1:                                          nsIScriptGlobalObject* aGlobal)
    1: {
    1:     nsXULPrototypeCache* cache = nsXULPrototypeCache::GetInstance();
    1:     if (!cache)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     NS_ASSERTION(cache->IsEnabled(),
    1:                  "writing to the FastLoad file, but the XUL cache is off?");
    1: 
    1:     nsIFastLoadService* fastLoadService = cache->GetFastLoadService();
    1:     if (!fastLoadService)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:     nsCAutoString urispec;
    1:     nsresult rv = mSrcURI->GetAsciiSpec(urispec);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     PRBool exists = PR_FALSE;
    1:     fastLoadService->HasMuxedDocument(urispec.get(), &exists);
    1:     /* return will be NS_OK from GetAsciiSpec.
    1:      * that makes no sense.
    1:      * nor does returning NS_OK from HasMuxedDocument.
    1:      * XXX return something meaningful.
    1:      */
    1:     if (exists)
    1:         return NS_OK;
    1: 
    1:     // Allow callers to pass null for aStream, meaning
    1:     // "use the FastLoad service's default output stream."
    1:     // See nsXULDocument.cpp for one use of this.
    1:     nsCOMPtr<nsIObjectOutputStream> objectOutput = aStream;
    1:     if (! objectOutput) {
    1:         fastLoadService->GetOutputStream(getter_AddRefs(objectOutput));
    1:         if (! objectOutput)
    1:             return NS_ERROR_NOT_AVAILABLE;
    1:     }
    1: 
    1:     rv = fastLoadService->
    1:          StartMuxedDocument(mSrcURI, urispec.get(),
    1:                             nsIFastLoadService::NS_FASTLOAD_WRITE);
    1:     NS_ASSERTION(rv != NS_ERROR_NOT_AVAILABLE, "reading FastLoad?!");
    1: 
    1:     nsCOMPtr<nsIURI> oldURI;
    1:     rv |= fastLoadService->SelectMuxedDocument(mSrcURI, getter_AddRefs(oldURI));
    1:     rv |= Serialize(objectOutput, aGlobal, nsnull);
    1:     rv |= fastLoadService->EndMuxedDocument(mSrcURI);
    1: 
    1:     if (oldURI) {
    1:         nsCOMPtr<nsIURI> tempURI;
    1:         rv |= fastLoadService->
    1:               SelectMuxedDocument(oldURI, getter_AddRefs(tempURI));
    1:     }
    1: 
    1:     if (NS_FAILED(rv))
    1:         cache->AbortFastLoads();
    1:     return rv;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsXULPrototypeScript::Deserialize(nsIObjectInputStream* aStream,
    1:                                   nsIScriptGlobalObject* aGlobal,
    1:                                   nsIURI* aDocumentURI,
    1:                                   const nsCOMArray<nsINodeInfo> *aNodeInfos)
    1: {
    1:     NS_TIMELINE_MARK_FUNCTION("chrome script deserialize");
    1:     nsresult rv;
    1: 
    1:     NS_ASSERTION(!mSrcLoading || mSrcLoadWaiters != nsnull ||
    1:                  !mScriptObject.mObject,
    1:                  "prototype script not well-initialized when deserializing?!");
    1: 
    1:     // Read basic prototype data
    1:     aStream->Read32(&mLineNo);
    1:     aStream->Read32(&mLangVersion);
    1: 
    1:     nsIScriptContext *context = aGlobal->GetScriptContext(
    1:                                             mScriptObject.mLangID);
    1:     NS_ASSERTION(context != nsnull, "Have no context for deserialization");
    1:     NS_ENSURE_TRUE(context, NS_ERROR_UNEXPECTED);
    1:     nsScriptObjectHolder newScriptObject(context);
    1:     rv = context->Deserialize(aStream, newScriptObject);
    1:     if (NS_FAILED(rv)) {
    1:         NS_WARNING("Language deseralization failed");
    1:         return rv;
    1:     }
 7230:     Set(newScriptObject);
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsXULPrototypeScript::DeserializeOutOfLine(nsIObjectInputStream* aInput,
    1:                                            nsIScriptGlobalObject* aGlobal)
    1: {
    1:     // Keep track of FastLoad failure via rv, so we can
    1:     // AbortFastLoads if things look bad.
    1:     nsresult rv = NS_OK;
    1: 
    1:     nsXULPrototypeCache* cache = nsXULPrototypeCache::GetInstance();
    1:     nsIFastLoadService* fastLoadService = cache->GetFastLoadService();
    1: 
    1:     // Allow callers to pass null for aInput, meaning
    1:     // "use the FastLoad service's default input stream."
    1:     // See nsXULContentSink.cpp for one use of this.
    1:     nsCOMPtr<nsIObjectInputStream> objectInput = aInput;
    1:     if (! objectInput && fastLoadService)
    1:         fastLoadService->GetInputStream(getter_AddRefs(objectInput));
    1: 
    1:     if (objectInput) {
    1:         PRBool useXULCache = PR_TRUE;
    1:         if (mSrcURI) {
    1:             // NB: we must check the XUL script cache early, to avoid
    1:             // multiple deserialization attempts for a given script, which
    1:             // would exhaust the multiplexed stream containing the singly
    1:             // serialized script.  Note that nsXULDocument::LoadScript
    1:             // checks the XUL script cache too, in order to handle the
    1:             // serialization case.
    1:             //
    1:             // We need do this only for <script src='strres.js'> and the
    1:             // like, i.e., out-of-line scripts that are included by several
    1:             // different XUL documents multiplexed in the FastLoad file.
    1:             useXULCache = cache->IsEnabled();
    1: 
    1:             if (useXULCache) {
    1:                 PRUint32 newLangID = nsIProgrammingLanguage::UNKNOWN;
    1:                 void *newScriptObject = cache->GetScript(mSrcURI, &newLangID);
    1:                 if (newScriptObject) {
    1:                     // Things may blow here if we simply change the script
    1:                     // language - other code may already have pre-fetched the
    1:                     // global for the language. (You can see this code by
    1:                     // setting langID to UNKNOWN in the nsXULPrototypeScript
    1:                     // ctor and not setting it until the scriptObject is set -
    1:                     // code that pre-fetches these globals will then start
    1:                     // asserting.)
    1:                     if (mScriptObject.mLangID != newLangID) {
    1:                         NS_ERROR("XUL cache gave different language?");
    1:                         return NS_ERROR_UNEXPECTED;
    1:                     }
 7230:                     Set(newScriptObject);
    1:                 }
    1:             }
    1:         }
    1: 
    1:         if (! mScriptObject.mObject) {
    1:             nsCOMPtr<nsIURI> oldURI;
    1: 
    1:             if (mSrcURI) {
    1:                 nsCAutoString spec;
    1:                 mSrcURI->GetAsciiSpec(spec);
    1:                 rv = fastLoadService->StartMuxedDocument(mSrcURI, spec.get(),
    1:                                                          nsIFastLoadService::NS_FASTLOAD_READ);
    1:                 if (NS_SUCCEEDED(rv))
    1:                     rv = fastLoadService->SelectMuxedDocument(mSrcURI, getter_AddRefs(oldURI));
    1:             } else {
    1:                 // An inline script: check FastLoad multiplexing direction
    1:                 // and skip Deserialize if we're not reading from a
    1:                 // muxed stream to get inline objects that are contained in
    1:                 // the current document.
    1:                 PRInt32 direction;
    1:                 fastLoadService->GetDirection(&direction);
    1:                 if (direction != nsIFastLoadService::NS_FASTLOAD_READ)
    1:                     rv = NS_ERROR_NOT_AVAILABLE;
    1:             }
    1: 
    1:             // We do reflect errors into rv, but our caller may want to
    1:             // ignore our return value, because mScriptObject will be null
    1:             // after any error, and that suffices to cause the script to
    1:             // be reloaded (from the src= URI, if any) and recompiled.
    1:             // We're better off slow-loading than bailing out due to a
    1:             // FastLoad error.
    1:             if (NS_SUCCEEDED(rv))
    1:                 rv = Deserialize(objectInput, aGlobal, nsnull, nsnull);
    1: 
    1:             if (NS_SUCCEEDED(rv) && mSrcURI) {
    1:                 rv = fastLoadService->EndMuxedDocument(mSrcURI);
    1: 
    1:                 if (NS_SUCCEEDED(rv) && oldURI) {
    1:                     nsCOMPtr<nsIURI> tempURI;
    1:                     rv = fastLoadService->SelectMuxedDocument(oldURI, getter_AddRefs(tempURI));
    1: 
    1:                     NS_ASSERTION(NS_SUCCEEDED(rv) && (!tempURI || tempURI == mSrcURI),
    1:                                  "not currently deserializing into the script we thought we were!");
    1:                 }
    1:             }
    1: 
    1:             if (NS_SUCCEEDED(rv)) {
    1:                 if (useXULCache && mSrcURI) {
    1:                     PRBool isChrome = PR_FALSE;
    1:                     mSrcURI->SchemeIs("chrome", &isChrome);
    1:                     if (isChrome) {
    1:                         cache->PutScript(mSrcURI,
    1:                                          mScriptObject.mLangID,
    1:                                          mScriptObject.mObject);
    1:                     }
    1:                 }
    1:             } else {
    1:                 // If mSrcURI is not in the FastLoad multiplex,
    1:                 // rv will be NS_ERROR_NOT_AVAILABLE and we'll try to
    1:                 // update the FastLoad file to hold a serialization of
    1:                 // this script, once it has finished loading.
    1:                 if (rv != NS_ERROR_NOT_AVAILABLE)
    1:                     cache->AbortFastLoads();
    1:             }
    1:         }
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsXULPrototypeScript::Compile(const PRUnichar* aText,
    1:                               PRInt32 aTextLength,
    1:                               nsIURI* aURI,
    1:                               PRUint32 aLineNo,
    1:                               nsIDocument* aDocument,
    1:                               nsIScriptGlobalObjectOwner* aGlobalOwner)
    1: {
    1:     // We'll compile the script using the prototype document's special
    1:     // script object as the parent. This ensures that we won't end up
    1:     // with an uncollectable reference.
    1:     //
    1:     // Compiling it using (for example) the first document's global
    1:     // object would cause JS to keep a reference via the __proto__ or
41968:     // parent pointer to the first document's global. If that happened,
41968:     // our script object would reference the first document, and the
41968:     // first document would indirectly reference the prototype document
41968:     // because it keeps the prototype cache alive. Circularity!
    1:     nsresult rv;
    1: 
    1:     // Use the prototype document's special context
    1:     nsIScriptContext *context;
    1: 
    1:     {
    1:         nsIScriptGlobalObject* global = aGlobalOwner->GetScriptGlobalObject();
    1:         NS_ASSERTION(global != nsnull, "prototype doc has no script global");
    1:         if (! global)
    1:             return NS_ERROR_UNEXPECTED;
    1: 
    1:         context = global->GetScriptContext(mScriptObject.mLangID);
    1:         NS_ASSERTION(context != nsnull, "no context for script global");
    1:         if (! context)
    1:             return NS_ERROR_UNEXPECTED;
    1:     }
    1: 
    1:     nsCAutoString urlspec;
21636:     nsContentUtils::GetWrapperSafeScriptFilename(aDocument, aURI, urlspec);
    1: 
    1:     // Ok, compile it to create a prototype script object!
    1: 
    1:     nsScriptObjectHolder newScriptObject(context);
    1:     rv = context->CompileScript(aText,
    1:                                 aTextLength,
    1:                                 nsnull,
    1:                                 // Use the enclosing document's principal
    1:                                 // XXX is this right? or should we use the
    1:                                 // protodoc's?
13464:                                 // If we start using the protodoc's, make sure
13464:                                 // the DowngradePrincipalIfNeeded stuff in
13464:                                 // nsXULDocument::OnStreamComplete still works!
    1:                                 aDocument->NodePrincipal(),
    1:                                 urlspec.get(),
    1:                                 aLineNo,
    1:                                 mLangVersion,
    1:                                 newScriptObject);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
 7230:     Set(newScriptObject);
    1:     return rv;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: // nsXULPrototypeText
    1: //
    1: 
    1: nsresult
    1: nsXULPrototypeText::Serialize(nsIObjectOutputStream* aStream,
    1:                               nsIScriptGlobalObject* aGlobal,
    1:                               const nsCOMArray<nsINodeInfo> *aNodeInfos)
    1: {
    1:     nsresult rv;
    1: 
    1:     // Write basic prototype data
    1:     rv = aStream->Write32(mType);
    1: 
    1:     rv |= aStream->WriteWStringZ(mValue.get());
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsXULPrototypeText::Deserialize(nsIObjectInputStream* aStream,
    1:                                 nsIScriptGlobalObject* aGlobal,
    1:                                 nsIURI* aDocumentURI,
    1:                                 const nsCOMArray<nsINodeInfo> *aNodeInfos)
    1: {
    1:     nsresult rv;
    1: 
    1:     rv = aStream->ReadString(mValue);
    1: 
    1:     return rv;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: //
    1: // nsXULPrototypePI
    1: //
    1: 
    1: nsresult
    1: nsXULPrototypePI::Serialize(nsIObjectOutputStream* aStream,
    1:                             nsIScriptGlobalObject* aGlobal,
    1:                             const nsCOMArray<nsINodeInfo> *aNodeInfos)
    1: {
    1:     nsresult rv;
    1: 
    1:     // Write basic prototype data
    1:     rv = aStream->Write32(mType);
    1: 
    1:     rv |= aStream->WriteWStringZ(mTarget.get());
    1:     rv |= aStream->WriteWStringZ(mData.get());
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsXULPrototypePI::Deserialize(nsIObjectInputStream* aStream,
    1:                               nsIScriptGlobalObject* aGlobal,
    1:                               nsIURI* aDocumentURI,
    1:                               const nsCOMArray<nsINodeInfo> *aNodeInfos)
    1: {
    1:     nsresult rv;
    1: 
    1:     rv = aStream->ReadString(mTarget);
    1:     rv |= aStream->ReadString(mData);
    1: 
    1:     return rv;
    1: }
