     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
     1: /* vim: set ts=2 sw=2 et tw=80: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
134925: #include "mozilla/Attributes.h"
134925: #include "mozilla/MathAlgorithms.h"
 54603: #include "mozilla/dom/TabParent.h"
 50731: 
     1: #include "nsCOMPtr.h"
     1: #include "nsEventStateManager.h"
     1: #include "nsEventListenerManager.h"
     1: #include "nsIMEStateManager.h"
 24836: #include "nsContentEventHandler.h"
     1: #include "nsIContent.h"
 94340: #include "nsINodeInfo.h"
     1: #include "nsIDocument.h"
     1: #include "nsIFrame.h"
     1: #include "nsIWidget.h"
     1: #include "nsPresContext.h"
     1: #include "nsIPresShell.h"
     1: #include "nsDOMEvent.h"
     1: #include "nsGkAtoms.h"
     1: #include "nsIFormControl.h"
     1: #include "nsIComboboxControlFrame.h"
 31443: #include "nsIScrollableFrame.h"
 81041: #include "nsIDOMHTMLElement.h"
     1: #include "nsIDOMXULControlElement.h"
     1: #include "nsINameSpaceManager.h"
     1: #include "nsIBaseWindow.h"
     1: #include "nsISelection.h"
     1: #include "nsFrameSelection.h"
     1: #include "nsPIDOMWindow.h"
 38336: #include "nsPIWindowRoot.h"
     1: #include "nsIEnumerator.h"
     1: #include "nsIWebNavigation.h"
     1: #include "nsIContentViewer.h"
129543: #include <algorithm>
  5298: #ifdef MOZ_XUL
  4709: #include "nsXULPopupManager.h"
  5298: #endif
 37058: #include "nsFrameManager.h"
     1: 
     1: #include "nsIServiceManager.h"
     1: #include "nsIScriptSecurityManager.h"
     1: 
 29018: #include "nsFocusManager.h"
     1: 
     1: #include "nsIDOMXULElement.h"
     1: #include "nsIDOMDocument.h"
     1: #include "nsIDOMKeyEvent.h"
     1: #include "nsIObserverService.h"
     1: #include "nsIDocShell.h"
     1: #include "nsIMarkupDocumentViewer.h"
108059: #include "nsIDOMWheelEvent.h"
 18445: #include "nsIDOMDragEvent.h"
     1: #include "nsIDOMEventTarget.h"
 77226: #include "nsIDOMUIEvent.h"
 18445: #include "nsDOMDragEvent.h"
 19703: #include "nsIDOMNSEditableElement.h"
 96948: #include "nsIDOMMozBrowserFrame.h"
 96948: #include "nsIMozBrowserFrame.h"
     1: 
 15969: #include "nsCaret.h"
     1: 
 51754: #include "nsSubDocumentFrame.h"
     1: #include "nsLayoutCID.h"
     1: #include "nsLayoutUtils.h"
     1: #include "nsIInterfaceRequestorUtils.h"
     1: #include "nsUnicharUtils.h"
     1: #include "nsContentUtils.h"
     1: 
     1: #include "imgIContainer.h"
     1: #include "nsIProperties.h"
     1: #include "nsISupportsPrimitives.h"
     1: #include "nsEventDispatcher.h"
     1: 
  7093: #include "nsServiceManagerUtils.h"
  7093: #include "nsITimer.h"
 68493: #include "nsFontMetrics.h"
 23192: #include "nsIDOMXULDocument.h"
 18445: #include "nsIDragService.h"
 18445: #include "nsIDragSession.h"
 18445: #include "nsDOMDataTransfer.h"
 18445: #include "nsContentAreaDragDrop.h"
 18445: #ifdef MOZ_XUL
 20988: #include "nsTreeBodyFrame.h"
 18445: #endif
 31218: #include "nsIController.h"
 36983: #include "nsICommandParams.h"
 41540: #include "mozilla/Services.h"
 64122: #include "mozAutoDocUpdate.h"
126764: #include "mozilla/dom/HTMLLabelElement.h"
 18445: 
 70840: #include "mozilla/Preferences.h"
 78124: #include "mozilla/LookAndFeel.h"
 84290: #include "sampler.h"
 70840: 
 95203: #include "nsIDOMClientRect.h"
 95203: 
     1: #ifdef XP_MACOSX
 32855: #import <ApplicationServices/ApplicationServices.h>
     1: #endif
     1: 
 70840: using namespace mozilla;
 54603: using namespace mozilla::dom;
 54603: 
     1: //#define DEBUG_DOCSHELL_FOCUS
     1: 
  7093: #define NS_USER_INTERACTION_INTERVAL 5000 // ms
  7093: 
115570: static const nsIntPoint kInvalidRefPoint = nsIntPoint(-1,-1);
115570: 
 79445: static bool sLeftClickOnly = true;
 79445: static bool sKeyCausesActivation = true;
108991: static uint32_t sESMInstanceCount = 0;
108991: static int32_t sChromeAccessModifier = 0, sContentAccessModifier = 0;
108991: int32_t nsEventStateManager::sUserInputEventDepth = 0;
 79445: bool nsEventStateManager::sNormalLMouseEventInProcess = false;
106838: nsEventStateManager* nsEventStateManager::sActiveESM = nullptr;
106838: nsIDocument* nsEventStateManager::sMouseOverDocument = nullptr;
106838: nsWeakFrame nsEventStateManager::sLastDragOverFrame = nullptr;
115570: nsIntPoint nsEventStateManager::sLastRefPoint = kInvalidRefPoint;
 95203: nsIntPoint nsEventStateManager::sLastScreenPoint = nsIntPoint(0,0);
115570: nsIntPoint nsEventStateManager::sSynthCenteringPoint = kInvalidRefPoint;
 95203: nsIntPoint nsEventStateManager::sLastClientPoint = nsIntPoint(0,0);
 95203: bool nsEventStateManager::sIsPointerLocked = false;
 95203: // Reference to the pointer locked element.
 95203: nsWeakPtr nsEventStateManager::sPointerLockedElement;
 95203: // Reference to the document which requested pointer lock.
 95203: nsWeakPtr nsEventStateManager::sPointerLockedDoc;
106838: nsCOMPtr<nsIContent> nsEventStateManager::sDragOverContent = nullptr;
     1: 
108991: static uint32_t gMouseOrKeyboardEventCounter = 0;
106838: static nsITimer* gUserInteractionTimer = nullptr;
106838: static nsITimerCallback* gUserInteractionTimerCallback = nullptr;
  7093: 
 77930: TimeStamp nsEventStateManager::sHandlingInputStart;
 77930: 
108052: nsEventStateManager::WheelPrefs*
108052:   nsEventStateManager::WheelPrefs::sInstance = nullptr;
108061: nsEventStateManager::DeltaAccumulator*
108061:   nsEventStateManager::DeltaAccumulator::sInstance = nullptr;
108052: 
108991: static inline int32_t
108059: RoundDown(double aDouble)
108059: {
108991:   return (aDouble > 0) ? static_cast<int32_t>(floor(aDouble)) :
108991:                          static_cast<int32_t>(ceil(aDouble));
108059: }
108059: 
 79445: static inline bool
 39761: IsMouseEventReal(nsEvent* aEvent)
 39761: {
 42296:   NS_ABORT_IF_FALSE(NS_IS_MOUSE_EVENT_STRUCT(aEvent), "Not a mouse event");
 39761:   // Return true if not synthesized.
 39761:   return static_cast<nsMouseEvent*>(aEvent)->reason == nsMouseEvent::eReal;
 39761: }
 39761: 
 21191: #ifdef DEBUG_DOCSHELL_FOCUS
 21191: static void
 21191: PrintDocTree(nsIDocShellTreeItem* aParentItem, int aLevel)
 21191: {
108991:   for (int32_t i=0;i<aLevel;i++) printf("  ");
108991: 
108991:   int32_t childWebshellCount;
 21191:   aParentItem->GetChildCount(&childWebshellCount);
 21191:   nsCOMPtr<nsIDocShell> parentAsDocShell(do_QueryInterface(aParentItem));
108991:   int32_t type;
 21191:   aParentItem->GetItemType(&type);
127381:   nsCOMPtr<nsIPresShell> presShell = parentAsDocShell->GetPresShell();
 39823:   nsRefPtr<nsPresContext> presContext;
 21191:   parentAsDocShell->GetPresContext(getter_AddRefs(presContext));
 21191:   nsCOMPtr<nsIContentViewer> cv;
 21191:   parentAsDocShell->GetContentViewer(getter_AddRefs(cv));
 21191:   nsCOMPtr<nsIDOMDocument> domDoc;
 21191:   if (cv)
 21191:     cv->GetDOMDocument(getter_AddRefs(domDoc));
 21191:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
106838:   nsCOMPtr<nsIDOMWindow> domwin = doc ? doc->GetWindow() : nullptr;
106838:   nsIURI* uri = doc ? doc->GetDocumentURI() : nullptr;
 21191: 
 21191:   printf("DS %p  Type %s  Cnt %d  Doc %p  DW %p  EM %p%c",
 21191:     static_cast<void*>(parentAsDocShell.get()),
 21191:     type==nsIDocShellTreeItem::typeChrome?"Chrome":"Content",
 21191:     childWebshellCount, static_cast<void*>(doc.get()),
 21191:     static_cast<void*>(domwin.get()),
106838:     static_cast<void*>(presContext ? presContext->EventStateManager() : nullptr),
 21191:     uri ? ' ' : '\n');
 21191:   if (uri) {
110974:     nsAutoCString spec;
 21191:     uri->GetSpec(spec);
 21191:     printf("\"%s\"\n", spec.get());
 21191:   }
 21191: 
 21191:   if (childWebshellCount > 0) {
108991:     for (int32_t i = 0; i < childWebshellCount; i++) {
 21191:       nsCOMPtr<nsIDocShellTreeItem> child;
 21191:       aParentItem->GetChildAt(i, getter_AddRefs(child));
 21191:       PrintDocTree(child, aLevel + 1);
 21191:     }
 21191:   }
 21191: }
 21191: 
 21191: static void
 21191: PrintDocTreeAll(nsIDocShellTreeItem* aItem)
 21191: {
 21191:   nsCOMPtr<nsIDocShellTreeItem> item = aItem;
 21191:   for(;;) {
 21191:     nsCOMPtr<nsIDocShellTreeItem> parent;
 21191:     item->GetParent(getter_AddRefs(parent));
 21191:     if (!parent)
 21191:       break;
 21191:     item = parent;
 21191:   }
 21191: 
 21191:   PrintDocTree(item, 0);
 21191: }
 21191: #endif
 21191: 
102310: class nsUITimerCallback MOZ_FINAL : public nsITimerCallback
  7093: {
  7093: public:
  7093:   nsUITimerCallback() : mPreviousCount(0) {}
  7093:   NS_DECL_ISUPPORTS
  7093:   NS_DECL_NSITIMERCALLBACK
  7093: private:
108991:   uint32_t mPreviousCount;
  7093: };
  7093: 
  7093: NS_IMPL_ISUPPORTS1(nsUITimerCallback, nsITimerCallback)
  7093: 
106838: // If aTimer is nullptr, this method always sends "user-interaction-inactive"
  7093: // notification.
  7093: NS_IMETHODIMP
  7093: nsUITimerCallback::Notify(nsITimer* aTimer)
  7093: {
  7093:   nsCOMPtr<nsIObserverService> obs =
 41540:     mozilla::services::GetObserverService();
 41540:   if (!obs)
 41540:     return NS_ERROR_FAILURE;
  7093:   if ((gMouseOrKeyboardEventCounter == mPreviousCount) || !aTimer) {
  7093:     gMouseOrKeyboardEventCounter = 0;
106838:     obs->NotifyObservers(nullptr, "user-interaction-inactive", nullptr);
 57074:     if (gUserInteractionTimer) {
 57074:       gUserInteractionTimer->Cancel();
 57074:       NS_RELEASE(gUserInteractionTimer);
 57074:     }
  7093:   } else {
106838:     obs->NotifyObservers(nullptr, "user-interaction-active", nullptr);
 57074:     nsEventStateManager::UpdateUserActivityTimer();
  7093:   }
  7093:   mPreviousCount = gMouseOrKeyboardEventCounter;
  7093:   return NS_OK;
  7093: }
  7093: 
     1: // mask values for ui.key.chromeAccess and ui.key.contentAccess
     1: #define NS_MODIFIER_SHIFT    1
     1: #define NS_MODIFIER_CONTROL  2
     1: #define NS_MODIFIER_ALT      4
     1: #define NS_MODIFIER_META     8
105732: #define NS_MODIFIER_OS       16
     1: 
     1: static nsIDocument *
     1: GetDocumentFromWindow(nsIDOMWindow *aWindow)
     1: {
     1:   nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(aWindow);
     1:   nsCOMPtr<nsIDocument> doc;
     1: 
     1:   if (win) {
     1:     doc = do_QueryInterface(win->GetExtantDocument());
     1:   }
     1: 
     1:   return doc;
     1: }
     1: 
108991: static int32_t
108991: GetAccessModifierMaskFromPref(int32_t aItemType)
     1: {
108991:   int32_t accessKey = Preferences::GetInt("ui.key.generalAccessKey", -1);
     1:   switch (accessKey) {
     1:     case -1:                             break; // use the individual prefs
     1:     case nsIDOMKeyEvent::DOM_VK_SHIFT:   return NS_MODIFIER_SHIFT;
     1:     case nsIDOMKeyEvent::DOM_VK_CONTROL: return NS_MODIFIER_CONTROL;
     1:     case nsIDOMKeyEvent::DOM_VK_ALT:     return NS_MODIFIER_ALT;
     1:     case nsIDOMKeyEvent::DOM_VK_META:    return NS_MODIFIER_META;
105732:     case nsIDOMKeyEvent::DOM_VK_WIN:     return NS_MODIFIER_OS;
     1:     default:                             return 0;
     1:   }
     1: 
     1:   switch (aItemType) {
     1:   case nsIDocShellTreeItem::typeChrome:
 70842:     return Preferences::GetInt("ui.key.chromeAccess", 0);
     1:   case nsIDocShellTreeItem::typeContent:
 70842:     return Preferences::GetInt("ui.key.contentAccess", 0);
     1:   default:
     1:     return 0;
     1:   }
     1: }
     1: 
108058: struct DeltaValues
108058: {
108058:   DeltaValues() : deltaX(0.0), deltaY(0.0) {}
108058: 
108058:   DeltaValues(double aDeltaX, double aDeltaY) :
108058:     deltaX(aDeltaX), deltaY(aDeltaY)
108058:   {
108058:   }
108058: 
108058:   explicit DeltaValues(widget::WheelEvent* aEvent) :
108058:     deltaX(aEvent->deltaX), deltaY(aEvent->deltaY)
108058:   {
108058:   }
108058: 
108058:   double deltaX;
108058:   double deltaY;
108058: };
108058: 
     1: class nsMouseWheelTransaction {
     1: public:
     1:   static nsIFrame* GetTargetFrame() { return sTargetFrame; }
     1:   static void BeginTransaction(nsIFrame* aTargetFrame,
108058:                                widget::WheelEvent* aEvent);
 25065:   // Be careful, UpdateTransaction may fire a DOM event, therefore, the target
 25065:   // frame might be destroyed in the event handler.
108058:   static bool UpdateTransaction(widget::WheelEvent* aEvent);
     1:   static void EndTransaction();
     1:   static void OnEvent(nsEvent* aEvent);
 24947:   static void Shutdown();
108991:   static uint32_t GetTimeoutTime();
108058: 
108058: 
108058:   static DeltaValues AccelerateWheelDelta(widget::WheelEvent* aEvent,
108058:                                           bool aAllowScrollSpeedOverride);
 32205: 
 32205:   enum {
 32205:     kScrollSeriesTimeout = 80
 32205:   };
     1: protected:
 23738:   static nsIntPoint GetScreenPoint(nsGUIEvent* aEvent);
 24947:   static void OnFailToScrollTarget();
 24947:   static void OnTimeout(nsITimer *aTimer, void *aClosure);
 24947:   static void SetTimeout();
108991:   static uint32_t GetIgnoreMoveDelayTime();
108991:   static int32_t GetAccelerationStart();
108991:   static int32_t GetAccelerationFactor();
108058:   static DeltaValues OverrideSystemScrollSpeed(widget::WheelEvent* aEvent);
108991:   static double ComputeAcceleratedWheelDelta(double aDelta, int32_t aFactor);
     1: 
     1:   static nsWeakFrame sTargetFrame;
108991:   static uint32_t    sTime;        // in milliseconds
108991:   static uint32_t    sMouseMoved;  // in milliseconds
 24947:   static nsITimer*   sTimer;
108991:   static int32_t     sScrollSeriesCounter;
     1: };
     1: 
106838: nsWeakFrame nsMouseWheelTransaction::sTargetFrame(nullptr);
108991: uint32_t    nsMouseWheelTransaction::sTime        = 0;
108991: uint32_t    nsMouseWheelTransaction::sMouseMoved  = 0;
106838: nsITimer*   nsMouseWheelTransaction::sTimer       = nullptr;
108991: int32_t     nsMouseWheelTransaction::sScrollSeriesCounter = 0;
 32205: 
 79445: static bool
108991: OutOfTime(uint32_t aBaseTime, uint32_t aThreshold)
 32205: {
108991:   uint32_t now = PR_IntervalToMilliseconds(PR_IntervalNow());
 32205:   return (now - aBaseTime > aThreshold);
 32205: }
 24947: 
 79445: static bool
108058: CanScrollInRange(nscoord aMin, nscoord aValue, nscoord aMax, double aDirection)
 37058: {
108058:   return aDirection > 0.0 ? aValue < static_cast<double>(aMax) :
108058:                             static_cast<double>(aMin) < aValue;
 37058: }
 37058: 
 79445: static bool
108058: CanScrollOn(nsIScrollableFrame* aScrollFrame, double aDeltaX, double aDeltaY)
 24947: {
108058:   MOZ_ASSERT(aScrollFrame);
108058:   NS_ASSERTION(aDeltaX || aDeltaY,
108058:                "One of the delta values must be non-zero at least");
108058: 
 37058:   nsPoint scrollPt = aScrollFrame->GetScrollPosition();
 37058:   nsRect scrollRange = aScrollFrame->GetScrollRange();
114765:   uint32_t directions = aScrollFrame->GetPerceivedScrollingDirections();
114765: 
114765:   return (aDeltaX && (directions & nsIScrollableFrame::HORIZONTAL) &&
114072:           CanScrollInRange(scrollRange.x, scrollPt.x, scrollRange.XMost(), aDeltaX)) ||
114765:          (aDeltaY && (directions & nsIScrollableFrame::VERTICAL) &&
114072:           CanScrollInRange(scrollRange.y, scrollPt.y, scrollRange.YMost(), aDeltaY));
 24947: }
     1: 
     1: void
     1: nsMouseWheelTransaction::BeginTransaction(nsIFrame* aTargetFrame,
108058:                                           widget::WheelEvent* aEvent)
     1: {
     1:   NS_ASSERTION(!sTargetFrame, "previous transaction is not finished!");
     1:   sTargetFrame = aTargetFrame;
 32205:   sScrollSeriesCounter = 0;
108058:   if (!UpdateTransaction(aEvent)) {
 24947:     NS_ERROR("BeginTransaction is called even cannot scroll the frame");
 24947:     EndTransaction();
 24947:   }
 24947: }
 24947: 
 79445: bool
108058: nsMouseWheelTransaction::UpdateTransaction(widget::WheelEvent* aEvent)
     1: {
 37058:   nsIScrollableFrame* sf = GetTargetFrame()->GetScrollTargetFrame();
 80486:   NS_ENSURE_TRUE(sf, false);
 37058: 
108058:   if (!CanScrollOn(sf, aEvent->deltaX, aEvent->deltaY)) {
 24947:     OnFailToScrollTarget();
 24947:     // We should not modify the transaction state when the view will not be
 24947:     // scrolled actually.
 80486:     return false;
 24947:   }
 24947: 
 24947:   SetTimeout();
 32205: 
 32205:   if (sScrollSeriesCounter != 0 && OutOfTime(sTime, kScrollSeriesTimeout))
 32205:     sScrollSeriesCounter = 0;
 32205:   sScrollSeriesCounter++;
 32205: 
     1:   // We should use current time instead of nsEvent.time.
     1:   // 1. Some events doesn't have the correct creation time.
     1:   // 2. If the computer runs slowly by other processes eating the CPU resource,
     1:   //    the event creation time doesn't keep real time.
     1:   sTime = PR_IntervalToMilliseconds(PR_IntervalNow());
     1:   sMouseMoved = 0;
 80486:   return true;
     1: }
     1: 
     1: void
     1: nsMouseWheelTransaction::EndTransaction()
     1: {
 24947:   if (sTimer)
 24947:     sTimer->Cancel();
106838:   sTargetFrame = nullptr;
 32205:   sScrollSeriesCounter = 0;
 75269: }
     1: 
     1: void
     1: nsMouseWheelTransaction::OnEvent(nsEvent* aEvent)
     1: {
     1:   if (!sTargetFrame)
     1:     return;
     1: 
     1:   if (OutOfTime(sTime, GetTimeoutTime())) {
 24947:     // Even if the scroll event which is handled after timeout, but onTimeout
 24947:     // was not fired by timer, then the scroll event will scroll old frame,
 24947:     // therefore, we should call OnTimeout here and ensure to finish the old
 24947:     // transaction.
106838:     OnTimeout(nullptr, nullptr);
     1:     return;
     1:   }
     1: 
108058:   switch (aEvent->message) {
108058:     case NS_WHEEL_WHEEL:
     1:       if (sMouseMoved != 0 &&
     1:           OutOfTime(sMouseMoved, GetIgnoreMoveDelayTime())) {
     1:         // Terminate the current mousewheel transaction if the mouse moved more
     1:         // than ignoremovedelay milliseconds ago
     1:         EndTransaction();
     1:       }
     1:       return;
     1:     case NS_MOUSE_MOVE:
     1:     case NS_DRAGDROP_OVER:
 39761:       if (IsMouseEventReal(aEvent)) {
     1:         // If the cursor is moving to be outside the frame,
     1:         // terminate the scrollwheel transaction.
 23738:         nsIntPoint pt = GetScreenPoint((nsGUIEvent*)aEvent);
     1:         nsIntRect r = sTargetFrame->GetScreenRectExternal();
     1:         if (!r.Contains(pt)) {
     1:           EndTransaction();
     1:           return;
     1:         }
     1: 
     1:         // If the cursor is moving inside the frame, and it is less than
     1:         // ignoremovedelay milliseconds since the last scroll operation, ignore
     1:         // the mouse move; otherwise, record the current mouse move time to be
     1:         // checked later
     1:         if (OutOfTime(sTime, GetIgnoreMoveDelayTime())) {
     1:           if (sMouseMoved == 0)
     1:             sMouseMoved = PR_IntervalToMilliseconds(PR_IntervalNow());
     1:         }
     1:       }
     1:       return;
     1:     case NS_KEY_PRESS:
     1:     case NS_KEY_UP:
     1:     case NS_KEY_DOWN:
     1:     case NS_MOUSE_BUTTON_UP:
     1:     case NS_MOUSE_BUTTON_DOWN:
     1:     case NS_MOUSE_DOUBLECLICK:
     1:     case NS_MOUSE_CLICK:
     1:     case NS_CONTEXTMENU:
     1:     case NS_DRAGDROP_DROP:
     1:       EndTransaction();
     1:       return;
     1:   }
     1: }
     1: 
 24947: void
 24947: nsMouseWheelTransaction::Shutdown()
 24947: {
 24947:   NS_IF_RELEASE(sTimer);
 24947: }
 24947: 
 24947: void
 24947: nsMouseWheelTransaction::OnFailToScrollTarget()
 24947: {
 24947:   NS_PRECONDITION(sTargetFrame, "We don't have mouse scrolling transaction");
 28026: 
 79445:   if (Preferences::GetBool("test.mousescroll", false)) {
 24947:     // This event is used for automated tests, see bug 442774.
 24947:     nsContentUtils::DispatchTrustedEvent(
 80526:                       sTargetFrame->GetContent()->OwnerDoc(),
 24947:                       sTargetFrame->GetContent(),
 24947:                       NS_LITERAL_STRING("MozMouseScrollFailed"),
 80486:                       true, true);
 28026:   }
 25065:   // The target frame might be destroyed in the event handler, at that time,
 25065:   // we need to finish the current transaction
 25065:   if (!sTargetFrame)
 25065:     EndTransaction();
 24947: }
 24947: 
 24947: void
 24947: nsMouseWheelTransaction::OnTimeout(nsITimer* aTimer, void* aClosure)
 24947: {
 24947:   if (!sTargetFrame) {
 24947:     // The transaction target was destroyed already
 24947:     EndTransaction();
 24947:     return;
 24947:   }
 24947:   // Store the sTargetFrame, the variable becomes null in EndTransaction.
 24947:   nsIFrame* frame = sTargetFrame;
 24947:   // We need to finish current transaction before DOM event firing. Because
 24947:   // the next DOM event might create strange situation for us.
 24947:   EndTransaction();
 28026: 
 79445:   if (Preferences::GetBool("test.mousescroll", false)) {
 24947:     // This event is used for automated tests, see bug 442774.
 24947:     nsContentUtils::DispatchTrustedEvent(
 80526:                       frame->GetContent()->OwnerDoc(),
 24947:                       frame->GetContent(),
 24947:                       NS_LITERAL_STRING("MozMouseScrollTransactionTimeout"),
 80486:                       true, true);
 24947:   }
 28026: }
 24947: 
 24947: void
 24947: nsMouseWheelTransaction::SetTimeout()
 24947: {
 24947:   if (!sTimer) {
 24947:     nsCOMPtr<nsITimer> timer = do_CreateInstance(NS_TIMER_CONTRACTID);
 24947:     if (!timer)
 24947:       return;
 24947:     timer.swap(sTimer);
 24947:   }
 24947:   sTimer->Cancel();
 68468: #ifdef DEBUG
 24947:   nsresult rv =
 68468: #endif
106838:   sTimer->InitWithFuncCallback(OnTimeout, nullptr, GetTimeoutTime(),
 24947:                                nsITimer::TYPE_ONE_SHOT);
 24947:   NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "nsITimer::InitWithFuncCallback failed");
 24947: }
 24947: 
 23738: nsIntPoint
     1: nsMouseWheelTransaction::GetScreenPoint(nsGUIEvent* aEvent)
     1: {
     1:   NS_ASSERTION(aEvent, "aEvent is null");
     1:   NS_ASSERTION(aEvent->widget, "aEvent-widget is null");
 25183:   return aEvent->refPoint + aEvent->widget->WidgetToScreenOffset();
     1: }
     1: 
108991: uint32_t
     1: nsMouseWheelTransaction::GetTimeoutTime()
     1: {
 70842:   return Preferences::GetUint("mousewheel.transaction.timeout", 1500);
     1: }
     1: 
108991: uint32_t
     1: nsMouseWheelTransaction::GetIgnoreMoveDelayTime()
     1: {
 70842:   return Preferences::GetUint("mousewheel.transaction.ignoremovedelay", 100);
     1: }
     1: 
108058: DeltaValues
108058: nsMouseWheelTransaction::AccelerateWheelDelta(widget::WheelEvent* aEvent,
108058:                                               bool aAllowScrollSpeedOverride)
 32205: {
108058:   DeltaValues result(aEvent);
108058: 
108058:   // Don't accelerate the delta values if the event isn't line scrolling.
108058:   if (aEvent->deltaMode != nsIDOMWheelEvent::DOM_DELTA_LINE) {
108058:     return result;
108058:   }
108058: 
 33016:   if (aAllowScrollSpeedOverride) {
108058:     result = OverrideSystemScrollSpeed(aEvent);
 33016:   }
 33016: 
 33016:   // Accelerate by the sScrollSeriesCounter
108991:   int32_t start = GetAccelerationStart();
 33016:   if (start >= 0 && sScrollSeriesCounter >= start) {
108991:     int32_t factor = GetAccelerationFactor();
 33016:     if (factor > 0) {
108058:       result.deltaX = ComputeAcceleratedWheelDelta(result.deltaX, factor);
108058:       result.deltaY = ComputeAcceleratedWheelDelta(result.deltaY, factor);
108058:     }
108058:   }
108058: 
108058:   return result;
108058: }
108058: 
108058: double
108058: nsMouseWheelTransaction::ComputeAcceleratedWheelDelta(double aDelta,
108991:                                                       int32_t aFactor)
 32205: {
108058:   if (aDelta == 0.0) {
 32205:     return 0;
108058:   }
108058: 
108058:   return (aDelta * sScrollSeriesCounter * (double)aFactor / 10);
 32205: }
 32205: 
108991: int32_t
 32205: nsMouseWheelTransaction::GetAccelerationStart()
 32205: {
 70842:   return Preferences::GetInt("mousewheel.acceleration.start", -1);
 32205: }
 32205: 
108991: int32_t
 32205: nsMouseWheelTransaction::GetAccelerationFactor()
 32205: {
 70842:   return Preferences::GetInt("mousewheel.acceleration.factor", -1);
 32205: }
 32205: 
108058: DeltaValues
108058: nsMouseWheelTransaction::OverrideSystemScrollSpeed(widget::WheelEvent* aEvent)
 33016: {
108058:   MOZ_ASSERT(sTargetFrame, "We don't have mouse scrolling transaction");
108058:   MOZ_ASSERT(aEvent->deltaMode == nsIDOMWheelEvent::DOM_DELTA_LINE);
108058: 
108058:   DeltaValues result(aEvent);
108058: 
108058:   // If the event doesn't scroll to both X and Y, we don't need to do anything
108058:   // here.  And also, if the event indicates the device supports high
108058:   // resolution scroll, we shouldn't need to override it.
108060:   if ((!aEvent->lineOrPageDeltaX && !aEvent->lineOrPageDeltaY) ||
108060:       (static_cast<double>(aEvent->lineOrPageDeltaX) != aEvent->deltaX) ||
108060:       (static_cast<double>(aEvent->lineOrPageDeltaY) != aEvent->deltaY)) {
108058:     return result;
 33016:   }
 33016: 
 33016:   // We shouldn't override the scrolling speed on non root scroll frame.
 33016:   if (sTargetFrame !=
 33016:         sTargetFrame->PresContext()->PresShell()->GetRootScrollFrame()) {
108058:     return result;
 33016:   }
 33016: 
 33016:   // Compute the overridden speed to nsIWidget.  The widget can check the
 33016:   // conditions (e.g., checking the prefs, and also whether the user customized
 33016:   // the system settings of the mouse wheel scrolling or not), and can limit
 33016:   // the speed for preventing the unexpected high speed scrolling.
 47148:   nsCOMPtr<nsIWidget> widget(sTargetFrame->GetNearestWidget());
108058:   NS_ENSURE_TRUE(widget, result);
108991:   int32_t overriddenDeltaX = 0, overriddenDeltaY = 0;
108060:   if (aEvent->lineOrPageDeltaX) {
108058:     nsresult rv =
108060:       widget->OverrideSystemMouseScrollSpeed(aEvent->lineOrPageDeltaX,
108058:                                              true, overriddenDeltaX);
108058:     if (NS_FAILED(rv)) {
108058:       return result;
108058:     }
108058:   }
108060:   if (aEvent->lineOrPageDeltaY) {
108058:     nsresult rv =
108060:       widget->OverrideSystemMouseScrollSpeed(aEvent->lineOrPageDeltaY,
108058:                                              false, overriddenDeltaY);
108058:     if (NS_FAILED(rv)) {
108058:       return result;
108058:     }
108058:   }
108058:   return DeltaValues(overriddenDeltaX, overriddenDeltaY);
 33016: }
 33016: 
     1: /******************************************************************/
     1: /* nsEventStateManager                                            */
     1: /******************************************************************/
     1: 
     1: nsEventStateManager::nsEventStateManager()
     1:   : mLockCursor(0),
 95203:     mPreLockPoint(0,0),
106838:     mCurrentTarget(nullptr),
106838:     mLastMouseOverFrame(nullptr),
     1:     // init d&d gesture state machine variables
     1:     mGestureDownPoint(0,0),
106838:     mPresContext(nullptr),
     1:     mLClickCount(0),
     1:     mMClickCount(0),
     1:     mRClickCount(0),
 80486:     m_haveShutdown(false),
 80486:     mClickHoldContextMenu(false)
     1: {
  7093:   if (sESMInstanceCount == 0) {
  7093:     gUserInteractionTimerCallback = new nsUITimerCallback();
 57074:     if (gUserInteractionTimerCallback)
  7093:       NS_ADDREF(gUserInteractionTimerCallback);
 57074:     UpdateUserActivityTimer();
 57074:   }
 57074:   ++sESMInstanceCount;
 57074: }
 57074: 
 57074: nsresult
 57074: nsEventStateManager::UpdateUserActivityTimer(void)
 57074: {
 57074:   if (!gUserInteractionTimerCallback)
 57074:     return NS_OK;
 57074: 
 57074:   if (!gUserInteractionTimer)
  7093:     CallCreateInstance("@mozilla.org/timer;1", &gUserInteractionTimer);
 57074: 
  7093:   if (gUserInteractionTimer) {
  7093:     gUserInteractionTimer->InitWithCallback(gUserInteractionTimerCallback,
  7093:                                             NS_USER_INTERACTION_INTERVAL,
 57074:                                             nsITimer::TYPE_ONE_SHOT);
 57074:   }
 57074:   return NS_OK;
     1: }
     1: 
 71000: static const char* kObservedPrefs[] = {
 71000:   "accessibility.accesskeycausesactivation",
 71000:   "nglayout.events.dispatchLeftClickOnly",
 71000:   "ui.key.generalAccessKey",
 71000:   "ui.key.chromeAccess",
 71000:   "ui.key.contentAccess",
 71000:   "ui.click_hold_context_menus",
 71000:   "dom.popup_allowed_events",
106838:   nullptr
 71000: };
 71000: 
 68780: nsresult
     1: nsEventStateManager::Init()
     1: {
     1:   nsCOMPtr<nsIObserverService> observerService =
 41540:     mozilla::services::GetObserverService();
 41540:   if (!observerService)
 41540:     return NS_ERROR_FAILURE;
     1: 
 80486:   observerService->AddObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID, true);
     1: 
     1:   if (sESMInstanceCount == 1) {
 71259:     sKeyCausesActivation =
 71259:       Preferences::GetBool("accessibility.accesskeycausesactivation",
 71259:                            sKeyCausesActivation);
     1:     sLeftClickOnly =
 70840:       Preferences::GetBool("nglayout.events.dispatchLeftClickOnly",
     1:                            sLeftClickOnly);
     1:     sChromeAccessModifier =
     1:       GetAccessModifierMaskFromPref(nsIDocShellTreeItem::typeChrome);
     1:     sContentAccessModifier =
     1:       GetAccessModifierMaskFromPref(nsIDocShellTreeItem::typeContent);
     1:   }
 71000:   Preferences::AddWeakObservers(this, kObservedPrefs);
     1: 
 43674:   mClickHoldContextMenu =
 79445:     Preferences::GetBool("ui.click_hold_context_menus", false);
 43674: 
 41540:   return NS_OK;
     1: }
     1: 
     1: nsEventStateManager::~nsEventStateManager()
     1: {
 54151:   if (sActiveESM == this) {
106838:     sActiveESM = nullptr;
 54151:   }
 43674:   if (mClickHoldContextMenu)
     1:     KillClickHoldTimer();
     1: 
 54257:   if (mDocument == sMouseOverDocument)
106838:     sMouseOverDocument = nullptr;
 54257: 
     1:   --sESMInstanceCount;
     1:   if(sESMInstanceCount == 0) {
 24947:     nsMouseWheelTransaction::Shutdown();
  7093:     if (gUserInteractionTimerCallback) {
106838:       gUserInteractionTimerCallback->Notify(nullptr);
  7093:       NS_RELEASE(gUserInteractionTimerCallback);
  7093:     }
  7093:     if (gUserInteractionTimer) {
  7093:       gUserInteractionTimer->Cancel();
  7093:       NS_RELEASE(gUserInteractionTimer);
  7093:     }
108052:     WheelPrefs::Shutdown();
108061:     DeltaAccumulator::Shutdown();
     1:   }
     1: 
 80526:   if (sDragOverContent && sDragOverContent->OwnerDoc() == mDocument) {
106838:     sDragOverContent = nullptr;
 79435:   }
 79435: 
     1:   if (!m_haveShutdown) {
     1:     Shutdown();
     1: 
     1:     // Don't remove from Observer service in Shutdown because Shutdown also
     1:     // gets called from xpcom shutdown observer.  And we don't want to remove
     1:     // from the service in that case.
     1: 
     1:     nsCOMPtr<nsIObserverService> observerService =
 41540:       mozilla::services::GetObserverService();
 41540:     if (observerService) {
     1:       observerService->RemoveObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID);
     1:     }
     1:   }
     1: 
     1: }
     1: 
     1: nsresult
     1: nsEventStateManager::Shutdown()
     1: {
 71000:   Preferences::RemoveObservers(this, kObservedPrefs);
 80486:   m_haveShutdown = true;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
     1: nsEventStateManager::Observe(nsISupports *aSubject,
     1:                              const char *aTopic,
     1:                              const PRUnichar *someData)
     1: {
     1:   if (!nsCRT::strcmp(aTopic, NS_XPCOM_SHUTDOWN_OBSERVER_ID))
     1:     Shutdown();
     1:   else if (!nsCRT::strcmp(aTopic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID)) {
     1:     if (!someData)
     1:       return NS_OK;
     1: 
     1:     nsDependentString data(someData);
     1:     if (data.EqualsLiteral("accessibility.accesskeycausesactivation")) {
     1:       sKeyCausesActivation =
 70840:         Preferences::GetBool("accessibility.accesskeycausesactivation",
     1:                              sKeyCausesActivation);
     1:     } else if (data.EqualsLiteral("nglayout.events.dispatchLeftClickOnly")) {
     1:       sLeftClickOnly =
 70840:         Preferences::GetBool("nglayout.events.dispatchLeftClickOnly",
     1:                              sLeftClickOnly);
     1:     } else if (data.EqualsLiteral("ui.key.generalAccessKey")) {
     1:       sChromeAccessModifier =
     1:         GetAccessModifierMaskFromPref(nsIDocShellTreeItem::typeChrome);
     1:       sContentAccessModifier =
     1:         GetAccessModifierMaskFromPref(nsIDocShellTreeItem::typeContent);
     1:     } else if (data.EqualsLiteral("ui.key.chromeAccess")) {
     1:       sChromeAccessModifier =
     1:         GetAccessModifierMaskFromPref(nsIDocShellTreeItem::typeChrome);
     1:     } else if (data.EqualsLiteral("ui.key.contentAccess")) {
     1:       sContentAccessModifier =
     1:         GetAccessModifierMaskFromPref(nsIDocShellTreeItem::typeContent);
 43674:     } else if (data.EqualsLiteral("ui.click_hold_context_menus")) {
 43674:       mClickHoldContextMenu =
 79445:         Preferences::GetBool("ui.click_hold_context_menus", false);
     1:     } else if (data.EqualsLiteral("dom.popup_allowed_events")) {
     1:       nsDOMEvent::PopupAllowedEventsChanged();
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
  4484: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsEventStateManager)
 68780:    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIObserver)
  4484:    NS_INTERFACE_MAP_ENTRY(nsIObserver)
  4484:    NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
  4484: NS_INTERFACE_MAP_END
  4484: 
 67682: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsEventStateManager)
 67682: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsEventStateManager)
  4484: 
  4484: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsEventStateManager)
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mCurrentTargetContent);
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mLastMouseOverElement);
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mGestureDownContent);
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mGestureDownFrameOwner);
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mLastLeftMouseDownContent);
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mLastLeftMouseDownContentParent);
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mLastMiddleMouseDownContent);
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mLastMiddleMouseDownContentParent);
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mLastRightMouseDownContent);
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mLastRightMouseDownContentParent);
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mActiveContent);
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mHoverContent);
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mURLTargetContent);
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mFirstMouseOverEventElement);
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mFirstMouseOutEventElement);
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mDocument);
122008:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mAccessKeys);
  4484: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
  4484: 
  4484: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsEventStateManager)
122008:   NS_IMPL_CYCLE_COLLECTION_UNLINK(mCurrentTargetContent);
122008:   NS_IMPL_CYCLE_COLLECTION_UNLINK(mLastMouseOverElement);
122008:   NS_IMPL_CYCLE_COLLECTION_UNLINK(mGestureDownContent);
122008:   NS_IMPL_CYCLE_COLLECTION_UNLINK(mGestureDownFrameOwner);
122008:   NS_IMPL_CYCLE_COLLECTION_UNLINK(mLastLeftMouseDownContent);
122008:   NS_IMPL_CYCLE_COLLECTION_UNLINK(mLastLeftMouseDownContentParent);
122008:   NS_IMPL_CYCLE_COLLECTION_UNLINK(mLastMiddleMouseDownContent);
122008:   NS_IMPL_CYCLE_COLLECTION_UNLINK(mLastMiddleMouseDownContentParent);
122008:   NS_IMPL_CYCLE_COLLECTION_UNLINK(mLastRightMouseDownContent);
122008:   NS_IMPL_CYCLE_COLLECTION_UNLINK(mLastRightMouseDownContentParent);
122008:   NS_IMPL_CYCLE_COLLECTION_UNLINK(mActiveContent);
122008:   NS_IMPL_CYCLE_COLLECTION_UNLINK(mHoverContent);
122008:   NS_IMPL_CYCLE_COLLECTION_UNLINK(mURLTargetContent);
122008:   NS_IMPL_CYCLE_COLLECTION_UNLINK(mFirstMouseOverEventElement);
122008:   NS_IMPL_CYCLE_COLLECTION_UNLINK(mFirstMouseOutEventElement);
122008:   NS_IMPL_CYCLE_COLLECTION_UNLINK(mDocument);
122008:   NS_IMPL_CYCLE_COLLECTION_UNLINK(mAccessKeys);
  4484: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
  4484: 
 68780: nsresult
     1: nsEventStateManager::PreHandleEvent(nsPresContext* aPresContext,
     1:                                     nsEvent *aEvent,
     1:                                     nsIFrame* aTargetFrame,
 82566:                                     nsEventStatus* aStatus)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aStatus);
     1:   NS_ENSURE_ARG(aPresContext);
     1:   if (!aEvent) {
     1:     NS_ERROR("aEvent is null.  This should never happen.");
     1:     return NS_ERROR_NULL_POINTER;
     1:   }
     1: 
     1:   mCurrentTarget = aTargetFrame;
106838:   mCurrentTargetContent = nullptr;
     1: 
     1:   // Focus events don't necessarily need a frame.
     1:   if (NS_EVENT_NEEDS_FRAME(aEvent)) {
     1:     NS_ASSERTION(mCurrentTarget, "mCurrentTarget is null.  this should not happen.  see bug #13007");
     1:     if (!mCurrentTarget) return NS_ERROR_NULL_POINTER;
     1:   }
 95203: #ifdef DEBUG
 95203:   if (NS_IS_DRAG_EVENT(aEvent) && sIsPointerLocked) {
 95203:     NS_ASSERTION(sIsPointerLocked,
 95203:       "sIsPointerLocked is true. Drag events should be suppressed when the pointer is locked.");
 95203:   }
 95203: #endif
 95203:   // Store last known screenPoint and clientPoint so pointer lock
 95203:   // can use these values as constants.
126028:   if (aEvent->mFlags.mIsTrusted &&
 95618:       ((NS_IS_MOUSE_EVENT_STRUCT(aEvent) &&
 95203:        IsMouseEventReal(aEvent)) ||
108049:        aEvent->eventStructType == NS_WHEEL_EVENT)) {
 95203:     if (!sIsPointerLocked) {
 95203:       sLastScreenPoint = nsDOMUIEvent::CalculateScreenPoint(aPresContext, aEvent);
106838:       sLastClientPoint = nsDOMUIEvent::CalculateClientPoint(aPresContext, aEvent, nullptr);
 95203:     }
 95203:   }
     1: 
  7093:   // Do not take account NS_MOUSE_ENTER/EXIT so that loading a page
  7093:   // when user is not active doesn't change the state to active.
126028:   if (aEvent->mFlags.mIsTrusted &&
  7093:       ((aEvent->eventStructType == NS_MOUSE_EVENT  &&
 39761:         IsMouseEventReal(aEvent) &&
  7093:         aEvent->message != NS_MOUSE_ENTER &&
  7093:         aEvent->message != NS_MOUSE_EXIT) ||
108049:        aEvent->eventStructType == NS_WHEEL_EVENT ||
  7093:        aEvent->eventStructType == NS_KEY_EVENT)) {
  7093:     if (gMouseOrKeyboardEventCounter == 0) {
  7093:       nsCOMPtr<nsIObserverService> obs =
 41540:         mozilla::services::GetObserverService();
  7093:       if (obs) {
106838:         obs->NotifyObservers(nullptr, "user-interaction-active", nullptr);
 57074:         UpdateUserActivityTimer();
  7093:       }
  7093:     }
  7093:     ++gMouseOrKeyboardEventCounter;
  7093:   }
  7093: 
     1:   *aStatus = nsEventStatus_eIgnore;
     1: 
     1:   nsMouseWheelTransaction::OnEvent(aEvent);
     1: 
     1:   switch (aEvent->message) {
     1:   case NS_MOUSE_BUTTON_DOWN:
  3233:     switch (static_cast<nsMouseEvent*>(aEvent)->button) {
     1:     case nsMouseEvent::eLeftButton:
     1: #ifndef XP_OS2
     1:       BeginTrackingDragGesture(aPresContext, (nsMouseEvent*)aEvent, aTargetFrame);
     1: #endif
     1:       mLClickCount = ((nsMouseEvent*)aEvent)->clickCount;
     1:       SetClickCount(aPresContext, (nsMouseEvent*)aEvent, aStatus);
 80486:       sNormalLMouseEventInProcess = true;
     1:       break;
     1:     case nsMouseEvent::eMiddleButton:
     1:       mMClickCount = ((nsMouseEvent*)aEvent)->clickCount;
     1:       SetClickCount(aPresContext, (nsMouseEvent*)aEvent, aStatus);
     1:       break;
     1:     case nsMouseEvent::eRightButton:
     1: #ifdef XP_OS2
     1:       BeginTrackingDragGesture(aPresContext, (nsMouseEvent*)aEvent, aTargetFrame);
     1: #endif
     1:       mRClickCount = ((nsMouseEvent*)aEvent)->clickCount;
     1:       SetClickCount(aPresContext, (nsMouseEvent*)aEvent, aStatus);
     1:       break;
     1:     }
     1:     break;
     1:   case NS_MOUSE_BUTTON_UP:
  3233:     switch (static_cast<nsMouseEvent*>(aEvent)->button) {
     1:       case nsMouseEvent::eLeftButton:
 43674:         if (mClickHoldContextMenu) {
     1:           KillClickHoldTimer();
 43674:         }
     1: #ifndef XP_OS2
     1:         StopTrackingDragGesture();
     1: #endif
 80486:         sNormalLMouseEventInProcess = false;
 63945:         // then fall through...
     1:       case nsMouseEvent::eRightButton:
     1: #ifdef XP_OS2
     1:         StopTrackingDragGesture();
     1: #endif
 63945:         // then fall through...
     1:       case nsMouseEvent::eMiddleButton:
     1:         SetClickCount(aPresContext, (nsMouseEvent*)aEvent, aStatus);
     1:         break;
     1:     }
     1:     break;
     1:   case NS_MOUSE_EXIT:
 12976:     // If the event is not a top-level window exit, then it's not
 12976:     // really an exit --- we may have traversed widget boundaries but
     1:     // we're still in our toplevel window.
     1:     {
  3233:       nsMouseEvent* mouseEvent = static_cast<nsMouseEvent*>(aEvent);
 12976:       if (mouseEvent->exit != nsMouseEvent::eTopLevel) {
 14640:         // Treat it as a synthetic move so we don't generate spurious
 14640:         // "exit" or "move" events.  Any necessary "out" or "over" events
 14640:         // will be generated by GenerateMouseEnterExit
 14640:         mouseEvent->message = NS_MOUSE_MOVE;
 14640:         mouseEvent->reason = nsMouseEvent::eSynthesized;
     1:         // then fall through...
     1:       } else {
     1:         GenerateMouseEnterExit((nsGUIEvent*)aEvent);
     1:         //This is a window level mouse exit event and should stop here
     1:         aEvent->message = 0;
     1:         break;
     1:       }
     1:     }
     1:   case NS_MOUSE_MOVE:
     1:     // on the Mac, GenerateDragGesture() may not return until the drag
     1:     // has completed and so |aTargetFrame| may have been deleted (moving
     1:     // a bookmark, for example).  If this is the case, however, we know
     1:     // that ClearFrameRefs() has been called and it cleared out
     1:     // |mCurrentTarget|. As a result, we should pass |mCurrentTarget|
     1:     // into UpdateCursor().
     1:     GenerateDragGesture(aPresContext, (nsMouseEvent*)aEvent);
     1:     UpdateCursor(aPresContext, aEvent, mCurrentTarget, aStatus);
     1:     GenerateMouseEnterExit((nsGUIEvent*)aEvent);
 86861:     // Flush pending layout changes, so that later mouse move events
 86861:     // will go to the right nodes.
 86861:     FlushPendingEvents(aPresContext);
     1:     break;
     1:   case NS_DRAGDROP_GESTURE:
 43674:     if (mClickHoldContextMenu) {
     1:       // an external drag gesture event came in, not generated internally
     1:       // by Gecko. Make sure we get rid of the click-hold timer.
     1:       KillClickHoldTimer();
 43674:     }
     1:     break;
     1:   case NS_DRAGDROP_OVER:
 18445:     // NS_DRAGDROP_DROP is fired before NS_DRAGDROP_DRAGDROP so send
 18445:     // the enter/exit events before NS_DRAGDROP_DROP.
     1:     GenerateDragDropEnterExit(aPresContext, (nsGUIEvent*)aEvent);
     1:     break;
     1: 
     1:   case NS_KEY_PRESS:
     1:     {
     1: 
     1:       nsKeyEvent* keyEvent = (nsKeyEvent*)aEvent;
     1: 
108991:       int32_t modifierMask = 0;
 96893:       if (keyEvent->IsShift())
     1:         modifierMask |= NS_MODIFIER_SHIFT;
 96893:       if (keyEvent->IsControl())
     1:         modifierMask |= NS_MODIFIER_CONTROL;
 96893:       if (keyEvent->IsAlt())
     1:         modifierMask |= NS_MODIFIER_ALT;
 96893:       if (keyEvent->IsMeta())
     1:         modifierMask |= NS_MODIFIER_META;
105732:       if (keyEvent->IsOS())
105732:         modifierMask |= NS_MODIFIER_OS;
     1: 
     1:       // Prevent keyboard scrolling while an accesskey modifier is in use.
     1:       if (modifierMask && (modifierMask == sChromeAccessModifier ||
     1:                            modifierMask == sContentAccessModifier))
106838:         HandleAccessKey(aPresContext, keyEvent, aStatus, nullptr,
     1:                         eAccessKeyProcessingNormal, modifierMask);
     1:     }
 63945:     // then fall through...
     1:   case NS_KEY_DOWN:
     1:   case NS_KEY_UP:
     1:     {
 29018:       nsIContent* content = GetFocusedContent();
 29018:       if (content)
 29018:         mCurrentTargetContent = content;
     1:     }
     1:     break;
108059:   case NS_WHEEL_WHEEL:
     1:     {
126028:       NS_ASSERTION(aEvent->mFlags.mIsTrusted,
108059:                    "Untrusted wheel event shouldn't be here");
108059: 
 29018:       nsIContent* content = GetFocusedContent();
 29018:       if (content)
 29018:         mCurrentTargetContent = content;
     1: 
108059:       widget::WheelEvent* wheelEvent = static_cast<widget::WheelEvent*>(aEvent);
108059:       WheelPrefs::GetInstance()->ApplyUserPrefsToDelta(wheelEvent);
108061: 
108588:       // If we won't dispatch a DOM event for this event, nothing to do anymore.
108588:       if (!NS_IsAllowedToDispatchDOMEvent(wheelEvent)) {
108588:         break;
108588:       }
108588: 
108061:       // Init lineOrPageDelta values for line scroll events for some devices
108061:       // on some platforms which might dispatch wheel events which don't have
108061:       // lineOrPageDelta values.  And also, if delta values are customized by
108061:       // prefs, this recomputes them.
108061:       DeltaAccumulator::GetInstance()->
108061:         InitLineOrPageDelta(aTargetFrame, this, wheelEvent);
 19319:     }
 19319:     break;
 11914:   case NS_QUERY_SELECTED_TEXT:
 78622:     DoQuerySelectedText(static_cast<nsQueryContentEvent*>(aEvent));
 11914:     break;
 11914:   case NS_QUERY_TEXT_CONTENT:
 11914:     {
 54603:       if (RemoteQueryContentEvent(aEvent))
 54603:         break;
 24836:       nsContentEventHandler handler(mPresContext);
 11914:       handler.OnQueryTextContent((nsQueryContentEvent*)aEvent);
 11914:     }
 11914:     break;
 11914:   case NS_QUERY_CARET_RECT:
 11914:     {
 54603:       // XXX remote event
 24836:       nsContentEventHandler handler(mPresContext);
 11914:       handler.OnQueryCaretRect((nsQueryContentEvent*)aEvent);
 11914:     }
 11914:     break;
 24836:   case NS_QUERY_TEXT_RECT:
 24836:     {
 54603:       // XXX remote event
 24836:       nsContentEventHandler handler(mPresContext);
 24836:       handler.OnQueryTextRect((nsQueryContentEvent*)aEvent);
 24836:     }
 24836:     break;
 24836:   case NS_QUERY_EDITOR_RECT:
 24836:     {
 54603:       // XXX remote event
 24836:       nsContentEventHandler handler(mPresContext);
 24836:       handler.OnQueryEditorRect((nsQueryContentEvent*)aEvent);
 24836:     }
 24836:     break;
 26757:   case NS_QUERY_CONTENT_STATE:
 26757:     {
 54603:       // XXX remote event
 26757:       nsContentEventHandler handler(mPresContext);
 26757:       handler.OnQueryContentState(static_cast<nsQueryContentEvent*>(aEvent));
 26757:     }
 26757:     break;
 26757:   case NS_QUERY_SELECTION_AS_TRANSFERABLE:
 26757:     {
 54603:       // XXX remote event
 26757:       nsContentEventHandler handler(mPresContext);
 26757:       handler.OnQuerySelectionAsTransferable(static_cast<nsQueryContentEvent*>(aEvent));
 26757:     }
 26757:     break;
 28352:   case NS_QUERY_CHARACTER_AT_POINT:
 28352:     {
 54603:       // XXX remote event
 28352:       nsContentEventHandler handler(mPresContext);
 28352:       handler.OnQueryCharacterAtPoint(static_cast<nsQueryContentEvent*>(aEvent));
 28352:     }
 28352:     break;
 63215:   case NS_QUERY_DOM_WIDGET_HITTEST:
 63215:     {
 63215:       // XXX remote event
 63215:       nsContentEventHandler handler(mPresContext);
 63215:       handler.OnQueryDOMWidgetHittest(static_cast<nsQueryContentEvent*>(aEvent));
 63215:     }
 63215:     break;
 24836:   case NS_SELECTION_SET:
 24836:     {
 54603:       nsSelectionEvent *selectionEvent =
 54603:           static_cast<nsSelectionEvent*>(aEvent);
 54603:       if (IsTargetCrossProcess(selectionEvent)) {
 54603:         // Will not be handled locally, remote the event
 54603:         if (GetCrossProcessTarget()->SendSelectionEvent(*selectionEvent))
 80486:           selectionEvent->mSucceeded = true;
 54603:         break;
 54603:       }
 24836:       nsContentEventHandler handler(mPresContext);
 24836:       handler.OnSelectionEvent((nsSelectionEvent*)aEvent);
 24836:     }
 24836:     break;
 31218:   case NS_CONTENT_COMMAND_CUT:
 31218:   case NS_CONTENT_COMMAND_COPY:
 31218:   case NS_CONTENT_COMMAND_PASTE:
 31218:   case NS_CONTENT_COMMAND_DELETE:
 31218:   case NS_CONTENT_COMMAND_UNDO:
 31218:   case NS_CONTENT_COMMAND_REDO:
 36983:   case NS_CONTENT_COMMAND_PASTE_TRANSFERABLE:
 31218:     {
 31218:       DoContentCommandEvent(static_cast<nsContentCommandEvent*>(aEvent));
 31218:     }
 31218:     break;
 39248:   case NS_CONTENT_COMMAND_SCROLL:
 39248:     {
 39248:       DoContentCommandScrollEvent(static_cast<nsContentCommandEvent*>(aEvent));
 39248:     }
 39248:     break;
 50731:   case NS_TEXT_TEXT:
 50731:     {
 50731:       nsTextEvent *textEvent = static_cast<nsTextEvent*>(aEvent);
 50731:       if (IsTargetCrossProcess(textEvent)) {
 50731:         // Will not be handled locally, remote the event
 54603:         if (GetCrossProcessTarget()->SendTextEvent(*textEvent)) {
 50731:           // Cancel local dispatching
126031:           aEvent->mFlags.mPropagationStopped = true;
 50731:         }
 50731:       }
 50731:     }
 50731:     break;
 50731:   case NS_COMPOSITION_START:
126028:     if (aEvent->mFlags.mIsTrusted) {
 78622:       // If the event is trusted event, set the selected text to data of
 78622:       // composition event.
 78622:       nsCompositionEvent *compositionEvent =
 78622:         static_cast<nsCompositionEvent*>(aEvent);
 80486:       nsQueryContentEvent selectedText(true, NS_QUERY_SELECTED_TEXT,
 78622:                                        compositionEvent->widget);
 78622:       DoQuerySelectedText(&selectedText);
 78622:       NS_ASSERTION(selectedText.mSucceeded, "Failed to get selected text");
 78622:       compositionEvent->data = selectedText.mReply.mString;
 78622:     }
 78622:     // through to compositionend handling
 78621:   case NS_COMPOSITION_UPDATE:
 50731:   case NS_COMPOSITION_END:
 50731:     {
 50731:       nsCompositionEvent *compositionEvent =
 50731:           static_cast<nsCompositionEvent*>(aEvent);
 50731:       if (IsTargetCrossProcess(compositionEvent)) {
 50731:         // Will not be handled locally, remote the event
 54603:         if (GetCrossProcessTarget()->SendCompositionEvent(*compositionEvent)) {
 50731:           // Cancel local dispatching
126031:           aEvent->mFlags.mPropagationStopped = true;
 50731:         }
 50731:       }
 50731:     }
 50731:     break;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
108991: static int32_t
     1: GetAccessModifierMask(nsISupports* aDocShell)
     1: {
     1:   nsCOMPtr<nsIDocShellTreeItem> treeItem(do_QueryInterface(aDocShell));
     1:   if (!treeItem)
     1:     return -1; // invalid modifier
     1: 
108991:   int32_t itemType;
     1:   treeItem->GetItemType(&itemType);
     1:   switch (itemType) {
     1: 
     1:   case nsIDocShellTreeItem::typeChrome:
     1:     return sChromeAccessModifier;
     1: 
     1:   case nsIDocShellTreeItem::typeContent:
     1:     return sContentAccessModifier;
     1: 
     1:   default:
     1:     return -1; // invalid modifier
     1:   }
     1: }
     1: 
 79445: static bool
 14328: IsAccessKeyTarget(nsIContent* aContent, nsIFrame* aFrame, nsAString& aKey)
  8407: {
125959:   // Use GetAttr because we want Unicode case=insensitive matching
125959:   // XXXbz shouldn't this be case-sensitive, per spec?
125959:   nsString contentKey;
125959:   if (!aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::accesskey, contentKey) ||
125959:       !contentKey.Equals(aKey, nsCaseInsensitiveStringComparator()))
 80486:     return false;
 23192: 
 23192:   nsCOMPtr<nsIDOMXULDocument> xulDoc =
 80526:     do_QueryInterface(aContent->OwnerDoc());
 33329:   if (!xulDoc && !aContent->IsXUL())
 80486:     return true;
 23192: 
 23192:     // For XUL we do visibility checks.
  8407:   if (!aFrame)
 80486:     return false;
  8407: 
  8407:   if (aFrame->IsFocusable())
 80486:     return true;
  8407: 
 80910:   if (!aFrame->IsVisibleConsideringAncestors())
 80486:     return false;
  8407: 
 23192:   // XUL controls can be activated.
  8407:   nsCOMPtr<nsIDOMXULControlElement> control(do_QueryInterface(aContent));
  8407:   if (control)
 80486:     return true;
  8407: 
 33329:   if (aContent->IsHTML()) {
 15065:     nsIAtom* tag = aContent->Tag();
 15065: 
 15065:     // HTML area, label and legend elements are never focusable, so
 15065:     // we need to check for them explicitly before giving up.
 15065:     if (tag == nsGkAtoms::area ||
 15065:         tag == nsGkAtoms::label ||
 15065:         tag == nsGkAtoms::legend)
 80486:       return true;
 30176: 
 33329:   } else if (aContent->IsXUL()) {
 30176:     // XUL label elements are never focusable, so we need to check for them
 30176:     // explicitly before giving up.
 30176:     if (aContent->Tag() == nsGkAtoms::label)
 80486:       return true;
 80486:   }
 80486: 
 80486:   return false;
  8407: }
  8407: 
 79445: bool
108991: nsEventStateManager::ExecuteAccessKey(nsTArray<uint32_t>& aAccessCharCodes,
 79445:                                       bool aIsTrustedEvent)
 14328: {
108991:   int32_t count, start = -1;
 29018:   nsIContent* focusedContent = GetFocusedContent();
 29018:   if (focusedContent) {
 29018:     start = mAccessKeys.IndexOf(focusedContent);
 29018:     if (start == -1 && focusedContent->GetBindingParent())
 29018:       start = mAccessKeys.IndexOf(focusedContent->GetBindingParent());
 14328:   }
 14328:   nsIContent *content;
 14328:   nsIFrame *frame;
108991:   int32_t length = mAccessKeys.Count();
108991:   for (uint32_t i = 0; i < aAccessCharCodes.Length(); ++i) {
108991:     uint32_t ch = aAccessCharCodes[i];
 14328:     nsAutoString accessKey;
 14328:     AppendUCS4ToUTF16(ch, accessKey);
 14328:     for (count = 1; count <= length; ++count) {
 14328:       content = mAccessKeys[(start + count) % length];
 36655:       frame = content->GetPrimaryFrame();
 14328:       if (IsAccessKeyTarget(content, frame, accessKey)) {
 79445:         bool shouldActivate = sKeyCausesActivation;
 14328:         while (shouldActivate && ++count <= length) {
 14328:           nsIContent *oc = mAccessKeys[(start + count) % length];
 36655:           nsIFrame *of = oc->GetPrimaryFrame();
 14328:           if (IsAccessKeyTarget(oc, of, accessKey))
 80486:             shouldActivate = false;
 14328:         }
 14328:         if (shouldActivate)
 14328:           content->PerformAccesskey(shouldActivate, aIsTrustedEvent);
 29018:         else {
 29018:           nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:           if (fm) {
 29018:             nsCOMPtr<nsIDOMElement> element = do_QueryInterface(content);
 29018:             fm->SetFocus(element, nsIFocusManager::FLAG_BYKEY);
 29018:           }
 29018:         }
 80486:         return true;
 80486:       }
 80486:     }
 80486:   }
 80486:   return false;
 14328: }
 14328: 
 79445: bool
 74612: nsEventStateManager::GetAccessKeyLabelPrefix(nsAString& aPrefix)
 74612: {
 74612:   aPrefix.Truncate();
 74612:   nsAutoString separator, modifierText;
 74612:   nsContentUtils::GetModifierSeparatorText(separator);
 74612: 
 74612:   nsCOMPtr<nsISupports> container = mPresContext->GetContainer();
108991:   int32_t modifier = GetAccessModifierMask(container);
 74612: 
 74612:   if (modifier & NS_MODIFIER_CONTROL) {
 74612:     nsContentUtils::GetControlText(modifierText);
 74612:     aPrefix.Append(modifierText + separator);
 74612:   }
 74612:   if (modifier & NS_MODIFIER_META) {
 74612:     nsContentUtils::GetMetaText(modifierText);
 74612:     aPrefix.Append(modifierText + separator);
 74612:   }
105732:   if (modifier & NS_MODIFIER_OS) {
105732:     nsContentUtils::GetOSText(modifierText);
105732:     aPrefix.Append(modifierText + separator);
105732:   }
 74612:   if (modifier & NS_MODIFIER_ALT) {
 74612:     nsContentUtils::GetAltText(modifierText);
 74612:     aPrefix.Append(modifierText + separator);
 74612:   }
 74612:   if (modifier & NS_MODIFIER_SHIFT) {
 74612:     nsContentUtils::GetShiftText(modifierText);
 74612:     aPrefix.Append(modifierText + separator);
 74612:   }
 74612:   return !aPrefix.IsEmpty();
 74612: }
 74612: 
     1: void
     1: nsEventStateManager::HandleAccessKey(nsPresContext* aPresContext,
     1:                                      nsKeyEvent *aEvent,
     1:                                      nsEventStatus* aStatus,
  1585:                                      nsIDocShellTreeItem* aBubbledFrom,
     1:                                      ProcessingAccessKeyState aAccessKeyState,
108991:                                      int32_t aModifierMask)
     1: {
     1:   nsCOMPtr<nsISupports> pcContainer = aPresContext->GetContainer();
     1: 
     1:   // Alt or other accesskey modifier is down, we may need to do an accesskey
 14328:   if (mAccessKeys.Count() > 0 &&
 14328:       aModifierMask == GetAccessModifierMask(pcContainer)) {
     1:     // Someone registered an accesskey.  Find and activate it.
108991:     nsAutoTArray<uint32_t, 10> accessCharCodes;
 14328:     nsContentUtils::GetAccessKeyCandidates(aEvent, accessCharCodes);
126028:     if (ExecuteAccessKey(accessCharCodes, aEvent->mFlags.mIsTrusted)) {
     1:       *aStatus = nsEventStatus_eConsumeNoDefault;
 14328:       return;
     1:     }
     1:   }
     1: 
     1:   // after the local accesskey handling
     1:   if (nsEventStatus_eConsumeNoDefault != *aStatus) {
     1:     // checking all sub docshells
     1: 
     1:     nsCOMPtr<nsIDocShellTreeNode> docShell(do_QueryInterface(pcContainer));
     1:     if (!docShell) {
     1:       NS_WARNING("no docShellTreeNode for presContext");
     1:       return;
     1:     }
     1: 
108991:     int32_t childCount;
     1:     docShell->GetChildCount(&childCount);
108991:     for (int32_t counter = 0; counter < childCount; counter++) {
     1:       // Not processing the child which bubbles up the handling
  1585:       nsCOMPtr<nsIDocShellTreeItem> subShellItem;
  1585:       docShell->GetChildAt(counter, getter_AddRefs(subShellItem));
  1585:       if (aAccessKeyState == eAccessKeyProcessingUp &&
  1585:           subShellItem == aBubbledFrom)
     1:         continue;
     1: 
     1:       nsCOMPtr<nsIDocShell> subDS = do_QueryInterface(subShellItem);
     1:       if (subDS && IsShellVisible(subDS)) {
127381:         nsCOMPtr<nsIPresShell> subPS = subDS->GetPresShell();
     1: 
     1:         // Docshells need not have a presshell (eg. display:none
     1:         // iframes, docshells in transition between documents, etc).
     1:         if (!subPS) {
     1:           // Oh, well.  Just move on to the next child
     1:           continue;
     1:         }
     1: 
     1:         nsPresContext *subPC = subPS->GetPresContext();
     1: 
     1:         nsEventStateManager* esm =
  3233:           static_cast<nsEventStateManager *>(subPC->EventStateManager());
     1: 
     1:         if (esm)
106838:           esm->HandleAccessKey(subPC, aEvent, aStatus, nullptr,
     1:                                eAccessKeyProcessingDown, aModifierMask);
     1: 
     1:         if (nsEventStatus_eConsumeNoDefault == *aStatus)
     1:           break;
     1:       }
     1:     }
     1:   }// if end . checking all sub docshell ends here.
     1: 
  1585:   // bubble up the process to the parent docshell if necessary
     1:   if (eAccessKeyProcessingDown != aAccessKeyState && nsEventStatus_eConsumeNoDefault != *aStatus) {
     1:     nsCOMPtr<nsIDocShellTreeItem> docShell(do_QueryInterface(pcContainer));
     1:     if (!docShell) {
  1585:       NS_WARNING("no docShellTreeItem for presContext");
     1:       return;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDocShellTreeItem> parentShellItem;
     1:     docShell->GetParent(getter_AddRefs(parentShellItem));
     1:     nsCOMPtr<nsIDocShell> parentDS = do_QueryInterface(parentShellItem);
     1:     if (parentDS) {
127381:       nsCOMPtr<nsIPresShell> parentPS = parentDS->GetPresShell();
     1:       NS_ASSERTION(parentPS, "Our PresShell exists but the parent's does not?");
     1: 
     1:       nsPresContext *parentPC = parentPS->GetPresContext();
     1:       NS_ASSERTION(parentPC, "PresShell without PresContext");
     1: 
     1:       nsEventStateManager* esm =
  3233:         static_cast<nsEventStateManager *>(parentPC->EventStateManager());
     1: 
     1:       if (esm)
  1585:         esm->HandleAccessKey(parentPC, aEvent, aStatus, docShell,
     1:                              eAccessKeyProcessingUp, aModifierMask);
     1:     }
     1:   }// if end. bubble up process
     1: }// end of HandleAccessKey
     1: 
105595: bool
105595: nsEventStateManager::DispatchCrossProcessEvent(nsEvent* aEvent,
105700:                                                nsFrameLoader* aFrameLoader,
105595:                                                nsEventStatus *aStatus) {
105700:   PBrowserParent* remoteBrowser = aFrameLoader->GetRemoteBrowser();
 73592:   TabParent* remote = static_cast<TabParent*>(remoteBrowser);
 73592:   if (!remote) {
105595:     return false;
105595:   }
105595: 
105595:   switch (aEvent->eventStructType) {
105595:   case NS_MOUSE_EVENT: {
 73592:     nsMouseEvent* mouseEvent = static_cast<nsMouseEvent*>(aEvent);
105595:     return remote->SendRealMouseEvent(*mouseEvent);
105595:   }
105595:   case NS_KEY_EVENT: {
 73592:     nsKeyEvent* keyEvent = static_cast<nsKeyEvent*>(aEvent);
105595:     return remote->SendRealKeyEvent(*keyEvent);
105595:   }
108049:   case NS_WHEEL_EVENT: {
108049:     widget::WheelEvent* wheelEvent = static_cast<widget::WheelEvent*>(aEvent);
108049:     return remote->SendMouseWheelEvent(*wheelEvent);
108049:   }
105595:   case NS_TOUCH_EVENT: {
105595:     // Let the child process synthesize a mouse event if needed, and
105595:     // ensure we don't synthesize one in this process.
105595:     *aStatus = nsEventStatus_eConsumeNoDefault;
105595:     nsTouchEvent* touchEvent = static_cast<nsTouchEvent*>(aEvent);
105595:     return remote->SendRealTouchEvent(*touchEvent);
105595:   }
105595:   default: {
105595:     MOZ_NOT_REACHED("Attempt to send non-whitelisted event?");
105595:     return false;
105595:   }
 73592:   }
 73592: }
 73592: 
 79445: bool
 73592: nsEventStateManager::IsRemoteTarget(nsIContent* target) {
 96948:   if (!target) {
 96948:     return false;
 96948:   }
 96948: 
 96948:   // <browser/iframe remote=true> from XUL
 96948:   if ((target->Tag() == nsGkAtoms::browser ||
 80649:        target->Tag() == nsGkAtoms::iframe) &&
 73592:       target->IsXUL() &&
 73592:       target->AttrValueIs(kNameSpaceID_None, nsGkAtoms::Remote,
 96948:                           nsGkAtoms::_true, eIgnoreCase)) {
 96948:     return true;
 96948:   }
 96948: 
121589:   // <frame/iframe mozbrowser/mozapp>
 96948:   nsCOMPtr<nsIMozBrowserFrame> browserFrame = do_QueryInterface(target);
121589:   if (browserFrame && browserFrame->GetReallyIsBrowserOrApp()) {
102765:     return !!TabParent::GetFrom(target);
 96948:   }
 96948: 
 96948:   return false;
 73592: }
 73592: 
113703: /*static*/ void
113703: nsEventStateManager::MapEventCoordinatesForChildProcess(nsFrameLoader* aFrameLoader,
113703:                                                         nsEvent* aEvent)
113703: {
113703:   // The "toplevel widget" in child processes is always at position
113703:   // 0,0.  Map the event coordinates to match that.
113703:   nsIFrame* targetFrame = aFrameLoader->GetPrimaryFrameOfOwningContent();
113703:   if (!targetFrame) {
113703:     return;
113703:   }
113703:   nsPresContext* presContext = targetFrame->PresContext();
113703: 
113703:   if (aEvent->eventStructType != NS_TOUCH_EVENT) {
113703:     nsPoint pt = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent,
113703:                                                               targetFrame);
113703:     aEvent->refPoint = pt.ToNearestPixels(presContext->AppUnitsPerDevPixel());
113703:   } else {
113703:     aEvent->refPoint = nsIntPoint();
113703:     // Find out how far we're offset from the nearest widget.
113703:     nsPoint offset =
113703:       nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent, targetFrame);
113703:     nsIntPoint intOffset =
113703:       offset.ToNearestPixels(presContext->AppUnitsPerDevPixel());
113703:     nsTouchEvent* touchEvent = static_cast<nsTouchEvent*>(aEvent);
113703:     // Then offset all the touch points by that distance, to put them
113703:     // in the space where top-left is 0,0.
113703:     const nsTArray<nsCOMPtr<nsIDOMTouch> >& touches = touchEvent->touches;
113703:     for (uint32_t i = 0; i < touches.Length(); ++i) {
113703:       nsIDOMTouch* touch = touches[i];
113703:       if (touch) {
113703:         touch->mRefPoint += intOffset;
113703:       }
113703:     }
113703:   }
113703: }
113703: 
105595: bool
105595: CrossProcessSafeEvent(const nsEvent& aEvent)
105595: {
105595:   switch (aEvent.eventStructType) {
105595:   case NS_KEY_EVENT:
108049:   case NS_WHEEL_EVENT:
105595:     return true;
105595:   case NS_MOUSE_EVENT:
105595:     switch (aEvent.message) {
105595:     case NS_MOUSE_BUTTON_DOWN:
105595:     case NS_MOUSE_BUTTON_UP:
105595:     case NS_MOUSE_MOVE:
105595:       return true;
105595:     default:
105595:       return false;
105595:     }
105595:   case NS_TOUCH_EVENT:
105595:     switch (aEvent.message) {
105595:     case NS_TOUCH_START:
105595:     case NS_TOUCH_MOVE:
105595:     case NS_TOUCH_END:
105595:     case NS_TOUCH_CANCEL:
105595:       return true;
105595:     default:
105595:       return false;
105595:     }
105595:   default:
105595:     return false;
105595:   }
105595: }
 73592: 
 79445: bool
 73592: nsEventStateManager::HandleCrossProcessEvent(nsEvent *aEvent,
 73592:                                              nsIFrame* aTargetFrame,
 73592:                                              nsEventStatus *aStatus) {
105595:   if (*aStatus == nsEventStatus_eConsumeNoDefault ||
126037:       aEvent->mFlags.mNoCrossProcessBoundaryForwarding ||
105595:       !CrossProcessSafeEvent(*aEvent)) {
 80486:     return false;
 73592:   }
105475: 
105595:   // Collect the remote event targets we're going to forward this
105595:   // event to.
105595:   //
105595:   // NB: the elements of |targets| must be unique, for correctness.
105595:   nsAutoTArray<nsCOMPtr<nsIContent>, 1> targets;
105595:   if (aEvent->eventStructType != NS_TOUCH_EVENT ||
105595:       aEvent->message == NS_TOUCH_START) {
105595:     // If this event only has one target, and it's remote, add it to
105595:     // the array.
 73592:     nsIContent* target = mCurrentTargetContent;
 73592:     if (!target && aTargetFrame) {
 73592:       target = aTargetFrame->GetContent();
 73592:     }
105595:     if (IsRemoteTarget(target)) {
105595:       targets.AppendElement(target);
105595:     }
105595:   } else {
105595:     // This is a touch event with possibly multiple touch points.
105595:     // Each touch point may have its own target.  So iterate through
105595:     // all of them and collect the unique set of targets for event
105595:     // forwarding.
105595:     //
105595:     // This loop is similar to the one used in
105595:     // PresShell::DispatchTouchEvent().
105595:     nsTouchEvent* touchEvent = static_cast<nsTouchEvent*>(aEvent);
105595:     const nsTArray<nsCOMPtr<nsIDOMTouch> >& touches = touchEvent->touches;
108991:     for (uint32_t i = 0; i < touches.Length(); ++i) {
105595:       nsIDOMTouch* touch = touches[i];
105595:       // NB: the |mChanged| check is an optimization, subprocesses can
105595:       // compute this for themselves.  If the touch hasn't changed, we
105595:       // may be able to avoid forwarding the event entirely (which is
105595:       // not free).
105595:       if (!touch || !touch->mChanged) {
105595:         continue;
105595:       }
105595:       nsCOMPtr<nsIDOMEventTarget> targetPtr;
105595:       touch->GetTarget(getter_AddRefs(targetPtr));
105595:       if (!targetPtr) {
105595:         continue;
105595:       }
105595:       nsCOMPtr<nsIContent> target = do_QueryInterface(targetPtr);
105595:       if (IsRemoteTarget(target) && !targets.Contains(target)) {
105595:         targets.AppendElement(target);
105595:       }
105595:     }
105595:   }
105595: 
105700:   if (targets.Length() == 0) {
105700:     return false;
105700:   }
105700: 
105595:   // Look up the frame loader for all the remote targets we found, and
105595:   // then dispatch the event to the remote content they represent.
105595:   bool dispatched = false;
108991:   for (uint32_t i = 0; i < targets.Length(); ++i) {
105595:     nsIContent* target = targets[i];
 73592:     nsCOMPtr<nsIFrameLoaderOwner> loaderOwner = do_QueryInterface(target);
 73592:     if (!loaderOwner) {
105700:       continue;
 73592:     }
 73592: 
 73592:     nsRefPtr<nsFrameLoader> frameLoader = loaderOwner->GetFrameLoader();
 73592:     if (!frameLoader) {
105700:       continue;
 73592:     }
 73592: 
108991:     uint32_t eventMode;
 73592:     frameLoader->GetEventMode(&eventMode);
 73592:     if (eventMode == nsIFrameLoader::EVENT_MODE_DONT_FORWARD_TO_CHILD) {
105700:       continue;
105700:     }
105700: 
113703:     MapEventCoordinatesForChildProcess(frameLoader, aEvent);
 73592: 
105595:     dispatched |= DispatchCrossProcessEvent(aEvent, frameLoader, aStatus);
105595:   }
105595:   return dispatched;
 73592: }
     1: 
     1: //
     1: // CreateClickHoldTimer
     1: //
     1: // Fire off a timer for determining if the user wants click-hold. This timer
     1: // is a one-shot that will be cancelled when the user moves enough to fire
     1: // a drag.
     1: //
     1: void
     1: nsEventStateManager::CreateClickHoldTimer(nsPresContext* inPresContext,
     1:                                           nsIFrame* inDownFrame,
     1:                                           nsGUIEvent* inMouseDownEvent)
     1: {
126028:   if (!inMouseDownEvent->mFlags.mIsTrusted)
     1:     return;
     1: 
     1:   // just to be anal (er, safe)
     1:   if (mClickHoldTimer) {
     1:     mClickHoldTimer->Cancel();
106838:     mClickHoldTimer = nullptr;
     1:   }
     1: 
     1:   // if content clicked on has a popup, don't even start the timer
     1:   // since we'll end up conflicting and both will show.
     1:   if (mGestureDownContent) {
     1:     // check for the |popup| attribute
     1:     if (nsContentUtils::HasNonEmptyAttr(mGestureDownContent, kNameSpaceID_None,
     1:                                         nsGkAtoms::popup))
     1:       return;
     1:     
     1:     // check for a <menubutton> like bookmarks
     1:     if (mGestureDownContent->Tag() == nsGkAtoms::menubutton)
     1:       return;
     1:   }
     1: 
     1:   mClickHoldTimer = do_CreateInstance("@mozilla.org/timer;1");
 43674:   if (mClickHoldTimer) {
108991:     int32_t clickHoldDelay =
 70842:       Preferences::GetInt("ui.click_hold_context_menus.delay", 500);
     1:     mClickHoldTimer->InitWithFuncCallback(sClickHoldCallback, this,
 43674:                                           clickHoldDelay,
     1:                                           nsITimer::TYPE_ONE_SHOT);
 43674:   }
     1: } // CreateClickHoldTimer
     1: 
     1: 
     1: //
     1: // KillClickHoldTimer
     1: //
     1: // Stop the timer that would show the context menu dead in its tracks
     1: //
     1: void
     1: nsEventStateManager::KillClickHoldTimer()
     1: {
     1:   if (mClickHoldTimer) {
     1:     mClickHoldTimer->Cancel();
106838:     mClickHoldTimer = nullptr;
     1:   }
     1: }
     1: 
     1: 
     1: //
     1: // sClickHoldCallback
     1: //
     1: // This fires after the mouse has been down for a certain length of time.
     1: //
     1: void
     1: nsEventStateManager::sClickHoldCallback(nsITimer *aTimer, void* aESM)
     1: {
130400:   nsRefPtr<nsEventStateManager> self = static_cast<nsEventStateManager*>(aESM);
130400:   if (self) {
     1:     self->FireContextClick();
130400:   }
     1: 
     1:   // NOTE: |aTimer| and |self->mAutoHideTimer| are invalid after calling ClosePopup();
     1: 
     1: } // sAutoHideCallback
     1: 
     1: 
     1: //
     1: // FireContextClick
     1: //
     1: // If we're this far, our timer has fired, which means the mouse has been down
     1: // for a certain period of time and has not moved enough to generate a dragGesture.
     1: // We can be certain the user wants a context-click at this stage, so generate
     1: // a dom event and fire it in.
     1: //
     1: // After the event fires, check if PreventDefault() has been set on the event which
     1: // means that someone either ate the event or put up a context menu. This is our cue
     1: // to stop tracking the drag gesture. If we always did this, draggable items w/out
     1: // a context menu wouldn't be draggable after a certain length of time, which is
     1: // _not_ what we want.
     1: //
     1: void
     1: nsEventStateManager::FireContextClick()
     1: {
     1:   if (!mGestureDownContent)
     1:     return;
     1: 
     1: #ifdef XP_MACOSX
 32855:   // Hack to ensure that we don't show a context menu when the user
 32855:   // let go of the mouse after a long cpu-hogging operation prevented
     1:   // us from handling any OS events. See bug 117589.
 32855:   if (!CGEventSourceButtonState(kCGEventSourceStateCombinedSessionState, kCGMouseButtonLeft))
     1:     return;
     1: #endif
     1: 
     1:   nsEventStatus status = nsEventStatus_eIgnore;
     1: 
     1:   // Dispatch to the DOM. We have to fake out the ESM and tell it that the
     1:   // current target frame is actually where the mouseDown occurred, otherwise it
     1:   // will use the frame the mouse is currently over which may or may not be
     1:   // the same. (Note: saari and I have decided that we don't have to reset |mCurrentTarget|
     1:   // when we're through because no one else is doing anything more with this
     1:   // event and it will get reset on the very next event to the correct frame).
 36655:   mCurrentTarget = mPresContext->GetPrimaryFrameFor(mGestureDownContent);
130400:   // make sure the widget sticks around
130400:   nsCOMPtr<nsIWidget> targetWidget;
130400:   if (mCurrentTarget && (targetWidget = mCurrentTarget->GetNearestWidget())) {
   238:     NS_ASSERTION(mPresContext == mCurrentTarget->PresContext(),
     1:                  "a prescontext returned a primary frame that didn't belong to it?");
     1: 
     1:     // before dispatching, check that we're not on something that
     1:     // doesn't get a context menu
     1:     nsIAtom *tag = mGestureDownContent->Tag();
 79445:     bool allowedToDispatch = true;
     1: 
 33329:     if (mGestureDownContent->IsXUL()) {
     1:       if (tag == nsGkAtoms::scrollbar ||
     1:           tag == nsGkAtoms::scrollbarbutton ||
     1:           tag == nsGkAtoms::button)
 80486:         allowedToDispatch = false;
     1:       else if (tag == nsGkAtoms::toolbarbutton) {
     1:         // a <toolbarbutton> that has the container attribute set
     1:         // will already have its own dropdown.
     1:         if (nsContentUtils::HasNonEmptyAttr(mGestureDownContent,
     1:                 kNameSpaceID_None, nsGkAtoms::container)) {
 80486:           allowedToDispatch = false;
     1:         } else {
     1:           // If the toolbar button has an open menu, don't attempt to open
     1:             // a second menu
     1:           if (mGestureDownContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::open,
     1:                                                nsGkAtoms::_true, eCaseMatters)) {
 80486:             allowedToDispatch = false;
     1:           }
     1:         }
     1:       }
     1:     }
 33329:     else if (mGestureDownContent->IsHTML()) {
     1:       nsCOMPtr<nsIFormControl> formCtrl(do_QueryInterface(mGestureDownContent));
     1: 
     1:       if (formCtrl) {
132300:         allowedToDispatch = formCtrl->IsTextControl(false) ||
132300:                             formCtrl->GetType() == NS_FORM_INPUT_FILE;
     1:       }
     1:       else if (tag == nsGkAtoms::applet ||
     1:                tag == nsGkAtoms::embed  ||
     1:                tag == nsGkAtoms::object) {
 80486:         allowedToDispatch = false;
     1:       }
     1:     }
     1: 
     1:     if (allowedToDispatch) {
     1:       // init the event while mCurrentTarget is still good
 80486:       nsMouseEvent event(true, NS_CONTEXTMENU,
     1:                          targetWidget,
     1:                          nsMouseEvent::eReal);
     1:       event.clickCount = 1;
     1:       FillInEventFromGestureDown(&event);
     1:         
     1:       // stop selection tracking, we're in control now
     1:       if (mCurrentTarget)
     1:       {
 70097:         nsRefPtr<nsFrameSelection> frameSel =
  8295:           mCurrentTarget->GetFrameSelection();
     1:         
     1:         if (frameSel && frameSel->GetMouseDownState()) {
     1:           // note that this can cause selection changed events to fire if we're in
     1:           // a text field, which will null out mCurrentTarget
 80486:           frameSel->SetMouseDownState(false);
     1:         }
     1:       }
     1: 
123981:       nsIDocument* doc = mGestureDownContent->GetCurrentDoc();
123981:       nsAutoHandlingUserInputStatePusher userInpStatePusher(true, &event, doc);
123981: 
     1:       // dispatch to DOM
     1:       nsEventDispatcher::Dispatch(mGestureDownContent, mPresContext, &event,
106838:                                   nullptr, &status);
     1: 
     1:       // We don't need to dispatch to frame handling because no frames
     1:       // watch NS_CONTEXTMENU except for nsMenuFrame and that's only for
     1:       // dismissal. That's just as well since we don't really know
     1:       // which frame to send it to.
     1:     }
     1:   }
     1: 
     1:   // now check if the event has been handled. If so, stop tracking a drag
     1:   if (status == nsEventStatus_eConsumeNoDefault) {
     1:     StopTrackingDragGesture();
     1:   }
     1: 
     1:   KillClickHoldTimer();
     1: 
     1: } // FireContextClick
     1: 
     1: 
     1: //
     1: // BeginTrackingDragGesture
     1: //
     1: // Record that the mouse has gone down and that we should move to TRACKING state
     1: // of d&d gesture tracker.
     1: //
 43674: // We also use this to track click-hold context menus. When the mouse goes down,
     1: // fire off a short timer. If the timer goes off and we have yet to fire the
     1: // drag gesture (ie, the mouse hasn't moved a certain distance), then we can
     1: // assume the user wants a click-hold, so fire a context-click event. We only
     1: // want to cancel the drag gesture if the context-click event is handled.
     1: //
     1: void
     1: nsEventStateManager::BeginTrackingDragGesture(nsPresContext* aPresContext,
     1:                                               nsMouseEvent* inDownEvent,
     1:                                               nsIFrame* inDownFrame)
     1: {
 43674:   if (!inDownEvent->widget)
 43674:     return;
 43674: 
     1:   // Note that |inDownEvent| could be either a mouse down event or a
     1:   // synthesized mouse move event.
 25183:   mGestureDownPoint = inDownEvent->refPoint +
 25183:     inDownEvent->widget->WidgetToScreenOffset();
     1: 
 79435:   inDownFrame->GetContentForEvent(inDownEvent,
     1:                                   getter_AddRefs(mGestureDownContent));
     1: 
     1:   mGestureDownFrameOwner = inDownFrame->GetContent();
 96887:   mGestureModifiers = inDownEvent->modifiers;
 96888:   mGestureDownButtons = inDownEvent->buttons;
     1: 
 43674:   if (mClickHoldContextMenu) {
     1:     // fire off a timer to track click-hold
     1:     CreateClickHoldTimer(aPresContext, inDownFrame, inDownEvent);
 43674:   }
     1: }
     1: 
     1: 
     1: //
     1: // StopTrackingDragGesture
     1: //
     1: // Record that the mouse has gone back up so that we should leave the TRACKING
     1: // state of d&d gesture tracker and return to the START state.
     1: //
     1: void
     1: nsEventStateManager::StopTrackingDragGesture()
     1: {
106838:   mGestureDownContent = nullptr;
106838:   mGestureDownFrameOwner = nullptr;
     1: }
     1: 
     1: void
     1: nsEventStateManager::FillInEventFromGestureDown(nsMouseEvent* aEvent)
     1: {
 47148:   NS_ASSERTION(aEvent->widget == mCurrentTarget->GetNearestWidget(),
     1:                "Incorrect widget in event");
     1: 
     1:   // Set the coordinates in the new event to the coordinates of
     1:   // the old event, adjusted for the fact that the widget might be
     1:   // different
 25183:   nsIntPoint tmpPoint = aEvent->widget->WidgetToScreenOffset();
 25183:   aEvent->refPoint = mGestureDownPoint - tmpPoint;
 96887:   aEvent->modifiers = mGestureModifiers;
 96888:   aEvent->buttons = mGestureDownButtons;
     1: }
     1: 
     1: //
     1: // GenerateDragGesture
     1: //
     1: // If we're in the TRACKING state of the d&d gesture tracker, check the current position
     1: // of the mouse in relation to the old one. If we've moved a sufficient amount from
     1: // the mouse down, then fire off a drag gesture event.
     1: void
     1: nsEventStateManager::GenerateDragGesture(nsPresContext* aPresContext,
     1:                                          nsMouseEvent *aEvent)
     1: {
     1:   NS_ASSERTION(aPresContext, "This shouldn't happen.");
     1:   if (IsTrackingDragGesture()) {
 36655:     mCurrentTarget = mGestureDownFrameOwner->GetPrimaryFrame();
     1: 
     1:     if (!mCurrentTarget) {
     1:       StopTrackingDragGesture();
     1:       return;
     1:     }
     1: 
     1:     // Check if selection is tracking drag gestures, if so
     1:     // don't interfere!
     1:     if (mCurrentTarget)
     1:     {
 70097:       nsRefPtr<nsFrameSelection> frameSel = mCurrentTarget->GetFrameSelection();
     1:       if (frameSel && frameSel->GetMouseDownState()) {
     1:         StopTrackingDragGesture();
     1:         return;
     1:       }
     1:     }
     1: 
 37876:     // If non-native code is capturing the mouse don't start a drag.
 37876:     if (nsIPresShell::IsMouseCapturePreventingDrag()) {
 37876:       StopTrackingDragGesture();
 37876:       return;
 37876:     }
 37876: 
108991:     static int32_t pixelThresholdX = 0;
108991:     static int32_t pixelThresholdY = 0;
     1: 
     1:     if (!pixelThresholdX) {
 78124:       pixelThresholdX =
 78124:         LookAndFeel::GetInt(LookAndFeel::eIntID_DragThresholdX, 0);
 78124:       pixelThresholdY =
 78124:         LookAndFeel::GetInt(LookAndFeel::eIntID_DragThresholdY, 0);
     1:       if (!pixelThresholdX)
     1:         pixelThresholdX = 5;
     1:       if (!pixelThresholdY)
     1:         pixelThresholdY = 5;
     1:     }
     1: 
     1:     // fire drag gesture if mouse has moved enough
 25183:     nsIntPoint pt = aEvent->refPoint + aEvent->widget->WidgetToScreenOffset();
134925:     if (Abs(pt.x - mGestureDownPoint.x) > pixelThresholdX ||
134925:         Abs(pt.y - mGestureDownPoint.y) > pixelThresholdY) {
 43674:       if (mClickHoldContextMenu) {
     1:         // stop the click-hold before we fire off the drag gesture, in case
     1:         // it takes a long time
     1:         KillClickHoldTimer();
 43674:       }
     1: 
 18445:       nsRefPtr<nsDOMDataTransfer> dataTransfer = new nsDOMDataTransfer();
 18445:       if (!dataTransfer)
 18445:         return;
 18445: 
 90375:       nsCOMPtr<nsISelection> selection;
 18445:       nsCOMPtr<nsIContent> eventContent, targetContent;
 79435:       mCurrentTarget->GetContentForEvent(aEvent, getter_AddRefs(eventContent));
 18445:       if (eventContent)
 18445:         DetermineDragTarget(aPresContext, eventContent, dataTransfer,
 90375:                             getter_AddRefs(selection), getter_AddRefs(targetContent));
 18445: 
     1:       // Stop tracking the drag gesture now. This should stop us from
     1:       // reentering GenerateDragGesture inside DOM event processing.
     1:       StopTrackingDragGesture();
     1: 
 18445:       if (!targetContent)
 18445:         return;
 18445: 
106838:       sLastDragOverFrame = nullptr;
 47148:       nsCOMPtr<nsIWidget> widget = mCurrentTarget->GetNearestWidget();
   482: 
     1:       // get the widget from the target frame
126028:       nsDragEvent startEvent(aEvent->mFlags.mIsTrusted,
126028:                              NS_DRAGDROP_START, widget);
 18445:       FillInEventFromGestureDown(&startEvent);
 18445: 
126028:       nsDragEvent gestureEvent(aEvent->mFlags.mIsTrusted,
126028:                                NS_DRAGDROP_GESTURE, widget);
   482:       FillInEventFromGestureDown(&gestureEvent);
     1: 
 18445:       startEvent.dataTransfer = gestureEvent.dataTransfer = dataTransfer;
 40485:       startEvent.inputSource = gestureEvent.inputSource = aEvent->inputSource;
 18445: 
     1:       // Dispatch to the DOM. By setting mCurrentTarget we are faking
     1:       // out the ESM and telling it that the current target frame is
     1:       // actually where the mouseDown occurred, otherwise it will use
     1:       // the frame the mouse is currently over which may or may not be
     1:       // the same. (Note: saari and I have decided that we don't have
     1:       // to reset |mCurrentTarget| when we're through because no one
     1:       // else is doing anything more with this event and it will get
     1:       // reset on the very next event to the correct frame).
     1: 
     1:       // Hold onto old target content through the event and reset after.
     1:       nsCOMPtr<nsIContent> targetBeforeEvent = mCurrentTargetContent;
     1: 
     1:       // Set the current target to the content for the mouse down
     1:       mCurrentTargetContent = targetContent;
     1: 
 19703:       // Dispatch both the dragstart and draggesture events to the DOM. For
 19703:       // elements in an editor, only fire the draggesture event so that the
 19703:       // editor code can handle it but content doesn't see a dragstart.
   482:       nsEventStatus status = nsEventStatus_eIgnore;
106838:       nsEventDispatcher::Dispatch(targetContent, aPresContext, &startEvent, nullptr,
 18445:                                   &status);
 18445: 
 18445:       nsDragEvent* event = &startEvent;
 18445:       if (status != nsEventStatus_eConsumeNoDefault) {
 18445:         status = nsEventStatus_eIgnore;
106838:         nsEventDispatcher::Dispatch(targetContent, aPresContext, &gestureEvent, nullptr,
   482:                                     &status);
 18445:         event = &gestureEvent;
 18445:       }
 18445: 
 18445:       // now that the dataTransfer has been updated in the dragstart and
 18445:       // draggesture events, make it read only so that the data doesn't
 18445:       // change during the drag.
 18445:       dataTransfer->SetReadOnly();
 18445: 
 34683:       if (status != nsEventStatus_eConsumeNoDefault) {
 79445:         bool dragStarted = DoDefaultDragStart(aPresContext, event, dataTransfer,
 90375:                                               targetContent, selection);
 34683:         if (dragStarted) {
106838:           sActiveESM = nullptr;
126031:           aEvent->mFlags.mPropagationStopped = true;
 34683:         }
 34683:       }
   482: 
     1:       // Note that frame event handling doesn't care about NS_DRAGDROP_GESTURE,
     1:       // which is just as well since we don't really know which frame to
     1:       // send it to
     1: 
     1:       // Reset mCurretTargetContent to what it was
     1:       mCurrentTargetContent = targetBeforeEvent;
     1:     }
     1: 
     1:     // Now flush all pending notifications, for better responsiveness
     1:     // while dragging.
     1:     FlushPendingEvents(aPresContext);
     1:   }
     1: } // GenerateDragGesture
     1: 
 18445: void
 18445: nsEventStateManager::DetermineDragTarget(nsPresContext* aPresContext,
 18445:                                          nsIContent* aSelectionTarget,
 18445:                                          nsDOMDataTransfer* aDataTransfer,
 90375:                                          nsISelection** aSelection,
 18445:                                          nsIContent** aTargetNode)
 18445: {
106838:   *aTargetNode = nullptr;
 18445: 
 18445:   nsCOMPtr<nsISupports> container = aPresContext->GetContainer();
107470:   nsCOMPtr<nsPIDOMWindow> window = do_GetInterface(container);
 98690:   if (!window)
 98690:     return;
 18445: 
 18445:   // GetDragData determines if a selection, link or image in the content
 18445:   // should be dragged, and places the data associated with the drag in the
 90375:   // data transfer.
 90375:   // mGestureDownContent is the node where the mousedown event for the drag
 90375:   // occurred, and aSelectionTarget is the node to use when a selection is used
 79445:   bool canDrag;
 18445:   nsCOMPtr<nsIContent> dragDataNode;
 96893:   bool wasAlt = (mGestureModifiers & widget::MODIFIER_ALT) != 0;
 90375:   nsresult rv = nsContentAreaDragDrop::GetDragData(window, mGestureDownContent,
 96893:                                                    aSelectionTarget, wasAlt,
 90375:                                                    aDataTransfer, &canDrag, aSelection,
 18445:                                                    getter_AddRefs(dragDataNode));
 18445:   if (NS_FAILED(rv) || !canDrag)
 18445:     return;
 18445: 
 18445:   // if GetDragData returned a node, use that as the node being dragged.
 18445:   // Otherwise, if a selection is being dragged, use the node within the
 18445:   // selection that was dragged. Otherwise, just use the mousedown target.
 18445:   nsIContent* dragContent = mGestureDownContent;
 18445:   if (dragDataNode)
 18445:     dragContent = dragDataNode;
 90375:   else if (*aSelection)
 18445:     dragContent = aSelectionTarget;
 18445: 
 18445:   nsIContent* originalDragContent = dragContent;
 18445: 
 18445:   // If a selection isn't being dragged, look for an ancestor with the
 18445:   // draggable property set. If one is found, use that as the target of the
 18445:   // drag instead of the node that was clicked on. If a draggable node wasn't
 18445:   // found, just use the clicked node.
 90375:   if (!*aSelection) {
 18445:     while (dragContent) {
 81041:       nsCOMPtr<nsIDOMHTMLElement> htmlElement = do_QueryInterface(dragContent);
 18445:       if (htmlElement) {
 79445:         bool draggable = false;
 18445:         htmlElement->GetDraggable(&draggable);
 18445:         if (draggable)
 18445:           break;
 18445:       }
 18445:       else {
 18445:         nsCOMPtr<nsIDOMXULElement> xulElement = do_QueryInterface(dragContent);
 18445:         if (xulElement) {
 18445:           // All XUL elements are draggable, so if a XUL element is
 18445:           // encountered, stop looking for draggable nodes and just use the
 18445:           // original clicked node instead.
 18445:           // XXXndeakin
 18445:           // In the future, we will want to improve this so that XUL has a
 18445:           // better way to specify whether something is draggable than just
 18445:           // on/off.
 18445:           dragContent = mGestureDownContent;
 18445:           break;
 18445:         }
 18445:         // otherwise, it's not an HTML or XUL element, so just keep looking
 18445:       }
 18445:       dragContent = dragContent->GetParent();
 18445:     }
 18445:   }
 18445: 
 18445:   // if no node in the hierarchy was found to drag, but the GetDragData method
 18985:   // returned a node, use that returned node. Otherwise, nothing is draggable.
 18985:   if (!dragContent && dragDataNode)
 18985:     dragContent = dragDataNode;
 18445: 
 18445:   if (dragContent) {
 18445:     // if an ancestor node was used instead, clear the drag data
 18445:     // XXXndeakin rework this a bit. Find a way to just not call GetDragData if we don't need to.
 18445:     if (dragContent != originalDragContent)
 18445:       aDataTransfer->ClearAll();
 18445:     *aTargetNode = dragContent;
 18445:     NS_ADDREF(*aTargetNode);
 18445:   }
 18445: }
 18445: 
 79445: bool
 18445: nsEventStateManager::DoDefaultDragStart(nsPresContext* aPresContext,
 18445:                                         nsDragEvent* aDragEvent,
 18445:                                         nsDOMDataTransfer* aDataTransfer,
 18445:                                         nsIContent* aDragTarget,
 90375:                                         nsISelection* aSelection)
 18445: {
 18445:   nsCOMPtr<nsIDragService> dragService =
 18445:     do_GetService("@mozilla.org/widget/dragservice;1");
 18445:   if (!dragService)
 80486:     return false;
 18445: 
 18445:   // Default handling for the draggesture/dragstart event.
 18445:   //
 18445:   // First, check if a drag session already exists. This means that the drag
 18445:   // service was called directly within a draggesture handler. In this case,
 18445:   // don't do anything more, as it is assumed that the handler is managing
 34683:   // drag and drop manually. Make sure to return true to indicate that a drag
 34683:   // began.
 18445:   nsCOMPtr<nsIDragSession> dragSession;
 18445:   dragService->GetCurrentSession(getter_AddRefs(dragSession));
 18445:   if (dragSession)
 80486:     return true;
 18445: 
 18445:   // No drag session is currently active, so check if a handler added
 18445:   // any items to be dragged. If not, there isn't anything to drag.
108991:   uint32_t count = 0;
 18445:   if (aDataTransfer)
 18445:     aDataTransfer->GetMozItemCount(&count);
 18445:   if (!count)
 80486:     return false;
 18445: 
 18445:   // Get the target being dragged, which may not be the same as the
 18445:   // target of the mouse event. If one wasn't set in the
 18445:   // aDataTransfer during the event handler, just use the original
 18445:   // target instead.
 18445:   nsCOMPtr<nsIDOMNode> dragTarget;
 18445:   nsCOMPtr<nsIDOMElement> dragTargetElement;
 18445:   aDataTransfer->GetDragTarget(getter_AddRefs(dragTargetElement));
 18445:   dragTarget = do_QueryInterface(dragTargetElement);
 18445:   if (!dragTarget) {
 18445:     dragTarget = do_QueryInterface(aDragTarget);
 18445:     if (!dragTarget)
 80486:       return false;
 18445:   }
 18445: 
 18552:   // check which drag effect should initially be used. If the effect was not
 18552:   // set, just use all actions, otherwise Windows won't allow a drop.
108991:   uint32_t action;
 18552:   aDataTransfer->GetEffectAllowedInt(&action);
 18552:   if (action == nsIDragService::DRAGDROP_ACTION_UNINITIALIZED)
 18552:     action = nsIDragService::DRAGDROP_ACTION_COPY |
 18552:              nsIDragService::DRAGDROP_ACTION_MOVE |
 18552:              nsIDragService::DRAGDROP_ACTION_LINK;
 18445: 
 18445:   // get any custom drag image that was set
108991:   int32_t imageX, imageY;
 18445:   nsIDOMElement* dragImage = aDataTransfer->GetDragImage(&imageX, &imageY);
 18445: 
 18445:   nsCOMPtr<nsISupportsArray> transArray;
103068:   aDataTransfer->GetTransferables(getter_AddRefs(transArray), dragTarget);
 18445:   if (!transArray)
 80486:     return false;
 18445: 
 18445:   // XXXndeakin don't really want to create a new drag DOM event
 18445:   // here, but we need something to pass to the InvokeDragSession
 18445:   // methods.
 18445:   nsCOMPtr<nsIDOMEvent> domEvent;
 18445:   NS_NewDOMDragEvent(getter_AddRefs(domEvent), aPresContext, aDragEvent);
 18445: 
 18445:   nsCOMPtr<nsIDOMDragEvent> domDragEvent = do_QueryInterface(domEvent);
 18445:   // if creating a drag event failed, starting a drag session will
 18445:   // just fail.
 90375: 
 90375:   // Use InvokeDragSessionWithSelection if a selection is being dragged,
 90375:   // such that the image can be generated from the selected text. However,
 90375:   // use InvokeDragSessionWithImage if a custom image was set or something
 90375:   // other than a selection is being dragged.
 90375:   if (!dragImage && aSelection) {
 90375:     dragService->InvokeDragSessionWithSelection(aSelection, transArray,
 18445:                                                 action, domDragEvent,
 18445:                                                 aDataTransfer);
 18445:   }
 18445:   else {
 18445:     // if dragging within a XUL tree and no custom drag image was
 18445:     // set, the region argument to InvokeDragSessionWithImage needs
 18445:     // to be set to the area encompassing the selected rows of the
 18445:     // tree to ensure that the drag feedback gets clipped to those
 18445:     // rows. For other content, region should be null.
 18445:     nsCOMPtr<nsIScriptableRegion> region;
 18445: #ifdef MOZ_XUL
 18445:     if (dragTarget && !dragImage) {
 18445:       nsCOMPtr<nsIContent> content = do_QueryInterface(dragTarget);
 18445:       if (content->NodeInfo()->Equals(nsGkAtoms::treechildren,
 18445:                                       kNameSpaceID_XUL)) {
 36655:         nsTreeBodyFrame* treeBody = do_QueryFrame(content->GetPrimaryFrame());
 36655:         if (treeBody) {
 20988:           treeBody->GetSelectionRegion(getter_AddRefs(region));
 18445:         }
 18445:       }
 18445:     }
 18445: #endif
 18445: 
 18445:     dragService->InvokeDragSessionWithImage(dragTarget, transArray,
 18445:                                             region, action, dragImage,
 18445:                                             imageX, imageY, domDragEvent,
 18445:                                             aDataTransfer);
 18445:   }
 34683: 
 80486:   return true;
 18445: }
 18445: 
     1: nsresult
  7251: nsEventStateManager::GetMarkupDocumentViewer(nsIMarkupDocumentViewer** aMv)
     1: {
106838:   *aMv = nullptr;
  7251: 
 29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:   if(!fm) return NS_ERROR_FAILURE;
 29018: 
 29018:   nsCOMPtr<nsIDOMWindow> focusedWindow;
 29018:   fm->GetFocusedWindow(getter_AddRefs(focusedWindow));
 29018: 
 29018:   nsCOMPtr<nsPIDOMWindow> ourWindow = do_QueryInterface(focusedWindow);
     1:   if(!ourWindow) return NS_ERROR_FAILURE;
     1: 
 73870:   nsIDOMWindow *rootWindow = ourWindow->GetPrivateRoot();
     1:   if(!rootWindow) return NS_ERROR_FAILURE;
     1: 
     1:   nsCOMPtr<nsIDOMWindow> contentWindow;
     1:   rootWindow->GetContent(getter_AddRefs(contentWindow));
     1:   if(!contentWindow) return NS_ERROR_FAILURE;
     1: 
     1:   nsIDocument *doc = GetDocumentFromWindow(contentWindow);
     1:   if(!doc) return NS_ERROR_FAILURE;
     1: 
 46225:   nsIPresShell *presShell = doc->GetShell();
     1:   if(!presShell) return NS_ERROR_FAILURE;
     1:   nsPresContext *presContext = presShell->GetPresContext();
     1:   if(!presContext) return NS_ERROR_FAILURE;
     1: 
     1:   nsCOMPtr<nsISupports> pcContainer = presContext->GetContainer();
     1:   if(!pcContainer) return NS_ERROR_FAILURE;
     1: 
     1:   nsCOMPtr<nsIDocShell> docshell(do_QueryInterface(pcContainer));
     1:   if(!docshell) return NS_ERROR_FAILURE;
     1: 
     1:   nsCOMPtr<nsIContentViewer> cv;
     1:   docshell->GetContentViewer(getter_AddRefs(cv));
     1:   if(!cv) return NS_ERROR_FAILURE;
     1: 
     1:   nsCOMPtr<nsIMarkupDocumentViewer> mv(do_QueryInterface(cv));
     1:   if(!mv) return NS_ERROR_FAILURE;
     1: 
  7251:   *aMv = mv;
  7251:   NS_IF_ADDREF(*aMv);
  7251: 
  7251:   return NS_OK;
  7251: }
  7251: 
  7251: nsresult
108991: nsEventStateManager::ChangeTextSize(int32_t change)
  7251: {
  7251:   nsCOMPtr<nsIMarkupDocumentViewer> mv;
  7251:   nsresult rv = GetMarkupDocumentViewer(getter_AddRefs(mv));
  7251:   NS_ENSURE_SUCCESS(rv, rv);
  7251: 
  7251:   float textzoom;
 70842:   float zoomMin = ((float)Preferences::GetInt("zoom.minPercent", 50)) / 100;
 70842:   float zoomMax = ((float)Preferences::GetInt("zoom.maxPercent", 300)) / 100;
  7251:   mv->GetTextZoom(&textzoom);
  7251:   textzoom += ((float)change) / 10;
 20751:   if (textzoom < zoomMin)
 20751:     textzoom = zoomMin;
 20751:   else if (textzoom > zoomMax)
 20751:     textzoom = zoomMax;
  7251:   mv->SetTextZoom(textzoom);
  7251: 
  7251:   return NS_OK;
  7251: }
  7251: 
  7251: nsresult
108991: nsEventStateManager::ChangeFullZoom(int32_t change)
  7251: {
  7251:   nsCOMPtr<nsIMarkupDocumentViewer> mv;
  7251:   nsresult rv = GetMarkupDocumentViewer(getter_AddRefs(mv));
  7251:   NS_ENSURE_SUCCESS(rv, rv);
  7251: 
  7187:   float fullzoom;
 70842:   float zoomMin = ((float)Preferences::GetInt("zoom.minPercent", 50)) / 100;
 70842:   float zoomMax = ((float)Preferences::GetInt("zoom.maxPercent", 300)) / 100;
  7187:   mv->GetFullZoom(&fullzoom);
  7187:   fullzoom += ((float)change) / 10;
  7187:   if (fullzoom < zoomMin)
  7187:     fullzoom = zoomMin;
  7187:   else if (fullzoom > zoomMax)
  7187:     fullzoom = zoomMax;
  7187:   mv->SetFullZoom(fullzoom);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: void
108991: nsEventStateManager::DoScrollHistory(int32_t direction)
     1: {
     1:   nsCOMPtr<nsISupports> pcContainer(mPresContext->GetContainer());
     1:   if (pcContainer) {
     1:     nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(pcContainer));
     1:     if (webNav) {
     1:       // positive direction to go back one step, nonpositive to go forward
     1:       if (direction > 0)
     1:         webNav->GoBack();
     1:       else
     1:         webNav->GoForward();
     1:     }
     1:   }
     1: }
     1: 
     1: void
 11660: nsEventStateManager::DoScrollZoom(nsIFrame *aTargetFrame,
108991:                                   int32_t adjustment)
  7251: {
  7251:   // Exclude form controls and XUL content.
  7251:   nsIContent *content = aTargetFrame->GetContent();
  7251:   if (content &&
  7251:       !content->IsNodeOfType(nsINode::eHTML_FORM_CONTROL) &&
108216:       !content->OwnerDoc()->IsXUL())
  7251:     {
 11660:       // positive adjustment to decrease zoom, negative to increase
108991:       int32_t change = (adjustment > 0) ? -1 : 1;
 11660: 
 88004:       if (Preferences::GetBool("browser.zoom.full") || content->GetCurrentDoc()->IsSyntheticDocument()) {
 11660:         ChangeFullZoom(change);
 70840:       } else {
 11660:         ChangeTextSize(change);
     1:       }
     1:     }
 70840: }
     1: 
     1: static nsIFrame*
 37058: GetParentFrameToScroll(nsIFrame* aFrame)
     1: {
 37058:   if (!aFrame)
106838:     return nullptr;
     1: 
132812:   if (aFrame->StyleDisplay()->mPosition == NS_STYLE_POSITION_FIXED &&
 21930:       nsLayoutUtils::IsReallyFixedPos(aFrame))
 37058:     return aFrame->PresContext()->GetPresShell()->GetRootScrollFrame();
     1: 
     1:   return aFrame->GetParent();
     1: }
     1: 
 26874: void
108060: nsEventStateManager::DispatchLegacyMouseScrollEvents(nsIFrame* aTargetFrame,
108060:                                                      widget::WheelEvent* aEvent,
108060:                                                      nsEventStatus* aStatus)
108060: {
108060:   MOZ_ASSERT(aEvent);
108060:   MOZ_ASSERT(aStatus);
108060: 
108060:   if (!aTargetFrame || *aStatus == nsEventStatus_eConsumeNoDefault) {
108060:     return;
108060:   }
108060: 
108060:   // Ignore mouse wheel transaction for computing legacy mouse wheel
108060:   // events' delta value.
108060:   nsIScrollableFrame* scrollTarget =
111054:     ComputeScrollTarget(aTargetFrame, aEvent,
111054:                         COMPUTE_LEGACY_MOUSE_SCROLL_EVENT_TARGET);
108060: 
108060:   nsIFrame* scrollFrame = do_QueryFrame(scrollTarget);
108060:   nsPresContext* pc =
108060:     scrollFrame ? scrollFrame->PresContext() : aTargetFrame->PresContext();
108060: 
108060:   // DOM event's delta vales are computed from CSS pixels.
108060:   nsSize scrollAmount = GetScrollAmount(pc, aEvent, scrollTarget);
108060:   nsIntSize scrollAmountInCSSPixels(
108060:     nsPresContext::AppUnitsToIntCSSPixels(scrollAmount.width),
108060:     nsPresContext::AppUnitsToIntCSSPixels(scrollAmount.height));
108060: 
108743:   // XXX We don't deal with fractional amount in legacy event, though the
108743:   //     default action handler (DoScrollText()) deals with it.
108743:   //     If we implemented such strict computation, we would need additional
108743:   //     accumulated delta values. It would made the code more complicated.
108743:   //     And also it would computes different delta values from older version.
108743:   //     It doesn't make sense to implement such code for legacy events and
108743:   //     rare cases.
108991:   int32_t scrollDeltaX, scrollDeltaY, pixelDeltaX, pixelDeltaY;
108060:   switch (aEvent->deltaMode) {
108060:     case nsIDOMWheelEvent::DOM_DELTA_PAGE:
108060:       scrollDeltaX =
108060:         !aEvent->lineOrPageDeltaX ? 0 :
108060:           (aEvent->lineOrPageDeltaX > 0  ? nsIDOMUIEvent::SCROLL_PAGE_DOWN :
108060:                                            nsIDOMUIEvent::SCROLL_PAGE_UP);
108060:       scrollDeltaY =
108060:         !aEvent->lineOrPageDeltaY ? 0 :
108060:           (aEvent->lineOrPageDeltaY > 0  ? nsIDOMUIEvent::SCROLL_PAGE_DOWN :
108060:                                            nsIDOMUIEvent::SCROLL_PAGE_UP);
108060:       pixelDeltaX = RoundDown(aEvent->deltaX * scrollAmountInCSSPixels.width);
108060:       pixelDeltaY = RoundDown(aEvent->deltaY * scrollAmountInCSSPixels.height);
108060:       break;
108060: 
108060:     case nsIDOMWheelEvent::DOM_DELTA_LINE:
108060:       scrollDeltaX = aEvent->lineOrPageDeltaX;
108060:       scrollDeltaY = aEvent->lineOrPageDeltaY;
108060:       pixelDeltaX = RoundDown(aEvent->deltaX * scrollAmountInCSSPixels.width);
108060:       pixelDeltaY = RoundDown(aEvent->deltaY * scrollAmountInCSSPixels.height);
108060:       break;
108060: 
108060:     case nsIDOMWheelEvent::DOM_DELTA_PIXEL:
108060:       scrollDeltaX = aEvent->lineOrPageDeltaX;
108060:       scrollDeltaY = aEvent->lineOrPageDeltaY;
108060:       pixelDeltaX = RoundDown(aEvent->deltaX);
108060:       pixelDeltaY = RoundDown(aEvent->deltaY);
108060:       break;
108060: 
108060:     default:
108060:       MOZ_NOT_REACHED("Invalid deltaMode value comes");
108060:       return;
108060:   }
108060: 
108060:   // Send the legacy events in following order:
108060:   // 1. Vertical scroll
108060:   // 2. Vertical pixel scroll (even if #1 isn't consumed)
108060:   // 3. Horizontal scroll (even if #1 and/or #2 are consumed)
108060:   // 4. Horizontal pixel scroll (even if #3 isn't consumed)
108060: 
108060:   nsWeakFrame targetFrame(aTargetFrame);
108060: 
108060:   nsEventStatus statusX = *aStatus;
108060:   nsEventStatus statusY = *aStatus;
108060:   if (scrollDeltaY) {
108060:     SendLineScrollEvent(aTargetFrame, aEvent, &statusY,
108060:                         scrollDeltaY, DELTA_DIRECTION_Y);
108060:     if (!targetFrame.IsAlive()) {
108060:       *aStatus = nsEventStatus_eConsumeNoDefault;
108060:       return;
108060:     }
108060:   }
108060: 
108060:   if (pixelDeltaY) {
108060:     SendPixelScrollEvent(aTargetFrame, aEvent, &statusY,
108060:                          pixelDeltaY, DELTA_DIRECTION_Y);
108060:     if (!targetFrame.IsAlive()) {
108060:       *aStatus = nsEventStatus_eConsumeNoDefault;
108060:       return;
108060:     }
108060:   }
108060: 
108060:   if (scrollDeltaX) {
108060:     SendLineScrollEvent(aTargetFrame, aEvent, &statusX,
108060:                         scrollDeltaX, DELTA_DIRECTION_X);
108060:     if (!targetFrame.IsAlive()) {
108060:       *aStatus = nsEventStatus_eConsumeNoDefault;
108060:       return;
108060:     }
108060:   }
108060: 
108060:   if (pixelDeltaX) {
108060:     SendPixelScrollEvent(aTargetFrame, aEvent, &statusX,
108060:                          pixelDeltaX, DELTA_DIRECTION_X);
108060:     if (!targetFrame.IsAlive()) {
108060:       *aStatus = nsEventStatus_eConsumeNoDefault;
108060:       return;
108060:     }
108060:   }
108060: 
108060:   if (statusY == nsEventStatus_eConsumeNoDefault ||
108060:       statusX == nsEventStatus_eConsumeNoDefault) {
108060:     *aStatus = nsEventStatus_eConsumeNoDefault;
108060:     return;
108060:   }
108060:   if (statusY == nsEventStatus_eConsumeDoDefault ||
108060:       statusX == nsEventStatus_eConsumeDoDefault) {
108060:     *aStatus = nsEventStatus_eConsumeDoDefault;
108060:   }
108060: }
108060: 
108060: void
 26874: nsEventStateManager::SendLineScrollEvent(nsIFrame* aTargetFrame,
108060:                                          widget::WheelEvent* aEvent,
 26874:                                          nsEventStatus* aStatus,
108991:                                          int32_t aDelta,
108060:                                          DeltaDirection aDeltaDirection)
 26874: {
 26874:   nsCOMPtr<nsIContent> targetContent = aTargetFrame->GetContent();
 26874:   if (!targetContent)
 29018:     targetContent = GetFocusedContent();
 26874:   if (!targetContent)
 26874:     return;
 26874: 
 26874:   while (targetContent->IsNodeOfType(nsINode::eTEXT)) {
 26874:     targetContent = targetContent->GetParent();
 26874:   }
 26874: 
126028:   nsMouseScrollEvent event(aEvent->mFlags.mIsTrusted, NS_MOUSE_SCROLL,
108060:                            aEvent->widget);
108060:   if (*aStatus == nsEventStatus_eConsumeNoDefault) {
126032:     event.mFlags.mDefaultPrevented = true;
108060:   }
 26874:   event.refPoint = aEvent->refPoint;
 26874:   event.widget = aEvent->widget;
 26874:   event.time = aEvent->time;
 96887:   event.modifiers = aEvent->modifiers;
 96888:   event.buttons = aEvent->buttons;
108076:   event.isHorizontal = (aDeltaDirection == DELTA_DIRECTION_X);
108060:   event.delta = aDelta;
108060:   event.inputSource = aEvent->inputSource;
108060: 
108060:   nsEventDispatcher::Dispatch(targetContent, aTargetFrame->PresContext(),
108060:                               &event, nullptr, aStatus);
 26874: }
 26874: 
 26874: void
 26874: nsEventStateManager::SendPixelScrollEvent(nsIFrame* aTargetFrame,
108060:                                           widget::WheelEvent* aEvent,
108060:                                           nsEventStatus* aStatus,
108991:                                           int32_t aPixelDelta,
108060:                                           DeltaDirection aDeltaDirection)
 26874: {
 26874:   nsCOMPtr<nsIContent> targetContent = aTargetFrame->GetContent();
 29018:   if (!targetContent) {
 29018:     targetContent = GetFocusedContent();
 26874:     if (!targetContent)
 26874:       return;
 29018:   }
 26874: 
 26874:   while (targetContent->IsNodeOfType(nsINode::eTEXT)) {
 26874:     targetContent = targetContent->GetParent();
 26874:   }
 26874: 
126028:   nsMouseScrollEvent event(aEvent->mFlags.mIsTrusted, NS_MOUSE_PIXEL_SCROLL,
108060:                            aEvent->widget);
108060:   if (*aStatus == nsEventStatus_eConsumeNoDefault) {
126032:     event.mFlags.mDefaultPrevented = true;
108060:   }
 19319:   event.refPoint = aEvent->refPoint;
 19319:   event.widget = aEvent->widget;
 19319:   event.time = aEvent->time;
 96887:   event.modifiers = aEvent->modifiers;
 96888:   event.buttons = aEvent->buttons;
108076:   event.isHorizontal = (aDeltaDirection == DELTA_DIRECTION_X);
108060:   event.delta = aPixelDelta;
108060:   event.inputSource = aEvent->inputSource;
108060: 
108060:   nsEventDispatcher::Dispatch(targetContent, aTargetFrame->PresContext(),
108060:                               &event, nullptr, aStatus);
 19319: }
 19319: 
108050: nsIScrollableFrame*
108050: nsEventStateManager::ComputeScrollTarget(nsIFrame* aTargetFrame,
108059:                                          widget::WheelEvent* aEvent,
111054:                                          ComputeScrollTargetOptions aOptions)
     1: {
111054:   if (aOptions & PREFER_MOUSE_WHEEL_TRANSACTION) {
108051:     // If the user recently scrolled with the mousewheel, then they probably
108051:     // want to scroll the same view as before instead of the view under the
108051:     // cursor.  nsMouseWheelTransaction tracks the frame currently being
108051:     // scrolled with the mousewheel. We consider the transaction ended when the
108051:     // mouse moves more than "mousewheel.transaction.ignoremovedelay"
108051:     // milliseconds after the last scroll operation, or any time the mouse moves
108051:     // out of the frame, or when more than "mousewheel.transaction.timeout"
108051:     // milliseconds have passed after the last operation, even if the mouse
108051:     // hasn't moved.
     1:     nsIFrame* lastScrollFrame = nsMouseWheelTransaction::GetTargetFrame();
     1:     if (lastScrollFrame) {
108051:       nsIScrollableFrame* frameToScroll =
108051:         lastScrollFrame->GetScrollTargetFrame();
 37058:       if (frameToScroll) {
108050:         return frameToScroll;
108050:       }
108050:     }
108051:   }
108050: 
108059:   // If the event doesn't cause scroll actually, we cannot find scroll target
108059:   // because we check if the event can cause scroll actually on each found
108059:   // scrollable frame.
108059:   if (!aEvent->deltaX && !aEvent->deltaY) {
108059:     return nullptr;
108059:   }
108059: 
111054:   bool checkIfScrollableX =
111054:     aEvent->deltaX && (aOptions & PREFER_ACTUAL_SCROLLABLE_TARGET_ALONG_X_AXIS);
111054:   bool checkIfScrollableY =
111054:     aEvent->deltaY && (aOptions & PREFER_ACTUAL_SCROLLABLE_TARGET_ALONG_Y_AXIS);
111054: 
108050:   nsIScrollableFrame* frameToScroll = nullptr;
111054:   nsIFrame* scrollFrame =
111054:     !(aOptions & START_FROM_PARENT) ? aTargetFrame :
111054:                                       GetParentFrameToScroll(aTargetFrame);
111054:   for (; scrollFrame; scrollFrame = GetParentFrameToScroll(scrollFrame)) {
     1:     // Check whether the frame wants to provide us with a scrollable view.
 37058:     frameToScroll = scrollFrame->GetScrollTargetFrame();
 37058:     if (!frameToScroll) {
     1:       continue;
     1:     }
     1: 
111054:     if (!checkIfScrollableX && !checkIfScrollableY) {
108051:       return frameToScroll;
108051:     }
108051: 
 37058:     nsPresContext::ScrollbarStyles ss = frameToScroll->GetScrollbarStyles();
108059:     bool hiddenForV = (NS_STYLE_OVERFLOW_HIDDEN == ss.mVertical);
108059:     bool hiddenForH = (NS_STYLE_OVERFLOW_HIDDEN == ss.mHorizontal);
108059:     if ((hiddenForV && hiddenForH) ||
111054:         (checkIfScrollableY && !checkIfScrollableX && hiddenForV) ||
111054:         (checkIfScrollableX && !checkIfScrollableY && hiddenForH)) {
     1:       continue;
     1:     }
     1: 
108051:     // For default action, we should climb up the tree if cannot scroll it
108051:     // by the event actually.
108059:     bool canScroll = CanScrollOn(frameToScroll,
108059:                                  aEvent->deltaX, aEvent->deltaY);
     1:     // Comboboxes need special care.
 23554:     nsIComboboxControlFrame* comboBox = do_QueryFrame(scrollFrame);
     1:     if (comboBox) {
     1:       if (comboBox->IsDroppedDown()) {
     1:         // Don't propagate to parent when drop down menu is active.
108051:         return canScroll ? frameToScroll : nullptr;
108051:       }
     1:       // Always propagate when not dropped down (even if focused).
108051:       continue;
108051:     }
108051: 
108051:     if (canScroll) {
108050:       return frameToScroll;
108050:     }
108051:   }
108050: 
108050:   nsIFrame* newFrame = nsLayoutUtils::GetCrossDocParentFrame(
108050:       aTargetFrame->PresContext()->FrameManager()->GetRootFrame());
111054:   aOptions =
111054:     static_cast<ComputeScrollTargetOptions>(aOptions & ~START_FROM_PARENT);
111054:   return newFrame ? ComputeScrollTarget(newFrame, aEvent, aOptions) : nullptr;
108051: }
108051: 
108057: nsSize
108051: nsEventStateManager::GetScrollAmount(nsPresContext* aPresContext,
108059:                                      widget::WheelEvent* aEvent,
108051:                                      nsIScrollableFrame* aScrollableFrame)
108051: {
108051:   MOZ_ASSERT(aPresContext);
108051:   MOZ_ASSERT(aEvent);
108059: 
108059:   bool isPage = (aEvent->deltaMode == nsIDOMWheelEvent::DOM_DELTA_PAGE);
108051:   if (aScrollableFrame) {
108057:     return isPage ? aScrollableFrame->GetPageScrollAmount() :
108051:                     aScrollableFrame->GetLineScrollAmount();
108051:   }
108051: 
108051:   // If there is no scrollable frame and page scrolling, use view port size.
108051:   if (isPage) {
108057:     return aPresContext->GetVisibleArea().Size();
108051:   }
108051: 
108051:   // If there is no scrollable frame, we should use root frame's information.
108051:   nsIFrame* rootFrame = aPresContext->PresShell()->GetRootFrame();
108051:   if (!rootFrame) {
108057:     return nsSize(0, 0);
108051:   }
108051:   nsRefPtr<nsFontMetrics> fm;
108051:   nsLayoutUtils::GetFontMetricsForFrame(rootFrame, getter_AddRefs(fm),
108051:     nsLayoutUtils::FontSizeInflationFor(rootFrame));
108057:   NS_ENSURE_TRUE(fm, nsSize(0, 0));
120305:   return nsSize(fm->AveCharWidth(), fm->MaxHeight());
108050: }
108050: 
108059: void
108059: nsEventStateManager::DoScrollText(nsIScrollableFrame* aScrollableFrame,
108059:                                   widget::WheelEvent* aEvent)
108050: {
108059:   MOZ_ASSERT(aScrollableFrame);
108059:   MOZ_ASSERT(aEvent);
108059: 
108059:   nsIFrame* scrollFrame = do_QueryFrame(aScrollableFrame);
108050:   MOZ_ASSERT(scrollFrame);
108050:   nsWeakFrame scrollFrameWeak(scrollFrame);
108050: 
108050:   nsIFrame* lastScrollFrame = nsMouseWheelTransaction::GetTargetFrame();
108050:   if (!lastScrollFrame) {
108059:     nsMouseWheelTransaction::BeginTransaction(scrollFrame, aEvent);
108050:   } else if (lastScrollFrame != scrollFrame) {
108050:     nsMouseWheelTransaction::EndTransaction();
108059:     nsMouseWheelTransaction::BeginTransaction(scrollFrame, aEvent);
108050:   } else {
108059:     nsMouseWheelTransaction::UpdateTransaction(aEvent);
108059:   }
108050: 
108050:   // When the scroll event will not scroll any views, UpdateTransaction
108050:   // fired MozMouseScrollFailed event which is for automated testing.
108050:   // In the event handler, the target frame might be destroyed.  Then,
108050:   // we should not try scrolling anything.
108050:   if (!scrollFrameWeak.IsAlive()) {
108050:     nsMouseWheelTransaction::EndTransaction();
108059:     return;
108059:   }
108059: 
108059:   // Default action's actual scroll amount should be computed from device
108059:   // pixels.
108059:   nsPresContext* pc = scrollFrame->PresContext();
108059:   nsSize scrollAmount = GetScrollAmount(pc, aEvent, aScrollableFrame);
108059:   nsIntSize scrollAmountInDevPixels(
108059:     pc->AppUnitsToDevPixels(scrollAmount.width),
108059:     pc->AppUnitsToDevPixels(scrollAmount.height));
108743:   nsIntPoint actualDevPixelScrollAmount =
108743:     DeltaAccumulator::GetInstance()->
108743:       ComputeScrollAmountForDefaultAction(aEvent, scrollAmountInDevPixels);
108059: 
110714:   // Don't scroll around the axis whose overflow style is hidden.
110714:   nsPresContext::ScrollbarStyles overflowStyle =
110714:                                    aScrollableFrame->GetScrollbarStyles();
110714:   if (overflowStyle.mHorizontal == NS_STYLE_OVERFLOW_HIDDEN) {
110714:     actualDevPixelScrollAmount.x = 0;
110714:   }
110714:   if (overflowStyle.mVertical == NS_STYLE_OVERFLOW_HIDDEN) {
110714:     actualDevPixelScrollAmount.y = 0;
110714:   }
110714: 
108059:   nsIAtom* origin = nullptr;
108059:   switch (aEvent->deltaMode) {
108059:     case nsIDOMWheelEvent::DOM_DELTA_LINE:
108059:       origin = nsGkAtoms::mouseWheel;
108059:       break;
108059:     case nsIDOMWheelEvent::DOM_DELTA_PAGE:
108059:       origin = nsGkAtoms::pages;
108059:       break;
108059:     case nsIDOMWheelEvent::DOM_DELTA_PIXEL:
108059:       origin = nsGkAtoms::pixels;
108059:       break;
108059:     default:
108059:       MOZ_NOT_REACHED("Invalid deltaMode value comes");
108059:       return;
108059:   }
108059: 
120483:   // We shouldn't scroll more one page at once except when over one page scroll
120483:   // is allowed for the event.
108059:   nsSize pageSize = aScrollableFrame->GetPageScrollAmount();
108059:   nsIntSize devPixelPageSize(pc->AppUnitsToDevPixels(pageSize.width),
108059:                              pc->AppUnitsToDevPixels(pageSize.height));
120483:   if (!WheelPrefs::GetInstance()->IsOverOnePageScrollAllowedX(aEvent) &&
134925:       Abs(actualDevPixelScrollAmount.x) > devPixelPageSize.width) {
108059:     actualDevPixelScrollAmount.x =
108059:       (actualDevPixelScrollAmount.x >= 0) ? devPixelPageSize.width :
108059:                                             -devPixelPageSize.width;
108059:   }
108059: 
120483:   if (!WheelPrefs::GetInstance()->IsOverOnePageScrollAllowedY(aEvent) &&
134925:       Abs(actualDevPixelScrollAmount.y) > devPixelPageSize.height) {
108059:     actualDevPixelScrollAmount.y =
108059:       (actualDevPixelScrollAmount.y >= 0) ? devPixelPageSize.height :
108059:                                             -devPixelPageSize.height;
108059:   }
108059: 
108743:   bool isDeltaModePixel =
108743:     (aEvent->deltaMode == nsIDOMWheelEvent::DOM_DELTA_PIXEL);
108743: 
108063:   nsIScrollableFrame::ScrollMode mode;
108063:   switch (aEvent->scrollType) {
108063:     case widget::WheelEvent::SCROLL_DEFAULT:
108063:       if (isDeltaModePixel) {
108063:         mode = nsIScrollableFrame::NORMAL;
108063:       } else {
108063:         mode = nsIScrollableFrame::SMOOTH;
108063:       }
108063:       break;
108063:     case widget::WheelEvent::SCROLL_SYNCHRONOUSLY:
108063:       mode = nsIScrollableFrame::INSTANT;
108063:       break;
108063:     case widget::WheelEvent::SCROLL_ASYNCHRONOUSELY:
108063:       mode = nsIScrollableFrame::NORMAL;
108063:       break;
108063:     case widget::WheelEvent::SCROLL_SMOOTHLY:
108063:       mode = nsIScrollableFrame::SMOOTH;
108063:       break;
108063:     default:
108063:       MOZ_NOT_REACHED("Invalid scrollType value comes");
108063:       return;
108063:   }
 70338: 
 37058:   nsIntPoint overflow;
108059:   aScrollableFrame->ScrollBy(actualDevPixelScrollAmount,
108059:                              nsIScrollableFrame::DEVICE_PIXELS,
108059:                              mode, &overflow, origin);
108059: 
111054:   if (!scrollFrameWeak.IsAlive()) {
111054:     // If the scroll causes changing the layout, we can think that the event
111054:     // has been completely consumed by the content.  Then, users probably don't
111054:     // want additional action.
111054:     aEvent->overflowDeltaX = aEvent->overflowDeltaY = 0;
111054:   } else if (isDeltaModePixel) {
108059:     aEvent->overflowDeltaX = overflow.x;
108059:     aEvent->overflowDeltaY = overflow.y;
108059:   } else {
108059:     aEvent->overflowDeltaX =
108059:       static_cast<double>(overflow.x) / scrollAmountInDevPixels.width;
108059:     aEvent->overflowDeltaY =
108059:       static_cast<double>(overflow.y) / scrollAmountInDevPixels.height;
108059:   }
110714: 
110714:   // If CSS overflow properties caused not to scroll, the overflowDelta* values
110714:   // should be same as delta* values since they may be used as gesture event by
111054:   // widget.  However, if there is another scrollable element in the ancestor
111054:   // along the axis, probably users don't want the operation to cause
111054:   // additional action such as moving history.  In such case, overflowDelta
111054:   // values should stay zero.
111054:   if (scrollFrameWeak.IsAlive()) {
111054:     if (aEvent->deltaX &&
111054:         overflowStyle.mHorizontal == NS_STYLE_OVERFLOW_HIDDEN &&
111054:         !ComputeScrollTarget(scrollFrame, aEvent,
111054:                              COMPUTE_SCROLLABLE_ANCESTOR_ALONG_X_AXIS)) {
110714:       aEvent->overflowDeltaX = aEvent->deltaX;
110714:     }
111054:     if (aEvent->deltaY &&
111054:         overflowStyle.mVertical == NS_STYLE_OVERFLOW_HIDDEN &&
111054:         !ComputeScrollTarget(scrollFrame, aEvent,
111054:                              COMPUTE_SCROLLABLE_ANCESTOR_ALONG_Y_AXIS)) {
110714:       aEvent->overflowDeltaY = aEvent->deltaY;
110714:     }
111054:   }
110714: 
110714:   NS_ASSERTION(aEvent->overflowDeltaX == 0 ||
111054:     (aEvent->overflowDeltaX > 0) == (aEvent->deltaX > 0),
110714:     "The sign of overflowDeltaX is different from the scroll direction");
110714:   NS_ASSERTION(aEvent->overflowDeltaY == 0 ||
111054:     (aEvent->overflowDeltaY > 0) == (aEvent->deltaY > 0),
110714:     "The sign of overflowDeltaY is different from the scroll direction");
110714: 
108066:   WheelPrefs::GetInstance()->CancelApplyingUserPrefsFromOverflowDelta(aEvent);
 28609: }
 28609: 
 31443: void
 31443: nsEventStateManager::DecideGestureEvent(nsGestureNotifyEvent* aEvent,
 31443:                                         nsIFrame* targetFrame)
 31443: {
 31443: 
 31443:   NS_ASSERTION(aEvent->message == NS_GESTURENOTIFY_EVENT_START,
 31443:                "DecideGestureEvent called with a non-gesture event");
 31443: 
 31443:   /* Check the ancestor tree to decide if any frame is willing* to receive
 31443:    * a MozPixelScroll event. If that's the case, the current touch gesture
 31443:    * will be used as a pan gesture; otherwise it will be a regular
 31443:    * mousedown/mousemove/click event.
 31443:    *
 31443:    * *willing: determine if it makes sense to pan the element using scroll events:
 31443:    *  - For web content: if there are any visible scrollbars on the touch point
 31443:    *  - For XUL: if it's an scrollable element that can currently scroll in some
 31443:     *    direction.
 31443:    *
 31443:    * Note: we'll have to one-off various cases to ensure a good usable behavior
 31443:    */
 31443:   nsGestureNotifyEvent::ePanDirection panDirection = nsGestureNotifyEvent::ePanNone;
 79445:   bool displayPanFeedback = false;
 31443:   for (nsIFrame* current = targetFrame; current;
 31443:        current = nsLayoutUtils::GetCrossDocParentFrame(current)) {
 31443: 
 31443:     nsIAtom* currentFrameType = current->GetType();
 31443: 
 31443:     // Scrollbars should always be draggable
 31443:     if (currentFrameType == nsGkAtoms::scrollbarFrame) {
 31443:       panDirection = nsGestureNotifyEvent::ePanNone;
 31443:       break;
 31443:     }
 31443: 
 31443: #ifdef MOZ_XUL
 31443:     // Special check for trees
 31443:     nsTreeBodyFrame* treeFrame = do_QueryFrame(current);
 31443:     if (treeFrame) {
 31443:       if (treeFrame->GetHorizontalOverflow()) {
 31443:         panDirection = nsGestureNotifyEvent::ePanHorizontal;
 31443:       }
 31443:       if (treeFrame->GetVerticalOverflow()) {
 31443:         panDirection = nsGestureNotifyEvent::ePanVertical;
 31443:       }
 31443:       break;
 31443:     }
 31443: #endif
 31443: 
 31443:     nsIScrollableFrame* scrollableFrame = do_QueryFrame(current);
 31443:     if (scrollableFrame) {
 31443:       if (current->IsFrameOfType(nsIFrame::eXULBox)) {
 80486:         displayPanFeedback = true;
 31443: 
 37061:         nsRect scrollRange = scrollableFrame->GetScrollRange();
 79445:         bool canScrollHorizontally = scrollRange.width > 0;
 31443: 
 31443:         if (targetFrame->GetType() == nsGkAtoms::menuFrame) {
 31443:           // menu frames report horizontal scroll when they have submenus
 31443:           // and we don't want that
 80486:           canScrollHorizontally = false;
 80486:           displayPanFeedback = false;
 31443:         }
 31443: 
 31443:         // Vertical panning has priority over horizontal panning, so
 37061:         // when vertical movement is possible we can just finish the loop.
 37061:         if (scrollRange.height > 0) {
 31443:           panDirection = nsGestureNotifyEvent::ePanVertical;
 31443:           break;
 31443:         }
 31443: 
 37061:         if (canScrollHorizontally) {
 31443:           panDirection = nsGestureNotifyEvent::ePanHorizontal;
 80486:           displayPanFeedback = false;
 31443:         }
 31443:       } else { //Not a XUL box
108991:         uint32_t scrollbarVisibility = scrollableFrame->GetScrollbarVisibility();
 31443: 
 31443:         //Check if we have visible scrollbars
 37292:         if (scrollbarVisibility & nsIScrollableFrame::VERTICAL) {
 31443:           panDirection = nsGestureNotifyEvent::ePanVertical;
 80486:           displayPanFeedback = true;
 31443:           break;
 31443:         }
 31443: 
 37292:         if (scrollbarVisibility & nsIScrollableFrame::HORIZONTAL) {
 31443:           panDirection = nsGestureNotifyEvent::ePanHorizontal;
 80486:           displayPanFeedback = true;
 31443:         }
 37061:       }
 31443:     } //scrollableFrame
 31443:   } //ancestor chain
 31443: 
 31443:   aEvent->displayPanFeedback = displayPanFeedback;
 31443:   aEvent->panDirection = panDirection;
 31443: }
 31443: 
 58135: #ifdef XP_MACOSX
 47793: static bool
 47793: NodeAllowsClickThrough(nsINode* aNode)
 47793: {
 47793:   while (aNode) {
 47793:     if (aNode->IsElement() && aNode->AsElement()->IsXUL()) {
 47793:       mozilla::dom::Element* element = aNode->AsElement();
 47793:       static nsIContent::AttrValuesArray strings[] =
106838:         {&nsGkAtoms::always, &nsGkAtoms::never, nullptr};
 47793:       switch (element->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::clickthrough,
 47793:                                        strings, eCaseMatters)) {
 47793:         case 0:
 47793:           return true;
 47793:         case 1:
 47793:           return false;
 47793:       }
 47793:     }
 47793:     aNode = nsContentUtils::GetCrossDocParentNode(aNode);
 47793:   }
 47793:   return true;
 47793: }
 58135: #endif
 47793: 
 68780: nsresult
     1: nsEventStateManager::PostHandleEvent(nsPresContext* aPresContext,
     1:                                      nsEvent *aEvent,
     1:                                      nsIFrame* aTargetFrame,
 82566:                                      nsEventStatus* aStatus)
     1: {
     1:   NS_ENSURE_ARG(aPresContext);
     1:   NS_ENSURE_ARG_POINTER(aStatus);
    55: 
 73592:   HandleCrossProcessEvent(aEvent, aTargetFrame, aStatus);
 73592: 
     1:   mCurrentTarget = aTargetFrame;
106838:   mCurrentTargetContent = nullptr;
    55: 
  8236:   // Most of the events we handle below require a frame.
  8236:   // Add special cases here.
 55257:   if (!mCurrentTarget && aEvent->message != NS_MOUSE_BUTTON_UP &&
 55257:       aEvent->message != NS_MOUSE_BUTTON_DOWN) {
    55:     return NS_OK;
    55:   }
    55: 
     1:   //Keep the prescontext alive, we might need it after event dispatch
     1:   nsRefPtr<nsPresContext> presContext = aPresContext;
    55:   nsresult ret = NS_OK;
     1: 
     1:   switch (aEvent->message) {
     1:   case NS_MOUSE_BUTTON_DOWN:
     1:     {
  3233:       if (static_cast<nsMouseEvent*>(aEvent)->button == nsMouseEvent::eLeftButton &&
 52199:           !sNormalLMouseEventInProcess) {
 32435:         // We got a mouseup event while a mousedown event was being processed.
 32435:         // Make sure that the capturing content is cleared.
106838:         nsIPresShell::SetCapturingContent(nullptr, 0);
     1:         break;
     1:       }
     1: 
 55892:       nsCOMPtr<nsIContent> activeContent;
     1:       if (nsEventStatus_eConsumeNoDefault != *aStatus) {
     1:         nsCOMPtr<nsIContent> newFocus;      
 79445:         bool suppressBlur = false;
     1:         if (mCurrentTarget) {
 79435:           mCurrentTarget->GetContentForEvent(aEvent, getter_AddRefs(newFocus));
132812:           const nsStyleUserInterface* ui = mCurrentTarget->StyleUserInterface();
134640:           activeContent = mCurrentTarget->GetContent();
134640: 
134640:           // In some cases, we do not want to even blur the current focused
134640:           // element. Those cases are:
134640:           // 1. -moz-user-focus CSS property is set to 'ignore';
134640:           // 2. Element with NS_EVENT_STATE_DISABLED
134640:           //    (aka :disabled pseudo-class for HTML element);
134640:           // 3. XUL control element has the disabled property set to 'true'.
134640:           //
134640:           // We can't use nsIFrame::IsFocusable() because we want to blur when
134640:           // we click on a visibility: none element.
134640:           // We can't use nsIContent::IsFocusable() because we want to blur when
134640:           // we click on a non-focusable element like a <div>.
134640:           // We have to use |aEvent->target| to not make sure we do not check an
134640:           // anonymous node of the targeted element.
134381:           suppressBlur = (ui->mUserFocus == NS_STYLE_USER_FOCUS_IGNORE);
134640: 
134640:           if (!suppressBlur) {
134640:             nsCOMPtr<Element> element = do_QueryInterface(aEvent->target);
134640:             suppressBlur = element &&
134640:                            element->State().HasState(NS_EVENT_STATE_DISABLED);
134640:           }
134640: 
134640:           if (!suppressBlur) {
134640:             nsCOMPtr<nsIDOMXULControlElement> xulControl =
134640:               do_QueryInterface(aEvent->target);
134640:             if (xulControl) {
134640:               bool disabled;
134640:               xulControl->GetDisabled(&disabled);
134640:               suppressBlur = disabled;
134640:             }
134640:           }
 29018:         }
 29018: 
 41068:         nsIFrame* currFrame = mCurrentTarget;
 41068: 
 41068:         // When a root content which isn't editable but has an editable HTML
 41068:         // <body> element is clicked, we should redirect the focus to the
 41068:         // the <body> element.  E.g., when an user click bottom of the editor
 41068:         // where is outside of the <body> element, the <body> should be focused
 41068:         // and the user can edit immediately after that.
 41068:         //
 41068:         // NOTE: The newFocus isn't editable that also means it's not in
 41068:         // designMode.  In designMode, all contents are not focusable.
 41068:         if (newFocus && !newFocus->IsEditable()) {
 41068:           nsIDocument *doc = newFocus->GetCurrentDoc();
 41634:           if (doc && newFocus == doc->GetRootElement()) {
 41068:             nsIContent *bodyContent =
 41068:               nsLayoutUtils::GetEditableRootContentByContentEditable(doc);
 41068:             if (bodyContent) {
 41068:               nsIFrame* bodyFrame = bodyContent->GetPrimaryFrame();
 41068:               if (bodyFrame) {
 41068:                 currFrame = bodyFrame;
 41068:                 newFocus = bodyContent;
 41068:               }
 41068:             }
 41068:           }
 41068:         }
 41068: 
 29018:         // When the mouse is pressed, the default action is to focus the
 29018:         // target. Look for the nearest enclosing focusable frame.
     1:         while (currFrame) {
     1:           // If the mousedown happened inside a popup, don't
     1:           // try to set focus on one of its containing elements
132812:           const nsStyleDisplay* display = currFrame->StyleDisplay();
     1:           if (display->mDisplay == NS_STYLE_DISPLAY_POPUP) {
106838:             newFocus = nullptr;
     1:             break;
     1:           }
     1: 
108991:           int32_t tabIndexUnused;
 80486:           if (currFrame->IsFocusable(&tabIndexUnused, true)) {
     1:             newFocus = currFrame->GetContent();
     1:             nsCOMPtr<nsIDOMElement> domElement(do_QueryInterface(newFocus));
     1:             if (domElement)
     1:               break;
     1:           }
     1:           currFrame = currFrame->GetParent();
     1:         }
     1: 
 29018:         nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:         if (fm) {
 29018:           // if something was found to focus, focus it. Otherwise, if the
 29018:           // element that was clicked doesn't have -moz-user-focus: ignore,
 29018:           // clear the existing focus. For -moz-user-focus: ignore, the focus
 29018:           // is just left as is.
 29018:           // Another effect of mouse clicking, handled in nsSelection, is that
 29018:           // it should update the caret position to where the mouse was
 29018:           // clicked. Because the focus is cleared when clicking on a
 29018:           // non-focusable node, the next press of the tab key will cause
 29018:           // focus to be shifted from the caret position instead of the root.
 29018:           if (newFocus && currFrame) {
 29018:             // use the mouse flag and the noscroll flag so that the content
 29018:             // doesn't unexpectedly scroll when clicking an element that is
 29018:             // only hald visible
 29018:             nsCOMPtr<nsIDOMElement> newFocusElement = do_QueryInterface(newFocus);
 29018:             fm->SetFocus(newFocusElement, nsIFocusManager::FLAG_BYMOUSE |
 29018:                                           nsIFocusManager::FLAG_NOSCROLL);
 29018:           }
     1:           else if (!suppressBlur) {
 29018:             // clear the focus within the frame and then set it as the
 29018:             // focused frame
 29018:             EnsureDocument(mPresContext);
 29018:             if (mDocument) {
 41071: #ifdef XP_MACOSX
 41071:               if (!activeContent || !activeContent->IsXUL())
 41071: #endif
 29018:                 fm->ClearFocus(mDocument->GetWindow());
 29018:               fm->SetFocusedWindow(mDocument->GetWindow());
 29018:             }
 29018:           }
     1:         }
     1: 
     1:         // The rest is left button-specific.
  3233:         if (static_cast<nsMouseEvent*>(aEvent)->button !=
     1:             nsMouseEvent::eLeftButton)
     1:           break;
     1: 
     1:         if (activeContent) {
     1:           // The nearest enclosing element goes into the
     1:           // :active state.  If we fail the QI to DOMElement,
     1:           // then we know we're only a node, and that we need
     1:           // to obtain our parent element and put it into :active
     1:           // instead.
     1:           nsCOMPtr<nsIDOMElement> elt(do_QueryInterface(activeContent));
     1:           if (!elt) {
     1:             nsIContent* par = activeContent->GetParent();
     1:             if (par)
     1:               activeContent = par;
     1:           }
     1:         }
     1:       }
     1:       else {
     1:         // if we're here, the event handler returned false, so stop
     1:         // any of our own processing of a drag. Workaround for bug 43258.
     1:         StopTrackingDragGesture();
 61173: 
 61173:         // When the event was cancelled, there is currently a chrome document
 61173:         // focused and a mousedown just occurred on a content document, ensure
 61173:         // that the window that was clicked is focused.
 61173:         EnsureDocument(mPresContext);
 61173:         nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 61173:         if (mDocument && fm) {
 61173:           nsCOMPtr<nsIDOMWindow> currentWindow;
 61173:           fm->GetFocusedWindow(getter_AddRefs(currentWindow));
118594:           if (currentWindow && mDocument->GetWindow() &&
118594:               currentWindow != mDocument->GetWindow() &&
 61173:               !nsContentUtils::IsChromeDoc(mDocument)) {
118594:             nsCOMPtr<nsIDOMWindow> currentTop;
118594:             nsCOMPtr<nsIDOMWindow> newTop;
118860:             currentWindow->GetTop(getter_AddRefs(currentTop));
118860:             mDocument->GetWindow()->GetTop(getter_AddRefs(newTop));
 61173:             nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(currentWindow);
 61173:             nsCOMPtr<nsIDocument> currentDoc = do_QueryInterface(win->GetExtantDocument());
118594:             if (nsContentUtils::IsChromeDoc(currentDoc) ||
118594:                 (currentTop && newTop && currentTop != newTop)) {
 61173:               fm->SetFocusedWindow(mDocument->GetWindow());
 61173:             }
 61173:           }
 61173:         }
     1:       }
 56644:       SetActiveManager(this, activeContent);
     1:     }
     1:     break;
     1:   case NS_MOUSE_BUTTON_UP:
     1:     {
 56644:       ClearGlobalActiveContent(this);
 39761:       if (IsMouseEventReal(aEvent)) {
     1:         if (!mCurrentTarget) {
 68780:           GetEventTarget();
  8236:         }
101341:         // Make sure to dispatch the click even if there is no frame for
101341:         // the current target element. This is required for Web compatibility.
 39761:         ret = CheckForAndDispatchClick(presContext, (nsMouseEvent*)aEvent,
 39761:                                        aStatus);
 39761:       }
 32435: 
     1:       nsIPresShell *shell = presContext->GetPresShell();
     1:       if (shell) {
 70097:         nsRefPtr<nsFrameSelection> frameSelection = shell->FrameSelection();
 80486:         frameSelection->SetMouseDownState(false);
     1:       }
     1:     }
     1:     break;
108059:   case NS_WHEEL_WHEEL:
 19319:     {
126028:       MOZ_ASSERT(aEvent->mFlags.mIsTrusted);
108059: 
108059:       if (*aStatus == nsEventStatus_eConsumeNoDefault) {
108059:         break;
108059:       }
108059: 
108059:       widget::WheelEvent* wheelEvent = static_cast<widget::WheelEvent*>(aEvent);
108062:       switch (WheelPrefs::GetInstance()->ComputeActionFor(wheelEvent)) {
108062:         case WheelPrefs::ACTION_SCROLL: {
127591:           if (!wheelEvent->deltaX && !wheelEvent->deltaY) {
127591:             break;
127591:           }
108059:           // For scrolling of default action, we should honor the mouse wheel
108059:           // transaction.
108059:           nsIScrollableFrame* scrollTarget =
111054:             ComputeScrollTarget(aTargetFrame, wheelEvent,
111054:                                 COMPUTE_DEFAULT_ACTION_TARGET);
108346:           wheelEvent->overflowDeltaX = wheelEvent->deltaX;
108346:           wheelEvent->overflowDeltaY = wheelEvent->deltaY;
108346:           WheelPrefs::GetInstance()->
108346:             CancelApplyingUserPrefsFromOverflowDelta(wheelEvent);
108059:           if (scrollTarget) {
108059:             DoScrollText(scrollTarget, wheelEvent);
108059:           } else {
108059:             nsMouseWheelTransaction::EndTransaction();
108059:           }
108062:           break;
108062:         }
127591:         case WheelPrefs::ACTION_HISTORY: {
127591:           // If this event doesn't cause NS_MOUSE_SCROLL event or the direction
127591:           // is oblique, don't perform history back/forward.
127591:           int32_t intDelta = wheelEvent->GetPreferredIntDelta();
127591:           if (!intDelta) {
108062:             break;
127591:           }
127591:           DoScrollHistory(intDelta);
108062:           break;
127591:         }
127591:         case WheelPrefs::ACTION_ZOOM: {
127591:           // If this event doesn't cause NS_MOUSE_SCROLL event or the direction
127591:           // is oblique, don't perform zoom in/out.
127591:           int32_t intDelta = wheelEvent->GetPreferredIntDelta();
127591:           if (!intDelta) {
127591:             break;
127591:           }
127591:           DoScrollZoom(aTargetFrame, intDelta);
127591:           break;
127591:         }
127591:         case WheelPrefs::ACTION_NONE:
108160:         default:
127591:           // If we don't handle the wheel event, all of the delta values must
127591:           // be overflown delta values.
127591:           wheelEvent->overflowDeltaX = wheelEvent->deltaX;
127591:           wheelEvent->overflowDeltaY = wheelEvent->deltaY;
127591:           WheelPrefs::GetInstance()->
127591:             CancelApplyingUserPrefsFromOverflowDelta(wheelEvent);
108160:           break;
108062:       }
108059:       *aStatus = nsEventStatus_eConsumeNoDefault;
 19319:     }
     1:     break;
     1: 
 31443:   case NS_GESTURENOTIFY_EVENT_START:
 31443:     {
 31443:       if (nsEventStatus_eConsumeNoDefault != *aStatus)
 31443:         DecideGestureEvent(static_cast<nsGestureNotifyEvent*>(aEvent), mCurrentTarget);
 31443:     }
 31443:     break;
 31443: 
 18445:   case NS_DRAGDROP_ENTER:
 18445:   case NS_DRAGDROP_OVER:
 18445:     {
 18445:       NS_ASSERTION(aEvent->eventStructType == NS_DRAG_EVENT, "Expected a drag event");
 18445: 
 18445:       nsCOMPtr<nsIDragSession> dragSession = nsContentUtils::GetDragSession();
 18445:       if (!dragSession)
 18445:         break;
 18445: 
 34272:       // Reset the flag.
 80486:       dragSession->SetOnlyChromeDrop(false);
 34272:       if (mPresContext) {
 34272:         EnsureDocument(mPresContext);
 34272:       }
 79445:       bool isChromeDoc = nsContentUtils::IsChromeDoc(mDocument);
 34272: 
 18445:       // the initial dataTransfer is the one from the dragstart event that
 18445:       // was set on the dragSession when the drag began.
 89615:       nsCOMPtr<nsIDOMDataTransfer> dataTransfer;
 18445:       nsCOMPtr<nsIDOMDataTransfer> initialDataTransfer;
 18445:       dragSession->GetDataTransfer(getter_AddRefs(initialDataTransfer));
 18445: 
 33528:       nsDragEvent *dragEvent = (nsDragEvent*)aEvent;
 33528: 
 33528:       // collect any changes to moz cursor settings stored in the event's
 33528:       // data transfer.
 33528:       UpdateDragDataTransfer(dragEvent);
 33528: 
 18445:       // cancelling a dragenter or dragover event means that a drop should be
 18445:       // allowed, so update the dropEffect and the canDrop state to indicate
 18445:       // that a drag is allowed. If the event isn't cancelled, a drop won't be
 18445:       // allowed. Essentially, to allow a drop somewhere, specify the effects
 18445:       // using the effectAllowed and dropEffect properties in a dragenter or
 18445:       // dragover event and cancel the event. To not allow a drop somewhere,
 18445:       // don't cancel the event or set the effectAllowed or dropEffect to
 18445:       // "none". This way, if the event is just ignored, no drop will be
 18445:       // allowed.
108991:       uint32_t dropEffect = nsIDragService::DRAGDROP_ACTION_NONE;
 18445:       if (nsEventStatus_eConsumeNoDefault == *aStatus) {
 18445:         // if the event has a dataTransfer set, use it.
 18445:         if (dragEvent->dataTransfer) {
 18445:           // get the dataTransfer and the dropEffect that was set on it
 18445:           dataTransfer = do_QueryInterface(dragEvent->dataTransfer);
 18445:           dataTransfer->GetDropEffectInt(&dropEffect);
 18445:         }
 18445:         else {
 18445:           // if dragEvent->dataTransfer is null, it means that no attempt was
 18445:           // made to access the dataTransfer during the event, yet the event
 18445:           // was cancelled. Instead, use the initial data transfer available
 18445:           // from the drag session. The drop effect would not have been
 18445:           // initialized (which is done in nsDOMDragEvent::GetDataTransfer),
 18445:           // so set it from the drag action. We'll still want to filter it
 18445:           // based on the effectAllowed below.
 89615:           dataTransfer = initialDataTransfer;
 18445: 
108991:           uint32_t action;
 18445:           dragSession->GetDragAction(&action);
 18445: 
 18445:           // filter the drop effect based on the action. Use UNINITIALIZED as
 18445:           // any effect is allowed.
 29545:           dropEffect = nsContentUtils::FilterDropEffect(action,
 18445:                          nsIDragService::DRAGDROP_ACTION_UNINITIALIZED);
 18445:         }
 18445: 
 18445:         // At this point, if the dataTransfer is null, it means that the
 18445:         // drag was originally started by directly calling the drag service.
 18445:         // Just assume that all effects are allowed.
108991:         uint32_t effectAllowed = nsIDragService::DRAGDROP_ACTION_UNINITIALIZED;
 18445:         if (dataTransfer)
 18445:           dataTransfer->GetEffectAllowedInt(&effectAllowed);
 18445: 
 18445:         // set the drag action based on the drop effect and effect allowed.
 18445:         // The drop effect field on the drag transfer object specifies the
 18445:         // desired current drop effect. However, it cannot be used if the
 18445:         // effectAllowed state doesn't include that type of action. If the
 18445:         // dropEffect is "none", then the action will be 'none' so a drop will
 18445:         // not be allowed.
108991:         uint32_t action = nsIDragService::DRAGDROP_ACTION_NONE;
 18445:         if (effectAllowed == nsIDragService::DRAGDROP_ACTION_UNINITIALIZED ||
 18445:             dropEffect & effectAllowed)
 18445:           action = dropEffect;
 18445: 
 18445:         if (action == nsIDragService::DRAGDROP_ACTION_NONE)
 18445:           dropEffect = nsIDragService::DRAGDROP_ACTION_NONE;
 18445: 
 18445:         // inform the drag session that a drop is allowed on this node.
 18445:         dragSession->SetDragAction(action);
 18445:         dragSession->SetCanDrop(action != nsIDragService::DRAGDROP_ACTION_NONE);
 34272: 
 34272:         // For now, do this only for dragover.
 34272:         //XXXsmaug dragenter needs some more work.
 34272:         if (aEvent->message == NS_DRAGDROP_OVER && !isChromeDoc) {
 34272:           // Someone has called preventDefault(), check whether is was content.
 34272:           dragSession->SetOnlyChromeDrop(
126032:             !aEvent->mFlags.mDefaultPreventedByContent);
 34272:         }
 34272:       } else if (aEvent->message == NS_DRAGDROP_OVER && !isChromeDoc) {
 34605:         // No one called preventDefault(), so handle drop only in chrome.
 80486:         dragSession->SetOnlyChromeDrop(true);
 18445:       }
 18445: 
 18445:       // now set the drop effect in the initial dataTransfer. This ensures
 18445:       // that we can get the desired drop effect in the drop event.
 89615:       if (initialDataTransfer)
 89615:         initialDataTransfer->SetDropEffectInt(dropEffect);
 18445:     }
 18445:     break;
 18445: 
     1:   case NS_DRAGDROP_DROP:
 18445:     {
 18445:       // now fire the dragdrop event, for compatibility with XUL
 18445:       if (mCurrentTarget && nsEventStatus_eConsumeNoDefault != *aStatus) {
 18445:         nsCOMPtr<nsIContent> targetContent;
 79435:         mCurrentTarget->GetContentForEvent(aEvent,
 18445:                                            getter_AddRefs(targetContent));
 18445: 
 47148:         nsCOMPtr<nsIWidget> widget = mCurrentTarget->GetNearestWidget();
126028:         nsDragEvent event(aEvent->mFlags.mIsTrusted,
126028:                           NS_DRAGDROP_DRAGDROP, widget);
 18445: 
 18445:         nsMouseEvent* mouseEvent = static_cast<nsMouseEvent*>(aEvent);
 18445:         event.refPoint = mouseEvent->refPoint;
 46252:         if (mouseEvent->widget) {
 46252:           event.refPoint += mouseEvent->widget->WidgetToScreenOffset();
 46252:         }
 46252:         event.refPoint -= widget->WidgetToScreenOffset();
 96887:         event.modifiers = mouseEvent->modifiers;
 96888:         event.buttons = mouseEvent->buttons;
 40485:         event.inputSource = mouseEvent->inputSource;
 18445: 
 18445:         nsEventStatus status = nsEventStatus_eIgnore;
 18445:         nsCOMPtr<nsIPresShell> presShell = mPresContext->GetPresShell();
 18445:         if (presShell) {
 18445:           presShell->HandleEventWithTarget(&event, mCurrentTarget,
 18445:                                            targetContent, &status);
 18445:         }
 18445:       }
106838:       sLastDragOverFrame = nullptr;
 56644:       ClearGlobalActiveContent(this);
 18445:       break;
 18445:     }
     1:   case NS_DRAGDROP_EXIT:
 18445:      // make sure to fire the enter and exit_synth events after the
 18445:      // NS_DRAGDROP_EXIT event, otherwise we'll clean up too early
     1:     GenerateDragDropEnterExit(presContext, (nsGUIEvent*)aEvent);
     1:     break;
     1: 
     1:   case NS_KEY_UP:
     1:     break;
     1: 
     1:   case NS_KEY_PRESS:
     1:     if (nsEventStatus_eConsumeNoDefault != *aStatus) {
     1:       nsKeyEvent* keyEvent = (nsKeyEvent*)aEvent;
     1:       //This is to prevent keyboard scrolling while alt modifier in use.
 96893:       if (!keyEvent->IsAlt()) {
     1:         switch(keyEvent->keyCode) {
     1:           case NS_VK_TAB:
 29018:           case NS_VK_F6:
 29018:             EnsureDocument(mPresContext);
 29018:             nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:             if (fm && mDocument) {
     1:               // Shift focus forward or back depending on shift key
 96893:               bool isDocMove = ((nsInputEvent*)aEvent)->IsControl() ||
 29018:                                  (keyEvent->keyCode == NS_VK_F6);
108991:               uint32_t dir =
 96893:                 static_cast<nsInputEvent*>(aEvent)->IsShift() ?
108991:                   (isDocMove ? static_cast<uint32_t>(nsIFocusManager::MOVEFOCUS_BACKWARDDOC) :
108991:                                static_cast<uint32_t>(nsIFocusManager::MOVEFOCUS_BACKWARD)) :
108991:                   (isDocMove ? static_cast<uint32_t>(nsIFocusManager::MOVEFOCUS_FORWARDDOC) :
108991:                                static_cast<uint32_t>(nsIFocusManager::MOVEFOCUS_FORWARD));
 29018:               nsCOMPtr<nsIDOMElement> result;
106838:               fm->MoveFocus(mDocument->GetWindow(), nullptr, dir,
 29018:                             nsIFocusManager::FLAG_BYKEY,
 29018:                             getter_AddRefs(result));
 29018:             }
     1:             *aStatus = nsEventStatus_eConsumeNoDefault;
     1:             break;
     1:         }
     1:       }
     1:     }
     1:     break;
     1: 
     1:   case NS_MOUSE_ENTER:
     1:     if (mCurrentTarget) {
     1:       nsCOMPtr<nsIContent> targetContent;
 79435:       mCurrentTarget->GetContentForEvent(aEvent, getter_AddRefs(targetContent));
     1:       SetContentState(targetContent, NS_EVENT_STATE_HOVER);
     1:     }
     1:     break;
 47793: 
 47793: #ifdef XP_MACOSX
 47793:   case NS_MOUSE_ACTIVATE:
 47793:     if (mCurrentTarget) {
 47793:       nsCOMPtr<nsIContent> targetContent;
 79435:       mCurrentTarget->GetContentForEvent(aEvent, getter_AddRefs(targetContent));
 47793:       if (!NodeAllowsClickThrough(targetContent)) {
 47793:         *aStatus = nsEventStatus_eConsumeNoDefault;
 47793:       }
 47793:     }
 47793:     break;
 47793: #endif
     1:   }
     1: 
     1:   //Reset target frame to null to avoid mistargeting after reentrant event
106838:   mCurrentTarget = nullptr;
106838:   mCurrentTargetContent = nullptr;
     1: 
     1:   return ret;
     1: }
     1: 
 79445: bool
 54603: nsEventStateManager::RemoteQueryContentEvent(nsEvent *aEvent)
 54603: {
 54603:   nsQueryContentEvent *queryEvent =
 54603:       static_cast<nsQueryContentEvent*>(aEvent);
 54603:   if (!IsTargetCrossProcess(queryEvent)) {
 80486:     return false;
 54603:   }
 54603:   // Will not be handled locally, remote the event
 54603:   GetCrossProcessTarget()->HandleQueryContentEvent(*queryEvent);
 80486:   return true;
 54603: }
 54603: 
 54603: TabParent*
 50731: nsEventStateManager::GetCrossProcessTarget()
 50731: {
 54603:   return TabParent::GetIMETabParent();
 50731: }
 50731: 
 79445: bool
 50731: nsEventStateManager::IsTargetCrossProcess(nsGUIEvent *aEvent)
 50731: {
 54776:   // Check to see if there is a focused, editable content in chrome,
 54776:   // in that case, do not forward IME events to content
 54776:   nsIContent *focusedContent = GetFocusedContent();
 54776:   if (focusedContent && focusedContent->IsEditable())
 80486:     return false;
106838:   return TabParent::GetIMETabParent() != nullptr;
 54603: }
 50731: 
 68780: void
     1: nsEventStateManager::NotifyDestroyPresContext(nsPresContext* aPresContext)
     1: {
     1:   nsIMEStateManager::OnDestroyPresContext(aPresContext);
 98800:   if (mHoverContent) {
 98800:     // Bug 70855: Presentation is going away, possibly for a reframe.
 98800:     // Reset the hover state so that if we're recreating the presentation,
 98800:     // we won't have the old hover state still set in the new presentation,
 98800:     // as if the new presentation is resized, a new element may be hovered. 
106838:     SetContentState(nullptr, NS_EVENT_STATE_HOVER);
 98800:   }
 68780: }
 68780: 
 68780: void
     1: nsEventStateManager::SetPresContext(nsPresContext* aPresContext)
     1: {
     1:   mPresContext = aPresContext;
 68780: }
 68780: 
 68780: void
     1: nsEventStateManager::ClearFrameRefs(nsIFrame* aFrame)
     1: {
     1:   if (aFrame && aFrame == mCurrentTarget) {
     1:     mCurrentTargetContent = aFrame->GetContent();
     1:   }
     1: }
     1: 
     1: void
     1: nsEventStateManager::UpdateCursor(nsPresContext* aPresContext,
     1:                                   nsEvent* aEvent, nsIFrame* aTargetFrame,
     1:                                   nsEventStatus* aStatus)
     1: {
 73592:   if (aTargetFrame && IsRemoteTarget(aTargetFrame->GetContent())) {
 73592:     return;
 73592:   }
 73592: 
108991:   int32_t cursor = NS_STYLE_CURSOR_DEFAULT;
106838:   imgIContainer* container = nullptr;
 79445:   bool haveHotspot = false;
     1:   float hotspotX = 0.0f, hotspotY = 0.0f;
     1: 
     1:   //If cursor is locked just use the locked one
     1:   if (mLockCursor) {
     1:     cursor = mLockCursor;
     1:   }
     1:   //If not locked, look for correct cursor
     1:   else if (aTargetFrame) {
     1:       nsIFrame::Cursor framecursor;
     1:       nsPoint pt = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent,
     1:                                                                 aTargetFrame);
     1:       if (NS_FAILED(aTargetFrame->GetCursor(pt, framecursor)))
     1:         return;  // don't update the cursor if we failed to get it from the frame see bug 118877
     1:       cursor = framecursor.mCursor;
     1:       container = framecursor.mContainer;
     1:       haveHotspot = framecursor.mHaveHotspot;
     1:       hotspotX = framecursor.mHotspotX;
     1:       hotspotY = framecursor.mHotspotY;
     1:   }
     1: 
 79445:   if (Preferences::GetBool("ui.use_activity_cursor", false)) {
 32813:     // Check whether or not to show the busy cursor
 32813:     nsCOMPtr<nsISupports> pcContainer = aPresContext->GetContainer();
 32813:     nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(pcContainer));
 32813:     if (!docShell) return;
108991:     uint32_t busyFlags = nsIDocShell::BUSY_FLAGS_NONE;
 32813:     docShell->GetBusyFlags(&busyFlags);
 32813: 
 32813:     // Show busy cursor everywhere before page loads
 32813:     // and just replace the arrow cursor after page starts loading
 32813:     if (busyFlags & nsIDocShell::BUSY_FLAGS_BUSY &&
 32813:           (cursor == NS_STYLE_CURSOR_AUTO || cursor == NS_STYLE_CURSOR_DEFAULT))
 32813:     {
 32813:       cursor = NS_STYLE_CURSOR_SPINNING;
106838:       container = nullptr;
 32813:     }
 32813:   }
 32813: 
     1:   if (aTargetFrame) {
     1:     SetCursor(cursor, container, haveHotspot, hotspotX, hotspotY,
 80486:               aTargetFrame->GetNearestWidget(), false);
     1:   }
     1: 
     1:   if (mLockCursor || NS_STYLE_CURSOR_AUTO != cursor) {
     1:     *aStatus = nsEventStatus_eConsumeDoDefault;
     1:   }
     1: }
     1: 
 68780: nsresult
108991: nsEventStateManager::SetCursor(int32_t aCursor, imgIContainer* aContainer,
 79445:                                bool aHaveHotspot,
     1:                                float aHotspotX, float aHotspotY,
 79445:                                nsIWidget* aWidget, bool aLockCursor)
     1: {
 54257:   EnsureDocument(mPresContext);
 54257:   NS_ENSURE_TRUE(mDocument, NS_ERROR_FAILURE);
 54257:   sMouseOverDocument = mDocument.get();
 54257: 
     1:   nsCursor c;
     1: 
     1:   NS_ENSURE_TRUE(aWidget, NS_ERROR_FAILURE);
     1:   if (aLockCursor) {
     1:     if (NS_STYLE_CURSOR_AUTO != aCursor) {
     1:       mLockCursor = aCursor;
     1:     }
     1:     else {
     1:       //If cursor style is set to auto we unlock the cursor again.
     1:       mLockCursor = 0;
     1:     }
     1:   }
     1:   switch (aCursor) {
     1:   default:
     1:   case NS_STYLE_CURSOR_AUTO:
     1:   case NS_STYLE_CURSOR_DEFAULT:
     1:     c = eCursor_standard;
     1:     break;
     1:   case NS_STYLE_CURSOR_POINTER:
     1:     c = eCursor_hyperlink;
     1:     break;
     1:   case NS_STYLE_CURSOR_CROSSHAIR:
     1:     c = eCursor_crosshair;
     1:     break;
     1:   case NS_STYLE_CURSOR_MOVE:
     1:     c = eCursor_move;
     1:     break;
     1:   case NS_STYLE_CURSOR_TEXT:
     1:     c = eCursor_select;
     1:     break;
     1:   case NS_STYLE_CURSOR_WAIT:
     1:     c = eCursor_wait;
     1:     break;
     1:   case NS_STYLE_CURSOR_HELP:
     1:     c = eCursor_help;
     1:     break;
     1:   case NS_STYLE_CURSOR_N_RESIZE:
     1:     c = eCursor_n_resize;
     1:     break;
     1:   case NS_STYLE_CURSOR_S_RESIZE:
     1:     c = eCursor_s_resize;
     1:     break;
     1:   case NS_STYLE_CURSOR_W_RESIZE:
     1:     c = eCursor_w_resize;
     1:     break;
     1:   case NS_STYLE_CURSOR_E_RESIZE:
     1:     c = eCursor_e_resize;
     1:     break;
     1:   case NS_STYLE_CURSOR_NW_RESIZE:
     1:     c = eCursor_nw_resize;
     1:     break;
     1:   case NS_STYLE_CURSOR_SE_RESIZE:
     1:     c = eCursor_se_resize;
     1:     break;
     1:   case NS_STYLE_CURSOR_NE_RESIZE:
     1:     c = eCursor_ne_resize;
     1:     break;
     1:   case NS_STYLE_CURSOR_SW_RESIZE:
     1:     c = eCursor_sw_resize;
     1:     break;
     1:   case NS_STYLE_CURSOR_COPY: // CSS3
     1:     c = eCursor_copy;
     1:     break;
     1:   case NS_STYLE_CURSOR_ALIAS:
     1:     c = eCursor_alias;
     1:     break;
     1:   case NS_STYLE_CURSOR_CONTEXT_MENU:
     1:     c = eCursor_context_menu;
     1:     break;
     1:   case NS_STYLE_CURSOR_CELL:
     1:     c = eCursor_cell;
     1:     break;
     1:   case NS_STYLE_CURSOR_GRAB:
     1:     c = eCursor_grab;
     1:     break;
     1:   case NS_STYLE_CURSOR_GRABBING:
     1:     c = eCursor_grabbing;
     1:     break;
     1:   case NS_STYLE_CURSOR_SPINNING:
     1:     c = eCursor_spinning;
     1:     break;
     1:   case NS_STYLE_CURSOR_MOZ_ZOOM_IN:
     1:     c = eCursor_zoom_in;
     1:     break;
     1:   case NS_STYLE_CURSOR_MOZ_ZOOM_OUT:
     1:     c = eCursor_zoom_out;
     1:     break;
     1:   case NS_STYLE_CURSOR_NOT_ALLOWED:
     1:     c = eCursor_not_allowed;
     1:     break;
     1:   case NS_STYLE_CURSOR_COL_RESIZE:
     1:     c = eCursor_col_resize;
     1:     break;
     1:   case NS_STYLE_CURSOR_ROW_RESIZE:
     1:     c = eCursor_row_resize;
     1:     break;
     1:   case NS_STYLE_CURSOR_NO_DROP:
     1:     c = eCursor_no_drop;
     1:     break;
     1:   case NS_STYLE_CURSOR_VERTICAL_TEXT:
     1:     c = eCursor_vertical_text;
     1:     break;
     1:   case NS_STYLE_CURSOR_ALL_SCROLL:
     1:     c = eCursor_all_scroll;
     1:     break;
     1:   case NS_STYLE_CURSOR_NESW_RESIZE:
     1:     c = eCursor_nesw_resize;
     1:     break;
     1:   case NS_STYLE_CURSOR_NWSE_RESIZE:
     1:     c = eCursor_nwse_resize;
     1:     break;
     1:   case NS_STYLE_CURSOR_NS_RESIZE:
     1:     c = eCursor_ns_resize;
     1:     break;
     1:   case NS_STYLE_CURSOR_EW_RESIZE:
     1:     c = eCursor_ew_resize;
     1:     break;
 10405:   case NS_STYLE_CURSOR_NONE:
 10405:     c = eCursor_none;
 10405:     break;
     1:   }
     1: 
     1:   // First, try the imgIContainer, if non-null
     1:   nsresult rv = NS_ERROR_FAILURE;
     1:   if (aContainer) {
108991:     uint32_t hotspotX, hotspotY;
     1: 
     1:     // css3-ui says to use the CSS-specified hotspot if present,
     1:     // otherwise use the intrinsic hotspot, otherwise use the top left
     1:     // corner.
     1:     if (aHaveHotspot) {
108991:       int32_t imgWidth, imgHeight;
     1:       aContainer->GetWidth(&imgWidth);
     1:       aContainer->GetHeight(&imgHeight);
     1: 
129543:       // XXX std::max(NS_lround(x), 0)?
     1:       hotspotX = aHotspotX > 0.0f
108991:                    ? uint32_t(aHotspotX + 0.5f) : uint32_t(0);
108991:       if (hotspotX >= uint32_t(imgWidth))
     1:         hotspotX = imgWidth - 1;
     1:       hotspotY = aHotspotY > 0.0f
108991:                    ? uint32_t(aHotspotY + 0.5f) : uint32_t(0);
108991:       if (hotspotY >= uint32_t(imgHeight))
     1:         hotspotY = imgHeight - 1;
     1:     } else {
     1:       hotspotX = 0;
     1:       hotspotY = 0;
     1:       nsCOMPtr<nsIProperties> props(do_QueryInterface(aContainer));
     1:       if (props) {
     1:         nsCOMPtr<nsISupportsPRUint32> hotspotXWrap, hotspotYWrap;
     1: 
     1:         props->Get("hotspotX", NS_GET_IID(nsISupportsPRUint32), getter_AddRefs(hotspotXWrap));
     1:         props->Get("hotspotY", NS_GET_IID(nsISupportsPRUint32), getter_AddRefs(hotspotYWrap));
     1: 
     1:         if (hotspotXWrap)
     1:           hotspotXWrap->GetData(&hotspotX);
     1:         if (hotspotYWrap)
     1:           hotspotYWrap->GetData(&hotspotY);
     1:       }
     1:     }
     1: 
     1:     rv = aWidget->SetCursor(aContainer, hotspotX, hotspotY);
     1:   }
     1: 
     1:   if (NS_FAILED(rv))
     1:     aWidget->SetCursor(c);
     1: 
     1:   return NS_OK;
     1: }
     1: 
 15594: class NS_STACK_CLASS nsESMEventCB : public nsDispatchingCallback
     1: {
     1: public:
     1:   nsESMEventCB(nsIContent* aTarget) : mTarget(aTarget) {}
     1: 
     1:   virtual void HandleEvent(nsEventChainPostVisitor& aVisitor)
     1:   {
     1:     if (aVisitor.mPresContext) {
 36655:       nsIFrame* frame = aVisitor.mPresContext->GetPrimaryFrameFor(mTarget);
     1:       if (frame) {
     1:         frame->HandleEvent(aVisitor.mPresContext,
     1:                            (nsGUIEvent*) aVisitor.mEvent,
     1:                            &aVisitor.mEventStatus);
     1:       }
     1:     }
     1:   }
     1: 
     1:   nsCOMPtr<nsIContent> mTarget;
     1: };
     1: 
131234: /*static*/ bool
131234: nsEventStateManager::IsHandlingUserInput()
131234: {
131234:   if (sUserInputEventDepth <= 0) {
131234:     return false;
131234:   }
131234: 
131234:   TimeDuration timeout = nsContentUtils::HandlingUserInputTimeout();
131234:   return timeout <= TimeDuration(0) ||
131234:          (TimeStamp::Now() - sHandlingInputStart) <= timeout;
131234: }
131234: 
     1: nsIFrame*
108991: nsEventStateManager::DispatchMouseEvent(nsGUIEvent* aEvent, uint32_t aMessage,
     1:                                         nsIContent* aTargetContent,
     1:                                         nsIContent* aRelatedContent)
     1: {
 95203:   // http://dvcs.w3.org/hg/webevents/raw-file/default/mouse-lock.html#methods
 95203:   // "[When the mouse is locked on an element...e]vents that require the concept
 95203:   // of a mouse cursor must not be dispatched (for example: mouseover, mouseout).
 95203:   if (sIsPointerLocked &&
 95203:       (aMessage == NS_MOUSELEAVE ||
 95203:        aMessage == NS_MOUSEENTER ||
 95203:        aMessage == NS_MOUSE_ENTER_SYNTH ||
 95203:        aMessage == NS_MOUSE_EXIT_SYNTH)) {
106838:     mCurrentTargetContent = nullptr;
 95203:     nsCOMPtr<Element> pointerLockedElement =
 95203:       do_QueryReferent(nsEventStateManager::sPointerLockedElement);
 95203:     if (!pointerLockedElement) {
 95203:       NS_WARNING("Should have pointer locked element, but didn't.");
106838:       return nullptr;
 95203:     }
 95203:     nsCOMPtr<nsIContent> content = do_QueryInterface(pointerLockedElement);
 95203:     return mPresContext->GetPrimaryFrameFor(content);
 95203:   }
 95203: 
 84290:   SAMPLE_LABEL("Input", "DispatchMouseEvent");
     1:   nsEventStatus status = nsEventStatus_eIgnore;
126028:   nsMouseEvent event(aEvent->mFlags.mIsTrusted, aMessage, aEvent->widget,
     1:                      nsMouseEvent::eReal);
     1:   event.refPoint = aEvent->refPoint;
 96887:   event.modifiers = ((nsMouseEvent*)aEvent)->modifiers;
 96888:   event.buttons = ((nsMouseEvent*)aEvent)->buttons;
 34743:   event.pluginEvent = ((nsMouseEvent*)aEvent)->pluginEvent;
     1:   event.relatedTarget = aRelatedContent;
 40485:   event.inputSource = static_cast<nsMouseEvent*>(aEvent)->inputSource;
     1: 
 51626:   nsWeakFrame previousTarget = mCurrentTarget;
 51626: 
     1:   mCurrentTargetContent = aTargetContent;
     1: 
106838:   nsIFrame* targetFrame = nullptr;
     1:   if (aTargetContent) {
     1:     nsESMEventCB callback(aTargetContent);
106838:     nsEventDispatcher::Dispatch(aTargetContent, mPresContext, &event, nullptr,
     1:                                 &status, &callback);
     1: 
     1:     // Although the primary frame was checked in event callback, 
     1:     // it may not be the same object after event dispatching and handling.
     1:     // So we need to refetch it.
 36655:     if (mPresContext) {
 36655:       targetFrame = mPresContext->GetPrimaryFrameFor(aTargetContent);
     1:     }
     1:   }
     1: 
106838:   mCurrentTargetContent = nullptr;
 51626:   mCurrentTarget = previousTarget;
     1: 
     1:   return targetFrame;
     1: }
     1: 
 78422: class MouseEnterLeaveDispatcher
 78422: {
 78422: public:
 78422:   MouseEnterLeaveDispatcher(nsEventStateManager* aESM,
 78422:                             nsIContent* aTarget, nsIContent* aRelatedTarget,
108991:                             nsGUIEvent* aEvent, uint32_t aType)
 78422:   : mESM(aESM), mEvent(aEvent), mType(aType)
 78422:   {
 78422:     nsPIDOMWindow* win =
106838:       aTarget ? aTarget->OwnerDoc()->GetInnerWindow() : nullptr;
 78422:     if (win && win->HasMouseEnterLeaveEventListeners()) {
 78422:       mRelatedTarget = aRelatedTarget ?
118445:         aRelatedTarget->FindFirstNonChromeOnlyAccessContent() : nullptr;
106838:       nsINode* commonParent = nullptr;
 78422:       if (aTarget && aRelatedTarget) {
 78422:         commonParent =
 78422:           nsContentUtils::GetCommonAncestor(aTarget, aRelatedTarget);
 78422:       }
 78422:       nsIContent* current = aTarget;
 78422:       // Note, it is ok if commonParent is null!
 78422:       while (current && current != commonParent) {
118445:         if (!current->ChromeOnlyAccess()) {
 78422:           mTargets.AppendObject(current);
 78422:         }
 78422:         // mouseenter/leave is fired only on elements.
 78422:         current = current->GetParent();
 78422:       }
 78422:     }
 78422:   }
 78422: 
 78422:   ~MouseEnterLeaveDispatcher()
 78422:   {
102778:     if (mType == NS_MOUSEENTER) {
108991:       for (int32_t i = mTargets.Count() - 1; i >= 0; --i) {
102778:         mESM->DispatchMouseEvent(mEvent, mType, mTargets[i], mRelatedTarget);
102778:       }
102778:     } else {
108991:       for (int32_t i = 0; i < mTargets.Count(); ++i) {
 78422:         mESM->DispatchMouseEvent(mEvent, mType, mTargets[i], mRelatedTarget);
 78422:       }
 78422:     }
102778:   }
 78422: 
 78422:   nsEventStateManager*   mESM;
 78422:   nsCOMArray<nsIContent> mTargets;
 78422:   nsCOMPtr<nsIContent>   mRelatedTarget;
 78422:   nsGUIEvent*            mEvent;
108991:   uint32_t               mType;
 78422: };
 78422: 
     1: void
     1: nsEventStateManager::NotifyMouseOut(nsGUIEvent* aEvent, nsIContent* aMovingInto)
     1: {
     1:   if (!mLastMouseOverElement)
     1:     return;
     1:   // Before firing mouseout, check for recursion
     1:   if (mLastMouseOverElement == mFirstMouseOutEventElement)
     1:     return;
     1: 
     1:   if (mLastMouseOverFrame) {
     1:     // if the frame is associated with a subdocument,
     1:     // tell the subdocument that we're moving out of it
 51754:     nsSubDocumentFrame* subdocFrame = do_QueryFrame(mLastMouseOverFrame.GetFrame());
     1:     if (subdocFrame) {
     1:       nsCOMPtr<nsIDocShell> docshell;
     1:       subdocFrame->GetDocShell(getter_AddRefs(docshell));
     1:       if (docshell) {
 39823:         nsRefPtr<nsPresContext> presContext;
     1:         docshell->GetPresContext(getter_AddRefs(presContext));
     1: 
     1:         if (presContext) {
 68780:           nsEventStateManager* kidESM = presContext->EventStateManager();
     1:           // Not moving into any element in this subdocument
106838:           kidESM->NotifyMouseOut(aEvent, nullptr);
     1:         }
     1:       }
     1:     }
     1:   }
     1:   // That could have caused DOM events which could wreak havoc. Reverify
     1:   // things and be careful.
     1:   if (!mLastMouseOverElement)
     1:     return;
     1: 
     1:   // Store the first mouseOut event we fire and don't refire mouseOut
     1:   // to that element while the first mouseOut is still ongoing.
     1:   mFirstMouseOutEventElement = mLastMouseOverElement;
     1: 
     1:   // Don't touch hover state if aMovingInto is non-null.  Caller will update
     1:   // hover state itself, and we have optimizations for hover switching between
     1:   // two nearby elements both deep in the DOM tree that would be defeated by
     1:   // switching the hover state to null here.
     1:   if (!aMovingInto) {
     1:     // Unset :hover
106838:     SetContentState(nullptr, NS_EVENT_STATE_HOVER);
     1:   }
     1: 
 78422:   MouseEnterLeaveDispatcher leaveDispatcher(this, mLastMouseOverElement, aMovingInto,
 78422:                                             aEvent, NS_MOUSELEAVE);
 78422: 
     1:   // Fire mouseout
     1:   DispatchMouseEvent(aEvent, NS_MOUSE_EXIT_SYNTH,
     1:                      mLastMouseOverElement, aMovingInto);
     1:   
106838:   mLastMouseOverFrame = nullptr;
106838:   mLastMouseOverElement = nullptr;
     1:   
     1:   // Turn recursion protection back off
106838:   mFirstMouseOutEventElement = nullptr;
     1: }
     1: 
     1: void
     1: nsEventStateManager::NotifyMouseOver(nsGUIEvent* aEvent, nsIContent* aContent)
     1: {
     1:   NS_ASSERTION(aContent, "Mouse must be over something");
     1: 
     1:   if (mLastMouseOverElement == aContent)
     1:     return;
     1: 
     1:   // Before firing mouseover, check for recursion
     1:   if (aContent == mFirstMouseOverEventElement)
     1:     return;
     1: 
     1:   // Check to see if we're a subdocument and if so update the parent
     1:   // document's ESM state to indicate that the mouse is over the
     1:   // content associated with our subdocument.
     1:   EnsureDocument(mPresContext);
     1:   nsIDocument *parentDoc = mDocument->GetParentDocument();
     1:   if (parentDoc) {
     1:     nsIContent *docContent = parentDoc->FindContentForSubDocument(mDocument);
     1:     if (docContent) {
 46225:       nsIPresShell *parentShell = parentDoc->GetShell();
     1:       if (parentShell) {
 68780:         nsEventStateManager* parentESM = parentShell->GetPresContext()->EventStateManager();
     1:         parentESM->NotifyMouseOver(aEvent, docContent);
     1:       }
     1:     }
     1:   }
     1:   // Firing the DOM event in the parent document could cause all kinds
     1:   // of havoc.  Reverify and take care.
     1:   if (mLastMouseOverElement == aContent)
     1:     return;
     1: 
     1:   // Remember mLastMouseOverElement as the related content for the
     1:   // DispatchMouseEvent() call below, since NotifyMouseOut() resets it, bug 298477.
     1:   nsCOMPtr<nsIContent> lastMouseOverElement = mLastMouseOverElement;
     1: 
 78422:   MouseEnterLeaveDispatcher enterDispatcher(this, aContent, lastMouseOverElement,
 78422:                                             aEvent, NS_MOUSEENTER);
 78422:   
     1:   NotifyMouseOut(aEvent, aContent);
     1: 
     1:   // Store the first mouseOver event we fire and don't refire mouseOver
     1:   // to that element while the first mouseOver is still ongoing.
     1:   mFirstMouseOverEventElement = aContent;
     1:   
     1:   SetContentState(aContent, NS_EVENT_STATE_HOVER);
     1:   
     1:   // Fire mouseover
     1:   mLastMouseOverFrame = DispatchMouseEvent(aEvent, NS_MOUSE_ENTER_SYNTH,
     1:                                            aContent, lastMouseOverElement);
     1:   mLastMouseOverElement = aContent;
     1:   
     1:   // Turn recursion protection back off
106838:   mFirstMouseOverEventElement = nullptr;
     1: }
     1: 
102504: // Returns the center point of the window's inner content area.
102504: // This is in widget coordinates, i.e. relative to the widget's top
114823: // left corner, not in screen coordinates, the same units that
114823: // nsDOMUIEvent::refPoint is in.
102504: static nsIntPoint
102504: GetWindowInnerRectCenter(nsPIDOMWindow* aWindow,
102504:                          nsIWidget* aWidget,
102504:                          nsPresContext* aContext)
102504: {
102504:   NS_ENSURE_TRUE(aWindow && aWidget && aContext, nsIntPoint(0,0));
102504: 
102504:   float cssInnerX = 0.0;
102504:   aWindow->GetMozInnerScreenX(&cssInnerX);
108991:   int32_t innerX = int32_t(NS_round(aContext->CSSPixelsToDevPixels(cssInnerX)));
102504: 
102504:   float cssInnerY = 0.0;
102504:   aWindow->GetMozInnerScreenY(&cssInnerY);
108991:   int32_t innerY = int32_t(NS_round(aContext->CSSPixelsToDevPixels(cssInnerY)));
108991:  
108991:   int32_t innerWidth = 0;
102504:   aWindow->GetInnerWidth(&innerWidth);
102504: 
108991:   int32_t innerHeight = 0;
102504:   aWindow->GetInnerHeight(&innerHeight);
102504: 
135201:   // convert CSS pixels returned by GetInner{Width,Height} into device pixels
135201:   // (so we can legitimately combine them with innerX and innerY from above,
135201:   // and coords returned from aWidget->GetScreenBounds() below)
135201:   innerWidth = int32_t(NS_round(aContext->CSSPixelsToDevPixels(innerWidth)));
135201:   innerHeight = int32_t(NS_round(aContext->CSSPixelsToDevPixels(innerHeight)));
135201: 
102504:   nsIntRect screen;
102504:   aWidget->GetScreenBounds(screen);
102504: 
102504:   return nsIntPoint(innerX - screen.x + innerWidth / 2,
102504:                     innerY - screen.y + innerHeight / 2);
102504: }
102504: 
     1: void
     1: nsEventStateManager::GenerateMouseEnterExit(nsGUIEvent* aEvent)
     1: {
     1:   EnsureDocument(mPresContext);
     1:   if (!mDocument)
     1:     return;
     1: 
     1:   // Hold onto old target content through the event and reset after.
     1:   nsCOMPtr<nsIContent> targetBeforeEvent = mCurrentTargetContent;
     1: 
     1:   switch(aEvent->message) {
     1:   case NS_MOUSE_MOVE:
     1:     {
114825:       // Mouse movement is reported on the MouseEvent.movement{X,Y} fields.
114825:       // Movement is calculated in nsDOMUIEvent::GetMovementPoint() as:
114825:       //   previous_mousemove_refPoint - current_mousemove_refPoint.
 95203:       if (sIsPointerLocked && aEvent->widget) {
114825:         // The pointer is locked. If the pointer is not located at the center of
114825:         // the window, dispatch a synthetic mousemove to return the pointer there.
114825:         // Doing this between "real" pointer moves gives the impression that the
114825:         // (locked) pointer can continue moving and won't stop at the screen
114825:         // boundary. We cancel the synthetic event so that we don't end up
114825:         // dispatching the centering move event to content.
102504:         nsIntPoint center = GetWindowInnerRectCenter(mDocument->GetWindow(),
102504:                                                      aEvent->widget,
102504:                                                      mPresContext);
102504:         aEvent->lastRefPoint = center;
102504:         if (aEvent->refPoint != center) {
114825:           // Mouse move doesn't finish at the center of the window. Dispatch a
114825:           // synthetic native mouse event to move the pointer back to the center
114825:           // of the window, to faciliate more movement. But first, record that
114825:           // we've dispatched a synthetic mouse movement, so we can cancel it
114825:           // in the other branch here.
114825:           sSynthCenteringPoint = center;
114823:           aEvent->widget->SynthesizeNativeMouseMove(
114823:             center + aEvent->widget->WidgetToScreenOffset());
114825:         } else if (aEvent->refPoint == sSynthCenteringPoint) {
114825:           // This is the "synthetic native" event we dispatched to re-center the
114825:           // pointer. Cancel it so we don't expose the centering move to content.
126031:           aEvent->mFlags.mPropagationStopped = true;
114825:           // Clear sSynthCenteringPoint so we don't cancel other events
114825:           // targeted at the center.
115570:           sSynthCenteringPoint = kInvalidRefPoint;
115570:         }
115570:       } else if (sLastRefPoint == kInvalidRefPoint) {
115570:         // We don't have a valid previous mousemove refPoint. This is either
115570:         // the first move we've encountered, or the mouse has just re-entered
115570:         // the application window. We should report (0,0) movement for this
115570:         // case, so make the current and previous refPoints the same.
115570:         aEvent->lastRefPoint = aEvent->refPoint;
 95203:       } else {
102504:         aEvent->lastRefPoint = sLastRefPoint;
 95203:       }
 95203: 
 95203:       // Update the last known refPoint with the current refPoint.
102504:       sLastRefPoint = aEvent->refPoint;
 95203: 
     1:       // Get the target content target (mousemove target == mouseover target)
 68780:       nsCOMPtr<nsIContent> targetElement = GetEventTargetContent(aEvent);
     1:       if (!targetElement) {
     1:         // We're always over the document root, even if we're only
     1:         // over dead space in a page (whose frame is not associated with
     1:         // any content) or in print preview dead space
 41634:         targetElement = mDocument->GetRootElement();
     1:       }
     1:       if (targetElement) {
     1:         NotifyMouseOver(aEvent, targetElement);
     1:       }
     1:     }
     1:     break;
     1:   case NS_MOUSE_EXIT:
     1:     {
     1:       // This is actually the window mouse exit event. We're not moving
     1:       // into any new element.
  8562: 
  8562:       if (mLastMouseOverFrame &&
  8562:           nsContentUtils::GetTopLevelWidget(aEvent->widget) !=
 47148:           nsContentUtils::GetTopLevelWidget(mLastMouseOverFrame->GetNearestWidget())) {
  8562:         // the MouseOut event widget doesn't have same top widget with
  8562:         // mLastMouseOverFrame, it's a spurious event for mLastMouseOverFrame
  8562:         break;
  8562:       }
  8562: 
115570:       // Reset sLastRefPoint, so that we'll know not to report any
115570:       // movement the next time we re-enter the window.
115570:       sLastRefPoint = kInvalidRefPoint;
115570: 
106838:       NotifyMouseOut(aEvent, nullptr);
     1:     }
     1:     break;
     1:   }
     1: 
     1:   // reset mCurretTargetContent to what it was
     1:   mCurrentTargetContent = targetBeforeEvent;
     1: }
     1: 
     1: void
 95203: nsEventStateManager::SetPointerLock(nsIWidget* aWidget,
 95203:                                     nsIContent* aElement)
 95203: {
106838:   // NOTE: aElement will be nullptr when unlocking.
 95203:   sIsPointerLocked = !!aElement;
 95203: 
 95203:   if (!aWidget) {
 95203:     return;
 95203:   }
 95203: 
 95203:   // Reset mouse wheel transaction
 95203:   nsMouseWheelTransaction::EndTransaction();
 95203: 
 95203:   // Deal with DnD events
 95203:   nsCOMPtr<nsIDragService> dragService =
 95203:     do_GetService("@mozilla.org/widget/dragservice;1");
 95203: 
 95203:   if (sIsPointerLocked) {
 95203:     // Store the last known ref point so we can reposition the pointer after unlock.
102504:     mPreLockPoint = sLastRefPoint;
102504: 
102504:     // Fire a synthetic mouse move to ensure event state is updated. We first
102504:     // set the mouse to the center of the window, so that the mouse event
102504:     // doesn't report any movement.
102504:     sLastRefPoint = GetWindowInnerRectCenter(aElement->OwnerDoc()->GetWindow(),
102504:                                              aWidget,
102504:                                              mPresContext);
114823:     aWidget->SynthesizeNativeMouseMove(
114823:       sLastRefPoint + aWidget->WidgetToScreenOffset());
 95203: 
 95203:     // Retarget all events to this element via capture.
 95203:     nsIPresShell::SetCapturingContent(aElement, CAPTURE_POINTERLOCK);
 95203: 
 95203:     // Suppress DnD
 95203:     if (dragService) {
 95203:       dragService->Suppress();
 95203:     }
 95203:   } else {
102504:     // Unlocking, so return pointer to the original position by firing a
102504:     // synthetic mouse event. We first reset sLastRefPoint to its
102504:     // pre-pointerlock position, so that the synthetic mouse event reports
102504:     // no movement.
102504:     sLastRefPoint = mPreLockPoint;
114823:     aWidget->SynthesizeNativeMouseMove(
114823:       mPreLockPoint + aWidget->WidgetToScreenOffset());
 95203: 
 95203:     // Don't retarget events to this element any more.
106838:     nsIPresShell::SetCapturingContent(nullptr, CAPTURE_POINTERLOCK);
 95203: 
 95203:     // Unsuppress DnD
 95203:     if (dragService) {
 95203:       dragService->Unsuppress();
 95203:     }
 95203:   }
 95203: }
 95203: 
 95203: void
     1: nsEventStateManager::GenerateDragDropEnterExit(nsPresContext* aPresContext,
     1:                                                nsGUIEvent* aEvent)
     1: {
     1:   //Hold onto old target content through the event and reset after.
     1:   nsCOMPtr<nsIContent> targetBeforeEvent = mCurrentTargetContent;
     1: 
     1:   switch(aEvent->message) {
     1:   case NS_DRAGDROP_OVER:
     1:     {
 58550:       // when dragging from one frame to another, events are fired in the
 58550:       // order: dragexit, dragenter, dragleave
 79435:       if (sLastDragOverFrame != mCurrentTarget) {
     1:         //We'll need the content, too, to check if it changed separately from the frames.
     1:         nsCOMPtr<nsIContent> lastContent;
     1:         nsCOMPtr<nsIContent> targetContent;
 79435:         mCurrentTarget->GetContentForEvent(aEvent, getter_AddRefs(targetContent));
 79435: 
 79435:         if (sLastDragOverFrame) {
   482:           //The frame has changed but the content may not have. Check before dispatching to content
 79435:           sLastDragOverFrame->GetContentForEvent(aEvent, getter_AddRefs(lastContent));
 79435: 
 79435:           FireDragEnterOrExit(sLastDragOverFrame->PresContext(),
 79435:                               aEvent, NS_DRAGDROP_EXIT_SYNTH,
 79435:                               targetContent, lastContent, sLastDragOverFrame);
 58550:         }
 58550: 
 58550:         FireDragEnterOrExit(aPresContext, aEvent, NS_DRAGDROP_ENTER,
 58550:                             lastContent, targetContent, mCurrentTarget);
 58550: 
 79435:         if (sLastDragOverFrame) {
 79435:           FireDragEnterOrExit(sLastDragOverFrame->PresContext(),
 79435:                               aEvent, NS_DRAGDROP_LEAVE_SYNTH,
 79435:                               targetContent, lastContent, sLastDragOverFrame);
 79435:         }
 79435: 
 79435:         sLastDragOverFrame = mCurrentTarget;
   482:       }
   482:     }
   482:     break;
   482: 
   482:   case NS_DRAGDROP_EXIT:
   482:     {
   482:       //This is actually the window mouse exit event.
 79435:       if (sLastDragOverFrame) {
   482:         nsCOMPtr<nsIContent> lastContent;
 79435:         sLastDragOverFrame->GetContentForEvent(aEvent, getter_AddRefs(lastContent));
 79435: 
 79435:         nsRefPtr<nsPresContext> lastDragOverFramePresContext = sLastDragOverFrame->PresContext();
 79435:         FireDragEnterOrExit(lastDragOverFramePresContext,
 79435:                             aEvent, NS_DRAGDROP_EXIT_SYNTH,
106838:                             nullptr, lastContent, sLastDragOverFrame);
 79435:         FireDragEnterOrExit(lastDragOverFramePresContext,
 79435:                             aEvent, NS_DRAGDROP_LEAVE_SYNTH,
106838:                             nullptr, lastContent, sLastDragOverFrame);
106838: 
106838:         sLastDragOverFrame = nullptr;
   482:       }
   482:     }
   482:     break;
   482:   }
   482: 
   482:   //reset mCurretTargetContent to what it was
   482:   mCurrentTargetContent = targetBeforeEvent;
   482: 
   482:   // Now flush all pending notifications, for better responsiveness.
   482:   FlushPendingEvents(aPresContext);
   482: }
   482: 
   482: void
   482: nsEventStateManager::FireDragEnterOrExit(nsPresContext* aPresContext,
   482:                                          nsGUIEvent* aEvent,
108991:                                          uint32_t aMsg,
   482:                                          nsIContent* aRelatedTarget,
   482:                                          nsIContent* aTargetContent,
   482:                                          nsWeakFrame& aTargetFrame)
   482: {
     1:   nsEventStatus status = nsEventStatus_eIgnore;
126028:   nsDragEvent event(aEvent->mFlags.mIsTrusted, aMsg, aEvent->widget);
     1:   event.refPoint = aEvent->refPoint;
 96887:   event.modifiers = ((nsMouseEvent*)aEvent)->modifiers;
 96888:   event.buttons = ((nsMouseEvent*)aEvent)->buttons;
   482:   event.relatedTarget = aRelatedTarget;
 40485:   event.inputSource = static_cast<nsMouseEvent*>(aEvent)->inputSource;
   482: 
   482:   mCurrentTargetContent = aTargetContent;
   482: 
   482:   if (aTargetContent != aRelatedTarget) {
     1:     //XXX This event should still go somewhere!!
   482:     if (aTargetContent)
   482:       nsEventDispatcher::Dispatch(aTargetContent, aPresContext, &event,
106838:                                   nullptr, &status);
     1: 
 19702:     // adjust the drag hover if the dragenter event was cancelled or this is a drag exit
 19702:     if (status == nsEventStatus_eConsumeNoDefault || aMsg == NS_DRAGDROP_EXIT)
106838:       SetContentState((aMsg == NS_DRAGDROP_ENTER) ? aTargetContent : nullptr,
   482:                       NS_EVENT_STATE_DRAGOVER);
 33528: 
 33528:     // collect any changes to moz cursor settings stored in the event's
 33528:     // data transfer.
 33528:     if (aMsg == NS_DRAGDROP_LEAVE_SYNTH || aMsg == NS_DRAGDROP_EXIT_SYNTH ||
 33528:         aMsg == NS_DRAGDROP_ENTER)
 33528:       UpdateDragDataTransfer(&event);
   482:   }
   482: 
   482:   // Finally dispatch the event to the frame
   482:   if (aTargetFrame)
   482:     aTargetFrame->HandleEvent(aPresContext, &event, &status);
     1: }
     1: 
 33528: void
 33528: nsEventStateManager::UpdateDragDataTransfer(nsDragEvent* dragEvent)
 33528: {
 33528:   NS_ASSERTION(dragEvent, "drag event is null in UpdateDragDataTransfer!");
 33528:   if (!dragEvent->dataTransfer)
 33528:     return;
 33528: 
 33528:   nsCOMPtr<nsIDragSession> dragSession = nsContentUtils::GetDragSession();
 33528: 
 33528:   if (dragSession) {
 33528:     // the initial dataTransfer is the one from the dragstart event that
 33528:     // was set on the dragSession when the drag began.
 33528:     nsCOMPtr<nsIDOMDataTransfer> initialDataTransfer;
 33528:     dragSession->GetDataTransfer(getter_AddRefs(initialDataTransfer));
 89615:     if (initialDataTransfer) {
 33528:       // retrieve the current moz cursor setting and save it.
 33528:       nsAutoString mozCursor;
 89615:       dragEvent->dataTransfer->GetMozCursor(mozCursor);
 89615:       initialDataTransfer->SetMozCursor(mozCursor);
 33528:     }
 33528:   }
 33528: }
 33528: 
     1: nsresult
     1: nsEventStateManager::SetClickCount(nsPresContext* aPresContext,
     1:                                    nsMouseEvent *aEvent,
     1:                                    nsEventStatus* aStatus)
     1: {
     1:   nsCOMPtr<nsIContent> mouseContent;
106838:   nsIContent* mouseContentParent = nullptr;
 79435:   mCurrentTarget->GetContentForEvent(aEvent, getter_AddRefs(mouseContent));
 69450:   if (mouseContent) {
 69450:     if (mouseContent->IsNodeOfType(nsINode::eTEXT)) {
 69450:       mouseContent = mouseContent->GetParent();
 69450:     }
 69450:     if (mouseContent && mouseContent->IsRootOfNativeAnonymousSubtree()) {
 69450:       mouseContentParent = mouseContent->GetParent();
 69450:     }
 69450:   }
     1: 
     1:   switch (aEvent->button) {
     1:   case nsMouseEvent::eLeftButton:
     1:     if (aEvent->message == NS_MOUSE_BUTTON_DOWN) {
     1:       mLastLeftMouseDownContent = mouseContent;
 51869:       mLastLeftMouseDownContentParent = mouseContentParent;
     1:     } else if (aEvent->message == NS_MOUSE_BUTTON_UP) {
 37465:       if (mLastLeftMouseDownContent == mouseContent ||
 51869:           mLastLeftMouseDownContentParent == mouseContent ||
 51869:           mLastLeftMouseDownContent == mouseContentParent) {
     1:         aEvent->clickCount = mLClickCount;
     1:         mLClickCount = 0;
     1:       } else {
     1:         aEvent->clickCount = 0;
     1:       }
106838:       mLastLeftMouseDownContent = nullptr;
106838:       mLastLeftMouseDownContentParent = nullptr;
     1:     }
     1:     break;
     1: 
     1:   case nsMouseEvent::eMiddleButton:
     1:     if (aEvent->message == NS_MOUSE_BUTTON_DOWN) {
     1:       mLastMiddleMouseDownContent = mouseContent;
 51869:       mLastMiddleMouseDownContentParent = mouseContentParent;
     1:     } else if (aEvent->message == NS_MOUSE_BUTTON_UP) {
 37465:       if (mLastMiddleMouseDownContent == mouseContent ||
 51869:           mLastMiddleMouseDownContentParent == mouseContent ||
 52181:           mLastMiddleMouseDownContent == mouseContentParent) {
     1:         aEvent->clickCount = mMClickCount;
     1:         mMClickCount = 0;
     1:       } else {
     1:         aEvent->clickCount = 0;
     1:       }
106838:       mLastMiddleMouseDownContent = nullptr;
106838:       mLastMiddleMouseDownContentParent = nullptr;
     1:     }
     1:     break;
     1: 
     1:   case nsMouseEvent::eRightButton:
     1:     if (aEvent->message == NS_MOUSE_BUTTON_DOWN) {
     1:       mLastRightMouseDownContent = mouseContent;
 51869:       mLastRightMouseDownContentParent = mouseContentParent;
     1:     } else if (aEvent->message == NS_MOUSE_BUTTON_UP) {
 37465:       if (mLastRightMouseDownContent == mouseContent ||
 51869:           mLastRightMouseDownContentParent == mouseContent ||
 52181:           mLastRightMouseDownContent == mouseContentParent) {
     1:         aEvent->clickCount = mRClickCount;
     1:         mRClickCount = 0;
     1:       } else {
     1:         aEvent->clickCount = 0;
     1:       }
106838:       mLastRightMouseDownContent = nullptr;
106838:       mLastRightMouseDownContentParent = nullptr;
     1:     }
     1:     break;
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsEventStateManager::CheckForAndDispatchClick(nsPresContext* aPresContext,
     1:                                               nsMouseEvent *aEvent,
     1:                                               nsEventStatus* aStatus)
     1: {
     1:   nsresult ret = NS_OK;
     1: 
     1:   //If mouse is still over same element, clickcount will be > 1.
     1:   //If it has moved it will be zero, so no click.
     1:   if (0 != aEvent->clickCount) {
     1:     //Check that the window isn't disabled before firing a click
     1:     //(see bug 366544).
106103:     if (aEvent->widget && !aEvent->widget->IsEnabled()) {
     1:       return ret;
     1:     }
     1:     //fire click
126038:     bool notDispatchToContents =
126038:      (aEvent->button == nsMouseEvent::eMiddleButton ||
126038:       aEvent->button == nsMouseEvent::eRightButton);
     1: 
126028:     nsMouseEvent event(aEvent->mFlags.mIsTrusted, NS_MOUSE_CLICK,
126028:                        aEvent->widget, nsMouseEvent::eReal);
     1:     event.refPoint = aEvent->refPoint;
     1:     event.clickCount = aEvent->clickCount;
 96887:     event.modifiers = aEvent->modifiers;
 96888:     event.buttons = aEvent->buttons;
     1:     event.time = aEvent->time;
126038:     event.mFlags.mNoContentDispatch = notDispatchToContents;
     1:     event.button = aEvent->button;
 40485:     event.inputSource = aEvent->inputSource;
     1: 
     1:     nsCOMPtr<nsIPresShell> presShell = mPresContext->GetPresShell();
     1:     if (presShell) {
 68780:       nsCOMPtr<nsIContent> mouseContent = GetEventTargetContent(aEvent);
     1: 
     1:       ret = presShell->HandleEventWithTarget(&event, mCurrentTarget,
     1:                                              mouseContent, aStatus);
     1:       if (NS_SUCCEEDED(ret) && aEvent->clickCount == 2) {
     1:         //fire double click
126028:         nsMouseEvent event2(aEvent->mFlags.mIsTrusted, NS_MOUSE_DOUBLECLICK,
     1:                             aEvent->widget, nsMouseEvent::eReal);
     1:         event2.refPoint = aEvent->refPoint;
     1:         event2.clickCount = aEvent->clickCount;
 96887:         event2.modifiers = aEvent->modifiers;
 96888:         event2.buttons = aEvent->buttons;
126038:         event2.mFlags.mNoContentDispatch = notDispatchToContents;
     1:         event2.button = aEvent->button;
 40485:         event2.inputSource = aEvent->inputSource;
     1: 
     1:         ret = presShell->HandleEventWithTarget(&event2, mCurrentTarget,
     1:                                                mouseContent, aStatus);
     1:       }
     1:     }
     1:   }
     1:   return ret;
     1: }
     1: 
 68780: nsIFrame*
 68780: nsEventStateManager::GetEventTarget()
     1: {
 30569:   nsIPresShell *shell;
 30569:   if (mCurrentTarget ||
 30569:       !mPresContext ||
 30569:       !(shell = mPresContext->GetPresShell())) {
 68780:     return mCurrentTarget;
 30569:   }
 30569: 
 30569:   if (mCurrentTargetContent) {
 36655:     mCurrentTarget = mPresContext->GetPrimaryFrameFor(mCurrentTargetContent);
 30569:     if (mCurrentTarget) {
 68780:       return mCurrentTarget;
 30569:     }
 30569:   }
 30569: 
 40047:   nsIFrame* frame = shell->GetEventTargetFrame();
 68780:   return (mCurrentTarget = frame);
 68780: }
 68780: 
 68780: already_AddRefed<nsIContent>
 68780: nsEventStateManager::GetEventTargetContent(nsEvent* aEvent)
     1: {
     1:   if (aEvent &&
     1:       (aEvent->message == NS_FOCUS_CONTENT ||
     1:        aEvent->message == NS_BLUR_CONTENT)) {
 68780:     nsCOMPtr<nsIContent> content = GetFocusedContent();
 68780:     return content.forget();
     1:   }
     1: 
     1:   if (mCurrentTargetContent) {
 68780:     nsCOMPtr<nsIContent> content = mCurrentTargetContent;
 68780:     return content.forget();
 68780:   }
 68780: 
106838:   nsIContent *content = nullptr;
     1: 
     1:   nsIPresShell *presShell = mPresContext->GetPresShell();
     1:   if (presShell) {
 68780:     content = presShell->GetEventTargetContent(aEvent).get();
     1:   }
     1: 
     1:   // Some events here may set mCurrentTarget but not set the corresponding
     1:   // event target in the PresShell.
 68780:   if (!content && mCurrentTarget) {
 79435:     mCurrentTarget->GetContentForEvent(aEvent, &content);
 68780:   }
 68780: 
 68780:   return content;
     1: }
     1: 
 70852: static Element*
 70852: GetLabelTarget(nsIContent* aPossibleLabel)
 42951: {
126764:   mozilla::dom::HTMLLabelElement* label =
126764:     mozilla::dom::HTMLLabelElement::FromContent(aPossibleLabel);
 42951:   if (!label)
106838:     return nullptr;
 42951: 
 70852:   return label->GetLabeledElement();
 42951: }
 42951: 
     1: static nsIContent* FindCommonAncestor(nsIContent *aNode1, nsIContent *aNode2)
     1: {
     1:   // Find closest common ancestor
     1:   if (aNode1 && aNode2) {
     1:     // Find the nearest common ancestor by counting the distance to the
     1:     // root and then walking up again, in pairs.
108991:     int32_t offset = 0;
     1:     nsIContent *anc1 = aNode1;
     1:     for (;;) {
     1:       ++offset;
     1:       nsIContent* parent = anc1->GetParent();
     1:       if (!parent)
     1:         break;
     1:       anc1 = parent;
     1:     }
     1:     nsIContent *anc2 = aNode2;
     1:     for (;;) {
     1:       --offset;
     1:       nsIContent* parent = anc2->GetParent();
     1:       if (!parent)
     1:         break;
     1:       anc2 = parent;
     1:     }
     1:     if (anc1 == anc2) {
     1:       anc1 = aNode1;
     1:       anc2 = aNode2;
     1:       while (offset > 0) {
     1:         anc1 = anc1->GetParent();
     1:         --offset;
     1:       }
     1:       while (offset < 0) {
     1:         anc2 = anc2->GetParent();
     1:         ++offset;
     1:       }
     1:       while (anc1 != anc2) {
     1:         anc1 = anc1->GetParent();
     1:         anc2 = anc2->GetParent();
     1:       }
     1:       return anc1;
     1:     }
     1:   }
106838:   return nullptr;
     1: }
     1: 
 81144: static Element*
 81144: GetParentElement(Element* aElement)
 81144: {
 81144:   nsIContent* p = aElement->GetParent();
106838:   return (p && p->IsElement()) ? p->AsElement() : nullptr;
 81144: }
 81144: 
 71112: /* static */
 77844: void
 81144: nsEventStateManager::SetFullScreenState(Element* aElement, bool aIsFullScreen)
 77844: {
 77844:   DoStateChange(aElement, NS_EVENT_STATE_FULL_SCREEN, aIsFullScreen);
 81144:   Element* ancestor = aElement;
 81144:   while ((ancestor = GetParentElement(ancestor))) {
 81144:     DoStateChange(ancestor, NS_EVENT_STATE_FULL_SCREEN_ANCESTOR, aIsFullScreen);
 81144:   }
 77844: }
 77844: 
 77844: /* static */
 71112: inline void
 71112: nsEventStateManager::DoStateChange(Element* aElement, nsEventStates aState,
 79445:                                    bool aAddState)
 42949: {
 71112:   if (aAddState) {
 71112:     aElement->AddStates(aState);
 71112:   } else {
 71112:     aElement->RemoveStates(aState);
 71112:   }
 71112: }
 71112: 
 71112: /* static */
 71113: inline void
 71113: nsEventStateManager::DoStateChange(nsIContent* aContent, nsEventStates aState,
 79445:                                    bool aStateAdded)
 71113: {
 71113:   if (aContent->IsElement()) {
 71113:     DoStateChange(aContent->AsElement(), aState, aStateAdded);
 71113:   }
 71113: }
 71113: 
 71113: /* static */
 71112: void
 71112: nsEventStateManager::UpdateAncestorState(nsIContent* aStartNode,
 71112:                                          nsIContent* aStopBefore,
 71112:                                          nsEventStates aState,
 79445:                                          bool aAddState)
 71112: {
 71112:   for (; aStartNode && aStartNode != aStopBefore;
 71112:        aStartNode = aStartNode->GetParent()) {
 71112:     // We might be starting with a non-element (e.g. a text node) and
 71112:     // if someone is doing something weird might be ending with a
 71112:     // non-element too (e.g. a document fragment)
 71112:     if (!aStartNode->IsElement()) {
 71112:       continue;
 71112:     }
 71112:     Element* element = aStartNode->AsElement();
 71112:     DoStateChange(element, aState, aAddState);
 71112:     Element* labelTarget = GetLabelTarget(element);
 42951:     if (labelTarget) {
 71112:       DoStateChange(labelTarget, aState, aAddState);
 71112:     }
 42949:   }
 86028: 
 86028:   if (aAddState) {
 86028:     // We might be in a situation where a node was in hover both
 86028:     // because it was hovered and because the label for it was
 86028:     // hovered, and while we stopped hovering the node the label is
 86028:     // still hovered.  Or we might have had two nested labels for the
 86028:     // same node, and while one is no longer hovered the other still
 86028:     // is.  In that situation, the label that's still hovered will be
 86028:     // aStopBefore or some ancestor of it, and the call we just made
 86028:     // to UpdateAncestorState with aAddState = false would have
 86028:     // removed the hover state from the node.  But the node should
 86028:     // still be in hover state.  To handle this situation we need to
 86028:     // keep walking up the tree and any time we find a label mark its
 86028:     // corresponding node as still in our state.
 86028:     for ( ; aStartNode; aStartNode = aStartNode->GetParent()) {
 86028:       if (!aStartNode->IsElement()) {
 86028:         continue;
 86028:       }
 86028: 
 86028:       Element* labelTarget = GetLabelTarget(aStartNode->AsElement());
 86028:       if (labelTarget && !labelTarget->State().HasState(aState)) {
 86028:         DoStateChange(labelTarget, aState, true);
 86028:       }
 86028:     }
 86028:   }
 42949: }
 42949: 
 79445: bool
 56168: nsEventStateManager::SetContentState(nsIContent *aContent, nsEventStates aState)
     1: {
 64122:   // We manage 4 states here: ACTIVE, HOVER, DRAGOVER, URLTARGET
 64122:   // The input must be exactly one of them.
 64122:   NS_PRECONDITION(aState == NS_EVENT_STATE_ACTIVE ||
 64122:                   aState == NS_EVENT_STATE_HOVER ||
 64122:                   aState == NS_EVENT_STATE_DRAGOVER ||
 64122:                   aState == NS_EVENT_STATE_URLTARGET,
 64122:                   "Unexpected state");
 64122: 
 64122:   nsCOMPtr<nsIContent> notifyContent1;
 64122:   nsCOMPtr<nsIContent> notifyContent2;
 79445:   bool updateAncestors;
 64122: 
 64122:   if (aState == NS_EVENT_STATE_HOVER || aState == NS_EVENT_STATE_ACTIVE) {
 64122:     // Hover and active are hierarchical
 80486:     updateAncestors = true;
     1: 
     1:     // check to see that this state is allowed by style. Check dragover too?
     1:     // XXX Is this even what we want?
 64122:     if (mCurrentTarget)
     1:     {
132812:       const nsStyleUserInterface* ui = mCurrentTarget->StyleUserInterface();
     1:       if (ui->mUserInput == NS_STYLE_USER_INPUT_NONE)
 80486:         return false;
     1:     }
     1: 
 64122:     if (aState == NS_EVENT_STATE_ACTIVE) {
 64122:       if (aContent != mActiveContent) {
 64122:         notifyContent1 = aContent;
 64122:         notifyContent2 = mActiveContent;
     1:         mActiveContent = aContent;
     1:       }
 64122:     } else {
 64122:       NS_ASSERTION(aState == NS_EVENT_STATE_HOVER, "How did that happen?");
 64122:       nsIContent* newHover;
     1:       
 63649:       if (mPresContext->IsDynamic()) {
     1:         newHover = aContent;
     1:       } else {
 36655:         NS_ASSERTION(!aContent ||
 36655:                      aContent->GetCurrentDoc() == mPresContext->PresShell()->GetDocument(),
 36655:                      "Unexpected document");
106838:         nsIFrame *frame = aContent ? aContent->GetPrimaryFrame() : nullptr;
     1:         if (frame && nsLayoutUtils::IsViewportScrollbarFrame(frame)) {
     1:           // The scrollbars of viewport should not ignore the hover state.
     1:           // Because they are *not* the content of the web page.
     1:           newHover = aContent;
     1:         } else {
     1:           // All contents of the web page should ignore the hover state.
106838:           newHover = nullptr;
     1:         }
     1:       }
     1: 
 64122:       if (newHover != mHoverContent) {
 64122:         notifyContent1 = newHover;
 64122:         notifyContent2 = mHoverContent;
 64122:         mHoverContent = newHover;
 64122:       }
 64122:     }
 64122:   } else {
 80486:     updateAncestors = false;
 64122:     if (aState == NS_EVENT_STATE_DRAGOVER) {
 79435:       if (aContent != sDragOverContent) {
 64122:         notifyContent1 = aContent;
 79435:         notifyContent2 = sDragOverContent;
 79435:         sDragOverContent = aContent;
 64122:       }
 64122:     } else if (aState == NS_EVENT_STATE_URLTARGET) {
 64122:       if (aContent != mURLTargetContent) {
 64122:         notifyContent1 = aContent;
 64122:         notifyContent2 = mURLTargetContent;
 64122:         mURLTargetContent = aContent;
 64122:       }
 64122:     }
 64122:   }
 64122: 
 71112:   // We need to keep track of which of notifyContent1 and notifyContent2 is
 71112:   // getting the state set and which is getting it unset.  If both are
 71112:   // non-null, then notifyContent1 is having the state set and notifyContent2
 71112:   // is having it unset.  But if one of them is null, we need to keep track of
 71112:   // the right thing for notifyContent1 explicitly.
 79445:   bool content1StateSet = true;
 64122:   if (!notifyContent1) {
 64122:     // This is ok because FindCommonAncestor wouldn't find anything
 64122:     // anyway if notifyContent1 is null.
 64122:     notifyContent1 = notifyContent2;
106838:     notifyContent2 = nullptr;
 80486:     content1StateSet = false;
 64122:   }
 64122: 
 64122:   if (notifyContent1 && mPresContext) {
     1:     EnsureDocument(mPresContext);
 64122:     if (mDocument) {
 71103:       nsAutoScriptBlocker scriptBlocker;
 64122: 
 71112:       if (updateAncestors) {
 64122:         nsCOMPtr<nsIContent> commonAncestor =
 64122:           FindCommonAncestor(notifyContent1, notifyContent2);
 64122:         if (notifyContent2) {
 71112:           // It's very important to first notify the state removal and
 71112:           // then the state addition, because due to labels it's
 71112:           // possible that we're removing state from some element but
 71112:           // then adding it again (say because mHoverContent changed
 71112:           // from a control to its label).
 80486:           UpdateAncestorState(notifyContent2, commonAncestor, aState, false);
 71112:         }
 71112:         UpdateAncestorState(notifyContent1, commonAncestor, aState,
 71112:                             content1StateSet);
 64122:       } else {
 64122:         if (notifyContent2) {
 80486:           DoStateChange(notifyContent2, aState, false);
 71113:         }
 71113:         DoStateChange(notifyContent1, aState, content1StateSet);
 64122:       }
     1:     }
     1:   }
     1: 
 80486:   return true;
 29018: }
 29018: 
 68780: void
 29018: nsEventStateManager::ContentRemoved(nsIDocument* aDocument, nsIContent* aContent)
     1: {
 95699:   /*
 95699:    * Anchor and area elements when focused or hovered might make the UI to show
 95699:    * the current link. We want to make sure that the UI gets informed when they
 95699:    * are actually removed from the DOM.
 95699:    */
 95699:   if (aContent->IsHTML() &&
 95699:       (aContent->Tag() == nsGkAtoms::a || aContent->Tag() == nsGkAtoms::area) &&
 95699:       (aContent->AsElement()->State().HasAtLeastOneOfStates(NS_EVENT_STATE_FOCUS |
 95699:                                                             NS_EVENT_STATE_HOVER))) {
 95699:     nsGenericHTMLElement* element = static_cast<nsGenericHTMLElement*>(aContent);
 95699:     element->LeaveLink(element->GetPresContext());
 95699:   }
 95699: 
119248:   nsIMEStateManager::OnRemoveContent(mPresContext, aContent);
119248: 
 29018:   // inform the focus manager that the content is being removed. If this
 29018:   // content is focused, the focus will be removed without firing events.
 41409:   nsFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:   if (fm)
 29018:     fm->ContentRemoved(aDocument, aContent);
     1: 
     1:   if (mHoverContent &&
     1:       nsContentUtils::ContentIsDescendantOf(mHoverContent, aContent)) {
     1:     // Since hover is hierarchical, set the current hover to the
     1:     // content's parent node.
 42951:     SetContentState(aContent->GetParent(), NS_EVENT_STATE_HOVER);
     1:   }
     1: 
     1:   if (mActiveContent &&
     1:       nsContentUtils::ContentIsDescendantOf(mActiveContent, aContent)) {
     1:     // Active is hierarchical, so set the current active to the
     1:     // content's parent node.
 42951:     SetContentState(aContent->GetParent(), NS_EVENT_STATE_ACTIVE);
     1:   }
     1: 
 79435:   if (sDragOverContent &&
 80526:       sDragOverContent->OwnerDoc() == aContent->OwnerDoc() &&
 79435:       nsContentUtils::ContentIsDescendantOf(sDragOverContent, aContent)) {
106838:     sDragOverContent = nullptr;
     1:   }
     1: 
     1:   if (mLastMouseOverElement &&
     1:       nsContentUtils::ContentIsDescendantOf(mLastMouseOverElement, aContent)) {
     1:     // See bug 292146 for why we want to null this out
106838:     mLastMouseOverElement = nullptr;
     1:   }
 68780: }
 68780: 
 79445: bool
 68780: nsEventStateManager::EventStatusOK(nsGUIEvent* aEvent)
     1: {
 68780:   return !(aEvent->message == NS_MOUSE_BUTTON_DOWN &&
 68780:       static_cast<nsMouseEvent*>(aEvent)->button == nsMouseEvent::eLeftButton  && 
 68780:       !sNormalLMouseEventInProcess);
     1: }
     1: 
     1: //-------------------------------------------
     1: // Access Key Registration
     1: //-------------------------------------------
 68780: void
108991: nsEventStateManager::RegisterAccessKey(nsIContent* aContent, uint32_t aKey)
     1: {
  8407:   if (aContent && mAccessKeys.IndexOf(aContent) == -1)
  8407:     mAccessKeys.AppendObject(aContent);
 68780: }
 68780: 
 68780: void
108991: nsEventStateManager::UnregisterAccessKey(nsIContent* aContent, uint32_t aKey)
     1: {
  8407:   if (aContent)
  8407:     mAccessKeys.RemoveObject(aContent);
 68780: }
 68780: 
108991: uint32_t
 68780: nsEventStateManager::GetRegisteredAccessKey(nsIContent* aContent)
  5414: {
111239:   MOZ_ASSERT(aContent);
  5414: 
  8407:   if (mAccessKeys.IndexOf(aContent) == -1)
 68780:     return 0;
  5414: 
  8407:   nsAutoString accessKey;
  8407:   aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::accesskey, accessKey);
 68780:   return accessKey.First();
  5414: }
  5414: 
     1: void
     1: nsEventStateManager::EnsureDocument(nsPresContext* aPresContext)
     1: {
     1:   if (!mDocument)
     1:     mDocument = aPresContext->Document();
     1: }
     1: 
     1: void
     1: nsEventStateManager::FlushPendingEvents(nsPresContext* aPresContext)
     1: {
106838:   NS_PRECONDITION(nullptr != aPresContext, "nullptr ptr");
     1:   nsIPresShell *shell = aPresContext->GetPresShell();
     1:   if (shell) {
 27993:     shell->FlushPendingNotifications(Flush_InterruptibleLayout);
     1:   }
     1: }
     1: 
 29018: nsIContent*
 29018: nsEventStateManager::GetFocusedContent()
     1: {
 29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:   if (!fm || !mDocument)
106838:     return nullptr;
 29018: 
 29018:   nsCOMPtr<nsPIDOMWindow> focusedWindow;
 80486:   return nsFocusManager::GetFocusedDescendant(mDocument->GetWindow(), false,
 29018:                                               getter_AddRefs(focusedWindow));
     1: }
     1: 
     1: //-------------------------------------------------------
 80486: // Return true if the docshell is visible
     1: 
 79445: bool
     1: nsEventStateManager::IsShellVisible(nsIDocShell* aShell)
     1: {
     1:   NS_ASSERTION(aShell, "docshell is null");
     1: 
     1:   nsCOMPtr<nsIBaseWindow> basewin = do_QueryInterface(aShell);
     1:   if (!basewin)
 80486:     return true;
     1: 
 79445:   bool isVisible = true;
     1:   basewin->GetVisibility(&isVisible);
     1: 
     1:   // We should be doing some additional checks here so that
     1:   // we don't tab into hidden tabs of tabbrowser.  -bryner
     1: 
     1:   return isVisible;
     1: }
 31218: 
 31218: nsresult
 31218: nsEventStateManager::DoContentCommandEvent(nsContentCommandEvent* aEvent)
 31218: {
 31218:   EnsureDocument(mPresContext);
 31218:   NS_ENSURE_TRUE(mDocument, NS_ERROR_FAILURE);
 38336:   nsCOMPtr<nsPIDOMWindow> window(mDocument->GetWindow());
 31218:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
 38336: 
 38336:   nsCOMPtr<nsPIWindowRoot> root = window->GetTopWindowRoot();
 38336:   NS_ENSURE_TRUE(root, NS_ERROR_FAILURE);
 31218:   const char* cmd;
 31218:   switch (aEvent->message) {
 31218:     case NS_CONTENT_COMMAND_CUT:
 31218:       cmd = "cmd_cut";
 31218:       break;
 31218:     case NS_CONTENT_COMMAND_COPY:
 31218:       cmd = "cmd_copy";
 31218:       break;
 31218:     case NS_CONTENT_COMMAND_PASTE:
 31218:       cmd = "cmd_paste";
 31218:       break;
 31218:     case NS_CONTENT_COMMAND_DELETE:
 31218:       cmd = "cmd_delete";
 31218:       break;
 31218:     case NS_CONTENT_COMMAND_UNDO:
 31218:       cmd = "cmd_undo";
 31218:       break;
 31218:     case NS_CONTENT_COMMAND_REDO:
 31218:       cmd = "cmd_redo";
 31218:       break;
 36983:     case NS_CONTENT_COMMAND_PASTE_TRANSFERABLE:
 36983:       cmd = "cmd_pasteTransferable";
 36983:       break;
 31218:     default:
 31218:       return NS_ERROR_NOT_IMPLEMENTED;
 31218:   }
 31218:   nsCOMPtr<nsIController> controller;
 38336:   nsresult rv = root->GetControllerForCommand(cmd, getter_AddRefs(controller));
 31218:   NS_ENSURE_SUCCESS(rv, rv);
 31218:   if (!controller) {
 31218:     // When GetControllerForCommand succeeded but there is no controller, the
 31218:     // command isn't supported.
 80486:     aEvent->mIsEnabled = false;
 31218:   } else {
 79445:     bool canDoIt;
 31218:     rv = controller->IsCommandEnabled(cmd, &canDoIt);
 31218:     NS_ENSURE_SUCCESS(rv, rv);
 31218:     aEvent->mIsEnabled = canDoIt;
 31218:     if (canDoIt && !aEvent->mOnlyEnabledCheck) {
 36983:       switch (aEvent->message) {
 36983:         case NS_CONTENT_COMMAND_PASTE_TRANSFERABLE: {
 36983:           nsCOMPtr<nsICommandController> commandController = do_QueryInterface(controller);
 36983:           NS_ENSURE_STATE(commandController);
 36983: 
 36983:           nsCOMPtr<nsICommandParams> params = do_CreateInstance("@mozilla.org/embedcomp/command-params;1", &rv);
 36983:           NS_ENSURE_SUCCESS(rv, rv);
 36983: 
 36983:           rv = params->SetISupportsValue("transferable", aEvent->mTransferable);
 36983:           NS_ENSURE_SUCCESS(rv, rv);
 36983: 
 36983:           rv = commandController->DoCommandWithParams(cmd, params);
 36983:           break;
 36983:         }
 36983:         
 36983:         default:
 31218:           rv = controller->DoCommand(cmd);
 36983:           break;
 36983:       }
 31218:       NS_ENSURE_SUCCESS(rv, rv);
 31218:     }
 31218:   }
 80486:   aEvent->mSucceeded = true;
 31218:   return NS_OK;
 31218: }
 39248: 
 39248: nsresult
 39248: nsEventStateManager::DoContentCommandScrollEvent(nsContentCommandEvent* aEvent)
 39248: {
 39248:   NS_ENSURE_TRUE(mPresContext, NS_ERROR_NOT_AVAILABLE);
 39248:   nsIPresShell* ps = mPresContext->GetPresShell();
 39248:   NS_ENSURE_TRUE(ps, NS_ERROR_NOT_AVAILABLE);
 39248:   NS_ENSURE_TRUE(aEvent->mScroll.mAmount != 0, NS_ERROR_INVALID_ARG);
 39248: 
 39248:   nsIScrollableFrame::ScrollUnit scrollUnit;
 39248:   switch (aEvent->mScroll.mUnit) {
 39248:     case nsContentCommandEvent::eCmdScrollUnit_Line:
 39248:       scrollUnit = nsIScrollableFrame::LINES;
 39248:       break;
 39248:     case nsContentCommandEvent::eCmdScrollUnit_Page:
 39248:       scrollUnit = nsIScrollableFrame::PAGES;
 39248:       break;
 39248:     case nsContentCommandEvent::eCmdScrollUnit_Whole:
 39248:       scrollUnit = nsIScrollableFrame::WHOLE;
 39248:       break;
 39248:     default:
 39248:       return NS_ERROR_INVALID_ARG;
 39248:   }
 39248: 
 80486:   aEvent->mSucceeded = true;
 39248: 
 39248:   nsIScrollableFrame* sf =
 39248:     ps->GetFrameToScrollAsScrollable(nsIPresShell::eEither);
108058:   aEvent->mIsEnabled = sf ?
108058:     (aEvent->mScroll.mIsHorizontal ?
108058:       CanScrollOn(sf, aEvent->mScroll.mAmount, 0) :
108058:       CanScrollOn(sf, 0, aEvent->mScroll.mAmount)) : false;
 39248: 
 39248:   if (!aEvent->mIsEnabled || aEvent->mOnlyEnabledCheck) {
 39248:     return NS_OK;
 39248:   }
 39248: 
 39248:   nsIntPoint pt(0, 0);
 39248:   if (aEvent->mScroll.mIsHorizontal) {
 39248:     pt.x = aEvent->mScroll.mAmount;
 39248:   } else {
 39248:     pt.y = aEvent->mScroll.mAmount;
 39248:   }
 39248: 
 39248:   // The caller may want synchronous scrolling.
 39248:   sf->ScrollBy(pt, scrollUnit, nsIScrollableFrame::INSTANT);
 39248:   return NS_OK;
 39248: }
 54151: 
 54151: void
 78622: nsEventStateManager::DoQuerySelectedText(nsQueryContentEvent* aEvent)
 78622: {
 78622:   if (RemoteQueryContentEvent(aEvent)) {
 78622:     return;
 78622:   }
 78622:   nsContentEventHandler handler(mPresContext);
 78622:   handler.OnQuerySelectedText(aEvent);
 78622: }
 78622: 
 78622: void
 56644: nsEventStateManager::SetActiveManager(nsEventStateManager* aNewESM,
 54151:                                       nsIContent* aContent)
 54151: {
 54151:   if (sActiveESM && aNewESM != sActiveESM) {
106838:     sActiveESM->SetContentState(nullptr, NS_EVENT_STATE_ACTIVE);
 54151:   }
 54151:   sActiveESM = aNewESM;
 56644:   if (sActiveESM && aContent) {
 54151:     sActiveESM->SetContentState(aContent, NS_EVENT_STATE_ACTIVE);
 54151:   }
 54151: }
 55892: 
 55892: void
 56644: nsEventStateManager::ClearGlobalActiveContent(nsEventStateManager* aClearer)
 55892: {
 56644:   if (aClearer) {
106838:     aClearer->SetContentState(nullptr, NS_EVENT_STATE_ACTIVE);
 79435:     if (sDragOverContent) {
106838:       aClearer->SetContentState(nullptr, NS_EVENT_STATE_DRAGOVER);
 79435:     }
 56644:   }
 56644:   if (sActiveESM && aClearer != sActiveESM) {
106838:     sActiveESM->SetContentState(nullptr, NS_EVENT_STATE_ACTIVE);
106838:   }
106838:   sActiveESM = nullptr;
106838: }
108052: 
108054: /******************************************************************/
108061: /* nsEventStateManager::DeltaAccumulator                          */
108054: /******************************************************************/
108054: 
108054: void
108061: nsEventStateManager::DeltaAccumulator::InitLineOrPageDelta(
108054:                                          nsIFrame* aTargetFrame,
108054:                                          nsEventStateManager* aESM,
108061:                                          widget::WheelEvent* aEvent)
108054: {
108054:   MOZ_ASSERT(aESM);
108054:   MOZ_ASSERT(aEvent);
108061: 
108061:   // Reset if the previous wheel event is too old.
108054:   if (!mLastTime.IsNull()) {
108054:     TimeDuration duration = TimeStamp::Now() - mLastTime;
108054:     if (duration.ToMilliseconds() > nsMouseWheelTransaction::GetTimeoutTime()) {
108054:       Reset();
108054:     }
108054:   }
108061:   // If we have accumulated delta,  we may need to reset it.
108743:   if (IsInTransaction()) {
108061:     // If wheel event type is changed, reset the values.
108061:     if (mHandlingDeltaMode != aEvent->deltaMode ||
108061:         mHandlingPixelOnlyDevice != aEvent->isPixelOnlyDevice) {
108061:       Reset();
108061:     } else {
108061:       // If the delta direction is changed, we should reset only the
108061:       // accumulated values.
108061:       if (mX && aEvent->deltaX && ((aEvent->deltaX > 0.0) != (mX > 0.0))) {
108743:         mX = mPendingScrollAmountX = 0.0;
108061:       }
108061:       if (mY && aEvent->deltaY && ((aEvent->deltaY > 0.0) != (mY > 0.0))) {
108743:         mY = mPendingScrollAmountY = 0.0;
108061:       }
108061:     }
108061:   }
108061: 
108061:   mHandlingDeltaMode = aEvent->deltaMode;
108061:   mHandlingPixelOnlyDevice = aEvent->isPixelOnlyDevice;
108061: 
108743:   // If it's handling neither pixel scroll mode for pixel only device nor
108743:   // delta values multiplied by prefs, we must not modify lineOrPageDelta
108743:   // values.
108743:   if (!(mHandlingDeltaMode == nsIDOMWheelEvent::DOM_DELTA_PIXEL &&
108743:         mHandlingPixelOnlyDevice) &&
108743:       !nsEventStateManager::WheelPrefs::GetInstance()->
108743:         NeedToComputeLineOrPageDelta(aEvent)) {
108743:     // Set the delta values to mX and mY.  They would be used when above block
108743:     // resets mX/mY/mPendingScrollAmountX/mPendingScrollAmountY if the direction
108743:     // is changed.
108743:     // NOTE: We shouldn't accumulate the delta values, it might could cause
108743:     //       overflow even though it's not a realistic situation.
108743:     if (aEvent->deltaX) {
108743:       mX = aEvent->deltaX;
108743:     }
108743:     if (aEvent->deltaY) {
108743:       mY = aEvent->deltaY;
108743:     }
108743:     mLastTime = TimeStamp::Now();
108743:     return;
108743:   }
108743: 
108061:   mX += aEvent->deltaX;
108061:   mY += aEvent->deltaY;
108061: 
108061:   if (mHandlingDeltaMode == nsIDOMWheelEvent::DOM_DELTA_PIXEL) {
108061:     // Records pixel delta values and init lineOrPageDeltaX and
108061:     // lineOrPageDeltaY for wheel events which are caused by pixel only
108061:     // devices.  Ignore mouse wheel transaction for computing this.  The
108061:     // lineOrPageDelta values will be used by dispatching legacy
108061:     // NS_MOUSE_SCROLL_EVENT (DOMMouseScroll) but not be used for scrolling
108061:     // of default action.  The transaction should be used only for the default
108061:     // action.
108061:     nsIScrollableFrame* scrollTarget =
111054:       aESM->ComputeScrollTarget(aTargetFrame, aEvent,
111054:                                 COMPUTE_LEGACY_MOUSE_SCROLL_EVENT_TARGET);
108061:     nsIFrame* frame = do_QueryFrame(scrollTarget);
108061:     nsPresContext* pc =
108061:       frame ? frame->PresContext() : aTargetFrame->PresContext();
108061:     nsSize scrollAmount = aESM->GetScrollAmount(pc, aEvent, scrollTarget);
108061:     nsIntSize scrollAmountInCSSPixels(
108061:       nsPresContext::AppUnitsToIntCSSPixels(scrollAmount.width),
108061:       nsPresContext::AppUnitsToIntCSSPixels(scrollAmount.height));
108061: 
108061:     aEvent->lineOrPageDeltaX = RoundDown(mX) / scrollAmountInCSSPixels.width;
108061:     aEvent->lineOrPageDeltaY = RoundDown(mY) / scrollAmountInCSSPixels.height;
108061: 
108061:     mX -= aEvent->lineOrPageDeltaX * scrollAmountInCSSPixels.width;
108061:     mY -= aEvent->lineOrPageDeltaY * scrollAmountInCSSPixels.height;
108061:   } else {
108061:     aEvent->lineOrPageDeltaX = RoundDown(mX);
108061:     aEvent->lineOrPageDeltaY = RoundDown(mY);
108061:     mX -= aEvent->lineOrPageDeltaX;
108061:     mY -= aEvent->lineOrPageDeltaY;
108061:   }
108054: 
108054:   mLastTime = TimeStamp::Now();
108054: }
108054: 
108054: void
108061: nsEventStateManager::DeltaAccumulator::Reset()
108054: {
108061:   mX = mY = 0.0;
108743:   mPendingScrollAmountX = mPendingScrollAmountY = 0.0;
115367:   mHandlingDeltaMode = UINT32_MAX;
108061:   mHandlingPixelOnlyDevice = false;
108054: }
108054: 
108743: nsIntPoint
108743: nsEventStateManager::DeltaAccumulator::ComputeScrollAmountForDefaultAction(
108743:                        widget::WheelEvent* aEvent,
108743:                        const nsIntSize& aScrollAmountInDevPixels)
108743: {
108743:   MOZ_ASSERT(aEvent);
108743: 
108743:   // If the wheel event is line scroll and the delta value is computed from
108743:   // system settings, allow to override the system speed.
108743:   bool allowScrollSpeedOverride =
108743:     (!aEvent->customizedByUserPrefs &&
108743:      aEvent->deltaMode == nsIDOMWheelEvent::DOM_DELTA_LINE);
108743:   DeltaValues acceleratedDelta =
108743:     nsMouseWheelTransaction::AccelerateWheelDelta(aEvent,
108743:                                                   allowScrollSpeedOverride);
108743: 
108743:   nsIntPoint result(0, 0);
108743:   if (aEvent->deltaMode == nsIDOMWheelEvent::DOM_DELTA_PIXEL) {
108743:     mPendingScrollAmountX += acceleratedDelta.deltaX;
108743:     mPendingScrollAmountY += acceleratedDelta.deltaY;
108743:   } else {
108743:     mPendingScrollAmountX +=
108743:       aScrollAmountInDevPixels.width * acceleratedDelta.deltaX;
108743:     mPendingScrollAmountY +=
108743:       aScrollAmountInDevPixels.height * acceleratedDelta.deltaY;
108743:   }
108743:   result.x = RoundDown(mPendingScrollAmountX);
108743:   result.y = RoundDown(mPendingScrollAmountY);
108743:   mPendingScrollAmountX -= result.x;
108743:   mPendingScrollAmountY -= result.y;
108743: 
108743:   return result;
108743: }
108743: 
108052: /******************************************************************/
108052: /* nsEventStateManager::WheelPrefs                                */
108052: /******************************************************************/
108052: 
108052: // static
108052: nsEventStateManager::WheelPrefs*
108052: nsEventStateManager::WheelPrefs::GetInstance()
108052: {
108052:   if (!sInstance) {
108052:     sInstance = new WheelPrefs();
108052:   }
108052:   return sInstance;
108052: }
108052: 
108052: // static
108052: void
108052: nsEventStateManager::WheelPrefs::Shutdown()
108052: {
108052:   delete sInstance;
108052:   sInstance = nullptr;
108052: }
108052: 
108052: // static
108052: int
108052: nsEventStateManager::WheelPrefs::OnPrefChanged(const char* aPrefName,
108052:                                                void* aClosure)
108052: {
108052:   // forget all prefs, it's not problem for performance.
108052:   sInstance->Reset();
108061:   DeltaAccumulator::GetInstance()->Reset();
108052:   return 0;
108052: }
108052: 
108052: nsEventStateManager::WheelPrefs::WheelPrefs()
108052: {
108052:   Reset();
108052:   Preferences::RegisterCallback(OnPrefChanged, "mousewheel.", nullptr);
108052: }
108052: 
108052: nsEventStateManager::WheelPrefs::~WheelPrefs()
108052: {
108052:   Preferences::UnregisterCallback(OnPrefChanged, "mousewheel.", nullptr);
108052: }
108052: 
108052: void
108052: nsEventStateManager::WheelPrefs::Reset()
108052: {
108052:   memset(mInit, 0, sizeof(mInit));
108052: 
108052: }
108052: 
108052: nsEventStateManager::WheelPrefs::Index
108062: nsEventStateManager::WheelPrefs::GetIndexFor(widget::WheelEvent* aEvent)
108052: {
108053:   if (!aEvent) {
108053:     return INDEX_DEFAULT;
108053:   }
108053: 
108052:   widget::Modifiers modifiers =
108052:     (aEvent->modifiers & (widget::MODIFIER_ALT |
108052:                           widget::MODIFIER_CONTROL |
108052:                           widget::MODIFIER_META |
108052:                           widget::MODIFIER_SHIFT |
108052:                           widget::MODIFIER_OS));
108052: 
108052:   switch (modifiers) {
108052:     case widget::MODIFIER_ALT:
108052:       return INDEX_ALT;
108052:     case widget::MODIFIER_CONTROL:
108052:       return INDEX_CONTROL;
108052:     case widget::MODIFIER_META:
108052:       return INDEX_META;
108052:     case widget::MODIFIER_SHIFT:
108052:       return INDEX_SHIFT;
108052:     case widget::MODIFIER_OS:
108052:       return INDEX_OS;
108052:     default:
108052:       // If two or more modifier keys are pressed, we should use default
108052:       // settings.
108052:       return INDEX_DEFAULT;
108052:   }
108052: }
108052: 
108052: void
108052: nsEventStateManager::WheelPrefs::GetBasePrefName(
108052:                        nsEventStateManager::WheelPrefs::Index aIndex,
108052:                        nsACString& aBasePrefName)
108052: {
108052:   aBasePrefName.AssignLiteral("mousewheel.");
108052:   switch (aIndex) {
108052:     case INDEX_ALT:
108053:       aBasePrefName.AppendLiteral("with_alt.");
108052:       break;
108052:     case INDEX_CONTROL:
108053:       aBasePrefName.AppendLiteral("with_control.");
108052:       break;
108052:     case INDEX_META:
108053:       aBasePrefName.AppendLiteral("with_meta.");
108052:       break;
108052:     case INDEX_SHIFT:
108053:       aBasePrefName.AppendLiteral("with_shift.");
108052:       break;
108052:     case INDEX_OS:
108053:       aBasePrefName.AppendLiteral("with_win.");
108052:       break;
108052:     case INDEX_DEFAULT:
108052:     default:
108053:       aBasePrefName.AppendLiteral("default.");
108052:       break;
108052:   }
108052: }
108052: 
108052: void
108052: nsEventStateManager::WheelPrefs::Init(
108052:                        nsEventStateManager::WheelPrefs::Index aIndex)
108052: {
108052:   if (mInit[aIndex]) {
108052:     return;
108052:   }
108052:   mInit[aIndex] = true;
108052: 
110974:   nsAutoCString basePrefName;
108052:   GetBasePrefName(aIndex, basePrefName);
108052: 
110974:   nsAutoCString prefNameX(basePrefName);
108052:   prefNameX.AppendLiteral("delta_multiplier_x");
108052:   mMultiplierX[aIndex] =
108052:     static_cast<double>(Preferences::GetInt(prefNameX.get(), 100)) / 100;
108052: 
110974:   nsAutoCString prefNameY(basePrefName);
108052:   prefNameY.AppendLiteral("delta_multiplier_y");
108052:   mMultiplierY[aIndex] =
108052:     static_cast<double>(Preferences::GetInt(prefNameY.get(), 100)) / 100;
108053: 
110974:   nsAutoCString prefNameZ(basePrefName);
108064:   prefNameZ.AppendLiteral("delta_multiplier_z");
108064:   mMultiplierZ[aIndex] =
108064:     static_cast<double>(Preferences::GetInt(prefNameZ.get(), 100)) / 100;
108064: 
110974:   nsAutoCString prefNameAction(basePrefName);
108053:   prefNameAction.AppendLiteral("action");
125268:   int32_t action = Preferences::GetInt(prefNameAction.get(), ACTION_SCROLL);
125304:   if (action < int32_t(ACTION_NONE) || action > int32_t(ACTION_LAST)) {
108053:     NS_WARNING("Unsupported action pref value, replaced with 'Scroll'.");
125268:     action = ACTION_SCROLL;
125268:   }
125268:   mActions[aIndex] = static_cast<Action>(action);
125268: 
125268:   // Compute action values overridden by .override_x pref.
125268:   // At present, override is possible only for the x-direction
125268:   // because this pref is introduced mainly for tilt wheels.
125268:   prefNameAction.AppendLiteral(".override_x");
125268:   int32_t actionOverrideX = Preferences::GetInt(prefNameAction.get(), -1);
125304:   if (actionOverrideX < -1 || actionOverrideX > int32_t(ACTION_LAST)) {
125268:     NS_WARNING("Unsupported action override pref value, didn't override.");
125268:     actionOverrideX = -1;
125268:   }
125268:   mOverriddenActionsX[aIndex] = (actionOverrideX == -1)
125268:                               ? static_cast<Action>(action)
125268:                               : static_cast<Action>(actionOverrideX);
108052: }
108052: 
108052: void
108052: nsEventStateManager::WheelPrefs::ApplyUserPrefsToDelta(
108059:                                    widget::WheelEvent* aEvent)
108052: {
108052:   Index index = GetIndexFor(aEvent);
108052:   Init(index);
108052: 
108059:   aEvent->deltaX *= mMultiplierX[index];
108059:   aEvent->deltaY *= mMultiplierY[index];
108064:   aEvent->deltaZ *= mMultiplierZ[index];
108059: 
108060:   // If the multiplier is 1.0 or -1.0, i.e., it doesn't change the absolute
108060:   // value, we should use lineOrPageDelta values which were set by widget.
108060:   // Otherwise, we need to compute them from accumulated delta values.
108064:   if (!NeedToComputeLineOrPageDelta(aEvent)) {
108991:     aEvent->lineOrPageDeltaX *= static_cast<int32_t>(mMultiplierX[index]);
108991:     aEvent->lineOrPageDeltaY *= static_cast<int32_t>(mMultiplierY[index]);
108060:   } else {
108060:     aEvent->lineOrPageDeltaX = 0;
108060:     aEvent->lineOrPageDeltaY = 0;
108060:   }
108060: 
108059:   aEvent->customizedByUserPrefs =
108064:     ((mMultiplierX[index] != 1.0) || (mMultiplierY[index] != 1.0) ||
108064:      (mMultiplierZ[index] != 1.0));
108052: }
108053: 
108066: void
108066: nsEventStateManager::WheelPrefs::CancelApplyingUserPrefsFromOverflowDelta(
108066:                                                    widget::WheelEvent* aEvent)
108066: {
108066:   Index index = GetIndexFor(aEvent);
108066:   Init(index);
108066: 
110714:   // XXX If the multiplier pref value is negative, the scroll direction was
110714:   //     changed and caused to scroll different direction.  In such case,
110714:   //     this method reverts the sign of overflowDelta.  Does it make widget
110714:   //     happy?  Although, widget can know the pref applied delta values by
110714:   //     referrencing the deltaX and deltaY of the event.
110714: 
108588:   if (mMultiplierX[index]) {
108066:     aEvent->overflowDeltaX /= mMultiplierX[index];
108588:   }
108588:   if (mMultiplierY[index]) {
108066:     aEvent->overflowDeltaY /= mMultiplierY[index];
108066:   }
108588: }
108066: 
108053: nsEventStateManager::WheelPrefs::Action
108062: nsEventStateManager::WheelPrefs::ComputeActionFor(widget::WheelEvent* aEvent)
108053: {
108053:   Index index = GetIndexFor(aEvent);
108053:   Init(index);
108062: 
125268:   bool deltaXPreferred =
134925:     (Abs(aEvent->deltaX) > Abs(aEvent->deltaY) &&
134925:      Abs(aEvent->deltaX) > Abs(aEvent->deltaZ));
125268:   Action* actions = deltaXPreferred ? mOverriddenActionsX : mActions;
125268:   if (actions[index] == ACTION_NONE || actions[index] == ACTION_SCROLL) {
125268:     return actions[index];
108053:   }
108061: 
108062:   // Momentum events shouldn't run special actions.
108062:   if (aEvent->isMomentum) {
108062:     // Use the default action.  Note that user might kill the wheel scrolling.
108062:     Init(INDEX_DEFAULT);
125268:     return (actions[INDEX_DEFAULT] == ACTION_SCROLL) ? ACTION_SCROLL :
108062:                                                        ACTION_NONE;
108062:   }
108062: 
127591:   return actions[index];
108062: }
108062: 
108061: bool
108061: nsEventStateManager::WheelPrefs::NeedToComputeLineOrPageDelta(
108061:                                    widget::WheelEvent* aEvent)
108061: {
108061:   Index index = GetIndexFor(aEvent);
108061:   Init(index);
108061: 
108061:   return (mMultiplierX[index] != 1.0 && mMultiplierX[index] != -1.0) ||
108061:          (mMultiplierY[index] != 1.0 && mMultiplierY[index] != -1.0);
108061: }
120483: 
120483: bool
120483: nsEventStateManager::WheelPrefs::IsOverOnePageScrollAllowedX(
120483:                                    widget::WheelEvent* aEvent)
120483: {
120483:   Index index = GetIndexFor(aEvent);
120483:   Init(index);
134925:   return Abs(mMultiplierX[index]) >=
120483:            MIN_MULTIPLIER_VALUE_ALLOWING_OVER_ONE_PAGE_SCROLL;
120483: }
120483: 
120483: bool
120483: nsEventStateManager::WheelPrefs::IsOverOnePageScrollAllowedY(
120483:                                    widget::WheelEvent* aEvent)
120483: {
120483:   Index index = GetIndexFor(aEvent);
120483:   Init(index);
134925:   return Abs(mMultiplierY[index]) >=
120483:            MIN_MULTIPLIER_VALUE_ALLOWING_OVER_ONE_PAGE_SCROLL;
120483: }
