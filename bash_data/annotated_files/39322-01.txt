29366: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=8 sw=4 et tw=80:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS execution context.
    1:  */
32777: #include <new>
    1: #include <stdarg.h>
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsarena.h" /* Added by JSIFY */
    1: #include "jsutil.h" /* Added by JSIFY */
    1: #include "jsclist.h"
    1: #include "jsprf.h"
    1: #include "jsatom.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsdbgapi.h"
    1: #include "jsexn.h"
16519: #include "jsfun.h"
    1: #include "jsgc.h"
    1: #include "jslock.h"
31898: #include "jsmath.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
24874: #include "jspubtd.h"
    1: #include "jsscan.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
24499: #include "jsstaticcheck.h"
    1: #include "jsstr.h"
17583: #include "jstracer.h"
    1: 
37741: using namespace js;
37741: 
26569: static void
26569: FreeContext(JSContext *cx);
26569: 
26569: static void
35075: MarkLocalRoots(JSTracer *trc, JSLocalRootStack *lrs);
35075: 
37777: #ifdef DEBUG
37777: bool
37777: CallStack::contains(JSStackFrame *fp)
37777: {
37777:     JSStackFrame *start;
37777:     JSStackFrame *stop;
37777:     if (isSuspended()) {
37777:         start = suspendedFrame;
37777:         stop = initialFrame->down;
37777:     } else {
37777:         start = cx->fp;
37777:         stop = cx->activeCallStack()->initialFrame->down;
37777:     }
37777:     for (JSStackFrame *f = start; f != stop; f = f->down) {
37777:         if (f == fp)
37777:             return true;
37777:     }
37777:     return false;
37777: }
37777: #endif
37777: 
35075: void
35075: JSThreadData::init()
26569: {
26569: #ifdef DEBUG
26569:     /* The data must be already zeroed. */
35075:     for (size_t i = 0; i != sizeof(*this); ++i)
35075:         JS_ASSERT(reinterpret_cast<uint8*>(this)[i] == 0);
26569: #endif
26569: #ifdef JS_TRACER
37741:     InitJIT(&traceMonitor);
26569: #endif
35075:     js_InitRandom(this);
26569: }
26569: 
35075: void
35075: JSThreadData::finish()
26569: {
26569: #ifdef DEBUG
26569:     /* All GC-related things must be already removed at this point. */
35075:     JS_ASSERT(gcFreeLists.isEmpty());
35075:     for (size_t i = 0; i != JS_ARRAY_LENGTH(scriptsToGC); ++i)
35075:         JS_ASSERT(!scriptsToGC[i]);
35075:     for (size_t i = 0; i != JS_ARRAY_LENGTH(nativeEnumCache); ++i)
35075:         JS_ASSERT(!nativeEnumCache[i]);
35075:     JS_ASSERT(!localRootStack);
26569: #endif
26569: 
35075:     js_FinishGSNCache(&gsnCache);
35075:     js_FinishPropertyCache(&propertyCache);
26569: #if defined JS_TRACER
37741:     FinishJIT(&traceMonitor);
26569: #endif
26569: }
26569: 
35075: void
35075: JSThreadData::mark(JSTracer *trc)
26569: {
35075: #ifdef JS_TRACER
35075:     traceMonitor.mark(trc);
35075: #endif
35075:     if (localRootStack)
35075:         MarkLocalRoots(trc, localRootStack);
35075: }
33747: 
35075: void
35075: JSThreadData::purge(JSContext *cx)
35075: {
35075:     purgeGCFreeLists();
35075: 
35075:     js_PurgeGSNCache(&gsnCache);
30733: 
30735:     /* FIXME: bug 506341. */
35075:     js_PurgePropertyCache(cx, &propertyCache);
30733: 
26569: #ifdef JS_TRACER
30733:     /*
33171:      * If we are about to regenerate shapes, we have to flush the JIT cache,
33171:      * which will eventually abort any current recording.
30733:      */
31843:     if (cx->runtime->gcRegenShapes)
35075:         traceMonitor.needFlush = JS_TRUE;
26569: #endif
26561: 
26569:     /* Destroy eval'ed scripts. */
35075:     js_DestroyScriptsToGC(cx, this);
33128: 
35075:     js_PurgeCachedNativeEnumerators(cx, this);
35075: }
35075: 
35075: void
35075: JSThreadData::purgeGCFreeLists()
35075: {
35075:     if (!localRootStack) {
35075:         gcFreeLists.purge();
35075:     } else {
35075:         JS_ASSERT(gcFreeLists.isEmpty());
35075:         localRootStack->gcFreeLists.purge();
35075:     }
26569: }
26569: 
26569: #ifdef JS_THREADSAFE
26569: 
26569: static JSThread *
26569: NewThread(jsword id)
26560: {
26569:     JS_ASSERT(js_CurrentThreadId() == id);
30851:     JSThread *thread = (JSThread *) js_calloc(sizeof(JSThread));
26569:     if (!thread)
26569:         return NULL;
26569:     JS_INIT_CLIST(&thread->contextList);
26569:     thread->id = id;
35075:     thread->data.init();
26569:     return thread;
26569: }
26561: 
26569: static void
26569: DestroyThread(JSThread *thread)
26561: {
26569:     /* The thread must have zero contexts. */
26561:     JS_ASSERT(JS_CLIST_IS_EMPTY(&thread->contextList));
27384:     JS_ASSERT(!thread->titleToShare);
35075:     thread->data.finish();
30851:     js_free(thread);
26560: }
26560: 
34365: JSThread *
34365: js_CurrentThread(JSRuntime *rt)
26569: {
26569:     jsword id = js_CurrentThreadId();
26569:     JS_LOCK_GC(rt);
26569: 
26561:     /*
26569:      * We must not race with a GC that accesses cx->thread for JSContext
26569:      * instances on all threads, see bug 476934.
26561:      */
26569:     js_WaitForGC(rt);
26569:     JSThreadsHashEntry *entry = (JSThreadsHashEntry *)
26569:                                 JS_DHashTableOperate(&rt->threads,
26569:                                                      (const void *) id,
26569:                                                      JS_DHASH_LOOKUP);
26561:     JSThread *thread;
26569:     if (JS_DHASH_ENTRY_IS_BUSY(&entry->base)) {
26569:         thread = entry->thread;
26569:         JS_ASSERT(thread->id == id);
26569:     } else {
26569:         JS_UNLOCK_GC(rt);
26569:         thread = NewThread(id);
26561:         if (!thread)
34365:             return NULL;
26569:         JS_LOCK_GC(rt);
26569:         js_WaitForGC(rt);
26569:         entry = (JSThreadsHashEntry *)
26569:                 JS_DHashTableOperate(&rt->threads, (const void *) id,
26569:                                      JS_DHASH_ADD);
26569:         if (!entry) {
26569:             JS_UNLOCK_GC(rt);
26569:             DestroyThread(thread);
34365:             return NULL;
26560:         }
26560: 
26569:         /* Another thread cannot initialize entry->thread. */
26569:         JS_ASSERT(!entry->thread);
26569:         entry->thread = thread;
13825:     }
    1: 
34365:     return thread;
34365: }
34365: 
34365: JSBool
34365: js_InitContextThread(JSContext *cx)
34365: {
34365:     JSThread *thread = js_CurrentThread(cx->runtime);
34365:     if (!thread)
34365:         return false;
34365: 
 9058:     JS_APPEND_LINK(&cx->threadLinks, &thread->contextList);
    1:     cx->thread = thread;
26569:     return true;
26569: }
26569: 
26569: void
26569: js_ClearContextThread(JSContext *cx)
26569: {
26569:     JS_ASSERT(CURRENT_THREAD_IS_ME(cx->thread));
26569:     JS_REMOVE_AND_INIT_LINK(&cx->threadLinks);
26569:     cx->thread = NULL;
26569: }
26569: 
26569: static JSBool
26569: thread_matchEntry(JSDHashTable *table,
26569:                   const JSDHashEntryHdr *hdr,
26569:                   const void *key)
26569: {
26569:     const JSThreadsHashEntry *entry = (const JSThreadsHashEntry *) hdr;
26569: 
26569:     return entry->thread->id == (jsword) key;
26569: }
26569: 
26569: static const JSDHashTableOps threads_ops = {
26569:     JS_DHashAllocTable,
26569:     JS_DHashFreeTable,
26569:     JS_DHashVoidPtrKeyStub,
26569:     thread_matchEntry,
26569:     JS_DHashMoveEntryStub,
26569:     JS_DHashClearEntryStub,
26569:     JS_DHashFinalizeStub,
26569:     NULL
26569: };
26569: 
26569: static JSDHashOperator
26569: thread_destroyer(JSDHashTable *table, JSDHashEntryHdr *hdr, uint32 /* index */,
26569:                  void * /* arg */)
26569: {
26569:     JSThreadsHashEntry *entry = (JSThreadsHashEntry *) hdr;
26569:     JSThread *thread = entry->thread;
26569: 
26569:     JS_ASSERT(JS_CLIST_IS_EMPTY(&thread->contextList));
26569:     DestroyThread(thread);
26569:     return JS_DHASH_REMOVE;
26569: }
26569: 
26569: static JSDHashOperator
26569: thread_purger(JSDHashTable *table, JSDHashEntryHdr *hdr, uint32 /* index */,
26569:               void *arg)
26569: {
26569:     JSContext* cx = (JSContext *) arg;
26569:     JSThread *thread = ((JSThreadsHashEntry *) hdr)->thread;
26569: 
26569:     if (JS_CLIST_IS_EMPTY(&thread->contextList)) {
26569:         JS_ASSERT(cx->thread != thread);
26569:         js_DestroyScriptsToGC(cx, &thread->data);
33128: 
33128:         /*
33952:          * The following is potentially suboptimal as it also zeros the caches
33128:          * in data, but the code simplicity wins here.
33128:          */
35075:         thread->data.purgeGCFreeLists();
33128:         js_PurgeCachedNativeEnumerators(cx, &thread->data);
26569:         DestroyThread(thread);
26569:         return JS_DHASH_REMOVE;
26569:     }
35075:     thread->data.purge(cx);
34288:     thread->gcThreadMallocBytes = JS_GC_THREAD_MALLOC_LIMIT;
26569:     return JS_DHASH_NEXT;
    1: }
    1: 
31843: static JSDHashOperator
35075: thread_marker(JSDHashTable *table, JSDHashEntryHdr *hdr, uint32 /* index */,
31843:               void *arg)
31843: {
31843:     JSThread *thread = ((JSThreadsHashEntry *) hdr)->thread;
31843:     thread->data.mark((JSTracer *) arg);
31843:     return JS_DHASH_NEXT;
31843: }
31843: 
    1: #endif /* JS_THREADSAFE */
    1: 
34365: JSThreadData *
34365: js_CurrentThreadData(JSRuntime *rt)
34365: {
34365: #ifdef JS_THREADSAFE
34366:     JSThread *thread = js_CurrentThread(rt);
34365:     if (!thread)
34365:         return NULL;
34365: 
34365:     return &thread->data;
34365: #else
34365:     return &rt->threadData;
34365: #endif
34365: }
34365: 
26569: JSBool
26569: js_InitThreads(JSRuntime *rt)
26569: {
26569: #ifdef JS_THREADSAFE
26569:     if (!JS_DHashTableInit(&rt->threads, &threads_ops, NULL,
26569:                            sizeof(JSThreadsHashEntry), 4)) {
26569:         rt->threads.ops = NULL;
26569:         return false;
26569:     }
26569: #else
35075:     rt->threadData.init();
26569: #endif
26569:     return true;
26569: }
26569: 
26569: void
26569: js_FinishThreads(JSRuntime *rt)
26569: {
26569: #ifdef JS_THREADSAFE
26569:     if (!rt->threads.ops)
26569:         return;
26569:     JS_DHashTableEnumerate(&rt->threads, thread_destroyer, NULL);
26569:     JS_DHashTableFinish(&rt->threads);
26569:     rt->threads.ops = NULL;
26569: #else
35075:     rt->threadData.finish();
26569: #endif
26569: }
26569: 
26569: void
26569: js_PurgeThreads(JSContext *cx)
26569: {
26569: #ifdef JS_THREADSAFE
26569:     JS_DHashTableEnumerate(&cx->runtime->threads, thread_purger, cx);
26569: #else
35075:     cx->runtime->threadData.purge(cx);
26569: #endif
26569: }
26569: 
31843: void
31843: js_TraceThreads(JSRuntime *rt, JSTracer *trc)
31843: {
31843: #ifdef JS_THREADSAFE
35075:     JS_DHashTableEnumerate(&rt->threads, thread_marker, trc);
31843: #else
31843:     rt->threadData.mark(trc);
31843: #endif
31843: }
31843: 
24874: /*
24874:  * JSOPTION_XML and JSOPTION_ANONFUNFIX must be part of the JS version
24874:  * associated with scripts, so in addition to storing them in cx->options we
24874:  * duplicate them in cx->version (script->version, etc.) and ensure each bit
24874:  * remains synchronized between the two through these two functions.
24874:  */
24874: void
24874: js_SyncOptionsToVersion(JSContext* cx)
24874: {
24874:     if (cx->options & JSOPTION_XML)
24874:         cx->version |= JSVERSION_HAS_XML;
24874:     else
24874:         cx->version &= ~JSVERSION_HAS_XML;
24874:     if (cx->options & JSOPTION_ANONFUNFIX)
24874:         cx->version |= JSVERSION_ANONFUNFIX;
24874:     else
24874:         cx->version &= ~JSVERSION_ANONFUNFIX;
24874: }
24874: 
24874: inline void
24874: js_SyncVersionToOptions(JSContext* cx)
24874: {
24874:     if (cx->version & JSVERSION_HAS_XML)
24874:         cx->options |= JSOPTION_XML;
24874:     else
24874:         cx->options &= ~JSOPTION_XML;
24874:     if (cx->version & JSVERSION_ANONFUNFIX)
24874:         cx->options |= JSOPTION_ANONFUNFIX;
24874:     else
24874:         cx->options &= ~JSOPTION_ANONFUNFIX;
24874: }
24874: 
    1: void
    1: js_OnVersionChange(JSContext *cx)
    1: {
    1: #ifdef DEBUG
    1:     JSVersion version = JSVERSION_NUMBER(cx);
    1: 
    1:     JS_ASSERT(version == JSVERSION_DEFAULT || version >= JSVERSION_ECMA_3);
    1: #endif
    1: }
    1: 
    1: void
    1: js_SetVersion(JSContext *cx, JSVersion version)
    1: {
    1:     cx->version = version;
24874:     js_SyncVersionToOptions(cx);
    1:     js_OnVersionChange(cx);
    1: }
    1: 
    1: JSContext *
    1: js_NewContext(JSRuntime *rt, size_t stackChunkSize)
    1: {
    1:     JSContext *cx;
    1:     JSBool ok, first;
    1:     JSContextCallback cxCallback;
    1: 
24872:     /*
24872:      * We need to initialize the new context fully before adding it to the
24872:      * runtime list. After that it can be accessed from another thread via
24872:      * js_ContextIterator.
24872:      */
32777:     void *mem = js_calloc(sizeof *cx);
32777:     if (!mem)
    1:         return NULL;
    1: 
32777:     cx = new (mem) JSContext(rt);
 2433:     cx->debugHooks = &rt->globalDebugHooks;
    1: #if JS_STACK_GROWTH_DIRECTION > 0
    1:     cx->stackLimit = (jsuword) -1;
    1: #endif
 5344:     cx->scriptStackQuota = JS_DEFAULT_SCRIPT_STACK_QUOTA;
24872:     JS_STATIC_ASSERT(JSVERSION_DEFAULT == 0);
24872:     JS_ASSERT(cx->version == JSVERSION_DEFAULT);
24872:     VOUCH_DOES_NOT_REQUIRE_STACK();
35112:     JS_InitArenaPool(&cx->stackPool, "stack", stackChunkSize, sizeof(jsval),
24872:                      &cx->scriptStackQuota);
24872: 
35112:     JS_InitArenaPool(&cx->tempPool, "temp",
24872:                      1024,  /* FIXME: bug 421435 */
24872:                      sizeof(jsdouble), &cx->scriptStackQuota);
24872: 
24872:     js_InitRegExpStatics(cx);
24872:     JS_ASSERT(cx->resolveFlags == 0);
    1: 
26569: #ifdef JS_THREADSAFE
26569:     if (!js_InitContextThread(cx)) {
26569:         FreeContext(cx);
26569:         return NULL;
26569:     }
26569: #endif
26569: 
26569:     /*
26569:      * Here the GC lock is still held after js_InitContextThread took it and
26569:      * the GC is not running on another thread.
26569:      */
26561:     for (;;) {
    1:         if (rt->state == JSRTS_UP) {
26058:             JS_ASSERT(!JS_CLIST_IS_EMPTY(&rt->contextList));
26058:             first = JS_FALSE;
    1:             break;
    1:         }
    1:         if (rt->state == JSRTS_DOWN) {
26058:             JS_ASSERT(JS_CLIST_IS_EMPTY(&rt->contextList));
26058:             first = JS_TRUE;
    1:             rt->state = JSRTS_LAUNCHING;
    1:             break;
    1:         }
    1:         JS_WAIT_CONDVAR(rt->stateChange, JS_NO_TIMEOUT);
26569: 
26569:         /*
26569:          * During the above wait after we are notified about the state change
26569:          * but before we wake up, another thread could enter the GC from
26569:          * js_DestroyContext, bug 478336. So we must wait here to ensure that
26569:          * when we exit the loop with the first flag set to true, that GC is
26569:          * finished.
26569:          */
26569:         js_WaitForGC(rt);
    1:     }
23092:     JS_APPEND_LINK(&cx->link, &rt->contextList);
    1:     JS_UNLOCK_GC(rt);
    1: 
    1:     /*
    1:      * If cx is the first context on this runtime, initialize well-known atoms,
    1:      * keywords, numbers, and strings.  If one of these steps should fail, the
    1:      * runtime will be left in a partially initialized state, with zeroes and
    1:      * nulls stored in the default-initialized remainder of the struct.  We'll
    1:      * clean the runtime up under js_DestroyContext, because cx will be "last"
    1:      * as well as "first".
    1:      */
    1:     if (first) {
    1: #ifdef JS_THREADSAFE
    1:         JS_BeginRequest(cx);
    1: #endif
 4342:         ok = js_InitCommonAtoms(cx);
 4342: 
    1:         /*
 4342:          * scriptFilenameTable may be left over from a previous episode of
 4342:          * non-zero contexts alive in rt, so don't re-init the table if it's
 4342:          * not necessary.
    1:          */
    1:         if (ok && !rt->scriptFilenameTable)
    1:             ok = js_InitRuntimeScriptState(rt);
    1:         if (ok)
    1:             ok = js_InitRuntimeNumberState(cx);
    1:         if (ok)
    1:             ok = js_InitRuntimeStringState(cx);
37766:         if (ok)
37766:             ok = JSScope::initRuntimeState(cx);
37766: 
    1: #ifdef JS_THREADSAFE
    1:         JS_EndRequest(cx);
    1: #endif
    1:         if (!ok) {
    1:             js_DestroyContext(cx, JSDCM_NEW_FAILED);
    1:             return NULL;
    1:         }
    1: 
    1:         JS_LOCK_GC(rt);
    1:         rt->state = JSRTS_UP;
    1:         JS_NOTIFY_ALL_CONDVAR(rt->stateChange);
    1:         JS_UNLOCK_GC(rt);
    1:     }
    1: 
    1:     cxCallback = rt->cxCallback;
    1:     if (cxCallback && !cxCallback(cx, JSCONTEXT_NEW)) {
    1:         js_DestroyContext(cx, JSDCM_NEW_FAILED);
    1:         return NULL;
    1:     }
17442: 
38568:     /* Using ContextAllocPolicy, so init after JSContext is ready. */
38568:     if (!cx->busyArrays.init()) {
38568:         FreeContext(cx);
38568:         return NULL;
38568:     }
38568: 
    1:     return cx;
    1: }
    1: 
24375: #if defined DEBUG && defined XP_UNIX
24375: # include <stdio.h>
24375: 
27012: class JSAutoFile {
24869: public:
27012:     JSAutoFile() : mFile(NULL) {}
24869: 
27012:     ~JSAutoFile() {
27012:         if (mFile)
27012:             fclose(mFile);
24869:     }
24869: 
24869:     FILE *open(const char *fname, const char *mode) {
27012:         return mFile = fopen(fname, mode);
24869:     }
24869:     operator FILE *() {
27012:         return mFile;
24869:     }
24869: 
24869: private:
27012:     FILE *mFile;
24869: };
24869: 
27012: #ifdef JS_EVAL_CACHE_METERING
24375: static void
24375: DumpEvalCacheMeter(JSContext *cx)
24375: {
24375:     struct {
24375:         const char *name;
24375:         ptrdiff_t  offset;
24375:     } table[] = {
24375: #define frob(x) { #x, offsetof(JSEvalCacheMeter, x) }
24375:         EVAL_CACHE_METER_LIST(frob)
24375: #undef frob
24375:     };
26569:     JSEvalCacheMeter *ecm = &JS_THREAD_DATA(cx)->evalCacheMeter;
24375: 
27012:     static JSAutoFile fp;
24375:     if (!fp) {
24869:         fp.open("/tmp/evalcache.stats", "w");
24375:         if (!fp)
24375:             return;
24375:     }
24375: 
24375:     fprintf(fp, "eval cache meter (%p):\n",
24375: #ifdef JS_THREADSAFE
24869:             (void *) cx->thread
24375: #else
24869:             (void *) cx->runtime
24375: #endif
24375:             );
24375:     for (uintN i = 0; i < JS_ARRAY_LENGTH(table); ++i) {
24375:         fprintf(fp, "%-8.8s  %llu\n",
33132:                 table[i].name,
33132:                 (unsigned long long int) *(uint64 *)((uint8 *)ecm + table[i].offset));
24375:     }
24375:     fprintf(fp, "hit ratio %g%%\n", ecm->hit * 100. / ecm->probe);
24375:     fprintf(fp, "avg steps %g\n", double(ecm->step) / ecm->probe);
24375:     fflush(fp);
24375: }
24375: # define DUMP_EVAL_CACHE_METER(cx) DumpEvalCacheMeter(cx)
27012: #endif
27012: 
27012: #ifdef JS_FUNCTION_METERING
27012: static void
27012: DumpFunctionMeter(JSContext *cx)
27012: {
27012:     struct {
27012:         const char *name;
27012:         ptrdiff_t  offset;
27012:     } table[] = {
27012: #define frob(x) { #x, offsetof(JSFunctionMeter, x) }
27012:         FUNCTION_KIND_METER_LIST(frob)
27012: #undef frob
27012:     };
27012:     JSFunctionMeter *fm = &cx->runtime->functionMeter;
27012: 
27012:     static JSAutoFile fp;
27012:     if (!fp) {
27012:         fp.open("/tmp/function.stats", "a");
27012:         if (!fp)
27012:             return;
27012:     }
27012: 
27012:     fprintf(fp, "function meter (%s):\n", cx->runtime->lastScriptFilename);
27012:     for (uintN i = 0; i < JS_ARRAY_LENGTH(table); ++i) {
27012:         fprintf(fp, "%-11.11s %d\n",
27012:                 table[i].name, *(int32 *)((uint8 *)fm + table[i].offset));
27012:     }
27012:     fflush(fp);
27012: }
27012: # define DUMP_FUNCTION_METER(cx)   DumpFunctionMeter(cx)
27012: #endif
27012: 
27012: #endif /* DEBUG && XP_UNIX */
27012: 
27012: #ifndef DUMP_EVAL_CACHE_METER
24375: # define DUMP_EVAL_CACHE_METER(cx) ((void) 0)
24375: #endif
24375: 
27012: #ifndef DUMP_FUNCTION_METER
27012: # define DUMP_FUNCTION_METER(cx)   ((void) 0)
27012: #endif
27012: 
38604: #ifdef JS_PROTO_CACHE_METERING
38604: static void
38604: DumpProtoCacheMeter(JSContext *cx)
38604: {
38604:     JSClassProtoCache::Stats *stats = &cx->runtime->classProtoCacheStats;
38604:     FILE *fp = fopen("/tmp/protocache.stats", "a");
38604:     fprintf(fp,
38604:             "hit ratio %g%%\n",
38604:             double(stats->hit) * 100.0 / double(stats->probe));
38604:     fclose(fp);
38604: }
38604: 
38604: # define DUMP_PROTO_CACHE_METER(cx) DumpProtoCacheMeter(cx)
38604: #else
38604: # define DUMP_PROTO_CACHE_METER(cx) ((void) 0)
38604: #endif
38604: 
38604: 
    1: void
    1: js_DestroyContext(JSContext *cx, JSDestroyContextMode mode)
    1: {
    1:     JSRuntime *rt;
    1:     JSContextCallback cxCallback;
    1:     JSBool last;
    1: 
28456:     rt = cx->runtime;
24871: #ifdef JS_THREADSAFE
26670:     /*
26670:      * For API compatibility we allow to destroy contexts without a thread in
26670:      * optimized builds. We assume that the embedding knows that an OOM error
26670:      * cannot happen in JS_SetContextThread.
26670:      */
26670:     JS_ASSERT(cx->thread && CURRENT_THREAD_IS_ME(cx->thread));
26670:     if (!cx->thread)
26670:         JS_SetContextThread(cx);
    1: 
28455:     JS_ASSERT_IF(rt->gcRunning, cx->outstandingRequests == 0);
28456: #endif
28455: 
    1:     if (mode != JSDCM_NEW_FAILED) {
    1:         cxCallback = rt->cxCallback;
    1:         if (cxCallback) {
    1:             /*
    1:              * JSCONTEXT_DESTROY callback is not allowed to fail and must
    1:              * return true.
    1:              */
    1: #ifdef DEBUG
    1:             JSBool callbackStatus =
    1: #endif
    1:             cxCallback(cx, JSCONTEXT_DESTROY);
    1:             JS_ASSERT(callbackStatus);
    1:         }
    1:     }
    1: 
    1:     JS_LOCK_GC(rt);
    1:     JS_ASSERT(rt->state == JSRTS_UP || rt->state == JSRTS_LAUNCHING);
24872: #ifdef JS_THREADSAFE
24872:     /*
24872:      * Typically we are called outside a request, so ensure that the GC is not
24872:      * running before removing the context from rt->contextList, see bug 477021.
24872:      */
24872:     if (cx->requestDepth == 0)
24872:         js_WaitForGC(rt);
24872: #endif
23092:     JS_REMOVE_LINK(&cx->link);
    1:     last = (rt->contextList.next == &rt->contextList);
    1:     if (last)
    1:         rt->state = JSRTS_LANDING;
26569:     if (last || mode == JSDCM_FORCE_GC || mode == JSDCM_MAYBE_GC
26569: #ifdef JS_THREADSAFE
26569:         || cx->requestDepth != 0
26569: #endif
26569:         ) {
28663:         JS_ASSERT(!rt->gcRunning);
28455: 
    1:         JS_UNLOCK_GC(rt);
    1: 
    1:         if (last) {
    1: #ifdef JS_THREADSAFE
    1:             /*
    1:              * If cx is not in a request already, begin one now so that we wait
    1:              * for any racing GC started on a not-last context to finish, before
    1:              * we plow ahead and unpin atoms.  Note that even though we begin a
    1:              * request here if necessary, we end all requests on cx below before
    1:              * forcing a final GC.  This lets any not-last context destruction
    1:              * racing in another thread try to force or maybe run the GC, but by
    1:              * that point, rt->state will not be JSRTS_UP, and that GC attempt
    1:              * will return early.
    1:              */
    1:             if (cx->requestDepth == 0)
    1:                 JS_BeginRequest(cx);
    1: #endif
    1: 
37766:             JSScope::finishRuntimeState(cx);
    1:             js_FinishRuntimeNumberState(cx);
    1:             js_FinishRuntimeStringState(cx);
    1: 
 4342:             /* Unpin all common atoms before final GC. */
 4342:             js_FinishCommonAtoms(cx);
 4076: 
    1:             /* Clear debugging state to remove GC roots. */
    1:             JS_ClearAllTraps(cx);
    1:             JS_ClearAllWatchPoints(cx);
    1:         }
    1: 
23094:         /* Remove more GC roots in regExpStatics, then collect garbage. */
23094:         JS_ClearRegExpRoots(cx);
    1: 
    1: #ifdef JS_THREADSAFE
    1:         /*
    1:          * Destroying a context implicitly calls JS_EndRequest().  Also, we must
    1:          * end our request here in case we are "last" -- in that event, another
    1:          * js_DestroyContext that was not last might be waiting in the GC for our
    1:          * request to end.  We'll let it run below, just before we do the truly
    1:          * final GC and then free atom state.
    1:          */
    1:         while (cx->requestDepth != 0)
    1:             JS_EndRequest(cx);
    1: #endif
    1: 
    1:         if (last) {
    1:             js_GC(cx, GC_LAST_CONTEXT);
24375:             DUMP_EVAL_CACHE_METER(cx);
27012:             DUMP_FUNCTION_METER(cx);
38604:             DUMP_PROTO_CACHE_METER(cx);
    1: 
    1:             /* Take the runtime down, now that it has no contexts or atoms. */
    1:             JS_LOCK_GC(rt);
    1:             rt->state = JSRTS_DOWN;
    1:             JS_NOTIFY_ALL_CONDVAR(rt->stateChange);
    1:         } else {
    1:             if (mode == JSDCM_FORCE_GC)
    1:                 js_GC(cx, GC_NORMAL);
    1:             else if (mode == JSDCM_MAYBE_GC)
    1:                 JS_MaybeGC(cx);
26569:             JS_LOCK_GC(rt);
26569:             js_WaitForGC(rt);
    1:         }
26569:     }
26569: #ifdef JS_THREADSAFE
26569:     js_ClearContextThread(cx);
26569: #endif
26569:     JS_UNLOCK_GC(rt);
26569:     FreeContext(cx);
26569: }
26569: 
26569: static void
26569: FreeContext(JSContext *cx)
26569: {
26569: #ifdef JS_THREADSAFE
26569:     JS_ASSERT(!cx->thread);
26569: #endif
    1: 
    1:     /* Free the stuff hanging off of cx. */
23094:     js_FreeRegExpStatics(cx);
24499:     VOUCH_DOES_NOT_REQUIRE_STACK();
    1:     JS_FinishArenaPool(&cx->stackPool);
    1:     JS_FinishArenaPool(&cx->tempPool);
    1: 
    1:     if (cx->lastMessage)
30851:         js_free(cx->lastMessage);
    1: 
    1:     /* Remove any argument formatters. */
35075:     JSArgumentFormatMap *map = cx->argumentFormatMap;
    1:     while (map) {
    1:         JSArgumentFormatMap *temp = map;
    1:         map = map->next;
30851:         cx->free(temp);
    1:     }
    1: 
    1:     /* Destroy the resolve recursion damper. */
    1:     if (cx->resolvingTable) {
    1:         JS_DHashTableDestroy(cx->resolvingTable);
    1:         cx->resolvingTable = NULL;
    1:     }
    1: 
    1:     /* Finally, free cx itself. */
38568:     cx->~JSContext();
30851:     js_free(cx);
    1: }
    1: 
    1: JSBool
    1: js_ValidContextPointer(JSRuntime *rt, JSContext *cx)
    1: {
    1:     JSCList *cl;
    1: 
    1:     for (cl = rt->contextList.next; cl != &rt->contextList; cl = cl->next) {
23092:         if (cl == &cx->link)
    1:             return JS_TRUE;
    1:     }
    1:     JS_RUNTIME_METER(rt, deadContexts);
    1:     return JS_FALSE;
    1: }
    1: 
23442: JSContext *
    1: js_ContextIterator(JSRuntime *rt, JSBool unlocked, JSContext **iterp)
    1: {
    1:     JSContext *cx = *iterp;
    1: 
    1:     if (unlocked)
    1:         JS_LOCK_GC(rt);
23092:     cx = js_ContextFromLinkField(cx ? cx->link.next : rt->contextList.next);
23092:     if (&cx->link == &rt->contextList)
    1:         cx = NULL;
    1:     *iterp = cx;
    1:     if (unlocked)
    1:         JS_UNLOCK_GC(rt);
    1:     return cx;
    1: }
    1: 
25087: JS_FRIEND_API(JSContext *)
25087: js_NextActiveContext(JSRuntime *rt, JSContext *cx)
25087: {
25087:     JSContext *iter = cx;
25087: #ifdef JS_THREADSAFE
25087:     while ((cx = js_ContextIterator(rt, JS_FALSE, &iter)) != NULL) {
25087:         if (cx->requestDepth)
25087:             break;
25087:     }
25087:     return cx;
25087: #else
25087:     return js_ContextIterator(rt, JS_FALSE, &iter);
25087: #endif
25087: }
25087: 
27384: #ifdef JS_THREADSAFE
27384: 
27384: uint32
27384: js_CountThreadRequests(JSContext *cx)
27384: {
27384:     JSCList *head, *link;
27384:     uint32 nrequests;
27384: 
27384:     JS_ASSERT(CURRENT_THREAD_IS_ME(cx->thread));
27384:     head = &cx->thread->contextList;
27384:     nrequests = 0;
27384:     for (link = head->next; link != head; link = link->next) {
27384:         JSContext *acx = CX_FROM_THREAD_LINKS(link);
27384:         JS_ASSERT(acx->thread == cx->thread);
27384:         if (acx->requestDepth)
27384:             nrequests++;
27384:     }
27384:     return nrequests;
27384: }
27384: 
27384: /*
27384:  * If the GC is running and we're called on another thread, wait for this GC
27384:  * activation to finish. We can safely wait here without fear of deadlock (in
27384:  * the case where we are called within a request on another thread's context)
27384:  * because the GC doesn't set rt->gcRunning until after it has waited for all
27384:  * active requests to end.
27384:  *
27384:  * We call here js_CurrentThreadId() after checking for rt->gcRunning to avoid
27384:  * expensive calls when the GC is not running.
27384:  */
27384: void
27384: js_WaitForGC(JSRuntime *rt)
27384: {
27384:     JS_ASSERT_IF(rt->gcRunning, rt->gcLevel > 0);
27384:     if (rt->gcRunning && rt->gcThread->id != js_CurrentThreadId()) {
27384:         do {
27384:             JS_AWAIT_GC_DONE(rt);
27384:         } while (rt->gcRunning);
27384:     }
27384: }
27384: 
27384: #endif
27384: 
18907: static JSDHashNumber
    1: resolving_HashKey(JSDHashTable *table, const void *ptr)
    1: {
    1:     const JSResolvingKey *key = (const JSResolvingKey *)ptr;
    1: 
    1:     return ((JSDHashNumber)JS_PTR_TO_UINT32(key->obj) >> JSVAL_TAGBITS) ^ key->id;
    1: }
    1: 
    1: JS_PUBLIC_API(JSBool)
    1: resolving_MatchEntry(JSDHashTable *table,
    1:                      const JSDHashEntryHdr *hdr,
    1:                      const void *ptr)
    1: {
    1:     const JSResolvingEntry *entry = (const JSResolvingEntry *)hdr;
    1:     const JSResolvingKey *key = (const JSResolvingKey *)ptr;
    1: 
    1:     return entry->key.obj == key->obj && entry->key.id == key->id;
    1: }
    1: 
    1: static const JSDHashTableOps resolving_dhash_ops = {
    1:     JS_DHashAllocTable,
    1:     JS_DHashFreeTable,
    1:     resolving_HashKey,
    1:     resolving_MatchEntry,
    1:     JS_DHashMoveEntryStub,
    1:     JS_DHashClearEntryStub,
    1:     JS_DHashFinalizeStub,
    1:     NULL
    1: };
    1: 
    1: JSBool
    1: js_StartResolving(JSContext *cx, JSResolvingKey *key, uint32 flag,
    1:                   JSResolvingEntry **entryp)
    1: {
    1:     JSDHashTable *table;
    1:     JSResolvingEntry *entry;
    1: 
    1:     table = cx->resolvingTable;
    1:     if (!table) {
    1:         table = JS_NewDHashTable(&resolving_dhash_ops, NULL,
    1:                                  sizeof(JSResolvingEntry),
    1:                                  JS_DHASH_MIN_SIZE);
    1:         if (!table)
    1:             goto outofmem;
    1:         cx->resolvingTable = table;
    1:     }
    1: 
    1:     entry = (JSResolvingEntry *)
    1:             JS_DHashTableOperate(table, key, JS_DHASH_ADD);
    1:     if (!entry)
    1:         goto outofmem;
    1: 
    1:     if (entry->flags & flag) {
    1:         /* An entry for (key, flag) exists already -- dampen recursion. */
    1:         entry = NULL;
    1:     } else {
    1:         /* Fill in key if we were the first to add entry, then set flag. */
    1:         if (!entry->key.obj)
    1:             entry->key = *key;
    1:         entry->flags |= flag;
    1:     }
    1:     *entryp = entry;
    1:     return JS_TRUE;
    1: 
    1: outofmem:
    1:     JS_ReportOutOfMemory(cx);
    1:     return JS_FALSE;
    1: }
    1: 
    1: void
    1: js_StopResolving(JSContext *cx, JSResolvingKey *key, uint32 flag,
    1:                  JSResolvingEntry *entry, uint32 generation)
    1: {
    1:     JSDHashTable *table;
    1: 
    1:     /*
    1:      * Clear flag from entry->flags and return early if other flags remain.
    1:      * We must take care to re-lookup entry if the table has changed since
    1:      * it was found by js_StartResolving.
    1:      */
    1:     table = cx->resolvingTable;
    1:     if (!entry || table->generation != generation) {
    1:         entry = (JSResolvingEntry *)
    1:                 JS_DHashTableOperate(table, key, JS_DHASH_LOOKUP);
    1:     }
    1:     JS_ASSERT(JS_DHASH_ENTRY_IS_BUSY(&entry->hdr));
    1:     entry->flags &= ~flag;
    1:     if (entry->flags)
    1:         return;
    1: 
    1:     /*
    1:      * Do a raw remove only if fewer entries were removed than would cause
    1:      * alpha to be less than .5 (alpha is at most .75).  Otherwise, we just
    1:      * call JS_DHashTableOperate to re-lookup the key and remove its entry,
    1:      * compressing or shrinking the table as needed.
    1:      */
    1:     if (table->removedCount < JS_DHASH_TABLE_SIZE(table) >> 2)
    1:         JS_DHashTableRawRemove(table, &entry->hdr);
    1:     else
    1:         JS_DHashTableOperate(table, key, JS_DHASH_REMOVE);
    1: }
    1: 
    1: JSBool
    1: js_EnterLocalRootScope(JSContext *cx)
    1: {
35075:     JSThreadData *td = JS_THREAD_DATA(cx);
35075:     JSLocalRootStack *lrs = td->localRootStack;
    1:     if (!lrs) {
35075:         lrs = (JSLocalRootStack *) js_malloc(sizeof *lrs);
35075:         if (!lrs) {
35075:             js_ReportOutOfMemory(cx);
35075:             return false;
35075:         }
    1:         lrs->scopeMark = JSLRS_NULL_MARK;
    1:         lrs->rootCount = 0;
    1:         lrs->topChunk = &lrs->firstChunk;
    1:         lrs->firstChunk.down = NULL;
35075:         td->gcFreeLists.moveTo(&lrs->gcFreeLists);
35075:         td->localRootStack = lrs;
    1:     }
    1: 
    1:     /* Push lrs->scopeMark to save it for restore when leaving. */
35075:     int mark = js_PushLocalRoot(cx, lrs, INT_TO_JSVAL(lrs->scopeMark));
    1:     if (mark < 0)
    1:         return JS_FALSE;
    1:     lrs->scopeMark = (uint32) mark;
35075:     return true;
    1: }
    1: 
    1: void
    1: js_LeaveLocalRootScopeWithResult(JSContext *cx, jsval rval)
    1: {
    1:     JSLocalRootStack *lrs;
    1:     uint32 mark, m, n;
    1:     JSLocalRootChunk *lrc;
    1: 
    1:     /* Defend against buggy native callers. */
35075:     lrs = JS_THREAD_DATA(cx)->localRootStack;
    1:     JS_ASSERT(lrs && lrs->rootCount != 0);
    1:     if (!lrs || lrs->rootCount == 0)
    1:         return;
    1: 
    1:     mark = lrs->scopeMark;
    1:     JS_ASSERT(mark != JSLRS_NULL_MARK);
    1:     if (mark == JSLRS_NULL_MARK)
    1:         return;
    1: 
    1:     /* Free any chunks being popped by this leave operation. */
    1:     m = mark >> JSLRS_CHUNK_SHIFT;
    1:     n = (lrs->rootCount - 1) >> JSLRS_CHUNK_SHIFT;
    1:     while (n > m) {
    1:         lrc = lrs->topChunk;
    1:         JS_ASSERT(lrc != &lrs->firstChunk);
    1:         lrs->topChunk = lrc->down;
35075:         js_free(lrc);
    1:         --n;
    1:     }
    1: 
    1:     /*
    1:      * Pop the scope, restoring lrs->scopeMark.  If rval is a GC-thing, push
    1:      * it on the caller's scope, or store it in lastInternalResult if we are
    1:      * leaving the outermost scope.  We don't need to allocate a new lrc
    1:      * because we can overwrite the old mark's slot with rval.
    1:      */
    1:     lrc = lrs->topChunk;
    1:     m = mark & JSLRS_CHUNK_MASK;
    1:     lrs->scopeMark = (uint32) JSVAL_TO_INT(lrc->roots[m]);
    1:     if (JSVAL_IS_GCTHING(rval) && !JSVAL_IS_NULL(rval)) {
    1:         if (mark == 0) {
    1:             cx->weakRoots.lastInternalResult = rval;
    1:         } else {
    1:             /*
    1:              * Increment m to avoid the "else if (m == 0)" case below.  If
    1:              * rval is not a GC-thing, that case would take care of freeing
    1:              * any chunk that contained only the old mark.  Since rval *is*
    1:              * a GC-thing here, we want to reuse that old mark's slot.
    1:              */
    1:             lrc->roots[m++] = rval;
    1:             ++mark;
    1:         }
    1:     }
    1:     lrs->rootCount = (uint32) mark;
    1: 
    1:     /*
    1:      * Free the stack eagerly, risking malloc churn.  The alternative would
    1:      * require an lrs->entryCount member, maintained by Enter and Leave, and
    1:      * tested by the GC in addition to the cx->localRootStack non-null test.
    1:      *
    1:      * That approach would risk hoarding 264 bytes (net) per context.  Right
    1:      * now it seems better to give fresh (dirty in CPU write-back cache, and
    1:      * the data is no longer needed) memory back to the malloc heap.
    1:      */
    1:     if (mark == 0) {
35075:         JSThreadData *td = JS_THREAD_DATA(cx);
35075:         JS_ASSERT(td->gcFreeLists.isEmpty());
35075:         lrs->gcFreeLists.moveTo(&td->gcFreeLists);
35075:         td->localRootStack = NULL;
35075:         js_free(lrs);
    1:     } else if (m == 0) {
    1:         lrs->topChunk = lrc->down;
35075:         js_free(lrc);
    1:     }
    1: }
    1: 
    1: void
    1: js_ForgetLocalRoot(JSContext *cx, jsval v)
    1: {
    1:     JSLocalRootStack *lrs;
    1:     uint32 i, j, m, n, mark;
    1:     JSLocalRootChunk *lrc, *lrc2;
    1:     jsval top;
    1: 
35075:     lrs = JS_THREAD_DATA(cx)->localRootStack;
    1:     JS_ASSERT(lrs && lrs->rootCount);
    1:     if (!lrs || lrs->rootCount == 0)
    1:         return;
    1: 
    1:     /* Prepare to pop the top-most value from the stack. */
    1:     n = lrs->rootCount - 1;
    1:     m = n & JSLRS_CHUNK_MASK;
    1:     lrc = lrs->topChunk;
    1:     top = lrc->roots[m];
    1: 
    1:     /* Be paranoid about calls on an empty scope. */
    1:     mark = lrs->scopeMark;
    1:     JS_ASSERT(mark < n);
    1:     if (mark >= n)
    1:         return;
    1: 
    1:     /* If v was not the last root pushed in the top scope, find it. */
    1:     if (top != v) {
    1:         /* Search downward in case v was recently pushed. */
    1:         i = n;
    1:         j = m;
    1:         lrc2 = lrc;
    1:         while (--i > mark) {
    1:             if (j == 0)
    1:                 lrc2 = lrc2->down;
    1:             j = i & JSLRS_CHUNK_MASK;
    1:             if (lrc2->roots[j] == v)
    1:                 break;
    1:         }
    1: 
    1:         /* If we didn't find v in this scope, assert and bail out. */
    1:         JS_ASSERT(i != mark);
    1:         if (i == mark)
    1:             return;
    1: 
    1:         /* Swap top and v so common tail code can pop v. */
    1:         lrc2->roots[j] = top;
    1:     }
    1: 
    1:     /* Pop the last value from the stack. */
    1:     lrc->roots[m] = JSVAL_NULL;
    1:     lrs->rootCount = n;
    1:     if (m == 0) {
    1:         JS_ASSERT(n != 0);
    1:         JS_ASSERT(lrc != &lrs->firstChunk);
    1:         lrs->topChunk = lrc->down;
30851:         cx->free(lrc);
    1:     }
    1: }
    1: 
    1: int
    1: js_PushLocalRoot(JSContext *cx, JSLocalRootStack *lrs, jsval v)
    1: {
    1:     uint32 n, m;
    1:     JSLocalRootChunk *lrc;
    1: 
    1:     n = lrs->rootCount;
    1:     m = n & JSLRS_CHUNK_MASK;
    1:     if (n == 0 || m != 0) {
    1:         /*
    1:          * At start of first chunk, or not at start of a non-first top chunk.
    1:          * Check for lrs->rootCount overflow.
    1:          */
    1:         if ((uint32)(n + 1) == 0) {
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_TOO_MANY_LOCAL_ROOTS);
    1:             return -1;
    1:         }
    1:         lrc = lrs->topChunk;
    1:         JS_ASSERT(n != 0 || lrc == &lrs->firstChunk);
    1:     } else {
    1:         /*
    1:          * After lrs->firstChunk, trying to index at a power-of-two chunk
    1:          * boundary: need a new chunk.
    1:          */
35075:         lrc = (JSLocalRootChunk *) js_malloc(sizeof *lrc);
35075:         if (!lrc) {
35075:             js_ReportOutOfMemory(cx);
    1:             return -1;
35075:         }
    1:         lrc->down = lrs->topChunk;
    1:         lrs->topChunk = lrc;
    1:     }
    1:     lrs->rootCount = n + 1;
    1:     lrc->roots[m] = v;
    1:     return (int) n;
    1: }
    1: 
35075: static void
35075: MarkLocalRoots(JSTracer *trc, JSLocalRootStack *lrs)
    1: {
    1:     uint32 n, m, mark;
    1:     JSLocalRootChunk *lrc;
  583:     jsval v;
    1: 
    1:     n = lrs->rootCount;
    1:     if (n == 0)
    1:         return;
    1: 
    1:     mark = lrs->scopeMark;
    1:     lrc = lrs->topChunk;
    1:     do {
    1:         while (--n > mark) {
    1:             m = n & JSLRS_CHUNK_MASK;
  583:             v = lrc->roots[m];
  583:             JS_ASSERT(JSVAL_IS_GCTHING(v) && v != JSVAL_NULL);
  583:             JS_SET_TRACING_INDEX(trc, "local_root", n);
  771:             js_CallValueTracerIfGCThing(trc, v);
    1:             if (m == 0)
    1:                 lrc = lrc->down;
    1:         }
    1:         m = n & JSLRS_CHUNK_MASK;
    1:         mark = JSVAL_TO_INT(lrc->roots[m]);
    1:         if (m == 0)
    1:             lrc = lrc->down;
    1:     } while (n != 0);
    1:     JS_ASSERT(!lrc);
    1: }
    1: 
    1: static void
36234: ReportError(JSContext *cx, const char *message, JSErrorReport *reportp,
36234:             JSErrorCallback callback, void *userRef)
    1: {
    1:     /*
    1:      * Check the error report, and set a JavaScript-catchable exception
    1:      * if the error is defined to have an associated exception.  If an
    1:      * exception is thrown, then the JSREPORT_EXCEPTION flag will be set
    1:      * on the error report, and exception-aware hosts should ignore it.
    1:      */
    1:     JS_ASSERT(reportp);
36234:     if ((!callback || callback == js_GetErrorMessage) &&
36234:         reportp->errorNumber == JSMSG_UNCAUGHT_EXCEPTION)
    1:         reportp->flags |= JSREPORT_EXCEPTION;
    1: 
    1:     /*
    1:      * Call the error reporter only if an exception wasn't raised.
    1:      *
    1:      * If an exception was raised, then we call the debugErrorHook
    1:      * (if present) to give it a chance to see the error before it
    1:      * propagates out of scope.  This is needed for compatability
    1:      * with the old scheme.
    1:      */
36234:     if (!JS_IsRunning(cx) ||
36234:         !js_ErrorToException(cx, message, reportp, callback, userRef)) {
    1:         js_ReportErrorAgain(cx, message, reportp);
 2433:     } else if (cx->debugHooks->debugErrorHook && cx->errorReporter) {
 2433:         JSDebugErrorHook hook = cx->debugHooks->debugErrorHook;
    1:         /* test local in case debugErrorHook changed on another thread */
    1:         if (hook)
 2433:             hook(cx, message, reportp, cx->debugHooks->debugErrorHookData);
    1:     }
    1: }
    1: 
22652: /* The report must be initially zeroed. */
22652: static void
22652: PopulateReportBlame(JSContext *cx, JSErrorReport *report)
22652: {
22652:     JSStackFrame *fp;
22652: 
22652:     /*
22652:      * Walk stack until we find a frame that is associated with some script
22652:      * rather than a native frame.
22652:      */
22652:     for (fp = js_GetTopStackFrame(cx); fp; fp = fp->down) {
22652:         if (fp->regs) {
22652:             report->filename = fp->script->filename;
22652:             report->lineno = js_FramePCToLineNumber(cx, fp);
22652:             break;
22652:         }
22652:     }
22652: }
22652: 
    1: /*
    1:  * We don't post an exception in this case, since doing so runs into
    1:  * complications of pre-allocating an exception object which required
    1:  * running the Exception class initializer early etc.
    1:  * Instead we just invoke the errorReporter with an "Out Of Memory"
    1:  * type message, and then hope the process ends swiftly.
    1:  */
    1: void
    1: js_ReportOutOfMemory(JSContext *cx)
    1: {
27060: #ifdef JS_TRACER
27060:     /*
27060:      * If we are in a builtin called directly from trace, don't report an
27060:      * error. We will retry in the interpreter instead.
27060:      */
27060:     if (JS_ON_TRACE(cx) && !cx->bailExit)
27060:         return;
27060: #endif
27060: 
    1:     JSErrorReport report;
    1:     JSErrorReporter onError = cx->errorReporter;
    1: 
    1:     /* Get the message for this error, but we won't expand any arguments. */
    1:     const JSErrorFormatString *efs =
    1:         js_GetLocalizedErrorMessage(cx, NULL, NULL, JSMSG_OUT_OF_MEMORY);
    1:     const char *msg = efs ? efs->format : "Out of memory";
    1: 
    1:     /* Fill out the report, but don't do anything that requires allocation. */
    1:     memset(&report, 0, sizeof (struct JSErrorReport));
    1:     report.flags = JSREPORT_ERROR;
    1:     report.errorNumber = JSMSG_OUT_OF_MEMORY;
22652:     PopulateReportBlame(cx, &report);
    1: 
    1:     /*
11758:      * If debugErrorHook is present then we give it a chance to veto sending
11758:      * the error on to the regular ErrorReporter. We also clear a pending
11758:      * exception if any now so the hooks can replace the out-of-memory error
11758:      * by a script-catchable exception.
    1:      */
11758:     cx->throwing = JS_FALSE;
    1:     if (onError) {
 2433:         JSDebugErrorHook hook = cx->debugHooks->debugErrorHook;
    1:         if (hook &&
 2433:             !hook(cx, msg, &report, cx->debugHooks->debugErrorHookData)) {
    1:             onError = NULL;
    1:         }
    1:     }
    1: 
    1:     if (onError)
    1:         onError(cx, msg, &report);
    1: }
    1: 
 8296: void
 8296: js_ReportOutOfScriptQuota(JSContext *cx)
 8296: {
 8296:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 8296:                          JSMSG_SCRIPT_STACK_QUOTA);
 8296: }
 8296: 
 8296: void
 8296: js_ReportOverRecursed(JSContext *cx)
 8296: {
 8296:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_OVER_RECURSED);
 8296: }
 8296: 
12983: void
12983: js_ReportAllocationOverflow(JSContext *cx)
12983: {
12983:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_ALLOC_OVERFLOW);
12983: }
12983: 
35302: /*
35302:  * Given flags and the state of cx, decide whether we should report an
35302:  * error, a warning, or just continue execution normally.  Return
35302:  * true if we should continue normally, without reporting anything;
35302:  * otherwise, adjust *flags as appropriate and return false.
35302:  */
35302: static bool
35302: checkReportFlags(JSContext *cx, uintN *flags)
35302: {
35302:     if (JSREPORT_IS_STRICT_MODE_ERROR(*flags)) {
39322:         /*
39322:          * Error in strict code; warning with strict option; okay otherwise.
39322:          * We assume that if the top frame is a native, then it is strict if
39322:          * the nearest scripted frame is strict, see bug 536306.
39322:          */
39322:         JSStackFrame *fp = js_GetScriptedCaller(cx, NULL);
39322:         if (fp && fp->script->strictModeCode)
35302:             *flags &= ~JSREPORT_WARNING;
35302:         else if (JS_HAS_STRICT_OPTION(cx))
35302:             *flags |= JSREPORT_WARNING;
35302:         else
35302:             return true;
35302:     } else if (JSREPORT_IS_STRICT(*flags)) {
35302:         /* Warning/error only when JSOPTION_STRICT is set. */
35302:         if (!JS_HAS_STRICT_OPTION(cx))
35302:             return true;
35302:     }
35302: 
35302:     /* Warnings become errors when JSOPTION_WERROR is set. */
35302:     if (JSREPORT_IS_WARNING(*flags) && JS_HAS_WERROR_OPTION(cx))
35302:         *flags &= ~JSREPORT_WARNING;
35302: 
35302:     return false;
35302: }
35302: 
    1: JSBool
    1: js_ReportErrorVA(JSContext *cx, uintN flags, const char *format, va_list ap)
    1: {
    1:     char *message;
    1:     jschar *ucmessage;
    1:     size_t messagelen;
    1:     JSErrorReport report;
    1:     JSBool warning;
    1: 
35302:     if (checkReportFlags(cx, &flags))
    1:         return JS_TRUE;
    1: 
    1:     message = JS_vsmprintf(format, ap);
    1:     if (!message)
    1:         return JS_FALSE;
    1:     messagelen = strlen(message);
    1: 
    1:     memset(&report, 0, sizeof (struct JSErrorReport));
    1:     report.flags = flags;
    1:     report.errorNumber = JSMSG_USER_DEFINED_ERROR;
    1:     report.ucmessage = ucmessage = js_InflateString(cx, message, &messagelen);
22652:     PopulateReportBlame(cx, &report);
    1: 
    1:     warning = JSREPORT_IS_WARNING(report.flags);
    1: 
36234:     ReportError(cx, message, &report, NULL, NULL);
30851:     js_free(message);
30851:     cx->free(ucmessage);
    1:     return warning;
    1: }
    1: 
    1: /*
    1:  * The arguments from ap need to be packaged up into an array and stored
    1:  * into the report struct.
    1:  *
    1:  * The format string addressed by the error number may contain operands
    1:  * identified by the format {N}, where N is a decimal digit. Each of these
    1:  * is to be replaced by the Nth argument from the va_list. The complete
    1:  * message is placed into reportp->ucmessage converted to a JSString.
    1:  *
    1:  * Returns true if the expansion succeeds (can fail if out of memory).
    1:  */
    1: JSBool
    1: js_ExpandErrorArguments(JSContext *cx, JSErrorCallback callback,
    1:                         void *userRef, const uintN errorNumber,
    1:                         char **messagep, JSErrorReport *reportp,
35302:                         bool charArgs, va_list ap)
    1: {
    1:     const JSErrorFormatString *efs;
    1:     int i;
    1:     int argCount;
    1: 
    1:     *messagep = NULL;
    1: 
    1:     /* Most calls supply js_GetErrorMessage; if this is so, assume NULL. */
    1:     if (!callback || callback == js_GetErrorMessage)
    1:         efs = js_GetLocalizedErrorMessage(cx, userRef, NULL, errorNumber);
    1:     else
    1:         efs = callback(userRef, NULL, errorNumber);
    1:     if (efs) {
    1:         size_t totalArgsLength = 0;
    1:         size_t argLengths[10]; /* only {0} thru {9} supported */
    1:         argCount = efs->argCount;
    1:         JS_ASSERT(argCount <= 10);
    1:         if (argCount > 0) {
    1:             /*
    1:              * Gather the arguments into an array, and accumulate
    1:              * their sizes. We allocate 1 more than necessary and
    1:              * null it out to act as the caboose when we free the
    1:              * pointers later.
    1:              */
    1:             reportp->messageArgs = (const jschar **)
30851:                 cx->malloc(sizeof(jschar *) * (argCount + 1));
    1:             if (!reportp->messageArgs)
    1:                 return JS_FALSE;
    1:             reportp->messageArgs[argCount] = NULL;
    1:             for (i = 0; i < argCount; i++) {
    1:                 if (charArgs) {
    1:                     char *charArg = va_arg(ap, char *);
    1:                     size_t charArgLength = strlen(charArg);
    1:                     reportp->messageArgs[i]
    1:                         = js_InflateString(cx, charArg, &charArgLength);
    1:                     if (!reportp->messageArgs[i])
    1:                         goto error;
    1:                 } else {
    1:                     reportp->messageArgs[i] = va_arg(ap, jschar *);
    1:                 }
    1:                 argLengths[i] = js_strlen(reportp->messageArgs[i]);
    1:                 totalArgsLength += argLengths[i];
    1:             }
    1:             /* NULL-terminate for easy copying. */
    1:             reportp->messageArgs[i] = NULL;
    1:         }
    1:         /*
    1:          * Parse the error format, substituting the argument X
    1:          * for {X} in the format.
    1:          */
    1:         if (argCount > 0) {
    1:             if (efs->format) {
    1:                 jschar *buffer, *fmt, *out;
    1:                 int expandedArgs = 0;
    1:                 size_t expandedLength;
    1:                 size_t len = strlen(efs->format);
    1: 
    1:                 buffer = fmt = js_InflateString (cx, efs->format, &len);
    1:                 if (!buffer)
    1:                     goto error;
    1:                 expandedLength = len
    1:                                  - (3 * argCount)       /* exclude the {n} */
    1:                                  + totalArgsLength;
    1: 
    1:                 /*
    1:                 * Note - the above calculation assumes that each argument
    1:                 * is used once and only once in the expansion !!!
    1:                 */
    1:                 reportp->ucmessage = out = (jschar *)
30851:                     cx->malloc((expandedLength + 1) * sizeof(jschar));
    1:                 if (!out) {
30851:                     cx->free(buffer);
    1:                     goto error;
    1:                 }
    1:                 while (*fmt) {
    1:                     if (*fmt == '{') {
    1:                         if (isdigit(fmt[1])) {
    1:                             int d = JS7_UNDEC(fmt[1]);
    1:                             JS_ASSERT(d < argCount);
    1:                             js_strncpy(out, reportp->messageArgs[d],
    1:                                        argLengths[d]);
    1:                             out += argLengths[d];
    1:                             fmt += 3;
    1:                             expandedArgs++;
    1:                             continue;
    1:                         }
    1:                     }
    1:                     *out++ = *fmt++;
    1:                 }
    1:                 JS_ASSERT(expandedArgs == argCount);
    1:                 *out = 0;
30851:                 cx->free(buffer);
    1:                 *messagep =
    1:                     js_DeflateString(cx, reportp->ucmessage,
    1:                                      (size_t)(out - reportp->ucmessage));
    1:                 if (!*messagep)
    1:                     goto error;
    1:             }
    1:         } else {
    1:             /*
    1:              * Zero arguments: the format string (if it exists) is the
    1:              * entire message.
    1:              */
    1:             if (efs->format) {
    1:                 size_t len;
    1:                 *messagep = JS_strdup(cx, efs->format);
    1:                 if (!*messagep)
    1:                     goto error;
    1:                 len = strlen(*messagep);
    1:                 reportp->ucmessage = js_InflateString(cx, *messagep, &len);
    1:                 if (!reportp->ucmessage)
    1:                     goto error;
    1:             }
    1:         }
    1:     }
    1:     if (*messagep == NULL) {
    1:         /* where's the right place for this ??? */
    1:         const char *defaultErrorMessage
    1:             = "No error message available for error number %d";
    1:         size_t nbytes = strlen(defaultErrorMessage) + 16;
30851:         *messagep = (char *)cx->malloc(nbytes);
    1:         if (!*messagep)
    1:             goto error;
    1:         JS_snprintf(*messagep, nbytes, defaultErrorMessage, errorNumber);
    1:     }
    1:     return JS_TRUE;
    1: 
    1: error:
    1:     if (reportp->messageArgs) {
    1:         /* free the arguments only if we allocated them */
    1:         if (charArgs) {
    1:             i = 0;
    1:             while (reportp->messageArgs[i])
30851:                 cx->free((void *)reportp->messageArgs[i++]);
    1:         }
30851:         cx->free((void *)reportp->messageArgs);
    1:         reportp->messageArgs = NULL;
    1:     }
    1:     if (reportp->ucmessage) {
30851:         cx->free((void *)reportp->ucmessage);
    1:         reportp->ucmessage = NULL;
    1:     }
    1:     if (*messagep) {
30851:         cx->free((void *)*messagep);
    1:         *messagep = NULL;
    1:     }
    1:     return JS_FALSE;
    1: }
    1: 
    1: JSBool
    1: js_ReportErrorNumberVA(JSContext *cx, uintN flags, JSErrorCallback callback,
    1:                        void *userRef, const uintN errorNumber,
    1:                        JSBool charArgs, va_list ap)
    1: {
    1:     JSErrorReport report;
    1:     char *message;
    1:     JSBool warning;
    1: 
35302:     if (checkReportFlags(cx, &flags))
    1:         return JS_TRUE;
35302:     warning = JSREPORT_IS_WARNING(flags);
    1: 
    1:     memset(&report, 0, sizeof (struct JSErrorReport));
    1:     report.flags = flags;
    1:     report.errorNumber = errorNumber;
22652:     PopulateReportBlame(cx, &report);
    1: 
    1:     if (!js_ExpandErrorArguments(cx, callback, userRef, errorNumber,
35302:                                  &message, &report, charArgs, ap)) {
    1:         return JS_FALSE;
    1:     }
    1: 
36234:     ReportError(cx, message, &report, callback, userRef);
    1: 
    1:     if (message)
30851:         cx->free(message);
    1:     if (report.messageArgs) {
    1:         /*
    1:          * js_ExpandErrorArguments owns its messageArgs only if it had to
    1:          * inflate the arguments (from regular |char *|s).
    1:          */
    1:         if (charArgs) {
    1:             int i = 0;
    1:             while (report.messageArgs[i])
30851:                 cx->free((void *)report.messageArgs[i++]);
    1:         }
30851:         cx->free((void *)report.messageArgs);
    1:     }
    1:     if (report.ucmessage)
30851:         cx->free((void *)report.ucmessage);
    1: 
    1:     return warning;
    1: }
    1: 
    1: JS_FRIEND_API(void)
    1: js_ReportErrorAgain(JSContext *cx, const char *message, JSErrorReport *reportp)
    1: {
    1:     JSErrorReporter onError;
    1: 
    1:     if (!message)
    1:         return;
    1: 
    1:     if (cx->lastMessage)
30851:         js_free(cx->lastMessage);
    1:     cx->lastMessage = JS_strdup(cx, message);
    1:     if (!cx->lastMessage)
    1:         return;
    1:     onError = cx->errorReporter;
    1: 
    1:     /*
    1:      * If debugErrorHook is present then we give it a chance to veto
    1:      * sending the error on to the regular ErrorReporter.
    1:      */
    1:     if (onError) {
 2433:         JSDebugErrorHook hook = cx->debugHooks->debugErrorHook;
    1:         if (hook &&
    1:             !hook(cx, cx->lastMessage, reportp,
 2433:                   cx->debugHooks->debugErrorHookData)) {
    1:             onError = NULL;
    1:         }
    1:     }
    1:     if (onError)
    1:         onError(cx, cx->lastMessage, reportp);
    1: }
    1: 
    1: void
    1: js_ReportIsNotDefined(JSContext *cx, const char *name)
    1: {
    1:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_DEFINED, name);
    1: }
    1: 
    1: JSBool
 7897: js_ReportIsNullOrUndefined(JSContext *cx, intN spindex, jsval v,
 7897:                            JSString *fallback)
 7897: {
 7897:     char *bytes;
 7897:     JSBool ok;
 7897: 
 7897:     bytes = js_DecompileValueGenerator(cx, spindex, v, fallback);
 7897:     if (!bytes)
 7897:         return JS_FALSE;
 7897: 
 7897:     if (strcmp(bytes, js_undefined_str) == 0 ||
 7897:         strcmp(bytes, js_null_str) == 0) {
 7897:         ok = JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR,
 7897:                                           js_GetErrorMessage, NULL,
 7897:                                           JSMSG_NO_PROPERTIES, bytes,
 7897:                                           NULL, NULL);
 7897:     } else if (JSVAL_IS_VOID(v)) {
 7897:         ok = JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR,
 7897:                                           js_GetErrorMessage, NULL,
31844:                                           JSMSG_UNEXPECTED_TYPE, bytes,
 7897:                                           js_undefined_str, NULL);
 7897:     } else {
 7897:         JS_ASSERT(JSVAL_IS_NULL(v));
 7897:         ok = JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR,
 7897:                                           js_GetErrorMessage, NULL,
31844:                                           JSMSG_UNEXPECTED_TYPE, bytes,
 7897:                                           js_null_str, NULL);
 7897:     }
 7897: 
30851:     cx->free(bytes);
 7897:     return ok;
 7897: }
 7897: 
16519: void
16519: js_ReportMissingArg(JSContext *cx, jsval *vp, uintN arg)
16519: {
16519:     char argbuf[11];
16519:     char *bytes;
16519:     JSAtom *atom;
16519: 
16519:     JS_snprintf(argbuf, sizeof argbuf, "%u", arg);
16519:     bytes = NULL;
16519:     if (VALUE_IS_FUNCTION(cx, *vp)) {
16519:         atom = GET_FUNCTION_PRIVATE(cx, JSVAL_TO_OBJECT(*vp))->atom;
16519:         bytes = js_DecompileValueGenerator(cx, JSDVG_SEARCH_STACK, *vp,
16519:                                            ATOM_TO_STRING(atom));
16519:         if (!bytes)
16519:             return;
16519:     }
16519:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
16519:                          JSMSG_MISSING_FUN_ARG, argbuf,
16519:                          bytes ? bytes : "");
30851:     cx->free(bytes);
16519: }
16519: 
 7897: JSBool
    1: js_ReportValueErrorFlags(JSContext *cx, uintN flags, const uintN errorNumber,
    1:                          intN spindex, jsval v, JSString *fallback,
    1:                          const char *arg1, const char *arg2)
    1: {
    1:     char *bytes;
    1:     JSBool ok;
    1: 
    1:     JS_ASSERT(js_ErrorFormatString[errorNumber].argCount >= 1);
    1:     JS_ASSERT(js_ErrorFormatString[errorNumber].argCount <= 3);
    1:     bytes = js_DecompileValueGenerator(cx, spindex, v, fallback);
    1:     if (!bytes)
    1:         return JS_FALSE;
    1: 
    1:     ok = JS_ReportErrorFlagsAndNumber(cx, flags, js_GetErrorMessage,
    1:                                       NULL, errorNumber, bytes, arg1, arg2);
30851:     cx->free(bytes);
    1:     return ok;
    1: }
    1: 
    1: #if defined DEBUG && defined XP_UNIX
    1: /* For gdb usage. */
27233: void js_traceon(JSContext *cx)  { cx->tracefp = stderr; cx->tracePrevPc = NULL; }
    1: void js_traceoff(JSContext *cx) { cx->tracefp = NULL; }
    1: #endif
    1: 
    1: JSErrorFormatString js_ErrorFormatString[JSErr_Limit] = {
    1: #define MSG_DEF(name, number, count, exception, format) \
    1:     { format, count, exception } ,
    1: #include "js.msg"
    1: #undef MSG_DEF
    1: };
    1: 
18727: JS_FRIEND_API(const JSErrorFormatString *)
    1: js_GetErrorMessage(void *userRef, const char *locale, const uintN errorNumber)
    1: {
    1:     if ((errorNumber > 0) && (errorNumber < JSErr_Limit))
    1:         return &js_ErrorFormatString[errorNumber];
    1:     return NULL;
    1: }
    1: 
    1: JSBool
25087: js_InvokeOperationCallback(JSContext *cx)
    1: {
25087:     JS_ASSERT(cx->operationCallbackFlag);
 9780: 
 9780:     /*
25087:      * Reset the callback flag first, then yield. If another thread is racing
25087:      * us here we will accumulate another callback request which will be
25087:      * serviced at the next opportunity.
 9780:      */
25087:     cx->operationCallbackFlag = 0;
25087: 
25087:     /*
27546:      * Unless we are going to run the GC, we automatically yield the current
27546:      * context every time the operation callback is hit since we might be
27546:      * called as a result of an impending GC, which would deadlock if we do
27546:      * not yield. Operation callbacks are supposed to happen rarely (seconds,
27546:      * not milliseconds) so it is acceptable to yield at every callback.
25087:      */
27546:     if (cx->runtime->gcIsNeeded)
27546:         js_GC(cx, GC_NORMAL);
25087: #ifdef JS_THREADSAFE
27546:     else
25087:         JS_YieldRequest(cx);
25087: #endif
25087: 
25087:     JSOperationCallback cb = cx->operationCallback;
25087: 
25087:     /*
25087:      * Important: Additional callbacks can occur inside the callback handler
25087:      * if it re-enters the JS engine. The embedding must ensure that the
25087:      * callback is disconnected before attempting such re-entry.
25087:      */
25087: 
25087:     return !cb || cb(cx);
 9780: }
22652: 
27546: void
27546: js_TriggerAllOperationCallbacks(JSRuntime *rt, JSBool gcLocked)
27546: {
27546:     JSContext *acx, *iter;
27546: #ifdef JS_THREADSAFE
27546:     if (!gcLocked)
27546:         JS_LOCK_GC(rt);
27546: #endif
27546:     iter = NULL;
27546:     while ((acx = js_ContextIterator(rt, JS_FALSE, &iter)))
27546:         JS_TriggerOperationCallback(acx);
27546: #ifdef JS_THREADSAFE
27546:     if (!gcLocked)
27546:         JS_UNLOCK_GC(rt);
27546: #endif
27546: }
27546: 
22652: JSStackFrame *
22652: js_GetScriptedCaller(JSContext *cx, JSStackFrame *fp)
22652: {
22652:     if (!fp)
22652:         fp = js_GetTopStackFrame(cx);
22652:     while (fp) {
22652:         if (fp->script)
22652:             return fp;
22652:         fp = fp->down;
22652:     }
22652:     return NULL;
22652: }
26550: 
26550: jsbytecode*
26550: js_GetCurrentBytecodePC(JSContext* cx)
26550: {
26550:     jsbytecode *pc, *imacpc;
26550: 
26550: #ifdef JS_TRACER
26550:     if (JS_ON_TRACE(cx)) {
26550:         pc = cx->bailExit->pc;
26550:         imacpc = cx->bailExit->imacpc;
26550:     } else
26550: #endif
26550:     {
26550:         JS_ASSERT_NOT_ON_TRACE(cx);  /* for static analysis */
26550:         JSStackFrame* fp = cx->fp;
26550:         if (fp && fp->regs) {
26550:             pc = fp->regs->pc;
26550:             imacpc = fp->imacpc;
26550:         } else {
26550:             return NULL;
26550:         }
26550:     }
26550: 
26550:     /*
26550:      * If we are inside GetProperty_tn or similar, return a pointer to the
26550:      * current instruction in the script, not the CALL instruction in the
26550:      * imacro, for the benefit of callers doing bytecode inspection.
26550:      */
26550:     return (*pc == JSOP_CALL && imacpc) ? imacpc : pc;
26550: }
31911: 
31911: bool
31911: js_CurrentPCIsInImacro(JSContext *cx)
31911: {
31911: #ifdef JS_TRACER
31911:     VOUCH_DOES_NOT_REQUIRE_STACK();
31911:     return (JS_ON_TRACE(cx) ? cx->bailExit->imacpc : cx->fp->imacpc) != NULL;
31911: #else
31911:     return false;
31911: #endif
31911: }
34288: 
34288: void
34288: JSContext::checkMallocGCPressure(void *p)
34288: {
34288:     if (!p) {
34288:         js_ReportOutOfMemory(this);
34288:         return;
34288:     }
34288: 
34288: #ifdef JS_THREADSAFE
34288:     JS_ASSERT(thread->gcThreadMallocBytes <= 0);
34288:     ptrdiff_t n = JS_GC_THREAD_MALLOC_LIMIT - thread->gcThreadMallocBytes;
34288:     thread->gcThreadMallocBytes = JS_GC_THREAD_MALLOC_LIMIT;
34288: 
34288:     JS_LOCK_GC(runtime);
34288:     runtime->gcMallocBytes -= n;
34288:     if (runtime->isGCMallocLimitReached())
34288: #endif
34288:     {
34288:         JS_ASSERT(runtime->isGCMallocLimitReached());
34288:         runtime->gcMallocBytes = -1;
34288: 
34288:         /*
34288:          * Empty the GC free lists to trigger a last-ditch GC when allocating
34288:          * any GC thing later on this thread. This minimizes the amount of
34288:          * checks on the fast path of the GC allocator. Note that we cannot
34288:          * touch the free lists on other threads as their manipulation is not
34288:          * thread-safe.
34288:          */
35075:         JS_THREAD_DATA(this)->purgeGCFreeLists();
34288:         js_TriggerGC(this, true);
34288:     }
34288:     JS_UNLOCK_GC(runtime);
34288: }
37739: 
37739: 
37739: bool
37739: JSContext::isConstructing()
37739: {
37739: #ifdef JS_TRACER
37739:     if (JS_ON_TRACE(this)) {
37739:         JS_ASSERT(bailExit);
37739:         return *bailExit->pc == JSOP_NEW;
37739:     }
37739: #endif
37739:     JSStackFrame *fp = js_GetTopStackFrame(this);
37739:     return fp && (fp->flags & JSFRAME_CONSTRUCTING);
37739: }
38604: 
38604: /*
38604:  * Release pool's arenas if the stackPool has existed for longer than the
38604:  * limit specified by gcEmptyArenaPoolLifespan.
38604:  */
38604: inline void
38604: FreeOldArenas(JSRuntime *rt, JSArenaPool *pool)
38604: {
38604:     JSArena *a = pool->current;
38604:     if (a == pool->first.next && a->avail == a->base + sizeof(int64)) {
38604:         int64 age = JS_Now() - *(int64 *) a->base;
38604:         if (age > int64(rt->gcEmptyArenaPoolLifespan) * 1000)
38604:             JS_FreeArenaPool(pool);
38604:     }
38604: }
38604: 
38604: void
38604: JSContext::purge()
38604: {
38604:     FreeOldArenas(runtime, &stackPool);
38604:     FreeOldArenas(runtime, &regexpPool);
38604:     classProtoCache.purge();
38604: }
