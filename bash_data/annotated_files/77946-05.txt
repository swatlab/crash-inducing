    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: #ifndef nsILineIterator_h___
    1: #define nsILineIterator_h___
    1: 
21112: #include "nscore.h"
21112: #include "nsCoord.h"
    1: 
21112: class nsIFrame;
21112: struct nsRect;
    1: 
    1: // Line Flags (see GetLine below)
    1: 
    1: // This bit is set when the line is wrapping up a block frame. When
    1: // clear, it means that the line contains inline elements.
    1: #define NS_LINE_FLAG_IS_BLOCK           0x1
    1: 
    1: // This bit is set when the line ends in some sort of break.
    1: #define NS_LINE_FLAG_ENDS_IN_BREAK      0x4
    1: 
21112: /**
21112:  * Line iterator API.
21112:  *
21112:  * Lines are numbered from 0 to N, where 0 is the top line and N is
21112:  * the bottom line.
21112:  *
21112:  * Obtain this interface from frames via nsIFrame::GetLineIterator.
21112:  * When you are finished using the iterator, call DisposeLineIterator()
21112:  * to destroy the iterator if appropriate.
21112:  */
21112: class nsILineIterator
21112: {
21112: protected:
21112:   ~nsILineIterator() { }
21112: 
20995: public:
21112:   virtual void DisposeLineIterator() = 0;
20989: 
21112:   /**
21112:    * The number of lines in the block
21112:    */
21112:   virtual PRInt32 GetNumLines() = 0;
    1: 
21112:   /**
21112:    * The prevailing direction of lines.
21112:    *
21112:    * @return PR_TRUE if the CSS direction property for the block is
21112:    *         "rtl", otherwise PR_FALSE
21112:    */
21112:   virtual PRBool GetDirection() = 0;
    1: 
    1:   // Return structural information about a line. aFirstFrameOnLine is
    1:   // the first frame on the line and aNumFramesOnLine is the number of
    1:   // frames that are on the line. If the line-number is invalid then
    1:   // aFirstFrameOnLine will be nsnull and aNumFramesOnLine will be
    1:   // zero.
    1:   //
    1:   // For valid line numbers, aLineBounds is set to the bounding box of
    1:   // the line (which is based on the in-flow position of the frames on
    1:   // the line; if a frame was moved because of relative positioning
    1:   // then its coordinates may be outside the line bounds).
    1:   //
    1:   // In addition, aLineFlags will contain flag information about the
    1:   // line.
    1:   NS_IMETHOD GetLine(PRInt32 aLineNumber,
    1:                      nsIFrame** aFirstFrameOnLine,
    1:                      PRInt32* aNumFramesOnLine,
    1:                      nsRect& aLineBounds,
    1:                      PRUint32* aLineFlags) = 0;
    1: 
21112:   /**
21112:    * Given a frame that's a child of the block, find which line its on
77946:    * and return that line index. Returns -1 if the frame cannot be found.
21112:    */
77946:   virtual PRInt32 FindLineContaining(nsIFrame* aFrame) = 0;
    1: 
    1:   // Given a line number and an X coordinate, find the frame on the
    1:   // line that is nearest to the X coordinate. The
    1:   // aXIsBeforeFirstFrame and aXIsAfterLastFrame flags are updated
    1:   // appropriately.
    1:   NS_IMETHOD FindFrameAt(PRInt32 aLineNumber,
    1:                          nscoord aX,
    1:                          nsIFrame** aFrameFound,
    1:                          PRBool* aXIsBeforeFirstFrame,
    1:                          PRBool* aXIsAfterLastFrame) = 0;
    1: 
    1:   // Give the line iterator implementor a chance todo something more complicated than
    1:   // nsIFrame::GetNextSibling()
    1:   NS_IMETHOD GetNextSiblingOnLine(nsIFrame*& aFrame, PRInt32 aLineNumber) = 0;
    1: 
    1: #ifdef IBMBIDI
    1:   // Check whether visual and logical order of frames within a line are identical.
    1:   //  If not, return the first and last visual frames
    1:   NS_IMETHOD CheckLineOrder(PRInt32                  aLine,
    1:                             PRBool                   *aIsReordered,
    1:                             nsIFrame                 **aFirstVisual,
    1:                             nsIFrame                 **aLastVisual) = 0;
    1: #endif
    1: };
    1: 
21112: class nsAutoLineIterator
21112: {
21112: public:
21112:   nsAutoLineIterator() : mRawPtr(nsnull) { }
21112:   nsAutoLineIterator(nsILineIterator *i) : mRawPtr(i) { }
20995: 
21112:   ~nsAutoLineIterator() {
21112:     if (mRawPtr)
21112:       mRawPtr->DisposeLineIterator();
21112:   }
21112: 
21112:   operator nsILineIterator*() { return mRawPtr; }
21112:   nsILineIterator* operator->() { return mRawPtr; }
21112: 
21112:   nsILineIterator* operator=(nsILineIterator* i) {
21112:     if (i == mRawPtr)
21112:       return i;
21112: 
21112:     if (mRawPtr)
21112:       mRawPtr->DisposeLineIterator();
21112: 
21112:     mRawPtr = i;
21112:     return i;
21112:   }
21112: 
21112: private:
21112:   nsILineIterator* mRawPtr;
    1: };
    1: 
    1: #endif /* nsILineIterator_h___ */
