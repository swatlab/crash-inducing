15273: /* ***** BEGIN LICENSE BLOCK *****
15273:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
15273:  *
15273:  * The contents of this file are subject to the Mozilla Public License Version
15273:  * 1.1 (the "License"); you may not use this file except in compliance with
15273:  * the License. You may obtain a copy of the License at
15273:  * http://www.mozilla.org/MPL/
15273:  *
15273:  * Software distributed under the License is distributed on an "AS IS" basis,
15273:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
15273:  * for the specific language governing rights and limitations under the
15273:  * License.
15273:  *
15273:  * The Original Code is the Netscape security libraries.
15273:  *
15273:  * The Initial Developer of the Original Code is
15273:  * Netscape Communications Corporation.
15273:  * Portions created by the Initial Developer are Copyright (C) 1994-2000
15273:  * the Initial Developer. All Rights Reserved.
15273:  *
15273:  * Contributor(s):
15273:  *
15273:  * Alternatively, the contents of this file may be used under the terms of
15273:  * either the GNU General Public License Version 2 or later (the "GPL"), or
15273:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
15273:  * in which case the provisions of the GPL or the LGPL are applicable instead
15273:  * of those above. If you wish to allow use of your version of this file only
15273:  * under the terms of either the GPL or the LGPL, and not to allow others to
15273:  * use your version of this file under the terms of the MPL, indicate your
15273:  * decision by deleting the provisions above and replace them with the notice
15273:  * and other provisions required by the GPL or the LGPL. If you do not delete
15273:  * the provisions above, a recipient may use your version of this file under
15273:  * the terms of any one of the MPL, the GPL or the LGPL.
15273:  *
15273:  * ***** END LICENSE BLOCK ***** */
15273: 
15273: /*
15273:  * Base64 decoding (ascii to binary).
15273:  *
20768:  * $Id: nssb64d.c,v 1.7 2008/10/05 20:59:26 nelson%bolyard.com Exp $
15273:  */
15273: 
15273: #include "nssb64.h"
15273: #include "nspr.h"
15273: #include "secitem.h"
15273: #include "secerr.h"
15273: 
15273: /*
15273:  * XXX We want this basic support to go into NSPR (the PL part).
15273:  * Until that can happen, the PL interface is going to be kept entirely
15273:  * internal here -- all static functions and opaque data structures.
15273:  * When someone can get it moved over into NSPR, that should be done:
15273:  *    - giving everything names that are accepted by the NSPR module owners
15273:  *	(though I tried to choose ones that would work without modification)
15273:  *    - exporting the functions (remove static declarations and add
20768:  *	to nssutil.def as necessary)
15273:  *    - put prototypes into appropriate header file (probably replacing
15273:  *	the entire current lib/libc/include/plbase64.h in NSPR)
15273:  *	along with a typedef for the context structure (which should be
15273:  *	kept opaque -- definition in the source file only, but typedef
15273:  *	ala "typedef struct PLBase64FooStr PLBase64Foo;" in header file)
15273:  *    - modify anything else as necessary to conform to NSPR required style
15273:  *	(I looked but found no formatting guide to follow)
15273:  *
15273:  * You will want to move over everything from here down to the comment
15273:  * which says "XXX End of base64 decoding code to be moved into NSPR",
15273:  * into a new file in NSPR.
15273:  */
15273: 
15273: /*
15273:  **************************************************************
15273:  * XXX Beginning of base64 decoding code to be moved into NSPR.
15273:  */
15273: 
15273: /*
15273:  * This typedef would belong in the NSPR header file (i.e. plbase64.h).
15273:  */
15273: typedef struct PLBase64DecoderStr PLBase64Decoder;
15273: 
15273: /*
15273:  * The following implementation of base64 decoding was based on code
15273:  * found in libmime (specifically, in mimeenc.c).  It has been adapted to
15273:  * use PR types and naming as well as to provide other necessary semantics
15273:  * (like buffer-in/buffer-out in addition to "streaming" without undue
15273:  * performance hit of extra copying if you made the buffer versions
15273:  * use the output_fn).  It also incorporates some aspects of the current
15273:  * NSPR base64 decoding code.  As such, you may find similarities to
15273:  * both of those implementations.  I tried to use names that reflected
15273:  * the original code when possible.  For this reason you may find some
15273:  * inconsistencies -- libmime used lots of "in" and "out" whereas the
15273:  * NSPR version uses "src" and "dest"; sometimes I changed one to the other
15273:  * and sometimes I left them when I thought the subroutines were at least
15273:  * self-consistent.
15273:  */
15273: 
15273: PR_BEGIN_EXTERN_C
15273: 
15273: /*
15273:  * Opaque object used by the decoder to store state.
15273:  */
15273: struct PLBase64DecoderStr {
15273:     /* Current token (or portion, if token_size < 4) being decoded. */
15273:     unsigned char token[4];
15273:     int token_size;
15273: 
15273:     /*
15273:      * Where to write the decoded data (used when streaming, not when
15273:      * doing all in-memory (buffer) operations).
15273:      *
15273:      * Note that this definition is chosen to be compatible with PR_Write.
15273:      */
15273:     PRInt32 (*output_fn) (void *output_arg, const unsigned char *buf,
15273: 			  PRInt32 size);
15273:     void *output_arg;
15273: 
15273:     /*
15273:      * Where the decoded output goes -- either temporarily (in the streaming
15273:      * case, staged here before it goes to the output function) or what will
15273:      * be the entire buffered result for users of the buffer version.
15273:      */
15273:     unsigned char *output_buffer;
15273:     PRUint32 output_buflen;	/* the total length of allocated buffer */
15273:     PRUint32 output_length;	/* the length that is currently populated */
15273: };
15273: 
15273: PR_END_EXTERN_C
15273: 
15273: 
15273: /*
15273:  * Table to convert an ascii "code" to its corresponding binary value.
15273:  * For ease of use, the binary values in the table are the actual values
15273:  * PLUS ONE.  This is so that the special value of zero can denote an
15273:  * invalid mapping; that was much easier than trying to fill in the other
15273:  * values with some value other than zero, and to check for it.
15273:  * Just remember to SUBTRACT ONE when using the value retrieved.
15273:  */
15273: static unsigned char base64_codetovaluep1[256] = {
15273: /*   0: */	  0,	  0,	  0,	  0,	  0,	  0,	  0,	  0,
15273: /*   8: */	  0,	  0,	  0,	  0,	  0,	  0,	  0,	  0,
15273: /*  16: */	  0,	  0,	  0,	  0,	  0,	  0,	  0,	  0,
15273: /*  24: */	  0,	  0,	  0,	  0,	  0,	  0,	  0,	  0,
15273: /*  32: */	  0,	  0,	  0,	  0,	  0,	  0,	  0,	  0,
15273: /*  40: */	  0,	  0,	  0,	 63,	  0,	  0,	  0,	 64,
15273: /*  48: */	 53,	 54,	 55,	 56,	 57,	 58,	 59,	 60,
15273: /*  56: */	 61,	 62,	  0,	  0,	  0,	  0,	  0,	  0,
15273: /*  64: */	  0,	  1,	  2,	  3,	  4,	  5,	  6,	  7,
15273: /*  72: */	  8,	  9,	 10,	 11,	 12,	 13,	 14,	 15,
15273: /*  80: */	 16,	 17,	 18,	 19,	 20,	 21,	 22,	 23,
15273: /*  88: */	 24,	 25,	 26,	  0,	  0,	  0,	  0,	  0,
15273: /*  96: */	  0,	 27,	 28,	 29,	 30,	 31,	 32,	 33,
15273: /* 104: */	 34,	 35,	 36,	 37,	 38,	 39,	 40,	 41,
15273: /* 112: */	 42,	 43,	 44,	 45,	 46,	 47,	 48,	 49,
15273: /* 120: */	 50,	 51,	 52,	  0,	  0,	  0,	  0,	  0,
15273: /* 128: */	  0,	  0,	  0,	  0,	  0,	  0,	  0,	  0
15273: /* and rest are all zero as well */
15273: };
15273: 
15273: #define B64_PAD	'='
15273: 
15273: 
15273: /*
15273:  * Reads 4; writes 3 (known, or expected, to have no trailing padding).
15273:  * Returns bytes written; -1 on error (unexpected character).
15273:  */
15273: static int
15273: pl_base64_decode_4to3 (const unsigned char *in, unsigned char *out)
15273: {
15273:     int j;
15273:     PRUint32 num = 0;
15273:     unsigned char bits;
15273: 
15273:     for (j = 0; j < 4; j++) {
15273: 	bits = base64_codetovaluep1[in[j]];
15273: 	if (bits == 0)
15273: 	    return -1;
15273: 	num = (num << 6) | (bits - 1);
15273:     }
15273: 
15273:     out[0] = (unsigned char) (num >> 16);
15273:     out[1] = (unsigned char) ((num >> 8) & 0xFF);
15273:     out[2] = (unsigned char) (num & 0xFF);
15273: 
15273:     return 3;
15273: }
15273: 
15273: /*
15273:  * Reads 3; writes 2 (caller already confirmed EOF or trailing padding).
15273:  * Returns bytes written; -1 on error (unexpected character).
15273:  */
15273: static int
15273: pl_base64_decode_3to2 (const unsigned char *in, unsigned char *out)
15273: {
15273:     PRUint32 num = 0;
15273:     unsigned char bits1, bits2, bits3;
15273: 
15273:     bits1 = base64_codetovaluep1[in[0]];
15273:     bits2 = base64_codetovaluep1[in[1]];
15273:     bits3 = base64_codetovaluep1[in[2]];
15273: 
15273:     if ((bits1 == 0) || (bits2 == 0) || (bits3 == 0))
15273: 	return -1;
15273: 
15273:     num = ((PRUint32)(bits1 - 1)) << 10;
15273:     num |= ((PRUint32)(bits2 - 1)) << 4;
15273:     num |= ((PRUint32)(bits3 - 1)) >> 2;
15273: 
15273:     out[0] = (unsigned char) (num >> 8);
15273:     out[1] = (unsigned char) (num & 0xFF);
15273: 
15273:     return 2;
15273: }
15273: 
15273: /*
15273:  * Reads 2; writes 1 (caller already confirmed EOF or trailing padding).
15273:  * Returns bytes written; -1 on error (unexpected character).
15273:  */
15273: static int
15273: pl_base64_decode_2to1 (const unsigned char *in, unsigned char *out)
15273: {
15273:     PRUint32 num = 0;
15273:     unsigned char bits1, bits2;
15273: 
15273:     bits1 = base64_codetovaluep1[in[0]];
15273:     bits2 = base64_codetovaluep1[in[1]];
15273: 
15273:     if ((bits1 == 0) || (bits2 == 0))
15273: 	return -1;
15273: 
15273:     num = ((PRUint32)(bits1 - 1)) << 2;
15273:     num |= ((PRUint32)(bits2 - 1)) >> 4;
15273: 
15273:     out[0] = (unsigned char) num;
15273: 
15273:     return 1;
15273: }
15273: 
15273: /*
15273:  * Reads 4; writes 0-3.  Returns bytes written or -1 on error.
15273:  * (Writes less than 3 only at (presumed) EOF.)
15273:  */
15273: static int
15273: pl_base64_decode_token (const unsigned char *in, unsigned char *out)
15273: {
15273:     if (in[3] != B64_PAD)
15273: 	return pl_base64_decode_4to3 (in, out);
15273: 
15273:     if (in[2] == B64_PAD)
15273: 	return pl_base64_decode_2to1 (in, out);
15273: 
15273:     return pl_base64_decode_3to2 (in, out);
15273: }
15273: 
15273: static PRStatus
15273: pl_base64_decode_buffer (PLBase64Decoder *data, const unsigned char *in,
15273: 			 PRUint32 length)
15273: {
15273:     unsigned char *out = data->output_buffer;
15273:     unsigned char *token = data->token;
15273:     int i, n = 0;
15273: 
15273:     i = data->token_size;
15273:     data->token_size = 0;
15273: 
15273:     while (length > 0) {
15273: 	while (i < 4 && length > 0) {
15273: 	    /*
15273: 	     * XXX Note that the following simply ignores any unexpected
15273: 	     * characters.  This is exactly what the original code in
15273: 	     * libmime did, and I am leaving it.  We certainly want to skip
15273: 	     * over whitespace (we must); this does much more than that.
15273: 	     * I am not confident changing it, and I don't want to slow
15273: 	     * the processing down doing more complicated checking, but
15273: 	     * someone else might have different ideas in the future.
15273: 	     */
15273: 	    if (base64_codetovaluep1[*in] > 0 || *in == B64_PAD)
15273: 		token[i++] = *in;
15273: 	    in++;
15273: 	    length--;
15273: 	}
15273: 
15273: 	if (i < 4) {
15273: 	    /* Didn't get enough for a complete token. */
15273: 	    data->token_size = i;
15273: 	    break;
15273: 	}
15273: 	i = 0;
15273: 
15273: 	PR_ASSERT((out - data->output_buffer + 3) <= data->output_buflen);
15273: 
15273: 	/*
15273: 	 * Assume we are not at the end; the following function only works
15273: 	 * for an internal token (no trailing padding characters) but is
15273: 	 * faster that way.  If it hits an invalid character (padding) it
15273: 	 * will return an error; we break out of the loop and try again
15273: 	 * calling the routine that will handle a final token.
15273: 	 * Note that we intentionally do it this way rather than explicitly
15273: 	 * add a check for padding here (because that would just slow down
15273: 	 * the normal case) nor do we rely on checking whether we have more
15273: 	 * input to process (because that would also slow it down but also
15273: 	 * because we want to allow trailing garbage, especially white space
15273: 	 * and cannot tell that without read-ahead, also a slow proposition).
15273: 	 * Whew.  Understand?
15273: 	 */
15273: 	n = pl_base64_decode_4to3 (token, out);
15273: 	if (n < 0)
15273: 	    break;
15273: 
15273: 	/* Advance "out" by the number of bytes just written to it. */
15273: 	out += n;
15273: 	n = 0;
15273:     }
15273: 
15273:     /*
15273:      * See big comment above, before call to pl_base64_decode_4to3.
15273:      * Here we check if we error'd out of loop, and allow for the case
15273:      * that we are processing the last interesting token.  If the routine
15273:      * which should handle padding characters also fails, then we just
15273:      * have bad input and give up.
15273:      */
15273:     if (n < 0) {
15273: 	n = pl_base64_decode_token (token, out);
15273: 	if (n < 0)
15273: 	    return PR_FAILURE;
15273: 
15273: 	out += n;
15273:     }
15273: 
15273:     /*
15273:      * As explained above, we can get here with more input remaining, but
15273:      * it should be all characters we do not care about (i.e. would be
15273:      * ignored when transferring from "in" to "token" in loop above,
15273:      * except here we choose to ignore extraneous pad characters, too).
15273:      * Swallow it, performing that check.  If we find more characters that
15273:      * we would expect to decode, something is wrong.
15273:      */
15273:     while (length > 0) {
15273: 	if (base64_codetovaluep1[*in] > 0)
15273: 	    return PR_FAILURE;
15273: 	in++;
15273: 	length--;
15273:     }
15273: 
15273:     /* Record the length of decoded data we have left in output_buffer. */
15273:     data->output_length = (PRUint32) (out - data->output_buffer);
15273:     return PR_SUCCESS;
15273: }
15273: 
15273: /*
15273:  * Flush any remaining buffered characters.  Given well-formed input,
15273:  * this will have nothing to do.  If the input was missing the padding
15273:  * characters at the end, though, there could be 1-3 characters left
15273:  * behind -- we will tolerate that by adding the padding for them.
15273:  */
15273: static PRStatus
15273: pl_base64_decode_flush (PLBase64Decoder *data)
15273: {
15273:     int count;
15273: 
15273:     /*
15273:      * If no remaining characters, or all are padding (also not well-formed
15273:      * input, but again, be tolerant), then nothing more to do.  (And, that
15273:      * is considered successful.)
15273:      */
15273:     if (data->token_size == 0 || data->token[0] == B64_PAD)
15273: 	return PR_SUCCESS;
15273: 
15273:     /*
15273:      * Assume we have all the interesting input except for some expected
15273:      * padding characters.  Add them and decode the resulting token.
15273:      */
15273:     while (data->token_size < 4)
15273: 	data->token[data->token_size++] = B64_PAD;
15273: 
15273:     data->token_size = 0;	/* so a subsequent flush call is a no-op */
15273: 
15273:     count = pl_base64_decode_token (data->token,
15273: 				    data->output_buffer + data->output_length);
15273:     if (count < 0)
15273: 	return PR_FAILURE;
15273: 
15273:     /*
15273:      * If there is an output function, call it with this last bit of data.
15273:      * Otherwise we are doing all buffered output, and the decoded bytes
15273:      * are now there, we just need to reflect that in the length.
15273:      */
15273:     if (data->output_fn != NULL) {
15273: 	PRInt32 output_result;
15273: 
15273: 	PR_ASSERT(data->output_length == 0);
15273: 	output_result = data->output_fn (data->output_arg,
15273: 					 data->output_buffer,
15273: 					 (PRInt32) count);
15273: 	if (output_result < 0)
15273: 	    return  PR_FAILURE;
15273:     } else {
15273: 	data->output_length += count;
15273:     }
15273: 
15273:     return PR_SUCCESS;
15273: }
15273: 
15273: 
15273: /*
15273:  * The maximum space needed to hold the output of the decoder given
15273:  * input data of length "size".
15273:  */
15273: static PRUint32
15273: PL_Base64MaxDecodedLength (PRUint32 size)
15273: {
15273:     return ((size * 3) / 4);
15273: }
15273: 
15273: 
15273: /*
15273:  * A distinct internal creation function for the buffer version to use.
15273:  * (It does not want to specify an output_fn, and we want the normal
15273:  * Create function to require that.)  If more common initialization
15273:  * of the decoding context needs to be done, it should be done *here*.
15273:  */
15273: static PLBase64Decoder *
15273: pl_base64_create_decoder (void)
15273: {
15273:     return PR_NEWZAP(PLBase64Decoder);
15273: }
15273: 
15273: /*
15273:  * Function to start a base64 decoding context.
15273:  * An "output_fn" is required; the "output_arg" parameter to that is optional.
15273:  */
15273: static PLBase64Decoder *
15273: PL_CreateBase64Decoder (PRInt32 (*output_fn) (void *, const unsigned char *,
15273: 					      PRInt32),
15273: 			void *output_arg)
15273: {
15273:     PLBase64Decoder *data;
15273: 
15273:     if (output_fn == NULL) {
15273: 	PR_SetError (PR_INVALID_ARGUMENT_ERROR, 0);
15273: 	return NULL;
15273:     }
15273: 
15273:     data = pl_base64_create_decoder ();
15273:     if (data != NULL) {
15273: 	data->output_fn = output_fn;
15273: 	data->output_arg = output_arg;
15273:     }
15273:     return data;
15273: }
15273: 
15273: 
15273: /*
15273:  * Push data through the decoder, causing the output_fn (provided to Create)
15273:  * to be called with the decoded data.
15273:  */
15273: static PRStatus
15273: PL_UpdateBase64Decoder (PLBase64Decoder *data, const char *buffer,
15273: 			PRUint32 size)
15273: {
15273:     PRUint32 need_length;
15273:     PRStatus status;
15273: 
15273:     /* XXX Should we do argument checking only in debug build? */
15273:     if (data == NULL || buffer == NULL || size == 0) {
15273: 	PR_SetError (PR_INVALID_ARGUMENT_ERROR, 0);
15273: 	return PR_FAILURE;
15273:     }
15273: 
15273:     /*
15273:      * How much space could this update need for decoding?
15273:      */
15273:     need_length = PL_Base64MaxDecodedLength (size + data->token_size);
15273: 
15273:     /*
15273:      * Make sure we have at least that much.  If not, (re-)allocate.
15273:      */
15273:     if (need_length > data->output_buflen) {
15273: 	unsigned char *output_buffer = data->output_buffer;
15273: 
15273: 	if (output_buffer != NULL)
15273: 	    output_buffer = (unsigned char *) PR_Realloc(output_buffer,
15273: 							 need_length);
15273: 	else
15273: 	    output_buffer = (unsigned char *) PR_Malloc(need_length);
15273: 
15273: 	if (output_buffer == NULL)
15273: 	    return PR_FAILURE;
15273: 
15273: 	data->output_buffer = output_buffer;
15273: 	data->output_buflen = need_length;
15273:     }
15273: 
15273:     /* There should not have been any leftover output data in the buffer. */
15273:     PR_ASSERT(data->output_length == 0);
15273:     data->output_length = 0;
15273: 
15273:     status = pl_base64_decode_buffer (data, (const unsigned char *) buffer,
15273: 				      size);
15273: 
15273:     /* Now that we have some decoded data, write it. */
15273:     if (status == PR_SUCCESS && data->output_length > 0) {
15273: 	PRInt32 output_result;
15273: 
15273: 	PR_ASSERT(data->output_fn != NULL);
15273: 	output_result = data->output_fn (data->output_arg,
15273: 					 data->output_buffer,
15273: 					 (PRInt32) data->output_length);
15273: 	if (output_result < 0)
15273: 	    status = PR_FAILURE;
15273:     }
15273: 
15273:     data->output_length = 0;
15273:     return status;
15273: }
15273: 
15273: 
15273: /*
15273:  * When you're done decoding, call this to free the data.  If "abort_p"
15273:  * is false, then calling this may cause the output_fn to be called
15273:  * one last time (as the last buffered data is flushed out).
15273:  */
15273: static PRStatus
15273: PL_DestroyBase64Decoder (PLBase64Decoder *data, PRBool abort_p)
15273: {
15273:     PRStatus status = PR_SUCCESS;
15273: 
15273:     /* XXX Should we do argument checking only in debug build? */
15273:     if (data == NULL) {
15273: 	PR_SetError (PR_INVALID_ARGUMENT_ERROR, 0);
15273: 	return PR_FAILURE;
15273:     }
15273: 
15273:     /* Flush out the last few buffered characters. */
15273:     if (!abort_p)
15273: 	status = pl_base64_decode_flush (data);
15273: 
15273:     if (data->output_buffer != NULL)
15273: 	PR_Free(data->output_buffer);
15273:     PR_Free(data);
15273: 
15273:     return status;
15273: }
15273: 
15273: 
15273: /*
15273:  * Perform base64 decoding from an input buffer to an output buffer.
15273:  * The output buffer can be provided (as "dest"); you can also pass in
15273:  * a NULL and this function will allocate a buffer large enough for you,
15273:  * and return it.  If you do provide the output buffer, you must also
15273:  * provide the maximum length of that buffer (as "maxdestlen").
15273:  * The actual decoded length of output will be returned to you in
15273:  * "output_destlen".
15273:  *
15273:  * Return value is NULL on error, the output buffer (allocated or provided)
15273:  * otherwise.
15273:  */
15273: static unsigned char *
15273: PL_Base64DecodeBuffer (const char *src, PRUint32 srclen, unsigned char *dest,
15273: 		       PRUint32 maxdestlen, PRUint32 *output_destlen)
15273: {
15273:     PRUint32 need_length;
15273:     unsigned char *output_buffer = NULL;
15273:     PLBase64Decoder *data = NULL;
15273:     PRStatus status;
15273: 
69345:     PR_ASSERT(srclen > 0);
69345:     if (srclen == 0)
15273: 	return dest;
15273: 
15273:     /*
15273:      * How much space could we possibly need for decoding this input?
15273:      */
15273:     need_length = PL_Base64MaxDecodedLength (srclen);
15273: 
15273:     /*
15273:      * Make sure we have at least that much, if output buffer provided.
15273:      * If no output buffer provided, then we allocate that much.
15273:      */
15273:     if (dest != NULL) {
15273: 	PR_ASSERT(maxdestlen >= need_length);
15273: 	if (maxdestlen < need_length) {
15273: 	    PR_SetError(PR_BUFFER_OVERFLOW_ERROR, 0);
15273: 	    goto loser;
15273: 	}
15273: 	output_buffer = dest;
15273:     } else {
15273: 	output_buffer = (unsigned char *) PR_Malloc(need_length);
15273: 	if (output_buffer == NULL)
15273: 	    goto loser;
15273: 	maxdestlen = need_length;
15273:     }
15273: 
15273:     data = pl_base64_create_decoder();
15273:     if (data == NULL)
15273: 	goto loser;
15273: 
15273:     data->output_buflen = maxdestlen;
15273:     data->output_buffer = output_buffer;
15273: 
15273:     status = pl_base64_decode_buffer (data, (const unsigned char *) src,
15273: 				      srclen);
15273: 
15273:     /*
15273:      * We do not wait for Destroy to flush, because Destroy will also
15273:      * get rid of our decoder context, which we need to look at first!
15273:      */
15273:     if (status == PR_SUCCESS)
15273: 	status = pl_base64_decode_flush (data);
15273: 
15273:     /* Must clear this or Destroy will free it. */
15273:     data->output_buffer = NULL;
15273: 
15273:     if (status == PR_SUCCESS) {
15273: 	*output_destlen = data->output_length;
15273: 	status = PL_DestroyBase64Decoder (data, PR_FALSE);
15273: 	data = NULL;
15273: 	if (status == PR_FAILURE)
15273: 	    goto loser;
15273: 	return output_buffer;
15273:     }
15273: 
15273: loser:
15273:     if (dest == NULL && output_buffer != NULL)
15273: 	PR_Free(output_buffer);
15273:     if (data != NULL)
15273: 	(void) PL_DestroyBase64Decoder (data, PR_TRUE);
15273:     return NULL;
15273: }
15273: 
15273: 
15273: /*
15273:  * XXX End of base64 decoding code to be moved into NSPR.
15273:  ********************************************************
15273:  */
15273: 
15273: /*
15273:  * This is the beginning of the NSS cover functions.  These will
15273:  * provide the interface we want to expose as NSS-ish.  For example,
15273:  * they will operate on our Items, do any special handling or checking
15273:  * we want to do, etc.
15273:  */
15273: 
15273: 
15273: PR_BEGIN_EXTERN_C
15273: 
15273: /*
15273:  * A boring cover structure for now.  Perhaps someday it will include
15273:  * some more interesting fields.
15273:  */
15273: struct NSSBase64DecoderStr {
15273:     PLBase64Decoder *pl_data;
15273: };
15273: 
15273: PR_END_EXTERN_C
15273: 
15273: 
15273: /*
15273:  * Function to start a base64 decoding context.
15273:  */
15273: NSSBase64Decoder *
15273: NSSBase64Decoder_Create (PRInt32 (*output_fn) (void *, const unsigned char *,
15273: 					       PRInt32),
15273: 			 void *output_arg)
15273: {
15273:     PLBase64Decoder *pl_data;
15273:     NSSBase64Decoder *nss_data;
15273: 
15273:     nss_data = PORT_ZNew(NSSBase64Decoder);
15273:     if (nss_data == NULL)
15273: 	return NULL;
15273: 
15273:     pl_data = PL_CreateBase64Decoder (output_fn, output_arg);
15273:     if (pl_data == NULL) {
15273: 	PORT_Free(nss_data);
15273: 	return NULL;
15273:     }
15273: 
15273:     nss_data->pl_data = pl_data;
15273:     return nss_data;
15273: }
15273: 
15273: 
15273: /*
15273:  * Push data through the decoder, causing the output_fn (provided to Create)
15273:  * to be called with the decoded data.
15273:  */
15273: SECStatus
15273: NSSBase64Decoder_Update (NSSBase64Decoder *data, const char *buffer,
15273: 			 PRUint32 size)
15273: {
15273:     PRStatus pr_status;
15273: 
15273:     /* XXX Should we do argument checking only in debug build? */
15273:     if (data == NULL) {
15273: 	PORT_SetError (SEC_ERROR_INVALID_ARGS);
15273: 	return SECFailure;
15273:     }
15273: 
15273:     pr_status = PL_UpdateBase64Decoder (data->pl_data, buffer, size);
15273:     if (pr_status == PR_FAILURE)
15273: 	return SECFailure;
15273: 
15273:     return SECSuccess;
15273: }
15273: 
15273: 
15273: /*
15273:  * When you're done decoding, call this to free the data.  If "abort_p"
15273:  * is false, then calling this may cause the output_fn to be called
15273:  * one last time (as the last buffered data is flushed out).
15273:  */
15273: SECStatus
15273: NSSBase64Decoder_Destroy (NSSBase64Decoder *data, PRBool abort_p)
15273: {
15273:     PRStatus pr_status;
15273: 
15273:     /* XXX Should we do argument checking only in debug build? */
15273:     if (data == NULL) {
15273: 	PORT_SetError (SEC_ERROR_INVALID_ARGS);
15273: 	return SECFailure;
15273:     }
15273: 
15273:     pr_status = PL_DestroyBase64Decoder (data->pl_data, abort_p);
15273: 
15273:     PORT_Free(data);
15273: 
15273:     if (pr_status == PR_FAILURE)
15273: 	return SECFailure;
15273: 
15273:     return SECSuccess;
15273: }
15273: 
15273: 
15273: /*
15273:  * Perform base64 decoding from an ascii string "inStr" to an Item.
15273:  * The length of the input must be provided as "inLen".  The Item
15273:  * may be provided (as "outItemOpt"); you can also pass in a NULL
15273:  * and the Item will be allocated for you.
15273:  *
15273:  * In any case, the data within the Item will be allocated for you.
15273:  * All allocation will happen out of the passed-in "arenaOpt", if non-NULL.
15273:  * If "arenaOpt" is NULL, standard allocation (heap) will be used and
15273:  * you will want to free the result via SECITEM_FreeItem.
15273:  *
15273:  * Return value is NULL on error, the Item (allocated or provided) otherwise.
15273:  */
15273: SECItem *
15273: NSSBase64_DecodeBuffer (PRArenaPool *arenaOpt, SECItem *outItemOpt,
15273: 			const char *inStr, unsigned int inLen)
15273: {
15273:     SECItem *out_item = outItemOpt;
15273:     PRUint32 max_out_len = PL_Base64MaxDecodedLength (inLen);
15273:     PRUint32 out_len;
15273:     void *mark = NULL;
15273:     unsigned char *dummy;
15273: 
15273:     PORT_Assert(outItemOpt == NULL || outItemOpt->data == NULL);
15273: 
15273:     if (arenaOpt != NULL)
15273: 	mark = PORT_ArenaMark (arenaOpt);
15273: 
15273:     out_item = SECITEM_AllocItem (arenaOpt, outItemOpt, max_out_len);
15273:     if (out_item == NULL) {
15273: 	if (arenaOpt != NULL)
15273: 	    PORT_ArenaRelease (arenaOpt, mark);
15273: 	return NULL;
15273:     }
15273: 
15273:     dummy = PL_Base64DecodeBuffer (inStr, inLen, out_item->data,
15273: 				   max_out_len, &out_len);
15273:     if (dummy == NULL) {
15273: 	if (arenaOpt != NULL) {
15273: 	    PORT_ArenaRelease (arenaOpt, mark);
15273: 	    if (outItemOpt != NULL) {
15273: 		outItemOpt->data = NULL;
15273: 		outItemOpt->len = 0;
15273: 	    }
15273: 	} else {
15273: 	    SECITEM_FreeItem (out_item,
15273: 			      (outItemOpt == NULL) ? PR_TRUE : PR_FALSE);
15273: 	}
15273: 	return NULL;
15273:     }
15273: 
15273:     if (arenaOpt != NULL)
15273: 	PORT_ArenaUnmark (arenaOpt, mark);
15273:     out_item->len = out_len;
15273:     return out_item;
15273: }
15273: 
15273: 
15273: /*
15273:  * XXX Everything below is deprecated.  If you add new stuff, put it
15273:  * *above*, not below.
15273:  */
15273: 
15273: /*
15273:  * XXX The following "ATOB" functions are provided for backward compatibility
15273:  * with current code.  They should be considered strongly deprecated.
15273:  * When we can convert all our code over to using the new NSSBase64Decoder_
15273:  * functions defined above, we should get rid of these altogether.  (Remove
15273:  * protoypes from base64.h as well -- actually, remove that file completely).
15273:  * If someone thinks either of these functions provides such a very useful
15273:  * interface (though, as shown, the same functionality can already be
15273:  * obtained by calling NSSBase64_DecodeBuffer directly), fine -- but then
15273:  * that API should be provided with a nice new NSSFoo name and using
15273:  * appropriate types, etc.
15273:  */
15273: 
15273: #include "base64.h"
15273: 
15273: /*
15273: ** Return an PORT_Alloc'd string which is the base64 decoded version
15273: ** of the input string; set *lenp to the length of the returned data.
15273: */
15273: unsigned char *
15273: ATOB_AsciiToData(const char *string, unsigned int *lenp)
15273: {
15273:     SECItem binary_item, *dummy;
15273: 
15273:     binary_item.data = NULL;
15273:     binary_item.len = 0;
15273: 
15273:     dummy = NSSBase64_DecodeBuffer (NULL, &binary_item, string,
15273: 				    (PRUint32) PORT_Strlen(string));
15273:     if (dummy == NULL)
15273: 	return NULL;
15273: 
15273:     PORT_Assert(dummy == &binary_item);
15273: 
15273:     *lenp = dummy->len;
15273:     return dummy->data;
15273: }
15273:  
15273: /*
15273: ** Convert from ascii to binary encoding of an item.
15273: */
15273: SECStatus
15273: ATOB_ConvertAsciiToItem(SECItem *binary_item, char *ascii)
15273: {
15273:     SECItem *dummy;
15273: 
15273:     if (binary_item == NULL) {
15273: 	PORT_SetError (SEC_ERROR_INVALID_ARGS);
15273: 	return SECFailure;
15273:     }
15273: 
15273:     /*
15273:      * XXX Would prefer to assert here if data is non-null (actually,
15273:      * don't need to, just let NSSBase64_DecodeBuffer do it), so as to
15273:      * to catch unintended memory leaks, but callers are not clean in
15273:      * this respect so we need to explicitly clear here to avoid the
15273:      * assert in NSSBase64_DecodeBuffer.
15273:      */
15273:     binary_item->data = NULL;
15273:     binary_item->len = 0;
15273: 
15273:     dummy = NSSBase64_DecodeBuffer (NULL, binary_item, ascii,
15273: 				    (PRUint32) PORT_Strlen(ascii));
15273: 
15273:     if (dummy == NULL)
15273: 	return SECFailure;
15273: 
15273:     return SECSuccess;
15273: }
