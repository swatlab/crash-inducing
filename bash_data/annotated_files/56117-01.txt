54814: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
54814:  * ***** BEGIN LICENSE BLOCK *****
54814:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
54814:  *
54814:  * The contents of this file are subject to the Mozilla Public License Version
54814:  * 1.1 (the "License"); you may not use this file except in compliance with
54814:  * the License. You may obtain a copy of the License at
54814:  * http://www.mozilla.org/MPL/
54814:  *
54814:  * Software distributed under the License is distributed on an "AS IS" basis,
54814:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
54814:  * for the specific language governing rights and limitations under the
54814:  * License.
54814:  *
54814:  * The Original Code is Mozilla Corporation code.
54814:  *
54814:  * The Initial Developer of the Original Code is Mozilla Foundation.
54814:  * Portions created by the Initial Developer are Copyright (C) 2009
54814:  * the Initial Developer. All Rights Reserved.
54814:  *
54814:  * Contributor(s):
54814:  *   Bas Schouten <bschouten@mozilla.com>
54814:  *
54814:  * Alternatively, the contents of this file may be used under the terms of
54814:  * either the GNU General Public License Version 2 or later (the "GPL"), or
54814:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
54814:  * in which case the provisions of the GPL or the LGPL are applicable instead
54814:  * of those above. If you wish to allow use of your version of this file only
54814:  * under the terms of either the GPL or the LGPL, and not to allow others to
54814:  * use your version of this file under the terms of the MPL, indicate your
54814:  * decision by deleting the provisions above and replace them with the notice
54814:  * and other provisions required by the GPL or the LGPL. If you do not delete
54814:  * the provisions above, a recipient may use your version of this file under
54814:  * the terms of any one of the MPL, the GPL or the LGPL.
54814:  *
54814:  * ***** END LICENSE BLOCK ***** */
54814: 
54814: #include "ImageLayerD3D10.h"
54814: #include "gfxImageSurface.h"
54814: #include "yuv_convert.h"
54814: 
54814: namespace mozilla {
54814: namespace layers {
54814: 
54814: using mozilla::MutexAutoLock;
54814: 
54814: ImageContainerD3D10::ImageContainerD3D10(LayerManagerD3D10 *aManager)
54814:   : ImageContainer(aManager)
54814:   , mActiveImageLock("mozilla.layers.ImageContainerD3D10.mActiveImageLock")
54814: {
54814: }
54814: 
54814: already_AddRefed<Image>
54814: ImageContainerD3D10::CreateImage(const Image::Format *aFormats,
54814:                                PRUint32 aNumFormats)
54814: {
54814:   if (!aNumFormats) {
54814:     return nsnull;
54814:   }
54814:   nsRefPtr<Image> img;
54814:   if (aFormats[0] == Image::PLANAR_YCBCR) {
54814:     img = new PlanarYCbCrImageD3D10(static_cast<LayerManagerD3D10*>(mManager));
54814:   } else if (aFormats[0] == Image::CAIRO_SURFACE) {
54814:     img = new CairoImageD3D10(static_cast<LayerManagerD3D10*>(mManager));
54814:   }
54814:   return img.forget();
54814: }
54814: 
54814: void
54814: ImageContainerD3D10::SetCurrentImage(Image *aImage)
54814: {
54814:   MutexAutoLock lock(mActiveImageLock);
54814: 
54814:   mActiveImage = aImage;
54814: }
54814: 
54814: already_AddRefed<Image>
54814: ImageContainerD3D10::GetCurrentImage()
54814: {
54814:   MutexAutoLock lock(mActiveImageLock);
54814: 
54814:   nsRefPtr<Image> retval = mActiveImage;
54814:   return retval.forget();
54814: }
54814: 
54814: already_AddRefed<gfxASurface>
54814: ImageContainerD3D10::GetCurrentAsSurface(gfxIntSize *aSize)
54814: {
54814:   MutexAutoLock lock(mActiveImageLock);
54814:   if (!mActiveImage) {
54814:     return nsnull;
54814:   }
54814: 
54814:   if (mActiveImage->GetFormat() == Image::PLANAR_YCBCR) {
54814:     PlanarYCbCrImageD3D10 *yuvImage =
54814:       static_cast<PlanarYCbCrImageD3D10*>(mActiveImage.get());
54814:     if (yuvImage->HasData()) {
54814:       *aSize = yuvImage->mSize;
54814:     }
54814:   } else if (mActiveImage->GetFormat() == Image::CAIRO_SURFACE) {
54814:     CairoImageD3D10 *cairoImage =
54814:       static_cast<CairoImageD3D10*>(mActiveImage.get());
54814:     *aSize = cairoImage->mSize;
54814:   }
54814: 
54814:   return static_cast<ImageD3D10*>(mActiveImage->GetImplData())->GetAsSurface();
54814: }
54814: 
54814: gfxIntSize
54814: ImageContainerD3D10::GetCurrentSize()
54814: {
54814:   MutexAutoLock lock(mActiveImageLock);
54814:   if (!mActiveImage) {
54814:     return gfxIntSize(0,0);
54814:   }
54814:   if (mActiveImage->GetFormat() == Image::PLANAR_YCBCR) {
54814:     PlanarYCbCrImageD3D10 *yuvImage =
54814:       static_cast<PlanarYCbCrImageD3D10*>(mActiveImage.get());
54814:     if (!yuvImage->HasData()) {
54814:       return gfxIntSize(0,0);
54814:     }
54814:     return yuvImage->mSize;
54814: 
54814:   } else if (mActiveImage->GetFormat() == Image::CAIRO_SURFACE) {
54814:     CairoImageD3D10 *cairoImage =
54814:       static_cast<CairoImageD3D10*>(mActiveImage.get());
54814:     return cairoImage->mSize;
54814:   }
54814: 
54814:   return gfxIntSize(0,0);
54814: }
54814: 
54814: PRBool
54814: ImageContainerD3D10::SetLayerManager(LayerManager *aManager)
54814: {
54814:   // we can't do anything here for now
54814:   return PR_FALSE;
54814: }
54814: 
54814: Layer*
54814: ImageLayerD3D10::GetLayer()
54814: {
54814:   return this;
54814: }
54814: 
54814: void
54814: ImageLayerD3D10::RenderLayer(float aOpacity, const gfx3DMatrix &aTransform)
54814: {
54814:   if (!GetContainer()) {
54814:     return;
54814:   }
54814: 
54814:   nsRefPtr<Image> image = GetContainer()->GetCurrentImage();
54814: 
54814: 
54814:   gfx3DMatrix transform = mTransform * aTransform;
54814:   effect()->GetVariableByName("mLayerTransform")->SetRawValue(&transform._11, 0, 64);
54814:   effect()->GetVariableByName("fLayerOpacity")->AsScalar()->SetFloat(GetOpacity() * aOpacity);
54814: 
54814:   ID3D10EffectTechnique *technique;
54814: 
54814:   if (image->GetFormat() == Image::PLANAR_YCBCR) {
54814:     PlanarYCbCrImageD3D10 *yuvImage =
54814:       static_cast<PlanarYCbCrImageD3D10*>(image.get());
54814: 
54814:     if (!yuvImage->HasData()) {
54814:       return;
54814:     }
54814: 
54814:     // TODO: At some point we should try to deal with mFilter here, you don't
54814:     // really want to use point filtering in the case of NEAREST, since that
54814:     // would also use point filtering for Chroma upsampling. Where most likely
54814:     // the user would only want point filtering for final RGB image upsampling.
54814: 
54814:     technique = effect()->GetTechniqueByName("RenderYCbCrLayer");
54814: 
54814:     effect()->GetVariableByName("tY")->AsShaderResource()->SetResource(yuvImage->mYView);
54814:     effect()->GetVariableByName("tCb")->AsShaderResource()->SetResource(yuvImage->mCbView);
54814:     effect()->GetVariableByName("tCr")->AsShaderResource()->SetResource(yuvImage->mCrView);
54814: 
54814:     effect()->GetVariableByName("vLayerQuad")->AsVector()->SetFloatVector(
54814:       ShaderConstantRectD3D10(
54814:         (float)0,
54814:         (float)0,
54814:         (float)yuvImage->mSize.width,
54814:         (float)yuvImage->mSize.height)
54814:       );
54814:   } else if (image->GetFormat() == Image::CAIRO_SURFACE) {
54814:     CairoImageD3D10 *cairoImage =
54814:       static_cast<CairoImageD3D10*>(image.get());
54814: 
54814:     if (mFilter == gfxPattern::FILTER_NEAREST) {
54814:       technique = effect()->GetTechniqueByName("RenderRGBALayerPremulPoint");
54814:     } else {
54814:       technique = effect()->GetTechniqueByName("RenderRGBALayerPremul");
54814:     }
54814: 
54814:     if (cairoImage->mSRView) {
54814:       effect()->GetVariableByName("tRGB")->AsShaderResource()->SetResource(cairoImage->mSRView);
54814:     }
54814: 
54814:     effect()->GetVariableByName("vLayerQuad")->AsVector()->SetFloatVector(
54814:       ShaderConstantRectD3D10(
54814:         (float)0,
54814:         (float)0,
54814:         (float)cairoImage->mSize.width,
54814:         (float)cairoImage->mSize.height)
54814:       );
54814:   }
54814: 
54814:   technique->GetPassByIndex(0)->Apply(0);
54814:   device()->Draw(4, 0);
54814: }
54814: 
54814: PlanarYCbCrImageD3D10::PlanarYCbCrImageD3D10(mozilla::layers::LayerManagerD3D10* aManager)
54814:   : PlanarYCbCrImage(static_cast<ImageD3D10*>(this))
54814:   , mHasData(PR_FALSE)
54814: {
56117:   mDevice = aManager->device();
54814: }
54814: 
54814: void
54814: PlanarYCbCrImageD3D10::SetData(const PlanarYCbCrImage::Data &aData)
54814: {
54814:   // XXX - For D3D10Ex we really should just copy to systemmem surfaces here.
54814:   // For now, we copy the data
54814:   int width_shift = 0;
54814:   int height_shift = 0;
54814:   if (aData.mYSize.width == aData.mCbCrSize.width &&
54814:       aData.mYSize.height == aData.mCbCrSize.height) {
54814:      // YV24 format
54814:      width_shift = 0;
54814:      height_shift = 0;
54814:      mType = gfx::YV24;
54814:   } else if (aData.mYSize.width / 2 == aData.mCbCrSize.width &&
54814:              aData.mYSize.height == aData.mCbCrSize.height) {
54814:     // YV16 format
54814:     width_shift = 1;
54814:     height_shift = 0;
54814:     mType = gfx::YV16;
54814:   } else if (aData.mYSize.width / 2 == aData.mCbCrSize.width &&
54814:              aData.mYSize.height / 2 == aData.mCbCrSize.height ) {
54814:       // YV12 format
54814:     width_shift = 1;
54814:     height_shift = 1;
54814:     mType = gfx::YV12;
54814:   } else {
54814:     NS_ERROR("YCbCr format not supported");
54814:   }
54814: 
54814:   mData = aData;
54814:   mData.mCbCrStride = mData.mCbCrSize.width = aData.mPicSize.width >> width_shift;
54814:   // Round up the values for width and height to make sure we sample enough data
54814:   // for the last pixel - See bug 590735
54814:   if (width_shift && (aData.mPicSize.width & 1)) {
54814:     mData.mCbCrStride++;
54814:     mData.mCbCrSize.width++;
54814:   }
54814:   mData.mCbCrSize.height = aData.mPicSize.height >> height_shift;
54814:   if (height_shift && (aData.mPicSize.height & 1)) {
54814:       mData.mCbCrSize.height++;
54814:   }
54814:   mData.mYSize = aData.mPicSize;
54814:   mData.mYStride = mData.mYSize.width;
54814: 
54814:   mBuffer = new PRUint8[mData.mCbCrStride * mData.mCbCrSize.height * 2 +
54814:                         mData.mYStride * mData.mYSize.height];
54814:   mData.mYChannel = mBuffer;
54814:   mData.mCbChannel = mData.mYChannel + mData.mYStride * mData.mYSize.height;
54814:   mData.mCrChannel = mData.mCbChannel + mData.mCbCrStride * mData.mCbCrSize.height;
54814: 
54814:   int cbcr_x = aData.mPicX >> width_shift;
54814:   int cbcr_y = aData.mPicY >> height_shift;
54814: 
54814:   for (int i = 0; i < mData.mYSize.height; i++) {
54814:     memcpy(mData.mYChannel + i * mData.mYStride,
54814:            aData.mYChannel + ((aData.mPicY + i) * aData.mYStride) + aData.mPicX,
54814:            mData.mYStride);
54814:   }
54814:   for (int i = 0; i < mData.mCbCrSize.height; i++) {
54814:     memcpy(mData.mCbChannel + i * mData.mCbCrStride,
54814:            aData.mCbChannel + ((cbcr_y + i) * aData.mCbCrStride) + cbcr_x,
54814:            mData.mCbCrStride);
54814:   }
54814:   for (int i = 0; i < mData.mCbCrSize.height; i++) {
54814:     memcpy(mData.mCrChannel + i * mData.mCbCrStride,
54814:            aData.mCrChannel + ((cbcr_y + i) * aData.mCbCrStride) + cbcr_x,
54814:            mData.mCbCrStride);
54814:   }
54814: 
54814:   // Fix picture rect to be correct
54814:   mData.mPicX = mData.mPicY = 0;
54814:   mSize = aData.mPicSize;
54814: 
54814:   AllocateTextures();
54814: 
54814:   mHasData = PR_TRUE;
54814: }
54814: 
54814: void
54814: PlanarYCbCrImageD3D10::AllocateTextures()
54814: {
54814:   D3D10_SUBRESOURCE_DATA dataY;
54814:   D3D10_SUBRESOURCE_DATA dataCb;
54814:   D3D10_SUBRESOURCE_DATA dataCr;
54814:   CD3D10_TEXTURE2D_DESC descY(DXGI_FORMAT_R8_UNORM,
54814:                               mData.mYSize.width,
54814:                               mData.mYSize.height, 1, 1);
54814:   CD3D10_TEXTURE2D_DESC descCbCr(DXGI_FORMAT_R8_UNORM,
54814:                                  mData.mCbCrSize.width,
54814:                                  mData.mCbCrSize.height, 1, 1);
54814: 
54814:   descY.Usage = descCbCr.Usage = D3D10_USAGE_IMMUTABLE;
54814: 
54814:   dataY.pSysMem = mData.mYChannel;
54814:   dataY.SysMemPitch = mData.mYStride;
54814:   dataCb.pSysMem = mData.mCbChannel;
54814:   dataCb.SysMemPitch = mData.mCbCrStride;
54814:   dataCr.pSysMem = mData.mCrChannel;
54814:   dataCr.SysMemPitch = mData.mCbCrStride;
54814: 
56117:   mDevice->CreateTexture2D(&descY, &dataY, getter_AddRefs(mYTexture));
56117:   mDevice->CreateTexture2D(&descCbCr, &dataCb, getter_AddRefs(mCbTexture));
56117:   mDevice->CreateTexture2D(&descCbCr, &dataCr, getter_AddRefs(mCrTexture));
56117:   mDevice->CreateShaderResourceView(mYTexture, NULL, getter_AddRefs(mYView));
56117:   mDevice->CreateShaderResourceView(mCbTexture, NULL, getter_AddRefs(mCbView));
56117:   mDevice->CreateShaderResourceView(mCrTexture, NULL, getter_AddRefs(mCrView));
54814: }
54814: 
54814: already_AddRefed<gfxASurface>
54814: PlanarYCbCrImageD3D10::GetAsSurface()
54814: {
54814:   nsRefPtr<gfxImageSurface> imageSurface =
54814:     new gfxImageSurface(mSize, gfxASurface::ImageFormatRGB24);
54814: 
54814:   // Convert from YCbCr to RGB now
54814:   gfx::ConvertYCbCrToRGB32(mData.mYChannel,
54814:                            mData.mCbChannel,
54814:                            mData.mCrChannel,
54814:                            imageSurface->Data(),
54814:                            0,
54814:                            0,
54814:                            mSize.width,
54814:                            mSize.height,
54814:                            mData.mYStride,
54814:                            mData.mCbCrStride,
54814:                            imageSurface->Stride(),
54814:                            mType);
54814: 
54814:   return imageSurface.forget().get();
54814: }
54814: 
54814: CairoImageD3D10::~CairoImageD3D10()
54814: {
54814: }
54814: 
54814: void
54814: CairoImageD3D10::SetData(const CairoImage::Data &aData)
54814: {
54814:   mSize = aData.mSize;
54814: 
54814:   nsRefPtr<gfxImageSurface> imageSurface;
54814: 
54814:   if (aData.mSurface->GetType() == gfxASurface::SurfaceTypeImage) {
54814:     imageSurface = static_cast<gfxImageSurface*>(aData.mSurface);
54814:   } else {
54814:     imageSurface = new gfxImageSurface(aData.mSize,
54814:                                        gfxASurface::ImageFormatARGB32);
54814:     
54814:     nsRefPtr<gfxContext> context = new gfxContext(imageSurface);
54814:     context->SetSource(aData.mSurface);
54814:     context->SetOperator(gfxContext::OPERATOR_SOURCE);
54814:     context->Paint();
54814:   }
54814: 
54814:   D3D10_SUBRESOURCE_DATA data;
54814:   
54814:   CD3D10_TEXTURE2D_DESC desc(DXGI_FORMAT_B8G8R8A8_UNORM, mSize.width, mSize.height, 1, 1);
54814:   desc.Usage = D3D10_USAGE_IMMUTABLE;
54814:   
54814:   data.pSysMem = imageSurface->Data();
54814:   data.SysMemPitch = imageSurface->Stride();
54814: 
54814:   mManager->device()->CreateTexture2D(&desc, &data, getter_AddRefs(mTexture));
54814:   mManager->device()->CreateShaderResourceView(mTexture, NULL, getter_AddRefs(mSRView));
54814: }
54814: 
54814: already_AddRefed<gfxASurface>
54814: CairoImageD3D10::GetAsSurface()
54814: {
54814:   return nsnull;
54814: }
54814: 
54814: } /* layers */
54814: } /* mozilla */
