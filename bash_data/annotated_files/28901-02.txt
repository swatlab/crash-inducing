 1617: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 1617:  *
 1617:  * ***** BEGIN LICENSE BLOCK *****
 1617:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 1617:  *
 1617:  * The contents of this file are subject to the Mozilla Public License Version
 1617:  * 1.1 (the "License"); you may not use this file except in compliance with
 1617:  * the License. You may obtain a copy of the License at
 1617:  * http://www.mozilla.org/MPL/
 1617:  *
 1617:  * Software distributed under the License is distributed on an "AS IS" basis,
 1617:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 1617:  * for the specific language governing rights and limitations under the
 1617:  * License.
 1617:  *
 1617:  * The Original Code is Mozilla Communicator client code, released
 1617:  * March 31, 1998.
 1617:  *
 1617:  * The Initial Developer of the Original Code is
 1617:  * Netscape Communications Corporation.
 1617:  * Portions created by the Initial Developer are Copyright (C) 1998
 1617:  * the Initial Developer. All Rights Reserved.
 1617:  *
 1617:  * Contributor(s):
 1617:  *   Rob Ginda rginda@netscape.com
 1617:  *   Bob Clary bob@bclary.com
 1617:  *
 1617:  * Alternatively, the contents of this file may be used under the terms of
 1617:  * either the GNU General Public License Version 2 or later (the "GPL"), or
 1617:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 1617:  * in which case the provisions of the GPL or the LGPL are applicable instead
 1617:  * of those above. If you wish to allow use of your version of this file only
 1617:  * under the terms of either the GPL or the LGPL, and not to allow others to
 1617:  * use your version of this file under the terms of the MPL, indicate your
 1617:  * decision by deleting the provisions above and replace them with the notice
 1617:  * and other provisions required by the GPL or the LGPL. If you do not delete
 1617:  * the provisions above, a recipient may use your version of this file under
 1617:  * the terms of any one of the MPL, the GPL or the LGPL.
 1617:  *
 1617:  * ***** END LICENSE BLOCK ***** */
 1617: 
 3403: // Spidermonkey shell now defaults to 1.8, so set the basic version to
 3403: // 1.5 for backwards compatibility.
 3403: 
 3403: if (typeof version != 'undefined')
 3403: {
 3403:   version(150);
 3403: }
 3403: 
 1617: var STATUS = "STATUS: ";
 1617: var VERBOSE = false;
 1617: var SECT_PREFIX = 'Section ';
 1617: var SECT_SUFFIX = ' of test - ';
 1617: var callStack = new Array();
 1617: 
 1879: var gTestfile;
 1879: var gTestPath;
14179: var gTestsuite;
14179: var gTestsubsuite;
 1879: var gDelayTestDriverEnd = false;
 1879: 
 1879: var gTestcases = new Array();
 1879: var gTc = gTestcases.length;
 1879: var BUGNUMBER = '';
 1879: var summary = '';
 1879: var description = '';
 1879: var expected = '';
 1879: var actual = '';
 1879: var msg = '';
 1879: 
 1879: var SECTION = "";
 1879: var VERSION = "";
 1879: var BUGNUMBER = "";
 1879: 
 1879: /*
 1879:  * constant strings
 1879:  */
19475: var GLOBAL = this + '';
 1879: var PASSED = " PASSED! ";
14689: var FAILED = " FAILED! ";
 1879: 
 1879: var DEBUG = false;
 1879: 
 1879: var DESCRIPTION;
 1879: var EXPECTED;
 1879: 
 1879: /*
 1879:  * wrapper for test case constructor that doesn't require the SECTION
 1879:  * argument.
 1879:  */
 1879: 
 1879: function AddTestCase( description, expect, actual ) {
 1879:   new TestCase( SECTION, description, expect, actual );
 1879: }
 1879: 
 1879: /*
 1879:  * Set up test environment.
 1879:  *
 1879:  */
 1879: function startTest() {
 1879:   // print out bugnumber
 1879: 
 1879:   if ( BUGNUMBER ) {
 1879:     print ("BUGNUMBER: " + BUGNUMBER );
 1879:   }
 1879:   if ( typeof version != 'function') {
 1879:     return;
 1879:   }
 1879: 
 1879:   // JavaScript 1.3 is supposed to be compliant ecma version 1.0
 1879:   if ( VERSION == "ECMA_1" ) {
 1879:     version ( "130" );
 1879:   }
 1879:   else if ( VERSION == "JS_1.8"  || gTestsuite == 'js1_8') {
 1879:     version ( "180" );
 1879:   }
 1879:   else if ( VERSION == "JS_1.7"  || gTestsuite == 'js1_7') {
 1879:     version ( "170" );
 1879:   }
 1879:   else if ( VERSION == "JS_1.6"  || gTestsuite == 'js1_6') {
 1879:     version ( "160" );
 1879:   }
 1879:   else if ( VERSION == "JS_1.5"  || gTestsuite == 'js1_5') {
 1879:     version ( "150" );
 1879:   }
 1879:   else if ( VERSION == "JS_1.4"  || gTestsuite == 'js1_4') {
 1879:     version ( "140" );
 1879:   }
 1879:   else if ( VERSION == "JS_1.3"  || gTestsuite == 'js1_3') {
 1879:     version ( "130" );
 1879:   }
 1879:   else if ( VERSION == "JS_1.2"  || gTestsuite == 'js1_2') {
 1879:     version ( "120" );
 1879:   }
 1879:   else if ( VERSION  == "JS_1.1" || gTestsuite == 'js1_1') {
 1879:     version ( "110" );
 1879:   }
 1879: }
 1879: 
 1879: function TestCase(n, d, e, a)
 1879: {
 1879:   this.path = (typeof gTestPath == 'undefined') ?
 1879:     (gTestsuite + '/' + gTestsubsuite + '/' + gTestfile) :
 1879:     gTestPath;
 1879:   this.file = gTestfile;
 1879:   this.name = n;
 1879:   this.description = d;
 1879:   this.expect = e;
 1879:   this.actual = a;
 1879:   this.passed = getTestCaseResult(e, a);
 1879:   this.reason = '';
 1879:   this.bugnumber = typeof(BUGNUMER) != 'undefined' ? BUGNUMBER : '';
 1879:   this.type = (typeof window == 'undefined' ? 'shell' : 'browser');
 1879:   gTestcases[gTc++] = this;
 1879: }
 1879: 
 1879: TestCase.prototype.dump = function () {
 3403:   dump('\njstest: '      + this.path + ' ' +
 1879:        'bug: '         + this.bugnumber + ' ' +
 1879:        'result: '      + (this.passed ? 'PASSED':'FAILED') + ' ' +
 1879:        'type: '        + this.type + ' ' +
 1879:        'description: ' + toPrinted(this.description) + ' ' +
15536: //       'expected: '    + toPrinted(this.expect) + ' ' +
15536: //       'actual: '      + toPrinted(this.actual) + ' ' +
 1879:        'reason: '      + toPrinted(this.reason) + '\n');
 1879: };
 1879: 
 1617: /*
 1617:  * The test driver searches for such a phrase in the test output.
 1617:  * If such phrase exists, it will set n as the expected exit code.
 1617:  */
 1617: function expectExitCode(n)
 1617: {
 1617:   print('--- NOTE: IN THIS TESTCASE, WE EXPECT EXIT CODE ' + n + ' ---');
 1617: }
 1617: 
 1617: /*
 1617:  * Statuses current section of a test
 1617:  */
 1617: function inSection(x)
 1617: {
 1617:   return SECT_PREFIX + x + SECT_SUFFIX;
 1617: }
 1617: 
 1617: /*
 1617:  * Report a failure in the 'accepted' manner
 1617:  */
 1617: function reportFailure (msg)
 1617: {
 1617:   var lines = msg.split ("\n");
 1617:   var l;
 1617:   var funcName = currentFunc();
 1617:   var prefix = (funcName) ? "[reported from " + funcName + "] ": "";
 1617:    
 1617:   for (var i=0; i<lines.length; i++)
 1617:     print (FAILED + prefix + lines[i]);
 1617: }
 1617: 
 1617: /*
 1617:  * Print a non-failure message.
 1617:  */
 1617: function printStatus (msg)
 1617: {
 1617: /* js1_6 had...
 1617:    msg = String(msg);
 1617:    msg = msg.toString();
 1617: */
 1617:   msg = msg.toString();
 1617:   var lines = msg.split ("\n");
 1617:   var l;
 1617: 
 1617:   for (var i=0; i<lines.length; i++)
 1617:     print (STATUS + lines[i]);
 1617: }
 1617: 
 1617: /*
 1617:  * Print a bugnumber message.
 1617:  */
 1617: function printBugNumber (num)
 1617: {
 1879:   BUGNUMBER = num;
 1879:   print ('BUGNUMBER: ' + num);
 1879: }
 1617: 
 1879: function toPrinted(value)
 1879: {
 1879:   if (typeof value == "xml") 
 1879:   {
 1879:     value = value.toXMLString();
 1879:   } 
 1879:   else 
 1879:   {
 1879:     value = String(value);
 1879:   }
15626:   value = value.replace(/\\n/g, 'NL')
15626:                .replace(/\n/g, 'NL')
15626:                .replace(/\\r/g, 'CR')
15626:                .replace(/[^\x20-\x7E]+/g, escapeString);
 1879:   return value;
 1617: }
 1617: 
15626: function escapeString (str)
15626: {
15626:   var a, b, c, d;
15626:   var len = str.length;
15626:   var result = "";
15626:   var digits = ["0", "1", "2", "3", "4", "5", "6", "7",
15626:                 "8", "9", "A", "B", "C", "D", "E", "F"];
15626: 
15626:   for (var i=0; i<len; i++)
15626:   {
15626:     var ch = str.charCodeAt(i);
15626: 
15626:     a = digits[ch & 0xf];
15626:     ch >>= 4;
15626:     b = digits[ch & 0xf];
15626:     ch >>= 4;
15626: 
15626:     if (ch)
15626:     {
15626:       c = digits[ch & 0xf];
15626:       ch >>= 4;
15626:       d = digits[ch & 0xf];
15626: 
15626:       result += "\\u" + d + c + b + a;
15626:     }
15626:     else
15626:     {
15626:       result += "\\x" + b + a;
15626:     }
15626:   }
15626: 
15626:   return result;
15626: }
15626: 
 1617: /*
28901:  * assertEq(actual, expected)
28901:  *           Throw if the two arguments are not ===
28901:  * see https://bugzilla.mozilla.org/show_bug.cgi?id=480199
28901:  */
28901: if (typeof assertEq == 'undefined')
28901: {
28901:   var assertEq =
28901:     function (actual, expected)
28901:     {
28901:       if (actual !== expected)
28901:       {
28901:         throw new TypeError('Assertion failed: got "' + actual + '", expected "' + expected);
28901:       }
28901:     };
28901: }
28901: 
28901: /*
 1617:  * Compare expected result to actual result, if they differ (in value and/or
 1617:  * type) report a failure.  If description is provided, include it in the
 1617:  * failure report.
 1617:  */
 2140: function reportCompare (expected, actual, description) {
 1617:   var expected_t = typeof expected;
 1617:   var actual_t = typeof actual;
 1617:   var output = "";
 1617: 
15626:   if (typeof description == "undefined")
15626:   {
15626:     description = '';
15626:   }
15626:   else if (VERBOSE)
15626:   {
 1617:     printStatus ("Comparing '" + description + "'");
15626:   }
 1617: 
 1617:   if (expected_t != actual_t)
 1879:   {
 1617:     output += "Type mismatch, expected type " + expected_t +
 1879:       ", actual type " + actual_t + " ";
 1879:   }
 1617:   else if (VERBOSE)
 1879:   {
 2140:     printStatus ("Expected type '" + expected_t + "' matched actual " +
 2140:                  "type '" + actual_t + "'");
 1879:   }
 1617: 
 1617:   if (expected != actual)
 1879:   {
 1879:     output += "Expected value '" + toPrinted(expected) +
 1879:       "', Actual value '" + toPrinted(actual) + "' ";
 1879:   }
 1617:   else if (VERBOSE)
 1879:   {
 2140:     printStatus ("Expected value '" + toPrinted(expected) +
 2140:                  "' matched actual value '" + toPrinted(actual) + "'");
 1879:   }
 1617: 
 1879:   var testcase = new TestCase(gTestfile, description, expected, actual);
 1879:   testcase.reason = output;
 1879: 
 1879:   if (testcase.passed)
 1617:   {
15626:     print(PASSED + description);
 1617:   }
 1617:   else
 1617:   {
15626:     reportFailure (description + " : " + output);
 1617:   }
 1617: 
 1879:   return testcase.passed;
 1617: }
 1617: 
 1617: /*
 2140:  * Attempt to match a regular expression describing the result to
 2140:  * the actual result, if they differ (in value and/or
 2140:  * type) report a failure.  If description is provided, include it in the
 2140:  * failure report.
 2140:  */
 2140: function reportMatch (expectedRegExp, actual, description) {
 2140:   var expected_t = "string";
 2140:   var actual_t = typeof actual;
 2140:   var output = "";
 2140: 
15626:   if (typeof description == "undefined")
15626:   {
15626:     description = '';
15626:   }
15626:   else if (VERBOSE)
15626:   {
 2140:     printStatus ("Comparing '" + description + "'");
15626:   }
 2140: 
 2140:   if (expected_t != actual_t)
 2140:   {
 2140:     output += "Type mismatch, expected type " + expected_t +
 2140:       ", actual type " + actual_t + " ";
 2140:   }
 2140:   else if (VERBOSE)
 2140:   {
 2140:     printStatus ("Expected type '" + expected_t + "' matched actual " +
 2140:                  "type '" + actual_t + "'");
 2140:   }
 2140: 
 2140:   var matches = expectedRegExp.test(actual);
 2140:   if (!matches)
 2140:   {
 2140:     output += "Expected match to '" + toPrinted(expectedRegExp) +
 2140:       "', Actual value '" + toPrinted(actual) + "' ";
 2140:   }
 2140:   else if (VERBOSE)
 2140:   {
 2140:     printStatus ("Expected match to '" + toPrinted(expectedRegExp) +
 2140:                  "' matched actual value '" + toPrinted(actual) + "'");
 2140:   }
 2140: 
 2140:   var testcase = new TestCase(gTestfile, description, true, matches);
 2140:   testcase.reason = output;
 2140: 
 2140:   if (testcase.passed)
 2140:   {
15626:     print(PASSED + description);
 2140:   }
 2140:   else
 2140:   {
15626:     reportFailure (description + " : " + output);
 2140:   }
 2140: 
 2140:   return testcase.passed;
 2140: }
 2140: 
 2140: /*
 1617:  * Puts funcName at the top of the call stack.  This stack is used to show
 1617:  * a function-reported-from field when reporting failures.
 1617:  */
 1617: function enterFunc (funcName)
 1617: {
 1617:   if (!funcName.match(/\(\)$/))
 1617:     funcName += "()";
 1617: 
 1617:   callStack.push(funcName);
 1617: }
 1617: 
 1617: /*
 1617:  * Pops the top funcName off the call stack.  funcName is optional, and can be
 1617:  * used to check push-pop balance.
 1617:  */
 1617: function exitFunc (funcName)
 1617: {
 1617:   var lastFunc = callStack.pop();
 1617:    
 1617:   if (funcName)
 1617:   {
 1617:     if (!funcName.match(/\(\)$/))
 1617:       funcName += "()";
 1617: 
 1617:     if (lastFunc != funcName)
 1879:       reportCompare(funcName, lastFunc, "Test driver failure wrong exit function ");
 1617:   }
 1617: }
 1617: 
 1617: /*
 1617:  * Peeks at the top of the call stack.
 1617:  */
 1617: function currentFunc()
 1617: {
 1617:   return callStack[callStack.length - 1];
 1617: }
 1617: 
 1617: /*
 1617:   Calculate the "order" of a set of data points {X: [], Y: []}
 1617:   by computing successive "derivatives" of the data until
 1617:   the data is exhausted or the derivative is linear.
 1617: */
 1617: function BigO(data)
 1617: {
 1617:   var order = 0;
 1617:   var origLength = data.X.length;
 1617: 
 1617:   while (data.X.length > 2)
 1617:   {
 1617:     var lr = new LinearRegression(data);
 1617:     if (lr.b > 1e-6)
 1617:     {
 1617:       // only increase the order if the slope
 1617:       // is "great" enough
 1617:       order++;
 1617:     }
 1617: 
 1617:     if (lr.r > 0.98 || lr.Syx < 1 || lr.b < 1e-6)
 1617:     {
 1617:       // terminate if close to a line lr.r
 1617:       // small error lr.Syx
 1617:       // small slope lr.b
 1617:       break;
 1617:     }
 1617:     data = dataDeriv(data);
 1617:   }
 1617: 
 1617:   if (2 == origLength - order)
 1617:   {
 1617:     order = Number.POSITIVE_INFINITY;
 1617:   }
 1617:   return order;
 1617: 
 1617:   function LinearRegression(data)
 1617:   {
 1617:     /*
 1617:       y = a + bx
 1617:       for data points (Xi, Yi); 0 <= i < n
 1617: 
 1617:       b = (n*SUM(XiYi) - SUM(Xi)*SUM(Yi))/(n*SUM(Xi*Xi) - SUM(Xi)*SUM(Xi))
 1617:       a = (SUM(Yi) - b*SUM(Xi))/n
 1617:     */
 1617:     var i;
 1617: 
 1617:     if (data.X.length != data.Y.length)
 1617:     {
 1617:       throw 'LinearRegression: data point length mismatch';
 1617:     }
 1617:     if (data.X.length < 3)
 1617:     {
 1617:       throw 'LinearRegression: data point length < 2';
 1617:     }
 1617:     var n = data.X.length;
 1617:     var X = data.X;
 1617:     var Y = data.Y;
 1617: 
 1617:     this.Xavg = 0;
 1617:     this.Yavg = 0;
 1617: 
 1617:     var SUM_X  = 0;
 1617:     var SUM_XY = 0;
 1617:     var SUM_XX = 0;
 1617:     var SUM_Y  = 0;
 1617:     var SUM_YY = 0;
 1617: 
 1617:     for (i = 0; i < n; i++)
 1617:     {
 1617:       SUM_X  += X[i];
 1617:       SUM_XY += X[i]*Y[i];
 1617:       SUM_XX += X[i]*X[i];
 1617:       SUM_Y  += Y[i];
 1617:       SUM_YY += Y[i]*Y[i];
 1617:     }
 1617: 
 1617:     this.b = (n * SUM_XY - SUM_X * SUM_Y)/(n * SUM_XX - SUM_X * SUM_X);
 1617:     this.a = (SUM_Y - this.b * SUM_X)/n;
 1617: 
 1617:     this.Xavg = SUM_X/n;
 1617:     this.Yavg = SUM_Y/n;
 1617: 
 1617:     var SUM_Ydiff2 = 0;
 1617:     var SUM_Xdiff2 = 0;
 1617:     var SUM_XdiffYdiff = 0;
 1617: 
 1617:     for (i = 0; i < n; i++)
 1617:     {
 1617:       var Ydiff = Y[i] - this.Yavg;
 1617:       var Xdiff = X[i] - this.Xavg;
 1617:        
 1617:       SUM_Ydiff2 += Ydiff * Ydiff;
 1617:       SUM_Xdiff2 += Xdiff * Xdiff;
 1617:       SUM_XdiffYdiff += Xdiff * Ydiff;
 1617:     }
 1617: 
 1617:     var Syx2 = (SUM_Ydiff2 - Math.pow(SUM_XdiffYdiff/SUM_Xdiff2, 2))/(n - 2);
 1617:     var r2   = Math.pow((n*SUM_XY - SUM_X * SUM_Y), 2) /
 1617:       ((n*SUM_XX - SUM_X*SUM_X)*(n*SUM_YY-SUM_Y*SUM_Y));
 1617: 
 1617:     this.Syx = Math.sqrt(Syx2);
 1617:     this.r = Math.sqrt(r2);
 1617: 
 1617:   }
 1617: 
 1617:   function dataDeriv(data)
 1617:   {
 1617:     if (data.X.length != data.Y.length)
 1617:     {
 1617:       throw 'length mismatch';
 1617:     }
 1617:     var length = data.X.length;
 1617: 
 1617:     if (length < 2)
 1617:     {
 1617:       throw 'length ' + length + ' must be >= 2';
 1617:     }
 1617:     var X = data.X;
 1617:     var Y = data.Y;
 1617: 
 1617:     var deriv = {X: [], Y: [] };
 1617: 
 1617:     for (var i = 0; i < length - 1; i++)
 1617:     {
 1617:       deriv.X[i] = (X[i] + X[i+1])/2;
 1617:       deriv.Y[i] = (Y[i+1] - Y[i])/(X[i+1] - X[i]);
 1617:     } 
 1617:     return deriv;
 1617:   }
 1617: 
14179:   return 0;
 1617: }
 1617: 
 1617: function compareSource(expect, actual, summary)
 1617: {
 1617:   // compare source
 1617:   var expectP = expect.
 1617:     replace(/([(){},.:\[\]])/mg, ' $1 ').
 1617:     replace(/(\w+)/mg, ' $1 ').
 1617:     replace(/<(\/)? (\w+) (\/)?>/mg, '<$1$2$3>').
 1617:     replace(/\s+/mg, ' ').
 1617:     replace(/new (\w+)\s*\(\s*\)/mg, 'new $1');
 1617: 
 1617:   var actualP = actual.
 1617:     replace(/([(){},.:\[\]])/mg, ' $1 ').
 1617:     replace(/(\w+)/mg, ' $1 ').
 1617:     replace(/<(\/)? (\w+) (\/)?>/mg, '<$1$2$3>').
 1617:     replace(/\s+/mg, ' ').
 1617:     replace(/new (\w+)\s*\(\s*\)/mg, 'new $1');
 1617: 
 1617:   print('expect:\n' + expectP);
 1617:   print('actual:\n' + actualP);
 1617: 
 1617:   reportCompare(expectP, actualP, summary);
 1617: 
 1617:   // actual must be compilable if expect is?
 1617:   try
 1617:   {
 1617:     var expectCompile = 'No Error';
 1617:     var actualCompile;
 1617: 
 1617:     eval(expect);
 1617:     try
 1617:     {
 1617:       eval(actual);
 1617:       actualCompile = 'No Error';
 1617:     }
 1617:     catch(ex1)
 1617:     {
 1617:       actualCompile = ex1 + '';
 1617:     }
 1617:     reportCompare(expectCompile, actualCompile,
 1617:                   summary + ': compile actual');
 1617:   }
 1617:   catch(ex)
 1617:   {
 1617:   }
 1617: }
 1617: 
 1617: function optionsInit() {
 1617: 
 1617:   // record initial values to support resetting
 1617:   // options to their initial values
 1617:   options.initvalues  = {};
 1617: 
 1617:   // record values in a stack to support pushing
 1617:   // and popping options
 1617:   options.stackvalues = [];
 1617: 
 1617:   var optionNames = options().split(',');
 1617: 
 1617:   for (var i = 0; i < optionNames.length; i++)
 1617:   {
 1617:     var optionName = optionNames[i];
 1617:     if (optionName)
 1617:     {
 1617:       options.initvalues[optionName] = '';
 1617:     }
 1617:   }
 1617: }
 1617: 
 1617: function optionsClear() {
 1617:        
 1617:   // turn off current settings
 1617:   var optionNames = options().split(',');
 1617:   for (var i = 0; i < optionNames.length; i++)
 1617:   {
 1617:     var optionName = optionNames[i];
 1617:     if (optionName)
 1617:     {
 1617:       options(optionName);
 1617:     }
 1617:   }
 1617: }
 1617: 
 1617: function optionsPush()
 1617: {
 1617:   var optionsframe = {};
 1617: 
 1617:   options.stackvalues.push(optionsframe);
 1617: 
 1617:   var optionNames = options().split(',');
 1617: 
 1617:   for (var i = 0; i < optionNames.length; i++)
 1617:   {
 1617:     var optionName = optionNames[i];
 1617:     if (optionName)
 1617:     {
 1617:       optionsframe[optionName] = '';
 1617:     }
 1617:   }
 1617: 
 1617:   optionsClear();
 1617: }
 1617: 
 1617: function optionsPop()
 1617: {
 1617:   var optionsframe = options.stackvalues.pop();
 1617: 
 1617:   optionsClear();
 1617: 
 1617:   for (optionName in optionsframe)
 1617:   {
 1617:     options(optionName);
 1617:   }
 1617: 
 1617: }
 1617: 
 1617: function optionsReset() {
 1617: 
25326:   try
25326:   {
 1617:     optionsClear();
 1617: 
 1617:     // turn on initial settings
 1617:     for (optionName in options.initvalues)
 1617:     {
 1617:       options(optionName);
 1617:     }
 1617:   }
25326:   catch(ex)
25326:   {
25326:     print('optionsReset: caught ' + ex);
25326:   }
25326: 
25326: }
 1617: 
 1617: if (typeof options == 'function')
 1617: {
 1617:   optionsInit();
 1617:   optionsClear();
 1617: }
 1879: 
 1879: function getTestCaseResult(expected, actual)
 1879: {
22025:   if (typeof expected != typeof actual)
22025:     return false;
22025:   if (typeof expected != 'number')
22025:     // Note that many tests depend on the use of '==' here, not '==='.
22025:     return actual == expected;
 1879: 
22025:   // Distinguish NaN from other values.  Using x != x comparisons here
22025:   // works even if tests redefine isNaN.
 1879:   if (actual != actual)
22025:     return expected != expected;
 1879:   if (expected != expected)
22025:     return false;
 1879: 
22025:   // Tolerate a certain degree of error.
22025:   if (actual != expected)
22025:     return Math.abs(actual - expected) <= 1E-10;
 1879: 
22025:   // Here would be a good place to distinguish 0 and -0, if we wanted
22025:   // to.  However, doing so would introduce a number of failures in
22025:   // areas where they don't seem important.  For example, the WeekDay
22025:   // function in ECMA-262 returns -0 for Sundays before the epoch, but
22025:   // the Date functions in SpiderMonkey specified in terms of WeekDay
22025:   // often don't.  This seems unimportant.
22025:   return true;
 1879: }
 1879: 
 1879: if (typeof dump == 'undefined')
 1879: {
 1879:   if (typeof window == 'undefined' &&
 1879:       typeof print == 'function')
 1879:   {
 1879:     dump = print;
 1879:   }
 1879:   else
 1879:   {
 1879:     dump = (function () {});
 1879:   }
 1879: }
 1879: 
 1879: function test() {
 1879:   for ( gTc=0; gTc < gTestcases.length; gTc++ ) {
 1879:     // temporary hack to work around some unknown issue in 1.7
 1879:     try
 1879:     {
 1879:       gTestcases[gTc].passed = writeTestCaseResult(
 1879:         gTestcases[gTc].expect,
 1879:         gTestcases[gTc].actual,
 1879:         gTestcases[gTc].description +" = "+ gTestcases[gTc].actual );
 1879:       gTestcases[gTc].reason += ( gTestcases[gTc].passed ) ? "" : "wrong value ";
 1879:     }
 1879:     catch(e)
 1879:     {
 1879:       print('test(): empty testcase for gTc = ' + gTc + ' ' + e);
 1879:     }
 1879:   }
 1879:   stopTest();
 1879:   return ( gTestcases );
 1879: }
 1879: 
 1879: /*
 1879:  * Begin printing functions.  These functions use the shell's
 1879:  * print function.  When running tests in the browser, these
 1879:  * functions, override these functions with functions that use
 1879:  * document.write.
 1879:  */
 1879: 
 1879: function writeTestCaseResult( expect, actual, string ) {
 1879:   var passed = getTestCaseResult( expect, actual );
 1879:   writeFormattedResult( expect, actual, string, passed );
 1879:   return passed;
 1879: }
 1879: function writeFormattedResult( expect, actual, string, passed ) {
14689:   var s = ( passed ? PASSED : FAILED ) + string + ' expected: ' + expect;
 1879:   print(s);
 1879:   return passed;
 1879: }
 1879: 
 1879: function writeHeaderToLog( string ) {
 1879:   print( string );
 1879: }
 1879: /* end of print functions */
 1879: 
 1879: 
 1879: /*
 1879:  * When running in the shell, run the garbage collector after the
 1879:  * test has completed.
 1879:  */
 1879: 
 1879: function stopTest() {
 1879:   var gc;
 1879:   if ( gc != undefined ) {
 1879:     gc();
 1879:   }
 1879: }
 1879: 
 1879: /*
 1879:  * Convenience function for displaying failed test cases.  Useful
 1879:  * when running tests manually.
 1879:  *
 1879:  */
 1879: function getFailedCases() {
 1879:   for ( var i = 0; i < gTestcases.length; i++ ) {
 1879:     if ( ! gTestcases[i].passed ) {
 1879:       print( gTestcases[i].description + " = " +gTestcases[i].actual +
 1879:              " expected: " + gTestcases[i].expect );
 1879:     }
 1879:   }
 1879: }
 1879: 
 1879: function jsTestDriverEnd()
 1879: {
 1879:   // gDelayTestDriverEnd is used to
 1879:   // delay collection of the test result and
 1879:   // signal to Spider so that tests can continue
 1879:   // to run after page load has fired. They are
 1879:   // responsible for setting gDelayTestDriverEnd = true
 1879:   // then when completed, setting gDelayTestDriverEnd = false
 1879:   // then calling jsTestDriverEnd()
 1879: 
 1879:   if (gDelayTestDriverEnd)
 1879:   {
 1879:     return;
 1879:   }
 1879: 
 1879:   try
 1879:   {
 1879:     optionsReset();
 1879:   }
 1879:   catch(ex)
 1879:   {
 1879:     dump('jsTestDriverEnd ' + ex);
 1879:   }
 1879: 
 1879:   for (var i = 0; i < gTestcases.length; i++)
 1879:   {
 1879:     gTestcases[i].dump();
 1879:   }
 1879: 
 1879: }
 1879: 
19318: function jit(on)
19318: {
19318:   if (on && !options().match(/jit/))
19318:   {
19318:     options('jit');
19318:   }
19318:   else if (!on && options().match(/jit/))
19318:   {
19318:     options('jit');
19318:   }
19318: }
19318: 
 1879: /*
 1879:  * Some tests need to know if we are in Rhino as opposed to SpiderMonkey
 1879:  */
 1879: function inRhino()
 1879: {
 1879:   return (typeof defineClass == "function");
 1879: }
 1879: 
 1879: /* these functions are useful for running tests manually in Rhino */
 1879: 
 1879: function GetContext() {
 1879:   return Packages.com.netscape.javascript.Context.getCurrentContext();
 1879: }
 1879: function OptLevel( i ) {
 1879:   i = Number(i);
 1879:   var cx = GetContext();
 1879:   cx.setOptimizationLevel(i);
 1879: }
 1879: /* end of Rhino functions */
 1879: 
 1879: 
