    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: #include "nsTableOuterFrame.h"
    1: #include "nsTableFrame.h"
    1: #include "nsStyleContext.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsPresContext.h"
    1: #include "nsCSSRendering.h"
    1: #include "nsIContent.h"
    1: #include "prinrval.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsIPresShell.h"
    1: #ifdef ACCESSIBILITY
61464: #include "nsAccessibilityService.h"
    1: #endif
    1: #include "nsIServiceManager.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsDisplayList.h"
    1: #include "nsLayoutUtils.h"
    1: 
    1: /* ----------- nsTableCaptionFrame ---------- */
    1: 
    1: #define NS_TABLE_FRAME_CAPTION_LIST_INDEX 0
    1: #define NO_SIDE 100
    1: 
    1: // caption frame
    1: nsTableCaptionFrame::nsTableCaptionFrame(nsStyleContext* aContext):
    1:   nsBlockFrame(aContext)
    1: {
    1:   // shrink wrap 
23305:   SetFlags(NS_BLOCK_FLOAT_MGR);
    1: }
    1: 
    1: nsTableCaptionFrame::~nsTableCaptionFrame()
    1: {
    1: }
    1: 
    1: nsIAtom*
    1: nsTableCaptionFrame::GetType() const
    1: {
    1:   return nsGkAtoms::tableCaptionFrame;
    1: }
    1: 
    1: /* virtual */ nscoord
    1: nsTableOuterFrame::GetBaseline() const
    1: {
    1:   nsIFrame* kid = mFrames.FirstChild();
    1:   if (!kid) {
    1:     NS_NOTREACHED("no inner table");
    1:     return nsHTMLContainerFrame::GetBaseline();
    1:   }
    1: 
    1:   return kid->GetBaseline() + kid->GetPosition().y;
    1: }
    1: 
    1: /* virtual */ nsSize
68481: nsTableCaptionFrame::ComputeAutoSize(nsRenderingContext *aRenderingContext,
    1:                                      nsSize aCBSize, nscoord aAvailableWidth,
    1:                                      nsSize aMargin, nsSize aBorder,
    1:                                      nsSize aPadding, PRBool aShrinkWrap)
    1: {
    1:   nsSize result = nsBlockFrame::ComputeAutoSize(aRenderingContext, aCBSize,
    1:                     aAvailableWidth, aMargin, aBorder, aPadding, aShrinkWrap);
12309:   PRUint8 captionSide = GetStyleTableBorder()->mCaptionSide;
12309:   if (captionSide == NS_STYLE_CAPTION_SIDE_LEFT ||
12309:       captionSide == NS_STYLE_CAPTION_SIDE_RIGHT) {
    1:     result.width = GetMinWidth(aRenderingContext);
12309:   } else if (captionSide == NS_STYLE_CAPTION_SIDE_TOP ||
12309:              captionSide == NS_STYLE_CAPTION_SIDE_BOTTOM) {
12309:     // The outer frame constrains our available width to the width of
12309:     // the table.  Grow if our min-width is bigger than that, but not
12309:     // larger than the containing block width.  (It would really be nice
12309:     // to transmit that information another way, so we could grow up to
12309:     // the table's available width, but that's harder.)
12309:     nscoord min = GetMinWidth(aRenderingContext);
12309:     if (min > aCBSize.width)
12309:       min = aCBSize.width;
12309:     if (min > result.width)
12309:       result.width = min;
    1:   }
    1:   return result;
    1: }
    1: 
  706: NS_IMETHODIMP 
  706: nsTableCaptionFrame::GetParentStyleContextFrame(nsPresContext* aPresContext,
  706:                                                 nsIFrame**      aProviderFrame,
  706:                                                 PRBool*         aIsChild)
  706: {
 1270:   NS_PRECONDITION(mContent->GetParent(),
 1270:                   "How could we not have a parent here?");
 1270:     
  706:   // The caption's style context parent is the inner frame, unless
  706:   // it's anonymous.
  706:   nsIFrame* outerFrame = GetParent();
  706:   if (outerFrame && outerFrame->GetType() == nsGkAtoms::tableOuterFrame) {
  706:     nsIFrame* innerFrame = outerFrame->GetFirstChild(nsnull);
  706:     if (innerFrame) {
  706:       *aProviderFrame =
  706:         nsFrame::CorrectStyleParentFrame(innerFrame,
34387:                                          GetStyleContext()->GetPseudo());
  706:       *aIsChild = PR_FALSE;
  706:       return NS_OK;
  706:     }
  706:   }
  706: 
  706:   NS_NOTREACHED("Where is our inner table frame?");
  706:   return nsBlockFrame::GetParentStyleContextFrame(aPresContext, aProviderFrame,
  706:                                                   aIsChild);
  706: }
  706: 
 3151: #ifdef ACCESSIBILITY
46338: already_AddRefed<nsAccessible>
46338: nsTableCaptionFrame::CreateAccessible()
 3151: {
 3151:   if (!GetRect().IsEmpty()) {
61464:     nsAccessibilityService* accService = nsIPresShell::AccService();
 3151:     if (accService) {
46338:       return accService->CreateHTMLCaptionAccessible(mContent,
46338:                                                      PresContext()->PresShell());
 3151:     }
 3151:   }
 3151: 
46338:   return nsnull;
 3151: }
 3151: #endif
 3151: 
    1: #ifdef NS_DEBUG
    1: NS_IMETHODIMP
    1: nsTableCaptionFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("Caption"), aResult);
    1: }
    1: #endif
    1: 
    1: nsIFrame* 
    1: NS_NewTableCaptionFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsTableCaptionFrame(aContext);
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsTableCaptionFrame)
32423: 
    1: /* ----------- nsTableOuterFrame ---------- */
    1: 
    1: nsTableOuterFrame::nsTableOuterFrame(nsStyleContext* aContext):
    1:   nsHTMLContainerFrame(aContext)
    1: {
    1: }
    1: 
    1: nsTableOuterFrame::~nsTableOuterFrame()
    1: {
    1: }
    1: 
23554: NS_QUERYFRAME_HEAD(nsTableOuterFrame)
23554:   NS_QUERYFRAME_ENTRY(nsITableLayout)
23554: NS_QUERYFRAME_TAIL_INHERITING(nsHTMLContainerFrame)
    1: 
    1: #ifdef ACCESSIBILITY
46338: already_AddRefed<nsAccessible>
46338: nsTableOuterFrame::CreateAccessible()
    1: {
61464:   nsAccessibilityService* accService = nsIPresShell::AccService();
    1:   if (accService) {
46338:     return accService->CreateHTMLTableAccessible(mContent,
46338:                                                  PresContext()->PresShell());
    1:   }
    1: 
46338:   return nsnull;
    1: }
    1: #endif
    1: 
    1: /* virtual */ PRBool
    1: nsTableOuterFrame::IsContainingBlock() const
    1: {
    1:   return PR_FALSE;
    1: }
    1: 
    1: void
36647: nsTableOuterFrame::DestroyFrom(nsIFrame* aDestructRoot)
    1: {
36647:   mCaptionFrames.DestroyFramesFrom(aDestructRoot);
36647:   nsHTMLContainerFrame::DestroyFrom(aDestructRoot);
    1: }
    1: 
30783: nsFrameList
30783: nsTableOuterFrame::GetChildList(nsIAtom* aListName) const
    1: {
    1:   if (nsGkAtoms::captionList == aListName) {
30783:     return mCaptionFrames;
    1:   }
    1:   if (!aListName) {
30783:     return mFrames;
    1:   }
72634:   return nsFrameList::EmptyList();
    1: }
    1: 
    1: nsIAtom*
    1: nsTableOuterFrame::GetAdditionalChildListName(PRInt32 aIndex) const
    1: {
    1:   if (aIndex == NS_TABLE_FRAME_CAPTION_LIST_INDEX) {
    1:     return nsGkAtoms::captionList;
    1:   }
72634:   return nsnull;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsTableOuterFrame::SetInitialChildList(nsIAtom*        aListName,
30790:                                        nsFrameList&    aChildList)
    1: {
    1:   if (nsGkAtoms::captionList == aListName) {
    1:     // the frame constructor already checked for table-caption display type
    1:     mCaptionFrames.SetFrames(aChildList);
    1:     mCaptionFrame = mCaptionFrames.FirstChild();
    1:   }
    1:   else {
    1:     NS_ASSERTION(!aListName, "wrong childlist");
    1:     NS_ASSERTION(mFrames.IsEmpty(), "Frame leak!");
30790:     mInnerTableFrame = nsnull;
30790:     if (aChildList.NotEmpty()) {
30790:       if (nsGkAtoms::tableFrame == aChildList.FirstChild()->GetType()) {
30790:         mInnerTableFrame = (nsTableFrame*)aChildList.FirstChild();
    1:         mFrames.SetFrames(aChildList);
    1:       }
    1:       else {
    1:         NS_ERROR("expected a table frame");
    1:         return NS_ERROR_INVALID_ARG;
    1:       }
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTableOuterFrame::AppendFrames(nsIAtom*        aListName,
30941:                                 nsFrameList&    aFrameList)
    1: {
    1:   nsresult rv;
    1: 
    1:   // We only have two child frames: the inner table and a caption frame.
    1:   // The inner frame is provided when we're initialized, and it cannot change
    1:   if (nsGkAtoms::captionList == aListName) {
30941:     NS_ASSERTION(aFrameList.IsEmpty() ||
30941:                  aFrameList.FirstChild()->GetType() == nsGkAtoms::tableCaptionFrame,
    1:                  "appending non-caption frame to captionList");
    1:     mCaptionFrames.AppendFrames(this, aFrameList);
    1:     mCaptionFrame = mCaptionFrames.FirstChild();
    1:     rv = NS_OK;
    1: 
    1:     // Reflow the new caption frame. It's already marked dirty, so
    1:     // just tell the pres shell.
  238:     PresContext()->PresShell()->
 1158:       FrameNeedsReflow(this, nsIPresShell::eTreeChange,
 1158:                        NS_FRAME_HAS_DIRTY_CHILDREN);
    1:   }
    1:   else {
    1:     NS_PRECONDITION(PR_FALSE, "unexpected child list");
    1:     rv = NS_ERROR_UNEXPECTED;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTableOuterFrame::InsertFrames(nsIAtom*        aListName,
    1:                                 nsIFrame*       aPrevFrame,
30941:                                 nsFrameList&    aFrameList)
    1: {
    1:   if (nsGkAtoms::captionList == aListName) {
    1:     NS_ASSERTION(!aPrevFrame || aPrevFrame->GetParent() == this,
    1:                  "inserting after sibling frame with different parent");
30941:     NS_ASSERTION(aFrameList.IsEmpty() ||
30941:                  aFrameList.FirstChild()->GetType() == nsGkAtoms::tableCaptionFrame,
    1:                  "inserting non-caption frame into captionList");
    1:     mCaptionFrames.InsertFrames(nsnull, aPrevFrame, aFrameList);
    1:     mCaptionFrame = mCaptionFrames.FirstChild();
 4195: 
 4195:     // Reflow the new caption frame. It's already marked dirty, so
 4195:     // just tell the pres shell.
 4195:     PresContext()->PresShell()->
 4195:       FrameNeedsReflow(this, nsIPresShell::eTreeChange,
 4195:                        NS_FRAME_HAS_DIRTY_CHILDREN);
    1:     return NS_OK;
    1:   }
    1:   else {
    1:     NS_PRECONDITION(!aPrevFrame, "invalid previous frame");
    1:     return AppendFrames(aListName, aFrameList);
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTableOuterFrame::RemoveFrame(nsIAtom*        aListName,
    1:                                nsIFrame*       aOldFrame)
    1: {
    1:   // We only have two child frames: the inner table and one caption frame.
    1:   // The inner frame can't be removed so this should be the caption
    1:   NS_PRECONDITION(nsGkAtoms::captionList == aListName, "can't remove inner frame");
    1: 
12309:   if (HasSideCaption()) {
    1:     // The old caption width had an effect on the inner table width so
    1:     // we're going to need to reflow it. Mark it dirty
    1:     mInnerTableFrame->AddStateBits(NS_FRAME_IS_DIRTY);
    1:   }
    1: 
    1:   // Remove the frame and destroy it
    1:   mCaptionFrames.DestroyFrame(aOldFrame);
    1:   mCaptionFrame = mCaptionFrames.FirstChild();
    1:   
  238:   PresContext()->PresShell()->
 1158:     FrameNeedsReflow(this, nsIPresShell::eTreeChange,
 1158:                      NS_FRAME_HAS_DIRTY_CHILDREN); // also means child removed
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_METHOD 
    1: nsTableOuterFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                                     const nsRect&           aDirtyRect,
    1:                                     const nsDisplayListSet& aLists)
    1: {
    1:   // No border, background or outline are painted because they all belong
    1:   // to the inner table.
    1:   if (!IsVisibleInSelection(aBuilder))
    1:     return NS_OK;
    1: 
    1:   // If there's no caption, take a short cut to avoid having to create
    1:   // the special display list set and then sort it.
    1:   if (!mCaptionFrame)
    1:     return BuildDisplayListForInnerTable(aBuilder, aDirtyRect, aLists);
    1:     
    1:   nsDisplayListCollection set;
    1:   nsresult rv = BuildDisplayListForInnerTable(aBuilder, aDirtyRect, set);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:   nsDisplayListSet captionSet(set, set.BlockBorderBackgrounds());
    1:   rv = BuildDisplayListForChild(aBuilder, mCaptionFrame, aDirtyRect, captionSet);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:   // Now we have to sort everything by content order, since the caption
    1:   // may be somewhere inside the table
    1:   set.SortAllByContentOrder(aBuilder, GetContent());
    1:   set.MoveTo(aLists);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsTableOuterFrame::BuildDisplayListForInnerTable(nsDisplayListBuilder*   aBuilder,
    1:                                                  const nsRect&           aDirtyRect,
    1:                                                  const nsDisplayListSet& aLists)
    1: {
    1:   // Just paint the regular children, but the children's background is our
    1:   // true background (there should only be one, the real table)
    1:   nsIFrame* kid = mFrames.FirstChild();
    1:   // The children should be in content order
    1:   while (kid) {
    1:     nsresult rv = BuildDisplayListForChild(aBuilder, kid, aDirtyRect, aLists);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     kid = kid->GetNextSibling();
    1:   }
    1:   return NS_OK;
    1: }
    1: 
30695: void
30695: nsTableOuterFrame::SetSelected(PRBool        aSelected,
18931:                                SelectionType aType)
    1: {
30695:   nsFrame::SetSelected(aSelected, aType);
30695:   if (mInnerTableFrame) {
30695:     mInnerTableFrame->SetSelected(aSelected, aType);
30695:   }
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsTableOuterFrame::GetParentStyleContextFrame(nsPresContext* aPresContext,
    1:                                               nsIFrame**      aProviderFrame,
    1:                                               PRBool*         aIsChild)
    1: {
    1:   // The table outer frame and the (inner) table frame split the style
    1:   // data by giving the table frame the style context associated with
    1:   // the table content node and creating a style context for the outer
    1:   // frame that is a *child* of the table frame's style context,
    1:   // matching the ::-moz-table-outer pseudo-element.  html.css has a
    1:   // rule that causes that pseudo-element (and thus the outer table)
    1:   // to inherit *some* style properties from the table frame.  The
    1:   // children of the table inherit directly from the inner table, and
    1:   // the outer table's style context is a leaf.
    1: 
    1:   if (!mInnerTableFrame) {
    1:     *aProviderFrame = this;
    1:     *aIsChild = PR_FALSE;
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   *aProviderFrame = mInnerTableFrame;
    1:   *aIsChild = PR_TRUE;
    1:   return NS_OK;
    1: }
    1: 
    1: // INCREMENTAL REFLOW HELPER FUNCTIONS 
    1: 
    1: void
    1: nsTableOuterFrame::InitChildReflowState(nsPresContext&    aPresContext,                     
    1:                                         nsHTMLReflowState& aReflowState)
    1:                                     
    1: {
    1:   nsMargin collapseBorder;
    1:   nsMargin collapsePadding(0,0,0,0);
    1:   nsMargin* pCollapseBorder  = nsnull;
    1:   nsMargin* pCollapsePadding = nsnull;
    1:   if ((aReflowState.frame == mInnerTableFrame) && (mInnerTableFrame->IsBorderCollapse())) {
    1:     collapseBorder  = mInnerTableFrame->GetIncludedOuterBCBorder();
    1:     pCollapseBorder = &collapseBorder;
    1:     pCollapsePadding = &collapsePadding;
    1:   }
    1:   aReflowState.Init(&aPresContext, -1, -1, pCollapseBorder, pCollapsePadding);
    1: }
    1: 
    1: // get the margin and padding data. nsHTMLReflowState doesn't handle the
    1: // case of auto margins
    1: void
36583: nsTableOuterFrame::GetChildMargin(nsPresContext*           aPresContext,
    1:                                   const nsHTMLReflowState& aOuterRS,
    1:                                   nsIFrame*                aChildFrame,
    1:                                   nscoord                  aAvailWidth,
    1:                                   nsMargin&                aMargin)
    1: {
    1:   // construct a reflow state to compute margin and padding. Auto margins
    1:   // will not be computed at this time.
    1: 
    1:   // create and init the child reflow state
    1:   // XXX We really shouldn't construct a reflow state to do this.
    1:   nsHTMLReflowState childRS(aPresContext, aOuterRS, aChildFrame,
    1:                             nsSize(aAvailWidth, aOuterRS.availableHeight),
    1:                             -1, -1, PR_FALSE);
    1:   InitChildReflowState(*aPresContext, childRS);
    1: 
    1:   aMargin = childRS.mComputedMargin;
    1: }
    1: 
    1: static nsSize
    1: GetContainingBlockSize(const nsHTMLReflowState& aOuterRS)
    1: {
    1:   nsSize size(0,0);
    1:   const nsHTMLReflowState* containRS =
    1:     aOuterRS.mCBReflowState;
    1: 
    1:   if (containRS) {
    1:     size.width = containRS->ComputedWidth();
    1:     if (NS_UNCONSTRAINEDSIZE == size.width) {
    1:       size.width = 0;
    1:     }
 4166:     size.height = containRS->ComputedHeight();
    1:     if (NS_UNCONSTRAINEDSIZE == size.height) {
    1:       size.height = 0;
    1:     }
    1:   }
    1:   return size;
    1: }
    1: 
    1: /* virtual */ nscoord
68481: nsTableOuterFrame::GetMinWidth(nsRenderingContext *aRenderingContext)
    1: {
    1:   nscoord width = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
    1:                     mInnerTableFrame, nsLayoutUtils::MIN_WIDTH);
    1:   DISPLAY_MIN_WIDTH(this, width);
    1:   if (mCaptionFrame) {
    1:     nscoord capWidth =
    1:       nsLayoutUtils::IntrinsicForContainer(aRenderingContext, mCaptionFrame,
    1:                                            nsLayoutUtils::MIN_WIDTH);
12309:     if (HasSideCaption()) {
    1:       width += capWidth;
12309:     } else {
    1:       if (capWidth > width) {
    1:         width = capWidth;
    1:       }
    1:     }
    1:   }
    1:   return width;
    1: }
    1: 
    1: /* virtual */ nscoord
68481: nsTableOuterFrame::GetPrefWidth(nsRenderingContext *aRenderingContext)
    1: {
    1:   nscoord maxWidth;
    1:   DISPLAY_PREF_WIDTH(this, maxWidth);
    1: 
    1:   maxWidth = nsLayoutUtils::IntrinsicForContainer(aRenderingContext,
    1:                mInnerTableFrame, nsLayoutUtils::PREF_WIDTH);
    1:   if (mCaptionFrame) {
    1:     PRUint8 captionSide = GetCaptionSide();
    1:     switch(captionSide) {
12309:     case NS_STYLE_CAPTION_SIDE_LEFT:
12309:     case NS_STYLE_CAPTION_SIDE_RIGHT:
    1:       {
    1:         nscoord capMin =
    1:           nsLayoutUtils::IntrinsicForContainer(aRenderingContext, mCaptionFrame,
    1:                                                nsLayoutUtils::MIN_WIDTH);
    1:         maxWidth += capMin;
    1:       }
    1:       break;
12309:     default:
    1:       {
12309:         nsLayoutUtils::IntrinsicWidthType iwt;
12309:         if (captionSide == NS_STYLE_CAPTION_SIDE_TOP ||
12309:             captionSide == NS_STYLE_CAPTION_SIDE_BOTTOM) {
12309:           // Don't let the caption's pref width expand the table's pref
12309:           // width.
12309:           iwt = nsLayoutUtils::MIN_WIDTH;
12309:         } else {
12309:           NS_ASSERTION(captionSide == NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE ||
12309:                        captionSide == NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE,
12309:                        "unexpected caption side");
12309:           iwt = nsLayoutUtils::PREF_WIDTH;
12309:         }
    1:         nscoord capPref =
    1:           nsLayoutUtils::IntrinsicForContainer(aRenderingContext, mCaptionFrame,
12309:                                                iwt);
32531:         maxWidth = NS_MAX(maxWidth, capPref);
    1:       }
12309:       break;
    1:     }
    1:   }
    1:   return maxWidth;
    1: }
    1: 
12402: // Compute the margin-box width of aChildFrame given the inputs.  If
12402: // aMarginResult is non-null, fill it with the part of the margin-width
12402: // that was contributed by the margin.
12402: static nscoord
68481: ChildShrinkWrapWidth(nsRenderingContext *aRenderingContext,
12402:                      nsIFrame *aChildFrame,
12402:                      nsSize aCBSize, nscoord aAvailableWidth,
12402:                      nscoord *aMarginResult = nsnull)
12402: {
12402:   // The outer table's children do not use it as a containing block.
12402:   nsCSSOffsetState offsets(aChildFrame, aRenderingContext, aCBSize.width);
12402:   nsSize size = aChildFrame->ComputeSize(aRenderingContext, aCBSize,
12402:                   aAvailableWidth,
12402:                   nsSize(offsets.mComputedMargin.LeftRight(),
12402:                          offsets.mComputedMargin.TopBottom()),
12402:                   nsSize(offsets.mComputedBorderPadding.LeftRight() -
12402:                            offsets.mComputedPadding.LeftRight(),
12402:                          offsets.mComputedBorderPadding.TopBottom() -
12402:                            offsets.mComputedPadding.TopBottom()),
12402:                   nsSize(offsets.mComputedPadding.LeftRight(),
12402:                          offsets.mComputedPadding.TopBottom()),
12402:                   PR_TRUE);
12402:   if (aMarginResult)
12402:     *aMarginResult = offsets.mComputedMargin.LeftRight();
12402:   return size.width + offsets.mComputedMargin.LeftRight() +
12402:                       offsets.mComputedBorderPadding.LeftRight();
12402: }
12402: 
    1: /* virtual */ nsSize
68481: nsTableOuterFrame::ComputeAutoSize(nsRenderingContext *aRenderingContext,
    1:                                    nsSize aCBSize, nscoord aAvailableWidth,
    1:                                    nsSize aMargin, nsSize aBorder,
    1:                                    nsSize aPadding, PRBool aShrinkWrap)
    1: {
    1:   if (!aShrinkWrap)
    1:     return nsHTMLContainerFrame::ComputeAutoSize(aRenderingContext, aCBSize,
    1:                aAvailableWidth, aMargin, aBorder, aPadding, aShrinkWrap);
    1: 
    1:   // When we're shrink-wrapping, our auto size needs to wrap around the
    1:   // actual size of the table, which (if it is specified as a percent)
    1:   // could be something that is not reflected in our GetMinWidth and
    1:   // GetPrefWidth.  See bug 349457 for an example.
    1: 
12402:   // Match the availableWidth logic in Reflow.
12309:   PRUint8 captionSide = GetCaptionSide();
12402:   nscoord width;
12402:   if (captionSide == NO_SIDE) {
12402:     width = ChildShrinkWrapWidth(aRenderingContext, mInnerTableFrame,
12402:                                  aCBSize, aAvailableWidth);
12402:   } else if (captionSide == NS_STYLE_CAPTION_SIDE_LEFT ||
12309:              captionSide == NS_STYLE_CAPTION_SIDE_RIGHT) {
12402:     nscoord capWidth = ChildShrinkWrapWidth(aRenderingContext, mCaptionFrame,
12402:                                             aCBSize, aAvailableWidth);
12402:     width = capWidth + ChildShrinkWrapWidth(aRenderingContext,
12402:                                             mInnerTableFrame, aCBSize,
12402:                                             aAvailableWidth - capWidth);
12402:   } else if (captionSide == NS_STYLE_CAPTION_SIDE_TOP ||
12402:              captionSide == NS_STYLE_CAPTION_SIDE_BOTTOM) {
12402:     nscoord margin;
12402:     width = ChildShrinkWrapWidth(aRenderingContext, mInnerTableFrame,
12402:                                  aCBSize, aAvailableWidth, &margin);
12402:     nscoord capWidth = ChildShrinkWrapWidth(aRenderingContext,
12402:                                             mCaptionFrame, aCBSize,
12402:                                             width - margin);
    1:     if (capWidth > width)
    1:       width = capWidth;
12402:   } else {
12402:     NS_ASSERTION(captionSide == NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE ||
12402:                  captionSide == NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE,
12402:                  "unexpected caption-side");
12402:     width = ChildShrinkWrapWidth(aRenderingContext, mInnerTableFrame,
12402:                                  aCBSize, aAvailableWidth);
12402:     nscoord capWidth = ChildShrinkWrapWidth(aRenderingContext,
12402:                                             mCaptionFrame, aCBSize,
12402:                                             aAvailableWidth);
12402:     if (capWidth > width)
12402:       width = capWidth;
    1:   }
    1: 
    1:   return nsSize(width, NS_UNCONSTRAINEDSIZE);
    1: }
    1: 
    1: PRUint8
    1: nsTableOuterFrame::GetCaptionSide()
    1: {
    1:   if (mCaptionFrame) {
    1:     return mCaptionFrame->GetStyleTableBorder()->mCaptionSide;
    1:   }
    1:   else {
    1:     return NO_SIDE; // no caption
    1:   }
    1: }
    1: 
    1: PRUint8
    1: nsTableOuterFrame::GetCaptionVerticalAlign()
    1: {
    1:   const nsStyleCoord& va = mCaptionFrame->GetStyleTextReset()->mVerticalAlign;
    1:   return (va.GetUnit() == eStyleUnit_Enumerated)
    1:            ? va.GetIntValue()
    1:            : NS_STYLE_VERTICAL_ALIGN_TOP;
    1: }
    1: 
    1: void
    1: nsTableOuterFrame::SetDesiredSize(PRUint8         aCaptionSide,
    1:                                   const nsMargin& aInnerMargin,
    1:                                   const nsMargin& aCaptionMargin,
    1:                                   nscoord&        aWidth,
    1:                                   nscoord&        aHeight)
    1: {
    1:   aWidth = aHeight = 0;
    1: 
    1:   nsRect innerRect = mInnerTableFrame->GetRect();
    1:   nscoord innerWidth = innerRect.width;
    1: 
    1:   nsRect captionRect(0,0,0,0);
    1:   nscoord captionWidth = 0;
    1:   if (mCaptionFrame) {
    1:     captionRect = mCaptionFrame->GetRect();
    1:     captionWidth = captionRect.width;
    1:   }
    1:   switch(aCaptionSide) {
12309:     case NS_STYLE_CAPTION_SIDE_LEFT:
32531:       aWidth = NS_MAX(aInnerMargin.left, aCaptionMargin.left + captionWidth + aCaptionMargin.right) +
    1:                innerWidth + aInnerMargin.right;
    1:       break;
12309:     case NS_STYLE_CAPTION_SIDE_RIGHT:
32531:       aWidth = NS_MAX(aInnerMargin.right, aCaptionMargin.left + captionWidth + aCaptionMargin.right) +
    1:                innerWidth + aInnerMargin.left;
    1:       break;
    1:     default:
    1:       aWidth = aInnerMargin.left + innerWidth + aInnerMargin.right;
32531:       aWidth = NS_MAX(aWidth, captionRect.XMost() + aCaptionMargin.right);
    1:   }
    1:   aHeight = innerRect.YMost() + aInnerMargin.bottom;
29651:   if (NS_STYLE_CAPTION_SIDE_BOTTOM != aCaptionSide) {
32531:     aHeight = NS_MAX(aHeight, captionRect.YMost() + aCaptionMargin.bottom);
29651:   }
29651:   else {
32531:     aHeight = NS_MAX(aHeight, captionRect.YMost() + aCaptionMargin.bottom +
29651:                               aInnerMargin.bottom);
29651:   }
    1: 
    1: }
    1: 
    1: nsresult 
    1: nsTableOuterFrame::GetCaptionOrigin(PRUint32         aCaptionSide,
    1:                                     const nsSize&    aContainBlockSize,
    1:                                     const nsSize&    aInnerSize, 
    1:                                     const nsMargin&  aInnerMargin,
    1:                                     const nsSize&    aCaptionSize,
    1:                                     nsMargin&        aCaptionMargin,
    1:                                     nsPoint&         aOrigin)
    1: {
    1:   aOrigin.x = aOrigin.y = 0;
    1:   if ((NS_UNCONSTRAINEDSIZE == aInnerSize.width) || (NS_UNCONSTRAINEDSIZE == aInnerSize.height) ||  
    1:       (NS_UNCONSTRAINEDSIZE == aCaptionSize.width) || (NS_UNCONSTRAINEDSIZE == aCaptionSize.height)) {
    1:     return NS_OK;
    1:   }
    1:   if (!mCaptionFrame) return NS_OK;
    1:   
29651:   NS_ASSERTION(NS_AUTOMARGIN != aCaptionMargin.left,   "The computed caption margin is auto?");
29651:   NS_ASSERTION(NS_AUTOMARGIN != aCaptionMargin.top,    "The computed caption margin is auto?");
29651:   NS_ASSERTION(NS_AUTOMARGIN != aCaptionMargin.bottom, "The computed caption margin is auto?");
29651: 
29651:   // horizontal computation
    1:   switch(aCaptionSide) {
12309:   case NS_STYLE_CAPTION_SIDE_BOTTOM:
12309:   case NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE: {
29651:     // FIXME: Position relative to right edge for RTL.  (Based on table
29651:     // direction or table parent direction?)
    1:     aOrigin.x = aCaptionMargin.left;
12312:     if (aCaptionSide == NS_STYLE_CAPTION_SIDE_BOTTOM) {
12312:       // We placed the caption using only the table's width as available
12312:       // width, and we should position it this way as well.
12312:       aOrigin.x += aInnerMargin.left;
12312:     }
29651:   } break;
29651:   case NS_STYLE_CAPTION_SIDE_LEFT: {
29651:     aOrigin.x = aCaptionMargin.left;
29651:   } break;
29651:   case NS_STYLE_CAPTION_SIDE_RIGHT: {
29651:     aOrigin.x = aInnerMargin.left + aInnerSize.width + aCaptionMargin.left;
29651:   } break;
29651:   default: { // top
29651:     NS_ASSERTION(aCaptionSide == NS_STYLE_CAPTION_SIDE_TOP ||
29651:                  aCaptionSide == NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE,
29651:                  "unexpected caption side");
12312:     // FIXME: Position relative to right edge for RTL.  (Based on table
12312:     // direction or table parent direction?)
29651:     aOrigin.x = aCaptionMargin.left;
29651:     if (aCaptionSide == NS_STYLE_CAPTION_SIDE_TOP) {
29651:       // We placed the caption using only the table's width as available
29651:       // width, and we should position it this way as well.
29651:       aOrigin.x += aInnerMargin.left;
    1:     }
29651:     
    1:   } break;
    1:   }
29651:   // vertical computation
29651:   switch (aCaptionSide) {
29651:     case NS_STYLE_CAPTION_SIDE_RIGHT:
29651:     case NS_STYLE_CAPTION_SIDE_LEFT:
    1:       aOrigin.y = aInnerMargin.top;
    1:       switch (GetCaptionVerticalAlign()) {
    1:         case NS_STYLE_VERTICAL_ALIGN_MIDDLE:
32531:           aOrigin.y = NS_MAX(0, aInnerMargin.top + ((aInnerSize.height - aCaptionSize.height) / 2));
    1:           break;
    1:         case NS_STYLE_VERTICAL_ALIGN_BOTTOM:
32531:           aOrigin.y = NS_MAX(0, aInnerMargin.top + aInnerSize.height - aCaptionSize.height);
    1:           break;
    1:         default:
    1:           break;
    1:       }
29651:       break;
29651:     case NS_STYLE_CAPTION_SIDE_BOTTOM: {
29651:       aOrigin.y = aInnerMargin.top + aInnerSize.height + aCaptionMargin.top;
    1:     } break;
29651:     case NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE: {
29651:       nsCollapsingMargin marg;
29651:       marg.Include(aCaptionMargin.top);
29651:       marg.Include(aInnerMargin.bottom);
29651:       nscoord collapseMargin = marg.get();
29651:       aOrigin.y = aInnerMargin.top + aInnerSize.height + collapseMargin;
    1:     } break;
29651:     case NS_STYLE_CAPTION_SIDE_TOP: {
29651:       aOrigin.y = aInnerMargin.top + aCaptionMargin.top;
29651:     } break;
29651:     case NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE: {
    1:       aOrigin.y = aCaptionMargin.top;
    1:     } break;
29651:     default:
29651:       NS_NOTREACHED("Unknown caption alignment type");
29651:       break;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult 
    1: nsTableOuterFrame::GetInnerOrigin(PRUint32         aCaptionSide,
    1:                                   const nsSize&    aContainBlockSize,
    1:                                   const nsSize&    aCaptionSize, 
    1:                                   const nsMargin&  aCaptionMargin,
    1:                                   const nsSize&    aInnerSize,
    1:                                   nsMargin&        aInnerMargin,
    1:                                   nsPoint&         aOrigin)
    1: {
29651:   
29651:   NS_ASSERTION(NS_AUTOMARGIN != aCaptionMargin.left,  "The computed caption margin is auto?");
29651:   NS_ASSERTION(NS_AUTOMARGIN != aCaptionMargin.right, "The computed caption margin is auto?");
29651:   NS_ASSERTION(NS_AUTOMARGIN != aInnerMargin.left,    "The computed inner margin is auto?");
29651:   NS_ASSERTION(NS_AUTOMARGIN != aInnerMargin.right,   "The computed inner margin is auto?");
29651:   NS_ASSERTION(NS_AUTOMARGIN != aInnerMargin.top,     "The computed inner margin is auto?");
29651:   NS_ASSERTION(NS_AUTOMARGIN != aInnerMargin.bottom,  "The computed inner margin is auto?");
29651:   
    1:   aOrigin.x = aOrigin.y = 0;
    1:   if ((NS_UNCONSTRAINEDSIZE == aInnerSize.width) || (NS_UNCONSTRAINEDSIZE == aInnerSize.height) ||  
    1:       (NS_UNCONSTRAINEDSIZE == aCaptionSize.width) || (NS_UNCONSTRAINEDSIZE == aCaptionSize.height)) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nscoord minCapWidth = aCaptionSize.width;
29651:   
    1:   minCapWidth += aCaptionMargin.left;
    1:   minCapWidth += aCaptionMargin.right;
    1: 
29651:   // horizontal computation
    1:   switch (aCaptionSide) {
12309:   case NS_STYLE_CAPTION_SIDE_LEFT: {
    1:     if (aInnerMargin.left < minCapWidth) {
    1:       // shift the inner table to get some place for the caption
    1:       aInnerMargin.right += aInnerMargin.left - minCapWidth;
32531:       aInnerMargin.right  = NS_MAX(0, aInnerMargin.right);
    1:       aInnerMargin.left   = minCapWidth;
    1:     }
    1:     aOrigin.x = aInnerMargin.left;
29651:   } break;
29651:   default: {
29651:     NS_ASSERTION(aCaptionSide == NS_STYLE_CAPTION_SIDE_TOP ||
29651:                  aCaptionSide == NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE ||
29651:                  aCaptionSide == NS_STYLE_CAPTION_SIDE_BOTTOM ||
29651:                  aCaptionSide == NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE ||
29651:                  aCaptionSide == NS_STYLE_CAPTION_SIDE_RIGHT ||
29651:                  aCaptionSide == NO_SIDE,
29651:                  "unexpected caption side");
29651:     aOrigin.x = aInnerMargin.left;
29651:   } break;
    1:   }
29651:   
29651:   // vertical computation
29651:   switch (aCaptionSide) {
29651:     case NS_STYLE_CAPTION_SIDE_BOTTOM:
29651:     case NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE: {
29651:       aOrigin.y = aInnerMargin.top;
29651:     } break;
29651:     case NS_STYLE_CAPTION_SIDE_LEFT:
29651:     case NS_STYLE_CAPTION_SIDE_RIGHT: {
    1:       aOrigin.y = aInnerMargin.top;
    1:       switch (GetCaptionVerticalAlign()) {
    1:         case NS_STYLE_VERTICAL_ALIGN_MIDDLE:
32531:           aOrigin.y = NS_MAX(aInnerMargin.top, (aCaptionSize.height - aInnerSize.height) / 2);
    1:           break;
    1:         case NS_STYLE_VERTICAL_ALIGN_BOTTOM:
32531:           aOrigin.y = NS_MAX(aInnerMargin.top, aCaptionSize.height - aInnerSize.height);
    1:           break;
    1:         default:
    1:           break;
    1:       }
    1:     } break;
29651:     case NO_SIDE:
29651:     case NS_STYLE_CAPTION_SIDE_TOP: {
29651:       aOrigin.y = aInnerMargin.top + aCaptionMargin.top + aCaptionSize.height +
29651:                   aCaptionMargin.bottom;
    1:     } break;
29651:     case NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE: {
    1:       nsCollapsingMargin marg;
    1:       marg.Include(aCaptionMargin.bottom);
    1:       marg.Include(aInnerMargin.top);
    1:       nscoord collapseMargin = marg.get();
    1:       aOrigin.y = aCaptionMargin.top + aCaptionSize.height + collapseMargin;
    1:     } break;
29651:     default:
29651:       NS_NOTREACHED("Unknown caption alignment type");
29651:       break;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
12308: void
12308: nsTableOuterFrame::OuterBeginReflowChild(nsPresContext*           aPresContext,
    1:                                          nsIFrame*                aChildFrame,
    1:                                          const nsHTMLReflowState& aOuterRS,
    1:                                          void*                    aChildRSSpace,
12308:                                          nscoord                  aAvailWidth)
    1: { 
    1:   // work around pixel rounding errors, round down to ensure we don't exceed the avail height in
    1:   nscoord availHeight = aOuterRS.availableHeight;
    1:   if (NS_UNCONSTRAINEDSIZE != availHeight) {
 9571:     if (mCaptionFrame == aChildFrame) {
 9571:       availHeight = NS_UNCONSTRAINEDSIZE;
 9571:     } else {
    1:       nsMargin margin;
36583:       GetChildMargin(aPresContext, aOuterRS, aChildFrame,
36583:                      aOuterRS.availableWidth, margin);
    1:     
    1:       NS_ASSERTION(NS_UNCONSTRAINEDSIZE != margin.top, "No unconstrainedsize arithmetic, please");
    1:       availHeight -= margin.top;
    1:  
    1:       NS_ASSERTION(NS_UNCONSTRAINEDSIZE != margin.bottom, "No unconstrainedsize arithmetic, please");
    1:       availHeight -= margin.bottom;
    1:     }
 9571:   }
    1:   nsSize availSize(aAvailWidth, availHeight);
    1:   // create and init the child reflow state, using placement new on
    1:   // stack space allocated by the caller, so that the caller can destroy
    1:   // it
    1:   nsHTMLReflowState &childRS = * new (aChildRSSpace)
    1:     nsHTMLReflowState(aPresContext, aOuterRS, aChildFrame, availSize,
    1:                       -1, -1, PR_FALSE);
    1:   InitChildReflowState(*aPresContext, childRS);
    1: 
    1:   // see if we need to reset top of page due to a caption
    1:   if (mCaptionFrame) {
    1:     PRUint8 captionSide = GetCaptionSide();
12309:     if (((captionSide == NS_STYLE_CAPTION_SIDE_BOTTOM ||
12309:           captionSide == NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE) &&
12309:          mCaptionFrame == aChildFrame) || 
12309:         ((captionSide == NS_STYLE_CAPTION_SIDE_TOP ||
12309:           captionSide == NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE) &&
12309:          mInnerTableFrame == aChildFrame)) {
    1:       childRS.mFlags.mIsTopOfPage = PR_FALSE;
    1:     }
    1:   }
    1: }
    1: 
12308: nsresult
12308: nsTableOuterFrame::OuterDoReflowChild(nsPresContext*             aPresContext,
12308:                                       nsIFrame*                  aChildFrame,
12308:                                       const nsHTMLReflowState&   aChildRS,
12308:                                       nsHTMLReflowMetrics&       aMetrics,
12308:                                       nsReflowStatus&            aStatus)
12308: { 
12308: 
    1:   // use the current position as a best guess for placement
    1:   nsPoint childPt = aChildFrame->GetPosition();
12308:   return ReflowChild(aChildFrame, aPresContext, aMetrics, aChildRS,
    1:                      childPt.x, childPt.y, NS_FRAME_NO_MOVE_FRAME, aStatus);
    1: }
    1: 
    1: void 
    1: nsTableOuterFrame::UpdateReflowMetrics(PRUint8              aCaptionSide,
    1:                                        nsHTMLReflowMetrics& aMet,
    1:                                        const nsMargin&      aInnerMargin,
    1:                                        const nsMargin&      aCaptionMargin)
    1: {
    1:   SetDesiredSize(aCaptionSide, aInnerMargin, aCaptionMargin,
    1:                  aMet.width, aMet.height);
    1: 
55039:   aMet.SetOverflowAreasToDesiredBounds();
55039:   ConsiderChildOverflow(aMet.mOverflowAreas, mInnerTableFrame);
    1:   if (mCaptionFrame) {
55039:     ConsiderChildOverflow(aMet.mOverflowAreas, mCaptionFrame);
    1:   }
    1:   FinishAndStoreOverflow(&aMet);
    1: }
    1: 
    1: NS_METHOD nsTableOuterFrame::Reflow(nsPresContext*           aPresContext,
    1:                                     nsHTMLReflowMetrics&     aDesiredSize,
    1:                                     const nsHTMLReflowState& aOuterRS,
    1:                                     nsReflowStatus&          aStatus)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsTableOuterFrame");
    1:   DISPLAY_REFLOW(aPresContext, this, aOuterRS, aDesiredSize, aStatus);
    1: 
    1:   // We desperately need an inner table frame,
    1:   // if this fails fix the frame constructor
    1:   if (mFrames.IsEmpty() || !mInnerTableFrame) {
    1:     NS_ERROR("incomplete children");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   nsresult rv = NS_OK;
    1:   PRUint8 captionSide = GetCaptionSide();
    1: 
    1:   // Initialize out parameters
    1:   aDesiredSize.width = aDesiredSize.height = 0;
    1:   aStatus = NS_FRAME_COMPLETE;
    1: 
    1:   if (!(GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
    1:     // Set up our kids.  They're already present, on an overflow list, 
    1:     // or there are none so we'll create them now
    1:     MoveOverflowToChildList(aPresContext);
    1:   }
    1: 
    1:   // Use longs to get more-aligned space.
    1:   #define LONGS_IN_HTMLRS \
    1:     ((sizeof(nsHTMLReflowState) + sizeof(long) - 1) / sizeof(long))
    1:   long captionRSSpace[LONGS_IN_HTMLRS];
12308:   nsHTMLReflowState *captionRS =
12308:     static_cast<nsHTMLReflowState*>((void*)captionRSSpace);
12309:   long innerRSSpace[LONGS_IN_HTMLRS];
12309:   nsHTMLReflowState *innerRS =
12309:     static_cast<nsHTMLReflowState*>((void*) innerRSSpace);
12309: 
13804:   nsRect origInnerRect = mInnerTableFrame->GetRect();
55037:   nsRect origInnerVisualOverflow = mInnerTableFrame->GetVisualOverflowRect();
13804:   PRBool innerFirstReflow =
13804:     (mInnerTableFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW) != 0;
13804:   nsRect origCaptionRect;
55037:   nsRect origCaptionVisualOverflow;
13804:   PRBool captionFirstReflow;
13804:   if (mCaptionFrame) {
13804:     origCaptionRect = mCaptionFrame->GetRect();
55037:     origCaptionVisualOverflow = mCaptionFrame->GetVisualOverflowRect();
13804:     captionFirstReflow =
13804:       (mCaptionFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW) != 0;
13804:   }
13804:   
12402:   // ComputeAutoSize has to match this logic.
12309:   if (captionSide == NO_SIDE) {
12309:     // We don't have a caption.
12309:     OuterBeginReflowChild(aPresContext, mInnerTableFrame, aOuterRS,
12309:                           innerRSSpace, aOuterRS.ComputedWidth());
12309:   } else if (captionSide == NS_STYLE_CAPTION_SIDE_LEFT ||
12309:              captionSide == NS_STYLE_CAPTION_SIDE_RIGHT) {
12309:     // nsTableCaptionFrame::ComputeAutoSize takes care of making side
12309:     // captions small.  Compute the caption's size first, and tell the
12309:     // table to fit in what's left.
12308:     OuterBeginReflowChild(aPresContext, mCaptionFrame, aOuterRS,
12308:                           captionRSSpace, aOuterRS.ComputedWidth());
12309:     nscoord innerAvailWidth = aOuterRS.ComputedWidth() -
12309:       (captionRS->ComputedWidth() + captionRS->mComputedMargin.LeftRight() +
12309:        captionRS->mComputedBorderPadding.LeftRight());
12309:     OuterBeginReflowChild(aPresContext, mInnerTableFrame, aOuterRS,
12309:                           innerRSSpace, innerAvailWidth);
12309: 
12309:   } else if (captionSide == NS_STYLE_CAPTION_SIDE_TOP ||
12309:              captionSide == NS_STYLE_CAPTION_SIDE_BOTTOM) {
12309:     // Compute the table's size first, and then prevent the caption from
12309:     // being wider unless it has to be.
12309:     //
12309:     // Note that CSS 2.1 (but not 2.0) says:
12309:     //   The width of the anonymous box is the border-edge width of the
12309:     //   table box inside it
12309:     // We don't actually make our anonymous box that width (if we did,
12309:     // it would break 'auto' margins), but this effectively does that.
12309:     OuterBeginReflowChild(aPresContext, mInnerTableFrame, aOuterRS,
12309:                           innerRSSpace, aOuterRS.ComputedWidth());
12309:     // It's good that CSS 2.1 says not to include margins, since we
12309:     // can't, since they already been converted so they exactly
12309:     // fill the available width (ignoring the margin on one side if
12312:     // neither are auto).  (We take advantage of that later when we call
12312:     // GetCaptionOrigin, though.)
12309:     nscoord innerBorderWidth = innerRS->ComputedWidth() +
12309:                                innerRS->mComputedBorderPadding.LeftRight();
12309:     OuterBeginReflowChild(aPresContext, mCaptionFrame, aOuterRS,
12309:                           captionRSSpace, innerBorderWidth);
12309:   } else {
12309:     NS_ASSERTION(captionSide == NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE ||
12309:                  captionSide == NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE,
12309:                  "unexpected caption-side");
12309:     // Size the table and the caption independently.
12309:     OuterBeginReflowChild(aPresContext, mCaptionFrame, aOuterRS,
12309:                           captionRSSpace, aOuterRS.ComputedWidth());
12309:     OuterBeginReflowChild(aPresContext, mInnerTableFrame, aOuterRS,
12309:                           innerRSSpace, aOuterRS.ComputedWidth());
12309:   }
12309: 
12309:   // First reflow the caption.
12309:   nsHTMLReflowMetrics captionMet;
12309:   nsSize captionSize;
12309:   nsMargin captionMargin;
12309:   if (mCaptionFrame) {
12309:     nsReflowStatus capStatus; // don't let the caption cause incomplete
12308:     rv = OuterDoReflowChild(aPresContext, mCaptionFrame, *captionRS,
12308:                             captionMet, capStatus);
    1:     if (NS_FAILED(rv)) return rv;
12308:     captionSize.width = captionMet.width;
12308:     captionSize.height = captionMet.height;
12308:     captionMargin = captionRS->mComputedMargin;
74400:     // Now that we know the height of the caption, reduce the available height
74400:     // for the table frame if we are height constrained and the caption is above
74400:     // or below the inner table.
74400:     if (NS_UNCONSTRAINEDSIZE != aOuterRS.availableHeight) {
74400:       nscoord captionHeight = 0;
74400:       switch (captionSide) {
74400:         case NS_STYLE_CAPTION_SIDE_TOP:
74400:         case NS_STYLE_CAPTION_SIDE_BOTTOM: {
74400:           captionHeight = captionSize.height + captionMargin.TopBottom();
74400:           break;
74400:         }
74400:         case NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE: {
74400:           nsCollapsingMargin belowCaptionMargin;
74400:           belowCaptionMargin.Include(captionMargin.bottom);
74400:           belowCaptionMargin.Include(innerRS->mComputedMargin.top);
74400:           captionHeight = captionSize.height + captionMargin.top +
74400:                           belowCaptionMargin.get();
74400:           break;
74400:         }
74400:         case NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE: {
74400:           nsCollapsingMargin aboveCaptionMargin;
74400:           aboveCaptionMargin.Include(captionMargin.top);
74400:           aboveCaptionMargin.Include(innerRS->mComputedMargin.bottom);
74400:           captionHeight = captionSize.height + captionMargin.bottom +
74400:                           aboveCaptionMargin.get();
74400:           break;
74400:         }
74400:       }
74400:       innerRS->availableHeight =
74400:         NS_MAX(0, innerRS->availableHeight - captionHeight);
74400:     }
    1:   } else {
    1:     captionSize.SizeTo(0,0);
    1:     captionMargin.SizeTo(0,0,0,0);
    1:   }
    1: 
    1:   // Then, now that we know how much to reduce the width of the inner
    1:   // table to account for side captions, reflow the inner table.
    1:   nsHTMLReflowMetrics innerMet;
12308:   rv = OuterDoReflowChild(aPresContext, mInnerTableFrame, *innerRS,
12308:                           innerMet, aStatus);
    1:   if (NS_FAILED(rv)) return rv;
12309:   nsSize innerSize;
12308:   innerSize.width = innerMet.width;
12308:   innerSize.height = innerMet.height;
12309:   nsMargin innerMargin = innerRS->mComputedMargin;
    1: 
    1:   nsSize   containSize = GetContainingBlockSize(aOuterRS);
    1: 
    1:   // Now that we've reflowed both we can place them.
    1:   // XXXldb Most of the input variables here are now uninitialized!
    1: 
    1:   // XXX Need to recompute inner table's auto margins for the case of side
    1:   // captions.  (Caption's are broken too, but that should be fixed earlier.)
    1: 
    1:   if (mCaptionFrame) {
    1:     nsPoint captionOrigin;
    1:     GetCaptionOrigin(captionSide, containSize, innerSize, 
    1:                      innerMargin, captionSize, captionMargin, captionOrigin);
    1:     FinishReflowChild(mCaptionFrame, aPresContext, captionRS, captionMet,
    1:                       captionOrigin.x, captionOrigin.y, 0);
    1:     captionRS->~nsHTMLReflowState();
    1:   }
    1:   // XXX If the height is constrained then we need to check whether
    1:   // everything still fits...
    1: 
    1:   nsPoint innerOrigin;
    1:   GetInnerOrigin(captionSide, containSize, captionSize, 
    1:                  captionMargin, innerSize, innerMargin, innerOrigin);
    1:   FinishReflowChild(mInnerTableFrame, aPresContext, innerRS, innerMet,
    1:                     innerOrigin.x, innerOrigin.y, 0);
    1:   innerRS->~nsHTMLReflowState();
    1: 
13804:   nsTableFrame::InvalidateFrame(mInnerTableFrame, origInnerRect,
55037:                                 origInnerVisualOverflow, innerFirstReflow);
13804:   if (mCaptionFrame) {
13804:     nsTableFrame::InvalidateFrame(mCaptionFrame, origCaptionRect,
55037:                                   origCaptionVisualOverflow,
55037:                                   captionFirstReflow);
13804:   }
13804: 
    1:   UpdateReflowMetrics(captionSide, aDesiredSize, innerMargin, captionMargin);
    1:   
    1:   // Return our desired rect
    1: 
    1:   NS_FRAME_SET_TRUNCATION(aStatus, aOuterRS, aDesiredSize);
    1:   return rv;
    1: }
    1: 
    1: nsIAtom*
    1: nsTableOuterFrame::GetType() const
    1: {
    1:   return nsGkAtoms::tableOuterFrame;
    1: }
    1: 
    1: /* ----- global methods ----- */
    1: 
    1: /*------------------ nsITableLayout methods ------------------------------*/
    1: NS_IMETHODIMP 
    1: nsTableOuterFrame::GetCellDataAt(PRInt32 aRowIndex, PRInt32 aColIndex, 
    1:                                  nsIDOMElement* &aCell,   //out params
    1:                                  PRInt32& aStartRowIndex, PRInt32& aStartColIndex, 
    1:                                  PRInt32& aRowSpan, PRInt32& aColSpan,
    1:                                  PRInt32& aActualRowSpan, PRInt32& aActualColSpan,
    1:                                  PRBool& aIsSelected)
    1: {
11311:   NS_ASSERTION(mInnerTableFrame, "no inner table frame yet?");
11311:   
11315:   return mInnerTableFrame->GetCellDataAt(aRowIndex, aColIndex, aCell,
    1:                                         aStartRowIndex, aStartColIndex, 
11311:                                         aRowSpan, aColSpan, aActualRowSpan,
11311:                                         aActualColSpan, aIsSelected);
    1: }
    1: 
11311: NS_IMETHODIMP
11311: nsTableOuterFrame::GetTableSize(PRInt32& aRowCount, PRInt32& aColCount)
    1: {
11311:   NS_ASSERTION(mInnerTableFrame, "no inner table frame yet?");
11311: 
11315:   return mInnerTableFrame->GetTableSize(aRowCount, aColCount);
    1: }
11311: 
11311: NS_IMETHODIMP
11311: nsTableOuterFrame::GetIndexByRowAndColumn(PRInt32 aRow, PRInt32 aColumn,
11311:                                           PRInt32 *aIndex)
11311: {
11311:   NS_ENSURE_ARG_POINTER(aIndex);
11311: 
11311:   NS_ASSERTION(mInnerTableFrame, "no inner table frame yet?");
11311:   return mInnerTableFrame->GetIndexByRowAndColumn(aRow, aColumn, aIndex);
11311: }
11311: 
11311: NS_IMETHODIMP
11311: nsTableOuterFrame::GetRowAndColumnByIndex(PRInt32 aIndex,
11311:                                           PRInt32 *aRow, PRInt32 *aColumn)
11311: {
11311:   NS_ENSURE_ARG_POINTER(aRow);
11311:   NS_ENSURE_ARG_POINTER(aColumn);
11311: 
11311:   NS_ASSERTION(mInnerTableFrame, "no inner table frame yet?");
11311:   return mInnerTableFrame->GetRowAndColumnByIndex(aIndex, aRow, aColumn);
    1: }
    1: 
    1: /*---------------- end of nsITableLayout implementation ------------------*/
    1: 
    1: 
    1: nsIFrame*
    1: NS_NewTableOuterFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsTableOuterFrame(aContext);
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsTableOuterFrame)
32423: 
    1: #ifdef DEBUG
    1: NS_IMETHODIMP
    1: nsTableOuterFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("TableOuter"), aResult);
    1: }
    1: #endif
    1: 
