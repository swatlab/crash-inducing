16299: /*
16299:    Copyright (C) 2003 Commonwealth Scientific and Industrial Research
16299:    Organisation (CSIRO) Australia
16299: 
16299:    Redistribution and use in source and binary forms, with or without
16299:    modification, are permitted provided that the following conditions
16299:    are met:
16299: 
16299:    - Redistributions of source code must retain the above copyright
16299:    notice, this list of conditions and the following disclaimer.
16299: 
16299:    - Redistributions in binary form must reproduce the above copyright
16299:    notice, this list of conditions and the following disclaimer in the
16299:    documentation and/or other materials provided with the distribution.
16299: 
16299:    - Neither the name of CSIRO Australia nor the names of its
16299:    contributors may be used to endorse or promote products derived from
16299:    this software without specific prior written permission.
16299: 
16299:    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
16299:    ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
16299:    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
16299:    PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE ORGANISATION OR
16299:    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
16299:    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
16299:    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
16299:    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
16299:    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
16299:    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
16299:    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
16299: */
16299: 
16299: /*
16299:  * oggplay_callback.c
16299:  *
16299:  * Shane Stephens <shane.stephens@annodex.net>
16299:  */
16299: #include "oggplay_private.h"
16299: 
16299: #define TIME_THEORA_DECODE 0
16299: 
16299: #include <stdlib.h>
16299: #if TIME_THEORA_DECODE
16299: #include <sys/time.h>
16299: #endif
16299: #include <time.h>
16299: #include <string.h>
16299: 
16299: void
16299: oggplay_init_theora(void *user_data) {
16299: 
16299:   OggPlayTheoraDecode   * decoder     = (OggPlayTheoraDecode *)user_data;
16299: 
16299:   theora_info_init(&(decoder->video_info));
16299:   theora_comment_init(&(decoder->video_comment));
16299:   decoder->remaining_header_packets = 3;
16299:   decoder->granulepos_seen = 0;
16299:   decoder->frame_delta = 0;
16299:   decoder->y_width = 0;
26904:   decoder->convert_to_rgb = 0;
16299:   decoder->decoder.decoded_type = OGGPLAY_YUV_VIDEO;
16299: }
16299: 
16299: void
16299: oggplay_shutdown_theora(void *user_data) {
16299: 
16299:   OggPlayTheoraDecode   * decoder = (OggPlayTheoraDecode *)user_data;
16299: 
16299:   if (decoder->remaining_header_packets == 0) {
16299:     theora_clear(&(decoder->video_handle));
16299:   }
16299:   theora_info_clear(&(decoder->video_info));
16299:   theora_comment_clear(&(decoder->video_comment));
16299: }
16299: 
16299: int
16299: oggplay_callback_theora (OGGZ * oggz, ogg_packet * op, long serialno,
16299:                 void * user_data) {
16299: 
16299:   OggPlayTheoraDecode   * decoder     = (OggPlayTheoraDecode *)user_data;
16299:   OggPlayDecode         * common      = &(decoder->decoder);
16299:   ogg_int64_t             granulepos  = oggz_tell_granulepos(oggz);
16299:   yuv_buffer              buffer;
16299:   int granuleshift;
16299:   long frame;
16299: 
16299: #if TIME_THEORA_DECODE
16299:   struct timeval          tv;
16299:   struct timeval          tv2;
16299:   int                     musec;
16299: #endif
16299: 
28620:   if ( (granulepos > 0) && (common->last_granulepos > granulepos)) {
28620:     /* 
28620:      * the granule position is not monotonically increasing,
28620:      * something wrong with the page!
28620:      * skipping this page..... 
28620:      */
28620:     return 0;
28620:   }
28620: 
16299:   /*
16299:    * always decode headers
16299:    */
16299:   if (theora_packet_isheader(op)) {
16343:     if (theora_decode_header(&(decoder->video_info), &(decoder->video_comment), op) < 0)
16343:       return -1;
16343: 
16299:     /*
16299:      * initialise width/stride/height data (this is common to all frames).
16299:      * Use the buffer stride for the width to avoid passing negative stride
16299:      * issues on to the user.
16299:      */
16299:     decoder->y_width = decoder->y_stride = decoder->video_info.frame_width;
16299:     decoder->y_height = decoder->video_info.frame_height;
16299:     decoder->uv_width = decoder->uv_stride = decoder->video_info.frame_width / 2;
16299:     decoder->uv_height = decoder->video_info.frame_height / 2;
30419:   
30419:     if (decoder->y_width == 0 ||
30419:         decoder->y_height == 0 || 
30419:         decoder->uv_width == 0 ||
30419:         decoder->uv_height == 0) {
30419:       decoder->decoder.active = 0;
30419:       return 0;
30419:     }
30419:     
16299:     if (--(decoder->remaining_header_packets) == 0) {
28472:       /* Ensure the offsets do not push the viewable area outside of the decoded frame. */
28472:       if (((decoder->video_info.height - decoder->video_info.offset_y)<decoder->video_info.frame_height)||
28472:           ((decoder->video_info.width - decoder->video_info.offset_x)<decoder->video_info.frame_width))
28472:           return -1;
28472:           
16299:       theora_decode_init(&(decoder->video_handle), &(decoder->video_info));
16299:     }
16299:     return 0;
16299:   }
16343:   else if (decoder->remaining_header_packets != 0) {
16343:     /*
16343:      * Invalid Ogg file. Missing headers
16343:      *
16343:      */
16343:     return -1;
16343:   }
16299: 
16299:   if (!decoder->decoder.active) {
16299:     /*
16299:      * don't decode other packets
16299:      */
16299:     return 0;
16299:   }
16299: 
16299:   /*
16299:    * if we get to here then we've passed all the header packets
16299:    */
16299:   if (common->current_loc == -1)
16299:     common->current_loc = 0;
16299: 
16299:   /*
16299:    * Decode the frame
16299:    */
16299: 
16299: #if TIME_THEORA_DECODE
16299:   gettimeofday(&tv, NULL);
16299: #endif
16299: 
16343:   if (theora_decode_packetin(&(decoder->video_handle), op) < 0)
16343:     return -1;
16343: 
16343:   if (theora_decode_YUVout(&(decoder->video_handle), &buffer) < 0)
16343:     return -1;
16299: 
16299: #if TIME_THEORA_DECODE
16299:   gettimeofday(&tv2, NULL);
16299:   musec = tv2.tv_usec - tv.tv_usec;
16299:   if (tv2.tv_sec > tv.tv_sec)
16299:     musec += (tv2.tv_sec - tv.tv_sec) * 1000000;
16299:   printf("decode took %dus\n", musec);
16299: #endif
16299: 
16299:   if (granulepos != -1) {
28620:     /* 
28620:      * save last granule position in order to be able to validate
28620:      * that it's monotonically increasing
28620:      */
28620:     common->last_granulepos = granulepos;
28620: 
28620:     /* calculate the frame number */
16299:     granuleshift = oggz_get_granuleshift(oggz, serialno);
16299:     frame = (granulepos >> granuleshift);
16299:     frame += (granulepos & ((1 << granuleshift) - 1));
28620:     
28620:     /* calculate the current location in the stream */
16299:     common->current_loc = frame * common->granuleperiod;    
16299:   } else {
16299:     common->current_loc = -1;
16299:   }
16299: 
16299:   if
16299:   (
16299:     (common->current_loc == -1)
16299:     ||
16299:     (common->current_loc >= common->player->presentation_time)
16299:   )
16299:   {
16299:     /*
16299:      * store the frame,
16299:      * use the buffer stride for the width to avoid passing negative stride
16299:      * issues on to the user.
16299:      * */
16299:     oggplay_data_handle_theora_frame(decoder, &buffer);
16299:   }
16299: 
16299:   if (op->e_o_s) {
16299:     common->active = 0;
16299:     common->player->active_tracks--;
16299:   }
16299: 
16299:   return 0;
16299: 
16299: }
16299: 
16299: void
16299: oggplay_init_cmml (void * user_data) {
16299: 
16299:   OggPlayCmmlDecode * decoder = (OggPlayCmmlDecode *)user_data;
16299:   decoder->decoder.decoded_type = OGGPLAY_CMML;
16299:   decoder->granuleshift = 32; /* default */
16299: }
16299: 
16299: int
16299: oggplay_callback_cmml (OGGZ * oggz, ogg_packet * op, long serialno,
16299:                 void * user_data) {
16299: 
16299:   OggPlayCmmlDecode * decoder     = (OggPlayCmmlDecode *)user_data;
16299:   OggPlayDecode     * common      = &(decoder->decoder);
16299:   ogg_int64_t         granulepos  = oggz_tell_granulepos (oggz);
16299: 
16299:   if (granulepos == 0) {
16299:     if (memcmp(op->packet, "CMML\0\0\0\0", 8) == 0) {
16299:       decoder->granuleshift = op->packet[28];
16299:     }
16299:   } else {
16299: 
16299:     if (decoder->granuleshift > 0) {
16299:       granulepos >>= decoder->granuleshift;
16299:     }
16299: 
16299:     common->current_loc = granulepos * common->granuleperiod;
29219:     common->last_granulepos = granulepos;
16299: 
16299:     oggplay_data_handle_cmml_data (&(decoder->decoder), op->packet, op->bytes);
16299:   }
16299: 
16299:   return 0;
16299: 
16299: }
16299: 
16299: void
16299: oggplay_init_skel (void * user_data) {
16299: 
16299:   OggPlaySkeletonDecode * decoder = (OggPlaySkeletonDecode *)user_data;
16299: 
16299:   decoder->presentation_time = 0;
16299:   decoder->base_time = 0;
16299: }
16299: 
16299: static inline unsigned long extract_int32(unsigned char *data) {
16299:   return data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24);
16299: }
16299: 
16299: static inline ogg_int64_t extract_int64(unsigned char *data) {
16299:   return ((ogg_int64_t)(extract_int32(data))) |
16299:          (((ogg_int64_t)(extract_int32(data + 4))) << 32);
16299: }
16299: 
16299: int
16299: oggplay_callback_skel (OGGZ * oggz, ogg_packet * op, long serialno,
16299:                 void * user_data) {
16299: 
16299:   OggPlaySkeletonDecode * decoder = (OggPlaySkeletonDecode *)user_data;
16299: 
16299:   if (strncmp((char *)op->packet, "fishead", 7) == 0) {
16299:     ogg_int64_t pt_num, pt_den, bt_num, bt_den;
16299: 
16299:     pt_num = extract_int64(op->packet + 12);
16299:     pt_den = extract_int64(op->packet + 20);
16299:     bt_num = extract_int64(op->packet + 28);
16299:     bt_den = extract_int64(op->packet + 36);
16299: 
16608:     if (pt_den != 0) {
26904:       decoder->presentation_time = OGGPLAY_TIME_INT_TO_FP(pt_num) / pt_den;
16608:     } else {
16608:       decoder->presentation_time = 0;
16608:     }
16608:     if (bt_den != 0) {
26904:       decoder->base_time = OGGPLAY_TIME_INT_TO_FP(bt_num) / bt_den;
16608:     } else {
16608:       decoder->base_time = 0;
16608:     }
16299: 
16299:     /* initialise the presentation times in the player to the values recorded in the skeleton */
16299:     decoder->decoder.player->presentation_time = decoder->presentation_time;
16299:   } else {
16299:     int i;
16299:     long          preroll       = extract_int32(op->packet + 44);
16299:     long          serialno      = extract_int32(op->packet + 12);
16299:     //ogg_int64_t   start_granule = extract_int64(op->packet + 36);
16299: 
16299:     for (i = 1; i < decoder->decoder.player->num_tracks; i++) {
16299:       if (decoder->decoder.player->decode_data[i]->serialno == serialno) {
16299:         decoder->decoder.player->decode_data[i]->preroll = preroll;
16299:         break;
16299:       }
16299:     }
16299:   }
16299: 
16299:   return 0;
16299: 
16299: }
16299: 
16299: int
16299: oggplay_fish_sound_callback_floats(FishSound * fsound, float ** pcm, 
16299:                                           long frames, void *user_data) {
16299: 
16299:   OggPlayAudioDecode *decoder = (OggPlayAudioDecode *)user_data;
16299:   OggPlayDecode *common = &(decoder->decoder);
16299: 
16299:   /*
16299:    * calculate the current location here so that it's only updated when
16299:    * audio data is actually available for processing
16299:    */
16299:   if (common->last_granulepos > 0) {
16299:     common->current_loc = common->last_granulepos * common->granuleperiod;
16299:   } else {
16299:     common->current_loc = -1;
16299:   }
16299: 
16299:   if
16299:   (
16299:     (common->current_loc == -1)
16299:     ||
16299:     (common->current_loc >= common->player->presentation_time)
16299:   )
16299:   {
16299: 
16299: 
16299:     /*
16299:      * store the frame
16299:      */
16299:     oggplay_data_handle_audio_data(&(decoder->decoder), (short *)pcm, frames,
16299:               sizeof(float));
25830: 
25830:       return FISH_SOUND_STOP_ERR;
16299:   }
16299: 
16299:   return FISH_SOUND_CONTINUE;
16299: }
16299: 
16299: void
16299: oggplay_init_audio (void * user_data) {
16299: 
16299:   OggPlayAudioDecode  * decoder = (OggPlayAudioDecode *)user_data;
16299: 
16299:   decoder->sound_handle = fish_sound_new(FISH_SOUND_DECODE,
16299:                                                       &(decoder->sound_info));
16299: 
16299:   decoder->sound_info.channels = 0;
16299:   fish_sound_set_interleave(decoder->sound_handle, 1);
16299:   fish_sound_set_decoded_float_ilv(decoder->sound_handle,
16299:                                       oggplay_fish_sound_callback_floats,
16299:                                       (void *)decoder);
16299: 
16299:   decoder->decoder.decoded_type = OGGPLAY_FLOATS_AUDIO;
16299: }
16299: 
16299: void
16299: oggplay_shutdown_audio(void *user_data) {
16299: 
16299:   OggPlayAudioDecode   * decoder = (OggPlayAudioDecode *)user_data;
16299: 
16299:   fish_sound_delete(decoder->sound_handle);
16299: 
16299: }
16299: 
16299: int
16299: oggplay_callback_audio (OGGZ * oggz, ogg_packet * op, long serialno,
16299:                 void * user_data) {
16299: 
16299:   OggPlayAudioDecode   * decoder     = (OggPlayAudioDecode *)user_data;
16299:   OggPlayDecode        * common      = &(decoder->decoder);
16299:   ogg_int64_t            granulepos  = oggz_tell_granulepos(oggz);
16299: 
16299:   if (granulepos > 0 && (!decoder->decoder.active)) {
16299:     return 0;
16299:   }
16299: 
16299:   common->last_granulepos = granulepos;
16299: 
16299:   fish_sound_prepare_truncation (decoder->sound_handle, op->granulepos,
16299:                                                                 op->e_o_s);
29219:   if (fish_sound_decode (decoder->sound_handle, op->packet, op->bytes) == -1) {
28870:     // Unrecoverable error, disable track
28870:     op->e_o_s = 1;
28870:     common->active = 0;
28870:     common->player->active_tracks--;
28870:     return OGGZ_ERR_HOLE_IN_DATA;
28870:   }
16299: 
16299:   if (decoder->sound_info.channels == 0) {
16299:     fish_sound_command(decoder->sound_handle, FISH_SOUND_GET_INFO,
16299:                     &(decoder->sound_info), sizeof(FishSoundInfo));
16299:   }
16299: 
16299:   if (op->e_o_s) {
16299:     common->active = 0;
16299:     common->player->active_tracks--;
16299:   }
16299: 
16299:   return 0;
16299: }
16299: 
16299: void
16299: oggplay_init_kate(void *user_data) {
16299: 
16299: #ifdef HAVE_KATE
26904:   int ret;
16299:   OggPlayKateDecode   * decoder     = (OggPlayKateDecode *)user_data;
16299: 
26904:   decoder->init = 0;
26904:   ret = kate_high_decode_init(&(decoder->k));
26904:   if (ret < 0) {
26904:     /* what to do ? */
26904:   }
26904:   else {
26904:     decoder->init = 1;
26904:   }
16299:   decoder->decoder.decoded_type = OGGPLAY_KATE;
26904: 
26904: #ifdef HAVE_TIGER
26904:   decoder->use_tiger = 1;
26904:   decoder->overlay_dest = -1;
26904: 
26904:   ret = tiger_renderer_create(&(decoder->tr));
26904:   if (ret < 0) {
26904:     /* what to do ? */
26904:     decoder->tr = NULL;
26904:   }
26904:   if (decoder->use_tiger) {
26904:     decoder->decoder.decoded_type = OGGPLAY_RGBA_VIDEO;
26904:   }
26904: #endif
26904: 
16299: #endif
16299: }
16299: 
16299: void
16299: oggplay_shutdown_kate(void *user_data) {
16299: 
16299: #ifdef HAVE_KATE
16299:   OggPlayKateDecode   * decoder = (OggPlayKateDecode *)user_data;
16299: 
26904: #ifdef HAVE_TIGER
26904:   if (decoder->tr) {
26904:     tiger_renderer_destroy(decoder->tr);
26904:   }
26904: #endif
26904: 
26904:   if (decoder->init) {
16299:     kate_high_decode_clear(&(decoder->k));
26904:   }
16299: #endif
16299: }
16299: 
16299: int
16299: oggplay_callback_kate (OGGZ * oggz, ogg_packet * op, long serialno,
16299:                 void * user_data) {
16299: 
16299: #ifdef HAVE_KATE
16299:   OggPlayKateDecode     * decoder     = (OggPlayKateDecode *)user_data;
16299:   OggPlayDecode         * common      = &(decoder->decoder);
16299:   ogg_int64_t             granulepos  = oggz_tell_granulepos(oggz);
16299:   int                     granuleshift;
16299:   ogg_int64_t             base, offset;
16299:   kate_packet kp;
16299:   const kate_event *ev = NULL;
16299:   int ret;
16299: 
26904:   if (!decoder->init) {
26904:     return E_OGGPLAY_UNINITIALISED;
26904:   }
26904: 
16299:   kate_packet_wrap(&kp, op->bytes, op->packet);
16299:   ret = kate_high_decode_packetin(&(decoder->k), &kp, &ev);
26904:   if (ret < 0) {
26904:     return E_OGGPLAY_BAD_INPUT;
26904:   }
16299: 
16299:   if (granulepos != -1) {
16299:     granuleshift = oggz_get_granuleshift(oggz, serialno);
16299:     base = (granulepos >> granuleshift);
16299:     offset = granulepos - (base << granuleshift);
16299:     common->current_loc = (base+offset) * common->granuleperiod;
29219:     common->last_granulepos = granulepos;
16299:   } else {
16299:     common->current_loc = -1;
16299:   }
16299: 
16299:   if
16299:   (
16299:     (common->current_loc == -1)
16299:     ||
16299:     (common->current_loc >= common->player->presentation_time)
16299:   )
16299:   {
16299:     /*
16299:      * process the data from the packet
16299:      * */
16299:     if (ev) {
16299:       oggplay_data_handle_kate_data(decoder, ev);
16299:     }
16299:   }
16299: 
16299:   if (op->e_o_s) {
16299:     common->active = 0;
16299:   }
16299: 
16299: #endif
16299: 
16299:   return 0;
16299: 
16299: }
16299: 
16299: OggPlayCallbackFunctions callbacks[] = {
16299:   {oggplay_init_theora, oggplay_callback_theora, oggplay_shutdown_theora,
16299:         sizeof(OggPlayTheoraDecode)},        /* THEORA */
16299:   {oggplay_init_audio, oggplay_callback_audio, oggplay_shutdown_audio,
16299:         sizeof(OggPlayAudioDecode)},         /* VORBIS */
16299:   {oggplay_init_audio, oggplay_callback_audio, oggplay_shutdown_audio,
16299:         sizeof(OggPlayAudioDecode)},         /* SPEEX */
16299:   {NULL, NULL, NULL, sizeof(OggPlayDecode)}, /* PCM */
16299:   {oggplay_init_cmml, oggplay_callback_cmml, NULL, sizeof(OggPlayCmmlDecode)},
16299:   {NULL, NULL, NULL, sizeof(OggPlayDecode)}, /* ANX2 */
16299:   {oggplay_init_skel, oggplay_callback_skel, NULL,
16299:         sizeof(OggPlaySkeletonDecode)},
16299:   {NULL, NULL, NULL, sizeof(OggPlayDecode)}, /* FLAC0 */
16299:   {NULL, NULL, NULL, sizeof(OggPlayDecode)}, /* FLAC */
16299:   {NULL, NULL, NULL, sizeof(OggPlayDecode)}, /* ANXDATA */
16299:   {NULL, NULL, NULL, sizeof(OggPlayDecode)}, /* CELT */
16299:   {oggplay_init_kate, oggplay_callback_kate, oggplay_shutdown_kate,
16299:         sizeof(OggPlayKateDecode)},          /* KATE */
28360:   {NULL, NULL, NULL, sizeof(OggPlayDecode)}, /* DIRAC */
16299:   {NULL, NULL, NULL, sizeof(OggPlayDecode)}  /* UNKNOWN */
16299: };
16299: 
16299: OggPlayDecode *
16299: oggplay_initialise_decoder(OggPlay *me, int content_type, int serialno) {
16299: 
16299:   ogg_int64_t    num;
16299:   ogg_int64_t    denom;
25830:   OggPlayDecode *decoder = NULL;
16299: 
25830:   if (me == NULL)
25830:     return NULL;
25830: 
25830:   decoder = oggplay_malloc (callbacks[content_type].size);
25830: 
25830:   if (decoder == NULL)
25830:     return NULL;
16299: 
16299:   decoder->serialno = serialno;
16299:   decoder->content_type = content_type;
16299:   decoder->content_type_name =
16299:           oggz_stream_get_content_type (me->oggz, serialno);
28621:   decoder->active = 0;
16299:   decoder->final_granulepos = -1;
16299:   decoder->player = me;
16299:   decoder->decoded_type = OGGPLAY_TYPE_UNKNOWN;
16299: 
16299:   /*
16299:    * set the StreamInfo to unitialised until we get some real data in
16299:    */
16299:   decoder->stream_info = OGGPLAY_STREAM_UNINITIALISED;
16299: 
16299:   /*
16299:    * set to -1 until headers decoded
16299:    */
16299:   decoder->current_loc = -1;
29219:   decoder->last_granulepos = -1;
16299: 
16299:   /*
16299:    * the offset is how far advanced or delayed this track is to the "standard"
16299:    * time position.  An offset of 1000, for example, indicates that data for
16299:    * this track arrives 1 second in advance of data for other tracks
16299:    */
16299:   decoder->offset = 0;
16299: 
16299:   oggz_get_granulerate(me->oggz, serialno, &num, &denom);
16299: 
16299:   /*
16299:    * convert num and denom to a 32.32 fixed point value
16299:    */
16608:   if (num != 0) {
26904:     decoder->granuleperiod = OGGPLAY_TIME_INT_TO_FP(denom) / num;
16608:   } else {
16608:     decoder->granuleperiod = 0;
16608:   }
16299: 
16299:   if (callbacks[content_type].init != NULL) {
16299:     callbacks[content_type].init(decoder);
16299:   }
16299: 
16299:   oggplay_data_initialise_list(decoder);
16299: 
16299:   return decoder;
16299: }
16299: 
16299: 
16299: /*
16299:  * this function needs to be called on each track to clear up allocated memory
16299:  */
16299: void
16299: oggplay_callback_shutdown(OggPlayDecode *decoder) {
16299: 
16299:   if (callbacks[decoder->content_type].shutdown != NULL) {
16299:     callbacks[decoder->content_type].shutdown(decoder);
16299:   }
16299: 
16299:   oggplay_data_shutdown_list(decoder);
16299: 
25830:   oggplay_free(decoder);
16299: }
16299: 
16299: 
16299: /*
16299:  * this is the callback that is used before all track types have been
16299:  * determined - i.e. at the beginning of an ogg bitstream or at the start
16299:  * of a new chain
16299:  */
16299: int
16299: oggplay_callback_predetected (OGGZ *oggz, ogg_packet *op, long serialno,
16299:                 void *user_data) {
16299: 
16299:   OggPlay     * me;
16299:   int           i;
16299:   int           content_type  = 0;
16299: 
16299:   me = (OggPlay *)user_data;
16299:   content_type = oggz_stream_get_content (me->oggz, serialno);
16299: 
16299:   /*
16299:    * if we encounter a serialno for the second time, then we've reached the
16299:    * end of the b_o_s packets
16299:    */
16299:   for (i = 0; i < me->num_tracks; i++) {
16299:     if (serialno == me->decode_data[i]->serialno) {
29344:       int ret = 0;
16299:       
16299:       /*
16299:        * call appropriate callback
16299:        */
16299:       if (callbacks[content_type].callback != NULL) {
29344:         ret = callbacks[content_type].callback(oggz, op, serialno,
16299:                                                me->decode_data[i]);
16299:       }
16299: 
29219:       if 
29219:       (
29219:         (op->granulepos >= 0) 
29219:         ||
29219:         (op->granulepos == -1 && me->decode_data[i]->last_granulepos != -1)
29219:       )
29219:       {
16299:         /*
16299:          * set up all the other callbacks
16299:          */
16299:         for (i = 0; i < me->num_tracks; i++) {
16299:           serialno = me->decode_data[i]->serialno;
16299:           content_type = oggz_stream_get_content (me->oggz, serialno);
16299:           oggz_set_read_callback(me->oggz, serialno,
16299:                           callbacks[content_type].callback, me->decode_data[i]);
16299:         }
16299: 
16299:         /*
16299:          * destroy this callback
16299:          */
16299:         oggz_set_read_callback (me->oggz, -1, NULL, NULL);
29219:         me->all_tracks_initialised = 1;
29219:       }
16299: 
29344:       return ret < 0 ? OGGZ_ERR_HOLE_IN_DATA : ret;
16299:     }
16299:   }
16299: 
25830:   me->callback_info = oggplay_realloc (me->callback_info,
16299:                   sizeof (OggPlayCallbackInfo) * ++me->num_tracks);
25830:   if (me->callback_info == NULL)
25830:     return -1;
25830: 
25830:   me->decode_data = oggplay_realloc (me->decode_data, sizeof (long) * me->num_tracks);
25830:   if (me->decode_data == NULL)
25830:     return -1;
25830: 
16299:   me->decode_data[me->num_tracks - 1] = oggplay_initialise_decoder(me,
16299:                                                       content_type, serialno);
25830:   if (me->decode_data[me->num_tracks - 1] == NULL)
25830:     return -1; 
25830: 
16299:   /*me->decode_data->callback_info = me->callback_info + (me->num_tracks - 1);*/
16299: 
16299:   /*
16299:    * call appropriate callback
16299:    */
16299:   if (callbacks[content_type].callback != NULL) {
29342:     return callbacks[content_type].callback(oggz, op, serialno,
16299:                                             me->decode_data[me->num_tracks - 1]);
16299:   }
16299: 
16299:   return 0;
16299: 
16299: }
