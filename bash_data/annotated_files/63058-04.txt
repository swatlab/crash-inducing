47361: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
47361: /* ***** BEGIN LICENSE BLOCK *****
47361:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
47361:  *
47361:  * The contents of this file are subject to the Mozilla Public License Version
47361:  * 1.1 (the "License"); you may not use this file except in compliance with
47361:  * the License. You may obtain a copy of the License at
47361:  * http://www.mozilla.org/MPL/
47361:  *
47361:  * Software distributed under the License is distributed on an "AS IS" basis,
47361:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
47361:  * for the specific language governing rights and limitations under the
47361:  * License.
47361:  *
47361:  * The Original Code is mozilla.org code.
47361:  *
47361:  * The Initial Developer of the Original Code is
47361:  * Netscape Communications Corporation.
47361:  * Portions created by the Initial Developer are Copyright (C) 1998
47361:  * the Initial Developer. All Rights Reserved.
47361:  *
47361:  * Contributor(s):
47361:  *   Sean Echevarria <sean@beatnik.com>
47361:  *   HÃ¥kan Waara <hwaara@chello.se>
47361:  *   Josh Aas <josh@mozilla.com>
47361:  *
47361:  * Alternatively, the contents of this file may be used under the terms of
47361:  * either the GNU General Public License Version 2 or later (the "GPL"), or
47361:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
47361:  * in which case the provisions of the GPL or the LGPL are applicable instead
47361:  * of those above. If you wish to allow use of your version of this file only
47361:  * under the terms of either the GPL or the LGPL, and not to allow others to
47361:  * use your version of this file under the terms of the MPL, indicate your
47361:  * decision by deleting the provisions above and replace them with the notice
47361:  * and other provisions required by the GPL or the LGPL. If you do not delete
47361:  * the provisions above, a recipient may use your version of this file under
47361:  * the terms of any one of the MPL, the GPL or the LGPL.
47361:  *
47361:  * ***** END LICENSE BLOCK ***** */
47361: 
47361: #include "nsPluginStreamListenerPeer.h"
47361: #include "nsIStreamConverterService.h"
47361: #include "nsIHttpChannel.h"
47361: #include "nsIHttpChannelInternal.h"
47361: #include "nsIFileChannel.h"
47361: #include "nsICachingChannel.h"
47361: #include "nsMimeTypes.h"
47361: #include "nsISupportsPrimitives.h"
47361: #include "nsNetCID.h"
47361: #include "nsPluginLogging.h"
47361: #include "nsIURI.h"
47361: #include "nsPluginHost.h"
47361: #include "nsIByteRangeRequest.h"
63058: #include "nsIMultiPartChannel.h"
47361: #include "nsIInputStreamTee.h"
47361: #include "nsPrintfCString.h"
57651: #include "nsIContentUtils.h"
57651: #include "nsIScriptGlobalObject.h"
57651: #include "nsIDocument.h"
57651: #include "nsIWebNavigation.h"
47361: 
47361: #define MAGIC_REQUEST_CONTEXT 0x01020304
47361: 
47361: // nsPluginByteRangeStreamListener
47361: 
63058: class nsPluginByteRangeStreamListener
63058:   : public nsIStreamListener
63058:   , public nsIInterfaceRequestor
63058: {
47361: public:
47361:   nsPluginByteRangeStreamListener(nsIWeakReference* aWeakPtr);
47361:   virtual ~nsPluginByteRangeStreamListener();
47361:   
47361:   NS_DECL_ISUPPORTS
47361:   NS_DECL_NSIREQUESTOBSERVER
47361:   NS_DECL_NSISTREAMLISTENER
63058:   NS_DECL_NSIINTERFACEREQUESTOR
47361:   
47361: private:
47361:   nsCOMPtr<nsIStreamListener> mStreamConverter;
47361:   nsWeakPtr mWeakPtrPluginStreamListenerPeer;
47361:   PRBool mRemoveMagicNumber;
47361: };
47361: 
63058: NS_IMPL_ISUPPORTS3(nsPluginByteRangeStreamListener,
63058:                    nsIRequestObserver,
63058:                    nsIStreamListener,
63058:                    nsIInterfaceRequestor)
63058: 
47361: nsPluginByteRangeStreamListener::nsPluginByteRangeStreamListener(nsIWeakReference* aWeakPtr)
47361: {
47361:   mWeakPtrPluginStreamListenerPeer = aWeakPtr;
47361:   mRemoveMagicNumber = PR_FALSE;
47361: }
47361: 
47361: nsPluginByteRangeStreamListener::~nsPluginByteRangeStreamListener()
47361: {
47361:   mStreamConverter = 0;
47361:   mWeakPtrPluginStreamListenerPeer = 0;
47361: }
47361: 
63058: /**
63058:  * Unwrap any byte-range requests so that we can check whether the base channel
63058:  * is being tracked properly.
63058:  */
63058: static nsCOMPtr<nsIRequest>
63058: GetBaseRequest(nsIRequest* r)
63058: {
63058:   nsCOMPtr<nsIMultiPartChannel> mp = do_QueryInterface(r);
63058:   if (!mp)
63058:     return r;
63058: 
63058:   nsCOMPtr<nsIChannel> base;
63058:   mp->GetBaseChannel(getter_AddRefs(base));
63058:   return already_AddRefed<nsIRequest>(base.forget());
63058: }
63058: 
47361: NS_IMETHODIMP
47361: nsPluginByteRangeStreamListener::OnStartRequest(nsIRequest *request, nsISupports *ctxt)
47361: {
47361:   nsresult rv;
47361:   
47361:   nsCOMPtr<nsIStreamListener> finalStreamListener = do_QueryReferent(mWeakPtrPluginStreamListenerPeer);
47361:   if (!finalStreamListener)
47361:     return NS_ERROR_FAILURE;
47361:   
63058:   nsPluginStreamListenerPeer *pslp =
63058:     static_cast<nsPluginStreamListenerPeer*>(finalStreamListener.get());
63058: 
63058:   NS_ASSERTION(pslp->mRequests.IndexOfObject(GetBaseRequest(request)) != -1,
63058:                "Untracked byte-range request?");
63058:   
47361:   nsCOMPtr<nsIStreamConverterService> serv = do_GetService(NS_STREAMCONVERTERSERVICE_CONTRACTID, &rv);
47361:   if (NS_SUCCEEDED(rv)) {
47361:     rv = serv->AsyncConvertData(MULTIPART_BYTERANGES,
47361:                                 "*/*",
47361:                                 finalStreamListener,
47361:                                 nsnull,
47361:                                 getter_AddRefs(mStreamConverter));
47361:     if (NS_SUCCEEDED(rv)) {
47361:       rv = mStreamConverter->OnStartRequest(request, ctxt);
47361:       if (NS_SUCCEEDED(rv))
47361:         return rv;
47361:     }
47361:   }
47361:   mStreamConverter = 0;
47361:   
47361:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(request));
47361:   if (!httpChannel) {
47361:     return NS_ERROR_FAILURE;
47361:   }
47361:   
47361:   PRUint32 responseCode = 0;
47361:   rv = httpChannel->GetResponseStatus(&responseCode);
47361:   if (NS_FAILED(rv)) {
47361:     return NS_ERROR_FAILURE;
47361:   }
47361:   
47361:   if (responseCode != 200) {
47361:     PRBool bWantsAllNetworkStreams = PR_FALSE;
47361:     pslp->GetPluginInstance()->
47361:     GetValueFromPlugin(NPPVpluginWantsAllNetworkStreams,
47361:                        (void*)&bWantsAllNetworkStreams);
47361:     if (!bWantsAllNetworkStreams){
47361:       return NS_ERROR_FAILURE;
47361:     }
47361:   }
47361:   
47361:   // if server cannot continue with byte range (206 status) and sending us whole object (200 status)
47361:   // reset this seekable stream & try serve it to plugin instance as a file
47361:   mStreamConverter = finalStreamListener;
47361:   mRemoveMagicNumber = PR_TRUE;
47361:   
47361:   rv = pslp->ServeStreamAsFile(request, ctxt);
47361:   return rv;
47361: }
47361: 
47361: NS_IMETHODIMP
47361: nsPluginByteRangeStreamListener::OnStopRequest(nsIRequest *request, nsISupports *ctxt,
47361:                                                nsresult status)
47361: {
47361:   if (!mStreamConverter)
47361:     return NS_ERROR_FAILURE;
47361:   
47361:   nsCOMPtr<nsIStreamListener> finalStreamListener = do_QueryReferent(mWeakPtrPluginStreamListenerPeer);
47361:   if (!finalStreamListener)
47361:     return NS_ERROR_FAILURE;
47361:   
63058:   nsPluginStreamListenerPeer *pslp =
63058:     static_cast<nsPluginStreamListenerPeer*>(finalStreamListener.get());
63058:   PRBool found = pslp->mRequests.RemoveObject(request);
63058:   if (!found) {
63058:     NS_ERROR("OnStopRequest received for untracked byte-range request!");
63058:   }
63058: 
47361:   if (mRemoveMagicNumber) {
47361:     // remove magic number from container
47361:     nsCOMPtr<nsISupportsPRUint32> container = do_QueryInterface(ctxt);
47361:     if (container) {
47361:       PRUint32 magicNumber = 0;
47361:       container->GetData(&magicNumber);
47361:       if (magicNumber == MAGIC_REQUEST_CONTEXT) {
47361:         // to allow properly finish nsPluginStreamListenerPeer->OnStopRequest()
47361:         // set it to something that is not the magic number.
47361:         container->SetData(0);
47361:       }
47361:     } else {
47361:       NS_WARNING("Bad state of nsPluginByteRangeStreamListener");
47361:     }
47361:   }
47361:   
47361:   return mStreamConverter->OnStopRequest(request, ctxt, status);
47361: }
47361: 
47361: // CachedFileHolder
47361: 
47361: CachedFileHolder::CachedFileHolder(nsIFile* cacheFile)
47361: : mFile(cacheFile)
47361: {
47361:   NS_ASSERTION(mFile, "Empty CachedFileHolder");
47361: }
47361: 
47361: CachedFileHolder::~CachedFileHolder()
47361: {
47361:   mFile->Remove(PR_FALSE);
47361: }
47361: 
47361: void
47361: CachedFileHolder::AddRef()
47361: {
47361:   ++mRefCnt;
47361:   NS_LOG_ADDREF(this, mRefCnt, "CachedFileHolder", sizeof(*this));
47361: }
47361: 
47361: void
47361: CachedFileHolder::Release()
47361: {
47361:   --mRefCnt;
47361:   NS_LOG_RELEASE(this, mRefCnt, "CachedFileHolder");
47361:   if (0 == mRefCnt)
47361:     delete this;
47361: }
47361: 
47361: 
47361: NS_IMETHODIMP
47361: nsPluginByteRangeStreamListener::OnDataAvailable(nsIRequest *request, nsISupports *ctxt,
47361:                                                  nsIInputStream *inStr, PRUint32 sourceOffset, PRUint32 count)
47361: {
47361:   if (!mStreamConverter)
47361:     return NS_ERROR_FAILURE;
47361:   
47361:   nsCOMPtr<nsIStreamListener> finalStreamListener = do_QueryReferent(mWeakPtrPluginStreamListenerPeer);
47361:   if (!finalStreamListener)
47361:     return NS_ERROR_FAILURE;
47361:   
47361:   return mStreamConverter->OnDataAvailable(request, ctxt, inStr, sourceOffset, count);
47361: }
47361: 
63058: NS_IMETHODIMP
63058: nsPluginByteRangeStreamListener::GetInterface(const nsIID& aIID, void** result)
63058: {
63058:   // Forward interface requests to our parent
63058:   nsCOMPtr<nsIInterfaceRequestor> finalStreamListener = do_QueryReferent(mWeakPtrPluginStreamListenerPeer);
63058:   if (!finalStreamListener)
63058:     return NS_ERROR_FAILURE;
63058: 
63058:   return finalStreamListener->GetInterface(aIID, result);
63058: }
63058:     
63058: 
47361: // nsPRUintKey
47361: 
47361: class nsPRUintKey : public nsHashKey {
47361: protected:
47361:   PRUint32 mKey;
47361: public:
47361:   nsPRUintKey(PRUint32 key) : mKey(key) {}
47361:   
47361:   PRUint32 HashCode() const {
47361:     return mKey;
47361:   }
47361:   
47361:   PRBool Equals(const nsHashKey *aKey) const {
47361:     return mKey == ((const nsPRUintKey*)aKey)->mKey;
47361:   }
47361:   nsHashKey *Clone() const {
47361:     return new nsPRUintKey(mKey);
47361:   }
47361:   PRUint32 GetValue() { return mKey; }
47361: };
47361: 
47361: // nsPluginStreamListenerPeer
47361: 
57651: NS_IMPL_ISUPPORTS8(nsPluginStreamListenerPeer,
47361:                    nsIStreamListener,
47361:                    nsIRequestObserver,
47361:                    nsIHttpHeaderVisitor,
47361:                    nsISupportsWeakReference,
47361:                    nsIPluginStreamInfo,
57651:                    nsINPAPIPluginStreamInfo,
57651:                    nsIInterfaceRequestor,
57651:                    nsIChannelEventSink)
47361: 
47361: nsPluginStreamListenerPeer::nsPluginStreamListenerPeer()
47361: {
47361:   mStreamType = NP_NORMAL;
47361:   mStartBinding = PR_FALSE;
47361:   mAbort = PR_FALSE;
47361:   mRequestFailed = PR_FALSE;
47361:   
47361:   mPendingRequests = 0;
47361:   mHaveFiredOnStartRequest = PR_FALSE;
47361:   mDataForwardToRequest = nsnull;
47361:   
47361:   mSeekable = PR_FALSE;
47361:   mModified = 0;
47361:   mStreamOffset = 0;
47361:   mStreamComplete = 0;
47361: }
47361: 
47361: nsPluginStreamListenerPeer::~nsPluginStreamListenerPeer()
47361: {
47361: #ifdef PLUGIN_LOGGING
47361:   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
47361:          ("nsPluginStreamListenerPeer::dtor this=%p, url=%s\n",this, mURLSpec.get()));
47361: #endif
47361: 
60021:   if (mPStreamListener) {
60021:     mPStreamListener->SetStreamListenerPeer(this);
60021:   }
60021: 
47361:   // close FD of mFileCacheOutputStream if it's still open
47361:   // or we won't be able to remove the cache file
47361:   if (mFileCacheOutputStream)
47361:     mFileCacheOutputStream = nsnull;
47361:   
47361:   delete mDataForwardToRequest;
47865: 
47865:   if (mPluginInstance)
60021:     mPluginInstance->FileCachedStreamListeners()->RemoveElement(this);
47361: }
47361: 
47361: // Called as a result of GetURL and PostURL
47361: nsresult nsPluginStreamListenerPeer::Initialize(nsIURI *aURL,
47835:                                                 nsNPAPIPluginInstance *aInstance,
63058:                                                 nsIPluginStreamListener* aListener)
47361: {
47361: #ifdef PLUGIN_LOGGING
47361:   nsCAutoString urlSpec;
47361:   if (aURL != nsnull) aURL->GetAsciiSpec(urlSpec);
47361:   
47361:   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
47361:          ("nsPluginStreamListenerPeer::Initialize instance=%p, url=%s\n", aInstance, urlSpec.get()));
47361:   
47361:   PR_LogFlush();
47361: #endif
47361:   
47361:   mURL = aURL;
47361:   
47835:   mPluginInstance = aInstance;
60021: 
60021:   mPStreamListener = static_cast<nsNPAPIPluginStreamListener*>(aListener);
60021:   mPStreamListener->SetStreamListenerPeer(this);
47361: 
63058:   mPendingRequests = 1;
47361:   
47361:   mDataForwardToRequest = new nsHashtable(16, PR_FALSE);
47361:   if (!mDataForwardToRequest)
47361:     return NS_ERROR_FAILURE;
47361:   
47361:   return NS_OK;
47361: }
47361: 
47361: /* Called by NewEmbeddedPluginStream() - if this is called, we weren't
47361:  * able to load the plugin, so we need to load it later once we figure
47361:  * out the mimetype.  In order to load it later, we need the plugin
47361:  * instance owner.
47361:  */
47361: nsresult nsPluginStreamListenerPeer::InitializeEmbedded(nsIURI *aURL,
47835:                                                         nsNPAPIPluginInstance* aInstance,
47361:                                                         nsIPluginInstanceOwner *aOwner)
47361: {
47361: #ifdef PLUGIN_LOGGING
47361:   nsCAutoString urlSpec;
47361:   aURL->GetSpec(urlSpec);
47361:   
47361:   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
47361:          ("nsPluginStreamListenerPeer::InitializeEmbedded url=%s\n", urlSpec.get()));
47361:   
47361:   PR_LogFlush();
47361: #endif
47361:   
47361:   mURL = aURL;
47361:   
47361:   if (aInstance) {
47835:     NS_ASSERTION(mPluginInstance == nsnull, "nsPluginStreamListenerPeer::InitializeEmbedded mPluginInstance != nsnull");
47835:     mPluginInstance = aInstance;
47361:   } else {
47361:     mOwner = aOwner;
47361:   }
47361:   
48840:   mPendingRequests = 1;
48840:   
47361:   mDataForwardToRequest = new nsHashtable(16, PR_FALSE);
47361:   if (!mDataForwardToRequest)
47361:     return NS_ERROR_FAILURE;
47361:   
47361:   return NS_OK;
47361: }
47361: 
47361: // Called by NewFullPagePluginStream()
47835: nsresult nsPluginStreamListenerPeer::InitializeFullPage(nsIURI* aURL, nsNPAPIPluginInstance *aInstance)
47361: {
47361:   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
47361:              ("nsPluginStreamListenerPeer::InitializeFullPage instance=%p\n",aInstance));
47361:   
47835:   NS_ASSERTION(mPluginInstance == nsnull, "nsPluginStreamListenerPeer::InitializeFullPage mPluginInstance != nsnull");
47835:   mPluginInstance = aInstance;
47361:   
47361:   mURL = aURL;
47361:   
47361:   mDataForwardToRequest = new nsHashtable(16, PR_FALSE);
47361:   if (!mDataForwardToRequest)
47361:     return NS_ERROR_FAILURE;
47361: 
48840:   mPendingRequests = 1;
48840:   
47361:   return NS_OK;
47361: }
47361: 
47361: // SetupPluginCacheFile is called if we have to save the stream to disk.
47361: // the most likely cause for this is either there is no disk cache available
47361: // or the stream is coming from a https server.
47361: //
47361: // These files will be deleted when the host is destroyed.
47361: //
47361: // TODO? What if we fill up the the dest dir?
47361: nsresult
47361: nsPluginStreamListenerPeer::SetupPluginCacheFile(nsIChannel* channel)
47361: {
47361:   nsresult rv = NS_OK;
47361:   
47361:   PRBool useExistingCacheFile = PR_FALSE;
47865:   nsRefPtr<nsPluginHost> pluginHost = dont_AddRef(nsPluginHost::GetInst());
47361: 
47865:   // Look for an existing cache file for the URI.
47965:   nsTArray< nsRefPtr<nsNPAPIPluginInstance> > *instances = pluginHost->InstanceArray();
47965:   for (PRUint32 i = 0; i < instances->Length(); i++) {
47361:     // most recent streams are at the end of list
60021:     nsTArray<nsPluginStreamListenerPeer*> *streamListeners = instances->ElementAt(i)->FileCachedStreamListeners();
60021:     for (PRInt32 i = streamListeners->Length() - 1; i >= 0; --i) {
60021:       nsPluginStreamListenerPeer *lp = streamListeners->ElementAt(i);
47361:       if (lp && lp->mLocalCachedFileHolder) {
47361:         useExistingCacheFile = lp->UseExistingPluginCacheFile(this);
47361:         if (useExistingCacheFile) {
47361:           mLocalCachedFileHolder = lp->mLocalCachedFileHolder;
47361:           break;
47361:         }
47361:       }
47361:       if (useExistingCacheFile)
47361:         break;
47361:     }
47361:   }
47361: 
47865:   // Create a new cache file if one could not be found.
47361:   if (!useExistingCacheFile) {
47361:     nsCOMPtr<nsIFile> pluginTmp;
47361:     rv = nsPluginHost::GetPluginTempDir(getter_AddRefs(pluginTmp));
47361:     if (NS_FAILED(rv)) {
47361:       return rv;
47361:     }
47361:     
47361:     // Get the filename from the channel
47361:     nsCOMPtr<nsIURI> uri;
47361:     rv = channel->GetURI(getter_AddRefs(uri));
47361:     if (NS_FAILED(rv)) return rv;
47361:     
47361:     nsCOMPtr<nsIURL> url(do_QueryInterface(uri));
47361:     if (!url)
47361:       return NS_ERROR_FAILURE;
47361:     
47361:     nsCAutoString filename;
47361:     url->GetFileName(filename);
47361:     if (NS_FAILED(rv))
47361:       return rv;
47361:     
47361:     // Create a file to save our stream into. Should we scramble the name?
47361:     filename.Insert(NS_LITERAL_CSTRING("plugin-"), 0);
47361:     rv = pluginTmp->AppendNative(filename);
47361:     if (NS_FAILED(rv))
47361:       return rv;
47361:     
47361:     // Yes, make it unique.
47361:     rv = pluginTmp->CreateUnique(nsIFile::NORMAL_FILE_TYPE, 0600);
47361:     if (NS_FAILED(rv))
47361:       return rv;
47361:     
47361:     // create a file output stream to write to...
47361:     nsCOMPtr<nsIOutputStream> outstream;
47361:     rv = NS_NewLocalFileOutputStream(getter_AddRefs(mFileCacheOutputStream), pluginTmp, -1, 00600);
47361:     if (NS_FAILED(rv))
47361:       return rv;
47361:     
47361:     // save the file.
47361:     mLocalCachedFileHolder = new CachedFileHolder(pluginTmp);
47361:   }
47361: 
47361:   // add this listenerPeer to list of stream peers for this instance
60021:   mPluginInstance->FileCachedStreamListeners()->AppendElement(this);
47361: 
47361:   return rv;
47361: }
47361: 
47361: NS_IMETHODIMP
47361: nsPluginStreamListenerPeer::OnStartRequest(nsIRequest *request,
47361:                                            nsISupports* aContext)
47361: {
47361:   nsresult  rv = NS_OK;
47361: 
63058:   if (mRequests.IndexOfObject(GetBaseRequest(request)) == -1) {
63058:     NS_ASSERTION(mRequests.Count() == 0,
63058:                  "Only our initial stream should be unknown!");
63058:     TrackRequest(request);
63058:   }
63058:   
47361:   if (mHaveFiredOnStartRequest) {
47361:     return NS_OK;
47361:   }
47361:   
47361:   mHaveFiredOnStartRequest = PR_TRUE;
47361:   
47361:   nsCOMPtr<nsIChannel> channel = do_QueryInterface(request);
47361:   NS_ENSURE_TRUE(channel, NS_ERROR_FAILURE);
47361:   
47361:   // deal with 404 (Not Found) HTTP response,
47361:   // just return, this causes the request to be ignored.
47361:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(channel));
47361:   if (httpChannel) {
47361:     PRUint32 responseCode = 0;
47361:     rv = httpChannel->GetResponseStatus(&responseCode);
47361:     if (NS_FAILED(rv)) {
47361:       // NPP_Notify() will be called from OnStopRequest
47361:       // in nsNPAPIPluginStreamListener::CleanUpStream
47361:       // return error will cancel this request
47361:       // ...and we also need to tell the plugin that
47361:       mRequestFailed = PR_TRUE;
47361:       return NS_ERROR_FAILURE;
47361:     }
47361:     
47361:     if (responseCode > 206) { // not normal
47361:       PRBool bWantsAllNetworkStreams = PR_FALSE;
47835:       mPluginInstance->GetValueFromPlugin(NPPVpluginWantsAllNetworkStreams,
47361:                                           (void*)&bWantsAllNetworkStreams);
47361:       if (!bWantsAllNetworkStreams) {
47361:         mRequestFailed = PR_TRUE;
47361:         return NS_ERROR_FAILURE;
47361:       }
47361:     }
47361:   }
47361:   
47361:   // do a little sanity check to make sure our frame isn't gone
47361:   // by getting the tag type and checking for an error, we can determine if
47361:   // the frame is gone
47361:   if (mOwner) {
47361:     nsCOMPtr<nsIPluginTagInfo> pti = do_QueryInterface(mOwner);
47361:     NS_ENSURE_TRUE(pti, NS_ERROR_FAILURE);
47361:     nsPluginTagType tagType;
47361:     if (NS_FAILED(pti->GetTagType(&tagType)))
47361:       return NS_ERROR_FAILURE;  // something happened to our object frame, so bail!
47361:   }
47361:   
47361:   // Get the notification callbacks from the channel and save it as
47361:   // week ref we'll use it in nsPluginStreamInfo::RequestRead() when
47361:   // we'll create channel for byte range request.
47361:   nsCOMPtr<nsIInterfaceRequestor> callbacks;
47361:   channel->GetNotificationCallbacks(getter_AddRefs(callbacks));
47361:   if (callbacks)
47361:     mWeakPtrChannelCallbacks = do_GetWeakReference(callbacks);
47361:   
47361:   nsCOMPtr<nsILoadGroup> loadGroup;
47361:   channel->GetLoadGroup(getter_AddRefs(loadGroup));
47361:   if (loadGroup)
47361:     mWeakPtrChannelLoadGroup = do_GetWeakReference(loadGroup);
47361:   
51739:   PRInt32 length;
47361:   rv = channel->GetContentLength(&length);
47361:   
47361:   // it's possible for the server to not send a Content-Length.
47361:   // we should still work in this case.
47361:   if (NS_FAILED(rv) || length == -1) {
47361:     // check out if this is file channel
47361:     nsCOMPtr<nsIFileChannel> fileChannel = do_QueryInterface(channel);
47361:     if (fileChannel) {
47361:       // file does not exist
47361:       mRequestFailed = PR_TRUE;
47361:       return NS_ERROR_FAILURE;
47361:     }
47361:     mLength = 0;
47361:   }
47361:   else {
47361:     mLength = length;
47361:   }
47361:   
47361:   nsCAutoString aContentType; // XXX but we already got the type above!
47361:   rv = channel->GetContentType(aContentType);
47361:   if (NS_FAILED(rv))
47361:     return rv;
47361:   
47361:   nsCOMPtr<nsIURI> aURL;
47361:   rv = channel->GetURI(getter_AddRefs(aURL));
47361:   if (NS_FAILED(rv))
47361:     return rv;
47361:   
47361:   aURL->GetSpec(mURLSpec);
47361:   
47361:   if (!aContentType.IsEmpty())
47361:     mContentType = aContentType;
47361:   
47361: #ifdef PLUGIN_LOGGING
47361:   PR_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NOISY,
47361:          ("nsPluginStreamListenerPeer::OnStartRequest this=%p request=%p mime=%s, url=%s\n",
47361:           this, request, aContentType.get(), mURLSpec.get()));
47361:   
47361:   PR_LogFlush();
47361: #endif
47361:   
47361:   NPWindow* window = nsnull;
47361:   
47835:   // if we don't have an nsNPAPIPluginInstance (mPluginInstance), it means
47361:   // we weren't able to load a plugin previously because we
47361:   // didn't have the mimetype.  Now that we do (aContentType),
47361:   // we'll try again with SetUpPluginInstance()
47361:   // which is called by InstantiateEmbeddedPlugin()
47361:   // NOTE: we don't want to try again if we didn't get the MIME type this time
47361:   
47835:   if (!mPluginInstance && mOwner && !aContentType.IsEmpty()) {
47835:     nsCOMPtr<nsIPluginInstance> pluginInstCOMPtr;
47835:     mOwner->GetInstance(getter_AddRefs(pluginInstCOMPtr));
47835:     mPluginInstance = static_cast<nsNPAPIPluginInstance*>(pluginInstCOMPtr.get());
47361: 
47361:     mOwner->GetWindow(window);
47835:     if (!mPluginInstance && window) {
47361:       nsRefPtr<nsPluginHost> pluginHost = dont_AddRef(nsPluginHost::GetInst());
47361:       
47361:       // determine if we need to try embedded again. FullPage takes a different code path
47361:       PRInt32 mode;
47361:       mOwner->GetMode(&mode);
56390:       if (mode == NP_EMBED) {
56390:         // Make sure to not allow new streams to be opened here; we've
56390:         // already got a stream for this data; we just need a properly
56390:         // set up plugin instance.
56390:         rv = pluginHost->DoInstantiateEmbeddedPlugin(aContentType.get(), aURL,
56390:                                                      mOwner, PR_FALSE);
56390:       }
56390:       else {
47361:         rv = pluginHost->SetUpPluginInstance(aContentType.get(), aURL, mOwner);
56390:       }
47361:       
47361:       if (NS_OK == rv) {
47835:         mOwner->GetInstance(getter_AddRefs(pluginInstCOMPtr));
47835:         mPluginInstance = static_cast<nsNPAPIPluginInstance*>(pluginInstCOMPtr.get());
47835:         if (mPluginInstance) {
47835:           mPluginInstance->Start();
47361:           mOwner->CreateWidget();
47361:           // If we've got a native window, the let the plugin know about it.
58796:           nsCOMPtr<nsIPluginInstanceOwner_MOZILLA_2_0_BRANCH> owner = do_QueryInterface(mOwner);
58796:           if (owner)
58796:             owner->SetWindow();
47361:         }
47361:       }
47361:     }
47361:   }
47361:   
47361:   // Set up the stream listener...
47361:   rv = SetUpStreamListener(request, aURL);
47361:   if (NS_FAILED(rv)) return rv;
47361:   
47361:   return rv;
47361: }
47361: 
47361: NS_IMETHODIMP nsPluginStreamListenerPeer::OnProgress(nsIRequest *request,
47361:                                                      nsISupports* aContext,
47361:                                                      PRUint64 aProgress,
47361:                                                      PRUint64 aProgressMax)
47361: {
47361:   nsresult rv = NS_OK;
47361:   return rv;
47361: }
47361: 
47361: NS_IMETHODIMP nsPluginStreamListenerPeer::OnStatus(nsIRequest *request,
47361:                                                    nsISupports* aContext,
47361:                                                    nsresult aStatus,
47361:                                                    const PRUnichar* aStatusArg)
47361: {
47361:   return NS_OK;
47361: }
47361: 
47361: NS_IMETHODIMP
47361: nsPluginStreamListenerPeer::GetContentType(char** result)
47361: {
47361:   *result = const_cast<char*>(mContentType.get());
47361:   return NS_OK;
47361: }
47361: 
47361: 
47361: NS_IMETHODIMP
47361: nsPluginStreamListenerPeer::IsSeekable(PRBool* result)
47361: {
47361:   *result = mSeekable;
47361:   return NS_OK;
47361: }
47361: 
47361: NS_IMETHODIMP
47361: nsPluginStreamListenerPeer::GetLength(PRUint32* result)
47361: {
47361:   *result = mLength;
47361:   return NS_OK;
47361: }
47361: 
47361: NS_IMETHODIMP
47361: nsPluginStreamListenerPeer::GetLastModified(PRUint32* result)
47361: {
47361:   *result = mModified;
47361:   return NS_OK;
47361: }
47361: 
47361: NS_IMETHODIMP
47361: nsPluginStreamListenerPeer::GetURL(const char** result)
47361: {
47361:   *result = mURLSpec.get();
47361:   return NS_OK;
47361: }
47361: 
47361: void
47361: nsPluginStreamListenerPeer::MakeByteRangeString(NPByteRange* aRangeList, nsACString &rangeRequest,
47361:                                                 PRInt32 *numRequests)
47361: {
47361:   rangeRequest.Truncate();
47361:   *numRequests  = 0;
47361:   //the string should look like this: bytes=500-700,601-999
47361:   if (!aRangeList)
47361:     return;
47361:   
47361:   PRInt32 requestCnt = 0;
47361:   nsCAutoString string("bytes=");
47361:   
47361:   for (NPByteRange * range = aRangeList; range != nsnull; range = range->next) {
47361:     // XXX zero length?
47361:     if (!range->length)
47361:       continue;
47361:     
47361:     // XXX needs to be fixed for negative offsets
47361:     string.AppendInt(range->offset);
47361:     string.Append("-");
47361:     string.AppendInt(range->offset + range->length - 1);
47361:     if (range->next)
47361:       string += ",";
47361:     
47361:     requestCnt++;
47361:   }
47361:   
47361:   // get rid of possible trailing comma
47361:   string.Trim(",", PR_FALSE);
47361:   
47361:   rangeRequest = string;
47361:   *numRequests  = requestCnt;
47361:   return;
47361: }
47361: 
47361: NS_IMETHODIMP
47361: nsPluginStreamListenerPeer::RequestRead(NPByteRange* rangeList)
47361: {
47361:   nsCAutoString rangeString;
47361:   PRInt32 numRequests;
47361:   
47361:   MakeByteRangeString(rangeList, rangeString, &numRequests);
47361:   
47361:   if (numRequests == 0)
47361:     return NS_ERROR_FAILURE;
47361:   
47361:   nsresult rv = NS_OK;
47361:   
47361:   nsCOMPtr<nsIInterfaceRequestor> callbacks = do_QueryReferent(mWeakPtrChannelCallbacks);
47361:   nsCOMPtr<nsILoadGroup> loadGroup = do_QueryReferent(mWeakPtrChannelLoadGroup);
47361:   nsCOMPtr<nsIChannel> channel;
47361:   rv = NS_NewChannel(getter_AddRefs(channel), mURL, nsnull, loadGroup, callbacks);
47361:   if (NS_FAILED(rv))
47361:     return rv;
47361:   
47361:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(channel));
47361:   if (!httpChannel)
47361:     return NS_ERROR_FAILURE;
47361:   
47361:   httpChannel->SetRequestHeader(NS_LITERAL_CSTRING("Range"), rangeString, PR_FALSE);
47361:   
47361:   mAbort = PR_TRUE; // instruct old stream listener to cancel
47361:   // the request on the next ODA.
47361:   
47361:   nsCOMPtr<nsIStreamListener> converter;
47361:   
47361:   if (numRequests == 1) {
47361:     converter = this;
47361:     // set current stream offset equal to the first offset in the range list
47361:     // it will work for single byte range request
47361:     // for multy range we'll reset it in ODA
47361:     SetStreamOffset(rangeList->offset);
47361:   } else {
47361:     nsWeakPtr weakpeer =
47361:     do_GetWeakReference(static_cast<nsISupportsWeakReference*>(this));
47361:     nsPluginByteRangeStreamListener *brrListener =
47361:     new nsPluginByteRangeStreamListener(weakpeer);
47361:     if (brrListener)
47361:       converter = brrListener;
47361:     else
47361:       return NS_ERROR_OUT_OF_MEMORY;
47361:   }
47361:   
47361:   mPendingRequests += numRequests;
47361:   
47361:   nsCOMPtr<nsISupportsPRUint32> container = do_CreateInstance(NS_SUPPORTS_PRUINT32_CONTRACTID, &rv);
47361:   if (NS_FAILED(rv))
47361:     return rv;
47361:   rv = container->SetData(MAGIC_REQUEST_CONTEXT);
47361:   if (NS_FAILED(rv))
47361:     return rv;
47361:   
63058:   rv = channel->AsyncOpen(converter, container);
63058:   if (NS_SUCCEEDED(rv))
63058:     TrackRequest(channel);
63058:   return rv;
47361: }
47361: 
47361: NS_IMETHODIMP
47361: nsPluginStreamListenerPeer::GetStreamOffset(PRInt32* result)
47361: {
47361:   *result = mStreamOffset;
47361:   return NS_OK;
47361: }
47361: 
47361: NS_IMETHODIMP
47361: nsPluginStreamListenerPeer::SetStreamOffset(PRInt32 value)
47361: {
47361:   mStreamOffset = value;
47361:   return NS_OK;
47361: }
47361: 
47361: nsresult nsPluginStreamListenerPeer::ServeStreamAsFile(nsIRequest *request,
47361:                                                        nsISupports* aContext)
47361: {
47835:   if (!mPluginInstance)
47361:     return NS_ERROR_FAILURE;
47361:   
47835:   // mPluginInstance->Stop calls mPStreamListener->CleanUpStream(), so stream will be properly clean up
47835:   mPluginInstance->Stop();
47835:   mPluginInstance->Start();
47361:   nsCOMPtr<nsIPluginInstanceOwner> owner;
47835:   mPluginInstance->GetOwner(getter_AddRefs(owner));
47361:   if (owner) {
47361:     NPWindow* window = nsnull;
47361:     owner->GetWindow(window);
47361: #if defined(MOZ_WIDGET_GTK2) || defined(MOZ_WIDGET_QT)
47361:     // Should call GetPluginPort() here.
47361:     // This part is copied from nsPluginInstanceOwner::GetPluginPort(). 
47361:     nsCOMPtr<nsIWidget> widget;
47361:     ((nsPluginNativeWindow*)window)->GetPluginWidget(getter_AddRefs(widget));
47361:     if (widget) {
47361:       window->window = widget->GetNativeData(NS_NATIVE_PLUGIN_PORT);
47361:     }
47361: #endif
58796:     nsCOMPtr<nsIPluginInstanceOwner_MOZILLA_2_0_BRANCH> owner = do_QueryInterface(mOwner);
58796:     if (owner)
58796:       owner->SetWindow();
47361:   }
47361:   
47361:   mSeekable = PR_FALSE;
47361:   mPStreamListener->OnStartBinding(this);
47361:   mStreamOffset = 0;
47361:   
47361:   // force the plugin to use stream as file
47361:   mStreamType = NP_ASFILE;
47361:   
47361:   // then check it out if browser cache is not available
47361:   nsCOMPtr<nsICachingChannel> cacheChannel = do_QueryInterface(request);
47361:   if (!(cacheChannel && (NS_SUCCEEDED(cacheChannel->SetCacheAsFile(PR_TRUE))))) {
47361:     nsCOMPtr<nsIChannel> channel = do_QueryInterface(request);
47361:     if (channel) {
47361:       SetupPluginCacheFile(channel);
47361:     }
47361:   }
47361:   
47361:   // unset mPendingRequests
47361:   mPendingRequests = 0;
47361:   
47361:   return NS_OK;
47361: }
47361: 
47361: PRBool
47361: nsPluginStreamListenerPeer::UseExistingPluginCacheFile(nsPluginStreamListenerPeer* psi)
47361: {
47361:   
47361:   NS_ENSURE_ARG_POINTER(psi);
47361:   
47361:   if (psi->mLength == mLength &&
47361:       psi->mModified == mModified &&
47361:       mStreamComplete &&
47361:       mURLSpec.Equals(psi->mURLSpec))
47361:   {
47361:     return PR_TRUE;
47361:   }
47361:   return PR_FALSE;
47361: }
47361: 
47361: NS_IMETHODIMP nsPluginStreamListenerPeer::OnDataAvailable(nsIRequest *request,
47361:                                                           nsISupports* aContext,
47361:                                                           nsIInputStream *aIStream,
47361:                                                           PRUint32 sourceOffset,
47361:                                                           PRUint32 aLength)
47361: {
63058:   NS_ASSERTION(mRequests.IndexOfObject(GetBaseRequest(request)) != -1,
63058:                "Received OnDataAvailable for untracked request.");
63058:   
47361:   if (mRequestFailed)
47361:     return NS_ERROR_FAILURE;
47361:   
47361:   if (mAbort) {
47361:     PRUint32 magicNumber = 0;  // set it to something that is not the magic number.
47361:     nsCOMPtr<nsISupportsPRUint32> container = do_QueryInterface(aContext);
47361:     if (container)
47361:       container->GetData(&magicNumber);
47361:     
47361:     if (magicNumber != MAGIC_REQUEST_CONTEXT) {
47361:       // this is not one of our range requests
47361:       mAbort = PR_FALSE;
47361:       return NS_BINDING_ABORTED;
47361:     }
47361:   }
47361:   
47361:   nsresult rv = NS_OK;
47361:   
47361:   if (!mPStreamListener)
47361:     return NS_ERROR_FAILURE;
47361:   
47361:   const char * url = nsnull;
47361:   GetURL(&url);
47361:   
47361:   PLUGIN_LOG(PLUGIN_LOG_NOISY,
47361:              ("nsPluginStreamListenerPeer::OnDataAvailable this=%p request=%p, offset=%d, length=%d, url=%s\n",
47361:               this, request, sourceOffset, aLength, url ? url : "no url set"));
47361:   
47361:   // if the plugin has requested an AsFileOnly stream, then don't
47361:   // call OnDataAvailable
47361:   if (mStreamType != NP_ASFILEONLY) {
47361:     // get the absolute offset of the request, if one exists.
47361:     nsCOMPtr<nsIByteRangeRequest> brr = do_QueryInterface(request);
47361:     if (brr) {
47361:       if (!mDataForwardToRequest)
47361:         return NS_ERROR_FAILURE;
47361:       
47361:       PRInt64 absoluteOffset64 = LL_ZERO;
47361:       brr->GetStartRange(&absoluteOffset64);
47361:       
47361:       // XXX handle 64-bit for real
47361:       PRInt32 absoluteOffset = (PRInt32)nsInt64(absoluteOffset64);
47361:       
47361:       // we need to track how much data we have forwarded to the
47361:       // plugin.
47361:       
47361:       // FIXME: http://bugzilla.mozilla.org/show_bug.cgi?id=240130
47361:       //
47361:       // Why couldn't this be tracked on the plugin info, and not in a
47361:       // *hash table*?
47361:       nsPRUintKey key(absoluteOffset);
47361:       PRInt32 amtForwardToPlugin =
47361:       NS_PTR_TO_INT32(mDataForwardToRequest->Get(&key));
47361:       mDataForwardToRequest->Put(&key, NS_INT32_TO_PTR(amtForwardToPlugin + aLength));
47361:       
47361:       SetStreamOffset(absoluteOffset + amtForwardToPlugin);
47361:     }
47361:     
47361:     nsCOMPtr<nsIInputStream> stream = aIStream;
47361:     
47361:     // if we are caching the file ourselves to disk, we want to 'tee' off
47361:     // the data as the plugin read from the stream.  We do this by the magic
47361:     // of an input stream tee.
47361:     
47361:     if (mFileCacheOutputStream) {
47361:       rv = NS_NewInputStreamTee(getter_AddRefs(stream), aIStream, mFileCacheOutputStream);
47361:       if (NS_FAILED(rv))
47361:         return rv;
47361:     }
47361:     
47361:     rv =  mPStreamListener->OnDataAvailable(this,
47361:                                             stream,
47361:                                             aLength);
47361:     
47361:     // if a plugin returns an error, the peer must kill the stream
47361:     //   else the stream and PluginStreamListener leak
47361:     if (NS_FAILED(rv))
47361:       request->Cancel(rv);
47361:   }
47361:   else
47361:   {
47361:     // if we don't read from the stream, OnStopRequest will never be called
47361:     char* buffer = new char[aLength];
47361:     PRUint32 amountRead, amountWrote = 0;
47361:     rv = aIStream->Read(buffer, aLength, &amountRead);
47361:     
47361:     // if we are caching this to disk ourselves, lets write the bytes out.
47361:     if (mFileCacheOutputStream) {
47361:       while (amountWrote < amountRead && NS_SUCCEEDED(rv)) {
47361:         rv = mFileCacheOutputStream->Write(buffer, amountRead, &amountWrote);
47361:       }
47361:     }
47361:     delete [] buffer;
47361:   }
47361:   return rv;
47361: }
47361: 
47361: NS_IMETHODIMP nsPluginStreamListenerPeer::OnStopRequest(nsIRequest *request,
47361:                                                         nsISupports* aContext,
47361:                                                         nsresult aStatus)
47361: {
47361:   nsresult rv = NS_OK;
47361: 
63058:   nsCOMPtr<nsIMultiPartChannel> mp = do_QueryInterface(request);
63058:   if (!mp) {
63058:     PRBool found = mRequests.RemoveObject(request);
63058:     if (!found) {
63058:       NS_ERROR("Received OnStopRequest for untracked request.");
63058:     }
63058:   }
63058:   
47361:   PLUGIN_LOG(PLUGIN_LOG_NOISY,
47361:              ("nsPluginStreamListenerPeer::OnStopRequest this=%p aStatus=%d request=%p\n",
47361:               this, aStatus, request));
47361:   
47361:   // for ByteRangeRequest we're just updating the mDataForwardToRequest hash and return.
47361:   nsCOMPtr<nsIByteRangeRequest> brr = do_QueryInterface(request);
47361:   if (brr) {
47361:     PRInt64 absoluteOffset64 = LL_ZERO;
47361:     brr->GetStartRange(&absoluteOffset64);
47361:     // XXX support 64-bit offsets
47361:     PRInt32 absoluteOffset = (PRInt32)nsInt64(absoluteOffset64);
47361:     
47361:     nsPRUintKey key(absoluteOffset);
47361:     
47361:     // remove the request from our data forwarding count hash.
47361:     mDataForwardToRequest->Remove(&key);
47361:     
47361:     
47361:     PLUGIN_LOG(PLUGIN_LOG_NOISY,
47361:                ("                          ::OnStopRequest for ByteRangeRequest Started=%d\n",
47361:                 absoluteOffset));
47361:   } else {
47361:     // if this is not byte range request and
47361:     // if we are writting the stream to disk ourselves,
47361:     // close & tear it down here
47361:     mFileCacheOutputStream = nsnull;
47361:   }
47361:   
47361:   // if we still have pending stuff to do, lets not close the plugin socket.
47361:   if (--mPendingRequests > 0)
47361:     return NS_OK;
47361:   
47361:   // we keep our connections around...
47361:   nsCOMPtr<nsISupportsPRUint32> container = do_QueryInterface(aContext);
47361:   if (container) {
47361:     PRUint32 magicNumber = 0;  // set it to something that is not the magic number.
47361:     container->GetData(&magicNumber);
47361:     if (magicNumber == MAGIC_REQUEST_CONTEXT) {
47361:       // this is one of our range requests
47361:       return NS_OK;
47361:     }
47361:   }
47361:   
47361:   if (!mPStreamListener)
47361:     return NS_ERROR_FAILURE;
47361:   
47361:   nsCOMPtr<nsIChannel> channel = do_QueryInterface(request);
47361:   if (!channel)
47361:     return NS_ERROR_FAILURE;
47361:   // Set the content type to ensure we don't pass null to the plugin
47361:   nsCAutoString aContentType;
47361:   rv = channel->GetContentType(aContentType);
47361:   if (NS_FAILED(rv) && !mRequestFailed)
47361:     return rv;
47361:   
47361:   if (!aContentType.IsEmpty())
47361:     mContentType = aContentType;
47361:   
47361:   // set error status if stream failed so we notify the plugin
47361:   if (mRequestFailed)
47361:     aStatus = NS_ERROR_FAILURE;
47361:   
47361:   if (NS_FAILED(aStatus)) {
47361:     // on error status cleanup the stream
47361:     // and return w/o OnFileAvailable()
47361:     mPStreamListener->OnStopBinding(this, aStatus);
47361:     return NS_OK;
47361:   }
47361:   
47361:   // call OnFileAvailable if plugin requests stream type StreamType_AsFile or StreamType_AsFileOnly
47361:   if (mStreamType >= NP_ASFILE) {
47361:     nsCOMPtr<nsIFile> localFile;
47361:     if (mLocalCachedFileHolder)
47361:       localFile = mLocalCachedFileHolder->file();
47361:     else {
47361:       nsCOMPtr<nsICachingChannel> cacheChannel = do_QueryInterface(request);
47361:       if (cacheChannel) {
47361:         cacheChannel->GetCacheFile(getter_AddRefs(localFile));
47361:       } else {
47361:         // see if it is a file channel.
47361:         nsCOMPtr<nsIFileChannel> fileChannel = do_QueryInterface(request);
47361:         if (fileChannel) {
47361:           fileChannel->GetFile(getter_AddRefs(localFile));
47361:         }
47361:       }
47361:     }
47361:     
47361:     if (localFile) {
47361:       OnFileAvailable(localFile);
47361:     }
47361:   }
47361:   
47361:   if (mStartBinding) {
47361:     // On start binding has been called
47361:     mPStreamListener->OnStopBinding(this, aStatus);
47361:   } else {
47361:     // OnStartBinding hasn't been called, so complete the action.
47361:     mPStreamListener->OnStartBinding(this);
47361:     mPStreamListener->OnStopBinding(this, aStatus);
47361:   }
47361:   
47361:   if (NS_SUCCEEDED(aStatus)) {
47361:     mStreamComplete = PR_TRUE;
47361:   }
47361:   
47361:   return NS_OK;
47361: }
47361: 
47361: nsresult nsPluginStreamListenerPeer::SetUpStreamListener(nsIRequest *request,
47361:                                                          nsIURI* aURL)
47361: {
47361:   nsresult rv = NS_OK;
47361:   
47361:   // If we don't yet have a stream listener, we need to get
47361:   // one from the plugin.
47361:   // NOTE: this should only happen when a stream was NOT created
47361:   // with GetURL or PostURL (i.e. it's the initial stream we
47361:   // send to the plugin as determined by the SRC or DATA attribute)
60120:   if (!mPStreamListener) {
60120:     if (!mPluginInstance) {
60120:       return NS_ERROR_FAILURE;
60120:     }
60120: 
60021:     nsCOMPtr<nsIPluginStreamListener> streamListener;
60021:     rv = mPluginInstance->NewStreamListener(nsnull, nsnull,
60021:                                             getter_AddRefs(streamListener));
60120:     if (NS_FAILED(rv) || !streamListener) {
60021:       return NS_ERROR_FAILURE;
60120:     }
47361: 
60021:     mPStreamListener = static_cast<nsNPAPIPluginStreamListener*>(streamListener.get());
60021:   }
47361: 
60021:   mPStreamListener->SetStreamListenerPeer(this);
47361: 
47361:   PRBool useLocalCache = PR_FALSE;
47361:   
47361:   // get httpChannel to retrieve some info we need for nsIPluginStreamInfo setup
47361:   nsCOMPtr<nsIChannel> channel = do_QueryInterface(request);
47361:   nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(channel);
47361:   
47361:   /*
47361:    * Assumption
47361:    * By the time nsPluginStreamListenerPeer::OnDataAvailable() gets
47361:    * called, all the headers have been read.
47361:    */
47361:   if (httpChannel) {
47361:     // Reassemble the HTTP response status line and provide it to our
47361:     // listener.  Would be nice if we could get the raw status line,
47361:     // but nsIHttpChannel doesn't currently provide that.
47361:     // Status code: required; the status line isn't useful without it.
47361:     PRUint32 statusNum;
47361:     if (NS_SUCCEEDED(httpChannel->GetResponseStatus(&statusNum)) &&
47361:         statusNum < 1000) {
47361:       // HTTP version: provide if available.  Defaults to empty string.
47361:       nsCString ver;
47361:       nsCOMPtr<nsIHttpChannelInternal> httpChannelInternal =
47361:       do_QueryInterface(channel);
47361:       if (httpChannelInternal) {
47361:         PRUint32 major, minor;
47361:         if (NS_SUCCEEDED(httpChannelInternal->GetResponseVersion(&major,
47361:                                                                  &minor))) {
47361:           ver = nsPrintfCString("/%lu.%lu", major, minor);
47361:         }
47361:       }
47361: 
47361:       // Status text: provide if available.  Defaults to "OK".
47361:       nsCString statusText;
47361:       if (NS_FAILED(httpChannel->GetResponseStatusText(statusText))) {
47361:         statusText = "OK";
47361:       }
47361: 
47361:       // Assemble everything and pass to listener.
47361:       nsPrintfCString status(100, "HTTP%s %lu %s", ver.get(), statusNum,
47361:                              statusText.get());
60120:       static_cast<nsIHTTPHeaderListener*>(mPStreamListener)->StatusLine(status.get());
47361:     }
47361: 
47361:     // Also provide all HTTP response headers to our listener.
47361:     httpChannel->VisitResponseHeaders(this);
47361:     
47361:     mSeekable = PR_FALSE;
47361:     // first we look for a content-encoding header. If we find one, we tell the
47361:     // plugin that stream is not seekable, because the plugin always sees
47361:     // uncompressed data, so it can't make meaningful range requests on a
47361:     // compressed entity.  Also, we force the plugin to use
47361:     // nsPluginStreamType_AsFile stream type and we have to save decompressed
47361:     // file into local plugin cache, because necko cache contains original
47361:     // compressed file.
47361:     nsCAutoString contentEncoding;
47361:     if (NS_SUCCEEDED(httpChannel->GetResponseHeader(NS_LITERAL_CSTRING("Content-Encoding"),
47361:                                                     contentEncoding))) {
47361:       useLocalCache = PR_TRUE;
47361:     } else {
47361:       // set seekability (seekable if the stream has a known length and if the
47361:       // http server accepts byte ranges).
47361:       PRUint32 length;
47361:       GetLength(&length);
47361:       if (length) {
47361:         nsCAutoString range;
47361:         if (NS_SUCCEEDED(httpChannel->GetResponseHeader(NS_LITERAL_CSTRING("accept-ranges"), range)) &&
47361:             range.Equals(NS_LITERAL_CSTRING("bytes"), nsCaseInsensitiveCStringComparator())) {
47361:           mSeekable = PR_TRUE;
47361:         }
47361:       }
47361:     }
47361:     
47361:     // we require a content len
47361:     // get Last-Modified header for plugin info
47361:     nsCAutoString lastModified;
47361:     if (NS_SUCCEEDED(httpChannel->GetResponseHeader(NS_LITERAL_CSTRING("last-modified"), lastModified)) &&
47361:         !lastModified.IsEmpty()) {
47361:       PRTime time64;
47361:       PR_ParseTimeString(lastModified.get(), PR_TRUE, &time64);  //convert string time to integer time
47361:       
47361:       // Convert PRTime to unix-style time_t, i.e. seconds since the epoch
47361:       double fpTime;
47361:       LL_L2D(fpTime, time64);
47361:       mModified = (PRUint32)(fpTime * 1e-6 + 0.5);
47361:     }
47361:   }
47361:   
47361:   rv = mPStreamListener->OnStartBinding(this);
47361:   
47361:   mStartBinding = PR_TRUE;
47361:   
47361:   if (NS_FAILED(rv))
47361:     return rv;
47361:   
47361:   mPStreamListener->GetStreamType(&mStreamType);
47361:   
47361:   if (!useLocalCache && mStreamType >= NP_ASFILE) {
47361:     // check it out if this is not a file channel.
47361:     nsCOMPtr<nsIFileChannel> fileChannel = do_QueryInterface(request);
47361:     if (!fileChannel) {
47361:       // and browser cache is not available
47361:       nsCOMPtr<nsICachingChannel> cacheChannel = do_QueryInterface(request);
47361:       if (!(cacheChannel && (NS_SUCCEEDED(cacheChannel->SetCacheAsFile(PR_TRUE))))) {
47361:         useLocalCache = PR_TRUE;
47361:       }
47361:     }
47361:   }
47361:   
47361:   if (useLocalCache) {
47361:     SetupPluginCacheFile(channel);
47361:   }
47361:   
47361:   return NS_OK;
47361: }
47361: 
47361: nsresult
47361: nsPluginStreamListenerPeer::OnFileAvailable(nsIFile* aFile)
47361: {
47361:   nsresult rv;
47361:   if (!mPStreamListener)
47361:     return NS_ERROR_FAILURE;
47361:   
47361:   nsCAutoString path;
47361:   rv = aFile->GetNativePath(path);
47361:   if (NS_FAILED(rv)) return rv;
47361:   
47361:   if (path.IsEmpty()) {
47361:     NS_WARNING("empty path");
47361:     return NS_OK;
47361:   }
47361:   
47361:   rv = mPStreamListener->OnFileAvailable(this, path.get());
47361:   return rv;
47361: }
47361: 
47361: NS_IMETHODIMP
47361: nsPluginStreamListenerPeer::VisitHeader(const nsACString &header, const nsACString &value)
47361: {
60021:   return mPStreamListener->NewResponseHeader(PromiseFlatCString(header).get(),
47361:                                              PromiseFlatCString(value).get());
47361: }
57651: 
57651: nsresult
57651: nsPluginStreamListenerPeer::GetInterfaceGlobal(const nsIID& aIID, void** result)
57651: {
57651:   if (!mPluginInstance) {
57651:     return NS_ERROR_FAILURE;
57651:   }
57651: 
57651:   nsCOMPtr<nsIPluginInstanceOwner> owner;
57651:   mPluginInstance->GetOwner(getter_AddRefs(owner));
57651:   if (owner) {
57651:     nsCOMPtr<nsIDocument> doc;
57651:     nsresult rv = owner->GetDocument(getter_AddRefs(doc));
57651:     if (NS_SUCCEEDED(rv) && doc) {
57651:       nsPIDOMWindow *window = doc->GetWindow();
57651:       if (window) {
57651:         nsCOMPtr<nsIWebNavigation> webNav = do_GetInterface(window);
57651:         nsCOMPtr<nsIInterfaceRequestor> ir = do_QueryInterface(webNav);
57651:         return ir->GetInterface(aIID, result);
57651:       }
57651:     }
57651:   }
57651: 
57651:   return NS_ERROR_FAILURE;
57651: }
57651: 
57651: NS_IMETHODIMP
57651: nsPluginStreamListenerPeer::GetInterface(const nsIID& aIID, void** result)
57651: {
57651:   // Provide nsIChannelEventSink ourselves, otherwise let our document's
57651:   // script global object owner provide the interface.
57651:   if (aIID.Equals(NS_GET_IID(nsIChannelEventSink))) {
57651:     return QueryInterface(aIID, result);
57651:   }
57651: 
57651:   return GetInterfaceGlobal(aIID, result);
57651: }
57651: 
63058: /**
63058:  * Proxy class which forwards async redirect notifications back to the necko
63058:  * callback, keeping nsPluginStreamListenerPeer::mRequests in sync with
63058:  * which channel is active.
63058:  */
63058: class ChannelRedirectProxyCallback : public nsIAsyncVerifyRedirectCallback
63058: {
63058: public:
63058:   ChannelRedirectProxyCallback(nsINPAPIPluginStreamInfo* listener,
63058:                                nsIAsyncVerifyRedirectCallback* parent,
63058:                                nsIChannel* oldChannel,
63058:                                nsIChannel* newChannel)
63058:     : mWeakListener(do_GetWeakReference(listener))
63058:     , mParent(parent)
63058:     , mOldChannel(oldChannel)
63058:     , mNewChannel(newChannel)
63058:   {
63058:   }
63058: 
63058:   NS_DECL_ISUPPORTS
63058: 
63058:   NS_IMETHODIMP OnRedirectVerifyCallback(nsresult result)
63058:   {
63058:     if (NS_SUCCEEDED(result)) {
63058:       nsCOMPtr<nsINPAPIPluginStreamInfo> listener = do_QueryReferent(mWeakListener);
63058:       if (listener)
63058:         listener->ReplaceRequest(mOldChannel, mNewChannel);
63058:     }
63058:     return mParent->OnRedirectVerifyCallback(result);
63058:   }
63058: 
63058: private:
63058:   nsWeakPtr mWeakListener;
63058:   nsCOMPtr<nsIAsyncVerifyRedirectCallback> mParent;
63058:   nsCOMPtr<nsIChannel> mOldChannel;
63058:   nsCOMPtr<nsIChannel> mNewChannel;
63058: };
63058: 
63058: NS_IMPL_ISUPPORTS1(ChannelRedirectProxyCallback, nsIAsyncVerifyRedirectCallback)
63058:     
63058: 
57651: NS_IMETHODIMP
57651: nsPluginStreamListenerPeer::AsyncOnChannelRedirect(nsIChannel *oldChannel, nsIChannel *newChannel,
57651:                                                    PRUint32 flags, nsIAsyncVerifyRedirectCallback* callback)
57651: {
60021:   // Disallow redirects if we don't have a stream listener.
60021:   if (!mPStreamListener) {
60021:     return NS_ERROR_FAILURE;
60021:   }
57651: 
63058:   nsCOMPtr<nsIAsyncVerifyRedirectCallback> proxyCallback =
63058:     new ChannelRedirectProxyCallback(this, callback, oldChannel, newChannel);
63058: 
60021:   // Give NPAPI a chance to control redirects.
63058:   bool notificationHandled = mPStreamListener->HandleRedirectNotification(oldChannel, newChannel, proxyCallback);
60021:   if (notificationHandled) {
60021:     return NS_OK;
60021:   }
60021: 
60021:   // Don't allow cross-origin 307 POST redirects.
57651:   nsCOMPtr<nsIHttpChannel> oldHttpChannel(do_QueryInterface(oldChannel));
57651:   if (oldHttpChannel) {
57651:     PRUint32 responseStatus;
57651:     nsresult rv = oldHttpChannel->GetResponseStatus(&responseStatus);
57651:     if (NS_FAILED(rv)) {
57651:       return rv;
57651:     }
57651:     if (responseStatus == 307) {
57651:       nsCAutoString method;
57651:       rv = oldHttpChannel->GetRequestMethod(method);
57651:       if (NS_FAILED(rv)) {
57651:         return rv;
57651:       }
57651:       if (method.EqualsLiteral("POST")) {
57651:         nsCOMPtr<nsIContentUtils2> contentUtils2 = do_GetService("@mozilla.org/content/contentutils2;1");
57651:         NS_ENSURE_TRUE(contentUtils2, NS_ERROR_FAILURE);
58548:         rv = contentUtils2->CheckSameOrigin(oldChannel, newChannel);
58548:         if (NS_FAILED(rv)) {
58548:           return rv;
58548:         }
57651:       }
57651:     }
57651:   }
57651: 
60021:   // Fall back to channel event sink for window.
57651:   nsCOMPtr<nsIChannelEventSink> channelEventSink;
57651:   nsresult rv = GetInterfaceGlobal(NS_GET_IID(nsIChannelEventSink), getter_AddRefs(channelEventSink));
57651:   if (NS_FAILED(rv)) {
60021:     return rv;
57651:   }
57651: 
63058:   return channelEventSink->AsyncOnChannelRedirect(oldChannel, newChannel, flags, proxyCallback);
57651: }
