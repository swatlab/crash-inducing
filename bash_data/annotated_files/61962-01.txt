34764: /* vim: sw=2 ts=2 et lcs=trail\:.,tab\:>~ :
34764:  * ***** BEGIN LICENSE BLOCK *****
34764:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
34764:  *
34764:  * The contents of this file are subject to the Mozilla Public License Version
34764:  * 1.1 (the "License"); you may not use this file except in compliance with
34764:  * the License. You may obtain a copy of the License at
34764:  * http://www.mozilla.org/MPL/
34764:  *
34764:  * Software distributed under the License is distributed on an "AS IS" basis,
34764:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
34764:  * for the specific language governing rights and limitations under the
34764:  * License.
34764:  *
34764:  * The Original Code is Places code.
34764:  *
34764:  * The Initial Developer of the Original Code is
61389:  * the Mozilla Foundation.
34764:  * Portions created by the Initial Developer are Copyright (C) 2009
34764:  * the Initial Developer. All Rights Reserved.
34764:  *
34764:  * Contributor(s):
34764:  *   Shawn Wilsher <me@shawnwilsher.com> (Original Author)
34764:  *
34764:  * Alternatively, the contents of this file may be used under the terms of
34764:  * either the GNU General Public License Version 2 or later (the "GPL"), or
34764:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
34764:  * in which case the provisions of the GPL or the LGPL are applicable instead
34764:  * of those above. If you wish to allow use of your version of this file only
34764:  * under the terms of either the GPL or the LGPL, and not to allow others to
34764:  * use your version of this file under the terms of the MPL, indicate your
34764:  * decision by deleting the provisions above and replace them with the notice
34764:  * and other provisions required by the GPL or the LGPL. If you do not delete
34764:  * the provisions above, a recipient may use your version of this file under
34764:  * the terms of any one of the MPL, the GPL or the LGPL.
34764:  *
34764:  * ***** END LICENSE BLOCK ***** */
34764: 
34764: #include "Helpers.h"
34764: #include "mozIStorageError.h"
59351: #include "plbase64.h"
59382: #include "prio.h"
34764: #include "nsString.h"
41397: #include "nsNavHistory.h"
61389: #include "mozilla/Services.h"
34764: 
59351: // The length of guids that are used by history and bookmarks.
59351: #define GUID_LENGTH 12
59351: 
34764: namespace mozilla {
34764: namespace places {
34764: 
34764: ////////////////////////////////////////////////////////////////////////////////
34764: //// AsyncStatementCallback
34764: 
59300: NS_IMPL_ISUPPORTS1(
59300:   AsyncStatementCallback
59300: , mozIStorageStatementCallback
59300: )
59300: 
59300: NS_IMETHODIMP
59300: AsyncStatementCallback::HandleResult(mozIStorageResultSet *aResultSet)
59300: {
59300:   NS_ABORT_IF_FALSE(false, "Was not expecting a resultset, but got it.");
59300:   return NS_OK;
59300: }
59300: 
59300: NS_IMETHODIMP
59300: AsyncStatementCallback::HandleCompletion(PRUint16 aReason)
59300: {
59300:   return NS_OK;
59300: }
59300: 
34764: NS_IMETHODIMP
34764: AsyncStatementCallback::HandleError(mozIStorageError *aError)
34764: {
34764: #ifdef DEBUG
34764:   PRInt32 result;
34764:   nsresult rv = aError->GetResult(&result);
34764:   NS_ENSURE_SUCCESS(rv, rv);
34764:   nsCAutoString message;
34764:   rv = aError->GetMessage(message);
34764:   NS_ENSURE_SUCCESS(rv, rv);
34764: 
34764:   nsCAutoString warnMsg;
42263:   warnMsg.Append("An error occurred while executing an async statement: ");
47715:   warnMsg.AppendInt(result);
34764:   warnMsg.Append(" ");
34764:   warnMsg.Append(message);
34764:   NS_WARNING(warnMsg.get());
34764: #endif
34764: 
34764:   return NS_OK;
34764: }
34764: 
41397: #define URI_TO_URLCSTRING(uri, spec) \
41397:   nsCAutoString spec; \
41397:   if (NS_FAILED(aURI->GetSpec(spec))) { \
41397:     return NS_ERROR_UNEXPECTED; \
41397:   }
41397: 
41397: // Bind URI to statement by index.
41397: nsresult // static
41397: URIBinder::Bind(mozIStorageStatement* aStatement,
41397:                 PRInt32 aIndex,
41397:                 nsIURI* aURI)
41397: {
41397:   NS_ASSERTION(aStatement, "Must have non-null statement");
41397:   NS_ASSERTION(aURI, "Must have non-null uri");
41397: 
41397:   URI_TO_URLCSTRING(aURI, spec);
41397:   return URIBinder::Bind(aStatement, aIndex, spec);
41397: }
41397: 
41397: // Statement URLCString to statement by index.
41397: nsresult // static
41397: URIBinder::Bind(mozIStorageStatement* aStatement,
41397:                 PRInt32 index,
41397:                 const nsACString& aURLString)
41397: {
41397:   NS_ASSERTION(aStatement, "Must have non-null statement");
41397:   return aStatement->BindUTF8StringByIndex(
41397:     index, StringHead(aURLString, URI_LENGTH_MAX)
41397:   );
41397: }
41397: 
41397: // Bind URI to statement by name.
41397: nsresult // static
41397: URIBinder::Bind(mozIStorageStatement* aStatement,
41397:                 const nsACString& aName,
41397:                 nsIURI* aURI)
41397: {
41397:   NS_ASSERTION(aStatement, "Must have non-null statement");
41397:   NS_ASSERTION(aURI, "Must have non-null uri");
41397: 
41397:   URI_TO_URLCSTRING(aURI, spec);
41397:   return URIBinder::Bind(aStatement, aName, spec);
41397: }
41397: 
41397: // Bind URLCString to statement by name.
41397: nsresult // static
41397: URIBinder::Bind(mozIStorageStatement* aStatement,
41397:                 const nsACString& aName,
41397:                 const nsACString& aURLString)
41397: {
41397:   NS_ASSERTION(aStatement, "Must have non-null statement");
41397:   return aStatement->BindUTF8StringByName(
41397:     aName, StringHead(aURLString, URI_LENGTH_MAX)
41397:   );
41397: }
41397: 
41397: // Bind URI to params by index.
41397: nsresult // static
41397: URIBinder::Bind(mozIStorageBindingParams* aParams,
41397:                 PRInt32 aIndex,
41397:                 nsIURI* aURI)
41397: {
41397:   NS_ASSERTION(aParams, "Must have non-null statement");
41397:   NS_ASSERTION(aURI, "Must have non-null uri");
41397: 
41397:   URI_TO_URLCSTRING(aURI, spec);
41397:   return URIBinder::Bind(aParams, aIndex, spec);
41397: }
41397: 
41397: // Bind URLCString to params by index.
41397: nsresult // static
41397: URIBinder::Bind(mozIStorageBindingParams* aParams,
41397:                 PRInt32 index,
41397:                 const nsACString& aURLString)
41397: {
41397:   NS_ASSERTION(aParams, "Must have non-null statement");
41397:   return aParams->BindUTF8StringByIndex(
41397:     index, StringHead(aURLString, URI_LENGTH_MAX)
41397:   );
41397: }
41397: 
41397: // Bind URI to params by name.
41397: nsresult // static
41397: URIBinder::Bind(mozIStorageBindingParams* aParams,
41397:                 const nsACString& aName,
41397:                 nsIURI* aURI)
41397: {
41397:   NS_ASSERTION(aParams, "Must have non-null params array");
41397:   NS_ASSERTION(aURI, "Must have non-null uri");
41397: 
41397:   URI_TO_URLCSTRING(aURI, spec);
41397:   return URIBinder::Bind(aParams, aName, spec);
41397: }
41397: 
41397: // Bind URLCString to params by name.
41397: nsresult // static
41397: URIBinder::Bind(mozIStorageBindingParams* aParams,
41397:                 const nsACString& aName,
41397:                 const nsACString& aURLString)
41397: {
41397:   NS_ASSERTION(aParams, "Must have non-null params array");
41397: 
41397:   nsresult rv = aParams->BindUTF8StringByName(
41397:     aName, StringHead(aURLString, URI_LENGTH_MAX)
41397:   );
41397:   NS_ENSURE_SUCCESS(rv, rv);
41397:   return NS_OK;
41397: }
41397: 
41397: #undef URI_TO_URLCSTRING
41397: 
47715: nsresult
47715: GetReversedHostname(nsIURI* aURI, nsString& aRevHost)
47715: {
47715:   nsCAutoString forward8;
47715:   nsresult rv = aURI->GetHost(forward8);
48783:   // Not all URIs have a host.
48783:   if (NS_FAILED(rv))
48783:     return rv;
47715: 
47715:   // can't do reversing in UTF8, better use 16-bit chars
47715:   GetReversedHostname(NS_ConvertUTF8toUTF16(forward8), aRevHost);
47715:   return NS_OK;
47715: }
47715: 
47715: void
47715: GetReversedHostname(const nsString& aForward, nsString& aRevHost)
47715: {
47715:   ReverseString(aForward, aRevHost);
47715:   aRevHost.Append(PRUnichar('.'));
47715: }
47715: 
47715: void
47715: ReverseString(const nsString& aInput, nsString& aReversed)
47715: {
47715:   aReversed.Truncate(0);
47715:   for (PRInt32 i = aInput.Length() - 1; i >= 0; i--) {
47715:     aReversed.Append(aInput[i]);
47715:   }
47715: }
41397: 
59351: static
59351: nsresult
59351: Base64urlEncode(const PRUint8* aBytes,
59351:                 PRUint32 aNumBytes,
59351:                 nsCString& _result)
59351: {
59351:   // SetLength does not set aside space for NULL termination.  PL_Base64Encode
59351:   // will not NULL terminate, however, nsCStrings must be NULL terminated.  As a
59351:   // result, we set the capacity to be one greater than what we need, and the
59351:   // length to our desired length.
59351:   PRUint32 length = (aNumBytes + 2) / 3 * 4; // +2 due to integer math.
59351:   NS_ENSURE_TRUE(_result.SetCapacity(length + 1), NS_ERROR_OUT_OF_MEMORY);
59351:   _result.SetLength(length);
59351:   (void)PL_Base64Encode(reinterpret_cast<const char*>(aBytes), aNumBytes,
59351:                         _result.BeginWriting());
59351: 
59351:   // base64url encoding is defined in RFC 4648.  It replaces the last two
59351:   // alphabet characters of base64 encoding with '-' and '_' respectively.
59351:   _result.ReplaceChar('+', '-');
59351:   _result.ReplaceChar('/', '_');
59351:   return NS_OK;
59351: }
59351: 
59382: #ifdef XP_WIN
59382: // Included here because windows.h conflicts with the use of mozIStorageError
59382: // above.
59382: #include <windows.h>
59676: #include <wincrypt.h>
59382: #endif
59382: 
59382: static
59382: nsresult
59382: GenerateRandomBytes(PRUint32 aSize,
59382:                     PRUint8* _buffer)
59382: {
59382:   // On Windows, we'll use its built-in cryptographic API.
59382: #if defined(XP_WIN)
59382:   HCRYPTPROV cryptoProvider;
59382:   BOOL rc = CryptAcquireContext(&cryptoProvider, 0, 0, PROV_RSA_FULL,
59382:                                 CRYPT_VERIFYCONTEXT | CRYPT_SILENT);
59382:   if (rc) {
59382:     rc = CryptGenRandom(cryptoProvider, aSize, _buffer);
61962:     (void)CryptReleaseContext(cryptoProvider, 0);
59382:   }
59382:   return rc ? NS_OK : NS_ERROR_FAILURE;
59382: 
59382:   // On Unix, we'll just read in from /dev/urandom.
59382: #elif defined(XP_UNIX)
59382:   NS_ENSURE_ARG_MAX(aSize, PR_INT32_MAX);
59382:   PRFileDesc* urandom = PR_Open("/dev/urandom", PR_RDONLY, 0);
59382:   nsresult rv = NS_ERROR_FAILURE;
59382:   if (urandom) {
59382:     PRInt32 bytesRead = PR_Read(urandom, _buffer, aSize);
59382:     if (bytesRead == static_cast<PRInt32>(aSize)) {
59382:       rv = NS_OK;
59382:     }
59382:     (void)PR_Close(urandom);
59382:   }
59382:   return rv;
59382: #endif
59382: }
59382: 
59351: nsresult
59351: GenerateGUID(nsCString& _guid)
59351: {
59351:   _guid.Truncate();
59351: 
59351:   // Request raw random bytes and base64url encode them.  For each set of three
59351:   // bytes, we get one character.
59351:   const PRUint32 kRequiredBytesLength =
59351:     static_cast<PRUint32>(GUID_LENGTH / 4 * 3);
59351: 
59382:   PRUint8 buffer[kRequiredBytesLength];
59382:   nsresult rv = GenerateRandomBytes(kRequiredBytesLength, buffer);
59351:   NS_ENSURE_SUCCESS(rv, rv);
59351: 
59351:   rv = Base64urlEncode(buffer, kRequiredBytesLength, _guid);
59351:   NS_ENSURE_SUCCESS(rv, rv);
59351: 
59351:   NS_ASSERTION(_guid.Length() == GUID_LENGTH, "GUID is not the right size!");
59351:   return NS_OK;
59351: }
59351: 
59371: bool
59371: IsValidGUID(const nsCString& aGUID)
59371: {
59371:   nsCString::size_type len = aGUID.Length();
59371:   if (len != GUID_LENGTH) {
59371:     return false;
59371:   }
59371: 
59371:   for (nsCString::size_type i = 0; i < len; i++ ) {
59371:     char c = aGUID[i];
59371:     if (c >= 'a' && c <= 'z' || // a-z
59371:         c >= 'A' && c <= 'Z' || // A-Z
59371:         c >= '0' && c <= '9' || // 0-9
59371:         c == '-' || c == '_') { // - or _
59371:       continue;
59371:     }
59371:     return false;
59371:   }
59371:   return true;
59371: }
59371: 
59379: void
59379: ForceWALCheckpoint(mozIStorageConnection* aDBConn)
59379: {
59379:   nsCOMPtr<mozIStorageAsyncStatement> stmt;
59379:   (void)aDBConn->CreateAsyncStatement(NS_LITERAL_CSTRING(
59379:     "pragma wal_checkpoint "
59379:   ), getter_AddRefs(stmt));
59379:   nsCOMPtr<mozIStoragePendingStatement> handle;
59379:   (void)stmt->ExecuteAsync(nsnull, getter_AddRefs(handle));
59379: }
59379: 
60948: bool
60948: GetHiddenState(bool aIsRedirect,
60948:                PRUint32 aTransitionType)
60948: {
60948:   return aTransitionType == nsINavHistoryService::TRANSITION_FRAMED_LINK ||
60948:          aTransitionType == nsINavHistoryService::TRANSITION_EMBED ||
60948:          aIsRedirect;
60948: }
60948: 
61389: ////////////////////////////////////////////////////////////////////////////////
61389: //// PlacesEvent
61389: 
61389: PlacesEvent::PlacesEvent(const char* aTopic)
61389: : mTopic(aTopic)
61389: , mDoubleEnqueue(false)
61389: {
61389: }
61389: 
61389: PlacesEvent::PlacesEvent(const char* aTopic,
61389:                          bool aDoubleEnqueue)
61389: : mTopic(aTopic)
61389: , mDoubleEnqueue(aDoubleEnqueue)
61389: {
61389: }
61389: 
61389: NS_IMETHODIMP
61389: PlacesEvent::Run()
61389: {
61389:   Notify();
61389:   return NS_OK;
61389: }
61389: 
61389: NS_IMETHODIMP
61389: PlacesEvent::Complete()
61389: {
61389:   Notify();
61389:   return NS_OK;
61389: }
61389: 
61389: void
61389: PlacesEvent::Notify()
61389: {
61389:   if (mDoubleEnqueue) {
61389:     mDoubleEnqueue = false;
61389:     (void)NS_DispatchToMainThread(this);
61389:   }
61389:   else {
61389:     NS_ASSERTION(NS_IsMainThread(), "Must only be used on the main thread!");
61389:     nsCOMPtr<nsIObserverService> obs = mozilla::services::GetObserverService();
61389:     if (obs) {
61389:       (void)obs->NotifyObservers(nsnull, mTopic, nsnull);
61389:     }
61389:   }
61389: }
61389: 
61389: NS_IMPL_THREADSAFE_ISUPPORTS2(
61389:   PlacesEvent
61389: , mozIStorageCompletionCallback
61389: , nsIRunnable
61389: )
61389: 
34764: } // namespace places
34764: } // namespace mozilla
