69223: /* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
69223:  * vim: set ts=4 sw=4 et tw=79 ft=cpp:
69223:  *
69223:  * ***** BEGIN LICENSE BLOCK *****
69223:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
69223:  *
69223:  * The contents of this file are subject to the Mozilla Public License Version
69223:  * 1.1 (the "License"); you may not use this file except in compliance with
69223:  * the License. You may obtain a copy of the License at
69223:  * http://www.mozilla.org/MPL/
69223:  *
69223:  * Software distributed under the License is distributed on an "AS IS" basis,
69223:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
69223:  * for the specific language governing rights and limitations under the
69223:  * License.
69223:  *
69223:  * The Original Code is SpiderMonkey JavaScript engine.
69223:  *
69223:  * The Initial Developer of the Original Code is
69223:  * Mozilla Corporation.
69223:  * Portions created by the Initial Developer are Copyright (C) 2009
69223:  * the Initial Developer. All Rights Reserved.
69223:  *
69223:  * Contributor(s):
69223:  *   Luke Wagner <luke@mozilla.com>
69223:  *
69223:  * Alternatively, the contents of this file may be used under the terms of
69223:  * either the GNU General Public License Version 2 or later (the "GPL"), or
69223:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
69223:  * in which case the provisions of the GPL or the LGPL are applicable instead
69223:  * of those above. If you wish to allow use of your version of this file only
69223:  * under the terms of either the GPL or the LGPL, and not to allow others to
69223:  * use your version of this file under the terms of the MPL, indicate your
69223:  * decision by deleting the provisions above and replace them with the notice
69223:  * and other provisions required by the GPL or the LGPL. If you do not delete
69223:  * the provisions above, a recipient may use your version of this file under
69223:  * the terms of any one of the MPL, the GPL or the LGPL.
69223:  *
69223:  * ***** END LICENSE BLOCK ***** */
69223: 
69223: #ifndef Stack_h__
69223: #define Stack_h__
69223: 
69223: #include "jsfun.h"
69223: 
70320: struct JSContext;
70320: 
69223: namespace js {
69223: 
69223: class StackFrame;
69223: class FrameRegs;
69223: class StackSegment;
69223: class StackSpace;
69223: class ContextStack;
69223: 
69223: class InvokeArgsGuard;
69223: class InvokeFrameGuard;
69223: class FrameGuard;
69223: class ExecuteFrameGuard;
69223: class DummyFrameGuard;
69223: class GeneratorFrameGuard;
69223: 
76020: namespace mjit {
76020:     struct JITScript;
76020:     struct CallSite;
76126:     jsbytecode *NativeToPC(JITScript *jit, void *ncode, CallSite **pinline);
76020: }
69223: namespace detail { struct OOMCheck; }
69223: 
69827: class ArgumentsObject;
69827: 
76001: #ifdef JS_METHODJIT
76001: typedef js::mjit::CallSite JSInlinedSite;
76001: #else
76001: struct JSInlinedSite {};
76001: #endif
76001: 
76020: typedef /* js::mjit::RejoinState */ size_t JSRejoinState;
69223: 
69223: /*
69223:  * VM stack layout
69223:  *
69223:  * SpiderMonkey uses a per-thread stack to store the activation records,
69223:  * parameters, locals, and expression temporaries for the stack of actively
69223:  * executing scripts, functions and generators. The per-thread stack is owned
69223:  * by the StackSpace object stored in the thread's ThreadData.
69223:  *
69223:  * The per-thread stack is subdivided into contiguous segments of memory which
69223:  * have a memory layout invariant that allows fixed offsets to be used for stack
69223:  * access (by the JIT) as well as fast call/return. This memory layout is
69223:  * encapsulated by a set of types that describe different regions of memory:
69223:  * StackSegment, StackFrame, FrameRegs and CallArgs. To avoid calling into C++,
69223:  * the JIT compiler generates code that simulates C++ stack operations.
69223:  *
69223:  * The memory layout of a segment looks like:
69223:  *
69223:  *                            current regs
69223:  *     .------------------------------------------------------.
69223:  *     |                  current frame                       |
69223:  *     |   .-------------------------------------.            V
69223:  *     |   |    initial frame                    |        FrameRegs
69223:  *     |   |   .------------.                    |            |
69223:  *     |   |   |            V                    V            V
69223:  * |StackSegment| slots |StackFrame| slots |StackFrame| slots |
69223:  *                        |      ^           |
69223:  *           ? <----------'      `-----------'
69223:  *                 prev               prev
69223:  *
69223:  * A segment starts with a fixed-size header (js::StackSegment) which logically
69223:  * describes the segment, links it to the rest of the stack, and points to the
69223:  * first and last frames in the segment.
69223:  *
69223:  * Each script activation (global or function code) is given a fixed-size header
69223:  * (js::StackFrame) which is associated with the values (called "slots") before
69223:  * and after it. The frame contains bookkeeping information about the activation
69223:  * and links to the previous frame.
69223:  *
69223:  * The slots preceeding a (function) StackFrame in memory are the arguments of
69223:  * the call. The slots after a StackFrame in memory are its locals followed
69223:  * by its expression stack. There is no clean line between the arguments of a
69223:  * frame and the expression stack of the previous frame since the top slots of
69223:  * the expression become the arguments of a call. There are also layout
69223:  * invariants concerning the arguments and StackFrame; see "Arguments" comment
69223:  * in StackFrame for more details.
69223:  *
69223:  * The top of a segment's current frame's expression stack is pointed to by the
69223:  * segment's "current regs", which contains the stack pointer 'sp'. In the
69223:  * interpreter, sp is adjusted as individual values are pushed and popped from
69223:  * the stack and the FrameRegs struct (pointed by the StackSegment) is a local
69223:  * var of js::Interpret. JIT code simulates this by lazily updating FrameRegs
69223:  * when calling from JIT code into the VM. Ideally, we'd like to remove all
69223:  * dependence on FrameRegs outside the interpreter.
69223:  *
69223:  * A call to a native (C++) function does not push a frame. Instead, an array
69223:  * of values (possibly from the top of a calling frame's expression stack) is
69223:  * passed to the native. The layout of this array is abstracted by js::CallArgs.
69223:  * Note that, between any two StackFrames there may be any number of native
69223:  * calls, so the meaning of 'prev' is not 'directly called by'.
69223:  *
69223:  * An additional feature (perhaps not for much longer: bug 650361) is that
69223:  * multiple independent "contexts" can interleave (LIFO) on a single contiguous
69223:  * stack. "Independent" here means that neither context sees the other's frames.
69223:  * Concretely, an embedding may enter the JS engine on cx1 and then, from a
69223:  * native called by the JS engine, reenter the VM on cx2. Changing from cx1 to
69223:  * cx2 causes cx1's segment to be "suspended" and a new segment started to be
69223:  * started for cx2. These two segments are linked from the perspective of
69223:  * StackSpace, since they are adjacent on the thread's stack, but not from the
69223:  * perspective of cx1 and cx2. Thus, each segment has two prev-links:
69223:  * previousInMemory and previousInContext. A context's apparent stack is
69223:  * encapsulated and managed by the js::ContextStack object stored in JSContext.
69223:  * ContextStack is the primary interface to the rest of the engine for pushing
69223:  * and popping args (for js::Invoke calls) and frames.
69223:  */
69223: 
69223: /*****************************************************************************/
69223: 
69223: class CallReceiver
69223: {
69223: #ifdef DEBUG
69223:     mutable bool usedRval_;
69223: #endif
69223:   protected:
69223:     Value *argv_;
69223:     CallReceiver() {}
69223:     CallReceiver(Value *argv) : argv_(argv) {
69223: #ifdef DEBUG
69223:         usedRval_ = false;
69223: #endif
69223:     }
69223: 
69223:   public:
69223:     friend CallReceiver CallReceiverFromVp(Value *);
69223:     friend CallReceiver CallReceiverFromArgv(Value *);
69223:     Value *base() const { return argv_ - 2; }
69223:     JSObject &callee() const { JS_ASSERT(!usedRval_); return argv_[-2].toObject(); }
69223:     Value &calleev() const { JS_ASSERT(!usedRval_); return argv_[-2]; }
69223:     Value &thisv() const { return argv_[-1]; }
69223: 
69223:     Value &rval() const {
69223: #ifdef DEBUG
69223:         usedRval_ = true;
69223: #endif
69223:         return argv_[-2];
69223:     }
69223: 
69223:     void calleeHasBeenReset() const {
69223: #ifdef DEBUG
69223:         usedRval_ = false;
69223: #endif
69223:     }
69223: };
69223: 
69223: JS_ALWAYS_INLINE CallReceiver
69223: CallReceiverFromVp(Value *vp)
69223: {
69223:     return CallReceiver(vp + 2);
69223: }
69223: 
69223: JS_ALWAYS_INLINE CallReceiver
69223: CallReceiverFromArgv(Value *argv)
69223: {
69223:     return CallReceiver(argv);
69223: }
69223: 
69223: /*****************************************************************************/
69223: 
69223: class CallArgs : public CallReceiver
69223: {
69223:     uintN argc_;
69223:   protected:
69223:     CallArgs() {}
69223:     CallArgs(uintN argc, Value *argv) : CallReceiver(argv), argc_(argc) {}
69223:   public:
69223:     friend CallArgs CallArgsFromVp(uintN, Value *);
69223:     friend CallArgs CallArgsFromArgv(uintN, Value *);
69223:     Value &operator[](unsigned i) const { JS_ASSERT(i < argc_); return argv_[i]; }
69223:     Value *argv() const { return argv_; }
69223:     uintN argc() const { return argc_; }
69223: };
69223: 
69223: JS_ALWAYS_INLINE CallArgs
69223: CallArgsFromVp(uintN argc, Value *vp)
69223: {
69223:     return CallArgs(argc, vp + 2);
69223: }
69223: 
69223: JS_ALWAYS_INLINE CallArgs
69223: CallArgsFromArgv(uintN argc, Value *argv)
69223: {
69223:     return CallArgs(argc, argv);
69223: }
69223: 
69223: /*****************************************************************************/
69223: 
69223: class StackFrame
69223: {
69223:   public:
69223:     enum Flags {
69223:         /* Primary frame type */
69223:         GLOBAL             =        0x1,  /* frame pushed for a global script */
69223:         FUNCTION           =        0x2,  /* frame pushed for a scripted call */
69223:         DUMMY              =        0x4,  /* frame pushed for bookkeeping */
69223: 
69223:         /* Frame subtypes */
69223:         EVAL               =        0x8,  /* frame pushed for eval() or debugger eval */
69223:         DEBUGGER           =       0x10,  /* frame pushed for debugger eval */
69223:         GENERATOR          =       0x20,  /* frame is associated with a generator */
69223:         FLOATING_GENERATOR =       0x40,  /* frame is is in generator obj, not on stack */
69223:         CONSTRUCTING       =       0x80,  /* frame is for a constructor invocation */
69223: 
69223:         /* Temporary frame states */
69223:         YIELDING           =      0x100,  /* js::Interpret dispatched JSOP_YIELD */
69223:         FINISHED_IN_INTERP =      0x200,  /* set if frame finished in Interpret() */
69223: 
69223:         /* Concerning function arguments */
69223:         OVERRIDE_ARGS      =      0x400,  /* overridden arguments local variable */
69223:         OVERFLOW_ARGS      =      0x800,  /* numActualArgs > numFormalArgs */
69223:         UNDERFLOW_ARGS     =     0x1000,  /* numActualArgs < numFormalArgs */
69223: 
69223:         /* Lazy frame initialization */
69223:         HAS_IMACRO_PC      =     0x2000,  /* frame has imacpc value available */
69223:         HAS_CALL_OBJ       =     0x4000,  /* frame has a callobj reachable from scopeChain_ */
69223:         HAS_ARGS_OBJ       =     0x8000,  /* frame has an argsobj in StackFrame::args */
69223:         HAS_HOOK_DATA      =    0x10000,  /* frame has hookData_ set */
69223:         HAS_ANNOTATION     =    0x20000,  /* frame has annotation_ set */
69223:         HAS_RVAL           =    0x40000,  /* frame has rval_ set */
69223:         HAS_SCOPECHAIN     =    0x80000,  /* frame has scopeChain_ set */
76001:         HAS_PREVPC         =   0x100000   /* frame has prevpc_ and prevInline_ set */
69223:     };
69223: 
69223:   private:
69223:     mutable uint32      flags_;         /* bits described by Flags */
69223:     union {                             /* describes what code is executing in a */
69223:         JSScript        *script;        /*   global frame */
69223:         JSFunction      *fun;           /*   function frame, pre GetScopeChain */
69223:     } exec;
69223:     union {                             /* describes the arguments of a function */
69827:         uintN           nactual;        /*   before js_GetArgsObject */
69827:         ArgumentsObject *obj;           /*   after js_GetArgsObject */
69223:         JSScript        *script;        /* eval has no args, but needs a script */
69223:     } args;
69223:     mutable JSObject    *scopeChain_;   /* current scope chain */
69223:     StackFrame          *prev_;         /* previous cx->regs->fp */
69223:     void                *ncode_;        /* return address for method JIT */
69223: 
69223:     /* Lazily initialized */
69223:     js::Value           rval_;          /* return value of the frame */
69223:     jsbytecode          *prevpc_;       /* pc of previous frame*/
76001:     JSInlinedSite       *prevInline_;   /* inlined site in previous frame */
69223:     jsbytecode          *imacropc_;     /* pc of macro caller */
69223:     void                *hookData_;     /* closure returned by call hook */
69223:     void                *annotation_;   /* perhaps remove with bug 546848 */
76020:     JSRejoinState       rejoin_;        /* If rejoining into the interpreter
76020:                                          * from JIT code, state at rejoin. */
69223: 
69223:     static void staticAsserts() {
69223:         JS_STATIC_ASSERT(offsetof(StackFrame, rval_) % sizeof(js::Value) == 0);
69223:         JS_STATIC_ASSERT(sizeof(StackFrame) % sizeof(js::Value) == 0);
69223:     }
69223: 
69223:     inline void initPrev(JSContext *cx);
76001:     jsbytecode *prevpcSlow(JSInlinedSite **pinlined);
69223: 
69223:   public:
69223:     /*
69223:      * Frame initialization
69223:      *
69223:      * After acquiring a pointer to an uninitialized stack frame on the VM
69223:      * stack from StackSpace, these members are used to initialize the stack
69223:      * frame before officially pushing the frame into the context.
69223:      */
69223: 
69223:     /* Used for Invoke, Interpret, trace-jit LeaveTree, and method-jit stubs. */
69223:     inline void initCallFrame(JSContext *cx, JSObject &callee, JSFunction *fun,
69223:                               uint32 nactual, uint32 flags);
69223: 
69223:     /* Used for SessionInvoke. */
69223:     inline void resetInvokeCallFrame();
69223: 
69223:     /* Called by method-jit stubs and serve as a specification for jit-code. */
69223:     inline void initCallFrameCallerHalf(JSContext *cx, uint32 flags, void *ncode);
69223:     inline void initCallFrameEarlyPrologue(JSFunction *fun, uint32 nactual);
69223:     inline void initCallFrameLatePrologue();
69223: 
69223:     /* Used for eval. */
69223:     inline void initEvalFrame(JSContext *cx, JSScript *script, StackFrame *prev,
69223:                               uint32 flags);
69704:     inline void initGlobalFrame(JSScript *script, JSObject &chain, StackFrame *prev,
69704:                                 uint32 flags);
69223: 
69223:     /* Used when activating generators. */
69223:     inline void stealFrameAndSlots(js::Value *vp, StackFrame *otherfp,
69223:                                    js::Value *othervp, js::Value *othersp);
69223: 
69223:     /* Perhaps one fine day we will remove dummy frames. */
69223:     inline void initDummyFrame(JSContext *cx, JSObject &chain);
69223: 
69223:     /*
69223:      * Stack frame type
69223:      *
69223:      * A stack frame may have one of three types, which determines which
69223:      * members of the frame may be accessed and other invariants:
69223:      *
69223:      *  global frame:   execution of global code or an eval in global code
69223:      *  function frame: execution of function code or an eval in a function
69223:      *  dummy frame:    bookkeeping frame (to be removed in bug 625199)
69223:      */
69223: 
69223:     bool isFunctionFrame() const {
69223:         return !!(flags_ & FUNCTION);
69223:     }
69223: 
69223:     bool isGlobalFrame() const {
69223:         return !!(flags_ & GLOBAL);
69223:     }
69223: 
69223:     bool isDummyFrame() const {
69223:         return !!(flags_ & DUMMY);
69223:     }
69223: 
69223:     bool isScriptFrame() const {
69223:         bool retval = !!(flags_ & (FUNCTION | GLOBAL));
69223:         JS_ASSERT(retval == !isDummyFrame());
69223:         return retval;
69223:     }
69223: 
69223:     /*
69223:      * Eval frames
69223:      *
69223:      * As noted above, global and function frames may optionally be 'eval
69223:      * frames'. Eval code shares its parent's arguments which means that the
69223:      * arg-access members of StackFrame may not be used for eval frames.
69223:      * Search for 'hasArgs' below for more details.
69223:      *
69223:      * A further sub-classification of eval frames is whether the frame was
69223:      * pushed for an ES5 strict-mode eval().
69223:      */
69223: 
69223:     bool isEvalFrame() const {
69223:         JS_ASSERT_IF(flags_ & EVAL, isScriptFrame());
69223:         return flags_ & EVAL;
69223:     }
69223: 
69223:     bool isNonEvalFunctionFrame() const {
69223:         return (flags_ & (FUNCTION | EVAL)) == FUNCTION;
69223:     }
69223: 
69223:     inline bool isStrictEvalFrame() const {
69223:         return isEvalFrame() && script()->strictModeCode;
69223:     }
69223: 
69223:     bool isNonStrictEvalFrame() const {
69223:         return isEvalFrame() && !script()->strictModeCode;
69223:     }
69223: 
69223:     /*
69223:      * Previous frame
69223:      *
69223:      * A frame's 'prev' frame is either null or the previous frame pointed to
69223:      * by cx->regs->fp when this frame was pushed. Often, given two prev-linked
69223:      * frames, the next-frame is a function or eval that was called by the
69223:      * prev-frame, but not always: the prev-frame may have called a native that
69223:      * reentered the VM through JS_CallFunctionValue on the same context
69223:      * (without calling JS_SaveFrameChain) which pushed the next-frame. Thus,
69223:      * 'prev' has little semantic meaning and basically just tells the VM what
69223:      * to set cx->regs->fp to when this frame is popped.
69223:      */
69223: 
69223:     StackFrame *prev() const {
69223:         return prev_;
69223:     }
69223: 
69223:     inline void resetGeneratorPrev(JSContext *cx);
76001:     inline void resetInlinePrev(StackFrame *prevfp, jsbytecode *prevpc);
76001: 
76001:     inline void initInlineFrame(JSFunction *fun, StackFrame *prevfp, jsbytecode *prevpc);
69223: 
69223:     /*
69223:      * Frame slots
69223:      *
69223:      * A frame's 'slots' are the fixed slots associated with the frame (like
69223:      * local variables) followed by an expression stack holding temporary
69223:      * values. A frame's 'base' is the base of the expression stack.
69223:      */
69223: 
69223:     js::Value *slots() const {
69223:         return (js::Value *)(this + 1);
69223:     }
69223: 
69223:     js::Value *base() const {
69223:         return slots() + script()->nfixed;
69223:     }
69223: 
69223:     js::Value &varSlot(uintN i) {
69223:         JS_ASSERT(i < script()->nfixed);
69223:         JS_ASSERT_IF(maybeFun(), i < script()->bindings.countVars());
69223:         return slots()[i];
69223:     }
69223: 
69223:     /*
69223:      * Script
69223:      *
69223:      * All function and global frames have an associated JSScript which holds
76001:      * the bytecode being executed for the frame. This script/bytecode does
76001:      * not reflect any inlining that has been performed by the method JIT.
76001:      *
76001:      * If other frames were inlined into this one, the script/pc reflect the
76001:      * point of the outermost call. Use inlinepc to get the script/pc for
76001:      * the innermost inlined frame. Inlined frame invariants:
76001:      *
76001:      * - Inlined frames have the same scope chain as the outer frame.
76001:      * - Inlined frames have the same strictness as the outer frame.
69223:      */
69223: 
69223:     /*
69223:      * Get the frame's current bytecode, assuming |this| is in |cx|.
69223:      * next is frame whose prev == this, NULL if not known or if this == cx->fp().
76001:      * If the frame is inside an inline call made within the pc, the state
76001:      * of any inlined frame(s) is returned through pinlined.
69223:      */
76001:     jsbytecode *pc(JSContext *cx, StackFrame *next = NULL, JSInlinedSite **pinlined = NULL);
69223: 
76001:     jsbytecode *prevpc(JSInlinedSite **pinlined) {
76001:         if (flags_ & HAS_PREVPC) {
76001:             if (pinlined)
76001:                 *pinlined = prevInline_;
69223:             return prevpc_;
69223:         }
76001:         return prevpcSlow(pinlined);
76001:     }
76001: 
76001:     JSInlinedSite *prevInline() {
76001:         JS_ASSERT(flags_ & HAS_PREVPC);
76001:         return prevInline_;
76001:     }
76001: 
76001:     /* Get the innermost pc/script in this frame, looking through any inlining. */
76001:     jsbytecode *inlinepc(JSContext *cx, JSScript **pscript);
69223: 
69223:     JSScript *script() const {
69223:         JS_ASSERT(isScriptFrame());
69223:         return isFunctionFrame()
69223:                ? isEvalFrame() ? args.script : fun()->script()
69223:                : exec.script;
69223:     }
69223: 
69223:     JSScript *functionScript() const {
69223:         JS_ASSERT(isFunctionFrame());
69223:         return isEvalFrame() ? args.script : fun()->script();
69223:     }
69223: 
69223:     JSScript *globalScript() const {
69223:         JS_ASSERT(isGlobalFrame());
69223:         return exec.script;
69223:     }
69223: 
69223:     JSScript *maybeScript() const {
69223:         return isScriptFrame() ? script() : NULL;
69223:     }
69223: 
69223:     size_t numFixed() const {
69223:         return script()->nfixed;
69223:     }
69223: 
69223:     size_t numSlots() const {
69223:         return script()->nslots;
69223:     }
69223: 
69223:     size_t numGlobalVars() const {
69223:         JS_ASSERT(isGlobalFrame());
69223:         return exec.script->nfixed;
69223:     }
69223: 
69223:     /*
69223:      * Function
69223:      *
69223:      * All function frames have an associated interpreted JSFunction.
69223:      */
69223: 
69223:     JSFunction* fun() const {
69223:         JS_ASSERT(isFunctionFrame());
69223:         return exec.fun;
69223:     }
69223: 
69223:     JSFunction* maybeFun() const {
69223:         return isFunctionFrame() ? fun() : NULL;
69223:     }
69223: 
69223:     /*
69223:      * Arguments
69223:      *
69223:      * Only non-eval function frames have arguments. A frame follows its
69223:      * arguments contiguously in memory. The arguments pushed by the caller are
69223:      * the 'actual' arguments. The declared arguments of the callee are the
69223:      * 'formal' arguments. When the caller passes less or equal actual
69223:      * arguments, the actual and formal arguments are the same array (but with
69223:      * different extents). When the caller passes too many arguments, the
69223:      * formal subset of the actual arguments is copied onto the top of the
69223:      * stack. This allows the engine to maintain a jit-time constant offset of
69223:      * arguments from the frame pointer. Since the formal subset of the actual
69223:      * arguments is potentially on the stack twice, it is important for all
69223:      * reads/writes to refer to the same canonical memory location.
69223:      *
69223:      * An arguments object (the object returned by the 'arguments' keyword) is
69223:      * lazily created, so a given function frame may or may not have one.
69223:      */
69223: 
69223:     /* True if this frame has arguments. Contrast with hasArgsObj. */
69223:     bool hasArgs() const {
69223:         return isNonEvalFunctionFrame();
69223:     }
69223: 
69223:     uintN numFormalArgs() const {
69223:         JS_ASSERT(hasArgs());
69223:         return fun()->nargs;
69223:     }
69223: 
69223:     js::Value &formalArg(uintN i) const {
69223:         JS_ASSERT(i < numFormalArgs());
69223:         return formalArgs()[i];
69223:     }
69223: 
69223:     js::Value *formalArgs() const {
69223:         JS_ASSERT(hasArgs());
69223:         return (js::Value *)this - numFormalArgs();
69223:     }
69223: 
69223:     js::Value *formalArgsEnd() const {
69223:         JS_ASSERT(hasArgs());
69223:         return (js::Value *)this;
69223:     }
69223: 
69223:     js::Value *maybeFormalArgs() const {
69223:         return (flags_ & (FUNCTION | EVAL)) == FUNCTION
69223:                ? formalArgs()
69223:                : NULL;
69223:     }
69223: 
69223:     inline uintN numActualArgs() const;
69223:     inline js::Value *actualArgs() const;
69223:     inline js::Value *actualArgsEnd() const;
76128:     inline void ensureCoherentArgCount();
69223: 
69223:     inline js::Value &canonicalActualArg(uintN i) const;
70319:     template <class Op>
70319:     inline bool forEachCanonicalActualArg(Op op, uintN start = 0, uintN count = uintN(-1));
69223:     template <class Op> inline bool forEachFormalArg(Op op);
69223: 
69223:     inline void clearMissingArgs();
69223: 
69223:     bool hasArgsObj() const {
69223:         return !!(flags_ & HAS_ARGS_OBJ);
69223:     }
69223: 
69827:     ArgumentsObject &argsObj() const {
69223:         JS_ASSERT(hasArgsObj());
69223:         JS_ASSERT(!isEvalFrame());
69223:         return *args.obj;
69223:     }
69223: 
69827:     ArgumentsObject *maybeArgsObj() const {
69223:         return hasArgsObj() ? &argsObj() : NULL;
69223:     }
69223: 
69827:     inline void setArgsObj(ArgumentsObject &obj);
69223: 
69223:     /*
69223:      * This value
69223:      *
69223:      * Every frame has a this value although, until 'this' is computed, the
69223:      * value may not be the semantically-correct 'this' value.
69223:      *
69223:      * The 'this' value is stored before the formal arguments for function
69223:      * frames and directly before the frame for global frames. The *Args
69223:      * members assert !isEvalFrame(), so we implement specialized inline
69223:      * methods for accessing 'this'. When the caller has static knowledge that
69223:      * a frame is a function or global frame, 'functionThis' and 'globalThis',
69223:      * respectively, allow more efficient access.
69223:      */
69223: 
69223:     js::Value &functionThis() const {
69223:         JS_ASSERT(isFunctionFrame());
69223:         if (isEvalFrame())
69223:             return ((js::Value *)this)[-1];
69223:         return formalArgs()[-1];
69223:     }
69223: 
69223:     JSObject &constructorThis() const {
69223:         JS_ASSERT(hasArgs());
69223:         return formalArgs()[-1].toObject();
69223:     }
69223: 
69223:     js::Value &globalThis() const {
69223:         JS_ASSERT(isGlobalFrame());
69223:         return ((js::Value *)this)[-1];
69223:     }
69223: 
69223:     js::Value &thisValue() const {
69223:         if (flags_ & (EVAL | GLOBAL))
69223:             return ((js::Value *)this)[-1];
69223:         return formalArgs()[-1];
69223:     }
69223: 
69223:     /*
69223:      * Callee
69223:      *
69223:      * Only function frames have a callee. An eval frame in a function has the
69223:      * same caller as its containing function frame.
69223:      */
69223: 
69223:     js::Value &calleev() const {
69223:         JS_ASSERT(isFunctionFrame());
69223:         if (isEvalFrame())
69223:             return ((js::Value *)this)[-2];
69223:         return formalArgs()[-2];
69223:     }
69223: 
69223:     JSObject &callee() const {
69223:         JS_ASSERT(isFunctionFrame());
69223:         return calleev().toObject();
69223:     }
69223: 
69223:     JSObject *maybeCallee() const {
69223:         return isFunctionFrame() ? &callee() : NULL;
69223:     }
69223: 
69223:     js::CallReceiver callReceiver() const {
69223:         return js::CallReceiverFromArgv(formalArgs());
69223:     }
69223: 
69223:     /*
69223:      * getValidCalleeObject is a fallible getter to compute the correct callee
69223:      * function object, which may require deferred cloning due to the JSObject
69223:      * methodReadBarrier. For a non-function frame, return true with *vp set
69223:      * from calleev, which may not be an object (it could be undefined).
69223:      */
69223:     bool getValidCalleeObject(JSContext *cx, js::Value *vp);
69223: 
69223:     /*
69223:      * Scope chain
69223:      *
69223:      * Every frame has a scopeChain which, when traversed via the 'parent' link
69223:      * to the root, indicates the current global object. A 'call object' is a
69223:      * node on a scope chain representing a function's activation record. A
69223:      * call object is used for dynamically-scoped name lookup and lexically-
69223:      * scoped upvar access. The call object holds the values of locals and
69223:      * arguments when a function returns (and its stack frame is popped). For
69223:      * performance reasons, call objects are created lazily for 'lightweight'
69223:      * functions, i.e., functions which are not statically known to require a
69223:      * call object. Thus, a given function frame may or may not have a call
69223:      * object. When a function does have a call object, it is found by walking
69223:      * up the scope chain until the first call object. Thus, it is important,
69223:      * when setting the scope chain, to indicate whether the new scope chain
69223:      * contains a new call object and thus changes the 'hasCallObj' state.
69223:      *
69223:      * NB: 'fp->hasCallObj()' implies that fp->callObj() needs to be 'put' when
69223:      * the frame is popped. Since the scope chain of a non-strict eval frame
69223:      * contains the call object of the parent (function) frame, it is possible
69223:      * to have:
69223:      *   !fp->hasCall() && fp->scopeChain().isCall()
69223:      */
69223: 
69223:     JSObject &scopeChain() const {
69223:         JS_ASSERT_IF(!(flags_ & HAS_SCOPECHAIN), isFunctionFrame());
69223:         if (!(flags_ & HAS_SCOPECHAIN)) {
69223:             scopeChain_ = callee().getParent();
69223:             flags_ |= HAS_SCOPECHAIN;
69223:         }
69223:         return *scopeChain_;
69223:     }
69223: 
69223:     bool hasCallObj() const {
69223:         bool ret = !!(flags_ & HAS_CALL_OBJ);
69223:         JS_ASSERT_IF(ret, !isNonStrictEvalFrame());
69223:         return ret;
69223:     }
69223: 
69223:     inline JSObject &callObj() const;
69223:     inline void setScopeChainNoCallObj(JSObject &obj);
69223:     inline void setScopeChainWithOwnCallObj(JSObject &obj);
69223: 
69223:     /*
69223:      * NB: putActivationObjects does not mark activation objects as having been
69223:      * put (since the frame is about to be popped).
69223:      */
69223:     inline void putActivationObjects();
69223:     inline void markActivationObjectsAsPut();
69223: 
69223:     /*
69223:      * Frame compartment
69223:      *
69223:      * A stack frame's compartment is the frame's containing context's
69223:      * compartment when the frame was pushed.
69223:      */
69223: 
69223:     JSCompartment *compartment() const {
69223:         JS_ASSERT_IF(isScriptFrame(), scopeChain().compartment() == script()->compartment);
69223:         return scopeChain().compartment();
69223:     }
69223: 
69223:     /*
69223:      * Imacropc
69223:      *
69223:      * A frame's IMacro pc is the bytecode address when an imacro started
69223:      * executing (guaranteed non-null). An imacro does not push a frame, so
69223:      * when the imacro finishes, the frame's IMacro pc becomes the current pc.
69223:      */
69223: 
69223:     bool hasImacropc() const {
69223:         return flags_ & HAS_IMACRO_PC;
69223:     }
69223: 
69223:     jsbytecode *imacropc() const {
69223:         JS_ASSERT(hasImacropc());
69223:         return imacropc_;
69223:     }
69223: 
69223:     jsbytecode *maybeImacropc() const {
69223:         return hasImacropc() ? imacropc() : NULL;
69223:     }
69223: 
69223:     void clearImacropc() {
69223:         flags_ &= ~HAS_IMACRO_PC;
69223:     }
69223: 
69223:     void setImacropc(jsbytecode *pc) {
69223:         JS_ASSERT(pc);
69223:         JS_ASSERT(!(flags_ & HAS_IMACRO_PC));
69223:         imacropc_ = pc;
69223:         flags_ |= HAS_IMACRO_PC;
69223:     }
69223: 
69223:     /* Annotation (will be removed after bug 546848) */
69223: 
69223:     void* annotation() const {
69223:         return (flags_ & HAS_ANNOTATION) ? annotation_ : NULL;
69223:     }
69223: 
69223:     void setAnnotation(void *annot) {
69223:         flags_ |= HAS_ANNOTATION;
69223:         annotation_ = annot;
69223:     }
69223: 
76020:     /* JIT rejoin state */
76020: 
76020:     JSRejoinState rejoin() const {
76020:         return rejoin_;
76020:     }
76020: 
76020:     void setRejoin(JSRejoinState state) {
76020:         rejoin_ = state;
76020:     }
76020: 
69223:     /* Debugger hook data */
69223: 
69223:     bool hasHookData() const {
69223:         return !!(flags_ & HAS_HOOK_DATA);
69223:     }
69223: 
69223:     void* hookData() const {
69223:         JS_ASSERT(hasHookData());
69223:         return hookData_;
69223:     }
69223: 
69223:     void* maybeHookData() const {
69223:         return hasHookData() ? hookData_ : NULL;
69223:     }
69223: 
69223:     void setHookData(void *v) {
69223:         hookData_ = v;
69223:         flags_ |= HAS_HOOK_DATA;
69223:     }
69223: 
69223:     /* Return value */
69223: 
69223:     const js::Value &returnValue() {
69223:         if (!(flags_ & HAS_RVAL))
69223:             rval_.setUndefined();
69223:         return rval_;
69223:     }
69223: 
69223:     void markReturnValue() {
69223:         flags_ |= HAS_RVAL;
69223:     }
69223: 
69223:     void setReturnValue(const js::Value &v) {
69223:         rval_ = v;
69223:         markReturnValue();
69223:     }
69223: 
69223:     void clearReturnValue() {
69223:         rval_.setUndefined();
69223:         markReturnValue();
69223:     }
69223: 
69223:     /* Native-code return address */
69223: 
69223:     void *nativeReturnAddress() const {
69223:         return ncode_;
69223:     }
69223: 
69223:     void setNativeReturnAddress(void *addr) {
69223:         ncode_ = addr;
69223:     }
69223: 
69223:     void **addressOfNativeReturnAddress() {
69223:         return &ncode_;
69223:     }
69223: 
69223:     /*
69223:      * Generator-specific members
69223:      *
69223:      * A non-eval function frame may optionally be the activation of a
69223:      * generator. For the most part, generator frames act like ordinary frames.
69223:      * For exceptions, see js_FloatingFrameIfGenerator.
69223:      */
69223: 
69223:     bool isGeneratorFrame() const {
69223:         return !!(flags_ & GENERATOR);
69223:     }
69223: 
69223:     bool isFloatingGenerator() const {
69223:         JS_ASSERT_IF(flags_ & FLOATING_GENERATOR, isGeneratorFrame());
69223:         return !!(flags_ & FLOATING_GENERATOR);
69223:     }
69223: 
69223:     void initFloatingGenerator() {
69223:         JS_ASSERT(!(flags_ & GENERATOR));
69223:         flags_ |= (GENERATOR | FLOATING_GENERATOR);
69223:     }
69223: 
69223:     void unsetFloatingGenerator() {
69223:         flags_ &= ~FLOATING_GENERATOR;
69223:     }
69223: 
69223:     void setFloatingGenerator() {
69223:         flags_ |= FLOATING_GENERATOR;
69223:     }
69223: 
69223:     /*
69223:      * js::Execute pushes both global and function frames (since eval() in a
69223:      * function pushes a frame with isFunctionFrame() && isEvalFrame()). Most
69223:      * code should not care where a frame was pushed, but if it is necessary to
69223:      * pick out frames pushed by js::Execute, this is the right query:
69223:      */
69223: 
69223:     bool isFramePushedByExecute() const {
69223:         return !!(flags_ & (GLOBAL | EVAL));
69223:     }
69223: 
69223:     /*
69223:      * Other flags
69223:      */
69223: 
69223:     bool isConstructing() const {
69223:         return !!(flags_ & CONSTRUCTING);
69223:     }
69223: 
69223:     uint32 isConstructingFlag() const {
69223:         JS_ASSERT(isFunctionFrame());
69223:         JS_ASSERT((flags_ & ~(CONSTRUCTING | FUNCTION)) == 0);
69223:         return flags_;
69223:     }
69223: 
69223:     bool isDebuggerFrame() const {
69223:         return !!(flags_ & DEBUGGER);
69223:     }
69223: 
69704:     bool isDirectEvalOrDebuggerFrame() const {
69704:         return (flags_ & (EVAL | DEBUGGER)) && !(flags_ & GLOBAL);
69223:     }
69223: 
69223:     bool hasOverriddenArgs() const {
69223:         return !!(flags_ & OVERRIDE_ARGS);
69223:     }
69223: 
69223:     bool hasOverflowArgs() const {
69223:         return !!(flags_ & OVERFLOW_ARGS);
69223:     }
69223: 
69223:     void setOverriddenArgs() {
69223:         flags_ |= OVERRIDE_ARGS;
69223:     }
69223: 
69223:     bool isYielding() {
69223:         return !!(flags_ & YIELDING);
69223:     }
69223: 
69223:     void setYielding() {
69223:         flags_ |= YIELDING;
69223:     }
69223: 
69223:     void clearYielding() {
69223:         flags_ &= ~YIELDING;
69223:     }
69223: 
69223:     void setFinishedInInterpreter() {
69223:         flags_ |= FINISHED_IN_INTERP;
69223:     }
69223: 
69223:     bool finishedInInterpreter() const {
69223:         return !!(flags_ & FINISHED_IN_INTERP);
69223:     }
69223: 
69223: #ifdef DEBUG
69223:     /* Poison scopeChain value set before a frame is flushed. */
69223:     static JSObject *const sInvalidScopeChain;
69223: #endif
69223: 
69223:   public:
69223:     /* Public, but only for JIT use: */
69223: 
69223:     static size_t offsetOfFlags() {
69223:         return offsetof(StackFrame, flags_);
69223:     }
69223: 
69223:     static size_t offsetOfExec() {
69223:         return offsetof(StackFrame, exec);
69223:     }
69223: 
69223:     void *addressOfArgs() {
69223:         return &args;
69223:     }
69223: 
76128:     static size_t offsetOfArgs() {
76128:         return offsetof(StackFrame, args);
76128:     }
76128: 
69223:     static size_t offsetOfScopeChain() {
69223:         return offsetof(StackFrame, scopeChain_);
69223:     }
69223: 
69223:     JSObject **addressOfScopeChain() {
69223:         JS_ASSERT(flags_ & HAS_SCOPECHAIN);
69223:         return &scopeChain_;
69223:     }
69223: 
69223:     static size_t offsetOfPrev() {
69223:         return offsetof(StackFrame, prev_);
69223:     }
69223: 
69223:     static size_t offsetOfReturnValue() {
69223:         return offsetof(StackFrame, rval_);
69223:     }
69223: 
69223:     static ptrdiff_t offsetOfNcode() {
69223:         return offsetof(StackFrame, ncode_);
69223:     }
69223: 
69223:     static ptrdiff_t offsetOfCallee(JSFunction *fun) {
69223:         JS_ASSERT(fun != NULL);
69223:         return -(fun->nargs + 2) * sizeof(js::Value);
69223:     }
69223: 
69223:     static ptrdiff_t offsetOfThis(JSFunction *fun) {
69223:         return fun == NULL
69223:                ? -1 * ptrdiff_t(sizeof(js::Value))
69223:                : -(fun->nargs + 1) * ptrdiff_t(sizeof(js::Value));
69223:     }
69223: 
69223:     static ptrdiff_t offsetOfFormalArg(JSFunction *fun, uintN i) {
69223:         JS_ASSERT(i < fun->nargs);
69223:         return (-(int)fun->nargs + i) * sizeof(js::Value);
69223:     }
69223: 
69223:     static size_t offsetOfFixed(uintN i) {
69223:         return sizeof(StackFrame) + i * sizeof(js::Value);
69223:     }
69223: 
69223: #ifdef JS_METHODJIT
69223:     js::mjit::JITScript *jit() {
69223:         return script()->getJIT(isConstructing());
69223:     }
69223: #endif
69223: 
69223:     void methodjitStaticAsserts();
69223: };
69223: 
69223: static const size_t VALUES_PER_STACK_FRAME = sizeof(StackFrame) / sizeof(Value);
69223: 
69223: inline StackFrame *          Valueify(JSStackFrame *fp) { return (StackFrame *)fp; }
69223: static inline JSStackFrame * Jsvalify(StackFrame *fp)   { return (JSStackFrame *)fp; }
69223: 
69223: /*****************************************************************************/
69223: 
69223: class FrameRegs
69223: {
69223:   public:
69223:     Value *sp;
69223:     jsbytecode *pc;
69223:   private:
76001:     JSInlinedSite *inlined_;
69223:     StackFrame *fp_;
69223:   public:
69223:     StackFrame *fp() const { return fp_; }
76001:     JSInlinedSite *inlined() const { return inlined_; }
69223: 
69223:     /* For jit use (need constant): */
76001:     static const size_t offsetOfFp = 3 * sizeof(void *);
76001:     static const size_t offsetOfInlined = 2 * sizeof(void *);
69223:     static void staticAssert() {
69223:         JS_STATIC_ASSERT(offsetOfFp == offsetof(FrameRegs, fp_));
76001:         JS_STATIC_ASSERT(offsetOfInlined == offsetof(FrameRegs, inlined_));
69223:     }
76001:     void clearInlined() { inlined_ = NULL; }
69223: 
69223:     /* For generator: */
69223:     void rebaseFromTo(StackFrame *from, StackFrame *to) {
69223:         fp_ = to;
69223:         sp = to->slots() + (sp - from->slots());
69223:     }
69223: 
69223:     /* For ContextStack: */
69223:     void popFrame(Value *newsp) {
76001:         pc = fp_->prevpc(&inlined_);
69223:         sp = newsp;
69223:         fp_ = fp_->prev();
69223:     }
69223: 
69223:     /* For FixupArity: */
69223:     void popPartialFrame(Value *newsp) {
69223:         sp = newsp;
69223:         fp_ = fp_->prev();
69223:     }
69223: 
76020:     /* For InternalInterpret: */
76020:     void restorePartialFrame(Value *newfp) {
76020:         fp_ = (StackFrame *) newfp;
69223:     }
69223: 
69223:     /* For stubs::CompileFunction, ContextStack: */
69223:     void prepareToRun(StackFrame *fp, JSScript *script) {
69223:         pc = script->code;
69223:         sp = fp->slots() + script->nfixed;
69223:         fp_ = fp;
76001:         inlined_ = NULL;
69223:     }
69223: 
69223:     /* For pushDummyFrame: */
69223:     void initDummyFrame(StackFrame *fp) {
69223:         pc = NULL;
69223:         sp = fp->slots();
69223:         fp_ = fp;
76001:         inlined_ = NULL;
69223:     }
76001: 
76001:     /* For expandInlineFrames: */
76001:     void expandInline(StackFrame *innerfp, jsbytecode *innerpc) {
76001:         pc = innerpc;
76001:         fp_ = innerfp;
76001:         inlined_ = NULL;
69859:     }
76126: 
76126: #ifdef JS_METHODJIT
76126:     /* For LimitCheck: */
76126:     void updateForNcode(mjit::JITScript *jit, void *ncode) {
76126:         pc = mjit::NativeToPC(jit, ncode, &inlined_);
76126:     }
76126: #endif
69223: };
69223: 
69223: /*****************************************************************************/
69223: 
69223: struct StackOverride
69223: {
69223:     Value         *top;
69223: #ifdef DEBUG
69223:     StackSegment  *seg;
69223:     StackFrame    *frame;
76001:     JSInlinedSite *inlined;
69223: #endif
69223: };
69223: 
69223: /*****************************************************************************/
69223: 
69223: class StackSpace
69223: {
69223:     Value         *base_;
69223: #ifdef XP_WIN
69223:     mutable Value *commitEnd_;
69223: #endif
69223:     Value *end_;
69223:     StackSegment  *seg_;
69223:     StackOverride override_;
69223: 
69223:     static const size_t CAPACITY_VALS  = 512 * 1024;
69223:     static const size_t CAPACITY_BYTES = CAPACITY_VALS * sizeof(Value);
69223:     static const size_t COMMIT_VALS    = 16 * 1024;
69223:     static const size_t COMMIT_BYTES   = COMMIT_VALS * sizeof(Value);
69223: 
69223:     static void staticAsserts() {
69223:         JS_STATIC_ASSERT(CAPACITY_VALS % COMMIT_VALS == 0);
69223:     }
69223: 
69223: #ifdef XP_WIN
69223:     JS_FRIEND_API(bool) bumpCommit(JSContext *maybecx, Value *from, ptrdiff_t nvals) const;
69223: #endif
69223: 
69223:     friend class ContextStack;
69223:     friend struct detail::OOMCheck;
69223:     inline bool ensureSpace(JSContext *maybecx, Value *from, ptrdiff_t nvals) const;
69223:     void pushSegment(StackSegment &seg);
69223:     void popSegment();
69223:     inline void pushOverride(Value *top, StackOverride *prev);
69223:     inline void popOverride(const StackOverride &prev);
69223: 
69223:   public:
69223:     StackSpace();
69223:     bool init();
69223:     ~StackSpace();
69223: 
69223:     /* See stack layout comment above. */
69223:     StackSegment *currentSegment() const { return seg_; }
69223:     Value *firstUnused() const;
69223: 
69223:     /* Optimization of firstUnused when currentSegment() is known active. */
69223:     inline Value *activeFirstUnused() const;
69223: 
69223:     /* Get the segment containing the target frame. */
69223:     StackSegment &containingSegment(const StackFrame *target) const;
69223: 
69223:     /*
69223:      * Retrieve the 'variables object' (ES3 term) associated with the given
69223:      * frame's Execution Context's VariableEnvironment (ES5 10.3).
69223:      */
69223:     JSObject &varObjForFrame(const StackFrame *fp);
69223: 
70320: #ifdef JS_TRACER
69223:     /*
69223:      * LeaveTree requires stack allocation to rebuild the stack. There is no
69223:      * good way to handle an OOM for these allocations, so this function checks
69223:      * that OOM cannot occur using the size of the TraceNativeStorage as a
69223:      * conservative upper bound.
69223:      */
69223:     inline bool ensureEnoughSpaceToEnterTrace();
70320: #endif
69223: 
69223:     /*
69223:      * If we let infinite recursion go until it hit the end of the contiguous
69223:      * stack, it would take a long time. As a heuristic, we kill scripts which
69223:      * go deeper than MAX_INLINE_CALLS. Note: this heuristic only applies to a
69223:      * single activation of the VM. If a script reenters, the call count gets
69223:      * reset. This is ok because we will quickly hit the C recursion limit.
69223:      */
69223:     static const size_t MAX_INLINE_CALLS = 3000;
69223: 
69223:     /*
69223:      * SunSpider and v8bench have roughly an average of 9 slots per script. Our
69223:      * heuristic for a quick over-recursion check uses a generous slot count
69223:      * based on this estimate. We take this frame size and multiply it by the
69223:      * old recursion limit from the interpreter. Worst case, if an average size
69223:      * script (<=9 slots) over recurses, it'll effectively be the same as having
69223:      * increased the old inline call count to <= 5,000.
69223:      */
69223:     static const size_t STACK_QUOTA = MAX_INLINE_CALLS * (VALUES_PER_STACK_FRAME + 18);
69223: 
69223:     /*
76001:      * Extra space to reserve on the stack before invoking the method JIT.
76001:      * This may be used for inlined stack frames.
76001:      */
76001:     static const size_t STACK_EXTRA = (VALUES_PER_STACK_FRAME + 18) * 10;
76001: 
76001:     /*
69223:      * In the mjit, we'd like to collapse two "overflow" checks into one:
69223:      *  - the MAX_INLINE_CALLS check (see above comment)
69223:      *  - the stack OOM check (or, on Windows, the commit/OOM check) This
69223:      * function produces a 'limit' pointer that satisfies both these checks.
69223:      * (The STACK_QUOTA comment explains how this limit simulates checking
69223:      * MAX_INLINE_CALLS.) This limit is guaranteed to have at least enough space
69223:      * for cx->fp()->nslots() plus an extra stack frame (which is the min
69223:      * requirement for entering mjit code) or else an error is reported and NULL
69223:      * is returned. When the stack grows past the returned limit, the script may
69223:      * still be within quota, but more memory needs to be committed. This is
69223:      * handled by bumpLimitWithinQuota.
69223:      */
69223:     inline Value *getStackLimit(JSContext *cx);
69223: 
69223:     /*
69223:      * Try to bump the limit, staying within |base + STACK_QUOTA|, by
69223:      * committing more pages of the contiguous stack.
69223:      *  base: the frame on which execution started
69223:      *  from: the current top of the stack
69223:      *  nvals: requested space above 'from'
69223:      *  *limit: receives bumped new limit
69223:      */
69223:     bool bumpLimitWithinQuota(JSContext *maybecx, StackFrame *base, Value *from, uintN nvals, Value **limit) const;
69223: 
69223:     /*
69223:      * Raise the given limit without considering quota.
69223:      * See comment in BumpStackFull.
69223:      */
69223:     bool bumpLimit(JSContext *cx, StackFrame *base, Value *from, uintN nvals, Value **limit) const;
69223: 
69223:     /* Called during GC: mark segments, frames, and slots under firstUnused. */
69223:     void mark(JSTracer *trc);
69223: };
69223: 
69223: /*****************************************************************************/
69223: 
69223: class ContextStack
69223: {
69223:     FrameRegs *regs_;
69223:     StackSegment *seg_;
69223:     StackSpace *space_;
69223:     JSContext *cx_;
69223: 
69223:     /*
69223:      * This is the collecting-point for code that wants to know when there is
69223:      * no JS active. Note that "no JS active" does not mean the stack is empty
69223:      * because of JS_(Save|Restore)FrameChain. If code really wants to know
69223:      * when the stack is empty, test |cx->stack.empty()|.
69223:      */
69223:     void notifyIfNoCodeRunning();
69223: 
69223:     /*
69223:      * Return whether this ContextStack is running code at the top of the
69223:      * contiguous stack. This is a precondition for extending the current
69223:      * segment by pushing stack frames or overrides etc.
69223:      */
69223:     inline bool isCurrentAndActive() const;
69223: 
69223: #ifdef DEBUG
69223:     void assertSegmentsInSync() const;
69223:     void assertSpaceInSync() const;
69223: #else
69223:     void assertSegmentsInSync() const {}
69223:     void assertSpaceInSync() const {}
69223: #endif
69223: 
69223:     friend class FrameGuard;
69223:     bool getSegmentAndFrame(JSContext *cx, uintN vplen, uintN nslots,
69223:                             FrameGuard *frameGuard) const;
69223:     void pushSegmentAndFrame(FrameRegs &regs, FrameGuard *frameGuard);
69223:     void pushSegmentAndFrameImpl(FrameRegs &regs, StackSegment &seg);
69223:     void popSegmentAndFrame();
69223:     void popSegmentAndFrameImpl();
69223: 
69223:     template <class Check>
69223:     inline StackFrame *getCallFrame(JSContext *cx, Value *sp, uintN nactual,
69223:                                     JSFunction *fun, JSScript *script, uint32 *pflags,
69223:                                     Check check) const;
69223: 
69223:     friend class InvokeArgsGuard;
69223:     bool pushInvokeArgsSlow(JSContext *cx, uintN argc, InvokeArgsGuard *argsGuard);
69223:     void popInvokeArgsSlow(const InvokeArgsGuard &argsGuard);
69223:     inline void popInvokeArgs(const InvokeArgsGuard &argsGuard);
69223: 
69223:     friend class InvokeFrameGuard;
69223:     void pushInvokeFrameSlow(InvokeFrameGuard *frameGuard);
69223:     void popInvokeFrameSlow(const InvokeFrameGuard &frameGuard);
69223:     inline void popInvokeFrame(const InvokeFrameGuard &frameGuard);
69223: 
69223:   public:
69223:     ContextStack(JSContext *cx);
69223:     ~ContextStack();
69223: 
69223:     /*
69223:      * A context is "empty" if it has no code, running or suspended, on its
69223:      * stack. Running code can be stopped (via JS_SaveFrameChain) which leads
69223:      * to the state |!cx->empty() && cx->running()|.
69223:      */
69223:     bool empty() const           { JS_ASSERT_IF(regs_, seg_); return !seg_; }
69223:     bool running() const         { JS_ASSERT_IF(regs_, regs_->fp()); return !!regs_; }
69223: 
69223:     /* Current regs of the current segment (see VM stack layout comment). */
69223:     FrameRegs &regs() const      { JS_ASSERT(regs_); return *regs_; }
69223: 
69223:     /* Convenience helpers. */
69223:     FrameRegs *maybeRegs() const { return regs_; }
69223:     StackFrame *fp() const       { return regs_->fp(); }
69223:     StackFrame *maybefp() const  { return regs_ ? regs_->fp() : NULL; }
69223: 
69223:     /* The StackSpace currently hosting this ContextStack. */
69223:     StackSpace &space() const    { assertSpaceInSync(); return *space_; }
69223: 
69223:     /*
69223:      * To avoid indirection, ContextSpace caches a pointers to the StackSpace.
69223:      * This must be kept coherent with cx->thread->data.space by calling
69223:      * 'threadReset' whenver cx->thread changes.
69223:      */
69223:     void threadReset();
69223: 
69223:     /*
69223:      * As an optimization, the interpreter/mjit can operate on a local
69223:      * FrameRegs instance repoint the ContextStack to this local instance.
69223:      */
69223:     void repointRegs(FrameRegs *regs) {
69223:         JS_ASSERT_IF(regs, regs->fp());
69223:         regs_ = regs;
69223:     }
69223: 
69223:     /* Return the current segment, which may or may not be active. */
69223:     js::StackSegment *currentSegment() const {
69223:         assertSegmentsInSync();
69223:         return seg_;
69223:     }
69223: 
69223:     /* This is an optimization of StackSpace::varObjForFrame. */
69223:     inline JSObject &currentVarObj() const;
69223: 
69223:     /* Search the call stack for the nearest frame with static level targetLevel. */
69223:     inline StackFrame *findFrameAtLevel(uintN targetLevel) const;
69223: 
69223: #ifdef DEBUG
69223:     /* Return whether the given frame is in this context's stack. */
69223:     bool contains(const StackFrame *fp) const;
69223: #endif
69223: 
69223:     /* Mark the top segment as suspended, without pushing a new one. */
69223:     void saveActiveSegment();
69223: 
69223:     /* Undoes calls to suspendActiveSegment. */
69223:     void restoreSegment();
69223: 
69223:     /*
69223:      * For the five sets of stack operations below:
69223:      *  - The boolean-valued functions call js_ReportOutOfScriptQuota on OOM.
69223:      *  - The "get*Frame" functions do not change any global state, they just
69223:      *    check OOM and return pointers to an uninitialized frame with the
69223:      *    requested missing arguments/slots. Only once the "push*Frame"
69223:      *    function has been called is global state updated. Thus, between
69223:      *    "get*Frame" and "push*Frame", the frame and slots are unrooted.
69223:      *  - Functions taking "*Guard" arguments will use the guard's destructor
69223:      *    to pop the stack. The caller must ensure the guard has the
69223:      *    appropriate lifetime.
69223:      */
69223: 
69223:     /*
69223:      * pushInvokeArgs allocates |argc + 2| rooted values that will be passed as
69223:      * the arguments to Invoke. A single allocation can be used for multiple
69223:      * Invoke calls. The InvokeArgumentsGuard passed to Invoke must come from
69223:      * an immediately-enclosing (stack-wise) call to pushInvokeArgs.
69223:      */
69223:     bool pushInvokeArgs(JSContext *cx, uintN argc, InvokeArgsGuard *ag);
69223: 
69223:     /* These functions are called inside Invoke, not Invoke clients. */
69223:     inline StackFrame *
69223:     getInvokeFrame(JSContext *cx, const CallArgs &args,
69223:                    JSFunction *fun, JSScript *script, uint32 *flags,
69223:                    InvokeFrameGuard *frameGuard) const;
69223:     void pushInvokeFrame(const CallArgs &args,
69223:                          InvokeFrameGuard *frameGuard);
69223: 
69223:     /* These functions are called inside Execute, not Execute clients. */
69223:     bool getExecuteFrame(JSContext *cx, JSScript *script,
69223:                          ExecuteFrameGuard *frameGuard) const;
69223:     void pushExecuteFrame(JSObject *initialVarObj,
69223:                           ExecuteFrameGuard *frameGuard);
69223: 
69223:     /* These functions are called inside SendToGenerator. */
69223:     bool getGeneratorFrame(JSContext *cx, uintN vplen, uintN nslots,
69223:                            GeneratorFrameGuard *frameGuard);
69223:     void pushGeneratorFrame(FrameRegs &regs,
69223:                             GeneratorFrameGuard *frameGuard);
69223: 
69223:     /* Pushes a StackFrame::isDummyFrame. */
69223:     bool pushDummyFrame(JSContext *cx, JSObject &scopeChain,
69223:                         DummyFrameGuard *frameGuard);
69223: 
69223:     /*
69223:      * An "inline frame" may only be pushed from within the top, active
69223:      * segment. This is the case for calls made inside mjit code and Interpret.
69223:      * The *WithinLimit variant stays within the stack quota using the given
69223:      * limit (see StackSpace::getStackLimit).
69223:      */
69223:     inline StackFrame *
69223:     getInlineFrame(JSContext *cx, Value *sp, uintN nactual,
69223:                    JSFunction *fun, JSScript *script, uint32 *flags) const;
69223:     inline StackFrame *
69223:     getInlineFrameWithinLimit(JSContext *cx, Value *sp, uintN nactual,
69223:                               JSFunction *fun, JSScript *script, uint32 *flags,
76020:                               StackFrame *base, Value **limit, void *topncode) const;
69223:     inline void pushInlineFrame(JSScript *script, StackFrame *fp, FrameRegs &regs);
69223:     inline void popInlineFrame();
69223: 
69223:     /* For jit use: */
69223:     static size_t offsetOfRegs() { return offsetof(ContextStack, regs_); }
69223: };
69223: 
69223: /*****************************************************************************/
69223: 
69223: class InvokeArgsGuard : public CallArgs
69223: {
69223:     friend class ContextStack;
69223:     ContextStack     *stack_;  /* null implies nothing pushed */
69223:     StackSegment     *seg_;    /* null implies no segment pushed */
69223:     StackOverride    prevOverride_;
69223:   public:
69223:     InvokeArgsGuard() : stack_(NULL), seg_(NULL) {}
69223:     ~InvokeArgsGuard();
69223:     bool pushed() const { return stack_ != NULL; }
69223: };
69223: 
69223: /*
69223:  * This type can be used to call Invoke when the arguments have already been
69223:  * pushed onto the stack as part of normal execution.
69223:  */
69223: struct InvokeArgsAlreadyOnTheStack : CallArgs
69223: {
69223:     InvokeArgsAlreadyOnTheStack(uintN argc, Value *vp) : CallArgs(argc, vp + 2) {}
69223: };
69223: 
69223: class InvokeFrameGuard
69223: 
69223: {
69223:     friend class ContextStack;
69223:     ContextStack *stack_;  /* null implies nothing pushed */
69223:     FrameRegs regs_;
69223:     FrameRegs *prevRegs_;
69223:   public:
69223:     InvokeFrameGuard() : stack_(NULL) {}
69223:     ~InvokeFrameGuard();
69223:     bool pushed() const { return stack_ != NULL; }
69223:     void pop();
69223:     StackFrame *fp() const { return regs_.fp(); }
69223: };
69223: 
69223: /* Reusable base; not for direct use. */
69223: class FrameGuard
69223: {
69223:     friend class ContextStack;
69223:     ContextStack *stack_;  /* null implies nothing pushed */
69223:     StackSegment *seg_;
69223:     Value *vp_;
69223:     StackFrame *fp_;
69223:   public:
69223:     FrameGuard() : stack_(NULL), vp_(NULL), fp_(NULL) {}
69223:     ~FrameGuard();
69223:     bool pushed() const { return stack_ != NULL; }
69223:     StackSegment *segment() const { return seg_; }
69223:     Value *vp() const { return vp_; }
69223:     StackFrame *fp() const { return fp_; }
69223: };
69223: 
69223: class ExecuteFrameGuard : public FrameGuard
69223: {
69223:     friend class ContextStack;
69223:     FrameRegs regs_;
69223: };
69223: 
69223: class DummyFrameGuard : public FrameGuard
69223: {
69223:     friend class ContextStack;
69223:     FrameRegs regs_;
69223: };
69223: 
69223: class GeneratorFrameGuard : public FrameGuard
69223: {};
69223: 
69223: /*****************************************************************************/
69223: 
69223: /*
69223:  * While |cx->fp|'s pc/sp are available in |cx->regs|, to compute the saved
69223:  * value of pc/sp for any other frame, it is necessary to know about that
69223:  * frame's next-frame. This iterator maintains this information when walking
69223:  * a chain of stack frames starting at |cx->fp|.
69223:  *
69223:  * Usage:
69223:  *   for (FrameRegsIter i(cx); !i.done(); ++i)
69223:  *     ... i.fp() ... i.sp() ... i.pc()
69223:  */
69223: class FrameRegsIter
69223: {
69223:     JSContext    *cx_;
69223:     StackSegment *seg_;
69223:     StackFrame   *fp_;
69223:     Value        *sp_;
69223:     jsbytecode   *pc_;
69223: 
69223:     void initSlow();
69223:     void incSlow(StackFrame *oldfp);
69223: 
69223:   public:
69223:     inline FrameRegsIter(JSContext *cx);
69223: 
69223:     bool done() const { return fp_ == NULL; }
69223:     inline FrameRegsIter &operator++();
69223: 
69223:     StackFrame *fp() const { return fp_; }
69223:     Value *sp() const { return sp_; }
69223:     jsbytecode *pc() const { return pc_; }
69223: };
69223: 
69223: /*
69223:  * Utility class for iteration over all active stack frames.
69223:  */
69223: class AllFramesIter
69223: {
69223: public:
69223:     AllFramesIter(JSContext *cx);
69223: 
69223:     bool done() const { return fp_ == NULL; }
69223:     AllFramesIter& operator++();
69223: 
69223:     StackFrame *fp() const { return fp_; }
69223: 
69223: private:
69223:     StackSegment *seg_;
69223:     StackFrame *fp_;
69223: };
69223: 
69223: }  /* namespace js */
69223: 
69223: #endif /* Stack_h__ */
