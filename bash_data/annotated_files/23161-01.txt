    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsPageFrame.h"
    1: #include "nsPresContext.h"
    1: #include "nsStyleContext.h"
    1: #include "nsIRenderingContext.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsIPresShell.h"
    1: #include "nsCSSFrameConstructor.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsPageContentFrame.h"
    1: #include "nsDisplayList.h"
    1: #include "nsLayoutUtils.h" // for function BinarySearchForPosition
    1: #include "nsCSSRendering.h"
    1: #include "nsSimplePageSequence.h" // for nsSharedPageData
    1: #include "nsTextFormatter.h" // for page number localization formatting
    1: #ifdef IBMBIDI
    1: #include "nsBidiUtils.h"
    1: #endif
    1: #include "nsIFontMetrics.h"
    1: #include "nsIPrintSettings.h"
    1: #include "nsRegion.h"
    1: 
    1: #include "prlog.h"
    1: #ifdef PR_LOGGING 
    1: extern PRLogModuleInfo * kLayoutPrintingLogMod;
    1: #define PR_PL(_p1)  PR_LOG(kLayoutPrintingLogMod, PR_LOG_DEBUG, _p1)
    1: #else
    1: #define PR_PL(_p1)
    1: #endif
    1: 
    1: nsIFrame*
    1: NS_NewPageFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsPageFrame(aContext);
    1: }
    1: 
    1: nsPageFrame::nsPageFrame(nsStyleContext* aContext)
    1: : nsContainerFrame(aContext)
    1: {
    1: }
    1: 
    1: nsPageFrame::~nsPageFrame()
    1: {
    1: }
    1: 
    1: NS_IMETHODIMP nsPageFrame::Reflow(nsPresContext*          aPresContext,
    1:                                   nsHTMLReflowMetrics&     aDesiredSize,
    1:                                   const nsHTMLReflowState& aReflowState,
    1:                                   nsReflowStatus&          aStatus)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsPageFrame");
    1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
    1:   aStatus = NS_FRAME_COMPLETE;  // initialize out parameter
    1: 
 4006:   NS_ASSERTION(mFrames.FirstChild() &&
 4006:                nsGkAtoms::pageContentFrame == mFrames.FirstChild()->GetType(),
 4006:                "pageFrame must have a pageContentFrame child");
    1: 
    1:   // Resize our frame allowing it only to be as big as we are
    1:   // XXX Pay attention to the page's border and padding...
    1:   if (mFrames.NotEmpty()) {
    1:     nsIFrame* frame = mFrames.FirstChild();
    1:     // When the reflow size is NS_UNCONSTRAINEDSIZE it means we are reflowing
    1:     // a single page to print selection. So this means we want to use
    1:     // NS_UNCONSTRAINEDSIZE without altering it
    1:     nscoord avHeight;
    1:     if (mPD->mReflowSize.height == NS_UNCONSTRAINEDSIZE) {
    1:       avHeight = NS_UNCONSTRAINEDSIZE;
    1:     } else {
    1:       avHeight = mPD->mReflowSize.height - mPD->mReflowMargin.TopBottom();
    1:     }
    1:     nsSize  maxSize(mPD->mReflowSize.width - mPD->mReflowMargin.LeftRight(),
    1:                     avHeight);
    1:     float scale = aPresContext->GetPageScale();
    1:     maxSize.width = NSToCoordCeil(maxSize.width / scale);
14185:     if (maxSize.height != NS_UNCONSTRAINEDSIZE) {
    1:       maxSize.height = NSToCoordCeil(maxSize.height / scale);
14185:     }
    1:     // Get the number of Twips per pixel from the PresContext
    1:     nscoord onePixelInTwips = nsPresContext::CSSPixelsToAppUnits(1);
    1:     // insurance against infinite reflow, when reflowing less than a pixel
    1:     // XXX Shouldn't we do something more friendly when invalid margins
    1:     //     are set?
    1:     if (maxSize.width < onePixelInTwips || maxSize.height < onePixelInTwips) {
    1:       aDesiredSize.width  = 0;
    1:       aDesiredSize.height = 0;
    1:       NS_WARNING("Reflow aborted; no space for content");
    1:       return NS_OK;
    1:     }
    1: 
    1:     nsHTMLReflowState kidReflowState(aPresContext, aReflowState, frame, maxSize);
    1:     kidReflowState.mFlags.mIsTopOfPage = PR_TRUE;
    1:     kidReflowState.mFlags.mTableIsSplittable = PR_TRUE;
    1: 
    1:     // calc location of frame
    1:     nscoord xc = mPD->mReflowMargin.left + mPD->mExtraMargin.left;
    1:     nscoord yc = mPD->mReflowMargin.top + mPD->mExtraMargin.top;
    1: 
    1:     // Get the child's desired size
    1:     ReflowChild(frame, aPresContext, aDesiredSize, kidReflowState, xc, yc, 0, aStatus);
    1: 
    1:     // Place and size the child
    1:     FinishReflowChild(frame, aPresContext, &kidReflowState, aDesiredSize, xc, yc, 0);
    1: 
 4006:     NS_ASSERTION(!NS_FRAME_IS_FULLY_COMPLETE(aStatus) ||
    1:                  !frame->GetNextInFlow(), "bad child flow list");
    1:   }
    1:   PR_PL(("PageFrame::Reflow %p ", this));
    1:   PR_PL(("[%d,%d][%d,%d]\n", aDesiredSize.width, aDesiredSize.height, aReflowState.availableWidth, aReflowState.availableHeight));
    1: 
    1:   // Return our desired size
    1:   aDesiredSize.width = aReflowState.availableWidth;
    1:   if (aReflowState.availableHeight != NS_UNCONSTRAINEDSIZE) {
    1:     aDesiredSize.height = aReflowState.availableHeight;
    1:   }
    1:   PR_PL(("PageFrame::Reflow %p ", this));
    1:   PR_PL(("[%d,%d]\n", aReflowState.availableWidth, aReflowState.availableHeight));
    1: 
    1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
    1:   return NS_OK;
    1: }
    1: 
    1: nsIAtom*
    1: nsPageFrame::GetType() const
    1: {
    1:   return nsGkAtoms::pageFrame; 
    1: }
    1: 
    1: #ifdef DEBUG
    1: NS_IMETHODIMP
    1: nsPageFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("Page"), aResult);
    1: }
    1: #endif
    1: 
    1: /* virtual */ PRBool
    1: nsPageFrame::IsContainingBlock() const
    1: {
    1:   return PR_TRUE;
    1: }
    1: 
    1: void 
    1: nsPageFrame::ProcessSpecialCodes(const nsString& aStr, nsString& aNewStr)
    1: {
    1: 
    1:   aNewStr = aStr;
    1: 
    1:   // Search to see if the &D code is in the string 
    1:   // then subst in the current date/time
    1:   NS_NAMED_LITERAL_STRING(kDate, "&D");
    1:   if (aStr.Find(kDate) != kNotFound) {
    1:     if (mPD->mDateTimeStr != nsnull) {
    1:       aNewStr.ReplaceSubstring(kDate.get(), mPD->mDateTimeStr);
    1:     } else {
    1:       aNewStr.ReplaceSubstring(kDate.get(), EmptyString().get());
    1:     }
    1:   }
    1: 
    1:   // NOTE: Must search for &PT before searching for &P
    1:   //
    1:   // Search to see if the "page number and page" total code are in the string
    1:   // and replace the page number and page total code with the actual
    1:   // values
    1:   NS_NAMED_LITERAL_STRING(kPageAndTotal, "&PT");
    1:   if (aStr.Find(kPageAndTotal) != kNotFound) {
    1:     PRUnichar * uStr = nsTextFormatter::smprintf(mPD->mPageNumAndTotalsFormat, mPageNum, mTotNumPages);
    1:     aNewStr.ReplaceSubstring(kPageAndTotal.get(), uStr);
    1:     nsMemory::Free(uStr);
    1:   }
    1: 
    1:   // Search to see if the page number code is in the string
    1:   // and replace the page number code with the actual value
    1:   NS_NAMED_LITERAL_STRING(kPage, "&P");
    1:   if (aStr.Find(kPage) != kNotFound) {
    1:     PRUnichar * uStr = nsTextFormatter::smprintf(mPD->mPageNumFormat, mPageNum);
    1:     aNewStr.ReplaceSubstring(kPage.get(), uStr);
    1:     nsMemory::Free(uStr);
    1:   }
    1: 
    1:   NS_NAMED_LITERAL_STRING(kTitle, "&T");
    1:   if (aStr.Find(kTitle) != kNotFound) {
    1:     if (mPD->mDocTitle != nsnull) {
    1:       aNewStr.ReplaceSubstring(kTitle.get(), mPD->mDocTitle);
    1:     } else {
    1:       aNewStr.ReplaceSubstring(kTitle.get(), EmptyString().get());
    1:     }
    1:   }
    1: 
    1:   NS_NAMED_LITERAL_STRING(kDocURL, "&U");
    1:   if (aStr.Find(kDocURL) != kNotFound) {
    1:     if (mPD->mDocURL != nsnull) {
    1:       aNewStr.ReplaceSubstring(kDocURL.get(), mPD->mDocURL);
    1:     } else {
    1:       aNewStr.ReplaceSubstring(kDocURL.get(), EmptyString().get());
    1:     }
    1:   }
    1: 
    1:   NS_NAMED_LITERAL_STRING(kPageTotal, "&L");
    1:   if (aStr.Find(kPageTotal) != kNotFound) {
    1:     PRUnichar * uStr = nsTextFormatter::smprintf(mPD->mPageNumFormat, mTotNumPages);
    1:     aNewStr.ReplaceSubstring(kPageTotal.get(), uStr);
    1:     nsMemory::Free(uStr);
    1:   }
    1: }
    1: 
    1: 
    1: //------------------------------------------------------------------------------
    1: nscoord nsPageFrame::GetXPosition(nsIRenderingContext& aRenderingContext, 
    1:                                   const nsRect&        aRect, 
    1:                                   PRInt32              aJust,
    1:                                   const nsString&      aStr)
    1: {
    1:   nscoord width = nsLayoutUtils::GetStringWidth(this, &aRenderingContext,
    1:                                                 aStr.get(), aStr.Length());
    1: 
    1:   nscoord x = aRect.x;
    1:   switch (aJust) {
    1:     case nsIPrintSettings::kJustLeft:
    1:       x += mPD->mExtraMargin.left + mPD->mEdgePaperMargin.left;
    1:       break;
    1: 
    1:     case nsIPrintSettings::kJustCenter:
    1:       x += (aRect.width - width) / 2;
    1:       break;
    1: 
    1:     case nsIPrintSettings::kJustRight:
    1:       x += aRect.width - width - mPD->mExtraMargin.right - mPD->mEdgePaperMargin.right;
    1:       break;
    1:   } // switch
    1: 
    1:   return x;
    1: }
    1: 
    1: // Draw a header or footer
    1: // @param aRenderingContext - rendering content ot draw into
    1: // @param aHeaderFooter - indicates whether it is a header or footer
    1: // @param aStrLeft - string for the left header or footer; can be empty
    1: // @param aStrCenter - string for the center header or footer; can be empty
    1: // @param aStrRight - string for the right header or footer; can be empty
    1: // @param aRect - the rect of the page
    1: // @param aAscent - the ascent of the font
    1: // @param aHeight - the height of the font
    1: void
    1: nsPageFrame::DrawHeaderFooter(nsIRenderingContext& aRenderingContext,
    1:                               nsHeaderFooterEnum   aHeaderFooter,
    1:                               const nsString&      aStrLeft,
    1:                               const nsString&      aStrCenter,
    1:                               const nsString&      aStrRight,
    1:                               const nsRect&        aRect,
    1:                               nscoord              aAscent,
    1:                               nscoord              aHeight)
    1: {
    1:   PRInt32 numStrs = 0;
    1:   if (!aStrLeft.IsEmpty()) numStrs++;
    1:   if (!aStrCenter.IsEmpty()) numStrs++;
    1:   if (!aStrRight.IsEmpty()) numStrs++;
    1: 
    1:   if (numStrs == 0) return;
    1:   nscoord strSpace = aRect.width / numStrs;
    1: 
    1:   if (!aStrLeft.IsEmpty()) {
    1:     DrawHeaderFooter(aRenderingContext, aHeaderFooter,
    1:                      nsIPrintSettings::kJustLeft, aStrLeft, aRect, aAscent,
    1:                      aHeight, strSpace);
    1:   }
    1:   if (!aStrCenter.IsEmpty()) {
    1:     DrawHeaderFooter(aRenderingContext, aHeaderFooter,
    1:                      nsIPrintSettings::kJustCenter, aStrCenter, aRect, aAscent,
    1:                      aHeight, strSpace);
    1:   }
    1:   if (!aStrRight.IsEmpty()) {
    1:     DrawHeaderFooter(aRenderingContext, aHeaderFooter,
    1:                      nsIPrintSettings::kJustRight, aStrRight, aRect, aAscent,
    1:                      aHeight, strSpace);
    1:   }
    1: }
    1: 
    1: // Draw a header or footer string
    1: // @param aRenderingContext - rendering content ot draw into
    1: // @param aHeaderFooter - indicates whether it is a header or footer
    1: // @param aJust - indicates where the string is located within the header/footer
    1: // @param aStr - the string to be drawn
    1: // @param aRect - the rect of the page
    1: // @param aHeight - the height of the font
    1: // @param aAscent - the ascent of the font
    1: // @param aWidth - available width for the string
    1: void
    1: nsPageFrame::DrawHeaderFooter(nsIRenderingContext& aRenderingContext,
    1:                               nsHeaderFooterEnum   aHeaderFooter,
    1:                               PRInt32              aJust,
    1:                               const nsString&      aStr,
    1:                               const nsRect&        aRect,
    1:                               nscoord              aAscent,
    1:                               nscoord              aHeight,
    1:                               nscoord              aWidth)
    1: {
    1: 
    1:   nscoord contentWidth = aWidth - (mPD->mEdgePaperMargin.left + mPD->mEdgePaperMargin.right);
    1: 
    1:   if ((aHeaderFooter == eHeader && aHeight < mPD->mReflowMargin.top) ||
    1:       (aHeaderFooter == eFooter && aHeight < mPD->mReflowMargin.bottom)) {
    1:     nsAutoString str;
    1:     ProcessSpecialCodes(aStr, str);
    1: 
    1:     PRInt32 indx;
    1:     PRInt32 textWidth = 0;
    1:     const PRUnichar* text = str.get();
    1: 
    1:     PRInt32 len = (PRInt32)str.Length();
    1:     if (len == 0) {
    1:       return; // bail is empty string
    1:     }
    1:     // find how much text fits, the "position" is the size of the available area
    1:     if (nsLayoutUtils::BinarySearchForPosition(&aRenderingContext, text, 0, 0, 0, len,
    1:                                 PRInt32(contentWidth), indx, textWidth)) {
    1:       if (indx < len-1 ) {
    1:         // we can't fit in all the text
    1:         if (indx > 3) {
    1:           // But we can fit in at least 4 chars.  Show all but 3 of them, then
    1:           // an ellipsis.
    1:           // XXXbz for non-plane0 text, this may be cutting things in the
    1:           // middle of a codepoint!  Also, we have no guarantees that the three
    1:           // dots will fit in the space the three chars we removed took up with
    1:           // these font metrics!
    1:           str.Truncate(indx-3);
    1:           str.AppendLiteral("...");
    1:         } else {
    1:           // We can only fit 3 or fewer chars.  Just show nothing
    1:           str.Truncate();
    1:         }
    1:       }
    1:     } else { 
    1:       return; // bail if couldn't find the correct length
    1:     }
    1:     
15358:     if (HasRTLChars(str)) {
15376:       PresContext()->SetBidiEnabled();
15358:     }
12922: 
    1:     // cacl the x and y positions of the text
    1:     nscoord x = GetXPosition(aRenderingContext, aRect, aJust, str);
    1:     nscoord y;
    1:     if (aHeaderFooter == eHeader) {
    1:       y = aRect.y + mPD->mExtraMargin.top + mPD->mEdgePaperMargin.top;
    1:     } else {
    1:       y = aRect.YMost() - aHeight - mPD->mExtraMargin.bottom - mPD->mEdgePaperMargin.bottom;
    1:     }
    1: 
    1:     // set up new clip and draw the text
    1:     aRenderingContext.PushState();
    1:     aRenderingContext.SetColor(NS_RGB(0,0,0));
    1:     aRenderingContext.SetClipRect(aRect, nsClipCombine_kReplace);
    1:     nsLayoutUtils::DrawString(this, &aRenderingContext, str.get(), str.Length(), nsPoint(x, y + aAscent));
    1:     aRenderingContext.PopState();
    1:   }
    1: }
    1: 
    1: static void PaintPrintPreviewBackground(nsIFrame* aFrame, nsIRenderingContext* aCtx,
    1:                                         const nsRect& aDirtyRect, nsPoint aPt)
    1: {
 3233:   static_cast<nsPageFrame*>(aFrame)->PaintPrintPreviewBackground(*aCtx, aPt);
    1: }
    1: 
    1: static void PaintPageContent(nsIFrame* aFrame, nsIRenderingContext* aCtx,
    1:                              const nsRect& aDirtyRect, nsPoint aPt)
    1: {
 3233:   static_cast<nsPageFrame*>(aFrame)->PaintPageContent(*aCtx, aDirtyRect, aPt);
    1: }
    1: 
    1: static void PaintHeaderFooter(nsIFrame* aFrame, nsIRenderingContext* aCtx,
    1:                               const nsRect& aDirtyRect, nsPoint aPt)
    1: {
 3233:   static_cast<nsPageFrame*>(aFrame)->PaintHeaderFooter(*aCtx, aPt);
    1: }
    1: 
    1: //------------------------------------------------------------------------------
    1: NS_IMETHODIMP
    1: nsPageFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                               const nsRect&           aDirtyRect,
    1:                               const nsDisplayListSet& aLists)
    1: {
    1:   nsDisplayListCollection set;
    1:   nsresult rv;
    1: 
  238:   if (PresContext()->IsScreen()) {
    1:     rv = set.BorderBackground()->AppendNewToTop(new (aBuilder)
    1:         nsDisplayGeneric(this, ::PaintPrintPreviewBackground, "PrintPreviewBackground"));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   rv = set.BorderBackground()->AppendNewToTop(new (aBuilder)
    1:         nsDisplayGeneric(this, ::PaintPageContent, "PageContent"));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
  238:   if (PresContext()->IsRootPaginatedDocument()) {
    1:     rv = set.Content()->AppendNewToTop(new (aBuilder)
    1:         nsDisplayGeneric(this, ::PaintHeaderFooter, "HeaderFooter"));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   set.MoveTo(aLists);
    1:   return NS_OK;
    1: }
    1: 
    1: //------------------------------------------------------------------------------
    1: void
    1: nsPageFrame::SetPageNumInfo(PRInt32 aPageNumber, PRInt32 aTotalPages) 
    1: { 
    1:   mPageNum     = aPageNumber; 
    1:   mTotNumPages = aTotalPages;
    1: }
    1: 
    1: 
    1: void
    1: nsPageFrame::PaintPrintPreviewBackground(nsIRenderingContext& aRenderingContext,
    1:                                          nsPoint aPt)
    1: {
    1:   // fill page with White
    1:   aRenderingContext.SetColor(NS_RGB(255,255,255));
    1:   // REVIEW: this used to have rect's width and height be the
    1:   // mClipRect if specialClipIsSet ... but that seems completely bogus
    1:   // and inconsistent with the painting of the shadow below
    1:   nsRect rect(aPt, GetSize());
    1:   rect.width  -= mPD->mShadowSize.width;
    1:   rect.height -= mPD->mShadowSize.height;
    1:   aRenderingContext.FillRect(rect);
    1:   // draw line around outside of page
    1:   aRenderingContext.SetColor(NS_RGB(0,0,0));
    1:   aRenderingContext.DrawRect(rect);
    1: 
    1:   if (mPD->mShadowSize.width > 0 && mPD->mShadowSize.height > 0) {
    1:     aRenderingContext.SetColor(NS_RGB(51,51,51));
    1:     nsRect r(aPt.x,aPt.y, mRect.width, mRect.height);
    1:     nsRect shadowRect;
    1:     shadowRect.x = r.x + r.width - mPD->mShadowSize.width;
    1:     shadowRect.y = r.y + mPD->mShadowSize.height;
    1:     shadowRect.width  = mPD->mShadowSize.width;
    1:     shadowRect.height = r.height - mPD->mShadowSize.height;
    1:     aRenderingContext.FillRect(shadowRect);
    1: 
    1:     shadowRect.x = r.x + mPD->mShadowSize.width;
    1:     shadowRect.y = r.y + r.height - mPD->mShadowSize.height;
    1:     shadowRect.width  = r.width - mPD->mShadowSize.width;
    1:     shadowRect.height = mPD->mShadowSize.height;
    1:     aRenderingContext.FillRect(shadowRect);
    1:   }
    1: }
    1: 
    1: void
    1: nsPageFrame::PaintHeaderFooter(nsIRenderingContext& aRenderingContext,
    1:                                nsPoint aPt)
    1: {
  238:   nsPresContext* pc = PresContext();
    1: 
    1:   if (!mPD->mPrintSettings) {
    1:     if (pc->Type() == nsPresContext::eContext_PrintPreview || pc->IsDynamic())
    1:       mPD->mPrintSettings = pc->GetPrintSettings();
    1:     if (!mPD->mPrintSettings)
    1:       return;
    1:   }
    1: 
    1:   nsRect rect(aPt.x, aPt.y, mRect.width - mPD->mShadowSize.width,
    1:               mRect.height - mPD->mShadowSize.height);
    1: 
    1:   aRenderingContext.SetColor(NS_RGB(0,0,0));
    1: 
    1:   // Get the FontMetrics to determine width.height of strings
    1:   nsCOMPtr<nsIFontMetrics> fontMet;
    1:   pc->DeviceContext()->GetMetricsFor(*mPD->mHeadFootFont, nsnull,
22335:                                      pc->GetUserFontSet(),
    1:                                      *getter_AddRefs(fontMet));
22335: 
22335:   aRenderingContext.SetFont(fontMet);
22335: 
    1:   nscoord ascent = 0;
    1:   nscoord visibleHeight = 0;
    1:   if (fontMet) {
    1:     fontMet->GetHeight(visibleHeight);
    1:     fontMet->GetMaxAscent(ascent);
    1:   }
    1: 
    1:   // print document headers and footers
    1:   nsXPIDLString headerLeft, headerCenter, headerRight;
    1:   mPD->mPrintSettings->GetHeaderStrLeft(getter_Copies(headerLeft));
    1:   mPD->mPrintSettings->GetHeaderStrCenter(getter_Copies(headerCenter));
    1:   mPD->mPrintSettings->GetHeaderStrRight(getter_Copies(headerRight));
    1:   DrawHeaderFooter(aRenderingContext, eHeader,
    1:                    headerLeft, headerCenter, headerRight,
    1:                    rect, ascent, visibleHeight);
    1: 
    1:   nsXPIDLString footerLeft, footerCenter, footerRight;
    1:   mPD->mPrintSettings->GetFooterStrLeft(getter_Copies(footerLeft));
    1:   mPD->mPrintSettings->GetFooterStrCenter(getter_Copies(footerCenter));
    1:   mPD->mPrintSettings->GetFooterStrRight(getter_Copies(footerRight));
    1:   DrawHeaderFooter(aRenderingContext, eFooter,
    1:                    footerLeft, footerCenter, footerRight,
    1:                    rect, ascent, visibleHeight);
    1: }
    1: 
    1: //------------------------------------------------------------------------------
    1: void
    1: nsPageFrame::PaintPageContent(nsIRenderingContext& aRenderingContext,
    1:                               const nsRect&        aDirtyRect,
    1:                               nsPoint              aPt) {
    1:   nsIFrame* pageContentFrame  = mFrames.FirstChild();
    1:   nsRect rect = aDirtyRect;
  238:   float scale = PresContext()->GetPageScale();
    1:   aRenderingContext.PushState();
14043:   nsPoint framePos = aPt + pageContentFrame->GetOffsetTo(this);
14043:   aRenderingContext.Translate(framePos.x, framePos.y);
    1:   // aPt translates to coords relative to this, then margins translate to
    1:   // pageContentFrame's coords
19835:   rect -= framePos;
    1:   aRenderingContext.Scale(scale, scale);
19835:   rect.ScaleRoundOut(1.0f / scale);
14043:   // Make sure we don't draw where we aren't supposed to draw, especially
14043:   // when printing selection
14043:   nsRect clipRect(nsPoint(0, 0), pageContentFrame->GetSize());
14832:   // Note: this computation matches how we compute maxSize.height
14832:   // in nsPageFrame::Reflow
14832:   nscoord expectedPageContentHeight = 
14832:     NSToCoordCeil((GetSize().height - mPD->mReflowMargin.TopBottom()) / scale);
14832:   if (clipRect.height > expectedPageContentHeight) {
14832:     // We're doing print-selection, with one long page-content frame.
14832:     // Clip to the appropriate page-content slice for the current page.
14832:     NS_ASSERTION(mPageNum > 0, "page num should be positive");
15591:     // Note: The pageContentFrame's y-position has been set such that a zero
15591:     // y-value matches the top edge of the current page.  So, to clip to the
15591:     // current page's content (in coordinates *relative* to the page content
15591:     // frame), we just negate its y-position and add the top margin.
15591:     clipRect.y = NSToCoordCeil((-pageContentFrame->GetRect().y + 
15591:                                 mPD->mReflowMargin.top) / scale);
14832:     clipRect.height = expectedPageContentHeight;
14832:     NS_ASSERTION(clipRect.y < pageContentFrame->GetSize().height,
14832:                  "Should be clipping to region inside the page content bounds");
14832:   }
14043:   aRenderingContext.SetClipRect(clipRect, nsClipCombine_kIntersect);
    1: 
    1:   nsRect backgroundRect = nsRect(nsPoint(0, 0), pageContentFrame->GetSize());
  238:   nsCSSRendering::PaintBackground(PresContext(), aRenderingContext, this,
19614:                                   rect, backgroundRect, PR_TRUE);
    1: 
    1:   nsLayoutUtils::PaintFrame(&aRenderingContext, pageContentFrame,
    1:                             nsRegion(rect), NS_RGBA(0,0,0,0));
    1: 
    1:   aRenderingContext.PopState();
    1: }
    1: 
    1: void
    1: nsPageFrame::SetSharedPageData(nsSharedPageData* aPD) 
    1: { 
    1:   mPD = aPD;
    1:   // Set the shared data into the page frame before reflow
 3233:   nsPageContentFrame * pcf = static_cast<nsPageContentFrame*>(mFrames.FirstChild());
    1:   if (pcf) {
    1:     pcf->SetSharedPageData(mPD);
    1:   }
    1: 
    1: }
    1: 
    1: nsIFrame*
    1: NS_NewPageBreakFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   NS_PRECONDITION(aPresShell, "null PresShell");
    1:   //check that we are only creating page break frames when printing
    1:   NS_ASSERTION(aPresShell->GetPresContext()->IsPaginated(), "created a page break frame while not printing");
    1: 
    1:   return new (aPresShell) nsPageBreakFrame(aContext);
    1: }
    1: 
    1: nsPageBreakFrame::nsPageBreakFrame(nsStyleContext* aContext) :
    1:   nsLeafFrame(aContext), mHaveReflowed(PR_FALSE)
    1: {
    1: }
    1: 
    1: nsPageBreakFrame::~nsPageBreakFrame()
    1: {
    1: }
    1: 
    1: nscoord
    1: nsPageBreakFrame::GetIntrinsicWidth()
    1: {
    1:   return nsPresContext::CSSPixelsToAppUnits(1);
    1: }
    1: 
14246: nscoord
14246: nsPageBreakFrame::GetIntrinsicHeight()
14246: {
14246:   return 0;
14246: }
14246: 
    1: nsresult 
    1: nsPageBreakFrame::Reflow(nsPresContext*          aPresContext,
    1:                          nsHTMLReflowMetrics&     aDesiredSize,
    1:                          const nsHTMLReflowState& aReflowState,
    1:                          nsReflowStatus&          aStatus)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsPageBreakFrame");
    1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
    1: 
    1:   // Override reflow, since we don't want to deal with what our
    1:   // computed values are.
    1:   aDesiredSize.width = GetIntrinsicWidth();
 7666:   aDesiredSize.height = (aReflowState.availableHeight == NS_UNCONSTRAINEDSIZE ?
 7666:                          0 : aReflowState.availableHeight);
    1:   // round the height down to the nearest pixel
    1:   aDesiredSize.height -=
    1:     aDesiredSize.height % nsPresContext::CSSPixelsToAppUnits(1);
    1: 
    1:   // Note: not using NS_FRAME_FIRST_REFLOW here, since it's not clear whether
    1:   // DidReflow will always get called before the next Reflow() call.
    1:   mHaveReflowed = PR_TRUE;
    1:   aStatus = NS_FRAME_COMPLETE; 
    1:   return NS_OK;
    1: }
    1: 
    1: nsIAtom*
    1: nsPageBreakFrame::GetType() const
    1: {
    1:   return nsGkAtoms::pageBreakFrame; 
    1: }
    1: 
23161: #ifdef DEBUG
23161: NS_IMETHODIMP
23161: nsPageBreakFrame::GetFrameName(nsAString& aResult) const
23161: {
23161:   return MakeFrameName(NS_LITERAL_STRING("PageBreak"), aResult);
23161: }
23161: #endif
