    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1999
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Boris Zbarsky <bzbarsky@mit.edu>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* rules in a CSS stylesheet other than style rules (e.g., @import rules) */
    1: 
    1: #include "nsCSSRules.h"
16545: #include "nsCSSValue.h"
63734: #include "mozilla/css/ImportRule.h"
63731: #include "mozilla/css/NameSpaceRule.h"
    1: 
    1: #include "nsString.h"
    1: #include "nsIAtom.h"
    1: #include "nsIURL.h"
    1: 
16545: #include "nsCSSProps.h"
42163: #include "nsCSSStyleSheet.h"
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsIDOMCSSStyleSheet.h"
    1: #include "nsIDOMCSSMediaRule.h"
    1: #include "nsIDOMCSSMozDocumentRule.h"
    1: #include "nsIDOMCSSCharsetRule.h"
16545: #include "nsIDOMCSSStyleDeclaration.h"
    1: #include "nsIMediaList.h"
20752: #include "nsICSSRuleList.h"
    1: #include "nsIDocument.h"
    1: #include "nsPresContext.h"
    1: 
    1: #include "nsContentUtils.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsDOMError.h"
16545: #include "nsStyleUtil.h"
47937: #include "mozilla/css/Declaration.h"
31706: #include "nsPrintfCString.h"
    1: 
63730: namespace css = mozilla::css;
63730: 
    1: #define IMPL_STYLE_RULE_INHERIT(_class, super) \
47887: /* virtual */ already_AddRefed<nsIStyleSheet> _class::GetStyleSheet() const { return super::GetStyleSheet(); }  \
47887: /* virtual */ void _class::SetStyleSheet(nsCSSStyleSheet* aSheet) { super::SetStyleSheet(aSheet); }  \
47887: /* virtual */ void _class::SetParentRule(nsICSSGroupRule* aRule) { super::SetParentRule(aRule); }  \
20752: nsIDOMCSSRule* _class::GetDOMRuleWeak(nsresult *aResult) { *aResult = NS_OK; return this; }  \
43120: /* virtual */ void _class::MapRuleInfoInto(nsRuleData* aRuleData) { }
    1: 
    1: #define IMPL_STYLE_RULE_INHERIT2(_class, super) \
47887: /* virtual */ already_AddRefed<nsIStyleSheet> _class::GetStyleSheet() const { return super::GetStyleSheet(); }  \
47887: /* virtual */ void  _class::SetParentRule(nsICSSGroupRule* aRule) { super::SetParentRule(aRule); }  \
43120: /* virtual */ void _class::MapRuleInfoInto(nsRuleData* aRuleData) { }
    1: 
    1: // -------------------------------
    1: // Style Rule List for group rules
    1: //
20752: class CSSGroupRuleRuleListImpl : public nsICSSRuleList
    1: {
    1: public:
    1:   CSSGroupRuleRuleListImpl(nsICSSGroupRule *aGroupRule);
    1: 
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   NS_DECL_NSIDOMCSSRULELIST
    1: 
20752:   virtual nsIDOMCSSRule* GetItemAt(PRUint32 aIndex, nsresult* aResult);
20752: 
    1:   void DropReference() { mGroupRule = nsnull; }
    1: 
    1: protected:
    1:   virtual ~CSSGroupRuleRuleListImpl(void);
    1: 
    1: private:
    1:   nsICSSGroupRule* mGroupRule;
    1: };
    1: 
    1: CSSGroupRuleRuleListImpl::CSSGroupRuleRuleListImpl(nsICSSGroupRule *aGroupRule)
    1: {
    1:   // Not reference counted to avoid circular references.
    1:   // The rule will tell us when its going away.
    1:   mGroupRule = aGroupRule;
    1: }
    1: 
    1: CSSGroupRuleRuleListImpl::~CSSGroupRuleRuleListImpl()
    1: {
    1: }
    1: 
40490: DOMCI_DATA(CSSGroupRuleRuleList, CSSGroupRuleRuleListImpl)
40490: 
    1: // QueryInterface implementation for CSSGroupRuleRuleList
    1: NS_INTERFACE_MAP_BEGIN(CSSGroupRuleRuleListImpl)
20752:   NS_INTERFACE_MAP_ENTRY(nsICSSRuleList)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSRuleList)
    1:   NS_INTERFACE_MAP_ENTRY(nsISupports)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CSSGroupRuleRuleList)
    1: NS_INTERFACE_MAP_END
    1: 
    1: 
    1: NS_IMPL_ADDREF(CSSGroupRuleRuleListImpl)
    1: NS_IMPL_RELEASE(CSSGroupRuleRuleListImpl)
    1: 
    1: NS_IMETHODIMP    
    1: CSSGroupRuleRuleListImpl::GetLength(PRUint32* aLength)
    1: {
    1:   if (mGroupRule) {
    1:     PRInt32 count;
    1:     mGroupRule->StyleRuleCount(count);
    1:     *aLength = (PRUint32)count;
    1:   } else {
    1:     *aLength = 0;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
20752: nsIDOMCSSRule*    
20752: CSSGroupRuleRuleListImpl::GetItemAt(PRUint32 aIndex, nsresult* aResult)
    1: {
    1:   nsresult result = NS_OK;
    1: 
    1:   if (mGroupRule) {
    1:     nsCOMPtr<nsICSSRule> rule;
    1: 
    1:     result = mGroupRule->GetStyleRuleAt(aIndex, *getter_AddRefs(rule));
    1:     if (rule) {
20752:       return rule->GetDOMRuleWeak(aResult);
20752:     }
20752:     if (result == NS_ERROR_ILLEGAL_VALUE) {
    1:       result = NS_OK; // per spec: "Return Value ... null if ... not a valid index."
    1:     }
    1:   }
    1: 
20752:   *aResult = result;
20752: 
20752:   return nsnull;
20752: }
20752: 
20752: NS_IMETHODIMP    
20752: CSSGroupRuleRuleListImpl::Item(PRUint32 aIndex, nsIDOMCSSRule** aReturn)
20752: {
20752:   nsresult rv;
20752:   nsIDOMCSSRule* rule = GetItemAt(aIndex, &rv);
20752:   if (!rule) {
20752:     *aReturn = nsnull;
20752:     return rv;
20752:   }
20752: 
47889:   NS_ADDREF(*aReturn = rule);
47889:   return NS_OK;
    1: }
    1: 
    1: // -------------------------------------------
    1: // CharsetRule
    1: //
54329: class NS_FINAL_CLASS CSSCharsetRuleImpl : public nsCSSRule,
    1:                                           public nsICSSRule,
    1:                                           public nsIDOMCSSCharsetRule
    1: {
    1: public:
    1:   CSSCharsetRuleImpl(const nsAString& aEncoding);
    1:   CSSCharsetRuleImpl(const CSSCharsetRuleImpl& aCopy);
54328: private:
54328:   ~CSSCharsetRuleImpl() {}
54328: public:
54328:   NS_DECL_ISUPPORTS
    1: 
    1:   DECL_STYLE_RULE_INHERIT
    1: 
    1:   // nsIStyleRule methods
    1: #ifdef DEBUG
43120:   virtual void List(FILE* out = stdout, PRInt32 aIndent = 0) const;
    1: #endif
    1: 
    1:   // nsICSSRule methods
47887:   virtual PRInt32 GetType() const;
50636:   virtual already_AddRefed<nsICSSRule> Clone() const;
    1: 
    1:   // nsIDOMCSSRule interface
    1:   NS_DECL_NSIDOMCSSRULE
    1:   
    1:   // nsIDOMCSSCharsetRule methods
    1:   NS_IMETHOD GetEncoding(nsAString& aEncoding);
    1:   NS_IMETHOD SetEncoding(const nsAString& aEncoding);
    1: 
    1: protected:
    1:   nsString  mEncoding;
    1: };
    1: 
    1: CSSCharsetRuleImpl::CSSCharsetRuleImpl(const nsAString& aEncoding)
    1:   : nsCSSRule(),
    1:     mEncoding(aEncoding)
    1: {
    1: }
    1: 
    1: CSSCharsetRuleImpl::CSSCharsetRuleImpl(const CSSCharsetRuleImpl& aCopy)
    1:   : nsCSSRule(aCopy),
    1:     mEncoding(aCopy.mEncoding)
    1: {
    1: }
    1: 
54328: NS_IMPL_ADDREF(CSSCharsetRuleImpl)
54328: NS_IMPL_RELEASE(CSSCharsetRuleImpl)
    1: 
40490: DOMCI_DATA(CSSCharsetRule, CSSCharsetRuleImpl)
40490: 
    1: // QueryInterface implementation for CSSCharsetRuleImpl
    1: NS_INTERFACE_MAP_BEGIN(CSSCharsetRuleImpl)
    1:   NS_INTERFACE_MAP_ENTRY(nsICSSRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIStyleRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSCharsetRule)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsICSSRule)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CSSCharsetRule)
    1: NS_INTERFACE_MAP_END
    1: 
    1: IMPL_STYLE_RULE_INHERIT(CSSCharsetRuleImpl, nsCSSRule)
    1: 
    1: #ifdef DEBUG
43120: /* virtual */ void
    1: CSSCharsetRuleImpl::List(FILE* out, PRInt32 aIndent) const
    1: {
    1:   // Indent
    1:   for (PRInt32 indent = aIndent; --indent >= 0; ) fputs("  ", out);
    1: 
    1:   fputs("@charset \"", out);
    1:   fputs(NS_LossyConvertUTF16toASCII(mEncoding).get(), out);
    1:   fputs("\"\n", out);
    1: }
    1: #endif
    1: 
47887: /* virtual */ PRInt32
47887: CSSCharsetRuleImpl::GetType() const
    1: {
47887:   return nsICSSRule::CHARSET_RULE;
    1: }
    1: 
50636: /* virtual */ already_AddRefed<nsICSSRule>
50636: CSSCharsetRuleImpl::Clone() const
    1: {
50636:   nsCOMPtr<nsICSSRule> clone = new CSSCharsetRuleImpl(*this);
50636:   return clone.forget();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: CSSCharsetRuleImpl::GetEncoding(nsAString& aEncoding)
    1: {
    1:   aEncoding = mEncoding;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: CSSCharsetRuleImpl::SetEncoding(const nsAString& aEncoding)
    1: {
    1:   mEncoding = aEncoding;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: NS_NewCSSCharsetRule(nsICSSRule** aInstancePtrResult, const nsAString& aEncoding)
    1: {
    1:   if (! aInstancePtrResult) {
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1: 
    1:   CSSCharsetRuleImpl* it = new CSSCharsetRuleImpl(aEncoding);
    1: 
    1:   if (!it) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
47889:   NS_ADDREF(*aInstancePtrResult = it);
47889:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: CSSCharsetRuleImpl::GetType(PRUint16* aType)
    1: {
    1:   *aType = nsIDOMCSSRule::CHARSET_RULE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: CSSCharsetRuleImpl::GetCssText(nsAString& aCssText)
    1: {
    1:   aCssText.AssignLiteral("@charset \"");
    1:   aCssText.Append(mEncoding);
    1:   aCssText.AppendLiteral("\";");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: CSSCharsetRuleImpl::SetCssText(const nsAString& aCssText)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: CSSCharsetRuleImpl::GetParentStyleSheet(nsIDOMCSSStyleSheet** aSheet)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aSheet);
    1: 
42968:   NS_IF_ADDREF(*aSheet = mSheet);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: CSSCharsetRuleImpl::GetParentRule(nsIDOMCSSRule** aParentRule)
    1: {
    1:   if (mParentRule) {
    1:     return mParentRule->GetDOMRule(aParentRule);
    1:   }
    1:   *aParentRule = nsnull;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: 
    1: // -------------------------------------------
63733: // ImportRule
    1: //
63733: 
63733: namespace mozilla {
63733: namespace css {
63733: 
63733: ImportRule::ImportRule(nsMediaList* aMedia)
    1:   : nsCSSRule()
    1:   , mURLSpec()
    1:   , mMedia(aMedia)
    1: {
    1:   // XXXbz This is really silly.... the mMedia here will be replaced
    1:   // with itself if we manage to load a sheet.  Which should really
    1:   // never fail nowadays, in sane cases.
    1: }
    1: 
63733: ImportRule::ImportRule(const ImportRule& aCopy)
    1:   : nsCSSRule(aCopy),
    1:     mURLSpec(aCopy.mURLSpec)
    1: {
64400:   // Whether or not an @import rule has a null sheet is a permanent
64400:   // property of that @import rule, since it is null only if the target
64400:   // sheet failed security checks.
    1:   if (aCopy.mChildSheet) {
64400:     nsRefPtr<nsCSSStyleSheet> sheet =
64400:       aCopy.mChildSheet->Clone(nsnull, this, nsnull, nsnull);
    1:     SetSheet(sheet);
    1:     // SetSheet sets mMedia appropriately
    1:   }
64400: }
    1: 
63733: ImportRule::~ImportRule()
    1: {
    1:   if (mChildSheet) {
    1:     mChildSheet->SetOwnerRule(nsnull);
    1:   }
    1: }
    1: 
63733: NS_IMPL_ADDREF(ImportRule)
63733: NS_IMPL_RELEASE(ImportRule)
    1: 
63733: // QueryInterface implementation for ImportRule
63733: NS_INTERFACE_MAP_BEGIN(ImportRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsICSSRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIStyleRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSImportRule)
63734:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsICSSRule)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CSSImportRule)
    1: NS_INTERFACE_MAP_END
    1: 
63733: IMPL_STYLE_RULE_INHERIT(ImportRule, nsCSSRule)
    1: 
    1: #ifdef DEBUG
43120: /* virtual */ void
63733: ImportRule::List(FILE* out, PRInt32 aIndent) const
    1: {
    1:   // Indent
    1:   for (PRInt32 indent = aIndent; --indent >= 0; ) fputs("  ", out);
    1: 
    1:   fputs("@import \"", out);
    1:   fputs(NS_LossyConvertUTF16toASCII(mURLSpec).get(), out);
    1:   fputs("\" ", out);
    1: 
    1:   nsAutoString mediaText;
    1:   mMedia->GetText(mediaText);
    1:   fputs(NS_LossyConvertUTF16toASCII(mediaText).get(), out);
    1:   fputs("\n", out);
    1: }
    1: #endif
    1: 
47887: /* virtual */ PRInt32
63733: ImportRule::GetType() const
    1: {
47887:   return nsICSSRule::IMPORT_RULE;
    1: }
    1: 
50636: /* virtual */ already_AddRefed<nsICSSRule>
63733: ImportRule::Clone() const
    1: {
63733:   nsCOMPtr<nsICSSRule> clone = new ImportRule(*this);
50636:   return clone.forget();
    1: }
    1: 
63735: nsresult
63733: ImportRule::SetMedia(const nsString& aMedia)
    1: {
    1:   if (mMedia) {
    1:     return mMedia->SetText(aMedia);
    1:   } else {
    1:     return NS_OK;
    1:   }
    1: }
    1: 
63735: void
63733: ImportRule::GetMedia(nsString& aMedia) const
    1: {
    1:   if (mMedia) {
63735:     mMedia->GetText(aMedia);
    1:   } else {
    1:     aMedia.Truncate();
    1:   }
    1: }
    1: 
63735: void
63733: ImportRule::SetSheet(nsCSSStyleSheet* aSheet)
    1: {
63735:   NS_PRECONDITION(aSheet, "null arg");
    1: 
    1:   // set the new sheet
    1:   mChildSheet = aSheet;
    1:   aSheet->SetOwnerRule(this);
    1: 
    1:   // set our medialist to be the same as the sheet's medialist
    1:   nsCOMPtr<nsIDOMMediaList> mediaList;
63735:   mChildSheet->GetMedia(getter_AddRefs(mediaList));
63735:   NS_ABORT_IF_FALSE(mediaList, "GetMedia returned null");
 3233:   mMedia = static_cast<nsMediaList*>(mediaList.get());
    1: }
    1: 
    1: NS_IMETHODIMP
63733: ImportRule::GetType(PRUint16* aType)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aType);
    1:   *aType = nsIDOMCSSRule::IMPORT_RULE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
63733: ImportRule::GetCssText(nsAString& aCssText)
    1: {
    1:   aCssText.AssignLiteral("@import url(");
25794:   nsStyleUtil::AppendEscapedCSSString(mURLSpec, aCssText);
    1:   aCssText.Append(NS_LITERAL_STRING(")"));
    1:   if (mMedia) {
    1:     nsAutoString mediaText;
    1:     mMedia->GetText(mediaText);
    1:     if (!mediaText.IsEmpty()) {
    1:       aCssText.AppendLiteral(" ");
    1:       aCssText.Append(mediaText);
    1:     }
    1:   }
    1:   aCssText.AppendLiteral(";");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
63733: ImportRule::SetCssText(const nsAString& aCssText)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
63733: ImportRule::GetParentStyleSheet(nsIDOMCSSStyleSheet** aSheet)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aSheet);
42968: 
42968:   NS_IF_ADDREF(*aSheet = mSheet);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
63733: ImportRule::GetParentRule(nsIDOMCSSRule** aParentRule)
    1: {
    1:   if (mParentRule) {
    1:     return mParentRule->GetDOMRule(aParentRule);
    1:   }
    1:   *aParentRule = nsnull;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
63733: ImportRule::GetHref(nsAString & aHref)
    1: {
    1:   aHref = mURLSpec;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
63733: ImportRule::GetMedia(nsIDOMMediaList * *aMedia)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aMedia);
47889: 
47889:   NS_IF_ADDREF(*aMedia = mMedia);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
63733: ImportRule::GetStyleSheet(nsIDOMCSSStyleSheet * *aStyleSheet)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aStyleSheet);
42969: 
42969:   NS_IF_ADDREF(*aStyleSheet = mChildSheet);
    1:   return NS_OK;
    1: }
    1: 
63733: } // namespace css
63733: } // namespace mozilla
63733: 
63733: // must be outside the namespace
63733: DOMCI_DATA(CSSImportRule, css::ImportRule)
63733: 
63733: nsresult
63734: NS_NewCSSImportRule(css::ImportRule** aInstancePtrResult,
63733:                     const nsString& aURLSpec,
63733:                     nsMediaList* aMedia)
63733: {
63733:   NS_ENSURE_ARG_POINTER(aInstancePtrResult);
63733: 
63733:   css::ImportRule* it = new css::ImportRule(aMedia);
63733: 
63733:   if (!it) {
63733:     return NS_ERROR_OUT_OF_MEMORY;
63733:   }
63733: 
63733:   it->SetURLSpec(aURLSpec);
63733:   NS_ADDREF(*aInstancePtrResult = it);
63733:   return NS_OK;
63733: }
63733: 
    1: nsCSSGroupRule::nsCSSGroupRule()
    1:   : nsCSSRule()
    1:   , mRuleCollection(nsnull)
    1: {
    1: }
    1: 
    1: static PRBool
    1: CloneRuleInto(nsICSSRule* aRule, void* aArray)
    1: {
50636:   nsCOMPtr<nsICSSRule> clone = aRule->Clone();
 3233:   static_cast<nsCOMArray<nsICSSRule>*>(aArray)->AppendObject(clone);
    1:   return PR_TRUE;
    1: }
    1: 
    1: static PRBool
    1: SetParentRuleReference(nsICSSRule* aRule, void* aParentRule)
    1: {
 3233:   nsCSSGroupRule* parentRule = static_cast<nsCSSGroupRule*>(aParentRule);
    1:   aRule->SetParentRule(parentRule);
    1:   return PR_TRUE;
    1: }
    1: 
    1: nsCSSGroupRule::nsCSSGroupRule(const nsCSSGroupRule& aCopy)
    1:   : nsCSSRule(aCopy)
    1:   , mRuleCollection(nsnull) // lazily constructed
    1: {
 3233:   const_cast<nsCSSGroupRule&>(aCopy).mRules.EnumerateForwards(CloneRuleInto, &mRules);
    1:   mRules.EnumerateForwards(SetParentRuleReference, this);
    1: }
    1: 
    1: nsCSSGroupRule::~nsCSSGroupRule()
    1: {
    1:   mRules.EnumerateForwards(SetParentRuleReference, nsnull);
    1:   if (mRuleCollection) {
    1:     mRuleCollection->DropReference();
    1:     NS_RELEASE(mRuleCollection);
    1:   }
    1: }
    1: 
54328: NS_IMPL_ADDREF(nsCSSGroupRule)
54328: NS_IMPL_RELEASE(nsCSSGroupRule)
54328: 
    1: IMPL_STYLE_RULE_INHERIT2(nsCSSGroupRule, nsCSSRule)
    1: 
    1: static PRBool
    1: SetStyleSheetReference(nsICSSRule* aRule, void* aSheet)
    1: {
42163:   nsCSSStyleSheet* sheet = (nsCSSStyleSheet*)aSheet;
    1:   aRule->SetStyleSheet(sheet);
    1:   return PR_TRUE;
    1: }
    1: 
47887: /* virtual */ void
42163: nsCSSGroupRule::SetStyleSheet(nsCSSStyleSheet* aSheet)
    1: {
    1:   mRules.EnumerateForwards(SetStyleSheetReference, aSheet);
47887:   nsCSSRule::SetStyleSheet(aSheet);
    1: }
    1: 
    1: #ifdef DEBUG
43120: /* virtual */ void
    1: nsCSSGroupRule::List(FILE* out, PRInt32 aIndent) const
    1: {
    1:   fputs(" {\n", out);
    1: 
    1:   for (PRInt32 index = 0, count = mRules.Count(); index < count; ++index) {
    1:     mRules.ObjectAt(index)->List(out, aIndent + 1);
    1:   }
    1:   fputs("}\n", out);
    1: }
    1: #endif
    1: 
    1: NS_IMETHODIMP
    1: nsCSSGroupRule::AppendStyleRule(nsICSSRule* aRule)
    1: {
    1:   mRules.AppendObject(aRule);
    1:   aRule->SetStyleSheet(mSheet);
    1:   aRule->SetParentRule(this);
    1:   if (mSheet) {
    1:     // XXXldb Shouldn't we be using |WillDirty| and |DidDirty| (and
    1:     // shouldn't |SetModified| be removed?
    1:     mSheet->SetModified(PR_TRUE);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSGroupRule::StyleRuleCount(PRInt32& aCount) const
    1: {
    1:   aCount = mRules.Count();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSGroupRule::GetStyleRuleAt(PRInt32 aIndex, nsICSSRule*& aRule) const
    1: {
    1:   if (aIndex < 0 || aIndex >= mRules.Count()) {
    1:     aRule = nsnull;
    1:     return NS_ERROR_ILLEGAL_VALUE;
    1:   }
    1: 
    1:   NS_ADDREF(aRule = mRules.ObjectAt(aIndex));
    1:   return NS_OK;
    1: }
    1: 
 9093: NS_IMETHODIMP_(PRBool)
    1: nsCSSGroupRule::EnumerateRulesForwards(RuleEnumFunc aFunc, void * aData) const
    1: {
 9093:   return
 3233:     const_cast<nsCSSGroupRule*>(this)->mRules.EnumerateForwards(aFunc, aData);
    1: }
    1: 
    1: /*
    1:  * The next two methods (DeleteStyleRuleAt and InsertStyleRulesAt)
    1:  * should never be called unless you have first called WillDirty() on
    1:  * the parents tylesheet.  After they are called, DidDirty() needs to
    1:  * be called on the sheet
    1:  */
    1: NS_IMETHODIMP
    1: nsCSSGroupRule::DeleteStyleRuleAt(PRUint32 aIndex)
    1: {
    1:   nsICSSRule* rule = mRules.SafeObjectAt(aIndex);
    1:   if (rule) {
    1:     rule->SetStyleSheet(nsnull);
    1:     rule->SetParentRule(nsnull);
    1:   }
    1:   return mRules.RemoveObjectAt(aIndex) ? NS_OK : NS_ERROR_ILLEGAL_VALUE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSGroupRule::InsertStyleRulesAt(PRUint32 aIndex,
    1:                                    nsCOMArray<nsICSSRule>& aRules)
    1: {
    1:   aRules.EnumerateForwards(SetStyleSheetReference, mSheet);
    1:   aRules.EnumerateForwards(SetParentRuleReference, this);
    1:   if (! mRules.InsertObjectsAt(aRules, aIndex)) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSGroupRule::ReplaceStyleRule(nsICSSRule* aOld, nsICSSRule* aNew)
    1: {
    1:   PRInt32 index = mRules.IndexOf(aOld);
    1:   NS_ENSURE_TRUE(index != -1, NS_ERROR_UNEXPECTED);
    1:   mRules.ReplaceObjectAt(aNew, index);
    1:   aNew->SetStyleSheet(mSheet);
    1:   aNew->SetParentRule(this);
    1:   aOld->SetStyleSheet(nsnull);
    1:   aOld->SetParentRule(nsnull);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSGroupRule::AppendRulesToCssText(nsAString& aCssText)
    1: {
    1:   aCssText.AppendLiteral(" {\n");
    1: 
    1:   // get all the rules
    1:   for (PRInt32 index = 0, count = mRules.Count(); index < count; ++index) {
    1:     nsICSSRule* rule = mRules.ObjectAt(index);
    1:     nsCOMPtr<nsIDOMCSSRule> domRule;
    1:     rule->GetDOMRule(getter_AddRefs(domRule));
    1:     if (domRule) {
    1:       nsAutoString cssText;
    1:       domRule->GetCssText(cssText);
    1:       aCssText.Append(NS_LITERAL_STRING("  ") +
    1:                       cssText +
    1:                       NS_LITERAL_STRING("\n"));
    1:     }
    1:   }
    1: 
    1:   aCssText.AppendLiteral("}");
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSGroupRule::GetParentStyleSheet(nsIDOMCSSStyleSheet** aSheet)
    1: {
42968:   NS_IF_ADDREF(*aSheet = mSheet);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSGroupRule::GetParentRule(nsIDOMCSSRule** aParentRule)
    1: {
    1:   if (mParentRule) {
    1:     return mParentRule->GetDOMRule(aParentRule);
    1:   }
    1:   *aParentRule = nsnull;
    1:   return NS_OK;
    1: }
    1: 
    1: // nsIDOMCSSMediaRule or nsIDOMCSSMozDocumentRule methods
    1: nsresult
    1: nsCSSGroupRule::GetCssRules(nsIDOMCSSRuleList* *aRuleList)
    1: {
    1:   if (!mRuleCollection) {
    1:     mRuleCollection = new CSSGroupRuleRuleListImpl(this);
    1:     if (!mRuleCollection) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:     NS_ADDREF(mRuleCollection);
    1:   }
    1: 
47889:   NS_ADDREF(*aRuleList = mRuleCollection);
47889:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsCSSGroupRule::InsertRule(const nsAString & aRule, PRUint32 aIndex, PRUint32* _retval)
    1: {
    1:   NS_ENSURE_TRUE(mSheet, NS_ERROR_FAILURE);
    1:   
    1:   if (aIndex > PRUint32(mRules.Count()))
    1:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
    1: 
    1:   NS_ASSERTION(PRUint32(mRules.Count()) <= PR_INT32_MAX,
    1:                "Too many style rules!");
    1: 
    1:   return mSheet->InsertRuleIntoGroup(aRule, this, aIndex, _retval);
    1: }
    1: 
    1: nsresult
    1: nsCSSGroupRule::DeleteRule(PRUint32 aIndex)
    1: {
    1:   NS_ENSURE_TRUE(mSheet, NS_ERROR_FAILURE);
    1: 
    1:   if (aIndex >= PRUint32(mRules.Count()))
    1:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
    1: 
    1:   NS_ASSERTION(PRUint32(mRules.Count()) <= PR_INT32_MAX,
    1:                "Too many style rules!");
    1: 
    1:   return mSheet->DeleteRuleFromGroup(this, aIndex);
    1: }
    1: 
    1: // -------------------------------------------
    1: // nsICSSMediaRule
    1: //
    1: nsCSSMediaRule::nsCSSMediaRule()
    1: {
    1: }
    1: 
    1: nsCSSMediaRule::nsCSSMediaRule(const nsCSSMediaRule& aCopy)
    1:   : nsCSSGroupRule(aCopy)
    1: {
    1:   if (aCopy.mMedia) {
    1:     aCopy.mMedia->Clone(getter_AddRefs(mMedia));
    1:     if (mMedia) {
    1:       // XXXldb This doesn't really make sense.
    1:       mMedia->SetStyleSheet(aCopy.mSheet);
    1:     }
    1:   }
    1: }
    1: 
    1: nsCSSMediaRule::~nsCSSMediaRule()
    1: {
    1:   if (mMedia) {
    1:     mMedia->SetStyleSheet(nsnull);
    1:   }
    1: }
    1: 
54328: NS_IMPL_ADDREF_INHERITED(nsCSSMediaRule, nsCSSGroupRule)
54328: NS_IMPL_RELEASE_INHERITED(nsCSSMediaRule, nsCSSGroupRule)
    1: 
40490: DOMCI_DATA(CSSMediaRule, nsCSSMediaRule)
40490: 
    1: // QueryInterface implementation for nsCSSMediaRule
    1: NS_INTERFACE_MAP_BEGIN(nsCSSMediaRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsICSSGroupRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsICSSRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIStyleRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSMediaRule)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsCSSGroupRule)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CSSMediaRule)
    1: NS_INTERFACE_MAP_END
    1: 
47887: /* virtual */ void
42163: nsCSSMediaRule::SetStyleSheet(nsCSSStyleSheet* aSheet)
    1: {
    1:   if (mMedia) {
    1:     // Set to null so it knows it's leaving one sheet and joining another.
    1:     mMedia->SetStyleSheet(nsnull);
    1:     mMedia->SetStyleSheet(aSheet);
    1:   }
    1: 
47887:   nsCSSGroupRule::SetStyleSheet(aSheet);
    1: }
    1: 
    1: #ifdef DEBUG
43120: /* virtual */ void
    1: nsCSSMediaRule::List(FILE* out, PRInt32 aIndent) const
    1: {
    1:   for (PRInt32 indent = aIndent; --indent >= 0; ) fputs("  ", out);
    1: 
    1:   nsAutoString  buffer;
    1: 
    1:   fputs("@media ", out);
    1: 
    1:   if (mMedia) {
    1:     nsAutoString mediaText;
    1:     mMedia->GetText(mediaText);
    1:     fputs(NS_LossyConvertUTF16toASCII(mediaText).get(), out);
    1:   }
    1: 
43120:   nsCSSGroupRule::List(out, aIndent);
    1: }
    1: #endif
    1: 
47887: /* virtual */ PRInt32
47887: nsCSSMediaRule::GetType() const
    1: {
47887:   return nsICSSRule::MEDIA_RULE;
    1: }
    1: 
50636: /* virtual */ already_AddRefed<nsICSSRule>
50636: nsCSSMediaRule::Clone() const
    1: {
50636:   nsCOMPtr<nsICSSRule> clone = new nsCSSMediaRule(*this);
50636:   return clone.forget();
    1: }
    1: 
    1: nsresult
    1: nsCSSMediaRule::SetMedia(nsMediaList* aMedia)
    1: {
    1:   mMedia = aMedia;
    1:   if (aMedia)
    1:     mMedia->SetStyleSheet(mSheet);
    1:   return NS_OK;
    1: }
    1: 
    1: // nsIDOMCSSRule methods
    1: NS_IMETHODIMP
    1: nsCSSMediaRule::GetType(PRUint16* aType)
    1: {
    1:   *aType = nsIDOMCSSRule::MEDIA_RULE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSMediaRule::GetCssText(nsAString& aCssText)
    1: {
    1:   aCssText.AssignLiteral("@media ");
    1:   // get all the media
    1:   if (mMedia) {
    1:     nsAutoString mediaText;
    1:     mMedia->GetText(mediaText);
    1:     aCssText.Append(mediaText);
    1:   }
    1: 
    1:   return nsCSSGroupRule::AppendRulesToCssText(aCssText);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSMediaRule::SetCssText(const nsAString& aCssText)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSMediaRule::GetParentStyleSheet(nsIDOMCSSStyleSheet** aSheet)
    1: {
    1:   return nsCSSGroupRule::GetParentStyleSheet(aSheet);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSMediaRule::GetParentRule(nsIDOMCSSRule** aParentRule)
    1: {
    1:   return nsCSSGroupRule::GetParentRule(aParentRule);
    1: }
    1: 
    1: // nsIDOMCSSMediaRule methods
    1: NS_IMETHODIMP
    1: nsCSSMediaRule::GetMedia(nsIDOMMediaList* *aMedia)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aMedia);
47889:   NS_IF_ADDREF(*aMedia = mMedia);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSMediaRule::GetCssRules(nsIDOMCSSRuleList* *aRuleList)
    1: {
    1:   return nsCSSGroupRule::GetCssRules(aRuleList);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSMediaRule::InsertRule(const nsAString & aRule, PRUint32 aIndex, PRUint32* _retval)
    1: {
    1:   return nsCSSGroupRule::InsertRule(aRule, aIndex, _retval);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSMediaRule::DeleteRule(PRUint32 aIndex)
    1: {
    1:   return nsCSSGroupRule::DeleteRule(aIndex);
    1: }
    1: 
    1: // nsICSSGroupRule interface
    1: NS_IMETHODIMP_(PRBool)
16223: nsCSSMediaRule::UseForPresentation(nsPresContext* aPresContext,
16223:                                    nsMediaQueryResultCacheKey& aKey)
    1: {
    1:   if (mMedia) {
16223:     return mMedia->Matches(aPresContext, aKey);
    1:   }
    1:   return PR_TRUE;
    1: }
    1: 
    1: 
    1: nsCSSDocumentRule::nsCSSDocumentRule(void)
    1: {
    1: }
    1: 
    1: nsCSSDocumentRule::nsCSSDocumentRule(const nsCSSDocumentRule& aCopy)
    1:   : nsCSSGroupRule(aCopy)
    1:   , mURLs(new URL(*aCopy.mURLs))
    1: {
    1: }
    1: 
    1: nsCSSDocumentRule::~nsCSSDocumentRule(void)
    1: {
    1: }
    1: 
54328: NS_IMPL_ADDREF_INHERITED(nsCSSDocumentRule, nsCSSGroupRule)
54328: NS_IMPL_RELEASE_INHERITED(nsCSSDocumentRule, nsCSSGroupRule)
    1: 
40490: DOMCI_DATA(CSSMozDocumentRule, nsCSSDocumentRule)
40490: 
    1: // QueryInterface implementation for nsCSSDocumentRule
    1: NS_INTERFACE_MAP_BEGIN(nsCSSDocumentRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsICSSGroupRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsICSSRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIStyleRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSMozDocumentRule)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsCSSGroupRule)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CSSMozDocumentRule)
    1: NS_INTERFACE_MAP_END
    1: 
    1: #ifdef DEBUG
43120: /* virtual */ void
    1: nsCSSDocumentRule::List(FILE* out, PRInt32 aIndent) const
    1: {
    1:   for (PRInt32 indent = aIndent; --indent >= 0; ) fputs("  ", out);
    1: 
    1:   nsCAutoString str;
    1:   str.AssignLiteral("@-moz-document ");
    1:   for (URL *url = mURLs; url; url = url->next) {
    1:     switch (url->func) {
    1:       case eURL:
    1:         str.AppendLiteral("url(\"");
    1:         break;
    1:       case eURLPrefix:
    1:         str.AppendLiteral("url-prefix(\"");
    1:         break;
    1:       case eDomain:
    1:         str.AppendLiteral("domain(\"");
    1:         break;
    1:     }
    1:     nsCAutoString escapedURL(url->url);
    1:     escapedURL.ReplaceSubstring("\"", "\\\""); // escape quotes
    1:     str.Append(escapedURL);
    1:     str.AppendLiteral("\"), ");
    1:   }
    1:   str.Cut(str.Length() - 2, 1); // remove last ,
    1:   fputs(str.get(), out);
    1: 
43120:   nsCSSGroupRule::List(out, aIndent);
    1: }
    1: #endif
    1: 
47887: /* virtual */ PRInt32
47887: nsCSSDocumentRule::GetType() const
    1: {
47887:   return nsICSSRule::DOCUMENT_RULE;
    1: }
    1: 
50636: /* virtual */ already_AddRefed<nsICSSRule>
50636: nsCSSDocumentRule::Clone() const
    1: {
50636:   nsCOMPtr<nsICSSRule> clone = new nsCSSDocumentRule(*this);
50636:   return clone.forget();
    1: }
    1: 
    1: // nsIDOMCSSRule methods
    1: NS_IMETHODIMP
    1: nsCSSDocumentRule::GetType(PRUint16* aType)
    1: {
    1:   // XXX What should really happen here?
    1:   *aType = nsIDOMCSSRule::UNKNOWN_RULE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSDocumentRule::GetCssText(nsAString& aCssText)
    1: {
    1:   aCssText.AssignLiteral("@-moz-document ");
    1:   for (URL *url = mURLs; url; url = url->next) {
    1:     switch (url->func) {
    1:       case eURL:
25794:         aCssText.AppendLiteral("url(");
    1:         break;
    1:       case eURLPrefix:
25794:         aCssText.AppendLiteral("url-prefix(");
    1:         break;
    1:       case eDomain:
25794:         aCssText.AppendLiteral("domain(");
    1:         break;
    1:     }
25794:     nsStyleUtil::AppendEscapedCSSString(NS_ConvertUTF8toUTF16(url->url),
25794:                                         aCssText);
25794:     aCssText.AppendLiteral("), ");
    1:   }
    1:   aCssText.Cut(aCssText.Length() - 2, 1); // remove last ,
    1: 
    1:   return nsCSSGroupRule::AppendRulesToCssText(aCssText);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSDocumentRule::SetCssText(const nsAString& aCssText)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSDocumentRule::GetParentStyleSheet(nsIDOMCSSStyleSheet** aSheet)
    1: {
    1:   return nsCSSGroupRule::GetParentStyleSheet(aSheet);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSDocumentRule::GetParentRule(nsIDOMCSSRule** aParentRule)
    1: {
    1:   return nsCSSGroupRule::GetParentRule(aParentRule);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSDocumentRule::GetCssRules(nsIDOMCSSRuleList* *aRuleList)
    1: {
    1:   return nsCSSGroupRule::GetCssRules(aRuleList);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSDocumentRule::InsertRule(const nsAString & aRule, PRUint32 aIndex, PRUint32* _retval)
    1: {
    1:   return nsCSSGroupRule::InsertRule(aRule, aIndex, _retval);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCSSDocumentRule::DeleteRule(PRUint32 aIndex)
    1: {
    1:   return nsCSSGroupRule::DeleteRule(aIndex);
    1: }
    1: 
    1: // nsICSSGroupRule interface
    1: NS_IMETHODIMP_(PRBool)
16223: nsCSSDocumentRule::UseForPresentation(nsPresContext* aPresContext,
16223:                                       nsMediaQueryResultCacheKey& aKey)
    1: {
    1:   nsIURI *docURI = aPresContext->Document()->GetDocumentURI();
    1:   nsCAutoString docURISpec;
    1:   if (docURI)
    1:     docURI->GetSpec(docURISpec);
    1: 
    1:   for (URL *url = mURLs; url; url = url->next) {
    1:     switch (url->func) {
    1:       case eURL: {
    1:         if (docURISpec == url->url)
    1:           return PR_TRUE;
    1:       } break;
    1:       case eURLPrefix: {
    1:         if (StringBeginsWith(docURISpec, url->url))
    1:           return PR_TRUE;
    1:       } break;
    1:       case eDomain: {
    1:         nsCAutoString host;
    1:         if (docURI)
    1:           docURI->GetHost(host);
    1:         PRInt32 lenDiff = host.Length() - url->url.Length();
    1:         if (lenDiff == 0) {
    1:           if (host == url->url)
    1:             return PR_TRUE;
    1:         } else {
    1:           if (StringEndsWith(host, url->url) &&
    1:               host.CharAt(lenDiff - 1) == '.')
    1:             return PR_TRUE;
    1:         }
    1:       } break;
    1:     }
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
23837: nsCSSDocumentRule::URL::~URL()
23837: {
23837:   NS_CSS_DELETE_LIST_MEMBER(nsCSSDocumentRule::URL, this, next);
23837: }
    1: 
    1: // -------------------------------------------
63730: // NameSpaceRule
    1: //
63730: 
63730: namespace mozilla {
63730: namespace css {
63730: 
63730: NameSpaceRule::NameSpaceRule()
    1:   : nsCSSRule(),
    1:     mPrefix(nsnull),
    1:     mURLSpec()
    1: {
    1: }
    1: 
63730: NameSpaceRule::NameSpaceRule(const NameSpaceRule& aCopy)
    1:   : nsCSSRule(aCopy),
    1:     mPrefix(aCopy.mPrefix),
    1:     mURLSpec(aCopy.mURLSpec)
    1: {
    1: }
    1: 
63730: NameSpaceRule::~NameSpaceRule()
    1: {
    1: }
    1: 
63730: NS_IMPL_ADDREF(NameSpaceRule)
63730: NS_IMPL_RELEASE(NameSpaceRule)
    1: 
63730: // QueryInterface implementation for NameSpaceRule
63730: NS_INTERFACE_MAP_BEGIN(NameSpaceRule)
63731:   if (aIID.Equals(NS_GET_IID(css::NameSpaceRule))) {
63731:     *aInstancePtr = this;
63731:     NS_ADDREF_THIS();
63731:     return NS_OK;
63731:   }
63731:   else
    1:   NS_INTERFACE_MAP_ENTRY(nsICSSRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIStyleRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSRule)
63731:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsICSSRule)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CSSNameSpaceRule)
    1: NS_INTERFACE_MAP_END
    1: 
63730: IMPL_STYLE_RULE_INHERIT(NameSpaceRule, nsCSSRule)
    1: 
    1: #ifdef DEBUG
43120: /* virtual */ void
63730: NameSpaceRule::List(FILE* out, PRInt32 aIndent) const
    1: {
    1:   for (PRInt32 indent = aIndent; --indent >= 0; ) fputs("  ", out);
    1: 
    1:   nsAutoString  buffer;
    1: 
    1:   fputs("@namespace ", out);
    1: 
    1:   if (mPrefix) {
    1:     mPrefix->ToString(buffer);
    1:     fputs(NS_LossyConvertUTF16toASCII(buffer).get(), out);
    1:     fputs(" ", out);
    1:   }
    1: 
    1:   fputs("url(", out);
    1:   fputs(NS_LossyConvertUTF16toASCII(mURLSpec).get(), out);
    1:   fputs(")\n", out);
    1: }
    1: #endif
    1: 
47887: /* virtual */ PRInt32
63730: NameSpaceRule::GetType() const
    1: {
47887:   return nsICSSRule::NAMESPACE_RULE;
    1: }
    1: 
50636: /* virtual */ already_AddRefed<nsICSSRule>
63730: NameSpaceRule::Clone() const
    1: {
63730:   nsCOMPtr<nsICSSRule> clone = new NameSpaceRule(*this);
50636:   return clone.forget();
    1: }
    1: 
    1: NS_IMETHODIMP
63730: NameSpaceRule::GetType(PRUint16* aType)
    1: {
    1:   // XXX What should really happen here?
    1:   *aType = nsIDOMCSSRule::UNKNOWN_RULE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
63730: NameSpaceRule::GetCssText(nsAString& aCssText)
    1: {
    1:   aCssText.AssignLiteral("@namespace ");
    1:   if (mPrefix) {
39101:     aCssText.Append(nsDependentAtomString(mPrefix) + NS_LITERAL_STRING(" "));
    1:   }
    1:   aCssText.AppendLiteral("url(");
25794:   nsStyleUtil::AppendEscapedCSSString(mURLSpec, aCssText);
    1:   aCssText.Append(NS_LITERAL_STRING(");"));
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
63730: NameSpaceRule::SetCssText(const nsAString& aCssText)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
63730: NameSpaceRule::GetParentStyleSheet(nsIDOMCSSStyleSheet** aSheet)
    1: {
42968:   NS_IF_ADDREF(*aSheet = mSheet);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
63730: NameSpaceRule::GetParentRule(nsIDOMCSSRule** aParentRule)
    1: {
    1:   if (mParentRule) {
    1:     return mParentRule->GetDOMRule(aParentRule);
    1:   }
    1:   *aParentRule = nsnull;
    1:   return NS_OK;
    1: }
16545: 
63730: } // namespace css
63730: } // namespace mozilla
63730: 
63730: // Must be outside namespace
63730: DOMCI_DATA(CSSNameSpaceRule, css::NameSpaceRule)
63730: 
63730: nsresult
63731: NS_NewCSSNameSpaceRule(css::NameSpaceRule** aInstancePtrResult,
63730:                        nsIAtom* aPrefix, const nsString& aURLSpec)
63730: {
63730:   if (! aInstancePtrResult) {
63730:     return NS_ERROR_NULL_POINTER;
63730:   }
63730: 
63730:   css::NameSpaceRule* it = new css::NameSpaceRule();
63730: 
63730:   if (!it) {
63730:     return NS_ERROR_OUT_OF_MEMORY;
63730:   }
63730: 
63730:   it->SetPrefix(aPrefix);
63730:   it->SetURLSpec(aURLSpec);
63730:   NS_ADDREF(*aInstancePtrResult = it);
63730:   return NS_OK;
63730: }
63730: 
16545: // -------------------------------------------
16545: // nsCSSFontFaceStyleDecl and related routines
16545: //
16545: 
16545: // A src: descriptor is represented as an array value; each entry in
16545: // the array can be eCSSUnit_URL, eCSSUnit_Local_Font, or
16545: // eCSSUnit_Font_Format.  Blocks of eCSSUnit_Font_Format may appear
16545: // only after one of the first two.  (css3-fonts only contemplates
16545: // annotating URLs with formats, but we handle the general case.)
16545: static void
25952: AppendSerializedFontSrc(const nsCSSValue& src, nsAString & aResult NS_OUTPARAM)
16545: {
25952:   NS_PRECONDITION(src.GetUnit() == eCSSUnit_Array,
16545:                   "improper value unit for src:");
16545: 
16545:   const nsCSSValue::Array& sources = *src.GetArrayValue();
46243:   size_t i = 0;
16545: 
16545:   while (i < sources.Count()) {
16545:     nsAutoString formats;
16545: 
16545:     if (sources[i].GetUnit() == eCSSUnit_URL) {
25793:       aResult.AppendLiteral("url(");
16545:       nsDependentString url(sources[i].GetOriginalURLValue());
25793:       nsStyleUtil::AppendEscapedCSSString(url, aResult);
25793:       aResult.AppendLiteral(")");
16545:     } else if (sources[i].GetUnit() == eCSSUnit_Local_Font) {
25793:       aResult.AppendLiteral("local(");
16545:       nsDependentString local(sources[i].GetStringBufferValue());
25793:       nsStyleUtil::AppendEscapedCSSString(local, aResult);
25793:       aResult.AppendLiteral(")");
16545:     } else {
16545:       NS_NOTREACHED("entry in src: descriptor with improper unit");
16545:       i++;
16545:       continue;
16545:     }
16545: 
16545:     i++;
16545:     formats.Truncate();
16545:     while (i < sources.Count() &&
16545:            sources[i].GetUnit() == eCSSUnit_Font_Format) {
16545:       formats.Append('"');
16545:       formats.Append(sources[i].GetStringBufferValue());
16545:       formats.AppendLiteral("\", ");
16545:       i++;
16545:     }
16545:     if (formats.Length() > 0) {
16545:       formats.Truncate(formats.Length() - 2); // remove the last comma
16545:       aResult.AppendLiteral(" format(");
16545:       aResult.Append(formats);
16545:       aResult.Append(')');
16545:     }
16545:     aResult.AppendLiteral(", ");
16545:   }
16545:   aResult.Truncate(aResult.Length() - 2); // remove the last comma-space
16545: }
16545: 
31706: // print all characters with at least four hex digits
31706: static void
31706: AppendSerializedUnicodePoint(PRUint32 aCode, nsACString &aBuf NS_OUTPARAM)
31706: {
31706:   aBuf.Append(nsPrintfCString("%04X", aCode));
31706: }
31706: 
31706: // A unicode-range: descriptor is represented as an array of integers,
31706: // to be interpreted as a sequence of pairs: min max min max ...
31706: // It is in source order.  (Possibly it should be sorted and overlaps
31706: // consolidated, but right now we don't do that.)
31706: static void
31706: AppendSerializedUnicodeRange(nsCSSValue const & aValue,
31706:                              nsAString & aResult NS_OUTPARAM)
31706: {
31706:   NS_PRECONDITION(aValue.GetUnit() == eCSSUnit_Null ||
31706:                   aValue.GetUnit() == eCSSUnit_Array,
31706:                   "improper value unit for unicode-range:");
31706:   aResult.Truncate();
31706:   if (aValue.GetUnit() != eCSSUnit_Array)
31706:     return;
31706: 
31706:   nsCSSValue::Array const & sources = *aValue.GetArrayValue();
31706:   nsCAutoString buf;
31706: 
31706:   NS_ABORT_IF_FALSE(sources.Count() % 2 == 0,
31706:                     "odd number of entries in a unicode-range: array");
31706: 
31706:   for (PRUint32 i = 0; i < sources.Count(); i += 2) {
31706:     PRUint32 min = sources[i].GetIntValue();
31706:     PRUint32 max = sources[i+1].GetIntValue();
31706: 
31706:     // We don't try to replicate the U+XX?? notation.
31706:     buf.AppendLiteral("U+");
31706:     AppendSerializedUnicodePoint(min, buf);
31706: 
31706:     if (min != max) {
31706:       buf.Append('-');
31706:       AppendSerializedUnicodePoint(max, buf);
31706:     }
31706:     buf.AppendLiteral(", ");
31706:   }
31706:   buf.Truncate(buf.Length() - 2); // remove the last comma-space
31706:   CopyASCIItoUTF16(buf, aResult);
31706: }
31706: 
16545: // Mapping from nsCSSFontDesc codes to nsCSSFontFaceStyleDecl fields.
16545: // Keep this in sync with enum nsCSSFontDesc in nsCSSProperty.h.
16545: nsCSSValue nsCSSFontFaceStyleDecl::* const
16545: nsCSSFontFaceStyleDecl::Fields[] = {
16545:     &nsCSSFontFaceStyleDecl::mFamily,
16545:     &nsCSSFontFaceStyleDecl::mStyle,
16545:     &nsCSSFontFaceStyleDecl::mWeight,
16545:     &nsCSSFontFaceStyleDecl::mStretch,
16545:     &nsCSSFontFaceStyleDecl::mSrc,
47359:     &nsCSSFontFaceStyleDecl::mUnicodeRange,
47359:     &nsCSSFontFaceStyleDecl::mFontFeatureSettings,
47359:     &nsCSSFontFaceStyleDecl::mFontLanguageOverride
16545: };
16545: 
40490: DOMCI_DATA(CSSFontFaceStyleDecl, nsCSSFontFaceStyleDecl)
40490: 
16545: // QueryInterface implementation for nsCSSFontFaceStyleDecl
16545: NS_INTERFACE_MAP_BEGIN(nsCSSFontFaceStyleDecl)
16545:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSStyleDeclaration)
16545:   NS_INTERFACE_MAP_ENTRY(nsISupports)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CSSFontFaceStyleDecl)
16545: NS_INTERFACE_MAP_END
16545: 
16545: NS_IMPL_ADDREF_USING_AGGREGATOR(nsCSSFontFaceStyleDecl, ContainingRule())
16545: NS_IMPL_RELEASE_USING_AGGREGATOR(nsCSSFontFaceStyleDecl, ContainingRule())
16545: 
16545: // helper for string GetPropertyValue and RemovePropertyValue
16545: nsresult
16545: nsCSSFontFaceStyleDecl::GetPropertyValue(nsCSSFontDesc aFontDescID,
16545:                                          nsAString & aResult NS_OUTPARAM) const
16545: {
16545:   NS_ENSURE_ARG_RANGE(aFontDescID, eCSSFontDesc_UNKNOWN,
16545:                       eCSSFontDesc_COUNT - 1);
16545: 
16545:   aResult.Truncate();
16545:   if (aFontDescID == eCSSFontDesc_UNKNOWN)
16545:     return NS_OK;
16545: 
16545:   const nsCSSValue& val = this->*nsCSSFontFaceStyleDecl::Fields[aFontDescID];
16545: 
25952:   if (val.GetUnit() == eCSSUnit_Null) {
25952:     // Avoid having to check no-value in the Family and Src cases below.
25952:     return NS_OK;
25952:   }
25952: 
16545:   switch (aFontDescID) {
16545:   case eCSSFontDesc_Family: {
48854:       // we don't use nsCSSValue::AppendToString here because it doesn't
16545:       // canonicalize the way we want, and anyway it's overkill when
16545:       // we know we have eCSSUnit_String
25796:       NS_ASSERTION(val.GetUnit() == eCSSUnit_String, "unexpected unit");
16545:       nsDependentString family(val.GetStringBufferValue());
25793:       nsStyleUtil::AppendEscapedCSSString(family, aResult);
16545:       return NS_OK;
16545:     }
16545: 
16545:   case eCSSFontDesc_Style:
48854:     val.AppendToString(eCSSProperty_font_style, aResult);
16545:     return NS_OK;
16545: 
16545:   case eCSSFontDesc_Weight:
48854:     val.AppendToString(eCSSProperty_font_weight, aResult);
16545:     return NS_OK;
16545: 
16545:   case eCSSFontDesc_Stretch:
48854:     val.AppendToString(eCSSProperty_font_stretch, aResult);
16545:     return NS_OK;
16545: 
51268:   case eCSSFontDesc_FontFeatureSettings:
51268:     val.AppendToString(eCSSProperty_font_feature_settings, aResult);
51268:     return NS_OK;
51268: 
51268:   case eCSSFontDesc_FontLanguageOverride:
51268:     val.AppendToString(eCSSProperty_font_language_override, aResult);
51268:     return NS_OK;
51268: 
16545:   case eCSSFontDesc_Src:
25952:     AppendSerializedFontSrc(val, aResult);
16545:     return NS_OK;
16545: 
16545:   case eCSSFontDesc_UnicodeRange:
31706:     AppendSerializedUnicodeRange(val, aResult);
16545:     return NS_OK;
16545: 
16545:   case eCSSFontDesc_UNKNOWN:
16545:   case eCSSFontDesc_COUNT:
16545:     ;
16545:   }
16545:   NS_NOTREACHED("nsCSSFontFaceStyleDecl::GetPropertyValue: "
16545:                 "out-of-range value got to the switch");
16545:   return NS_ERROR_INVALID_ARG;
16545: }
16545: 
16545: 
16545: // attribute DOMString cssText;
16545: NS_IMETHODIMP
16545: nsCSSFontFaceStyleDecl::GetCssText(nsAString & aCssText)
16545: {
16545:   nsAutoString descStr;
16545: 
16545:   aCssText.Truncate();
16545:   for (nsCSSFontDesc id = nsCSSFontDesc(eCSSFontDesc_UNKNOWN + 1);
16545:        id < eCSSFontDesc_COUNT;
16545:        id = nsCSSFontDesc(id + 1)) {
16545:     if ((this->*nsCSSFontFaceStyleDecl::Fields[id]).GetUnit()
16545:           != eCSSUnit_Null &&
16545:         NS_SUCCEEDED(GetPropertyValue(id, descStr))) {
16545:       NS_ASSERTION(descStr.Length() > 0,
16545:                    "GetCssText: non-null unit, empty property value");
16545:       aCssText.AppendLiteral("  ");
16545:       aCssText.AppendASCII(nsCSSProps::GetStringValue(id).get());
16545:       aCssText.AppendLiteral(": ");
16545:       aCssText.Append(descStr);
16545:       aCssText.AppendLiteral(";\n");
16545:     }
16545:   }
16545:   return NS_OK;
16545: }
16545: 
16545: NS_IMETHODIMP
16545: nsCSSFontFaceStyleDecl::SetCssText(const nsAString & aCssText)
16545: {
16545:   return NS_ERROR_NOT_IMPLEMENTED; // bug 443978
16545: }
16545: 
16545: // DOMString getPropertyValue (in DOMString propertyName);
16545: NS_IMETHODIMP
16545: nsCSSFontFaceStyleDecl::GetPropertyValue(const nsAString & propertyName,
16545:                                          nsAString & aResult NS_OUTPARAM)
16545: {
16545:   return GetPropertyValue(nsCSSProps::LookupFontDesc(propertyName), aResult);
16545: }
16545: 
16545: // nsIDOMCSSValue getPropertyCSSValue (in DOMString propertyName);
16545: NS_IMETHODIMP
16545: nsCSSFontFaceStyleDecl::GetPropertyCSSValue(const nsAString & propertyName,
16545:                                             nsIDOMCSSValue **aResult NS_OUTPARAM)
16545: {
16545:   // ??? nsDOMCSSDeclaration returns null/NS_OK, but that seems wrong.
16545:   return NS_ERROR_NOT_IMPLEMENTED;
16545: }
16545: 
16545: // DOMString removeProperty (in DOMString propertyName) raises (DOMException);
16545: NS_IMETHODIMP
16545: nsCSSFontFaceStyleDecl::RemoveProperty(const nsAString & propertyName,
16545:                                        nsAString & aResult NS_OUTPARAM)
16545: {
16545:   nsCSSFontDesc descID = nsCSSProps::LookupFontDesc(propertyName);
16545:   NS_ASSERTION(descID >= eCSSFontDesc_UNKNOWN &&
16545:                descID < eCSSFontDesc_COUNT,
16545:                "LookupFontDesc returned value out of range");
16545: 
16545:   if (descID == eCSSFontDesc_UNKNOWN) {
16545:     aResult.Truncate();
16545:   } else {
16545:     nsresult rv = GetPropertyValue(descID, aResult);
16545:     NS_ENSURE_SUCCESS(rv, rv);
16545:     (this->*nsCSSFontFaceStyleDecl::Fields[descID]).Reset();
16545:   }
16545:   return NS_OK;
16545: }
16545: 
16545: // DOMString getPropertyPriority (in DOMString propertyName);
16545: NS_IMETHODIMP
16545: nsCSSFontFaceStyleDecl::GetPropertyPriority(const nsAString & propertyName,
16545:                                             nsAString & aResult NS_OUTPARAM)
16545: {
16545:   // font descriptors do not have priorities at present
16545:   aResult.Truncate();
16545:   return NS_OK;
16545: }
16545: 
16545: // void setProperty (in DOMString propertyName, in DOMString value,
16545: //                   in DOMString priority)  raises (DOMException);
16545: NS_IMETHODIMP
16545: nsCSSFontFaceStyleDecl::SetProperty(const nsAString & propertyName,
16545:                                     const nsAString & value,
16545:                                     const nsAString & priority)
16545: {
16545:   return NS_ERROR_NOT_IMPLEMENTED; // bug 443978
16545: }
16545: 
16545: // readonly attribute unsigned long length;
16545: NS_IMETHODIMP
16545: nsCSSFontFaceStyleDecl::GetLength(PRUint32 *aLength)
16545: {
16545:   PRUint32 len = 0;
16545:   for (nsCSSFontDesc id = nsCSSFontDesc(eCSSFontDesc_UNKNOWN + 1);
16545:        id < eCSSFontDesc_COUNT;
16545:        id = nsCSSFontDesc(id + 1))
16545:     if ((this->*nsCSSFontFaceStyleDecl::Fields[id]).GetUnit() != eCSSUnit_Null)
16545:       len++;
16545: 
16545:   *aLength = len;
16545:   return NS_OK;
16545: }
16545: 
16545: // DOMString item (in unsigned long index);
16545: NS_IMETHODIMP
16545: nsCSSFontFaceStyleDecl::Item(PRUint32 index, nsAString & aResult NS_OUTPARAM)
16545:  {
16545:   PRInt32 nset = -1;
16545:   for (nsCSSFontDesc id = nsCSSFontDesc(eCSSFontDesc_UNKNOWN + 1);
16545:        id < eCSSFontDesc_COUNT;
16545:        id = nsCSSFontDesc(id + 1)) {
16545:     if ((this->*nsCSSFontFaceStyleDecl::Fields[id]).GetUnit()
16545:         != eCSSUnit_Null) {
16545:       nset++;
16545:       if (nset == PRInt32(index)) {
16545:         aResult.AssignASCII(nsCSSProps::GetStringValue(id).get());
16545:         return NS_OK;
16545:       }
16545:     }
16545:   }
16545:   aResult.Truncate();
16545:   return NS_OK;
16545: }
16545: 
16545: // readonly attribute nsIDOMCSSRule parentRule;
16545: NS_IMETHODIMP
16545: nsCSSFontFaceStyleDecl::GetParentRule(nsIDOMCSSRule** aParentRule)
16545: {
16545:   return ContainingRule()->GetDOMRule(aParentRule);
16545: }
16545: 
16545: 
16545: // -------------------------------------------
16545: // nsCSSFontFaceRule
16545: // 
16545: 
50636: /* virtual */ already_AddRefed<nsICSSRule>
50636: nsCSSFontFaceRule::Clone() const
16545: {
50636:   nsCOMPtr<nsICSSRule> clone = new nsCSSFontFaceRule(*this);
50636:   return clone.forget();
16545: }
16545: 
54328: NS_IMPL_ADDREF(nsCSSFontFaceRule)
54328: NS_IMPL_RELEASE(nsCSSFontFaceRule)
16545: 
40490: DOMCI_DATA(CSSFontFaceRule, nsCSSFontFaceRule)
40490: 
16545: // QueryInterface implementation for nsCSSFontFaceRule
16545: NS_INTERFACE_MAP_BEGIN(nsCSSFontFaceRule)
16545:   NS_INTERFACE_MAP_ENTRY(nsICSSRule)
16545:   NS_INTERFACE_MAP_ENTRY(nsIStyleRule)
16545:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSFontFaceRule)
16545:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSRule)
16545:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsICSSRule)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CSSFontFaceRule)
16545: NS_INTERFACE_MAP_END
16545: 
16545: IMPL_STYLE_RULE_INHERIT(nsCSSFontFaceRule, nsCSSRule)
16545: 
16545: #ifdef DEBUG
43120: void
16545: nsCSSFontFaceRule::List(FILE* out, PRInt32 aIndent) const
16545: {
16545:   nsCString baseInd, descInd;
16545:   for (PRInt32 indent = aIndent; --indent >= 0; ) {
16545:     baseInd.AppendLiteral("  ");
16545:     descInd.AppendLiteral("  ");
16545:   }
16545:   descInd.AppendLiteral("  ");
16545: 
16545:   nsString descStr;
16545: 
16545:   fprintf(out, "%s@font-face {\n", baseInd.get());
16545:   for (nsCSSFontDesc id = nsCSSFontDesc(eCSSFontDesc_UNKNOWN + 1);
16545:        id < eCSSFontDesc_COUNT;
16545:        id = nsCSSFontDesc(id + 1))
16545:     if ((mDecl.*nsCSSFontFaceStyleDecl::Fields[id]).GetUnit()
16545:         != eCSSUnit_Null) {
16545:       if (NS_FAILED(mDecl.GetPropertyValue(id, descStr)))
16545:         descStr.AssignLiteral("#<serialization error>");
16545:       else if (descStr.Length() == 0)
16545:         descStr.AssignLiteral("#<serialization missing>");
16545:       fprintf(out, "%s%s: %s\n",
16545:               descInd.get(), nsCSSProps::GetStringValue(id).get(),
16545:               NS_ConvertUTF16toUTF8(descStr).get());
16545:     }
16545:   fprintf(out, "%s}\n", baseInd.get());
16545: }
16545: #endif
16545: 
47887: /* virtual */ PRInt32
47887: nsCSSFontFaceRule::GetType() const
16545: {
47887:   return nsICSSRule::FONT_FACE_RULE;
16545: }
16545: 
16545: NS_IMETHODIMP
16545: nsCSSFontFaceRule::GetType(PRUint16* aType)
16545: {
16545:   *aType = nsIDOMCSSRule::FONT_FACE_RULE;
16545:   return NS_OK;
16545: }
16545: 
16545: NS_IMETHODIMP
16545: nsCSSFontFaceRule::GetCssText(nsAString& aCssText)
16545: {
16545:   nsAutoString propText;
16545:   mDecl.GetCssText(propText);
16545: 
16545:   aCssText.AssignLiteral("@font-face {\n");
16545:   aCssText.Append(propText);
16545:   aCssText.Append('}');
16545:   return NS_OK;
16545: }
16545: 
16545: NS_IMETHODIMP
16545: nsCSSFontFaceRule::SetCssText(const nsAString& aCssText)
16545: {
16545:   return NS_ERROR_NOT_IMPLEMENTED; // bug 443978
16545: }
16545: 
16545: NS_IMETHODIMP
16545: nsCSSFontFaceRule::GetParentStyleSheet(nsIDOMCSSStyleSheet** aSheet)
16545: {
42968:   NS_IF_ADDREF(*aSheet = mSheet);
16545:   return NS_OK;
16545: }
16545: 
16545: NS_IMETHODIMP
16545: nsCSSFontFaceRule::GetParentRule(nsIDOMCSSRule** aParentRule)
16545: {
16545:   if (mParentRule) {
16545:     return mParentRule->GetDOMRule(aParentRule);
16545:   }
16545:   *aParentRule = nsnull;
16545:   return NS_OK;
16545: }
16545: 
16545: NS_IMETHODIMP
16545: nsCSSFontFaceRule::GetStyle(nsIDOMCSSStyleDeclaration** aStyle)
16545: {
47889:   NS_IF_ADDREF(*aStyle = &mDecl);
47889:   return NS_OK;
16545: }
16545: 
16545: // Arguably these should forward to nsCSSFontFaceStyleDecl methods.
16545: void
16545: nsCSSFontFaceRule::SetDesc(nsCSSFontDesc aDescID, nsCSSValue const & aValue)
16545: {
16545:   NS_PRECONDITION(aDescID > eCSSFontDesc_UNKNOWN &&
16545:                   aDescID < eCSSFontDesc_COUNT,
16545:                   "aDescID out of range in nsCSSFontFaceRule::SetDesc");
16545: 
16545:   mDecl.*nsCSSFontFaceStyleDecl::Fields[aDescID] = aValue;
16545: }
16545: 
16545: void
16545: nsCSSFontFaceRule::GetDesc(nsCSSFontDesc aDescID, nsCSSValue & aValue)
16545: {
16545:   NS_PRECONDITION(aDescID > eCSSFontDesc_UNKNOWN &&
16545:                   aDescID < eCSSFontDesc_COUNT,
16545:                   "aDescID out of range in nsCSSFontFaceRule::GetDesc");
16545: 
16545:   aValue = mDecl.*nsCSSFontFaceStyleDecl::Fields[aDescID];
16545: }
